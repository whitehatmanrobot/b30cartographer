 ( thin wrapper for ATQ call and managing references)

    Arguments:

      pvBuffer      pointer to buffer where to read in the contents

      cbSize        size of the buffer

    Returns:

      TRUE on success and FALSE on a failure.

--*/
//  VIRTUAL
BOOL CLIENT_CONNECTION::ReadFile(
            IN LPVOID pBuffer,
            IN DWORD  cbSize /* = MAX_READ_BUFF_SIZE */
            )
{
    _ASSERT(pBuffer != NULL);
    _ASSERT(cbSize > 0);

    ZeroMemory(&m_Overlapped, sizeof(OVERLAPPED));

    return  AtqReadFile(m_pAtqContext,      // Atq context
                        pBuffer,            // Buffer
                        cbSize,             // BytesToRead
                        &m_Overlapped) ;
}


/*++

    Writes contents from given buffer using ATQ.
     ( thin wrapper for ATQ call and managing references)

    Arguments:

      pvBuffer      pointer to buffer containing contents for write

      cbSize        size of the buffer

    Returns:

      TRUE on success and FALSE on a failure.

--*/
//  VIRTUAL
BOOL CLIENT_CONNECTION::WriteFile( IN LPVOID pBuffer, IN DWORD cbSize )
{
    BOOL    fReturn = TRUE;
    int     BytesAlreadySent = 0;
    DWORD   BytesSent;
    DWORD   dwError = NO_ERROR;
    DWORD   cTimesBlocked = 0;
    DWORD   dwSleepTime = 1000;

    _ASSERT(pBuffer != NULL);

    for (BytesSent = 0; BytesSent < cbSize; BytesSent += BytesAlreadySent)
    {
        BytesAlreadySent = send(m_sClient,
                                (const char FAR *) pBuffer + BytesSent,
                                (int) (cbSize - BytesSent),
                                0);
        if (BytesAlreadySent == SOCKET_ERROR)
        {
            //The above send will fail with WSAEWOULDBLOCK when
            //the TCP buffer is full...  this can easily happen for blob
            //protocol sinks.  The correct thing to do is rely on memory 
            //instead of TCP buffers to store pending sends, but the 
            //low impact work-around is to sleep after we would block
            dwError = GetLastError();
            if ((WSAEWOULDBLOCK == dwError) && (cTimesBlocked < 500))
            {
                SetLastError(NO_ERROR);
                cTimesBlocked++;
                BytesAlreadySent = 0;
                Sleep(dwSleepTime);
                dwSleepTime += dwSleepTime;
                continue;
            }
            fReturn = FALSE;
            break;
        }
    }
    return fReturn;
}

BOOL CLIENT_CONNECTION::WriteSocket( IN SOCKET Sock, IN LPVOID pBuffer, IN DWORD cbSize )
{
    BOOL    fReturn = TRUE;
    int     BytesAlreadySent = 0;
    DWORD   BytesSent;

    _ASSERT(pBuffer != NULL);

    for (BytesSent = 0; BytesSent < cbSize; BytesSent += BytesAlreadySent)
    {
        BytesAlreadySent = send(Sock,
                                (const char FAR *) pBuffer + BytesSent,
                                (int) (cbSize - BytesSent),
                                0);
        if (BytesAlreadySent == SOCKET_ERROR)
        {
            fReturn = FALSE;
            break;
        }
    }
    return fReturn;
}



/*++

    Writes contents from given buffer using ATQ.
     (thin wrapper for ATQ call and managing references)

    Arguments:

      Pov      pointer to OVERLAPPED structure describing the write

    Returns:

      TRUE on success and FALSE on a failure.

--*/
//  VIRTUAL
BOOL CLIENT_CONNECTION::WriteFile(
    IN  LPVOID      lpvBuffer,
    IN  DWORD       cbSize,
    IN  OVERLAPPED  *lpo)
{
    BOOL  fReturn = TRUE;

    _ASSERT(lpo != NULL);
    _ASSERT(lpvBuffer != NULL);
    _ASSERT(cbSize != 0);

    fReturn = AtqWriteFile(m_pAtqContext, lpvBuffer, cbSize, lpo);
    return fReturn;
}


/*++

    Transmits contents of the file ( of specified size)
     using the ATQ and client socket.
     ( thin wrapper for ATQ call and managing references)

    Arguments:

      hFile         handle for file to be transmitted

      liSize        large integer containing the size of file

      lpTransmitBuffers
        buffers containing the head and tail buffers that
            need to be transmitted along with the file.

    Returns:

      TRUE on success and FALSE on a failure.

--*/

BOOL CLIENT_CONNECTION::TransmitFile(
    IN  HANDLE                  hFile,
    IN  LARGE_INTEGER           &liSize,
    IN  LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers
    )
{
    _ASSERT(hFile != INVALID_HANDLE_VALUE);
    _ASSERT(liSize.QuadPart > 0);

    return  AtqTransmitFile(
                        m_pAtqContext,              // Atq context
                        hFile,                      // file data comes from
                        (DWORD) liSize.LowPart,                     // Bytes To Send
                        lpTransmitBuffers,          // header/tail buffers
                        0                           // Flags
                        );
}


//+------------------------------------------------------------
//
// Function: CLIENT_CONNECTION::PostCompletionStatus
//
// Synopsis: Wrapper around atq for posting completion status
//
// Arguments:
//  dwBytes: The number of bytes to indicate in the completion status
//
// Returns:
//  TRUE: Success
//  FALSE: Failure
//
// History:
// jstamerj 1998/11/03 20:16:17: Created.
//
//-------------------------------------------------------------
BOOL CLIENT_CONNECTION::PostCompletionStatus(
    IN  DWORD   dwBytes)
{
    return AtqPostCompletionStatus(
        m_pAtqContext,
        dwBytes);
}


/*++

    Starts up a session for new client.
    Adds the client socket to the ATQ completion port and gets an ATQ context.
    Then prepares  receive buffer and starts off a receive request from client.
      ( Also moves the client connection to CcsGettingRequest state)

    Parameters:
      pvInitial   pointer to void buffer containing the initial data
      cbWritten   count of bytes in the buffer

    Returns:

        TRUE on success and FALSE if there is any error.
--*/

//  VIRTUAL
BOOL CLIENT_CONNECTION::StartSession( void)
{
  return TRUE;
}


/*++

    Receive full Request from the client.
    If the entire request is received,
     *pfFullRequestRecvd will be set to TRUE and
     the request will be parsed.

    Arguments:

        cbWritten              count of bytes written in last IO operation.
        pfFullRequestRecvd     pointer to boolean, which on successful return
                                indicates if the full request was received.

    Returns:

        TRUE on success and
        FALSE if there is any error ( to abort this connection).

--*/

BOOL CLIENT_CONNECTION::ReceiveRequest(IN DWORD cbWritten, OUT LPBOOL pfFullRequestRecvd)
{
   return ( TRUE);
}

/*++

   Description:

       Initiates a disconnect operation for current connection.
       If already shutdown, this function returns doing nothing.
       Optionally if there is any error message to be sent, they may be sent

   Arguments:

      dwErrorCode
         error code for server errors if any ( Win 32 error code)
        If dwErrorCode != NO_ERROR, then there is a system level error code.
         by the REQUEST object. But the disconnection occurs immediately; Hence
         the REQUEST object should send synchronous error messages.

   Returns:
       None

--*/
VOID CLIENT_CONNECTION::DisconnectClient(IN DWORD dwErrorCode)
{
   SOCKET  hSocket;

   hSocket = (SOCKET)InterlockedExchangePointer( (PVOID *)&m_sClient, (PVOID) INVALID_SOCKET );
   if ( hSocket != INVALID_SOCKET )
   {
       if ( QueryAtqContext() != NULL )
       {
            AtqCloseSocket(QueryAtqContext() , (dwErrorCode == NO_ERROR));
       }
       else
       {
            ShutAndCloseSocket( m_sClient );
       }
   }
}



/*++

   Description:

       returns the client user name
       VIRTUAL function so apps can override its return value

   Arguments:

       void

   Returns:
       returns ptr to user name

--*/
LPCTSTR CLIENT_CONNECTION::QueryClientUserName( VOID )
{
    return   m_pchLocalHostName;
}



//
// Private Functions
//


# if DBG

//  VIRTUAL
VOID CLIENT_CONNECTION::Print( VOID) const
{


    return;

} // ICLIENT_CONNECTION::Print()


# endif // DBG


/*++

    Description:

       Performs a hard close on the socket using shutdown before close.

    Arguments:

       sock    socket to be closed

    Returns:

      0  if no errors  or
      socket specific error code

--*/

INT ShutAndCloseSocket( IN SOCKET sock)
{

    INT  serr = 0;

    //
    // Shut the socket. ( Assumes this to be a TCP socket.)
    //  Prevent future sends from occuring. hence 2nd param is "1"
    //

    if( sock != INVALID_SOCKET )
    {
      if ( shutdown( sock, 1) == SOCKET_ERROR)
        serr = WSAGetLastError();

      closesocket( sock);
    }

    return ( serr);

} // ShutAndCloseSocket()



/*++
    This function canonicalizes the path, taking into account the current
    user's current directory value.

    Arguments:
        pszDest   string that will on return contain the complete
                    canonicalized path. This buffer will be of size
                    specified in *lpdwSize.

        lpdwSize  Contains the size of the buffer pszDest on entry.
                On return contains the number of bytes written
                into the buffer or number of bytes required.

        pszSearchPath  pointer to string containing the path to be converted.
                    IF NULL, use the current directory only

    Returns:

        Win32 Error Code - NO_ERROR on success

    MuraliK   24-Apr-1995   Created.

--*/
BOOL
ResolveVirtualRoot(
        OUT CHAR *      pszDest,
    IN  OUT LPDWORD     lpdwSize,
    IN  OUT CHAR *      pszSearchPath,
        OUT HANDLE *    phToken /* = NULL */
    )
{
    TraceFunctEnter("ResolveVirtualRoot");

    _ASSERT(pszDest != NULL);
    _ASSERT(lpdwSize != NULL);
    _ASSERT(pszSearchPath != NULL);
    //
    // Now we have the complete symbolic path to the target file.
    //  Translate it into the absolute path
    //

#if 0
    if (!TsLookupVirtualRoot(g_pTsvcInfo->GetTsvcCache(),   // TSvcCache
                                pszSearchPath,              // pszRoot
                                pszDest,                    // pszDirectory
                                lpdwSize,                   // lpcbSize
                                NULL,                       // lpdwAccessMask
                                NULL,                       // pcchDirRoot
                                NULL,                       // pcchVroot
                                phToken,                    // phImpersonationToken
                                NULL,                       // pszAddress
                                NULL                        // lpdwFileSystem
                                ))
    {
        ErrorTrace(NULL, "TsLookupVirtualRoot failed looking for %s: %d", pszSearchPath, GetLastError());
        TraceFunctLeave();
        return FALSE;
    }
#endif

    TraceFunctLeave();
    return TRUE;
}



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\globals.cxx ===
/*++

   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        globals.cxx

   Abstract:

        This module contains global variable definitions shared by the
        various SMTP Service components.

   Author:
        KeithMo     07-Mar-1993 Created.

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "smtpcli.hxx"
#include "smtpout.hxx"
#include "dropdir.hxx"

#include <isplat.h>

#include "mailmsg_i.c"
#include "mailmsgi_i.c"
#include "aqueue_i.c"

#include "aqstore.hxx"

#include <dnsapi.h>
//
//  Version string for this server
//

#define MSSMTP_VERSION_STR_IIS        "Microsoft-IIS/K2"
#define MSSMTP_VERSION_STR_W95        "Microsoft-PWS-95/K2"
#define MSSMTP_VERSION_STR_NTW        "Microsoft-PWS/K2"

//
// Set to the largest of the three
//

#define MSSMTP_VERSION_STR_MAX        MSSMTP_VERSION_STR_W95

//
// Creates the version string
//

#define MAKE_VERSION_STRING( _s )   ("Server: " ##_s "\r\n")

//
//  MIME version we say we support
//

#define SMTP_MIME_VERSION_STR       "MIME-version: 1.0"

#define SMTP_TEMP_DIR_NAME          " "

//
// Server type string
//

CHAR g_szServerType[ sizeof(MSSMTP_VERSION_STR_MAX)];
DWORD g_cbServerType = 0;
CHAR szServerVersion[sizeof(MAKE_VERSION_STRING(MSSMTP_VERSION_STR_MAX))];
DWORD cbServerVersionString = 0;

DWORD g_ProductType = 5;
PLATFORM_TYPE g_SmtpPlatformType = PtNtServer;

//computer name
CHAR g_ComputerName[MAX_PATH + 1];
DWORD g_ComputerNameLength;

// number of procs on system for thread mgmt.
DWORD g_NumProcessors = 1;

CHAR g_VersionString[128];
CHAR g_Password[MAX_PATH + 1];
CHAR g_UserName[MAX_PATH + 1];
CHAR g_DomainName[MAX_PATH + 1];

static char g_BoundaryChars [] = "0123456789abcdefghijklmnopqrstuvwxyz"
                                "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

//Max Objects

DWORD g_cMaxAddressObjects;
DWORD g_cMaxPropertyBagObjects;
DWORD g_cMaxMailObjects;
DWORD g_cMaxEtrnObjects;
DWORD g_cMaxRoutingThreads;


DWORD g_cMaxConnectionObjs = 2000;
BOOL  g_CalledSrand;
DWORD g_dwIncMsgId;

//These buffers are associated with every incoming connection - so we
//will need to have atleast those any plus a few more for use in Dir pickup
//and large SSL buffers
DWORD g_cMaxDirBuffers = 2500;
//This buffer is now used primarily as WRITEBUFFER for every connection
//We have decided to go with 32K buffer
//NK** : Make this metabse readable
DWORD g_cMaxDirChangeIoSize = SMTP_WRITE_BUFFER_SIZE;


//loopback address
DWORD g_LoopBackAddr;

unsigned char GlobalIpBuffer[10000];
CShareLockNH  g_GlobalLock;
SOCKET g_IpListSocket = INVALID_SOCKET;
WSAOVERLAPPED WsaOverLapped;

HANDLE  g_ShutdownHandle = NULL;
HANDLE  g_TcpNotifyHandle = NULL;
HANDLE  g_FreeLibThreadHandle = NULL;
CTcpRegIpList  g_TcpRegIpList;

//
// Notification object used to watch for changes in CAPI stores
//
STORE_CHANGE_NOTIFIER *g_pCAPIStoreChangeNotifier;

//
//  Miscellaneous data.
//

LARGE_INTEGER    AllocationGranularity;         // Page allocation granularity.
HANDLE           g_hSysAccToken = NULL;
TCHAR          * g_pszSmtpTempDirName;            // Name of temporary directory.

DWORD           g_PickupWait;
DWORD           g_FreeLibInterval = 1;   //Interval in min to wait before calling CoFreeUnusedLib
DWORD           g_UseMapiDriver = 0;
LONG            g_MaxFindThreads;

//
// Platform type
//

PLATFORM_TYPE SmtpPlatformType = PtNtServer;
BOOL g_fIsWindows95 = FALSE;

//
// Statistics.
// used to write statistics counter values to when instance is unknown
//

LPSMTP_SERVER_STATISTICS  g_pSmtpStats;

//
// SEO Handle
//
IUnknown    *g_punkSEOHandle;

//
// Externals for SEO
//
extern HRESULT SEOGetServiceHandle(IUnknown **);


//
// Generate the string storage space
//

#if 0
# include "strconst.h"
# define CStrM( FriendlyName, ActualString)   \
   const char  PSZ_ ## FriendlyName[] = ActualString;

ConstantStringsForThisModule()

# undef CStrM

#endif

DWORD SmtpDebug;
extern "C" {
BOOL g_IsShuttingDown = FALSE;
}

DWORD g_SmtpInitializeStatus = 0;
TIME_ZONE_INFORMATION   tzInfo;

#define MAX_CONNECTION_OBJECTS  5000;

BOOL GetMachineIpAddresses(void);
void DeleteIpListFunction(PVOID IpList);
DWORD TcpRegNotifyThread( LPDWORD lpdw );
DWORD FreeLibThread( LPDWORD lpdw );
USERDELETEFUNC CTcpRegIpList::m_DeleteFunc = DeleteIpListFunction;

//
// eventlog object
//
CEventLogWrapper g_EventLog;

//
// Header Date time cache
//

//PCACHED_DATETIME_FORMATS    g_pDateTimeCache = NULL;

static TCHAR    szParamPath[] = TEXT("System\\CurrentControlSet\\Services\\SmtpSvc\\Parameters");
static WCHAR    szParamPathW[] = L"System\\CurrentControlSet\\Services\\SmtpSvc\\Parameters";
static TCHAR    szMaxAddrObjects[] = TEXT("MaxAddressObjects");
static WCHAR    szMaxAddrObjectsW[] = L"MaxAddressObjects";
static TCHAR    szMaxPropertyBagObjects[] = TEXT("MaxPropertyBagObjects");
static WCHAR    szMaxPropertyBagObjectsW[] = L"MaxPropertyBagObjects";
static TCHAR    szMaxMailObjects[] = TEXT("MaxMailObjects");
static WCHAR    szMaxMailObjectsW[] = L"MaxMailObjects";
static TCHAR    szMaxEtrnObjects[] = TEXT("MaxEtrnObjects");
static WCHAR    szMaxEtrnObjectsW[] = L"MaxEtrnObjects";
static TCHAR    szDirBuffers[] = TEXT("MaxDirectoryBuffers");
static WCHAR    szDirBuffersW[] = L"MaxDirectoryBuffers";
static TCHAR    szDirBuffersSize[] = TEXT("DirectoryBuffSize");
static WCHAR    szDirBuffersSizeW[] = L"DirectoryBufferSize";
static TCHAR    szDirPendingIos[] = TEXT("NumDirPendingIos");
static WCHAR    szDirPendingIosW[] = L"NumDirPendingIos";
static TCHAR    szRoutingThreads[] = TEXT("RoutingThreads");
static WCHAR    szRoutingThreadsW[] = L"RoutingThreads";
static TCHAR    szProductType[] = TEXT("ProductType");
static WCHAR    szProductTypeW[] = L"ProductType";
static TCHAR    szResolverSockets[] = TEXT("NumDnsResolverSockets");
static WCHAR    szResolverSocketsW[] = L"NumDnsResolverSockets";
static TCHAR    szDnsSocketTimeout[] = TEXT("msDnsSocketTimeout");
static WCHAR    szDnsSocketTimeoutW[] = L"msDnsSocketTimeout";
static TCHAR    szPickupWait[] = TEXT("PickupWait");
static WCHAR    szPickupWaitW[] = L"PickupWait";
static TCHAR    szMaxFindThreads[] = TEXT("MaxFindThreads");
static WCHAR    szMaxFindThreadsW[] = L"MaxFindThreads";
static TCHAR    szFreeLibInterval[] = TEXT("FreeLibInterval");
static WCHAR    szFreeLibIntervalW[] = L"FreeLibInterval";
static TCHAR    szUseMapiDrv[] = TEXT("UseMapiDriver");
static WCHAR    szUseMapiDrvW[] = L"UseMapiDriver";

//
// resolver globals
//

DWORD   g_ResolverSockets = 10;
DWORD   g_DnsSocketTimeout = 60000;



typedef struct  tagVERTAG {
    LPSTR   pszTag;
} VERTAG, *PVERTAG, FAR *LPVERTAG;



VERTAG  Tags[] = {
  //  { "FileDescription" },
//  { "OriginalFilename" },
  //  { "ProductName" },
    { "ProductVersion" },
//  { "LegalCopyright" },
//  { "LegalCopyright" },
};

#define NUM_TAGS    (sizeof( Tags ) / sizeof( VERTAG ))


//DWORD ConfigIMCService(void);

DWORD   SetVersionStrings( LPSTR lpszFile, LPSTR lpszTitle, LPSTR   lpstrOut,   DWORD   cbOut   )
{
    static char sz[256], szFormat[256], sz2[256];
    int     i;
    UINT    uBytes;
    LPVOID  lpMem;
    DWORD   dw = 0, dwSize;
    HANDLE  hMem;
    LPVOID  lpsz;
    LPDWORD lpLang;
    DWORD   dwLang2;
    BOOL    bRC, bFileFound = FALSE;

    LPSTR   lpstrOrig = lpstrOut ;


    //CharUpper( lpszTitle );

    if ( dwSize = GetFileVersionInfoSize( lpszFile, &dw ) ) {
        if ( hMem = GlobalAlloc( GMEM_MOVEABLE|GMEM_ZEROINIT, (UINT)dwSize ) ) {
            lpMem = GlobalLock(hMem);
            if (GetFileVersionInfo( lpszFile, 0, dwSize, lpMem ) &&
                VerQueryValue(  lpMem, "\\VarFileInfo\\Translation",
                                (LPVOID FAR *)&lpLang, &uBytes ) )
            {
                dwLang2 = MAKELONG( HIWORD(lpLang[0]), LOWORD(lpLang[0]) );

                for( i=0; i<NUM_TAGS; i++ ) {

                    lpsz = 0 ;
                    //
                    // need to do the reverse because most winnt files are wrong
                    //
                    wsprintf( sz, "\\StringFileInfo\\%08lx\\%s", lpLang[0], Tags[i].pszTag );
                    wsprintf( sz2, "\\StringFileInfo\\%08lx\\%s", dwLang2, Tags[i].pszTag );
                    bRC =   VerQueryValue( lpMem, sz, &lpsz, &uBytes ) ||
                            VerQueryValue( lpMem, sz2, &lpsz, &uBytes ) ;

                    if( lpsz != 0 )
                    {

                        if( uBytes+1 < cbOut )
                        {
                            uBytes = min( (UINT)lstrlen( (char*)lpsz ), uBytes ) ;
                            CopyMemory( lpstrOut, lpsz, uBytes ) ;
                            lpstrOut[uBytes++] = ' ' ;
                            lpstrOut += uBytes ;
                            cbOut -= uBytes ;
                        }
                        else
                        {
                            GlobalUnlock( hMem );
                            GlobalFree( hMem );
                            return  (DWORD)(lpstrOut - lpstrOrig) ;
                        }
                    }

                }
                // version info from fixed struct
                bRC = VerQueryValue(lpMem,
                                    "\\",
                                    &lpsz,
                                    &uBytes );

                #define lpvs    ((VS_FIXEDFILEINFO FAR *)lpsz)
                static  char    szVersion[] = "Version: %d.%d.%d.%d" ;

                if ( (cbOut > (sizeof( szVersion )*2)) && lpsz ) {

                    CopyMemory( szFormat, szVersion, sizeof( szVersion ) ) ;
                    //LoadString( hInst, IDS_VERSION, szFormat, sizeof(szFormat) );

                    DWORD   cbPrint = wsprintf( lpstrOut, szFormat, HIWORD(lpvs->dwFileVersionMS),
                                LOWORD(lpvs->dwFileVersionMS),
                                HIWORD(lpvs->dwFileVersionLS),
                                LOWORD(lpvs->dwFileVersionLS) );
                    lpstrOut += cbPrint ;

                }
                bFileFound = TRUE;
            }   else    {

            }

            GlobalUnlock( hMem );
            GlobalFree( hMem );
        }       else    {

        }
    }   else    {

    }
    DWORD   dw2 = GetLastError() ;

    return  (DWORD)(lpstrOut - lpstrOrig) ;
}


BOOL InitServerVersionString( VOID )
{
    BOOL fRet = TRUE ;
    DWORD szSize;
    char szServerPath[MAX_PATH + 1];
    char * szOffset;

    CopyMemory(szServerPath, "c:\\", sizeof( "c:\\" ) ) ;

    g_VersionString [0] = '\0';

    HMODULE hModule = GetModuleHandle( "smtpsvc.dll" ) ;
    if( hModule != 0 )
    {

        if( !GetModuleFileName( hModule, szServerPath, sizeof( szServerPath ) ) )
        {
            lstrcpy( szServerPath, "c:\\") ;
        }
        else
        {
            szSize = SetVersionStrings(szServerPath, "", g_VersionString, 128 );
            szOffset = strstr(g_VersionString, "Version");
            if(szOffset)
            {
                //Move interesting part of string (including the
                //terminating NULL) to front of g_VersionString.
                MoveMemory(g_VersionString, szOffset, 
                    szSize+1 - (szOffset - g_VersionString));
            }

        }
    }


    return TRUE ;
}

BOOL GetGlobalRegistrySettings(void)
{
    BOOL        fRet = TRUE;
    HKEY        hkeySmtp = NULL;
    HKEY        hkeySub = NULL;
    DWORD       dwErr;
    DWORD       dwDisp;

    DWORD       dwMaxFindThreads;

    TraceFunctEnterEx((LPARAM)NULL, "GetGlobalRegistrySettings");

    dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szParamPath, NULL, NULL,
            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeySmtp, &dwDisp);
    if (dwErr != ERROR_SUCCESS)
    {
        SmtpLogEventEx(SMTP_EVENT_CANNOT_OPEN_SVC_REGKEY, (const char *)SMTP_PARAMETERS_KEY, dwErr);
        TraceFunctLeave();
        SetLastError(dwErr);
        return FALSE;
    }

    g_cMaxAddressObjects = ReadRegistryDword(hkeySmtp, szMaxAddrObjects, 100000);
    StateTrace((LPARAM)NULL, "g_cMaxAddressObjects = %u", g_cMaxAddressObjects);

    //NK ** We atleast need as many buffers as many connections we accept
    //so I have now tied it to that value
    //g_cMaxDirBuffers = ReadRegistryDword(hkeySmtp, szDirBuffers, 5000);
    //g_cMaxDirChangeIoSize = ReadRegistryDword(hkeySmtp, szDirBuffersSize, MAX_WRITE_FILE_BLOCK);

    g_ResolverSockets = ReadRegistryDword(hkeySmtp, szResolverSockets, 10);
    g_DnsSocketTimeout = ReadRegistryDword(hkeySmtp, szDnsSocketTimeout, 60000);

    g_PickupWait = ReadRegistryDword(hkeySmtp, szPickupWait, 200);
    // don't let them make this wait more than 5 secs.  that is too much.
    if (g_PickupWait > 5000)
    {
        g_PickupWait = 5000;
    }

    //In seems like after the call to unload, the dlls get physically unloaded
    //11 min after that. So I am setting the interval by default to 11.
    g_FreeLibInterval = ReadRegistryDword(hkeySmtp,szFreeLibInterval, 11);
    // don't let them make this wait more than 60 min.  that is too much.
    if (g_FreeLibInterval > 60)
    {
        g_FreeLibInterval = 60;
    }

    dwMaxFindThreads = ReadRegistryDword(hkeySmtp, szMaxFindThreads, 3);
    // don't want this to be bigger than the routing threads, but we want at least one.
    if (dwMaxFindThreads > 3)
    {
        dwMaxFindThreads = 3;
    }
    else if (dwMaxFindThreads <= 0)
    {
        dwMaxFindThreads = 1;
    }

    g_MaxFindThreads = dwMaxFindThreads;

    RegCloseKey(hkeySmtp);
    TraceFunctLeaveEx((LPARAM)NULL);
    return fRet;
}

void IpAddressListCallBack (DWORD dwError, DWORD cbTransferred, LPWSAOVERLAPPED LpOverlapped,
                            DWORD dwFlags)
{
    DWORD wsError = 0;
    DWORD bytesReturned = 0;

    GetMachineIpAddresses();

    wsError = WSAIoctl(g_IpListSocket, SIO_ADDRESS_LIST_CHANGE, NULL, 0, NULL,
                    0, &bytesReturned, &WsaOverLapped, IpAddressListCallBack);

}

BOOL GetMachineIpAddresses(void)
{
    DWORD   bytesReturned = 0;
    DWORD   wsError = 0;
    BOOL fRet = FALSE;

    g_GlobalLock.ExclusiveLock();

    ZeroMemory((void *)GlobalIpBuffer, sizeof(GlobalIpBuffer));

     if(g_IpListSocket != INVALID_SOCKET)
     {
        wsError = WSAIoctl(g_IpListSocket, SIO_ADDRESS_LIST_QUERY, NULL, 0, (LPVOID) GlobalIpBuffer,
                    sizeof(GlobalIpBuffer), &bytesReturned, NULL, NULL);

        if(wsError == 0)
        {
            fRet = TRUE;
        }
     }

    g_GlobalLock.ExclusiveUnlock();
    return fRet;
}

BOOL IsIpInGlobalList(DWORD IpAddress)
{
    INT AddressCount = 0;
    SOCKET_ADDRESS_LIST * ptr = NULL;
    sockaddr_in * Current = NULL;
    char Scratch[100];

    TraceFunctEnterEx((LPARAM)NULL, "IsIpInGlobalList");

    g_GlobalLock.ShareLock();

    Scratch[0] = '\0';

    ptr = (SOCKET_ADDRESS_LIST *)GlobalIpBuffer;

    for (AddressCount = 0; AddressCount < ptr->iAddressCount;AddressCount++)
    {
            Current = (sockaddr_in *) ptr->Address[AddressCount].lpSockaddr;
            if(Current)
            {
                DebugTrace((LPARAM)NULL," Address - %s", inet_ntoa( Current->sin_addr));

                if(Current->sin_addr.s_addr == IpAddress)
                {
                    InetNtoa(*(struct in_addr *) &Current->sin_addr.s_addr, Scratch);

                    ErrorTrace((LPARAM) NULL, "IpAddress %s is one of mine - Failing connection", Scratch);
                    g_GlobalLock.ShareUnlock();
                    TraceFunctLeaveEx((LPARAM)NULL);
                    return TRUE;
                }
            }
    }

    g_GlobalLock.ShareUnlock();

    InetNtoa(*(struct in_addr *) &IpAddress, Scratch);

    DebugTrace((LPARAM) NULL, "IpAddress %s is not one of mine ", Scratch);

    TraceFunctLeaveEx((LPARAM)NULL);
    return FALSE;
}

void VerifyFQDNWithGlobalIp(DWORD InstanceId, char * szFQDomainName)
{
    INT AddressCount = 0;
    SOCKET_ADDRESS_LIST * ptr = NULL;
    sockaddr_in * Current = NULL;
    char Scratch[100];
    Scratch[0] = '\0';
    CONST CHAR *apszMsgs[2];
    CHAR achInstance[20];
    CHAR achIPAddr[20];
    PHOSTENT pH = NULL;

    //Get the current instnace id
    wsprintf( achInstance,
              "%lu",
              InstanceId );
    apszMsgs[1] = achInstance;


    g_GlobalLock.ShareLock();
    ptr = (SOCKET_ADDRESS_LIST *)GlobalIpBuffer;
    for (AddressCount = 0; AddressCount < ptr->iAddressCount;AddressCount++)
    {
        Current = (sockaddr_in *) ptr->Address[AddressCount].lpSockaddr;
        if(Current)
        {
            ((PSMTP_IIS_SERVICE) g_pInetSvc)->StartHintFunction();
            //For each IP address find the host name
            pH = gethostbyaddr( (char*)(&((PSOCKADDR_IN)Current)->sin_addr), 4, PF_INET );
            if(pH == NULL)
            {
                SmtpLogEvent( SMTP_EVENT_UNRESOLVED_FQDN, 0, (const CHAR **)NULL, 0 );
            }
            else if(_strnicmp(pH->h_name,szFQDomainName,strlen(szFQDomainName)))
            {
                wsprintf( achIPAddr,"%s",inet_ntoa( Current->sin_addr));
                apszMsgs[0] = achIPAddr;
                SmtpLogEvent( SMTP_EVENT_UNRESOLVED_FQDN,2,apszMsgs,0 );
            }
        }
    }
    g_GlobalLock.ShareUnlock();
}


//
//  Public functions.
//

APIERR
InitializeGlobals(
            VOID
            )

/*++

Routine Description:

    Initializes global shared variables.  Some values are
        initialized with constants, others are read from the
        configuration registry.

Arguments:

    None.

Return Value:

    Win32

--*/
{
    DWORD  err;
    DWORD MaxConnections;
    SYSTEM_INFO     systemInfo;
    HRESULT hr = S_OK;
    DWORD   wsError = 0;
    DWORD   bytesReturned = 0;
    DWORD   dwThreadId = 0;

    TraceFunctEnter( "InitializeGlobals" );

    g_CalledSrand = FALSE;
    g_dwIncMsgId = 0;

    g_ShutdownHandle = CreateEvent( NULL, TRUE, FALSE, NULL );
    if(g_ShutdownHandle == NULL)
    {
        err = GetLastError();
        ErrorTrace(0, "Cannot allocate shutdown handle. err: %u", err);
        _ASSERT(err != NO_ERROR);
        if(err == NO_ERROR)
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        goto error_exit;
    }

    g_TcpNotifyHandle =
            CreateThread(   NULL,
                            0,
                            (LPTHREAD_START_ROUTINE)TcpRegNotifyThread,
                            NULL,
                            0,
                            &dwThreadId );

    if (g_TcpNotifyHandle == NULL )
    {
        err = GetLastError();
        ErrorTrace(0, "Cannot create notify thread. err: %u", err);
        _ASSERT(err != NO_ERROR);
        if(err == NO_ERROR)
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        goto error_exit;
    }

    hr = g_EventLog.Initialize("smtpsvc");
    if (FAILED(hr)) {
        // do nothing
    }

    g_IpListSocket = socket (AF_INET, SOCK_STREAM, 0);
    if(g_IpListSocket != INVALID_SOCKET)
    {
        GetMachineIpAddresses();
        wsError = WSAIoctl(g_IpListSocket, SIO_ADDRESS_LIST_CHANGE, NULL, 0, NULL,
                    0, &bytesReturned, &WsaOverLapped, IpAddressListCallBack);

        if(wsError == 0)
        {
            //fRet = TRUE;
        }

    }

    //
    // read the global registry settings
    //

    g_SmtpPlatformType =  IISGetPlatformType();

    if(!GetGlobalRegistrySettings())
    {
        FatalTrace(NULL, "Could not read global reg settings!");
        TraceFunctLeave();
        return ERROR_SERVICE_DISABLED;
    }

    //thread to periodically call free ununsed libraries
    //so dll's can be unloaded
    g_FreeLibThreadHandle =
            CreateThread(   NULL,
                            0,
                            (LPTHREAD_START_ROUTINE)FreeLibThread,
                            NULL,
                            0,
                            &dwThreadId );

    if (g_FreeLibThreadHandle == NULL )
    {
        err = GetLastError();
        ErrorTrace(0, "Cannot create Free Library thread. err: %u", err);
        _ASSERT(err != NO_ERROR);
        if(err == NO_ERROR)
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        goto error_exit;
    }

    //
    // do global SEO initialization
    //
    hr = SEOGetServiceHandle(&g_punkSEOHandle);
    if (FAILED(hr))
    {
        ErrorTrace(0, "SEOGetServiceHandle returned %x", hr);

        // we're in trouble here.  we'll try and continue on, but server events
        // probably won't work right
        g_punkSEOHandle = NULL;
        //SmtpLogEventSimple(SEO_INIT_FAILED, hr);
    }

    //
    // Initialize the server version string based on the platform type
    //
    InitServerVersionString();

    SmtpPlatformType =  IISGetPlatformType();

    switch ( SmtpPlatformType )
    {

    case PtNtWorkstation:
        lstrcpy(szServerVersion,MAKE_VERSION_STRING(MSSMTP_VERSION_STR_NTW));
        lstrcpy(g_szServerType, MSSMTP_VERSION_STR_NTW);
        break;

    case PtWindows95:
    case PtWindows9x:
        lstrcpy(szServerVersion,MAKE_VERSION_STRING(MSSMTP_VERSION_STR_W95));
        lstrcpy(g_szServerType, MSSMTP_VERSION_STR_W95);
        g_fIsWindows95 = TRUE;
        break;

    default:

        //
        // Either server or unhandled platform type!
        //

        DBG_ASSERT(InetIsNtServer(SmtpPlatformType));
        lstrcpy(szServerVersion,MAKE_VERSION_STRING(MSSMTP_VERSION_STR_IIS));
        lstrcpy(g_szServerType, MSSMTP_VERSION_STR_IIS);
    }

    g_cbServerType = lstrlen( g_szServerType);
    cbServerVersionString = lstrlen(szServerVersion);

    //store the computer name
    g_ComputerNameLength = MAX_PATH;
    if (!GetComputerName(g_ComputerName, &g_ComputerNameLength))
    {
        err = GetLastError();
        ErrorTrace((LPARAM)NULL, "GetComputerName() failed with err %d", err);
        TraceFunctLeave();
        return err;
    }


    // number of processors on the system.
    GetSystemInfo( &systemInfo );
    g_NumProcessors = systemInfo.dwNumberOfProcessors;

    g_LoopBackAddr = inet_addr ("127.0.0.1");
    g_pSmtpStats = NULL;

    //find out what the max connection paramater is
    MaxConnections = MAX_CONNECTION_OBJECTS;

    DebugTrace(NULL, "g_cMaxConnectionObjs = %d", g_cMaxConnectionObjs);

    //allocate some SMTP_CONNECTION objects from CPOOL
    if (!SMTP_CONNECTION::Pool.ReserveMemory( g_cMaxConnectionObjs, sizeof(SMTP_CONNECTION) ) )
    {
        err = GetLastError();
        ErrorTrace(0, "ReserveMemory failed for SMTP_CONNECTION. err: %u", err);
        _ASSERT(err != NO_ERROR);
        if(err == NO_ERROR)
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        goto error_exit;
    }


    g_SmtpInitializeStatus |= INITIALIZE_INBOUNDPOOL;

    //allocate some SMTP_CONNECTION objects from CPOOL
    if (!SMTP_CONNOUT::Pool.ReserveMemory(MaxConnections, sizeof(SMTP_CONNOUT) ) )
    {
        err = GetLastError();
        ErrorTrace(0, "ReserveMemory failed for SMTP_CONNOUT. err: %u", err);
        _ASSERT(err != NO_ERROR);
        if(err == NO_ERROR)
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        goto error_exit;
    }

    g_SmtpInitializeStatus |= INITIALIZE_OUTBOUNDPOOL;

    //allocate some CAddr objects from CPOOL
    if (!CAddr::Pool.ReserveMemory(1000, sizeof(CAddr) ) )
    {
        err = GetLastError();
        ErrorTrace(0, "ReserveMemory failed for CAddr. err: %u", err);
        _ASSERT(err != NO_ERROR);
        if(err == NO_ERROR)
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        goto error_exit;
    }

    g_SmtpInitializeStatus |= INITIALIZE_ADDRESSPOOL;


    if (!CAsyncMx::Pool.ReserveMemory(3000, sizeof(CAsyncMx)))
    {
            err = GetLastError();
            ErrorTrace(0, "ReserveMemory failed for CBuffer. err: %u", err);
            _ASSERT(err != NO_ERROR);
            if(err == NO_ERROR)
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto error_exit;
    }

    g_SmtpInitializeStatus |= INITIALIZE_CASYNCMX;

    if (!CAsyncSmtpDns::Pool.ReserveMemory(4000, sizeof(CAsyncSmtpDns)))
    {
            err = GetLastError();
            ErrorTrace(0, "ReserveMemory failed for CBuffer. err: %u", err);
            _ASSERT(err != NO_ERROR);
            if(err == NO_ERROR)
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto error_exit;
    }

    g_SmtpInitializeStatus |= INITIALIZE_CASYNCDNS;

    //
    // Initialize the file handle cache
    //
    if (!InitializeCache()) {
            err = GetLastError();
            ErrorTrace(0, "InitializeCache failed err: %u", err);
            _ASSERT(err != NO_ERROR);
            if(err == NO_ERROR)
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto error_exit;
    }

    g_SmtpInitializeStatus |= INITIALIZE_FILEHC;


    if (!CBuffer::Pool.ReserveMemory(g_cMaxDirBuffers, sizeof(CBuffer)))
    {
            err = GetLastError();
            ErrorTrace(0, "ReserveMemory failed for CBuffer. err: %u", err);
            _ASSERT(err != NO_ERROR);
            if(err == NO_ERROR)
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto error_exit;
    }

    g_SmtpInitializeStatus |= INITIALIZE_CBUFFERPOOL;

    if (!CIoBuffer::Pool.ReserveMemory(g_cMaxDirBuffers, g_cMaxDirChangeIoSize))
    {
            err = GetLastError();
            ErrorTrace(0, "ReserveMemory failed for CIOBuffer. err: %u", err);
            _ASSERT(err != NO_ERROR);
            if(err == NO_ERROR)
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto error_exit;
        }

    g_SmtpInitializeStatus |= INITIALIZE_CIOBUFFPOOL;

    if (!CBlockMemoryAccess::m_Pool.ReserveMemory(2000, sizeof(BLOCK_HEAP_NODE)))
    {
            err = GetLastError();
            ErrorTrace(0, "ReserveMemory failed for CBlockMemoryAccess. err: %u", err);
            _ASSERT(err != NO_ERROR);
            if(err == NO_ERROR)
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto error_exit;
    }
    g_SmtpInitializeStatus |= INITIALIZE_CBLOCKMGR;

    if (!CDropDir::m_Pool.ReserveMemory(1000, sizeof(CDropDir)))
    {
            err = GetLastError();
            ErrorTrace(0, "ReserveMemory failed for CDropDir. err: %u", err);
            _ASSERT(err != NO_ERROR);
            if(err == NO_ERROR)
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto error_exit;
    }
    g_SmtpInitializeStatus |= INITIALIZE_CDROPDIR;

    //
    // Create the CAPI store notification object
    //
    g_pCAPIStoreChangeNotifier = new STORE_CHANGE_NOTIFIER();

    if ( g_pCAPIStoreChangeNotifier == NULL )
    {
            err = GetLastError();
            ErrorTrace(0, "Failed to create CAPIStoreChange notifier err: %u", err);
            _ASSERT(err != NO_ERROR);
            if(err == NO_ERROR)
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto error_exit;
    }


    if (!CEncryptCtx::Initialize(
            "SmtpSvc",
            (struct IMDCOM*) g_pInetSvc->QueryMDObject(),
            (PVOID) (&g_SmtpSMC)))
    {
        err = GetLastError();
        ErrorTrace(0, "Initializing SSL Context failed. err: %u", err);
        _ASSERT(err != NO_ERROR);
        if(err == NO_ERROR)
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        goto error_exit;
    }

    g_SmtpInitializeStatus |= INITIALIZE_SSLCONTEXT;

    if (!CSecurityCtx::Initialize(FALSE, FALSE))
    {
        err = GetLastError();
        ErrorTrace(NULL, "CSecurityCtx::Initialize failed, %u", err);
        if(err == NO_ERROR)
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        goto error_exit;
    }

    g_SmtpInitializeStatus |= INITIALIZE_CSECURITY;

    GetTimeZoneInformation(&tzInfo);

    TraceFunctLeave();
    return NO_ERROR;

error_exit:

    err = GetLastError();
    if(err == NO_ERROR)
    {
        SetLastError(ERROR_PATH_NOT_FOUND);
        err = ERROR_PATH_NOT_FOUND;
    }

    TraceFunctLeave();
    return err;

}   // InitializeGlobals


VOID
TerminateGlobals(
            VOID
            )

/*++

Routine Description:

    Terminates global shared variables.

Arguments:

    None.

Return Value:

    None.

--*/
{

  if(g_ShutdownHandle)
  {
    SetEvent(g_ShutdownHandle);
  }

  if(g_SmtpInitializeStatus & INITIALIZE_INBOUNDPOOL)
  {
    //finally, release all our memory
    SMTP_CONNECTION::Pool.ReleaseMemory();
  }

  if(g_SmtpInitializeStatus & INITIALIZE_OUTBOUNDPOOL)
  {
    SMTP_CONNOUT::Pool.ReleaseMemory();
  }

  if(g_SmtpInitializeStatus & INITIALIZE_ADDRESSPOOL)
  {
    CAddr::Pool.ReleaseMemory();
  }

  if(g_SmtpInitializeStatus & INITIALIZE_CBUFFERPOOL)
  {
    //finally, release all our memory
    CBuffer::Pool.ReleaseMemory();
  }

  if(g_SmtpInitializeStatus & INITIALIZE_CIOBUFFPOOL)
  {
    //finally, release all our memory
    CIoBuffer::Pool.ReleaseMemory();
  }

  if (g_SmtpInitializeStatus & INITIALIZE_CDROPDIR)
  {
      CDropDir::m_Pool.ReleaseMemory();
  }
  
  if ( g_pCAPIStoreChangeNotifier )
  {
      delete g_pCAPIStoreChangeNotifier;
      g_pCAPIStoreChangeNotifier = NULL;
  }

  if (g_SmtpInitializeStatus & INITIALIZE_SSLCONTEXT) {
      CEncryptCtx::Terminate();
  }

  if (g_SmtpInitializeStatus & INITIALIZE_CSECURITY)
        CSecurityCtx::Terminate();

  if(g_SmtpInitializeStatus & INITIALIZE_CASYNCMX)
  {
    //finally, release all our memory
    CAsyncMx::Pool.ReleaseMemory();
  }

  if(g_SmtpInitializeStatus & INITIALIZE_CASYNCDNS)
  {
    //finally, release all our memory
    CAsyncSmtpDns::Pool.ReleaseMemory();
  }

  if (g_SmtpInitializeStatus & INITIALIZE_FILEHC) {
    TerminateCache();
  }

  if(g_SmtpInitializeStatus & INITIALIZE_CBLOCKMGR)
  {
    //finally, release all our memory
    CBlockMemoryAccess::m_Pool.ReleaseMemory();
  }

    if( g_pSmtpStats != NULL )
    {
        delete g_pSmtpStats;
        g_pSmtpStats = NULL;
    }

    if(g_IpListSocket != INVALID_SOCKET)
    {
        closesocket (g_IpListSocket);
        g_IpListSocket = INVALID_SOCKET;
    }

    UnLoadQueueDriver();

    //
    // do global SEO cleanup
    //
    if (g_punkSEOHandle != NULL)
    {
        g_punkSEOHandle->Release();
        g_punkSEOHandle = NULL;
    }

    if(g_TcpNotifyHandle != NULL)
    {
        WaitForSingleObject(g_TcpNotifyHandle, INFINITE);
        CloseHandle(g_TcpNotifyHandle);
        g_TcpNotifyHandle = NULL;
    }

    if(g_FreeLibThreadHandle != NULL)
    {
        WaitForSingleObject(g_FreeLibThreadHandle, INFINITE);
        CloseHandle(g_FreeLibThreadHandle);
        g_FreeLibThreadHandle = NULL;
    }


    if(g_ShutdownHandle != NULL)
    {
        CloseHandle(g_ShutdownHandle);
        g_ShutdownHandle = NULL;
    }

}   // TerminateGlobals

//
// Given a directory path, this subroutine will create the direct layer by layer
//

BOOL CreateLayerDirectory( char * str )
{
    BOOL fReturn = TRUE;
    char Tmp [MAX_PATH + 1];

    do
    {
        INT index=0;
        INT iLength = lstrlen(str) + 1;

        // first find the index for the first directory
        if ( iLength > 2 )
        {
            if ( str[1] == _T(':'))
            {
                // assume the first character is driver letter
                if ( str[2] == _T('\\'))
                {
                    index = 2;
                } else
                {
                    index = 1;
                }
            } else if ( str[0] == _T('\\'))
            {
                if ( str[1] == _T('\\'))
                {
                    BOOL fFound = FALSE;
                    INT i;
                    INT nNum = 0;
                    // unc name
                    for (i = 2; i < iLength; i++ )
                    {
                        if ( str[i]==_T('\\'))
                        {
                            // find it
                            nNum ++;
                            if ( nNum == 2 )
                            {
                                fFound = TRUE;
                                break;
                            }
                        }
                    }
                    if ( fFound )
                    {
                        index = i;
                    } else
                    {
                        // bad name
                        break;
                    }
                } else
                {
                    index = 1;
                }
            }
        } else if ( str[0] == _T('\\'))
        {
            index = 0;
        }

        // okay ... build directory
        do
        {
            // find next one
            do
            {
                if ( index < ( iLength - 1))
                {
                    index ++;
                } else
                {
                    break;
                }
            } while ( str[index] != _T('\\'));


            TCHAR szCurrentDir[MAX_PATH+1];

            GetCurrentDirectory( MAX_PATH+1, szCurrentDir );

            lstrcpyn(Tmp, str, ( index + 1 ));

            if ( !SetCurrentDirectory( Tmp))
            {
                if (( fReturn = CreateDirectory( Tmp, NULL )) != TRUE )
                {
                    break;
                }
            }

            SetCurrentDirectory( szCurrentDir );

            if ( index >= ( iLength - 1 ))
            {
                fReturn = TRUE;
                break;
            }
        } while ( TRUE );
    } while (FALSE);

    return(fReturn);
}

void GenerateMessageId (char * Buffer, DWORD BuffLen)
{
    //Temporary stuff
    DWORD MsgIdLen = 20;
    if(BuffLen < MsgIdLen)
        MsgIdLen = BuffLen;

    if( !g_CalledSrand )
    {
        srand( GetTickCount() );
        g_CalledSrand = TRUE;
    }
    
    lstrcpyn (Buffer, g_ComputerName, (MsgIdLen - 1));

    DWORD Loop = lstrlen(Buffer);
    while (Loop < (MsgIdLen - 1) )
    {
        Buffer[Loop] = g_BoundaryChars[rand() % (sizeof(g_BoundaryChars) - 1)];
        Loop++;
    }
    Buffer [Loop] = '\0';
}

DWORD GetIncreasingMsgId()
{
    return( InterlockedIncrement( (LONG*)&g_dwIncMsgId ) );
}


void DeleteIpListFunction(PVOID IpList)
{
    PIP_ARRAY aipServers = (PIP_ARRAY) IpList;

    if(aipServers != NULL)
    {
        DnsApiFree(aipServers);
    }
}

DWORD FreeLibThread( LPDWORD lpdw )
{
    DWORD   dw = 0;
    DWORD   dwWaitMillisec = g_FreeLibInterval * 1000 * 60;

    TraceFunctEnterEx((LPARAM) NULL, "FreeLibThread");

    for ( ;; )
    {
        dw = WaitForSingleObject(g_ShutdownHandle,
                                    dwWaitMillisec );

        switch( dw )
        {
        //
        // normal shutdown signalled
        //
        case WAIT_OBJECT_0:

            ErrorTrace((LPARAM) NULL, "Exiting FreeLibThread for hShutdownEvent");
            return  0;

        //
        // Timeout occured
        //
        case WAIT_TIMEOUT:
            CoFreeUnusedLibraries();
            break;

        default:
            ErrorTrace((LPARAM) NULL, "Exiting FreeLibThread for default reasons");
            return  1;
        }
    }

    return  2;
}


#define NUM_REG_THREAD_OBJECTS  2

DWORD TcpRegNotifyThread( LPDWORD lpdw )
{
    HANDLE  Handles[NUM_REG_THREAD_OBJECTS];
    PIP_ARRAY       aipServers =NULL;
    PLIST_ENTRY     pEntry = NULL;
    CTcpRegIpList   * pIpEntry = NULL;
    CTcpRegIpList   *IpList = NULL;
    HKEY       hKey = NULL;
    DWORD   dw = 0;

    TraceFunctEnterEx((LPARAM) NULL, "TcpRegNotifyThread");

    Handles[0] = g_ShutdownHandle;

    Handles[1] = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( Handles[1] == NULL )
    {
        return  1;
    }


    DnsGetDnsServerList( (PIP_ARRAY *) &aipServers );
    if (aipServers != NULL)
        g_TcpRegIpList.Update(aipServers);

    if ( RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
                        "System\\CurrentControlSet\\Services\\Tcpip",
                        0,
                        KEY_READ,
                        &hKey ) != ERROR_SUCCESS )
    {
        ErrorTrace((LPARAM) NULL, "RegNotifyThread RegOpenKeyEx failed %d", GetLastError());
        CloseHandle( Handles[1] );
        return  1;
    }

    for ( ;; )
    {
        if ( RegNotifyChangeKeyValue(hKey,
                                    TRUE,
                                    REG_NOTIFY_CHANGE_ATTRIBUTES |
                                    REG_NOTIFY_CHANGE_LAST_SET,
                                    Handles[1],
                                    TRUE ) != ERROR_SUCCESS )
        {
            ErrorTrace((LPARAM) NULL, "RegNotifyThread RegNotifyChangeKeyValue failed %d", GetLastError());
            RegCloseKey( hKey );
            CloseHandle( Handles[1] );
            return  1;
        }

        dw = WaitForMultipleObjects(NUM_REG_THREAD_OBJECTS,
                                    Handles,
                                    FALSE,
                                    INFINITE );

        switch( dw )
        {
            //
            // normal signalled event
            //
            case WAIT_OBJECT_0:
    
                //close all the handles
                RegCloseKey( hKey );
                CloseHandle( Handles[1] );
                Handles[1] = NULL;
                hKey = NULL;
    
                g_TcpRegIpList.Update(NULL);
                ErrorTrace((LPARAM) NULL, "Exiting TcpRegNotifyThread for hShutdownEvent");
                return  0;
    
            //
            // signalled that our registry keys have changed
            //
            case WAIT_OBJECT_0+1:
                DnsGetDnsServerList( &aipServers );
                g_TcpRegIpList.Update(aipServers);
                break;
            default:
                RegCloseKey( hKey );
                CloseHandle( Handles[1] );
                return  1;
        }
    }

    RegCloseKey( hKey );
    CloseHandle( Handles[1] );

    return  2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\globals.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    This module contains declarations for globals.

Author:

    Johnson Apacible (JohnsonA)     26-Sept-1995

Revision History:

--*/

#ifndef _SMTPDATA_
#define _SMTPDATA_

//
// tracing
//

#define INIT_TRACE              InitAsyncTrace( )
#define TERM_TRACE              TermAsyncTrace( )
#define ENTER( _x_ )            TraceFunctEnter( _x_ );
#define LEAVE                   TraceFunctLeave( );

#define DOMAIN_ROUTE_HT_SIGNATURE_VALID     'DRHV'
#define DOMAIN_ROUTE_HT_SIGNATURE_FREE      'DRHF'

#define LOCAL_DOMAIN_HT_SIGNATURE_VALID     'LDHV'
#define LOCAL_DOMAIN_HT SIGNATURE_FREE      'LDHF'

#define DEDICATED_CLIENT_REQUEST_THREADS    3
#define SYSTEM_ROUTING_THREADS_PER_PROC     12
#define CHECK_QUEUE_COUNT                   50
#define ADD_THREAD_BACKLOG                  100

#define SMTP_BASE_PRODUCT   (0)

#define SMTP_UNRECOG_COMMAND_CODE   500
#define SMTP_SYNTAX_ERROR_CODE      501
#define SMTP_NOT_IMPLEMENTED_CODE   502
#define SMTP_BAD_SEQUENCE_CODE      503
#define SMTP_PARAM_NOT_IMPLEMENTED_CODE 504

#define SMTP_SYS_STATUS_CODE        211
#define SMTP_SERVICE_CLOSE_CODE     221
#define SMTP_SERVICE_READY_CODE     220
#define SMTP_OK_CODE                250
#define SMTP_USER_NOT_LOCAL_CODE    251
#define SMTP_MBOX_BUSY_CODE         450
#define SMTP_MBOX_NOTFOUND_CODE     550
#define SMTP_ERROR_PROCESSING_CODE  451
#define SMTP_USERNOTLOCAL_CODE      551
#define SMTP_INSUFF_STORAGE_CODE    452
#define SMTP_ACTION_ABORTED_CODE    552
#define SMTP_ACTION_NOT_TAKEN_CODE  553
#define SMTP_START_MAIL_CODE        354
#define SMTP_TRANSACT_FAILED_CODE   554

#define SMTP_SERVICE_UNAVAILABLE_CODE 421
#define SMTP_COMPLETE_FAILURE_DWORD 5

enum RCPTYPE{LOCAL_NAME, REMOTE_NAME, ALIAS_NAME};

#define NORMAL_RCPT (char)'R'
#define ERROR_RCPT  (char)'E'
//
// use the current command for transaction logging
//
#define USE_CURRENT         0xFFFFFFFF

static const char * LOCAL_TRANSCRIPT    = "ltr";
static const char * REMOTE_TRANSCRIPT   = "rtr";
static const char * ALIAS_EXT           = "dl";

#define ISNULLADDRESS(Address) ((Address[0] == '<') && (Address[1] == '>'))

typedef char RCPT_TYPE;

extern SMTP_STATISTICS_0 g_pSmtpStat;
extern LPSMTP_SERVER_STATISTICS  g_pSmtpStats;
extern TIME_ZONE_INFORMATION   tzInfo;

extern CHAR  g_ComputerName[];
extern CHAR  g_VersionString[];
extern DWORD g_ComputerNameLength;
extern DWORD g_LoopBackAddr;
extern DWORD g_ProductType;
extern DWORD g_NumProcessors;
extern DWORD g_PickupWait;
extern LONG g_MaxFindThreads;
extern PLATFORM_TYPE g_SmtpPlatformType;
extern CEventLogWrapper g_EventLog;

extern "C"
{
extern BOOL g_IsShuttingDown;
}

#define INITIALIZE_INBOUNDPOOL  0x00000001
#define INITIALIZE_OUTBOUNDPOOL 0x00000002
#define INITIALIZE_ADDRESSPOOL  0x00000004
#define INITIALIZE_MAILOBJPOOL  0x00000008
#define INITIALIZE_CBUFFERPOOL  0x00000010
#define INITIALIZE_CIOBUFFPOOL  0x00000020
#define INITIALIZE_SSLCONTEXT   0x00000040
#define INITIALIZE_ETRNENTRYPOOL 0x00000080
#define INITIALIZE_CSECURITY    0x00000100
#define INITIALIZE_CPROPERTYBAGPOOL 0x00000200
#define INITIALIZE_CASYNCMX     0x00000400
#define INITIALIZE_CASYNCDNS    0x00000800
#define INITIALIZE_CBLOCKMGR    0x00001000
#define INITIALIZE_FILEHC       0x00002000
#define INITIALIZE_CDROPDIR     0x00004000

extern  DWORD g_SmtpInitializeStatus;

//Domain validation flags
#define SMTP_NOVALIDATE_EHLO    0x00000001
#define SMTP_NOVALIDATE_MAIL    0x00000002
#define SMTP_NOVALIDATE_RCPT    0x00000004
#define SMTP_NOVALIDATE_PKUP    0x00000008
#define SMTP_NOVALIDATE_ETRN    0x00000010


#define BUMP_COUNTER(InstObj, counter) \
                        InterlockedIncrement((LPLONG) &(InstObj->QueryStatsObj()->QueryStatsMember()->counter))

#define DROP_COUNTER(InstObj, counter) \
                        InterlockedDecrement((LPLONG) &(InstObj->QueryStatsObj()->QueryStatsMember()->counter))

#define ADD_COUNTER(InstObj, counter, value)    \
        INTERLOCKED_ADD_CHEAP(&(InstObj->QueryStatsObj()->QueryStatsMember()->counter), value)

#define ADD_BIGCOUNTER(InstObj, counter, value) \
        INTERLOCKED_BIGADD_CHEAP(&(InstObj->QueryStatsObj()->QueryStatsMember()->counter), value)

/***********************************************************
 *    Type Definitions
 ************************************************************/
const DWORD MAX_RESPONSE_LEN = 300;
const DWORD RESPONSE_BUFF_SIZE = MAX_RESPONSE_LEN + MAX_PATH;
const DWORD cMaxRoutingSources = 32;
const DWORD cbMaxRoutingSource = 512;
const DWORD smarthostNone = 0;
const DWORD smarthostAfterFail = 1;
const DWORD smarthostAlways = 2;
// Removed by KeithLau on 7/18/96
// const DWORD cMaxValidDomains = 32;

#define SMTP_WRITE_BUFFER_SIZE ( 64 * 1024 ) //64K buffers

enum SMTP_MSG_FILE_TYPE {SYSTEM_MSG_FILE, LOCAL_MSG_FILE, ABOOK_MSG_FILE};

enum SMTPCMDSEX {
    #undef SmtpDef
    #define SmtpDef(a)  CMD_EX_##a,
    #include "smtpdef.h"
    CMD_EX_UNKNOWN
};

enum SMTPLOGS {
    #undef SmtpDef
    #define SmtpDef(a)  LOG_FLAG_##a = (1<<CMD_EX_##a),
    #include "smtpdef.h"
    LOG_FLAG_UNKNOWN = (1<<CMD_EX_UNKNOWN)
};

#define DEFAULT_CMD_LOG_FLAGS           LOG_FLAG_HELO | \
                                        LOG_FLAG_EHLO | \
                                        LOG_FLAG_MAIL | \
                                        LOG_FLAG_RCPT | \
                                        LOG_FLAG_DATA | \
                                        LOG_FLAG_QUIT | \
                    LOG_FLAG_ETRN | \
                    LOG_FLAG_VRFY | \
                    LOG_FLAG_STARTTLS |\
                    LOG_FLAG_AUTH |\
                    LOG_FLAG_TURN |\
                    LOG_FLAG_BDAT |\
                                        LOG_FLAG_UNKNOWN

/*++

        Returns a UniqueFilename for an e-mail message.
        The caller should loop through this call and a call to
        CreateFile with the CREATE_NEW flag. If the Create fails due
        to YYY, then the caller should loop again.

    Arguments:

        psz - a buffer
        pdw - IN the size of the buffer,
              OUT: the size of the buffer needed (error == ERROR_MORE_DATA)
                   or the size of the filename.

    Returns:

        TRUE on SUCCESS
        FALSE if buffer isn't big enough.

--*/
BOOL    GetUniqueFilename(
    IN OUT  LPTSTR  psz,
    IN OUT  LPDWORD pdw
    );

BOOL CreateLayerDirectory( char * str );

#define RESOLUTION_UNCACHEDDNS          0x00000001
#define RESOLUTION_GETHOSTBYNAME        0x00000002
#define RESOULTION_DNS_GETHOSTBYNAME    0x00000003


#endif // _SMTPDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\makefile.inc ===
$(O)\seo.h $(O)\seo_i.c : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(O)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqueue.h $(O)\aqueue_i.c : $(STAXINC)\export\aqueue.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqueue_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqueue_i.c \
    -header $@ \
    -tlb $(O)\aqueue.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpdisp.h $(O)\smtpdisp_i.c : $(STAXINC)\export\smtpdisp.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpdisp_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpdisp_i.c \
    -header $@ \
    -tlb $(O)\smtpdisp.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\imsg.h $(O)\imsg_i.c : $(STAXINC)\export\imsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\imsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\imsg_i.c \
    -header $@ \
    -tlb $(O)\imsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpevent.h $(O)\smtpevent_i.c : $(STAXINC)\export\smtpevent.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpevent_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpevent_i.c \
    -header $@ \
    -tlb $(O)\smtpevent.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\cdo.h $(O)\cdo_i.c : $(STAXINC)\cdo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\cdo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\cdo_i.c \
    -header $@ \
    -tlb $(O)\cdo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\wstgado.h $(O)\wstgado_i.c : $(STAXINC)\export\wstgado.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\wstgado_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\wstgado_i.c \
    -header $@ \
    -tlb $(O)\wstagado.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\pe_disp.h $(O)\pe_disp_i.c : $(STAXINC)\export\pe_disp.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\pe_disp_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\pe_disp_i.c \
    -header $@ \
    -tlb $(O)\pe_disp.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpsvc.h $(O)\smtpsvc_s.c : ..\smtpsvc.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -oldnames \
    -client none \
    -sstub $(O)\smtpsvc_s.c \
    -header $@ \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

!ifndef INETAMSG_MC_PATH
INETAMSG_MC_PATH=..\..\..\inc
!endif
$(O)\smtpmsg.h $(O)\smtpmsg.rc $(O)\msg00001.bin: smtpmsg.mc $(INETAMSG_MC_PATH)\inetamsg.mc $(STAXINC)\export\aqerr.mc $(STAXINC)\export\phatqmsg.mc $(STAXINC)\export\caterr.mc
    copy /a $(INETAMSG_MC_PATH)\inetamsg.mc + /a smtpmsg.mc + /a $(STAXINC)\export\aqerr.mc + /a $(STAXINC)\export\phatqmsg.mc + /a $(STAXINC)\export\caterr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\smtpmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\smtpmsg.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\headers.cxx ===
/*
 * Copyright (c) 1983, 1995 Eric P. Allman
 * Copyright (c) 1988, 1993
 *    The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by the University of
 *    California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "smtpinc.h"
#include <listmacr.h>
#include "headers.hxx"

int strcasecmp(char *s1, char *s2);
int strncasecmp(char *s1, char *s2, int n);

struct hdrinfo
{
    char    *hi_field;    /* the name of the field */
    unsigned int    hi_flags;    /* status bits, see below */
};

struct hdrinfo    HdrInfo[] =
{
        /* originator fields, most to least significant  */
    "resent-sender",      H_FROM|H_RESENT,
    "resent-from",        H_FROM|H_RESENT,
    "resent-reply-to",    H_FROM|H_RESENT,
    "sender",             H_FROM,
    "from",               H_FROM,
    "reply-to",           H_FROM,
    "full-name",          0,
    "return-receipt-to",  H_FROM|H_RECEIPTTO,
    "errors-to",          H_FROM|H_ERRORSTO,

        /* destination fields */
    "to",                 H_RCPT,
    "resent-to",          H_RCPT|H_RESENT,
    "cc",                 H_RCPT,
    "resent-cc",          H_RCPT|H_RESENT,
    "bcc",                H_RCPT,
    "resent-bcc",         H_RCPT|H_RESENT,
    "apparently-to",      H_RCPT,

        /* message identification and control */
    "message-id",         H_MID,
    "resent-message-id",  H_RESENT,

        /* date fields */
    "date",               H_DATE,
    "resent-date",        H_RESENT,

        /* trace fields */
    "received",           0,
    "x400-received",      0,
    "via",                0,
    "mail-from",          H_TRACE,

        /* miscellaneous fields */
    "comments",           0,
    "return-path",        H_RETURNPATH,
    "subject",            H_SUBJECT,

        /* X-Headers */
    "x-sender",           H_X_SENDER,
    "x-receiver",         H_X_RECEIVER,


    // 10/15/98 - MikeSwa Added supersedes headers
    "x-msgguid",          H_X_MSGGUID,
    "x-supersedesmsgguid",H_X_SUPERSEDES_MSGGUID,

    // 12/18/98 -- pgopi. Added X-originalArrivalTime header
    "x-originalarrivaltime" , H_X_ORIGINAL_ARRIVAL_TIME,
    
    NULL,                 0,
};


#define xalloc(size) HeapAlloc(GetProcessHeap(), 0, size)
/*
**  CHOMPHEADER -- process and save a header line.
**
**    Called by collect and by readcf to deal with header lines.
**
**    Parameters:
**        line -- header as a text line.
**        def -- if set, this is a default value.
**        hdrp -- a pointer to the place to save the header.
**        e -- the envelope including this header.
**
**    Returns:
**        flags for this header.
**
**    Side Effects:
**        The header is saved on the header list.
**        Contents of 'line' are destroyed.
*/
BOOL ChompHeader(char * line, DWORD& HeaderFlags, char ** ppszValueBuf)
{
    register char *p = line;
    HEADERVAL *h = NULL;
    char *fname = NULL;
    char *fvalue = NULL;
    char *oldfvalue = NULL;
    struct hdrinfo *hi = NULL;
    DWORD fNameSize;


    /* find canonical name */
    fname = p;

    while (isascii(*p) && isgraph(*p) && *p != ':')
             p++;

    fvalue = p;

    while (isascii(*p) && isspace(*p))
           p++;

    //See if we had anything atall
    if(p == line)
    {
        //We had a seperator CRLF
        HeaderFlags |= H_EOH;
        return (FALSE);
    }

    if (*p++ != ':' || fname == fvalue)
    {
        //syserr("553 header syntax error, line \"%s\"", line);
        return (FALSE);
    }

    fvalue = p;

    if(ppszValueBuf)
        *ppszValueBuf = fvalue;

    fNameSize = (DWORD)((p - line) - 1);

    /* see if it is a known type */
    for (hi = HdrInfo; hi->hi_field != NULL; hi++)
     {
         if (strncasecmp(hi->hi_field, fname, fNameSize) == 0)
          {
              HeaderFlags |= hi->hi_flags; //set our flag
              break;
          }
      }

    return (TRUE);
}


#if 0
/*
**  ADDHEADER -- add a header entry to the end of the queue.
**
**    This bypasses the special checking of chompheader.
**
**    Parameters:
**        field -- the name of the header field.
**        value -- the value of the field.
**        hp -- an indirect pointer to the header structure list.
**
**    Returns:
**        none.
**
**    Side Effects:
**        adds the field on the list of headers for this envelope.
*/

void
addheader(field, value, hdrlist)
    char *field;
    char *value;
    HDR **hdrlist;
{
    register HDR *h;
    register struct hdrinfo *hi;
    HDR **hp;

    /* find info struct */
    for (hi = HdrInfo; hi->hi_field != NULL; hi++)
    {
        if (strcasecmp(field, hi->hi_field) == 0)
            break;
    }

    /* find current place in list -- keep back pointer? */
    for (hp = hdrlist; (h = *hp) != NULL; hp = &h->h_link)
    {
        if (strcasecmp(field, h->h_field) == 0)
            break;
    }

    /* allocate space for new header */
    h = (HDR *) xalloc(sizeof *h);
    h->h_field = field;
    h->h_value = newstr(value);
    h->h_link = *hp;
    h->h_flags = hi->hi_flags | H_DEFAULT;
    clrbitmap(h->h_mflags);
    *hp = h;
}
/*
**  HVALUE -- return value of a header.
**
**    Only "real" fields (i.e., ones that have not been supplied
**    as a default) are used.
**
**    Parameters:
**        field -- the field name.
**        header -- the header list.
**
**    Returns:
**        pointer to the value part.
**        NULL if not found.
**
**    Side Effects:
**        none.
*/

char * hvalue(char * field, HDR * header)
{
    register HDR *h;

    for (h = header; h != NULL; h = h->h_link)
    {
        if (!bitset(H_DEFAULT, h->h_flags) &&
            strcasecmp(h->h_field, field) == 0)
            return (h->h_value);
    }
    return (NULL);
}
#endif

/*
**  ISHEADER -- predicate telling if argument is a header.
**
**    A line is a header if it has a single word followed by
**    optional white space followed by a colon.
**
**    Header fields beginning with two dashes, although technically
**    permitted by RFC822, are automatically rejected in order
**    to make MIME work out.  Without this we could have a technically
**    legal header such as ``--"foo:bar"'' that would also be a legal
**    MIME separator.
**
**    Parameters:
**        h -- string to check for possible headerness.
**
**    Returns:
**        TRUE if h is a header.
**        FALSE otherwise.
**
**    Side Effects:
**        none.
*/

BOOL IsHeader(char *h)
{
    register char *s = h;

    if (s[0] == '-' && s[1] == '-')
        return FALSE;

    while (*s > ' ' && *s != ':' && *s != '\0')
        s++;

    if (h == s)
        return FALSE;

    /* following technically violates RFC822 */
    while (isascii(*s) && isspace(*s))
        s++;

    return (*s == ':');
}

#if 0
/*
**  EATHEADER -- run through the stored header and extract info.
**
**    Parameters:
**        e -- the envelope to process.
**        full -- if set, do full processing (e.g., compute
**            message priority).  This should not be set
**            when reading a queue file because some info
**            needed to compute the priority is wrong.
**
**    Returns:
**        none.
**
**    Side Effects:
**        Sets a bunch of global variables from information
**            in the collected header.
**        Aborts the message if the hop count is exceeded.
*/

void
eatheader(e, full)
    register ENVELOPE *e;
    bool full;
{
    register HDR *h;
    register char *p;
    int hopcnt = 0;
    char *msgid;
    char buf[MAXLINE];

    /*
    **  Set up macros for possible expansion in headers.
    */

    define('f', e->e_sender, e);
    define('g', e->e_sender, e);
    if (e->e_origrcpt != NULL && *e->e_origrcpt != '\0')
        define('u', e->e_origrcpt, e);
    else
        define('u', NULL, e);

    /* full name of from person */
    p = hvalue("full-name", e->e_header);
    if (p != NULL)
        define('x', p, e);

    if (tTd(32, 1))
        printf("----- collected header -----\n");
    msgid = NULL;
    for (h = e->e_header; h != NULL; h = h->h_link)
    {
        if (tTd(32, 1))
            printf("%s: ", h->h_field);
        if (h->h_value == NULL)
        {
            if (tTd(32, 1))
                printf("<NULL>\n");
            continue;
        }

        /* do early binding */
        if (bitset(H_DEFAULT, h->h_flags))
        {
            if (tTd(32, 1))
            {
                printf("(");
                xputs(h->h_value);
                printf(") ");
            }
            expand(h->h_value, buf, sizeof buf, e);
            if (buf[0] != '\0')
            {
                if (bitset(H_FROM, h->h_flags))
                {
                    extern char *crackaddr();

                    expand(crackaddr(buf), buf, sizeof buf, e);
                }
                h->h_value = newstr(buf);
                h->h_flags &= ~H_DEFAULT;
            }
        }

        if (tTd(32, 1))
        {
            xputs(h->h_value);
            printf("\n");
        }

        /* count the number of times it has been processed */
        if (bitset(H_TRACE, h->h_flags))
            hopcnt++;

        /* send to this person if we so desire */
        if (GrabTo && bitset(H_RCPT, h->h_flags) &&
            !bitset(H_DEFAULT, h->h_flags) &&
            (!bitset(EF_RESENT, e->e_flags) || bitset(H_RESENT, h->h_flags)))
        {
            int saveflags = e->e_flags;

            (void) sendtolist(h->h_value, NULLADDR,
                      &e->e_sendqueue, 0, e);

            /* delete fatal errors generated by this address */
            if (!GrabTo && !bitset(EF_FATALERRS, saveflags))
                e->e_flags &= ~EF_FATALERRS;
        }

        /* save the message-id for logging */
        p = "resent-message-id";
        if (!bitset(EF_RESENT, e->e_flags))
            p += 7;
        if (strcasecmp(h->h_field, p) == 0)
        {
            msgid = h->h_value;
            while (isascii(*msgid) && isspace(*msgid))
                msgid++;
        }

        /* see if this is a return-receipt header */
        if (bitset(H_RECEIPTTO, h->h_flags))
            e->e_receiptto = h->h_value;
    }
    if (tTd(32, 1))
        printf("----------------------------\n");

    /* if we are just verifying (that is, sendmail -t -bv), drop out now */
    if (OpMode == MD_VERIFY)
        return;

    /* store hop count */
    if (hopcnt > e->e_hopcount)
        e->e_hopcount = hopcnt;

    /* message priority */
    p = hvalue("precedence", e->e_header);
    if (p != NULL)
        e->e_class = priencode(p);
    if (e->e_class < 0)
        e->e_timeoutclass = TOC_NONURGENT;
    else if (e->e_class > 0)
        e->e_timeoutclass = TOC_URGENT;
    if (full)
    {
        e->e_msgpriority = e->e_msgsize
                 - e->e_class * WkClassFact
                 + e->e_nrcpts * WkRecipFact;
    }

    /* message timeout priority */
    p = hvalue("priority", e->e_header);
    if (p != NULL)
    {
        /* (this should be in the configuration file) */
        if (strcasecmp(p, "urgent"))
            e->e_timeoutclass = TOC_URGENT;
        else if (strcasecmp(p, "normal"))
            e->e_timeoutclass = TOC_NORMAL;
        else if (strcasecmp(p, "non-urgent"))
            e->e_timeoutclass = TOC_NONURGENT;
    }

    /* date message originated */
    p = hvalue("posted-date", e->e_header);
    if (p == NULL)
        p = hvalue("date", e->e_header);
    if (p != NULL)
        define('a', p, e);

    /* check to see if this is a MIME message */
    if ((e->e_bodytype != NULL &&
         strcasecmp(e->e_bodytype, "8BITMIME") == 0) ||
        hvalue("MIME-Version", e->e_header) != NULL)
    {
        e->e_flags |= EF_IS_MIME;
        if (HasEightBits)
            e->e_bodytype = "8BITMIME";
    }
    else if ((p = hvalue("Content-Type", e->e_header)) != NULL)
    {
        /* this may be an RFC 1049 message */
        p = strpbrk(p, ";/");
        if (p == NULL || *p == ';')
        {
            /* yep, it is */
            e->e_flags |= EF_DONT_MIME;
        }
    }

    /*
    **  From person in antiquated ARPANET mode
    **    required by UK Grey Book e-mail gateways (sigh)
    */

    if (OpMode == MD_ARPAFTP)
    {
        register struct hdrinfo *hi;

        for (hi = HdrInfo; hi->hi_field != NULL; hi++)
        {
            if (bitset(H_FROM, hi->hi_flags) &&
                (!bitset(H_RESENT, hi->hi_flags) ||
                 bitset(EF_RESENT, e->e_flags)) &&
                (p = hvalue(hi->hi_field, e->e_header)) != NULL)
                break;
        }
        if (hi->hi_field != NULL)
        {
            if (tTd(32, 2))
                printf("eatheader: setsender(*%s == %s)\n",
                    hi->hi_field, p);
            setsender(p, e, NULL, TRUE);
        }
    }

    /*
    **  Log collection information.
    */

# ifdef LOG
    if (bitset(EF_LOGSENDER, e->e_flags) && LogLevel > 4)
        logsender(e, msgid);
# endif /* LOG */
    e->e_flags &= ~EF_LOGSENDER;
}
/*
**  LOGSENDER -- log sender information
**
**    Parameters:
**        e -- the envelope to log
**        msgid -- the message id
**
**    Returns:
**        none
*/

void
logsender(e, msgid)
    register ENVELOPE *e;
    char *msgid;
{
# ifdef LOG
    char *name;
    register char *sbp;
    register char *p;
    int l;
    char hbuf[MAXNAME + 1];
    char sbuf[MAXLINE + 1];
    char mbuf[MAXNAME + 1];

    /* don't allow newlines in the message-id */
    if (msgid != NULL)
    {
        l = strlen(msgid);
        if (l > sizeof mbuf - 1)
            l = sizeof mbuf - 1;
        bcopy(msgid, mbuf, l);
        mbuf[l] = '\0';
        p = mbuf;
        while ((p = strchr(p, '\n')) != NULL)
            *p++ = ' ';
    }

    if (bitset(EF_RESPONSE, e->e_flags))
        name = "[RESPONSE]";
    else if ((name = macvalue('_', e)) != NULL)
        ;
    else if (RealHostName == NULL)
        name = "localhost";
    else if (RealHostName[0] == '[')
        name = RealHostName;
    else
    {
        name = hbuf;
        (void) sprintf(hbuf, "%.80s", RealHostName);
        if (RealHostAddr.sa.sa_family != 0)
        {
            p = &hbuf[strlen(hbuf)];
            (void) sprintf(p, " (%s)",
                anynet_ntoa(&RealHostAddr));
        }
    }

    /* some versions of syslog only take 5 printf args */
#  if (SYSLOG_BUFSIZE) >= 256
    sbp = sbuf;
    sprintf(sbp, "from=%.200s, size=%ld, class=%d, pri=%ld, nrcpts=%d",
        e->e_from.q_paddr == NULL ? "<NONE>" : e->e_from.q_paddr,
        e->e_msgsize, e->e_class, e->e_msgpriority, e->e_nrcpts);
    sbp += strlen(sbp);
    if (msgid != NULL)
    {
        sprintf(sbp, ", msgid=%.100s", mbuf);
        sbp += strlen(sbp);
    }
    if (e->e_bodytype != NULL)
    {
        (void) sprintf(sbp, ", bodytype=%.20s", e->e_bodytype);
        sbp += strlen(sbp);
    }
    p = macvalue('r', e);
    if (p != NULL)
        (void) sprintf(sbp, ", proto=%.20s", p);
    syslog(LOG_INFO, "%s: %s, relay=%s",
        e->e_id, sbuf, name);

#  else            /* short syslog buffer */

    syslog(LOG_INFO, "%s: from=%s",
        e->e_id, e->e_from.q_paddr == NULL ? "<NONE>" :
                shortenstring(e->e_from.q_paddr, 83));
    syslog(LOG_INFO, "%s: size=%ld, class=%ld, pri=%ld, nrcpts=%d",
        e->e_id, e->e_msgsize, e->e_class,
        e->e_msgpriority, e->e_nrcpts);
    if (msgid != NULL)
        syslog(LOG_INFO, "%s: msgid=%s", e->e_id, mbuf);
    sbp = sbuf;
    sprintf(sbp, "%s:", e->e_id);
    sbp += strlen(sbp);
    if (e->e_bodytype != NULL)
    {
        sprintf(sbp, " bodytype=%s,", e->e_bodytype);
        sbp += strlen(sbp);
    }
    p = macvalue('r', e);
    if (p != NULL)
    {
        sprintf(sbp, " proto=%s,", p);
        sbp += strlen(sbp);
    }
    syslog(LOG_INFO, "%s relay=%s", sbuf, name);
#  endif
# endif
}
/*
**  PRIENCODE -- encode external priority names into internal values.
**
**    Parameters:
**        p -- priority in ascii.
**
**    Returns:
**        priority as a numeric level.
**
**    Side Effects:
**        none.
*/

int
priencode(p)
    char *p;
{
    register int i;

    for (i = 0; i < NumPriorities; i++)
    {
        if (!strcasecmp(p, Priorities[i].pri_name))
            return (Priorities[i].pri_val);
    }

    /* unknown priority */
    return (0);
}
/*
**  CRACKADDR -- parse an address and turn it into a macro
**
**    This doesn't actually parse the address -- it just extracts
**    it and replaces it with "$g".  The parse is totally ad hoc
**    and isn't even guaranteed to leave something syntactically
**    identical to what it started with.  However, it does leave
**    something semantically identical.
**
**    This algorithm has been cleaned up to handle a wider range
**    of cases -- notably quoted and backslash escaped strings.
**    This modification makes it substantially better at preserving
**    the original syntax.
**
**    Parameters:
**        addr -- the address to be cracked.
**
**    Returns:
**        a pointer to the new version.
**
**    Side Effects:
**        none.
**
**    Warning:
**        The return value is saved in local storage and should
**        be copied if it is to be reused.
*/

char *
crackaddr(addr)
    register char *addr;
{
    register char *p;
    register char c;
    int cmtlev;
    int realcmtlev;
    int anglelev, realanglelev;
    int copylev;
    bool qmode;
    bool realqmode;
    bool skipping;
    bool putgmac = FALSE;
    bool quoteit = FALSE;
    bool gotangle = FALSE;
    bool gotcolon = FALSE;
    register char *bp;
    char *buflim;
    char *bufhead;
    char *addrhead;
    static char buf[MAXNAME + 1];

    if (tTd(33, 1))
        printf("crackaddr(%s)\n", addr);

    /* strip leading spaces */
    while (*addr != '\0' && isascii(*addr) && isspace(*addr))
        addr++;

    /*
    **  Start by assuming we have no angle brackets.  This will be
    **  adjusted later if we find them.
    */

    bp = bufhead = buf;
    buflim = &buf[sizeof buf - 5];
    p = addrhead = addr;
    copylev = anglelev = realanglelev = cmtlev = realcmtlev = 0;
    qmode = realqmode = FALSE;

    while ((c = *p++) != '\0')
    {
        /*
        **  If the buffer is overful, go into a special "skipping"
        **  mode that tries to keep legal syntax but doesn't actually
        **  output things.
        */

        skipping = bp >= buflim;

        if (copylev > 0 && !skipping)
            *bp++ = c;

        /* check for backslash escapes */
        if (c == '\\')
        {
            /* arrange to quote the address */
            if (cmtlev <= 0 && !qmode)
                quoteit = TRUE;

            if ((c = *p++) == '\0')
            {
                /* too far */
                p--;
                goto putg;
            }
            if (copylev > 0 && !skipping)
                *bp++ = c;
            goto putg;
        }

        /* check for quoted strings */
        if (c == '"' && cmtlev <= 0)
        {
            qmode = !qmode;
            if (copylev > 0 && !skipping)
                realqmode = !realqmode;
            continue;
        }
        if (qmode)
            goto putg;

        /* check for comments */
        if (c == '(')
        {
            cmtlev++;

            /* allow space for closing paren */
            if (!skipping)
            {
                buflim--;
                realcmtlev++;
                if (copylev++ <= 0)
                {
                    *bp++ = ' ';
                    *bp++ = c;
                }
            }
        }
        if (cmtlev > 0)
        {
            if (c == ')')
            {
                cmtlev--;
                copylev--;
                if (!skipping)
                {
                    realcmtlev--;
                    buflim++;
                }
            }
            continue;
        }
        else if (c == ')')
        {
            /* syntax error: unmatched ) */
            if (copylev > 0 && !skipping)
                bp--;
        }

        /* check for group: list; syntax */
        if (c == ':' && anglelev <= 0 && !gotcolon && !ColonOkInAddr)
        {
            register char *q;

            if (*p == ':')
            {
                /* special case -- :: syntax */
                if (cmtlev <= 0 && !qmode)
                    quoteit = TRUE;
                if (copylev > 0 && !skipping)
                {
                    *bp++ = c;
                    *bp++ = c;
                }
                p++;
                goto putg;
            }

            gotcolon = TRUE;

            bp = bufhead;
            if (quoteit)
            {
                *bp++ = '"';

                /* back up over the ':' and any spaces */
                --p;
                while (isascii(*--p) && isspace(*p))
                    continue;
                p++;
            }
            for (q = addrhead; q < p; )
            {
                c = *q++;
                if (bp < buflim)
                {
                    if (quoteit && c == '"')
                        *bp++ = '\\';
                    *bp++ = c;
                }
            }
            if (quoteit)
            {
                if (bp == &bufhead[1])
                    bp--;
                else
                    *bp++ = '"';
                while ((c = *p++) != ':')
                {
                    if (bp < buflim)
                        *bp++ = c;
                }
                *bp++ = c;
            }

            /* any trailing white space is part of group: */
            while (isascii(*p) && isspace(*p) && bp < buflim)
                *bp++ = *p++;
            copylev = 0;
            putgmac = quoteit = FALSE;
            bufhead = bp;
            addrhead = p;
            continue;
        }

        if (c == ';' && copylev <= 0 && !ColonOkInAddr)
        {
            if (bp < buflim)
                *bp++ = c;
        }

        /* check for characters that may have to be quoted */
        if (strchr(MustQuoteChars, c) != NULL)
        {
            /*
            **  If these occur as the phrase part of a <>
            **  construct, but are not inside of () or already
            **  quoted, they will have to be quoted.  Note that
            **  now (but don't actually do the quoting).
            */

            if (cmtlev <= 0 && !qmode)
                quoteit = TRUE;
        }

        /* check for angle brackets */
        if (c == '<')
        {
            register char *q;

            /* assume first of two angles is bogus */
            if (gotangle)
                quoteit = TRUE;
            gotangle = TRUE;

            /* oops -- have to change our mind */
            anglelev = 1;
            if (!skipping)
                realanglelev = 1;

            bp = bufhead;
            if (quoteit)
            {
                *bp++ = '"';

                /* back up over the '<' and any spaces */
                --p;
                while (isascii(*--p) && isspace(*p))
                    continue;
                p++;
            }
            for (q = addrhead; q < p; )
            {
                c = *q++;
                if (bp < buflim)
                {
                    if (quoteit && c == '"')
                        *bp++ = '\\';
                    *bp++ = c;
                }
            }
            if (quoteit)
            {
                if (bp == &buf[1])
                    bp--;
                else
                    *bp++ = '"';
                while ((c = *p++) != '<')
                {
                    if (bp < buflim)
                        *bp++ = c;
                }
                *bp++ = c;
            }
            copylev = 0;
            putgmac = quoteit = FALSE;
            continue;
        }

        if (c == '>')
        {
            if (anglelev > 0)
            {
                anglelev--;
                if (!skipping)
                {
                    realanglelev--;
                    buflim++;
                }
            }
            else if (!skipping)
            {
                /* syntax error: unmatched > */
                if (copylev > 0)
                    bp--;
                quoteit = TRUE;
                continue;
            }
            if (copylev++ <= 0)
                *bp++ = c;
            continue;
        }

        /* must be a real address character */
    putg:
        if (copylev <= 0 && !putgmac)
        {
            *bp++ = MACROEXPAND;
            *bp++ = 'g';
            putgmac = TRUE;
        }
    }

    /* repair any syntactic damage */
    if (realqmode)
        *bp++ = '"';
    while (realcmtlev-- > 0)
        *bp++ = ')';
    while (realanglelev-- > 0)
        *bp++ = '>';
    *bp++ = '\0';

    if (tTd(33, 1))
        printf("crackaddr=>`%s'\n", buf);

    return (buf);
}
/*
**  PUTHEADER -- put the header part of a message from the in-core copy
**
**    Parameters:
**        mci -- the connection information.
**        h -- the header to put.
**        e -- envelope to use.
**
**    Returns:
**        none.
**
**    Side Effects:
**        none.
*/

/*
 * Macro for fast max (not available in e.g. DG/UX, 386/ix).
 */
#ifndef MAX
# define MAX(a,b) (((a)>(b))?(a):(b))
#endif

void
putheader(mci, h, e)
    register MCI *mci;
    register HDR *h;
    register ENVELOPE *e;
{
    char buf[MAX(MAXLINE,BUFSIZ)];
    char obuf[MAXLINE];

    if (tTd(34, 1))
        printf("--- putheader, mailer = %s ---\n",
            mci->mci_mailer->m_name);

    mci->mci_flags |= MCIF_INHEADER;
    for (; h != NULL; h = h->h_link)
    {
        register char *p = h->h_value;
        extern bool bitintersect();

        if (tTd(34, 11))
        {
            printf("  %s: ", h->h_field);
            xputs(p);
        }

        /* suppress Content-Transfer-Encoding: if we are MIMEing */
        if (bitset(H_CTE, h->h_flags) &&
            bitset(MCIF_CVT8TO7|MCIF_INMIME, mci->mci_flags))
        {
            if (tTd(34, 11))
                printf(" (skipped (content-transfer-encoding))\n");
            continue;
        }

        if (bitset(MCIF_INMIME, mci->mci_flags))
            goto vanilla;

        if (bitset(H_CHECK|H_ACHECK, h->h_flags) &&
            !bitintersect(h->h_mflags, mci->mci_mailer->m_flags))
        {
            if (tTd(34, 11))
                printf(" (skipped)\n");
            continue;
        }

        /* handle Resent-... headers specially */
        if (bitset(H_RESENT, h->h_flags) && !bitset(EF_RESENT, e->e_flags))
        {
            if (tTd(34, 11))
                printf(" (skipped (resent))\n");
            continue;
        }

        /* suppress return receipts if requested */
        if (bitset(H_RECEIPTTO, h->h_flags) &&
            bitset(EF_NORECEIPT, e->e_flags))
        {
            if (tTd(34, 11))
                printf(" (skipped (receipt))\n");
            continue;
        }

        /* macro expand value if generated internally */
        if (bitset(H_DEFAULT, h->h_flags))
        {
            expand(p, buf, sizeof buf, e);
            p = buf;
            if (p == NULL || *p == '\0')
            {
                if (tTd(34, 11))
                    printf(" (skipped -- null value)\n");
                continue;
            }
        }

        if (tTd(34, 11))
            printf("\n");

        if (bitset(H_STRIPVAL, h->h_flags))
        {
            /* empty field */
            (void) sprintf(obuf, "%s:", h->h_field);
            putline(obuf, mci);
        }
        else if (bitset(H_FROM|H_RCPT, h->h_flags))
        {
            /* address field */
            bool oldstyle = bitset(EF_OLDSTYLE, e->e_flags);

            if (bitset(H_FROM, h->h_flags))
                oldstyle = FALSE;
            commaize(h, p, oldstyle, mci, e);
        }
        else
        {
            /* vanilla header line */
            register char *nlp;

vanilla:
            (void) sprintf(obuf, "%s: ", h->h_field);
            while ((nlp = strchr(p, '\n')) != NULL)
            {
                *nlp = '\0';
                (void) strcat(obuf, p);
                *nlp = '\n';
                putline(obuf, mci);
                p = ++nlp;
                obuf[0] = '\0';
            }
            (void) strcat(obuf, p);
            putline(obuf, mci);
        }
    }

    /*
    **  If we are converting this to a MIME message, add the
    **  MIME headers.
    */

#if MIME8TO7
    if (bitset(MM_MIME8BIT, MimeMode) &&
        bitset(EF_HAS8BIT, e->e_flags) &&
        !bitset(EF_DONT_MIME, e->e_flags) &&
        !bitnset(M_8BITS, mci->mci_mailer->m_flags) &&
        !bitset(MCIF_CVT8TO7, mci->mci_flags))
    {
        if (hvalue("MIME-Version", e->e_header) == NULL)
            putline("MIME-Version: 1.0", mci);
        if (hvalue("Content-Type", e->e_header) == NULL)
        {
            sprintf(obuf, "Content-Type: text/plain; charset=%s",
                defcharset(e));
            putline(obuf, mci);
        }
        if (hvalue("Content-Transfer-Encoding", e->e_header) == NULL)
            putline("Content-Transfer-Encoding: 8bit", mci);
    }
#endif
}
/*
**  COMMAIZE -- output a header field, making a comma-translated list.
**
**    Parameters:
**        h -- the header field to output.
**        p -- the value to put in it.
**        oldstyle -- TRUE if this is an old style header.
**        mci -- the connection information.
**        e -- the envelope containing the message.
**
**    Returns:
**        none.
**
**    Side Effects:
**        outputs "p" to file "fp".
*/

void
commaize(h, p, oldstyle, mci, e)
    register HDR *h;
    register char *p;
    bool oldstyle;
    register MCI *mci;
    register ENVELOPE *e;
{
    register char *obp;
    int opos;
    int omax;
    bool firstone = TRUE;
    char obuf[MAXLINE + 3];

    /*
    **  Output the address list translated by the
    **  mailer and with commas.
    */

    if (tTd(14, 2))
        printf("commaize(%s: %s)\n", h->h_field, p);

    obp = obuf;
    (void) sprintf(obp, "%s: ", h->h_field);
    opos = strlen(h->h_field) + 2;
    obp += opos;
    omax = mci->mci_mailer->m_linelimit - 2;
    if (omax < 0 || omax > 78)
        omax = 78;

    /*
    **  Run through the list of values.
    */

    while (*p != '\0')
    {
        register char *name;
        register int c;
        char savechar;
        int flags;
        auto int stat;

        /*
        **  Find the end of the name.  New style names
        **  end with a comma, old style names end with
        **  a space character.  However, spaces do not
        **  necessarily delimit an old-style name -- at
        **  signs mean keep going.
        */

        /* find end of name */
        while ((isascii(*p) && isspace(*p)) || *p == ',')
            p++;
        name = p;
        for (;;)
        {
            auto char *oldp;
            char pvpbuf[PSBUFSIZE];

            (void) prescan(p, oldstyle ? ' ' : ',', pvpbuf,
                       sizeof pvpbuf, &oldp, NULL);
            p = oldp;

            /* look to see if we have an at sign */
            while (*p != '\0' && isascii(*p) && isspace(*p))
                p++;

            if (*p != '@')
            {
                p = oldp;
                break;
            }
            p += *p == '@' ? 1 : 2;
            while (*p != '\0' && isascii(*p) && isspace(*p))
                p++;
        }
        /* at the end of one complete name */

        /* strip off trailing white space */
        while (p >= name &&
               ((isascii(*p) && isspace(*p)) || *p == ',' || *p == '\0'))
            p--;
        if (++p == name)
            continue;
        savechar = *p;
        *p = '\0';

        /* translate the name to be relative */
        flags = RF_HEADERADDR|RF_ADDDOMAIN;
        if (bitset(H_FROM, h->h_flags))
            flags |= RF_SENDERADDR;
#if USERDB
        else if (e->e_from.q_mailer != NULL &&
             bitnset(M_UDBRECIPIENT, e->e_from.q_mailer->m_flags))
        {
            extern char *udbsender();
            char *q;

            q = udbsender(name);
            if (q != NULL)
                name = q;
        }
#endif
        stat = EX_OK;
        name = remotename(name, mci->mci_mailer, flags, &stat, e);
        if (*name == '\0')
        {
            *p = savechar;
            continue;
        }

        /* output the name with nice formatting */
        opos += strlen(name);
        if (!firstone)
            opos += 2;
        if (opos > omax && !firstone)
        {
            (void) strcpy(obp, ",\n");
            putline(obuf, mci);
            obp = obuf;
            (void) strcpy(obp, "        ");
            opos = strlen(obp);
            obp += opos;
            opos += strlen(name);
        }
        else if (!firstone)
        {
            (void) strcpy(obp, ", ");
            obp += 2;
        }

        while ((c = *name++) != '\0' && obp < &obuf[MAXLINE])
            *obp++ = c;
        firstone = FALSE;
        *p = savechar;
    }
    (void) strcpy(obp, "\n");
    putline(obuf, mci);
}
/*
**  COPYHEADER -- copy header list
**
**    This routine is the equivalent of newstr for header lists
**
**    Parameters:
**        header -- list of header structures to copy.
**
**    Returns:
**        a copy of 'header'.
**
**    Side Effects:
**        none.
*/

HDR *
copyheader(header)
    register HDR *header;
{
    register HDR *newhdr;
    HDR *ret;
    register HDR **tail = &ret;

    while (header != NULL)
    {
        newhdr = (HDR *) xalloc(sizeof(HDR));
        STRUCTCOPY(*header, *newhdr);
        *tail = newhdr;
        tail = &newhdr->h_link;
        header = header->h_link;
    }
    *tail = NULL;

    return ret;
}
#endif*/

//-----------------------------------------------------------------------------
//  Description:
//      Given a header, this function parses it for CRLF<LWSP> sequences
//      unfolds it into a separate buffer, and returns the unfolded line. If
//      the header passed in is not folded, no unfolded line is returned.
//  Arguments:
//      IN CHAR *pszHeader - The folded header. *MUST* be a NULL terminated
//          string.
//      OUT CHAR **ppszUnfolded - If pszValueBuf is not folded, NULL is
//          returned otherwise a new buffer is allocated and pszValueBuf
//          unfolded into the buffer, and the buffer is returned in this
//          parameter. The buffer must be freed with FreeUnfoldedBuffer().
//  Returns:
//      TRUE on success.
//      FALSE on out of memory errors.
//-----------------------------------------------------------------------------
BOOL UnfoldHeader(char *pszHeader, char **ppszUnfolded)
{
    int cbHeader = 0;
    BOOL fUnfold = FALSE;

    *ppszUnfolded = NULL;

    // Check for embedded CRLF<LWSP> AND get length of pszHeader at the same time
    for(cbHeader = 0; pszHeader[cbHeader]; cbHeader++)
    {
        if(!fUnfold &&

           pszHeader[cbHeader] == '\r' &&

           (pszHeader[cbHeader + 1] &&
            pszHeader[cbHeader + 1] == '\n') &&

           (pszHeader[cbHeader + 2] &&
           (pszHeader[cbHeader + 2] == ' ' || pszHeader[cbHeader + 2] == '\t')))

        {
            fUnfold = TRUE;
        }
    }

    if(!fUnfold)
        return TRUE;

    *ppszUnfolded = new char[cbHeader + 1];
    if(!*ppszUnfolded)
        return FALSE;

    //
    // Copy pszHeader to *ppszUnfolded while skipping CRLF<LWSP> sequences
    //

    int i = 0;
    int j = 0;
    while(j < cbHeader)
    {
        if(pszHeader[j] == '\r' && (j+1 < cbHeader && pszHeader[j+1] == '\n'))
        {
            j += 2; // skip the CRLF we found

            while(j < cbHeader && (pszHeader[j] == ' ' || pszHeader[j] == '\t'))
                j++; // skip LWSP

            if(j >= cbHeader)
                break;
        }
        (*ppszUnfolded)[i++] = pszHeader[j++];
    }
    _ASSERT(i < cbHeader);
    (*ppszUnfolded)[i] = '\0';
    return TRUE;
}

void FreeUnfoldedHeader(char *pszHeader)
{
    delete [] pszHeader;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\iissmtp.cxx ===
/*++
   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        iissmtp.cxx

   Abstract:

        This module defines the SMTP_IIS_SERVICE class

   Author:

        Johnson Apacible    (JohnsonA)      June-04-1996
        Rohan Phillips      (Rohanp)        Feb-04-1997 - modified for smtp


--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include <smtpinet.h>
#include "aqstore.hxx"


//
// External reference to SEO helpers
//
extern HRESULT RegisterPlatSEOInstance(DWORD dwInstanceID);

BOOL
SMTP_IIS_SERVICE::AddInstanceInfo(
                     IN DWORD dwInstance,
                     IN BOOL fMigrateRoots
                     )
{
    HRESULT hr;
    PSMTP_SERVER_INSTANCE pInstance;
    MB      mb( (IMDCOM*) QueryMDObject() );

    TraceFunctEnterEx((LPARAM)this, "SMTP_IIS_SERVICE::AddInstanceInfo");

    //
    // Register the instance for server events
    //
    DebugTrace((LPARAM)this, "Registering SEO for instance %u", dwInstance);
    hr = RegisterPlatSEOInstance(dwInstance);
    if (FAILED(hr))
    {
        char szInst[10];

        ErrorTrace((LPARAM)this, "Instance %d: RegisterSEOInstance returned %08x",
                    dwInstance, hr);
        _itoa((int)dwInstance, szInst, 10);
        SmtpLogEventEx(SEO_REGISTER_INSTANCE_FAILED,
                        szInst,
                        hr);
    }

    //
    // Create the new instance
    //

    pInstance = new SMTP_SERVER_INSTANCE(
                                this,
                                dwInstance,
                                IPPORT_SMTP,
                                QueryRegParamKey(),
                                SMTP_ANONYMOUS_SECRET_W,
                                SMTP_ROOT_SECRET_W,
                                fMigrateRoots
                                );

    if(pInstance == NULL)
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    if (m_fCreatingInstance)
    {
        //We just received the notification for the creation of the metabase
        //object for a VS... none of the config information is there.  We do 
        //not want to attempt starting, becuase we will log that we cannot 
        //find out config info in the event log!

        DebugTrace((LPARAM)this,"Instnace not started on metabase creation");
        SetLastError( ERROR_SERVICE_DISABLED );
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE ;
    }

    return AddInstanceInfoHelper( pInstance );

} // SMTP_IIS_SERVICE::AddInstanceInfo

DWORD
SMTP_IIS_SERVICE::DisconnectUsersByInstance(
    IN IIS_SERVER_INSTANCE * pInstance
    )
/*++

    Virtual callback invoked by IIS_SERVER_INSTANCE::StopInstance() to
    disconnect all users associated with the given instance.

    Arguments:

        pInstance - All users associated with this instance will be
            forcibly disconnected.

--*/
{

    ((SMTP_SERVER_INSTANCE *)pInstance)->DisconnectAllConnections();
    return NO_ERROR;

}   // SMTP_IIS_SERVICE::DisconnectUsersByInstance


DWORD
SMTP_IIS_SERVICE::GetServiceConfigInfoSize(
                    IN DWORD dwLevel
                    )
{
    switch (dwLevel) {
    case 1:
        return sizeof(SMTP_CONFIG_INFO);
    }

    return 0;

} // SMTP_IIS_SERVICE::GetServerConfigInfoSize


VOID
SMTP_IIS_SERVICE::StartHintFunction()
{

    if (QueryCurrentServiceState() == SERVICE_START_PENDING )
    {
        UpdateServiceStatus(SERVICE_START_PENDING, NO_ERROR, m_dwStartHint,SERVICE_START_WAIT_HINT);
        m_dwStartHint++;
    }
}


SMTP_IIS_SERVICE::SMTP_IIS_SERVICE(
        IN  LPCSTR                           pszServiceName,
        IN  LPCSTR                           pszModuleName,
        IN  LPCSTR                           pszRegParamKey,
        IN  DWORD                            dwServiceId,
        IN  ULONGLONG                        SvcLocId,
        IN  BOOL                             MultipleInstanceSupport,
        IN  DWORD                            cbAcceptExRecvBuffer,
        IN  ATQ_CONNECT_CALLBACK             pfnConnect,
        IN  ATQ_COMPLETION                   pfnConnectEx,
        IN  ATQ_COMPLETION                   pfnIoCompletion
        ) : IIS_SERVICE( pszServiceName,
                         pszModuleName,
                         pszRegParamKey,
                         dwServiceId,
                         SvcLocId,
                         MultipleInstanceSupport,
                         cbAcceptExRecvBuffer,
                         pfnConnect,
                         pfnConnectEx,
                         pfnIoCompletion
                         )
{

    MB          mb( (IMDCOM*) QueryMDObject() );
    DWORD       MaxPoolThreadValue = 0;


    TraceFunctEnterEx((LPARAM)this, "SMTP_IIS_SERVICE::SMTP_IIS_SERVICE");

    m_OldMaxPoolThreadValue = 0;
    m_cMaxSystemRoutingThreads = 0;
    m_cCurrentSystemRoutingThreads = 0;
    m_fHaveResetPrincipalNames = FALSE;

    //
    // configure the number of SMTP routing threads and IIS pool threads.
    //

    m_dwStartHint = 2;
    m_OldMaxPoolThreadValue = 0;

    MaxPoolThreadValue = (DWORD)AtqGetInfo(AtqMaxPoolThreads);

    if(MaxPoolThreadValue < 15)
        m_OldMaxPoolThreadValue = (DWORD)AtqSetInfo(AtqMaxPoolThreads, 15);

    m_fCreatingInstance = FALSE;

    InitializeListHead(&m_InstanceInfoList);
    TraceFunctLeaveEx((LPARAM)this);

} // SMTP_IIS_SERVICE::SMTP_IIS_SERVICE

BOOL
SMTP_IIS_SERVICE::AggregateStatistics(
        IN PCHAR    pDestination,
        IN PCHAR    pSource
        )
{

    LPSMTP_STATISTICS_0   pStatDest = (LPSMTP_STATISTICS_0) pDestination;
    LPSMTP_STATISTICS_0   pStatSrc  = (LPSMTP_STATISTICS_0) pSource;

    if ((NULL == pDestination) || (NULL == pSource))
    {
        return FALSE;
    }

    pStatDest->BytesSentTotal       += pStatSrc->BytesSentTotal;
    pStatDest->BytesRcvdTotal       += pStatSrc->BytesRcvdTotal;

    pStatDest->BytesSentMsg         += pStatSrc->BytesSentMsg;
    pStatDest->BytesRcvdMsg         += pStatSrc->BytesRcvdMsg;
    pStatDest->NumMsgRecvd          += pStatSrc->NumMsgRecvd;
    pStatDest->NumRcptsRecvd        += pStatSrc->NumRcptsRecvd;
    pStatDest->NumRcptsRecvdLocal   += pStatSrc->NumRcptsRecvdLocal;
    pStatDest->NumRcptsRecvdRemote  += pStatSrc->NumRcptsRecvdRemote;
    pStatDest->MsgsRefusedDueToSize += pStatSrc->MsgsRefusedDueToSize;

    pStatDest->MsgsRefusedDueToNoCAddrObjects   += pStatSrc->MsgsRefusedDueToNoCAddrObjects;
    pStatDest->MsgsRefusedDueToNoMailObjects    += pStatSrc->MsgsRefusedDueToNoMailObjects;
    pStatDest->NumMsgsDelivered                 += pStatSrc->NumMsgsDelivered;
    pStatDest->NumDeliveryRetries               += pStatSrc->NumDeliveryRetries;
    pStatDest->NumMsgsForwarded                 += pStatSrc->NumMsgsForwarded;
    pStatDest->NumNDRGenerated                  += pStatSrc->NumNDRGenerated;
    pStatDest->LocalQueueLength                 += pStatSrc->LocalQueueLength;
    pStatDest->RetryQueueLength                 += pStatSrc->RetryQueueLength;
    pStatDest->NumMailFileHandles               += pStatSrc->NumMailFileHandles;
    pStatDest->NumQueueFileHandles              += pStatSrc->NumQueueFileHandles;
    pStatDest->CatQueueLength                   += pStatSrc->CatQueueLength;

    pStatDest->NumMsgsSent                += pStatSrc->NumMsgsSent;
    pStatDest->NumRcptsSent               += pStatSrc->NumRcptsSent;
    pStatDest->NumSendRetries             += pStatSrc->NumSendRetries;
    pStatDest->RemoteQueueLength          += pStatSrc->RemoteQueueLength;

    pStatDest->NumDnsQueries                += pStatSrc->NumDnsQueries;
    pStatDest->RemoteRetryQueueLength       += pStatSrc->RemoteRetryQueueLength;

    pStatDest->NumConnInOpen                += pStatSrc->NumConnInOpen;
    pStatDest->NumConnInClose               += pStatSrc->NumConnInClose;
    pStatDest->NumConnOutOpen               += pStatSrc->NumConnOutOpen;
    pStatDest->NumConnOutClose              += pStatSrc->NumConnOutClose;
    pStatDest->NumConnOutRefused            += pStatSrc->NumConnOutRefused;

    pStatDest->NumProtocolErrs              += pStatSrc->NumProtocolErrs;
    pStatDest->DirectoryDrops               += pStatSrc->DirectoryDrops;
    pStatDest->RoutingTableLookups          += pStatSrc->RoutingTableLookups;
    pStatDest->ETRNMessages                 += pStatSrc->ETRNMessages;
    pStatDest->TimeOfLastClear              += pStatSrc->TimeOfLastClear;

    pStatDest->MsgsBadmailNoRecipients      += pStatSrc->MsgsBadmailNoRecipients;
    pStatDest->MsgsBadmailHopCountExceeded  += pStatSrc->MsgsBadmailHopCountExceeded;
    pStatDest->MsgsBadmailFailureGeneral    += pStatSrc->MsgsBadmailFailureGeneral;
    pStatDest->MsgsBadmailBadPickupFile     += pStatSrc->MsgsBadmailBadPickupFile;
    pStatDest->MsgsBadmailEvent             += pStatSrc->MsgsBadmailEvent;
    pStatDest->MsgsBadmailNdrOfDsn          += pStatSrc->MsgsBadmailNdrOfDsn;
    pStatDest->MsgsPendingRouting           += pStatSrc->MsgsPendingRouting;
    pStatDest->MsgsPendingUnreachableLink   += pStatSrc->MsgsPendingUnreachableLink;
    pStatDest->SubmittedMessages            += pStatSrc->SubmittedMessages;
    pStatDest->DSNFailures                  += pStatSrc->DSNFailures;
    pStatDest->MsgsInLocalDelivery          += pStatSrc->MsgsInLocalDelivery;

    return TRUE;
}

SMTP_IIS_SERVICE::~SMTP_IIS_SERVICE()
{
    if(m_OldMaxPoolThreadValue != 0)
        AtqSetInfo(AtqMaxPoolThreads, m_OldMaxPoolThreadValue);
}


VOID
SMTP_IIS_SERVICE::MDChangeNotify(
    MD_CHANGE_OBJECT * pcoChangeList
    )
/*++

  This method handles the metabase change notification for this service

  Arguments:

    pcoChangeList - path and id that has changed

--*/
{
    DWORD   i;
    BOOL    fSslModified = FALSE;
    LPSTR   szIdString = NULL;
    BOOL    fSetCreatingInstance = FALSE;

    AcquireServiceLock();

    if (!m_fCreatingInstance)
    {
        //Check if this is a creation event.... if we are just creating the 
        //class key in smtpsvc/<instance>, then this is the notify we get 
        //when admin is creating an instance.  We should bail early so we 
        //do not attempt to create an instance and log bogus errors in 
        //the event log. If m_fCreatingInstance is set to TRUE... we will
        //not try to start the instance (by calling AddInstanceInfoHelper)

        //Parse the string and see if the last thing is the instance ID.. .we
        //expect it to be in the form of:
        //      /LM/{service_name}/{instance_id}/
        if (pcoChangeList->pszMDPath)
        {
            szIdString = (LPSTR)pcoChangeList->pszMDPath + 
                     sizeof(SMTP_MD_ROOT_PATH) - 2*sizeof(CHAR);
        }

        //We are now at the '/' before the instance id
        if (szIdString && (szIdString[0] == '/') && (szIdString[1] != '\0'))
        {
            //We have a possible winner... check for <n>/\0
            do {szIdString++;} while (*szIdString && isdigit((UCHAR)*szIdString));

            //If the last 2 characters are '/' and '\0'... we need to look further
            if ((szIdString[0] == '/') && (szIdString[1] == '\0'))
            {
                //Since all of this work is to avoid trying to start when
                //admin creates a new virtual server, we would be well advised
                //to only bail early in the exact case of admin adding a virtual
                //server instance.  They always create the key type first, so
                //we will check for it
                if ((MD_CHANGE_TYPE_ADD_OBJECT & pcoChangeList->dwMDChangeType) &&
                    (1 == pcoChangeList->dwMDNumDataIDs) &&
                    (MD_KEY_TYPE == pcoChangeList->pdwMDDataIDs[0]))
                {
                    //This is the notify that causes IIS to try and make us start
                    //before we have any config information.  If we call,
                    //IIS_SERVICE::MDChangeNotify it will turn around and start
                    //our instance.  .
                    m_fCreatingInstance = TRUE;
                
                    //This thread needs to unset it.  While the instance is created
                    //we will get other notifies (on this thread) when IIS sets 
                    //the service state.
                    fSetCreatingInstance = TRUE;
                }
            }
        }
    }
        

    IIS_SERVICE::MDChangeNotify( pcoChangeList );

    //The above call is were m_fCreatingInstance is used...reset it if we set it
    if (fSetCreatingInstance)
        m_fCreatingInstance = FALSE; 

    for ( i = 0; i < pcoChangeList->dwMDNumDataIDs; i++ )
    {
        switch ( pcoChangeList->pdwMDDataIDs[i] )
        {
        case MD_SSL_PUBLIC_KEY:
        case MD_SSL_PRIVATE_KEY:
        case MD_SSL_KEY_PASSWORD:
            fSslModified = TRUE;
            break;

        default:
            break;
        }
    }

    if ( !fSslModified && g_pSslKeysNotify )
    {
        if ( strlen( (LPSTR)pcoChangeList->pszMDPath ) >= sizeof("/LM/SMTPSVC/SSLKeys" )-1 &&
             !_memicmp( pcoChangeList->pszMDPath,
                        "/LM/SMTPSVC/SSLKeys",
                        sizeof("/LM/SMTPSVC/SSLKeys" )-1 ) )
        {
            fSslModified = TRUE;
        }
    }

    if ( fSslModified && g_pSslKeysNotify )
    {
        (g_pSslKeysNotify)( SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED, this );
    }

    ReleaseServiceLock();
}

/*++

    Name:

        APIERR SMTP_IIS_SERVICE::LoadAdvancedQueueingDll()

    Description:

        This method reads from the metabase to see if an advanced queueing dll
        has been set and loads it if so. If no dll is set then the default is
        loaded.

    Returns:

        NO_ERROR on success
        Whatever error occurred on failure

--*/

APIERR SMTP_IIS_SERVICE::LoadAdvancedQueueingDll()
{
    char szValueName[MAX_PATH + 1];
    char szAQDll[MAX_PATH + 1];
    STR TempString;
    DWORD fRet;
    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );

    TraceFunctEnterEx((LPARAM)this, "SMTP_IIS_SERVICE::LoadAdvancedQueueingDll()");

    lstrcpy(szValueName, g_pInetSvc->QueryMDPath());

    if ( !mb.Open( szValueName, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE) ) 
    {
        return ERROR_SERVICE_DISABLED;
    }

    TempString.Reset();
    szAQDll[0] = '\0';
    if (fRet = mb.GetStr("", MD_AQUEUE_DLL, IIS_MD_UT_FILE, &TempString, METADATA_INHERIT, "")) 
    {
        lstrcpyn(szAQDll, TempString.QueryStr(), MAX_PATH);
        DebugTrace((LPARAM)this, "Loading extended advanced queueing DLL %s", szAQDll);
    } 
    
    if (!fRet || (szAQDll[0] == '\0'))
    {
        lstrcpyn(szAQDll, AQ_DLL_NAME, MAX_PATH);
        DebugTrace((LPARAM)this, "No extended advanced queueing DLL set, loading %s\n", szAQDll);
    }

    if(!LoadAdvancedQueueing(szAQDll))
    {
        HRESULT err = GetLastError();
        ErrorTrace((LPARAM)this, "LoadAdvancedQueueing failed, %u", err);
        SmtpLogEvent(SMTP_EVENT_FAILED_TO_LOAD_AQUEUE, 0, (const CHAR **)NULL, 0);
        if(err == NO_ERROR)
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);

        mb.Close();
        TraceFunctLeaveEx((LPARAM)this);
        return err;
    }

    mb.Close();
    TraceFunctLeaveEx((LPARAM)this);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\main.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    main.cxx

    This module contains the main startup code for the SMTP Service.


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        JohnL   ????
        MuraliK     11-July-1995 Used Ipc() functions from Inetsvcs.dll

*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "inetsvcs.h"
#include <metacach.hxx>
#include <dbgutil.h>


// ATL Header files
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

//
// RPC related includes
//

extern "C" {
#include <inetinfo.h>
#include <smtpsvc.h>
};

#include <smtpinet.h>

extern DWORD g_cMaxConnectionObjs;

BOOL
InitializeSmtpServiceRpc(
                IN LPCSTR        pszServiceName,
                IN RPC_IF_HANDLE hRpcInterface
                );

BOOL CleanupSmtpServiceRpc(
                 VOID
                 );

//
//  Private constants.
//

BOOL        fAnySecureFilters = FALSE;

//
// for PDC hack
//

#define VIRTUAL_ROOTS_KEY_A     "Virtual Roots"
#define HTTP_EXT_MAPS           "Script Map"
#define SMTP_MODULE_NAME        "smtpsvc"

//
//  Global startup named event
//
DWORD GlobalInitializeStatus = 0;
BOOL g_ServiceBooted = FALSE;

//
//  Private globals.
//

#define INITIALIZE_IPC          0x00000001
#define INITIALIZE_SOCKETS      0x00000002
#define INITIALIZE_ACCESS       0x00000004
#define INITIALIZE_SERVICE      0x00000008
#define INITIALIZE_CONNECTIONS  0x00000010
#define INITIALIZE_DISCOVERY    0x00000020

#define INITIALIZE_RPC          0x00000040
#define INITIALIZE_GLOBALS      0x00000080
#define INITIALIZE_COMMON_DLLS  0x00000100
#define INITIALIZE_ROUTE_SORT   0x00000200
#define INITIALIZE_FIO          0x00000400


DEFINE_TSVC_INFO_INTERFACE();

DECLARE_DEBUG_PRINTS_OBJECT();
#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisSmtpServerGuid, 
0x784d8907, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();
#endif

//
// The following critical section synchronizes execution in ServiceEntry().
// This is necessary because the NT Service Controller may reissue a service
// start notification immediately after we have set our status to stopped.
// This can lead to an unpleasant race condition in ServiceEntry() as one
// thread cleans up global state as another thread is initializing it.
//

CRITICAL_SECTION g_csServiceEntryLock;

//
//  Private prototypes.
//

extern VOID SmtpOnConnect( IN SOCKET        sNew,
                  IN SOCKADDR_IN * psockaddr,       //Should be SOCKADDR *
                  IN PVOID         pEndpointContext,
                  IN PVOID         pAtqEndpointObject );

extern VOID
SmtpOnConnectEx(
    VOID *        patqContext,
    DWORD         cbWritten,
    DWORD         err,
    OVERLAPPED *  lpo
    );

VOID
SmtpCompletion(
    PVOID        pvContext,
    DWORD        cbWritten,
    DWORD        dwCompletionStatus,
    OVERLAPPED * lpo
    );

APIERR InitializeService( LPVOID pContext );
APIERR TerminateService( LPVOID pContext );

VOID TerminateInstances( PSMTP_IIS_SERVICE pService);

/************************************************************
 *  Symbolic Constants
 ************************************************************/

static TCHAR    szTcpipPath[] = TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters");

/************************************************************
 *  ATL Module
 ************************************************************/
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

#if 0
/************************************************************
 *  ATL Module
 ************************************************************/
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()
#endif


//+---------------------------------------------------------------------------
//
//  Function:
//
//      DllEntryPoint
//
//  Synopsis:
//  Arguments:
//  Returns:
//      See Win32 SDK
//
//  History:
//
//      Richard Kamicar     (rkamicar)              5 January 1996
//
//  Notes:
//
//      If we find we need this per service, we can move it out of here..
//
//----------------------------------------------------------------------------
BOOL WINAPI
DllEntryPoint(HINSTANCE hInst, DWORD dwReason, LPVOID lpvContext)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:

#ifndef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT( SMTP_MODULE_NAME, IisSmtpServerGuid);
#else
        CREATE_DEBUG_PRINT_OBJECT( SMTP_MODULE_NAME);
        SET_DEBUG_FLAGS( 0);
#endif


        //
        // To help performance, cancel thread attach and detach notifications
        //
        _Module.Init(ObjectMap, hInst);
        DisableThreadLibraryCalls((HMODULE) hInst);
        InitializeCriticalSection( &g_csServiceEntryLock );

        break;

    case DLL_PROCESS_DETACH:

        // Shutdown ATL
        _Module.Term();

#ifdef _NO_TRACING_
        DBG_CLOSE_LOG_FILE();
#endif
        DELETE_DEBUG_PRINT_OBJECT();

         DeleteCriticalSection( &g_csServiceEntryLock );
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;
    }
    return TRUE;
}

BOOL WINAPI DllMain (HANDLE hInst, ULONG dwReason, LPVOID lpvReserve)
{
  return DllEntryPoint((HINSTANCE) hInst, dwReason, lpvReserve);
}


//
//  Public functions.
//

VOID
ServiceEntry(
    DWORD cArgs,
    LPSTR pArgs[],
    PTCPSVCS_GLOBAL_DATA    pGlobalData     // unused
    )
/*++

    Routine:
        This is the "real" entrypoint for the service.  When
                the Service Controller dispatcher is requested to
                start a service, it creates a thread that will begin
                executing this routine.

    Arguments:
        cArgs - Number of command line arguments to this service.

        pArgs - Pointers to the command line arguments.

    Returns:
        None.  Does not return until service is stopped.

--*/
{
    APIERR err = NO_ERROR;
    BOOL fInitSvcObject = FALSE;

    EnterCriticalSection( &g_csServiceEntryLock );

    if ( !InitCommonDlls() )
    {
        DBGPRINTF(( DBG_CONTEXT,
                "[ServiceEntry] InitCommonDlls failed! Bailing\n" ));

        err = GetLastError();
        LeaveCriticalSection( &g_csServiceEntryLock );
        goto notify_scm;
    }

    InitAsyncTrace();

    GlobalInitializeStatus |= INITIALIZE_COMMON_DLLS;

    if (!InitializeCache()) goto exit;

    GlobalInitializeStatus |= INITIALIZE_FIO;

    //
    // Initialize Globals
    //

    err = InitializeGlobals();
    if ( err != NO_ERROR )
    {
        goto exit;
    }

    GlobalInitializeStatus |= INITIALIZE_GLOBALS;

    //  Initialize the service status structure.
    //
    g_pInetSvc = new SMTP_IIS_SERVICE(
                                SMTP_SERVICE_NAME_A,
                                SMTP_MODULE_NAME,
                                SMTP_PARAMETERS_KEY,
                                INET_SMTP_SVC_ID,
                                INET_SMTP_SVCLOC_ID,
                                TRUE,
                                0,
                                SmtpOnConnect,
                                SmtpOnConnectEx,
                                SmtpCompletion
                                );


    
    //
    //  If we couldn't allocate memory for the service info struct, then the
    //  machine is really hosed.
    //

   if( ( g_pInetSvc != NULL ) && g_pInetSvc->IsActive() )

    {
     
       err = ((SMTP_IIS_SERVICE *)g_pInetSvc)->LoadAdvancedQueueingDll();
       if( err != NO_ERROR )
            goto exit;


        fInitSvcObject = TRUE;

        err = g_pInetSvc->StartServiceOperation(
                                    SERVICE_CTRL_HANDLER(),
                                    InitializeService,
                                    TerminateService
                                    );
        



        if ( err )
        {
                //
                //  The event has already been logged
                //

                DBGPRINTF(( DBG_CONTEXT,
                           "SMTP ServiceEntry: StartServiceOperation returned %d\n",
                           err ));
        }
    }
   else if (g_pInetSvc == NULL)
   {
        err = ERROR_NOT_ENOUGH_MEMORY;
   }
   else
   {
        err = g_pInetSvc->QueryCurrentServiceError();
   }

exit:

    if ( g_pInetSvc != NULL )
    {
        g_pInetSvc->CloseService( );
    }

    TerminateGlobals( );

    if( GlobalInitializeStatus & INITIALIZE_FIO)
    {
        TerminateCache();
    }

    if( GlobalInitializeStatus & INITIALIZE_COMMON_DLLS)
    {
        TerminateCommonDlls();
    }


    TermAsyncTrace();

    LeaveCriticalSection( &g_csServiceEntryLock );

notify_scm:
    //
    // We need to tell the Service Control Manager that the service
    // is stopped if we haven't called g_pInetSvc->StartServiceOperation.
    //  1) InitCommonDlls fails, or
    //  2) InitializeGlobals failed, or
    //  3) new operator failed, or
    //  4) SMTP_IIS_SERVICE constructor couldn't initialize properly
    //

    if ( !fInitSvcObject ) {
        SERVICE_STATUS_HANDLE hsvcStatus;
        SERVICE_STATUS svcStatus;

        hsvcStatus = RegisterServiceCtrlHandler( SMTP_SERVICE_NAME,
                                                 SERVICE_CTRL_HANDLER() );


        if ( hsvcStatus != NULL_SERVICE_STATUS_HANDLE ) {
            svcStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
            svcStatus.dwCurrentState = SERVICE_STOPPED;
            svcStatus.dwWin32ExitCode = err;
            svcStatus.dwServiceSpecificExitCode = err;
            svcStatus.dwControlsAccepted = 0;
            svcStatus.dwCheckPoint = 0;
            svcStatus.dwWaitHint = 0;

            SetServiceStatus( hsvcStatus, (LPSERVICE_STATUS) &svcStatus );
        }
    }

} // ServiceEntry

//
//  Private functions.
//

APIERR
InitializeService(
            LPVOID pContext
            )
/*++

    Routine:
        This function initializes the various SMTP Service components.

    Arguments:
        lpContext - Pointer to the service object

    Returns:
        NO_ERROR if successful, otherwise a Win32
                    status code.

--*/
{
    APIERR err;
    DWORD dwErr = NO_ERROR;
    PSMTP_IIS_SERVICE psi = (PSMTP_IIS_SERVICE)pContext;
    MB      mb( (IMDCOM*) psi->QueryMDObject() );
    STR         TempString;

    char        szTcpipName[MAX_PATH + 1];
    BOOL        bUpdatedDomain;
    BOOL        bUpdatedFQDN;
    HRESULT     hr;

    g_IsShuttingDown = FALSE;

    TraceFunctEnter("InitializeService");

    DBGPRINTF(( DBG_CONTEXT,
                   "initializing Smtp service\n" ));

    SetLastError(NO_ERROR);

    psi->StartHintFunction();

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr))
    {
        DBGPRINTF(( DBG_CONTEXT,
           "Cannot CoInitialize, error %lu\n",
            hr ));
        FatalTrace(0,"Cannot CoInitialize, error %d",hr);
//      TraceFunctLeave();
//      return hr;
    }

    g_ProductType = 5;

    psi->StartHintFunction();

    //g_ProductType = 0;

    if ( !mb.Open( "/LM/SMTPSVC/",
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "InitializeService: Cannot open path %s, error %lu\n",
                    "/LM/SMTPSVC/", GetLastError() ));
        g_pInetSvc->ShutdownService( );
        TraceFunctLeave();
        return ERROR_SERVICE_DISABLED;
    }

    g_ServiceBooted  = TRUE;

    //
    // Initialize the Default Domain, Fully Qualified Domain Name (FQDN) settings.
    // The service will use the default TCP/IP settings in the control panel for these
    // values if the user has never modified the settings.
    //

    DWORD tmp;

    if (!mb.GetDword("", MD_UPDATED_DEFAULT_DOMAIN, IIS_MD_UT_SERVER, &tmp))
    {
        bUpdatedDomain = FALSE;
    }
    else
    {
        bUpdatedDomain = !!tmp;
    }

    if (!mb.GetDword("", MD_UPDATED_FQDN, IIS_MD_UT_SERVER, &tmp))
    {
        bUpdatedFQDN = FALSE;
    }
    else
    {
        bUpdatedFQDN = !!tmp;
    }


    psi->StartHintFunction();

    szTcpipName[0] = '\0';
    lstrcpyn(szTcpipName, g_ComputerName, MAX_PATH);

    //
    // will need to check against TCP/IP settings
    //
    HKEY    hkeyTcpipParam = NULL;
    DWORD   SizeOfBuffer = 0;
    DWORD   cbOffset;
    DWORD   dwType;
    DWORD   err2;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTcpipPath, 0, KEY_QUERY_VALUE, &hkeyTcpipParam) == ERROR_SUCCESS)
    {
        SizeOfBuffer = MAX_PATH;
        err2 = RegQueryValueEx(hkeyTcpipParam, "Hostname", 0, &dwType, (LPBYTE)szTcpipName, &SizeOfBuffer);
        if (err2 != ERROR_SUCCESS || SizeOfBuffer <= 1 || dwType != REG_SZ)
        {
            lstrcpyn(szTcpipName, g_ComputerName, MAX_PATH);
        }
        else
        {
            cbOffset = SizeOfBuffer - 1;
            szTcpipName[cbOffset] = '.';
            SizeOfBuffer = MAX_PATH - (cbOffset);
            err2 = RegQueryValueEx(hkeyTcpipParam, "Domain", 0, &dwType, (LPBYTE)szTcpipName + cbOffset + 1, &SizeOfBuffer);
            if (err2 != ERROR_SUCCESS || SizeOfBuffer <= 1 || dwType != REG_SZ)
            {
                szTcpipName[cbOffset] = '\0';
            }
        }

        _VERIFY(RegCloseKey(hkeyTcpipParam) == ERROR_SUCCESS);
    }


    ((SMTP_IIS_SERVICE *) g_pInetSvc)->SetTcpipName(szTcpipName);


    if (!bUpdatedDomain)
    {
       TempString.Reset();
        if(! mb.GetStr("", MD_DEFAULT_DOMAIN_VALUE, IIS_MD_UT_SERVER, &TempString) ||
            TempString.IsEmpty())
        {
            mb.SetString("", MD_DEFAULT_DOMAIN_VALUE, IIS_MD_UT_SERVER, szTcpipName);
        }

        else
        {
            if (lstrcmpi(szTcpipName,TempString.QueryStr()))
            //
            // no match, update
            //
            {
                mb.SetString("", MD_DEFAULT_DOMAIN_VALUE, IIS_MD_UT_SERVER, szTcpipName);
            }
        }
    }

    if (!bUpdatedFQDN)
    {
       TempString.Reset();
        if(! mb.GetStr("", MD_FQDN_VALUE, IIS_MD_UT_SERVER, &TempString) ||
            TempString.IsEmpty())
        {
            mb.SetString("", MD_FQDN_VALUE, IIS_MD_UT_SERVER, szTcpipName);
        }

        else
        {
            if (lstrcmpi(szTcpipName,TempString.QueryStr()))
            //
            // no match, update
            //
            {
                mb.SetString("", MD_FQDN_VALUE, IIS_MD_UT_SERVER, szTcpipName);
            }
        }
    }

    if (!mb.GetDword("", MD_MAX_MAIL_OBJECTS, IIS_MD_UT_SERVER, &g_cMaxConnectionObjs))
    {
        g_cMaxConnectionObjs = 5000;
    }

    mb.Close();

    psi->StartHintFunction();

    //
    //  Initialize various components.  The ordering of the
    //  components is somewhat limited.  Globals should be
    //  initialized first, then the event logger.  After
    //  the event logger is initialized, the other components
    //  may be initialized in any order with one exception.
    //  InitializeSockets must be the last initialization
    //  routine called.  It kicks off the main socket connection
    //  thread.
    //

    if( err = psi->InitializeDiscovery( ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "psi->InitializeDiscovery failed, error %lu\n",
                    err ));

        FatalTrace(0,"psi->InitializeDiscovery failed %d\n",err);
        TraceFunctLeave();
        return err;
    }

    GlobalInitializeStatus |= INITIALIZE_DISCOVERY;

    if( err = psi->InitializeSockets( ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "cannot initialize service, error %lu\n",
                    err ));

        FatalTrace(0,"psi->InitializeSockets failed %d\n",err);

        TraceFunctLeave();
        return err;
    }

    GlobalInitializeStatus |= INITIALIZE_SOCKETS;

    psi->StartHintFunction();

    if(!InitializeSmtpServiceRpc(SMTP_SERVICE_NAME, smtp_ServerIfHandle))
    {
         err = GetLastError();

        DBGPRINTF(( DBG_CONTEXT,
                   "cannot initialize RPC service, error %lu\n",
                    err ));

        FatalTrace(0,"InitializeSmtpServiceRpc failed %d\n",err);
        TraceFunctLeave();
        return err;
    }

    GlobalInitializeStatus |= INITIALIZE_RPC;

    //
    // Reset any Service Principal Names (for Kerberos) that may have been
    // registered
    //

    if (psi->ResetServicePrincipalNames()) {

        DebugTrace(
            0,
            "Unable to reset Kerberos Principal Names %lu, will try later",
            GetLastError());

    }

    //
    // Read and activate all the instances configured
    //

    InitializeInstances( psi );

    //
    //  Success!
    //

    DBGPRINTF(( DBG_CONTEXT, "SMTP Service initialized\n" ));

    TraceFunctLeave();

    return NO_ERROR;

} // InitializeService


APIERR TerminateService(IN LPVOID pContext)
/*++

    Routine:
        This function cleans up the various SMTP Service components.

    Arguments:
        pContext - Pointer to the service object

    Returns:
        NO_ERROR if successful, otherwise a Win32
                    status code.

--*/
{
    PSMTP_IIS_SERVICE psi = (PSMTP_IIS_SERVICE)pContext;
    DWORD err;

    TraceFunctEnter("TerminateService");

    if(!g_ServiceBooted)
    {
        ErrorTrace(NULL, "Smtp service not started, returning");
        return NO_ERROR;
    }

    g_ServiceBooted = FALSE ;

    g_IsShuttingDown = TRUE;

    DBG_ASSERT( pContext == g_pInetSvc);

    DBGPRINTF(( DBG_CONTEXT,
                   " SMTP terminating service\n" ));

    //
    //  Components should be terminated in reverse
    //  initialization order.
    //


    //get an exclusive lock on the server.
    //this will wait until all RPCs have
    //exited out of the server and then
    //return

    psi->AcquireServiceExclusiveLock();
    psi->ReleaseServiceExclusiveLock();

    TerminateInstances(psi);

    g_pInetSvc->ShutdownService( );

    if( GlobalInitializeStatus & INITIALIZE_DISCOVERY)
    {
        if ( (err = psi->TerminateDiscovery()) != NO_ERROR)
        {
            DBGPRINTF(( DBG_CONTEXT, "TerminateDiscovery() failed. Error = %u\n",
                   err));
        }
    }

    if( GlobalInitializeStatus & INITIALIZE_SOCKETS)
    {
        psi->CleanupSockets( );
    }

    TsFlushMetaCache(METACACHE_SMTP_SERVER_ID,TRUE);

    if( GlobalInitializeStatus & INITIALIZE_RPC)
    {
        CleanupSmtpServiceRpc();
    }

    CoFreeUnusedLibraries();
    CoUninitialize();

    DBGPRINTF(( DBG_CONTEXT,"service terminated\n" ));

    TraceFunctLeave();
    return NO_ERROR;

}  // TerminateService
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\isrpc.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    isrpc.cxx

Abstract:

    Contains ISRPC class implementation.

Author:

    Murali R. Krishnan         11-Dec-1995

Environment:

    User Mode - Win32

Revision History:

--*/


/************************************************************
 *  Include Headers
 ************************************************************/

#ifndef dllexp
#define dllexp __declspec( dllexport )
#endif

//
//  System include files.
//

#include "smtpinc.h"

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock2.h>
#include <lm.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#include <isrpc.hxx>

/************************************************************
 *  Functions
 ************************************************************/


DWORD
InetinfoStartRpcServerListen(
    VOID
    )
/*++

Routine Description:

    This function starts RpcServerListen for this process. The first
    service that is calling this function will actually start the
    RpcServerListen, subsequent calls are just noted down in num count.

Arguments:

    None.

Return Value:

    None.

--*/
{

    RPC_STATUS Status = RPC_S_OK;
    Status = RpcServerListen(
                    1,                              // minimum num threads.
                    RPC_C_LISTEN_MAX_CALLS_DEFAULT, // max concurrent calls.
                    TRUE );                         // don't wait

    return( Status );
}


DWORD
InetinfoStopRpcServerListen(
    VOID
    )
/*++

Routine Description:

Arguments:

    None.

Return Value:

    None.

--*/
{
    RPC_STATUS Status = RPC_S_OK;

    Status = RpcMgmtStopServerListening(0);

    //
    // wait for all RPC threads to go away.
    //

    if( Status == RPC_S_OK) {
        Status = RpcMgmtWaitServerListen();
    }

    return( Status );
}


ISRPC::ISRPC(IN LPCTSTR  pszServiceName)
/*++

  This function constructs a new ISRPC object, initializing the
   members to proper state.
  Always the ISRPC members will use RPC_C_AUTHN_WINNT.

  Arguments:

    pszServiceName -  pointer to string containing the name of the service
    dwServiceAuthId - DWORD containing the service Authentication Identifier.

  Returns:
    A valid initialized ISRPC object on success.

--*/
:  m_dwProtocols         ( 0),
   m_fInterfaceAdded     ( FALSE),
   m_fEpRegistered       ( FALSE),
   m_fServerStarted      ( FALSE),
   m_hRpcInterface       ( NULL),
   m_pszServiceName      ( pszServiceName),
   m_pBindingVector      ( NULL)
{
    //DBG_REQUIRE( SetSecurityDescriptor() == NO_ERROR);
    SetSecurityDescriptor();

#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   " Created new ISRPC object for %s at %08x\n",
                   m_pszServiceName, this));
    }
#endif
} // ISRPC::ISRPC()




ISRPC::~ISRPC(VOID)
/*++

  This function cleans up the ISRPC object and releases any dynamic memory or
  state associated with this object.

--*/
{

    CleanupData();
#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   " Destroyed ISRPC object for %s at %08x\n",
                   m_pszServiceName, this));
    }
#endif
} // ISRPC::~ISRPC()




DWORD
ISRPC::CleanupData(VOID)
/*++

Routine Description:

    This member function cleans up the ISRPC object.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD rpcStatus = RPC_S_OK;
#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   " ISRPC(%08x)::Cleaning up for %s\n",
                   m_pszServiceName));
    }
#endif
    if ( m_fServerStarted) {

        rpcStatus = StopServer( );
    }

    //DBG_ASSERT( rpcStatus == RPC_S_OK);

    rpcStatus = UnRegisterInterface();

    m_dwProtocols     = 0;
    m_hRpcInterface   = NULL;

    return (rpcStatus);
} // ISRPC::CleanupData()




DWORD
ISRPC::RegisterInterface( IN RPC_IF_HANDLE  hRpcInterface)
/*++

  This function registers the RPC inteface in the object.
  If there is already a valid instance present in the object,
   this function fails and returns error.
  If this is the new interface specified, the function registers the
    interface both for dynamic and static bindings.

   Should be called after calling AddProtocol() and before StartServer()

  Arguments:
    hRpcInteface - RPC inteface handle.

  Returns:
    Win32 Error Code - NO_ERROR on success.

--*/
{
    DWORD dwError = NO_ERROR;

    if ( m_dwProtocols == 0) {

        // No protocol added. Return failure.
        return ( ERROR_INVALID_PARAMETER);
    }

    if ( m_hRpcInterface != NULL) {

        dwError =  ( RPC_S_DUPLICATE_ENDPOINT);
    } else {

        //
        // since there is no duplicate, just set the new value and return.
        //

        if ( hRpcInterface == NULL) {

            dwError = ERROR_INVALID_PARAMETER;
        } else {

            m_hRpcInterface = hRpcInterface;
        }
    }


    if ( dwError == RPC_S_OK) {

        dwError = RpcServerRegisterIf(m_hRpcInterface,
                                      0,   // MgrUuid
                                      0    // MgrEpv (Entry Point Vector)
                                      );

        if ( dwError == RPC_S_OK ) {

            m_fInterfaceAdded = TRUE;

            //
            //  Establish the dynamic bindings if any.
            //

            if ( (m_dwProtocols & (ISRPC_OVER_TCPIP | ISRPC_OVER_SPX)) != 0) {

                dwError = RpcServerInqBindings( &m_pBindingVector);

                if ( dwError == RPC_S_OK) {

                    //DBG_ASSERT( m_pBindingVector != NULL);

                    dwError = RpcEpRegister(m_hRpcInterface,
                                            m_pBindingVector,
                                            NULL,
                                            (unsigned char *) "" );

                    if ( dwError == RPC_S_OK) {

                        m_fEpRegistered = TRUE;
                    }
                } // Ep registering
            } // dynamic bindings
        } // registration successful
    }

#if 0
    IF_DEBUG(DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "ISRPC(%08x)::RegisterInterface(%08x)"
                   " returns %ld\n",
                   this, hRpcInterface, dwError));
    }
#endif
    return ( dwError);

} // ISRPC::RegisterInterface()



DWORD
ISRPC::UnRegisterInterface( VOID)
/*++

  This function unregisters the RPC inteface in the object.

   Should be called after after StopServer() and before cleanup.

  Arguments:
    None

  Returns:
    Win32 Error Code - NO_ERROR on success.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if ( m_fEpRegistered) {

        //DBG_ASSERT( m_hRpcInterface != NULL && m_pBindingVector != NULL);
        rpcStatus = RpcEpUnregister(m_hRpcInterface,
                                    m_pBindingVector,
                                    NULL              // pUuidVector
                                    );
        //_ASSERT( rpcStatus == RPC_S_OK);
        m_fEpRegistered = FALSE;
    }

    if ( m_pBindingVector != NULL) {

        rpcStatus = RpcBindingVectorFree( &m_pBindingVector);
        //_ASSERT( rpcStatus == RPC_S_OK);
        m_pBindingVector = NULL;
    }

    if ( m_fInterfaceAdded != NULL) {

        rpcStatus = RpcServerUnregisterIf(m_hRpcInterface,
                                          NULL,      // MgrUuid
                                          TRUE  // wait for calls to complete
										  );
		//_ASSERT(rpcStatus == RPC_S_OK);
		m_fInterfaceAdded = FALSE;
    }
    return ( rpcStatus);

} // ISRPC::UnRegisterInterface()




DWORD
ISRPC::AddProtocol( IN DWORD Protocol)
/*++

Routine Description:

    This member function adds another protocol to the binding list.

Arguments:

    protocol - protocol binding opcode.

    fDynamic - Boolean indicating if the call should do dynamic or static
                RPC binding for the protocol specified.

Return Value:

    RPC error code.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if ( Protocol & ISRPC_OVER_LPC ) {

        // Currently we only support static binding
        rpcStatus = BindOverLpc( FALSE);
    }

#ifndef CHICAGO

    //
    // Enable all remote bindings
    //

    if ( rpcStatus == RPC_S_OK ) {

        if ( Protocol & ISRPC_OVER_TCPIP ) {

            // Currently we only support dynamic binding
            rpcStatus = BindOverTcp( TRUE);
        }

        if ( rpcStatus == RPC_S_OK && Protocol & ISRPC_OVER_NP ) {

            // Currently we only support static binding
            rpcStatus = BindOverNamedPipe( FALSE);
        }

        if ( rpcStatus == RPC_S_OK &&  Protocol & ISRPC_OVER_SPX  ) {

            // Currently we only support dynamic binding
            rpcStatus = BindOverSpx( TRUE);
        }
    }

#else // CHICAGO
    rpcStatus = RPC_S_OK;

    if ( Protocol & ISRPC_OVER_TCPIP ) {

        // Currently we only support dynamic binding
        rpcStatus = BindOverTcp( TRUE);
    }

    if ( Protocol & ISRPC_OVER_NB ) {

        // Currently we only support dynamic binding
        // Ignore status for NB for now
        (VOID)BindOverNetBios(TRUE);
    }
#endif // CHICAGO
#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   "ISRPC(%08x)::AddProtocol(%08x) returns %ld.\n",
                   this, Protocol, rpcStatus ));
    }
#endif
    return( rpcStatus );

} // ISRPC::AddProtocol()

DWORD
ISRPC::RemoveProtocol(IN DWORD Protocol)
/*++

Routine Description:

    This member function removes a protocol from the binding list.

Arguments:

    protocol - protocol binding opcode.

Return Value:

    RPC error code.

Note:
    As a side effect, this function removes the dynamic endpoing on
     TCPIP when SPX binding is removed and vice-versa.

--*/
{
#if 0
    DBGPRINTF(( DBG_CONTEXT,
               " ISRPC(%08x)::RemoveProtocol(%s) is not implemented\n",
               this, m_pszServiceName));
    DBG_ASSERT( FALSE);
#endif
    return ( ERROR_CALL_NOT_IMPLEMENTED);
} // ISRPC::RemoveProtocol()




DWORD
ISRPC::StartServer(
            VOID
            )
/*++

Routine Description:

    This member function start RPC server.

Arguments:

    None.

Return Value:

    RPC error code.

--*/
{
    DWORD rpcStatus;

    //
    // add the interface.
    //

    if ( m_hRpcInterface == NULL) {

        return (ERROR_INVALID_PARAMETER);
    }

    //
    // start rpc server.
    //

#ifndef SERVICE_AS_EXE

    rpcStatus = InetinfoStartRpcServerListen();

#else

    rpcStatus = RpcServerListen(
                                1,          // minimum num threads.
                                1,          // max concurrent calls.
                                TRUE );     // don't wait

#endif // SERVICE_AS_EXE

    if ( rpcStatus == RPC_S_OK ) {
        m_fServerStarted = TRUE;
    }
#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "ISRPC(%08x)::StartServer(%s) returns %ld\n",
                   this, m_pszServiceName, rpcStatus));
    }
#endif
    return( rpcStatus );

} // ISRPC::StartServer()




DWORD
ISRPC::StopServer(
            VOID
            )
{
    DWORD  rpcStatus = RPC_S_OK;

    if( m_fServerStarted ) {

#ifndef SERVICE_AS_EXE

        rpcStatus = InetinfoStopRpcServerListen();
#else

        //
        // stop server listen.
        //

        rpcStatus = RpcMgmtStopServerListening(0);

        //
        // wait for all RPC threads to go away.
        //

        if( rpcStatus == RPC_S_OK) {

            rpcStatus = RpcMgmtWaitServerListen();
        }

#endif // SERVICE_AS_EXE

        m_fServerStarted = FALSE;
    }

#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   "ISRPC(%08x)::StopServer( %s) returns %d\n",
                   this, m_pszServiceName, rpcStatus));
    }
#endif

    return ( rpcStatus);
} // ISRPC::StopServer()



DWORD
ISRPC::EnumBindingStrings(
    IN OUT LPINET_BINDINGS pBindings
    )
/*++

Routine Description:

    This member function enumurates the binding strings of the protocols
    bound to the server.

Arguments:

    pBindings : pointer to a binding strings structure. The caller
        should call FreeBindingStrings member function to free the string
        after use.

Return Value:

    Windows Error Code;

--*/
{
   DWORD dwError;
   RPC_BINDING_VECTOR * pBindingVector = NULL;
   LPINET_BIND_INFO pBindingsInfo;
   DWORD  dwCount = 0;
   DWORD i;

   //
   // query RPC for RPC_BINDING_VECTORS.
   //

   dwError =   RpcServerInqBindings( &pBindingVector );

   if( dwError != NO_ERROR ) {

       goto Cleanup;
   }

   //DBG_ASSERT( pBindingVector->Count > 0 );

   //
   // alloc memory for  INET_RPC_BINDING_STRINGS.
   //

   pBindingsInfo = (LPINET_BIND_INFO)
     LocalAlloc( GPTR, sizeof(INET_BIND_INFO) * pBindingVector->Count );

   if( pBindingsInfo == NULL ) {

       dwError = ERROR_NOT_ENOUGH_MEMORY;
       goto Cleanup;
   }

   //
   // convert binding handle to binding vectors.
   //

   pBindings->NumBindings  = 0;
   pBindings->BindingsInfo = pBindingsInfo;

   for( i = 0; i < pBindingVector->Count; i++ ) {

       LPSTR BindingString;

       BindingString = NULL;
       dwError = RpcBindingToStringBindingA(pBindingVector->BindingH[i],
                                            (LPBYTE *)&BindingString );

       if( dwError != NO_ERROR ) {
           goto Cleanup;
       }
#if 0
       IF_DEBUG( DLL_RPC) {
           DBGPRINTF(( DBG_CONTEXT, "Binding Handle[%d] = %08x. String = %s\n",
                      i, pBindingVector->BindingH[i], BindingString));
       }
#endif

       //
       // check to we get only our named-pipe endpoint.
       //

       if( strstr( BindingString, "ncacn_np" ) != NULL ) {

           //
           // found a named-pipe binding string.
           //

           if( strstr(BindingString,
                      m_pszServiceName ) == NULL ) {

               //
               // found a non service named-pipe entry.
               // ignore it.
               //

               RpcStringFreeA( (LPBYTE *)&BindingString );

           } else {
#if 0
               IF_DEBUG( DLL_RPC) {
                   DBGPRINTF(( DBG_CONTEXT, "Binding String Chosen = %s\n",
                              BindingString));
               }
#endif
               pBindings->BindingsInfo[dwCount].Length =
                 (strlen(BindingString) + 1) * sizeof(CHAR);
               pBindings->BindingsInfo[dwCount].BindData = BindingString;
               dwCount++;
           }
       }

   } // for

   dwError = NO_ERROR;
   pBindings->NumBindings = dwCount;
#if 0
   IF_DEBUG( DLL_RPC) {

       DBGPRINTF(( DBG_CONTEXT, "Binding Vectors chosen"
                  " Service = %s, NumBindings = %d of Total = %d\n",
                  m_pszServiceName, dwCount, pBindingVector->Count));
   }
#endif
 Cleanup:

   if( pBindingVector != NULL ) {

       DWORD LocalError;
       LocalError = RpcBindingVectorFree( &pBindingVector );
       //DBG_ASSERT( LocalError == NO_ERROR );
   }

   if( dwError != NO_ERROR ) {
       FreeBindingStrings( pBindings );
       pBindings->NumBindings = 0;
#if 0
       IF_DEBUG( DLL_RPC) {

           DBGPRINTF(( DBG_CONTEXT,
                      "ISRPC(%08x)::EnumBindingStrings(%s) failed, %ld.",
                      this, m_pszServiceName, dwError ));
       }
#endif
   }

   return( dwError );

} // ISRPC::EnumBindingStrings()




VOID
ISRPC::FreeBindingStrings(
     IN OUT LPINET_BINDINGS pInetBindings
    )
/*++

Routine Description:

    This member function deletes a binding vector that was returned by the
    EnumBindingStrings member function.

Arguments:

    pBindings : pointer to a binding vector.

Return Value:

    Windows Error Code;

--*/
{
    DWORD dwError;
    DWORD i;


    //
    // free binding strings.
    //

    for( i = 0; i < pInetBindings->NumBindings; i++) {
        dwError = RpcStringFreeA( ((LPBYTE *)&pInetBindings
                                 ->BindingsInfo[i].BindData ));
        //DBG_ASSERT( dwError == NO_ERROR );
    }

    pInetBindings->NumBindings = 0;

    //
    // free bindings info array.
    //

    if( pInetBindings->BindingsInfo != NULL ) {
        LocalFree( (HANDLE)pInetBindings->BindingsInfo );
        pInetBindings->BindingsInfo = NULL;
    }

    return;

} // ISRPC::FreeBindingStrings()




DWORD
ISRPC::BindOverTcp(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    //DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_TCPIP) == 0);

    if ( !fDynamic) {

        rpcStatus =  ( ERROR_CALL_NOT_IMPLEMENTED);

    } else {

        rpcStatus = ( ISRPC::DynamicBindOverTcp());
    }

    if ( rpcStatus == RPC_S_OK) {

        m_dwProtocols |= ISRPC_OVER_TCPIP;
    }

#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "(%08x)::BindOverTcp(%s) returns %d\n",
                   this, m_pszServiceName, rpcStatus));
    }
#endif
    return ( rpcStatus);
} // ISRPC::BindOverTcpIp()

#ifdef CHICAGO
DWORD
ISRPC::BindOverNetBios(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    //DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_NB) == 0);

    if ( !fDynamic) {

        return ( ERROR_CALL_NOT_IMPLEMENTED);
    }

    // We will use Dynamic endpoint for the NetBios binding.

    rpcStatus =
      RpcServerUseProtseqW(
                           L"ncacn_nb_ipx",        // protocol string.
                           ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                           &sm_sid );           // security

    rpcStatus =
      RpcServerUseProtseqW(
                           L"ncacn_nb_tcp",        // protocol string.
                           ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                           &sm_sid );           // security

    switch (rpcStatus) {

      case RPC_S_OK:

        //
        // set the protocol bit.
        //

        m_dwProtocols |= ISRPC_OVER_NB;
        break;

      case RPC_S_DUPLICATE_ENDPOINT:

        //DBGPRINTF(( DBG_CONTEXT,
        //           "(%08x) ncacn_nb is already added for %s\n",
        //           this,
        //           m_pszServiceName));
        rpcStatus = RPC_S_OK;
        break;

      case RPC_S_PROTSEQ_NOT_SUPPORTED:
      case RPC_S_CANT_CREATE_ENDPOINT:

        //DBGPRINTF(( DBG_CONTEXT,
        //           "(%08x) ncacn_nb is not supported for %s (%ld).\n",
        //           this, m_pszServiceName, rpcStatus ));
        rpcStatus = RPC_S_OK;
        break;

      default:
        break;
    } // switch()

    //
    // if the security support provider is not enabled, do so.
    //

    if( rpcStatus == RPC_S_OK && !IsSecurityEnabled() ) {

        rpcStatus = AddSecurity();

    }
#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "(%08x)::BindOverNetBios(%s) returns %d\n",
                   this, m_pszServiceName, rpcStatus));
    }
#endif
    return ( rpcStatus);
} // ISRPC::BindOverNetBios()
#endif // CHICAGO

DWORD
ISRPC::BindOverNamedPipe(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    //DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_NP) == 0);


    //
    // On Named Pipe, we support only static bindings. No dynamic Binding.
    //

    if ( fDynamic) {

        return ( ERROR_CALL_NOT_IMPLEMENTED);
    }

    if( (m_dwProtocols & ISRPC_OVER_NP) == 0 ) {

        WCHAR  rgchNp[1024];

        wsprintfW( rgchNp,
#ifdef UNICODE
                  L"%ws%s"
#else
                  L"%ws%S"
#endif // UNICODE
                  ,
                  ISRPC_NAMED_PIPE_PREFIX_W,
                  m_pszServiceName);

        //
        // Establish a static Named pipe binding.
        //

        rpcStatus =
          RpcServerUseProtseqEpW(
                                 L"ncacn_np",        // protocol string.
                                 ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                                 rgchNp,             // end point!
                                 NULL );          // security
#if 0
        IF_DEBUG( DLL_RPC) {

            CHAR pszBuff[100];
            wsprintfA( pszBuff, "%S", rgchNp);
            DBGPRINTF(( DBG_CONTEXT,
                       " RpcServerUseProtseqEpW( %s, %d, %s, %08x) returns"
                       " %d\n",
                       "ncacn_np", ISRPC_PROTSEQ_MAX_REQS,
                       pszBuff, &sm_sid, rpcStatus));
        }
#endif
        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //
            m_dwProtocols |= ISRPC_OVER_NP;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            //
            // Ignore the duplicate end point error
            //
            //DBGPRINTF(( DBG_CONTEXT,
            //           "(%08x) ncacn_np is already added for %s\n",
            //           this,
            //           m_pszServiceName));
            m_dwProtocols |= ISRPC_OVER_NP;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "(%08x) ncacn_np is not supported for %s (%ld).\n",
            //           this, m_pszServiceName, rpcStatus ));
            rpcStatus = RPC_S_OK;
            break;

          default:
            break;
        } // switch()
    }

    return ( rpcStatus);

} // ISRPC::BindOverNamedPipe()





DWORD
ISRPC::BindOverLpc(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    //DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_LPC) == 0);


    //
    // On LPC, we support only static bindings. No dynamic Binding.
    //

    if ( fDynamic) {

        return ( ERROR_CALL_NOT_IMPLEMENTED);
    }

    if( (m_dwProtocols & ISRPC_OVER_LPC) == 0 ) {

        WCHAR  rgchLpc[1024];

        // LPC Endpoint string is:   <InterfaceName>_LPC
        wsprintfW( rgchLpc,
#ifdef UNICODE
                  L"%s_%ws"
#else
                  L"%S_%ws"
#endif // UNICODE
                  ,
                  m_pszServiceName,
                  ISRPC_LPC_NAME_SUFFIX_W);

        //
        // Establish a static Lpc binding.
        //

        rpcStatus =
          RpcServerUseProtseqEpW(
                                 L"ncalrpc",         // protocol string.
                                 ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                                 rgchLpc,            // end point!
                                 &sm_sid );          // security
#if 0
        IF_DEBUG( DLL_RPC) {

            CHAR pszBuff[100];
            wsprintfA( pszBuff, "%S", rgchLpc);
            DBGPRINTF(( DBG_CONTEXT,
                       " RpcServerUseProtseqEpW( %s, %d, %s, %08x) returns"
                       " %d\n",
                       "ncalrpc", ISRPC_PROTSEQ_MAX_REQS,
                       pszBuff, &sm_sid, rpcStatus));
        }
#endif
        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //
            m_dwProtocols |= ISRPC_OVER_LPC;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            //
            // Ignore the duplicate end point error
            //
            //DBGPRINTF(( DBG_CONTEXT,
            //           "(%08x) ncalrpc is already added for %s\n",
            //           this,
            //           m_pszServiceName));
            m_dwProtocols |= ISRPC_OVER_LPC;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "(%08x) ncalrpc is not supported for %s (%ld).\n",
            //           this, m_pszServiceName, rpcStatus ));
            rpcStatus = RPC_S_OK;
            break;

          default:
            break;
        } // switch()
    }

    return ( rpcStatus);

} // ISRPC::BindOverLpc()




DWORD
ISRPC::BindOverSpx(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    //DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_SPX) == 0);

    if ( !fDynamic) {

        rpcStatus =  ( ERROR_CALL_NOT_IMPLEMENTED);

    } else {

        rpcStatus = ISRPC::DynamicBindOverSpx();
    }

    if ( rpcStatus == RPC_S_OK) {

        m_dwProtocols |= ISRPC_OVER_SPX;
    }

#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "(%08x)::BindOverSpx(%s) returns %d\n",
                   this, m_pszServiceName, rpcStatus));
    }
#endif

    return ( rpcStatus);
} // ISRPC::BindOverSpx()


# if DBG

VOID
ISRPC::Print(VOID) const
{
#if 0
    DBGPRINTF(( DBG_CONTEXT,
               " ISRPC(%08x). SvcName=%s\n"
               " Protocols = %d.\n"
               " RPC Interface = %08x. Binding Vector = %08x\n"
               " InterfaceAdded = %d.\n"
               " EpRegistered = %d. ServerStarted = %d.\n"
               ,
               this, m_pszServiceName,
               m_dwProtocols,
               m_hRpcInterface, m_pBindingVector,
               m_fInterfaceAdded,
               m_fEpRegistered, m_fServerStarted
               ));
#endif

} // ISRPC::Print()

# endif // DBG



/******************************
 * STATIC Member Definitions
 ******************************/

DWORD ISRPC::sm_dwProtocols = 0;

SECURITY_DESCRIPTOR ISRPC::sm_sid;
BOOL  ISRPC::sm_fSecurityEnabled = FALSE;


DWORD
ISRPC::Initialize(VOID)
{
    sm_dwProtocols  = 0;

    return SetSecurityDescriptor();

} // ISRPC::Initialize()



DWORD
ISRPC::Cleanup(VOID)
{
    //
    // Free up the security descriptor
    //

    if (sm_sid.Dacl)
        delete [] (BYTE *) (sm_sid.Dacl);

    ZeroMemory( (PVOID) &sm_sid, sizeof(sm_sid));

    //
    // For now nothing to do. Just a place holder.
    //

    return ( NO_ERROR);

} // ISRPC::Cleanup()


DWORD
ISRPC::DynamicBindOverTcp(VOID)
/*++
  This static function (ISRPC member) establishes a dynamic endpoing
   RPC binding over TCP/IP, using a run-time library call to RPC.
  RPC run-time library allows one to create as many dynamic end points
   as one wishes. So we maintain external state and control the number
   of end points created to 1.

  Arguments:
    None

  Returns:
    RPC status - RPC_S_OK for success.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if( (sm_dwProtocols & ISRPC_OVER_TCPIP) == 0 ) {

        //
        // Not already present. Add dynamic endpoint over TCP/IP
        //

        rpcStatus =
          RpcServerUseProtseqW(
                               L"ncacn_ip_tcp",    // protocol string.
                               ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                               &sm_sid );          // security

        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //

            sm_dwProtocols |= ISRPC_OVER_TCPIP;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "ncacn_ip_tcp is already added.\n"));
            sm_dwProtocols |= ISRPC_OVER_TCPIP;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "ncacn_ip_tcp is not supported. Error = %ld\n",
            //           rpcStatus));

            break;

          default:
            break;
        } // switch()

        //
        // if the security support provider is not enabled, do so.
        //

        if( rpcStatus == RPC_S_OK && !IsSecurityEnabled() ) {

            rpcStatus = AddSecurity();

        }
    }
#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "DynamicBindOverTcp() returns %d\n",
                   rpcStatus));
    }
#endif
    return ( rpcStatus);

} // ISRPC::DynamicBindOverTcp()




DWORD
ISRPC::DynamicBindOverSpx(VOID)
/*++
  This static function (ISRPC member) establishes a dynamic endpoing
   RPC binding over SPX, using a run-time library call to RPC.
  RPC run-time library allows one to create as many dynamic end points
   as one wishes. So we maintain external state and control the number
   of end points created to 1.

  Arguments:
    None

  Returns:
    RPC status - RPC_S_OK for success.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if( (sm_dwProtocols & ISRPC_OVER_SPX) == 0 ) {

        // Use dynamic end point for the server.
        rpcStatus =
          RpcServerUseProtseqW(
                               L"ncacn_spx",       // protocol string.
                               ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                               &sm_sid );          // security

        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //
            sm_dwProtocols |= ISRPC_OVER_SPX;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "ncacn_spx is already added.\n"
            //           ));
            sm_dwProtocols |= ISRPC_OVER_SPX;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "ncacn_spx is not supported. Error (%ld).\n",
            //           rpcStatus ));
            break;

          default:
            break;
        } // switch()

        //
        // if the security support provider is not enabled, do so.
        //

        if( rpcStatus == RPC_S_OK && !IsSecurityEnabled()) {

            rpcStatus = AddSecurity();
        }
    }

#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "DynamicBindOverSpx() returns %d\n",
                   rpcStatus));
    }
#endif

    return ( rpcStatus);

} // ISRPC::DynamicBindOverSpx()


//----------------------------------------------------------------
//  Description:
//      Initializes a SECURITY_DESCRIPTOR to allow access to all
//      ("World").
//  Arguments:
//      pSd Pass in a pointer to the SECURITY_DESCRIPTOR
//  Returns:
//      ERROR_SUCCESS if initialization proceeded successfully.
//      Win32 error if some failure occurred.
//----------------------------------------------------------------
DWORD InitializeWorldSecurityDescriptor (PSECURITY_DESCRIPTOR pSd)
{ 
    DWORD dwErr = ERROR_SUCCESS;
    PSID pSidWorld = NULL;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    ACL *pAcl = NULL;
    DWORD dwAclSize = 0;

    _ASSERT (pSd);

    if (!AllocateAndInitializeSid (
            &WorldAuthority,
            1,
            SECURITY_WORLD_RID,
            0,0,0,0,0,0,0,
            &pSidWorld)){

        dwErr = GetLastError ();
        goto Exit;
    }

    dwAclSize = sizeof (ACL) +  //  Length of ACL
                (sizeof (ACCESS_ALLOWED_ACE) - sizeof (DWORD)) +    // Length of ACE #1
                GetLengthSid (pSidWorld) +                          // Length of SID for ACE #1
                (sizeof (ACCESS_DENIED_ACE) - sizeof (DWORD)) +     // Length of ACE #2
                GetLengthSid (pSidWorld);                           // Length of SID for ACE #1

    pAcl = (PACL) new BYTE [dwAclSize]; 
    if (!pAcl) {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    if (!InitializeSecurityDescriptor (pSd, SECURITY_DESCRIPTOR_REVISION)) {
        dwErr = GetLastError ();
        goto Exit;
    }

    if (!InitializeAcl (
            pAcl,
            dwAclSize,
            ACL_REVISION)) {

        dwErr = GetLastError ();
        goto Exit;
    }

    if (!AddAccessDeniedAce  (pAcl, ACL_REVISION, WRITE_DAC | WRITE_OWNER, pSidWorld) ||
        !AddAccessAllowedAce (pAcl, ACL_REVISION, GENERIC_ALL, pSidWorld)) {

        dwErr = GetLastError ();
        goto Exit;
    }

    if (!SetSecurityDescriptorDacl (pSd, TRUE, pAcl, FALSE)) {
        dwErr = GetLastError ();
        goto Exit;
    }

    pAcl = NULL; // Now pAcl is set on pSd... and will be deleted as pSd->Dacl

Exit:
    if (pSidWorld)
        FreeSid (pSidWorld);

    if (pAcl)
        delete [] pAcl;

    return dwErr;
}



DWORD
ISRPC::SetSecurityDescriptor( VOID)
/*++

Routine Description:

    This member function builds the security descriptor used by RPC module.

Arguments:

    None.

Return Value:

    Windows error code.

--*/
{
    DWORD dwError = NO_ERROR;

    //
    // build a security descriptor that will grant everyone
    // all access to the object --- this is done by setting a
    //  "World" DACL in the SECURITY_DESCRIPTOR.
    //

    dwError = InitializeWorldSecurityDescriptor(&sm_sid);
    if (dwError != ERROR_SUCCESS) {
        //
        // free up security discriptor memory and set it to NULL.
        //
        if (sm_sid.Dacl)
            delete [] (BYTE*) sm_sid.Dacl;

        memset( (PVOID ) &sm_sid,  0, sizeof(sm_sid));
    }

    return( dwError );

} // ISRPC::SetSecurityDescriptor()




DWORD
ISRPC::AddSecurity(
    VOID
    )
/*++

Routine Description:

    This member function adds security support provider over RPC.

Arguments:

    None.

Return Value:

    Windows error code.

--*/
{
    DWORD rpcStatus;

    //
    // Register for authentication using WinNT.
    //

    rpcStatus = RpcServerRegisterAuthInfo(
                    (unsigned char * ) NULL, // app name to security provider
                    RPC_C_AUTHN_WINNT,       // Auth package ID.
                    NULL,                    // RPC_C_AUTHN_WINNT ==> NULL
                    NULL                     // args ptr for authn function.
                    );

    if ( rpcStatus == RPC_S_OK) {

        sm_fSecurityEnabled = TRUE;
    }

#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "AddSecurity() returns Error %u\n",
                   rpcStatus));
    }
#endif

    return (rpcStatus);
} // ISRPC::AddSecurity()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\pe_dispi.cxx ===
/*++

   Copyright (c) 1998    Microsoft Corporation

   Module  Name :

        pe_dispi.cxx

   Abstract:

        This module provides the implementation for the protocol
        event dispatchers

   Author:

           Keith Lau    (KeithLau)    6/24/98

   Project:

           SMTP Server DLL

   Revision History:

            KeithLau            Created

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"

#include "initguid.h"

//
// ATL includes
//
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL

//
// SEO includes
//
#include "seo.h"
#include "seolib.h"

#include <memory.h>
#include "smtpcli.hxx"
#include "smtpout.hxx"
#include <smtpguid.h>

//
// Dispatcher implementation
//
#include "pe_dispi.hxx"


// =================================================================
// Outbound command generation dispatcher
//

//
// These are the commands that the default handlers hook
//
char *COutboundDispatcher::s_rgszDefaultCommand[PE_STATE_MAX_STATES] =
{
    "ehlo",
    "mail",
    "rcpt",
    NULL,
    "quit"
};

//
// This is what we use to map an event type to an internal index
//
const GUID *COutboundDispatcher::s_rgrguidEventTypes[PE_STATE_MAX_STATES] =
{
    &CATID_SMTP_ON_SESSION_START,
    &CATID_SMTP_ON_MESSAGE_START,
    &CATID_SMTP_ON_PER_RECIPIENT,
    &CATID_SMTP_ON_BEFORE_DATA,
    &CATID_SMTP_ON_SESSION_END
};

//
// Generic dispatcher methods
//
HRESULT CGenericProtoclEventDispatcher::GetLowerAnsiStringFromVariant(
            CComVariant &vString,
            LPSTR       pszString,
            DWORD       *pdwLength
            )
{
    HRESULT hr = S_OK;
    DWORD   dwInLength;

    if (!pszString)
        return(E_POINTER);
    if (!pdwLength)
        return(E_INVALIDARG);

    // Default to NULL
    *pszString = NULL;

    if (vString.vt == VT_BSTR)
    {
        DWORD dwLength = lstrlenW(vString.bstrVal) + 1;

        // Set the size anyway
        dwInLength = *pdwLength;
        *pdwLength = dwLength;

        if (dwLength > dwInLength)
            return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

        // copy the rule into an ascii string
        if (WideCharToMultiByte(CP_ACP, 0, vString.bstrVal,
                                -1, pszString, dwLength, NULL, NULL) <= 0)
            return(HRESULT_FROM_WIN32(GetLastError()));

        // Convert to lower case once and for all to avoid strcmpi
        while (*pszString)
        {
            *pszString = (CHAR)tolower(*pszString);
            pszString++;
        }
    }
    else
        hr = E_INVALIDARG;
    return(hr);
}

HRESULT CGenericProtoclEventDispatcher::InsertBinding(
            LPPE_COMMAND_NODE   *ppHeadNode,
            LPPE_BINDING_NODE   pBinding,
            LPSTR               pszCommandKeyword,
            DWORD               dwCommandKeywordSize
            )
{
    DWORD                   dwPriority;
    BOOL                    fReorder = FALSE;
    LPPE_COMMAND_NODE       pNode;

    TraceFunctEnter("CGenericProtoclEventDispatcher::InsertBinding");

    if (!ppHeadNode || !pBinding || !pszCommandKeyword)
        return(E_POINTER);

    pNode = *ppHeadNode;
    while (pNode)
    {
        // All strings come in lower case
        if (!strcmp(pszCommandKeyword, pNode->pszCommandKeyword))
        {
            DebugTrace((LPARAM)0, "Found command %s", pszCommandKeyword);

            // Now we determine if we have changed the max priority
            // if we increased the priority (i.e. lower value), then
            // we will have to reposition out node
            dwPriority = pBinding->dwPriority;
            if (pBinding->dwPriority < dwPriority)
            {
                pBinding->dwPriority = dwPriority;
                fReorder = TRUE;
                DebugTrace((LPARAM)0, "Reordering commands");
            }

            // Now insert the binding in the right order
            LPPE_BINDING_NODE   pWalk = pNode->pFirstBinding;
            LPPE_BINDING_NODE   pPrev = (LPPE_BINDING_NODE)&(pNode->pFirstBinding);
            if (!pWalk)
            {
                pBinding->pNext = pNode->pFirstBinding;
                pNode->pFirstBinding = pBinding;
            }
            else while (pWalk)
            {
                if (pWalk->dwPriority > dwPriority)
                    break;
                pPrev = pWalk;
                pWalk = pWalk->pNext;
            }
            pBinding->pNext = pWalk;
            pPrev->pNext = pBinding;

            if (!fReorder)
                return(S_OK);
            else
                break;
        }

        // Next!
        pNode = pNode->pNext;
    }

    if (!fReorder)
    {
        char    *pTemp;
        DWORD   dwSize = sizeof(PE_COMMAND_NODE);

        // Not found, create a new command node, plus a buffer
        // for the command keyword
        dwSize += dwCommandKeywordSize;
        pTemp = new char [dwSize];
        if (!pTemp)
            return(E_OUTOFMEMORY);

        pNode = (LPPE_COMMAND_NODE)pTemp;
        pTemp = (char *)(pNode + 1);

        DebugTrace((LPARAM)0,
                    "Creating node for command %s",
                    pszCommandKeyword);

        strcpy(pTemp, pszCommandKeyword);
        dwPriority = pBinding->dwPriority;
        pBinding->pNext = NULL;
        pNode->pszCommandKeyword = pTemp;
        pNode->dwHighestPriority = dwPriority;
        pNode->pFirstBinding = pBinding;
    }

    // Insert based on top priority
    LPPE_COMMAND_NODE   pWalk = *ppHeadNode;
    LPPE_COMMAND_NODE   pPrev = (LPPE_COMMAND_NODE)ppHeadNode;
    if (!pWalk)
    {
        pNode->pNext = NULL;
        *ppHeadNode = pNode;
        return(S_OK);
    }
    while (pWalk)
    {
        if (pWalk->dwHighestPriority > dwPriority)
            break;
        pPrev = pWalk;
        pWalk = pWalk->pNext;
    }
    pNode->pNext = pWalk;
    pPrev->pNext = pNode;

    TraceFunctLeave();
    return(S_OK);
}

HRESULT CGenericProtoclEventDispatcher::InsertBindingWithHash(
            LPPE_COMMAND_NODE   *rgpHeadNodes,
            DWORD               dwHashSize,
            LPPE_BINDING_NODE   pBinding,
            LPSTR               pszCommandKeyword,
            DWORD               dwCommandKeywordSize
            )
{
    TraceFunctEnter("CGenericProtoclEventDispatcher::InsertBindingWithHash");

    if (!rgpHeadNodes || !pBinding || !pszCommandKeyword)
        return(E_POINTER);

    DWORD dwHash = GetHashValue(
                dwHashSize,
                pszCommandKeyword,
                dwCommandKeywordSize);

    HRESULT hr = InsertBinding(
                &(rgpHeadNodes[dwHash]),
                pBinding,
                pszCommandKeyword,
                dwCommandKeywordSize);

    TraceFunctLeave();
    return(hr);
}

HRESULT CGenericProtoclEventDispatcher::FindCommandFromHash(
            LPPE_COMMAND_NODE   *rgpHeadNodes,
            DWORD               dwHashSize,
            LPSTR               pszCommandKeyword,
            DWORD               dwCommandKeywordSize,
            LPPE_COMMAND_NODE   *ppCommandNode
            )
{
    TraceFunctEnter("CGenericProtoclEventDispatcher::FindCommandFromHash");

    if (!rgpHeadNodes || !pszCommandKeyword || !ppCommandNode)
        return(E_POINTER);

    DWORD dwHash = GetHashValue(
                dwHashSize,
                pszCommandKeyword,
                dwCommandKeywordSize);

    LPPE_COMMAND_NODE   pNode = rgpHeadNodes[dwHash];

    while (pNode)
    {
        if (!strcmp(pszCommandKeyword, pNode->pszCommandKeyword))
        {
            *ppCommandNode = pNode;
            TraceFunctLeave();
            return(S_OK);
        }
        pNode = pNode->pNext;
    }
    TraceFunctLeave();
    return(S_FALSE);
}

HRESULT CGenericProtoclEventDispatcher::CleanupCommandNodes(
            LPPE_COMMAND_NODE   pHeadNode,
            LPPE_COMMAND_NODE   pSkipNode
            )
{
    LPPE_COMMAND_NODE   pNode;
    while (pHeadNode)
    {
        pNode = pHeadNode->pNext;
        if (pHeadNode != pSkipNode)
        {
            char    *pTemp = (char *)pHeadNode;
            delete [] pTemp;
        }
        pHeadNode = pNode;
    }
    return(S_OK);
}


//
// Inbound dispatcher methods
//

HRESULT CInboundDispatcher::AllocBinding(
            REFGUID         rguidEventType,
            IEventBinding   *piBinding,
            CBinding        **ppNewBinding
            )
{
    if (ppNewBinding)
        *ppNewBinding = NULL;
    if (!piBinding || !ppNewBinding)
        return(E_POINTER);

    *ppNewBinding = new CInboundBinding(this);

    if (*ppNewBinding == NULL)
        return(E_OUTOFMEMORY);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CInboundDispatcher::ChainSinks(
            IUnknown                    *pServer,
            IUnknown                    *pSession,
            IMailMsgProperties          *pMsg,
            ISmtpInCommandContext       *pContext,
            DWORD                       dwStopAtPriority,
            LPPE_COMMAND_NODE           pCommandNode,
            LPPE_BINDING_NODE           *ppResumeFrom
            )
{
    HRESULT hr = S_OK;

    LPPE_BINDING_NODE   pBinding = NULL;

    TraceFunctEnterEx((LPARAM)this, "CInboundDispatcher::ChainSinks");

    // These are the essential pointers that CANNOT be NULL
    if (!pContext || !pCommandNode || !ppResumeFrom)
        return(E_POINTER);

    // What we do is strictly determined by the ppPreviousCommand
    // and ppResumeFrom pointers. The logic is as follows:
    //
    // pCmdNode     ppResumeFrom    Action
    //    NULL          X           Error (E_POINTER)
    //   !NULL          NULL        Error (ERROR_NO_MORE_ITEMS)
    //   !NULL         !NULL        Start from the exact binding specified in
    //                                *ppResumeFrom
    //
    // On exit, these pointers will be updated to the following:
    //
    // *ppResumeFrom      - This will be set to the next binding to resume from
    //                      This will be set to NULL if there are no more bindings

    pBinding = *ppResumeFrom;
    if (!pBinding)
    {
        _ASSERT(FALSE);
        ErrorTrace((LPARAM)this, "ERROR! Empty binding chain!!");
        return(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
    }

    // We know exactly where to start chaining ... Do it.
    // Break when:
    // 1) The default handler binding is encountered, or
    // 2) Sinks results are S_OK
    // 3) No more bindings left
    CInboundBinding     *pInboundBinding;
    IUnknown            *pUnkSink = NULL;
    ISmtpInCommandSink  *pSink;

    hr = S_OK;
    *ppResumeFrom = pBinding;
    while (pBinding && (hr == S_OK))
    {
        // One of the exiting conditions
        if (pBinding->dwPriority > dwStopAtPriority)
            break;

        // Get the containing binding class
        pInboundBinding = CONTAINING_RECORD(
                    pBinding, CInboundBinding, m_bnInfo);

        // Call the sink
        hr = m_piEventManager->CreateSink(
                    pInboundBinding->m_piBinding,
                    NULL,
                    &pUnkSink);
        if (SUCCEEDED(hr))
        {
            hr = pUnkSink->QueryInterface(
                        IID_ISmtpInCommandSink,
                        (LPVOID *)&pSink);
            pUnkSink->Release();
            pUnkSink = NULL;
            if (SUCCEEDED(hr))
            {
                hr = pSink->OnSmtpInCommand(
                            pServer,
                            pSession,
                            pMsg,
                            pContext);
                pSink->Release();
                if (hr == MAILTRANSPORT_S_PENDING)
                    break;
            }
            else
                hr = S_OK;
        }
        else
            hr = S_OK;

        // Next
        pBinding = pBinding->pNext;
        *ppResumeFrom = pBinding;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}

//
// CInboundDispatcher::CInboundBinding methods
//
HRESULT CInboundDispatcher::CInboundBinding::Init(
            IEventBinding *piBinding
            )
{
    HRESULT hr;
    CComPtr<IEventPropertyBag>  piEventProperties;
    CComVariant                 vRule;
    CHAR                        szCommandKeyword[256];
    DWORD                       cchCommandKeyword = 0;

    TraceFunctEnterEx((LPARAM)this,
            "CInboundDispatcher::CInboundBinding::Init");

    if (!piBinding || !m_pDispatcher)
        return(E_POINTER);

    // get the parent initialized
    hr = CBinding::Init(piBinding);
    if (FAILED(hr)) return hr;

    // Store the priority
    m_bnInfo.dwPriority = CBinding::m_dwPriority;
    m_bnInfo.dwFlags = 0;

    // get the binding database
    hr = m_piBinding->get_SourceProperties(&piEventProperties);
    if (FAILED(hr)) return hr;

    // get the rule from the binding database
    hr = piEventProperties->Item(&CComVariant("Rule"), &vRule);
    if (FAILED(hr)) return hr;

    // Process the VARIANT to obtain a lower-case ANSI string
    if (hr == S_OK)
    {
        cchCommandKeyword = sizeof(szCommandKeyword);
        hr = GetLowerAnsiStringFromVariant(
                    vRule,
                    szCommandKeyword,
                    &cchCommandKeyword);
    }

    // We cannot proceed without a rule, so we discard this binding
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM)this,
                "Failed to get keyword, error %08x", hr);
        return(hr);
    }
    if (!cchCommandKeyword || !(*szCommandKeyword))
        return(E_INVALIDARG);

    DebugTrace((LPARAM)this, "Rule: %s", szCommandKeyword);

    // Call the dispatcher to insert the node into the command list
    hr = CGenericProtoclEventDispatcher::InsertBindingWithHash(
                m_pDispatcher->m_rgpCommandList,
                m_pDispatcher->m_dwHashSize,
                &m_bnInfo,
                szCommandKeyword,
                cchCommandKeyword);
    if (SUCCEEDED(hr))
        m_pDispatcher->m_fSinksInstalled = TRUE;

    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}


//
// Outbound dispatcher methods
//
void COutboundDispatcher::InitializeDefaultCommandBindings()
{
    for (DWORD i = 0; i < PE_STATE_MAX_STATES; i++)
    {
        if (s_rgszDefaultCommand[i])
        {
            // Set up the list head
            m_rgpCommandList[i] = &(m_rgcnDefaultCommand[i]);

            // Set up the command node
            m_rgpCommandList[i]->pNext = NULL;
            m_rgpCommandList[i]->pszCommandKeyword = s_rgszDefaultCommand[i];
            m_rgpCommandList[i]->dwHighestPriority = PRIO_DEFAULT;
            m_rgpCommandList[i]->pFirstBinding = &(m_rgbnDefaultCommand[i]);

            // Set up the binding node
            m_rgbnDefaultCommand[i].pNext = NULL;
            m_rgbnDefaultCommand[i].dwPriority = PRIO_DEFAULT;
            m_rgbnDefaultCommand[i].dwFlags = PEBN_DEFAULT;
        }
        else
            m_rgpCommandList[i] = NULL;
    }
}

HRESULT COutboundDispatcher::AllocBinding(
            REFGUID         rguidEventType,
            IEventBinding   *piBinding,
            CBinding        **ppNewBinding
            )
{
    if (ppNewBinding)
        *ppNewBinding = NULL;
    if (!piBinding || !ppNewBinding)
        return(E_POINTER);

    *ppNewBinding = new COutboundBinding(this, rguidEventType);

    if (*ppNewBinding == NULL)
        return(E_OUTOFMEMORY);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE COutboundDispatcher::ChainSinks(
            IUnknown                *pServer,
            IUnknown                *pSession,
            IMailMsgProperties      *pMsg,
            ISmtpOutCommandContext  *pContext,
            DWORD                   dwEventType,
            LPPE_COMMAND_NODE       *ppPreviousCommand,
            LPPE_BINDING_NODE       *ppResumeFrom
            )
{
    HRESULT hr = S_OK;

    LPPE_COMMAND_NODE   pCommand = NULL;
    LPPE_BINDING_NODE   pBinding = NULL;

    _ASSERT(dwEventType < PE_OET_INVALID_EVENT_TYPE);

    TraceFunctEnterEx((LPARAM)this, "COutboundDispatcher::ChainSinks");

    // These are the essential pointers that CANNOT be NULL
    if (!pContext || !ppPreviousCommand || !ppResumeFrom)
        return(E_POINTER);

    // If we encounter a bad event type, just gracefully return
    // without doing anythig
    if (dwEventType >= PE_OET_INVALID_EVENT_TYPE)
    {
        *ppResumeFrom = NULL;
        ErrorTrace((LPARAM)this,
                "Skipping event due to bad event type %u",
                dwEventType);
        return(S_OK);
    }

    // What we do is strictly determined by the ppPreviousCommand
    // and ppResumeFrom pointers. The logic is as follows:
    //
    // ppPrevCmd    ppResumeFrom    Action
    //    NULL          NULL        Start from the first command for this event type
    //    NULL         !NULL        Start from the first command for this event type
    //   !NULL          NULL        Start from the first binding for the command
    //                                that follows *ppPreviousCommand
    //   !NULL         !NULL        Start from the exact binding specified in
    //                                *ppResumeFrom
    //
    // On exit, these pointers will be updated to the following:
    //
    // *ppPreviousCommand - This will point to the command node of the command
    //                      that was just processed
    // *ppResumeFrom      - This will be set to the next binding to resume from
    //                      This will be set to NULL if there are no more bindings

    if (!*ppPreviousCommand)
    {
        pCommand = m_rgpCommandList[dwEventType];
        if (!pCommand)
        {
            // Ooooops! We peeked with SinksInstalled() but now we have no sinks
            // This is an error but we will recover gracefully
            _ASSERT(pCommand);
            ErrorTrace((LPARAM)this, "ERROR! Empty command chain!!");
            return(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
        }

        // We check this downstream
        pBinding = pCommand->pFirstBinding;
    }
    else if (*ppResumeFrom)
    {
        // We resume from the exact binding as specified
        pCommand = *ppPreviousCommand;
        pBinding = *ppResumeFrom;
    }
    else
    {
        // We start with the next command in the list
        pCommand = (*ppPreviousCommand)->pNext;
        if (!pCommand)
        {
            DebugTrace((LPARAM)this, "No more commands to chain");
            *ppPreviousCommand = NULL;
            *ppResumeFrom = NULL;
            return(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
        }

        // We check this downstream
        pBinding = pCommand->pFirstBinding;
    }

    // DEBUG Check: we want the retail perf to be as high as possible
    // and we want it to be fail safe as well. We will do an internal
    // check here to make sure that any command node has at least one
    // binding, and that we have bindings when we expect them.
#ifdef DEBUG
    if (!pBinding)
    {
        // Ooooops! We have a command node without a binding. This is a blatant
        // error but we recover gracefully
        _ASSERT(pBinding);
        ErrorTrace((LPARAM)this, "ERROR! Empty binding chain!!");
        return(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
    }
#endif

    // We know exactly where to start chaining ... Do it.
    // Break when:
    // 1) The default handler binding is encountered, or
    // 2) Sinks results are S_OK
    // 3) No more bindings left
    COutboundBinding    *pOutboundBinding;
    IUnknown            *pUnkSink = NULL;
    ISmtpOutCommandSink *pSink;
    COutboundContext    *pCContext;

    // Initialize pContext->m_pCurrentCommandContext
    pCContext = (COutboundContext *)pContext;
    pCContext->m_pCurrentCommandContext = pCommand;

    hr = S_OK;
    while (pBinding && (hr == S_OK))
    {
        // One of the exiting conditions
        if (pBinding->dwFlags & PEBN_DEFAULT)
            break;

        // Get the containing binding class
        pOutboundBinding = CONTAINING_RECORD(
                    pBinding, COutboundBinding, m_bnInfo);

        // Call the sink
        hr = m_piEventManager->CreateSink(
                    pOutboundBinding->m_piBinding,
                    NULL,
                    &pUnkSink);
        if (SUCCEEDED(hr))
        {
            hr = pUnkSink->QueryInterface(
                        IID_ISmtpOutCommandSink,
                        (LPVOID *)&pSink);
            pUnkSink->Release();
            pUnkSink = NULL;
            if (SUCCEEDED(hr))
            {
                // Pre-fill in the next binding to avoid
                // race conditions in the async case
                *ppResumeFrom = pBinding->pNext;
                hr = pSink->OnSmtpOutCommand(
                            pServer,
                            pSession,
                            pMsg,
                            pContext);
                pSink->Release();
                if (hr == MAILTRANSPORT_S_PENDING)
                    hr = S_OK;
                //  break;
            }
            else
                hr = S_OK;
        }
        else
            hr = S_OK;

        // Next
        pBinding = pBinding->pNext;
    }

    // Return where to resume from ...
    *ppPreviousCommand = pCommand;
    *ppResumeFrom = pBinding;

    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}

//
// COutboundDispatcher::COutboundBinding methods
//
COutboundDispatcher::COutboundBinding::COutboundBinding(
            COutboundDispatcher *pDispatcher,
            REFGUID             rguidEventType
            )
{
    _ASSERT(pDispatcher);
    m_pDispatcher = pDispatcher;

    // Based on the event type GUID, we can calculate which
    // event type id this goes to
    for (m_dwEventType = 0;
         m_dwEventType < PE_OET_INVALID_EVENT_TYPE;
         m_dwEventType++)
        if (rguidEventType == *(s_rgrguidEventTypes[m_dwEventType]))
            break;
    // If the GUID is not recognized, then the final value of
    // m_dwEventType will be PE_OET_INVALID_EVENT_TYPE, which
    // we will not process in this dispatcher
}


HRESULT COutboundDispatcher::COutboundBinding::Init(
            IEventBinding *piBinding
            )
{
    HRESULT hr;
    CComPtr<IEventPropertyBag>  piEventProperties;
    CComVariant                 vRule;
    CHAR                        szCommandKeyword[256];
    DWORD                       cchCommandKeyword = 0;

    TraceFunctEnterEx((LPARAM)this,
            "COutboundDispatcher::COutboundBinding::Init");

    if (!piBinding || !m_pDispatcher)
        return(E_POINTER);

    // If the event type GUID is unknown, invalidate this binding
    if (m_dwEventType >= PE_OET_INVALID_EVENT_TYPE)
        return(E_INVALIDARG);

    // get the parent initialized
    hr = CBinding::Init(piBinding);
    if (FAILED(hr)) return hr;

    // Store the priority
    m_bnInfo.dwPriority = CBinding::m_dwPriority;
    m_bnInfo.dwFlags = 0;

    // get the binding database
    hr = m_piBinding->get_SourceProperties(&piEventProperties);
    if (FAILED(hr)) return hr;

    // get the rule from the binding database
    hr = piEventProperties->Item(&CComVariant("Rule"), &vRule);
    if (FAILED(hr)) return hr;

    // Process the VARIANT to obtain a lower-case ANSI string
    if (hr == S_OK)
    {
        cchCommandKeyword = sizeof(szCommandKeyword);
        hr = GetLowerAnsiStringFromVariant(
                    vRule,
                    szCommandKeyword,
                    &cchCommandKeyword);
    }
    else if(hr == S_FALSE)
    {
        //
        // Treat no rule as an empty string rule
        //
        szCommandKeyword[0] = '\0';
        cchCommandKeyword = 1;
    }


    // We cannot proceed without a rule, so we discard this binding
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM)this,
                "Failed to get keyword, error %08x", hr);
        return(hr);
    }
    if (!cchCommandKeyword)
        return(E_INVALIDARG);

    DebugTrace((LPARAM)this, "Rule: %s", szCommandKeyword);

    // Call the dispatcher to insert the node into the command list
    hr = CGenericProtoclEventDispatcher::InsertBinding(
                &((m_pDispatcher->m_rgpCommandList)[m_dwEventType]),
                &m_bnInfo,
                szCommandKeyword,
                cchCommandKeyword);
    if (SUCCEEDED(hr))
        m_pDispatcher->m_fSinksInstalled = TRUE;

    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}


//
// CResponseDispatcher mathods
//

HRESULT CResponseDispatcher::AllocBinding(
            REFGUID         rguidEventType,
            IEventBinding   *piBinding,
            CBinding        **ppNewBinding
            )
{
    if (ppNewBinding)
        *ppNewBinding = NULL;
    if (!piBinding || !ppNewBinding)
        return(E_POINTER);

    *ppNewBinding = new CResponseBinding(this);

    if (*ppNewBinding == NULL)
        return(E_OUTOFMEMORY);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CResponseDispatcher::ChainSinks(
            IUnknown                    *pServer,
            IUnknown                    *pSession,
            IMailMsgProperties          *pMsg,
            ISmtpServerResponseContext  *pContext,
            DWORD                       dwStopAtPriority,
            LPPE_COMMAND_NODE           pCommandNode,
            LPPE_BINDING_NODE           *ppResumeFrom
            )
{
    HRESULT hr = S_OK;

    LPPE_BINDING_NODE   pBinding = NULL;

    TraceFunctEnterEx((LPARAM)this, "CResponseDispatcher::ChainSinks");

    // These are the essential pointers that CANNOT be NULL
    if (!pContext || !pCommandNode || !ppResumeFrom)
        return(E_POINTER);

    // What we do is strictly determined by the ppPreviousCommand
    // and ppResumeFrom pointers. The logic is as follows:
    //
    // pCmdNode     ppResumeFrom    Action
    //    NULL          X           Error (E_POINTER)
    //   !NULL          NULL        Error (ERROR_NO_MORE_ITEMS)
    //   !NULL         !NULL        Start from the exact binding specified in
    //                                *ppResumeFrom
    //
    // On exit, these pointers will be updated to the following:
    //
    // *ppResumeFrom      - This will be set to the next binding to resume from
    //                      This will be set to NULL if there are no more bindings

    pBinding = *ppResumeFrom;
    if (!pBinding)
    {
        _ASSERT(FALSE);
        ErrorTrace((LPARAM)this, "ERROR! Empty binding chain!!");
        return(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
    }

    // We know exactly where to start chaining ... Do it.
    // Break when:
    // 1) The default handler binding is encountered, or
    // 2) Sinks results are S_OK
    // 3) No more bindings left
    CResponseBinding        *pResponseBinding;
    IUnknown                *pUnkSink = NULL;
    ISmtpServerResponseSink *pSink;

    hr = S_OK;
    *ppResumeFrom = pBinding;
    while (pBinding && (hr == S_OK))
    {
        // One of the exiting conditions
        if (pBinding->dwPriority > dwStopAtPriority)
            break;

        // Get the containing binding class
        pResponseBinding = CONTAINING_RECORD(
                    pBinding, CResponseBinding, m_bnInfo);

        // Call the sink
        hr = m_piEventManager->CreateSink(
                    pResponseBinding->m_piBinding,
                    NULL,
                    &pUnkSink);
        if (SUCCEEDED(hr))
        {
            hr = pUnkSink->QueryInterface(
                        IID_ISmtpServerResponseSink,
                        (LPVOID *)&pSink);
            pUnkSink->Release();
            pUnkSink = NULL;
            if (SUCCEEDED(hr))
            {
                // Pre-fill in the next binding to avoid
                // race conditions in the async case
                hr = pSink->OnSmtpServerResponse(
                            pServer,
                            pSession,
                            pMsg,
                            pContext);
                pSink->Release();
                if (hr == MAILTRANSPORT_S_PENDING)
                    hr = S_OK;
                //  break;
            }
            else
                hr = S_OK;
        }
        else
            hr = S_OK;

        // Next
        pBinding = pBinding->pNext;
        *ppResumeFrom = pBinding;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}

//
// CResponseDispatcher::CResponseBinding methods
//
HRESULT CResponseDispatcher::CResponseBinding::Init(
            IEventBinding *piBinding
            )
{
    HRESULT hr;
    CComPtr<IEventPropertyBag>  piEventProperties;
    CComVariant                 vRule;
    CHAR                        szCommandKeyword[256];
    DWORD                       cchCommandKeyword = 0;

    TraceFunctEnterEx((LPARAM)this,
            "CResponseDispatcher::CResponseBinding::Init");

    if (!piBinding || !m_pDispatcher)
        return(E_POINTER);

    // get the parent initialized
    hr = CBinding::Init(piBinding);
    if (FAILED(hr)) return hr;

    // Store the priority
    m_bnInfo.dwPriority = CBinding::m_dwPriority;
    m_bnInfo.dwFlags = 0;

    // get the binding database
    hr = m_piBinding->get_SourceProperties(&piEventProperties);
    if (FAILED(hr)) return hr;

    // get the rule from the binding database
    hr = piEventProperties->Item(&CComVariant("Rule"), &vRule);
    if (FAILED(hr)) return hr;

    // Process the VARIANT to obtain a lower-case ANSI string
    if (hr == S_OK)
    {
        cchCommandKeyword = sizeof(szCommandKeyword);
        hr = GetLowerAnsiStringFromVariant(
                    vRule,
                    szCommandKeyword,
                    &cchCommandKeyword);
    }

    // We cannot proceed without a rule, so we discard this binding
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM)this,
                "Failed to get keyword, error %08x", hr);
        return(hr);
    }
    if (!cchCommandKeyword || !(*szCommandKeyword))
        return(E_INVALIDARG);

    DebugTrace((LPARAM)this, "Rule: %s", szCommandKeyword);

    // Call the dispatcher to insert the node into the command list
    hr = CGenericProtoclEventDispatcher::InsertBindingWithHash(
                m_pDispatcher->m_rgpCommandList,
                m_pDispatcher->m_dwHashSize,
                &m_bnInfo,
                szCommandKeyword,
                cchCommandKeyword);
    if (SUCCEEDED(hr))
        m_pDispatcher->m_fSinksInstalled = TRUE;

    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\pe_out.cxx ===
/*++

   Copyright (c) 1998    Microsoft Corporation

   Module  Name :

        pe_out.cxx

   Abstract:

        This module defines the outbound protocol event classes

   Author:

           Keith Lau    (KeithLau)    6/18/98

   Project:

           SMTP Server DLL

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/


#define INCL_INETSRV_INCS
#include "smtpinc.h"

//
// ATL includes
//
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL

//
// SEO includes
//
#include "seo.h"
#include "seolib.h"

#include <memory.h>
#include "smtpcli.hxx"
#include "smtpout.hxx"

//
// Dispatcher implementation
//
#include "pe_dispi.hxx"


HRESULT SMTP_CONNOUT::GetNextResponse(
            char        *InputLine,
            DWORD       BufSize,
            char        **NextInputLine,
            LPDWORD     pRemainingBufSize,
            DWORD       UndecryptedTailSize
            )
{
    HRESULT hr                  = S_OK;
    char    *Buffer             = NULL;
    char    *pszSearch          = NULL;
    BOOL    fFullLine           = FALSE;
    DWORD   IntermediateSize    = 0;

    TraceFunctEnterEx((LPARAM)this,
                "SMTP_CONNOUT::GetNextResponse");

    _ASSERT(InputLine);
    if (!InputLine)
        return(E_POINTER);

    // Start at the beginning
    Buffer = InputLine;

    // We only process full lines (i.e. ends with CRLF)
    while (pszSearch = IsLineComplete(Buffer, BufSize))
    {
        // Calculate the size of the line
        IntermediateSize = (DWORD)((pszSearch - Buffer) + 2); //+2 for CRLF

        // Make sure the response at least contains an error code
        if (IntermediateSize >=  5)
        {
            if(IntermediateSize == 5)
            {
                //We have a 250CRLF type response - which according to
                //Drums draft is now legit
                // Get the error code
                Buffer[3] = '\0';
                m_ResponseContext.m_dwSmtpStatus = atoi(Buffer);
                Buffer [3] = CR;
                fFullLine = TRUE;
            }
            else
            {
                // If we encounter a multi-line response, we will keep
                // parsing
                if (Buffer[3] == '-')
                {
                    // Try to append the line, this can only fail due
                    // to out of memory
                    hr = m_ResponseContext.m_cabResponse.Append(
                                Buffer,
                                IntermediateSize,
                                NULL);
                    if (FAILED(hr))
                        return(hr);

                    // Go to the next line
                    Buffer += IntermediateSize;
                    BufSize -= IntermediateSize;
                    continue;
                }
                if (Buffer[3] == ' ')
                {
                    // Get the error code
                    Buffer[3] = '\0';
                    m_ResponseContext.m_dwSmtpStatus = atoi(Buffer);
                    Buffer [3] = ' ';
                    fFullLine = TRUE;
                }
                else
                {
                    //We got some crap
                    m_ResponseContext.m_dwSmtpStatus = 0;
                    fFullLine = TRUE;
                }
            }
        }

        // Try to append the line, this can only fail due
        // to out of memory
        hr = m_ResponseContext.m_cabResponse.Append(
                    Buffer,
                    IntermediateSize,
                    NULL);
        if (FAILED(hr))
            return(hr);

        // Adjust the counters
        Buffer += IntermediateSize;
        BufSize -= IntermediateSize;

        // If we have a full response (single or multi-line)
        if (fFullLine)
            break;
    }

    if (fFullLine)
    {
        char    cTerm = '\0';

        // NULL-temrinate it
        hr = m_ResponseContext.m_cabResponse.Append(&cTerm, 1, NULL);
        if (FAILED(hr))
            return(hr);
        else
        {
            // We got a full response. Mark the pointers for
            // the next response
            if (NextInputLine)
                *NextInputLine = Buffer;
            if (pRemainingBufSize)
                *pRemainingBufSize = BufSize;
        }
    }
    else
    {
        // We have either a partial or empty line, either case
        // we need another completion for more data
        hr = S_FALSE;
        MoveMemory((void *)QueryMRcvBuffer(),
                    Buffer,
                    BufSize + UndecryptedTailSize);
        m_cbParsable = BufSize;
        m_cbReceived = BufSize + UndecryptedTailSize;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}

HRESULT SMTP_CONNOUT::BuildCommandQEntry(
            LPOUTBOUND_COMMAND_Q_ENTRY  *ppEntry,
            BOOL                        *pfUseNative
            )
{
    // Build a command entry
    DWORD                       dwKeywordLength = 0;
    DWORD                       dwTotalLength = 0;
    LPSTR                       szTemp;
    LPSTR                       pTemp = NULL;
    LPOUTBOUND_COMMAND_Q_ENTRY  pEntry;
    BOOL                        fUseNative = FALSE;

    if (!ppEntry)
        return(E_POINTER);
    *ppEntry = NULL;

    // Determine which response to use
    szTemp = m_OutboundContext.m_cabCommand.Buffer();
    if (!*szTemp)
    {
        szTemp = m_OutboundContext.m_cabNativeCommand.Buffer();
        dwTotalLength = m_OutboundContext.m_cabNativeCommand.Length();
        fUseNative = TRUE;

        // If we have nothing in the buffer, we will return S_FALSE
        if (!*szTemp)
            return(S_FALSE);
    }
    else
        dwTotalLength = m_OutboundContext.m_cabCommand.Length();

    // Determine the length of the keyword
    while ((*szTemp != ' ') && (*szTemp != '\0') && (*szTemp != '\r'))
    {
        szTemp++;
        dwKeywordLength++;
    }
    dwKeywordLength++;

    // Determine the total required buffer size
    //NK** add a byte at end to hold the null
    dwTotalLength +=
        (sizeof(OUTBOUND_COMMAND_Q_ENTRY) + dwKeywordLength + 1);

    pTemp = new CHAR [dwTotalLength];
    if (!pTemp)
        return(E_OUTOFMEMORY);

    pEntry = (LPOUTBOUND_COMMAND_Q_ENTRY)pTemp;
    pTemp += sizeof(OUTBOUND_COMMAND_Q_ENTRY);
    pEntry->dwFlags = 0;

    // Set the pipelined flag
    if (m_OutboundContext.m_dwCommandStatus & EXPE_PIPELINED)
        pEntry->dwFlags |= PECQ_PIPELINED;

    // Copy the command keyword
    if (fUseNative)
        szTemp = m_OutboundContext.m_cabNativeCommand.Buffer();
    else
        szTemp = m_OutboundContext.m_cabCommand.Buffer();
    pEntry->pszCommandKeyword = (LPSTR)pTemp;
    if (dwKeywordLength > 1)
    {
        LPSTR   pszTemp = szTemp;
        while (--dwKeywordLength)
            *pTemp++ = (CHAR)tolower(*pszTemp++);
    }
    *pTemp++ = '\0';

    // Copy the full command
    pEntry->pszFullCommand = (LPSTR)pTemp;
    lstrcpy((LPSTR)pTemp, (LPSTR)szTemp);

    *ppEntry = pEntry;
    *pfUseNative = fUseNative;
    return(S_OK);
}


///////////////////////////////////////////////////////////////////
//
//  This function should only be called from GlueDispatch
//
//  It micro-manages sink firing scenarios



HRESULT SMTP_CONNOUT::OnOutboundCommandEvent(
            IUnknown        *pServer,
            IUnknown        *pSession,
            DWORD           dwEventType,
            BOOL            fRepeatLastCommand,
            PMFI            pDefaultOutboundHandler
            )
{
    HRESULT hr = S_OK;
    BOOL    fResult = TRUE;
    BOOL    fFireEvent = TRUE;

    ISmtpOutCommandContext  *pContext = (ISmtpOutCommandContext *) &m_OutboundContext;

    // d:\ex\staxpt\src\mail\smtp\server\pe_out.cxx(265) : fatal error C1001: INTERNAL COMPILER ERROR
    //  (compiler file 'E:\utc\src\\P2\main.c', line 379)
    // Please choose the Technical Support command on the Visual C++
    // Help menu, or open the Technical Support help file for more information
    //_ASSERT(pDefaultOutboundHandler);

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::OnOutboundCommandEvent");

    // First, we want to make sure that both the command and response
    // dispatchers are not NULL. If they are NULL, then we just call the
    // default handler, if any.
    if (m_pOutboundDispatcher && m_pResponseDispatcher)
    {
        // Now, we take a peek at the bindings and see if we have
        // any sinks installed for this event type
        hr = m_pOutboundDispatcher->SinksInstalled(dwEventType);
        if (hr != S_OK)
        {
            fFireEvent = FALSE;
            DebugTrace((LPARAM)this,
                "There are no sink bindings for this event type");
        }
    }
    else
    {
        fFireEvent = FALSE;
        DebugTrace((LPARAM)this, "Sinks will not be fired because dispatcher NULL");
    }

    // Fire the event accordingly
    // The outbound event is different from the other protocol events
    // For this event, we really don't know when the default handler
    // should be fired. There are two scenarios when we know to fire
    // the default handler:
    //
    // 1) We call the next set of sinks. If the ChainSinks call returns
    //    S_OK and pfFireDefaultHandler returns TRUE, then we will fire
    //    the default handler
    // 2) If we are not able to fire sinks due to a missing dispatcher,
    //    we will fire the default handler (if there is one), and call
    //    it done.

    LPPE_COMMAND_NODE   pCommandNode = NULL;
    LPPE_BINDING_NODE   pBindingNode = NULL;

    if (fFireEvent)
    {
        BOOL    fFireDefaultHandler = FALSE;

        // Set it up for the dispatcher
        pBindingNode    = NULL;
        pCommandNode    = m_OutboundContext.m_pCurrentCommandContext;

        // Now, if we are asked to repeat the last command, we will have to
        // set up the binding node
        if (fRepeatLastCommand)
        {
            _ASSERT(m_OutboundContext.m_pCurrentCommandContext);
            pBindingNode = m_OutboundContext.m_pCurrentCommandContext->pFirstBinding;
        }

        hr = m_pOutboundDispatcher->ChainSinks(
                    pServer,
                    pSession,
                    m_pIMsg,
                    pContext,
                    dwEventType,
                    &pCommandNode,
                    &pBindingNode
                    );

        // If the event is consumed or if there are no more bindgins
        // left, we will jump to analyze the status codes.
        if ((hr == S_FALSE) || (hr == EXPE_S_CONSUMED))
            goto Analysis;
        if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
            goto Analysis;
        if (FAILED(hr))
            goto Abort;

        // See if we are asked to fire the default handler
        if (pBindingNode)
        {
            // We must have aborted due to default handler, verify this
            // Also verify that we have a default handler ...
            _ASSERT(pBindingNode->dwFlags & PEBN_DEFAULT);
            // The following line results in fatal error C1001: INTERNAL COMPILER ERROR
            //_ASSERT(pDefaultOutboundHandler);

            fResult = (this->*pDefaultOutboundHandler)(NULL, 0, 0);
            if(!fResult)
                m_OutboundContext.m_dwCommandStatus = EXPE_DROP_SESSION;

            // Call the dispatcher to process any remaining sinks
            pBindingNode = pBindingNode->pNext;
            if (pBindingNode)
            {
                hr = m_pOutboundDispatcher->ChainSinks(
                            pServer,
                            pSession,
                            m_pIMsg,
                            pContext,
                            dwEventType,
                            &pCommandNode,
                            &pBindingNode
                            );
            }
        }
    }
    else if (pDefaultOutboundHandler)
    {
        // If we already fired the default handler, unless we are
        // asked to repeat, we are plain done
        if (!m_fNativeHandlerFired ||
            fRepeatLastCommand)
        {
            fResult = (this->*pDefaultOutboundHandler)(NULL, 0, 0);
            if(!fResult)
                m_OutboundContext.m_dwCommandStatus = EXPE_DROP_SESSION;

            m_fNativeHandlerFired = TRUE;
        }
        else
        {
            // We are done ...
            hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            m_fNativeHandlerFired = FALSE;
            m_OutboundContext.m_dwCommandStatus = EXPE_SUCCESS;
        }
    }
    else
    {
        // No sinks and no default handler? We're done.
        hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        m_fNativeHandlerFired = FALSE;
        m_OutboundContext.m_dwCommandStatus = EXPE_SUCCESS;
    }

Analysis:

    // Update the context values
    m_OutboundContext.m_pCurrentCommandContext = pCommandNode;
    m_OutboundContext.m_pCurrentBinding = pBindingNode;

    if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
    {
        // Reset the context values
        _ASSERT(!m_OutboundContext.m_pCurrentCommandContext);
        _ASSERT(!m_OutboundContext.m_pCurrentBinding);

        m_OutboundContext.m_dwCommandStatus = EXPE_SUCCESS;
    }
    else
    {
        // If we don't have a status code, something is wrong. We will
        // assert in debug and drop the connection in reality.
        //
        // This is possible when misbehaving high-priority sinks consume
        // the event without setting the status code.
        if (m_OutboundContext.m_dwCommandStatus == EXPE_UNHANDLED)
        {
            ErrorTrace((LPARAM)this, "The outbound status code is undefined!");
            m_OutboundContext.m_dwCommandStatus = EXPE_DROP_SESSION;
        }
    }

Abort:

    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}


HRESULT SMTP_CONNOUT::OnServerResponseEvent(
            IUnknown                    *pServer,
            IUnknown                    *pSession,
            PMFI                        pDefaultResponseHandler
            )
{
    HRESULT hr = S_OK;
    BOOL    fResult = TRUE;
    BOOL    fFireEvent = TRUE;

    LPPE_COMMAND_NODE   pCommandNode = NULL;
    LPPE_BINDING_NODE   pBindingNode = NULL;

    ISmtpServerResponseContext  *pContext = (ISmtpServerResponseContext *) &m_ResponseContext;

    _ASSERT(m_ResponseContext.m_pCommand);

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::OnServerResponseEvent");

    // First, we want to make sure that both the command and response
    // dispatchers are not NULL. If they are NULL, then we just call the
    // default handler, if any.
    if (m_pOutboundDispatcher && m_pResponseDispatcher)
    {
        // Now, we take a peek at the bindings and see if we have
        // any sinks installed for this command
        hr = m_pResponseDispatcher->SinksInstalled(
                    m_ResponseContext.m_pCommand->pszCommandKeyword,
                    &pCommandNode);
        if (hr != S_OK)
        {
            fFireEvent = FALSE;
            DebugTrace((LPARAM)this,
                "There are no sink bindings for this command");
        }
    }
    else
    {
        fFireEvent = FALSE;
        DebugTrace((LPARAM)this, "Sinks will not be fired because dispatcher NULL");
    }

    if (fFireEvent)
    {
        _ASSERT(pCommandNode);
        pBindingNode = pCommandNode->pFirstBinding;
        _ASSERT(pBindingNode);
    }

    // Fire the event accordingly
    hr = S_OK;
    if (pDefaultResponseHandler)
    {
        DebugTrace((LPARAM)this, "Calling sinks for native command <%s>",
                    m_ResponseContext.m_pCommand->pszCommandKeyword);
        if (fFireEvent)
        {
            hr = m_pResponseDispatcher->ChainSinks(
                        pServer,
                        pSession,
                        m_pIMsg,
                        pContext,
                        PRIO_DEFAULT,
                        pCommandNode,
                        &pBindingNode
                        );
            if ((hr == S_FALSE) || (hr == EXPE_S_CONSUMED))
                goto Analysis;
            if (FAILED(hr))
                goto Abort;
        }

        fResult = (this->*pDefaultResponseHandler)(
                    m_ResponseContext.m_cabResponse.Buffer(),
                    m_ResponseContext.m_cabResponse.Length(),
                    0);
        if(!fResult)
            m_ResponseContext.m_dwResponseStatus = EXPE_DROP_SESSION;

        if (fFireEvent && pBindingNode)
            hr = m_pResponseDispatcher->ChainSinks(
                        pServer,
                        pSession,
                        m_pIMsg,
                        pContext,
                        PRIO_LOWEST,
                        pCommandNode,
                        &pBindingNode
                        );
    }
    else
    {
        DebugTrace((LPARAM)this, "Calling sinks for non-native command <%s>",
                    m_ResponseContext.m_pCommand->pszCommandKeyword);
        if (fFireEvent)
        {
            hr = m_pResponseDispatcher->ChainSinks(
                        pServer,
                        pSession,
                        m_pIMsg,
                        pContext,
                        PRIO_LOWEST,
                        pCommandNode,
                        &pBindingNode
                        );

            // Fall back to "*" sinks
            if ((hr == S_OK) &&
                (m_ResponseContext.m_dwResponseStatus == EXPE_UNHANDLED))
            {
                hr = m_pResponseDispatcher->SinksInstalled(
                            "*",
                            &pCommandNode);
                if (hr == S_OK)
                {
                    _ASSERT(pCommandNode);
                    pBindingNode = pCommandNode->pFirstBinding;
                    _ASSERT(pBindingNode);
                    hr = m_pResponseDispatcher->ChainSinks(
                                pServer,
                                pSession,
                                m_pIMsg,
                                pContext,
                                PRIO_LOWEST,
                                pCommandNode,
                                &pBindingNode
                                );
                }
                else
                    hr = S_OK;
            }
        }
    }

Analysis:

    // If no sinks has handled the response, we will invoke
    // a default handler. This will fail and drop the connection if
    // the SMTP response code is anything other than a complete success.
    if (m_ResponseContext.m_dwResponseStatus == EXPE_UNHANDLED)
    {
        if (!IsSmtpCompleteSuccess(m_ResponseContext.m_dwSmtpStatus))
            m_ResponseContext.m_dwResponseStatus = EXPE_DROP_SESSION;
        else
            m_ResponseContext.m_dwResponseStatus = EXPE_SUCCESS;
        hr = S_OK;
    }

Abort:

    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}


#define MAX_OUTSTANDING_COMMANDS    500

BOOL SMTP_CONNOUT::GlueDispatch(
            const char  *InputLine,
            DWORD       ParameterSize,
            DWORD       UndecryptedTailSize,
            DWORD       dwOutboundEventType,
            PMFI        pDefaultOutboundHandler,
            PMFI        pDefaultResponseHandler,
            LPSTR       szDefaultResponseHandlerKeyword,
            BOOL        *pfDoneWithEvent,
            BOOL        *pfAbortEvent
            )
{
    HRESULT hr;
    BOOL    fResult = TRUE;
    BOOL    fRepeatLastCommand = FALSE;
    BOOL    fSendBinaryBlob = FALSE;
    DWORD   dwBuffer = 0;
    BOOL    fStateChange = FALSE;
    BOOL    fResponsesHandled = FALSE;
    PMFI    pfnNextState = NULL;
    char    chErrorPrefix = SMTP_COMPLETE_SUCCESS;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::GlueDispatch");

    _ASSERT(m_pInstance);
    _ASSERT(m_pIEventRouter);

    m_ResponseContext.m_pCommand = NULL;

    // Check args.
    if (!InputLine || !pfDoneWithEvent || !pfAbortEvent ||
        !m_pInstance || !m_pIEventRouter)
    {
        ErrorTrace((LPARAM) this, "NULL Pointer");
        TraceFunctLeaveEx((LPARAM)this);
        SetLastError(E_POINTER);
        return(FALSE);
    }
    if (dwOutboundEventType >= PE_OET_INVALID_EVENT_TYPE)
    {
        ErrorTrace((LPARAM) this,
                "Skipping event because of bad outbound event type");
        TraceFunctLeaveEx((LPARAM)this);
        return(TRUE);
    }

    // By default we are still going
    *pfDoneWithEvent = FALSE;
    *pfAbortEvent = FALSE;

    // Get the dispatcher if we don't already have it ...
    if (!m_pOutboundDispatcher)
    {
        hr = m_pIEventRouter->GetDispatcherByClassFactory(
                    CLSID_COutboundDispatcher,
                    &g_cfOutbound,
                    *(COutboundDispatcher::s_rgrguidEventTypes[dwOutboundEventType]),
                    IID_ISmtpOutboundCommandDispatcher,
                    (IUnknown **)&m_pOutboundDispatcher);
        if(!SUCCEEDED(hr))
        {
            // If we fail, we will not fire protocol events
            m_pOutboundDispatcher = NULL;
            ErrorTrace((LPARAM) this,
                "Unable to get outbound dispatcher from router (%08x)", hr);
        }
    }

    //
    // We make sure we will not send out new commands until all our
    // queued commands' responses are received and processed.
    //
    if (InputLine)
    {
        // Handle responses first, followed by generating commands
        char    *pResponses = (char *)InputLine;
        DWORD   dwRemaining = ParameterSize;

        while (!m_FifoQ.IsEmpty())
        {
            // Parse out the next response
            hr = GetNextResponse(
                        pResponses,
                        dwRemaining,
                        &pResponses,
                        &dwRemaining,
                        UndecryptedTailSize);
            if (hr == S_OK)
            {
                //
                // jstamerj 1998/10/30 12:37:28:
                //   Set the correct next state in the response context
                //
                m_ResponseContext.m_dwNextState = CResponseDispatcher::PeStateFromOutboundEventType((OUTBOUND_EVENT_TYPES)dwOutboundEventType);

                // We have a full response, now dequeue the corresponding
                // command entry
                m_ResponseContext.m_pCommand = (LPOUTBOUND_COMMAND_Q_ENTRY)m_FifoQ.Dequeue();

                // This should not be NULL at any time!
                _ASSERT(m_ResponseContext.m_pCommand);

                DebugTrace((LPARAM)this, "Processing Response <%s> for <%s>",
                            m_ResponseContext.m_cabResponse.Buffer(),
                            m_ResponseContext.m_pCommand->pszFullCommand);

                // All except for the last item in the queue must be pipelined
                if (!m_FifoQ.IsEmpty())
                {
                    _ASSERT((m_ResponseContext.m_pCommand->dwFlags & PECQ_PIPELINED) != 0);
                }

                // Call the event handler
                hr = OnServerResponseEvent(
                            m_pInstance->GetInstancePropertyBag(),
                            GetSessionPropertyBag(),
                            (strcmp(m_ResponseContext.m_pCommand->pszCommandKeyword,
                                szDefaultResponseHandlerKeyword) == 0)?
                                pDefaultResponseHandler:
                                NULL
                            );

                // We will ignore all responses to commands that are
                // pipelined. If the command that caused this response is
                // not pipelined, it will fall through this loop and be
                // handled downstream.
                fResponsesHandled = TRUE;

                // Delete the command entry ...
                LPBYTE  pTemp = (LPBYTE)m_ResponseContext.m_pCommand;
                delete [] pTemp;

                pTemp = NULL;
                //Check if we really want to continue
                if( m_ResponseContext.m_dwResponseStatus == EXPE_TRANSIENT_FAILURE ||
                     m_ResponseContext.m_dwResponseStatus == EXPE_COMPLETE_FAILURE )
                {
                    //Free up the command list
                    while(pTemp = (LPBYTE)m_FifoQ.Dequeue())
                    {
                        delete [] pTemp;
                        pTemp = NULL;
                    }
                    //break out of the command loop
                    break;
                }

                // We are done with this response, and the FIFO is not empty,
                // we will reset the context
                if (!m_FifoQ.IsEmpty())
                    m_ResponseContext.ResetResponseContext();
            }
            else if (hr == S_FALSE)
                // This means that the whole buffer received is not long enough
                // to hold the next response. We will wait for the remainder.
                // This might take several completions if needed.
                // Make sure we don't reset the response context at this point
                // or we will lose the previous buffer.
                break;
            else
            {
                // No memory to get the response buffer, slam the connection
                DebugTrace((LPARAM)this, "Failed to GetNextResponse (%08x)", hr);
                TraceFunctLeaveEx((LPARAM)this);
                return(FALSE);
            }
        }
    }

    // If we have exhausted all responses and still our command queue
    // is not empty, we need to pend another read for more responses
    if (!m_FifoQ.IsEmpty())
    {
        DebugTrace((LPARAM)this, "Pending a read for more response data");
        TraceFunctLeaveEx((LPARAM)this);
        return(TRUE);
    }

    // Okay, we are now done all queued responses. Before we send out more
    // commands, we want to check if a sink wanted to change the state. If
    // so, we will honor this state change ...
    if (fResponsesHandled)
    {
        switch (m_ResponseContext.m_dwResponseStatus)
        {
        case EXPE_SUCCESS:
            break;

        case EXPE_TRANSIENT_FAILURE:
            chErrorPrefix = SMTP_TRANSIENT_FAILURE;
            pfnNextState = DoCompletedMessage;
            fStateChange = TRUE;
            break;

        case EXPE_COMPLETE_FAILURE:
            chErrorPrefix = SMTP_COMPLETE_FAILURE;
            pfnNextState = DoCompletedMessage;
            fStateChange = TRUE;
            break;

        case EXPE_REPEAT_COMMAND:
            fRepeatLastCommand = TRUE;
            break;

        case EXPE_DROP_SESSION:
            DisconnectClient();
            *pfDoneWithEvent = TRUE;
            *pfAbortEvent = TRUE;
            fResult = FALSE;
            break;

        case EXPE_CHANGE_STATE:
            // Figure out which state pointer to jump to
            switch (m_ResponseContext.m_dwNextState)
            {
            case PE_STATE_SESSION_START:
                pfnNextState = DoSessionStartEvent;
                break;
            case PE_STATE_MESSAGE_START:
                pfnNextState = DoMessageStartEvent;
                break;
            case PE_STATE_PER_RECIPIENT:
                pfnNextState = DoPerRecipientEvent;
                break;
            case PE_STATE_DATA_OR_BDAT:
                pfnNextState = DoBeforeDataEvent;
                break;
            case PE_STATE_SESSION_END:
                pfnNextState = DoSessionEndEvent;
                break;
            default:
                ErrorTrace((LPARAM)this,
                            "Bad next state %u, ignoring ...",
                            m_ResponseContext.m_dwNextState);
            }
            if (pfnNextState)
            {
                *pfDoneWithEvent = TRUE;
                fStateChange = TRUE;
            }
            break;

        case EXPE_UNHANDLED:
            _ASSERT(FALSE);
            break;

        default:
            _ASSERT(FALSE);
        }
    }

    // OK, now we are clear to send the next command ...
    // If the result is already FALSE, we are going to disconnect. Then there
    // is no point generating more commands ...
    //
    // Also, if we are returning from some other state, we just leave
    if (fResult && !fStateChange)
    {
        //NK** : I moved this from outside if to inside. Need to do this to preserve the response in cases where we hit
        //TRANSIENT or permanent errorn
        // Reset the response context
        m_ResponseContext.ResetResponseContext();

        //we need to save the first pipelined address so we can
        //start at this address and check the replies
        m_FirstPipelinedAddress = m_NextAddress;

        do
        {
            BOOL    fUseNative = FALSE;

            // Reset the context
            m_OutboundContext.ResetOutboundContext();

            // Catch here: set what the next address is so that other
            // sinks can at least have a clue who the current recipient is.
            //
            // jstamerj 1998/10/22 17:26:54: Sinks are really
            // interested in the recipient index in the mailmsg, not
            // the index into our private array.  Give them that
            // instead.
            //
            if((dwOutboundEventType == PE_OET_PER_RECIPIENT) &&
               (m_NextAddress < m_NumRcpts))
                m_OutboundContext.m_dwCurrentRecipient = m_RcptIndexList[m_NextAddress];

            // Raise the outbound event ...
            hr = OnOutboundCommandEvent(
                        m_pInstance->GetInstancePropertyBag(),
                        GetSessionPropertyBag(),
                        dwOutboundEventType,
                        fRepeatLastCommand,
                        pDefaultOutboundHandler);
            fRepeatLastCommand = FALSE;

            // See if we are done with this event type
            if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
            {
                DebugTrace((LPARAM)this, "Done processing this event, leaving ...");
                *pfDoneWithEvent = TRUE;
                break;
            }

            // See if the last command should be repeated
            if ((m_OutboundContext.m_dwCommandStatus != EXPE_UNHANDLED) &&
                (m_OutboundContext.m_dwCommandStatus & EXPE_REPEAT_COMMAND))
                fRepeatLastCommand = TRUE;

            // See if we're sending blob rather then the command
            if ((m_OutboundContext.m_dwCommandStatus != EXPE_UNHANDLED) &&
                (m_OutboundContext.m_dwCommandStatus & EXPE_BLOB_READY))
                fSendBinaryBlob = TRUE;

            // Handle the status codes, minus the repeat flag ...
            switch (m_OutboundContext.m_dwCommandStatus & (~EXPE_REPEAT_COMMAND) & (~EXPE_BLOB_READY))
            {
            case EXPE_PIPELINED:

                // If the remote server does not support pipelineing,
                // we will honor that.
                if(!IsOptionSet(PIPELINE_OPTION) || !m_pInstance->ShouldPipeLineOut())
                    m_OutboundContext.m_dwCommandStatus = EXPE_NOT_PIPELINED;
                // Fall Thru ...

            case EXPE_SUCCESS:
                {
                    LPOUTBOUND_COMMAND_Q_ENTRY  pEntry = NULL;
                    LPSTR                       pBuffer;

                    // Build the entry
                    hr = BuildCommandQEntry(&pEntry, &fUseNative);
                    if (FAILED(hr))
                    {
                        chErrorPrefix = SMTP_TRANSIENT_FAILURE;
                        pfnNextState = DoCompletedMessage;
                        fStateChange = TRUE;
                        break;
                    }

                    if (hr == S_OK)
                    {
                        // Push the command into the FIFO queue
                        if (!m_FifoQ.Enqueue((LPVOID)pEntry))
                        {
                            // Since pEntry is never NULL here, we will always succeed
                            _ASSERT(FALSE);
                        }

                        // Write out the command to the real buffer
                        // If the buffer is not big enough, this will write and
                        // flush multiple times until the command is sent
                        pBuffer = (fUseNative)?
                                m_OutboundContext.m_cabNativeCommand.Buffer():
                                m_OutboundContext.m_cabCommand.Buffer();

                        if ( fSendBinaryBlob) {
                            FormatBinaryBlob( m_OutboundContext.m_pbBlob, m_OutboundContext.m_cbBlob);
                        } else {
                            //FormatSmtpMessage will use the first string
                            //as a format string.  Since we obviously have no
                            //arguments, any %'s in pBuffer will cause sprintf
                            //to AV. We must force FormatSmtpMessage to not use
                            //pBuffer as a format string.
                            FormatSmtpMessage(FSM_LOG_ALL, "%s", pBuffer);
                        }
                    }
                }
                break;

            case EXPE_TRANSIENT_FAILURE:
                chErrorPrefix = SMTP_TRANSIENT_FAILURE;
                pfnNextState = DoCompletedMessage;
                fStateChange = TRUE;
                break;

            case EXPE_COMPLETE_FAILURE:
                chErrorPrefix = SMTP_COMPLETE_FAILURE;
                pfnNextState = DoCompletedMessage;
                fStateChange = TRUE;
                break;

            case EXPE_DROP_SESSION:
                DisconnectClient();
                *pfAbortEvent = TRUE;
                *pfDoneWithEvent = TRUE;
                fResult = FALSE;
                break;

            case EXPE_UNHANDLED:
            default:
                DisconnectClient();
                *pfAbortEvent = TRUE;
                *pfDoneWithEvent = TRUE;
                fResult = FALSE;
            }

        } while (m_FifoQ.IsEmpty() ||
                 ((m_OutboundContext.m_dwCommandStatus & EXPE_PIPELINED) &&
                     m_FifoQ.Length() < MAX_OUTSTANDING_COMMANDS));

        // OK, we can flush these commands ...
        fResult = SendSmtpResponse();
    }

    // Make sure we free the outbound dispatcher before
    // exiting or jumping states.
    if (*pfDoneWithEvent || fStateChange)
    {
        if(fStateChange)
            m_fNativeHandlerFired = FALSE;

        // Release the dispatcher
        if (m_pOutboundDispatcher)
        {
            m_pOutboundDispatcher->Release();
            m_pOutboundDispatcher = NULL;
        }

        if (pfnNextState)
        {
            // Call the next state handler
            *pfDoneWithEvent = TRUE;
            *pfAbortEvent = TRUE;
            //
            // jstamerj 1998/11/01 18:51:01: Since we're jumping to
            // another state, reset the variable that keeps track
            // of which command we're firing.
            //
            m_OutboundContext.m_pCurrentCommandContext = NULL;

            DebugTrace((LPARAM)this, "Jumping to another state");
            fResult = (this->*pfnNextState)(&chErrorPrefix, 1, 0);
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(fResult);
}

BOOL SMTP_CONNOUT::DoSessionStartEvent(
            char    *InputLine,
            DWORD   ParameterSize,
            DWORD   UndecryptedTailSize
            )
{
    BOOL    fResult = TRUE;
    BOOL    fDoneEvent = FALSE;
    BOOL    fAbortEvent = FALSE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNOUT::DoSessionStartEvent");

    // Always set the state to itself
    SetNextState (&SMTP_CONNOUT::DoSessionStartEvent);

    // Call the catch-all handler
    fResult = GlueDispatch(
                InputLine,
                ParameterSize,
                UndecryptedTailSize,
                PE_OET_SESSION_START,
                &SMTP_CONNOUT::DoEHLOCommand,
                &SMTP_CONNOUT::DoEHLOResponse,
                m_HeloSent?"helo":"ehlo",
                &fDoneEvent,
                &fAbortEvent);

    if (fDoneEvent && !fAbortEvent)
    {
        if (m_TlsState == MUST_DO_TLS)
        {
            SetNextState(&SMTP_CONNOUT::DoSTARTTLSCommand);
            fResult = DoSTARTTLSCommand(InputLine, ParameterSize, UndecryptedTailSize);
        }
        else if (m_MsgOptions & KNOWN_AUTH_FLAGS)
        {
            fResult = DoSASLCommand(InputLine, ParameterSize, UndecryptedTailSize);
        }
        else if (m_MsgOptions & EMPTY_CONNECTION_OPTION)
        {
            fResult = DoSessionEndEvent(InputLine, ParameterSize, UndecryptedTailSize);
        }
        else
        {
            fResult = DoMessageStartEvent(InputLine, ParameterSize, UndecryptedTailSize);
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(fResult);
}

BOOL SMTP_CONNOUT::DoMessageStartEvent(
            char    *InputLine,
            DWORD   ParameterSize,
            DWORD   UndecryptedTailSize
            )
{
    BOOL    fResult = TRUE;
    BOOL    fDoneEvent = FALSE;
    BOOL    fAbortEvent = FALSE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNOUT::DoMessageStartEvent");

    //send an ETRN request if it defined
    // The ETRN respond will eventually come back to this state
    // again but with the ETRN_SENT option set so it's like a small loop
    if((m_MsgOptions & DOMAIN_INFO_SEND_ETRN) && IsOptionSet(ETRN_OPTION)
        && !IsOptionSet(ETRN_SENT))
    {
        return DoETRNCommand();
    }

    // check to see if this is an empty turn command
    // we need to go back to startsession to issue the TURN
//    if ((m_pIMsg == NULL) && (m_MsgOptions & DOMAIN_INFO_SEND_TURN)) {
    if (m_Flags & TURN_ONLY_OPTION) {
        _ASSERT((m_pIMsg == NULL) && (m_MsgOptions & DOMAIN_INFO_SEND_TURN));
        return StartSession();
    }

    // Always set the state to itself
    SetNextState (&SMTP_CONNOUT::DoMessageStartEvent);

    // Call the catch-all handler
    fResult = GlueDispatch(
                InputLine,
                ParameterSize,
                UndecryptedTailSize,
                PE_OET_MESSAGE_START,
                &SMTP_CONNOUT::DoMAILCommand,
                &SMTP_CONNOUT::DoMAILResponse,
                "mail",
                &fDoneEvent,
                &fAbortEvent);

    if (fDoneEvent && !fAbortEvent)
    {
        // Change to the next state if done ...
        //m_NextAddress = 0;
        fResult = DoPerRecipientEvent(InputLine, ParameterSize, UndecryptedTailSize);
    }

    return(fResult);
}

BOOL SMTP_CONNOUT::DoPerRecipientEvent(
            char    *InputLine,
            DWORD   ParameterSize,
            DWORD   UndecryptedTailSize
            )
{
    BOOL    fResult = TRUE;
    BOOL    fDoneEvent = FALSE;
    BOOL    fAbortEvent = FALSE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNOUT::DoPerRecipientEvent");

    // Always set the state to itself
    SetNextState (&SMTP_CONNOUT::DoPerRecipientEvent);

    DebugTrace((LPARAM)this,
                "Processing recipient index %u",
                m_NextAddress);

    // Call the catch-all handler
    fResult = GlueDispatch(
                InputLine,
                ParameterSize,
                UndecryptedTailSize,
                PE_OET_PER_RECIPIENT,
                &SMTP_CONNOUT::DoRCPTCommand,
                &SMTP_CONNOUT::DoRCPTResponse,
                "rcpt",
                &fDoneEvent,
                &fAbortEvent);

    if (fDoneEvent && !fAbortEvent)
    {
        // Change to the next state if done ...
        if(m_NumFailedAddrs >= m_NumRcptSentSaved)
        {
            TraceFunctLeaveEx((LPARAM)this);
            SetNextState (&SMTP_CONNOUT::WaitForRSETResponse);
            if(m_NumRcptSentSaved)
                m_RsetReasonCode = ALL_RCPTS_FAILED;
            else
                m_RsetReasonCode = NO_RCPTS_SENT;
            return DoRSETCommand(NULL, 0, 0);
        }

        // OK, fire the "before data" event
        fResult = DoBeforeDataEvent(InputLine, ParameterSize, UndecryptedTailSize);
    }

    return(fResult);
}

BOOL SMTP_CONNOUT::DoBeforeDataEvent(
            char    *InputLine,
            DWORD   ParameterSize,
            DWORD   UndecryptedTailSize
            )
{
    BOOL    fResult = TRUE;
    BOOL    fDoneEvent = FALSE;
    BOOL    fAbortEvent = FALSE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNOUT::DoBeforeDataEvent");

    // Always set the state to itself
    SetNextState (&SMTP_CONNOUT::DoBeforeDataEvent);

    // Call the catch-all handler
    fResult = GlueDispatch(
                InputLine,
                ParameterSize,
                UndecryptedTailSize,
                PE_OET_BEFORE_DATA,
                NULL,
                NULL,
                "",
                &fDoneEvent,
                &fAbortEvent);

    if (fDoneEvent && !fAbortEvent)
    {
        // Change to the next state if done ...
        if (m_fUseBDAT)
            fResult = DoBDATCommand(InputLine, ParameterSize, UndecryptedTailSize);
        else
            fResult = DoDATACommand(InputLine, ParameterSize, UndecryptedTailSize);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(fResult);
}

BOOL SMTP_CONNOUT::DoSessionEndEvent(
            char    *InputLine,
            DWORD   ParameterSize,
            DWORD   UndecryptedTailSize
            )
{
    BOOL    fResult = TRUE;
    BOOL    fDoneEvent = FALSE;
    BOOL    fAbortEvent = FALSE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNOUT::DoSessionEndEvent");

    // Always set the state to itself
    SetNextState (&SMTP_CONNOUT::DoSessionEndEvent);

    // Call the catch-all handler
    fResult = GlueDispatch(
                InputLine,
                ParameterSize,
                UndecryptedTailSize,
                PE_OET_SESSION_END,
                &SMTP_CONNOUT::DoQUITCommand,
                &SMTP_CONNOUT::WaitForQuitResponse,
                "quit",
                &fDoneEvent,
                &fAbortEvent);

    // Either way we cut it, if we are done, we will delete the connection
    if (fDoneEvent)
        fResult = FALSE;

    TraceFunctLeaveEx((LPARAM)this);
    return(fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ismtpsvr.rc
//
#define IDS_PROJNAME                    100
#define IDR_SMTPSERVER                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\pe_supp.cxx ===
/*++

   Copyright (c) 1998    Microsoft Corporation

   Module  Name :

        pe_supp.cxx

   Abstract:

        This module provides the implementation for the protocol
		event context

   Author:

           Keith Lau    (KeithLau)    7/07/98

   Project:

           SMTP Server DLL

   Revision History:

			KeithLau			Created

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"

//
// ATL includes
//
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL

//
// SEO includes
//
#include "seo.h"
#include "seolib.h"

#include <memory.h>
#include "smtpcli.hxx"
#include "smtpout.hxx"

//
// Dispatcher implementation 
//
#include "pe_dispi.hxx"


HRESULT STDMETHODCALLTYPE CInboundContext::NotifyAsyncCompletion(
			HRESULT	hrResult
			)
{
    TraceFunctEnterEx((LPARAM)this, "CInboundContext::NotifyAsyncCompletion");

	HRESULT hrRes = S_OK;
	SMTP_CONNECTION	*pParent = NULL;

	// We can obtain the SMTP_CONNECTION object from this
	pParent = CONTAINING_RECORD(this, SMTP_CONNECTION, m_CInboundContext);

	// Call the notify method on the parent class
	hrRes = pParent->OnNotifyAsyncCompletion(
				hrResult
				);

    DebugTrace((LPARAM)this, "returning hr %08lx", hrRes);

    TraceFunctLeaveEx((LPARAM)this);

	return(hrRes);
}

HRESULT STDMETHODCALLTYPE COutboundContext::NotifyAsyncCompletion(
			HRESULT	hrResult
			)
{
	return(E_NOTIMPL);
}

HRESULT STDMETHODCALLTYPE CResponseContext::NotifyAsyncCompletion(
			HRESULT	hrResult
			)
{
	return(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\registry.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       registry.cxx
//
//  Contents:   implementations for CRegKey member Members
//
//  Members:    CRegKey::CRegKey - constructor for registry key object
//              CRegKey::CRegKey - constructor for registry key object
//              CRegKey::CreateKey - real worker for constructors
//              CRegKey::~CRegKey - destructor for registry key object
//              CRegKey::Delete - delete a registry key
//              CRegKey::EnumValues - enumerate values of a registry key
//              CRegKey::EnumKeys - enumerate subkeys of a registry key
//              CRegKey::NotifyChange - setup change notification for a key
//
//              CRegValue::GetValue - sets a registry value
//              CRegValue::SetValue - retrieves a registry value
//              CRegValue::Delete - deletes a registry value
//              CRegValue::GetTypeCode - returns the type code of the value
//
//              CRegMSZ::SetStrings - sets a multi-string registry value
//              CRegMSZ::GetStrings - retrieves a multi-string registry value
//
//  History:    09/30/92    Rickhi  Created
//
//              09/22/93    AlokS   Took out exception throwing code
//                                  and added proper return code for
//                                  each method.
//
//              07/26/94    AlokS   Made it real light weight for simple
//                                  registry set/get operations
//
//              12/09/07    Milans  Ported it over to Exchange
//
//  Notes:      see notes in registry.h
//
//----------------------------------------------------------------------------

#include    "smtpinc.h"
#include    "registry.h"

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using HKEY for parent
//
//  Arguments:  [hkParent] - handle to parent key
//              [pszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//              [fThrowExceptionOnError] - Constructor throw exception on error
//
//  Signals:    Internal error state is set if construction fails.
//
//  Returns:    -none-
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All except the hkParent and pszPath are optional parameters.
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        HKEY hkParent,
        LPCSTR pszPath,
        REGSAM samDesiredAccess,
        LPCSTR pszClass,
        DWORD dwOptions,
        DWORD *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
    :_hkParent(hkParent),
     _hkThis(NULL),
     _dwErr (ERROR_SUCCESS)
{
    _dwErr = CreateKey( _hkParent,
                     pszPath,
                     samDesiredAccess,
                     pszClass,
                     dwOptions,
                     pdwDisposition,
                     pSecurityAttributes );
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using CRegKey for parent
//
//  Arguments:  [prkParent] - ptr to Parent CRegKey
//              [pszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//              [fThrowExceptionOnError] - Constructor throw exception on error
//
//  Signals:    Internal Error state is set if error occures during construction.
//
//  Returns:    nothing
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All except the prkParent and pszPath are optional parameters.
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        const CRegKey &crkParent,
        LPCSTR pszPath,
        REGSAM samDesiredAccess,
        LPCSTR pszClass,
        DWORD dwOptions,
        DWORD *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
    :_hkParent(crkParent.GetHandle()),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
    _dwErr = CreateKey ( _hkParent,
                      pszPath,
                      samDesiredAccess,
                      pszClass,
                      dwOptions,
                      pdwDisposition,
                      pSecurityAttributes );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using HKEY for parent
//                              Merely opens the key, if exist
//
//  Arguments:  [hkParent] - HKEY to Parent
//                              [dwErr]      - Error code returned here
//                      [pszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    Internal Error state is set if error occures during construction
//
//  Returns:    nothing
//
//  History:    09/22/93    AlokS  Created
//
//  Notes:      Check error status to determine if constructor succeeded
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        HKEY hkParent,
        DWORD *pdwErr,
        LPCSTR pszPath,
        REGSAM samDesiredAccess )
    :_hkParent(hkParent),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
     *pdwErr = _dwErr = OpenKey  ( _hkParent, pszPath, samDesiredAccess );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using CRegKey for parent
//                              Merely opens the key, if exist
//
//  Arguments:  [prkParent] - ptr to Parent CRegKey
//              [dwErr]           -  Error code returned here.
//                      [pszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    Internal Error state is set if error occures during construction
//
//  Returns:    nothing
//
//  History:    09/22/93    AlokS  Created
//
//  Notes:      Check error status to determine if constructor succeeded
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        const CRegKey  &crkParent,
        DWORD *pdwErr,
        LPCSTR pszPath,
        REGSAM   samDesiredAccess )
    :_hkParent(crkParent.GetHandle()),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
     *pdwErr = _dwErr = OpenKey ( _hkParent, pszPath, samDesiredAccess );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::~CRegKey, public
//
//  Synopsis:   Destructor for registry key object
//
//  Arguments:  none
//
//  Signals:    nothing
//
//  Returns:    nothing
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

CRegKey::~CRegKey()
{
    if (_hkThis != NULL)
        RegCloseKey(_hkThis);
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CreateKey, private
//
//  Synopsis:   This method does the real work of the constructors.
//
//  Arguments:  [hkParent] - handle to parent key
//              [pszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All parameters are required.
//
//--------------------------------------------------------------------------

DWORD CRegKey::CreateKey (
        HKEY hkParent,
        LPCSTR  pszPath,
        REGSAM  samDesiredAccess,
        LPCSTR  pszClass,
        DWORD   dwOptions,
        DWORD   *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
{
    DWORD   dwDisposition;
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;
    LPSECURITY_ATTRIBUTES lpsec = pSecurityAttributes;

    //  create/open the key
    if ((dwRc = RegCreateKeyEx(hkParent,
                           (LPSTR) pszPath,    //  path to key
                           0,                  //  title index
                           (LPSTR) pszClass,   //  class of key
                           dwOptions,          //  key options
                           samDesiredAccess,   //  desired access
                           lpsec,              //  if created
                           &_hkThis,           //  handle
                           &dwDisposition)     //  opened/created
                          )==ERROR_SUCCESS)
    {
        //  save away the name
        _cszName.Set((PCHAR) pszPath);

        //  setup the return parameters
        if (pdwDisposition != NULL)
            *pdwDisposition = dwDisposition;

    }
    else
        dwErr = Creg_ERROR(dwRc);

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::OpenKey, private
//
//  Synopsis:   This method does the real work of the constructors.
//
//  Arguments:  [hkParent] - handle to parent key
//                      [pszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/22/93        AlokS  Created
//
//  Notes:      All parameters are required.
//
//--------------------------------------------------------------------------

DWORD CRegKey::OpenKey (
        HKEY    hkParent,
        LPCSTR  pszPath,
        REGSAM  samDesiredAccess )
{
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;

    //  open the key
    if ((dwRc = RegOpenKeyEx(hkParent,
                         pszPath,           //  path to key
                         0,                  //  reserved
                         samDesiredAccess,   //  desired access
                         &_hkThis            //  handle
                        ))==ERROR_SUCCESS)
    {
        //  save away the name
        _cszName.Set((PCHAR) pszPath);

    }
    else
        dwErr = Creg_ERROR(dwRc);

    return(dwErr);
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::Delete, public
//
//  Synopsis:   Deletes an existing key from the registry.  Note that
//              the key object still exists, the destructor must be
//              called seperately.
//
//  Arguments:  none
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CRegKey::Delete(void)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD   dwRc;
    SRegKeySet *pChildren;

    dwErr = this->EnumKeys(&pChildren);

    if (dwErr == ERROR_SUCCESS) {

        ULONG i;
        DWORD dwErrDelete = ERROR_SUCCESS;

        for(i = 0; i < pChildren->cKeys; i++) {

            dwErr = pChildren->aprkKey[i]->Delete();

            if (dwErr != ERROR_SUCCESS) {

                dwErrDelete = dwErr;

            }

            delete pChildren->aprkKey[i];

        }

        if (dwErrDelete == ERROR_SUCCESS) {

            if (( dwRc= RegDeleteKey(_hkThis, NULL))!=ERROR_SUCCESS) {

                dwErr = Creg_ERROR(dwRc);

            }

        } else {

            dwErr = dwErrDelete;

        }

        delete pChildren;

    }

    return(dwErr);
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::EnumValues, public
//
//  Synopsis:   Enumerates the values stored in an open registry key.
//
//  Arguments:  [pprvs] - SRegValueSet allocated and returned by this
//                                    method.  The caller is responsible for releasing
//                                    the allocated CRegValue objects via delete and the
//                                    SRegValueSet structure via CRegKey::MemFree.
//
//  Signals:  none
//
//  Returns:  ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      The data associated with each Value is not returned. The
//              caller may invoke the GetValue method of each CRegValue
//              returned to get it's associated data.
//
//--------------------------------------------------------------------------

DWORD CRegKey::EnumValues(SRegValueSet **pprvs)
{
    DWORD dwErr = ERROR_SUCCESS;

    //  figure out how many values are currently stored in this key
    //  and allocate a buffer to hold the return results.

    CHAR    szClass[MAX_PATH];
    ULONG   cbClass = sizeof(szClass);
    ULONG   cSubKeys, cbMaxSubKeyLen, cbMaxClassLen;
    ULONG   cValues, cbMaxValueIDLen, cbMaxValueLen;
    SECURITY_DESCRIPTOR SecDescriptor;
    FILETIME ft;

    DWORD dwRc = RegQueryInfoKey(_hkThis,
                               szClass,
                               &cbClass,
                               NULL,
                               &cSubKeys,
                               &cbMaxSubKeyLen,
                               &cbMaxClassLen,
                               &cValues,
                               &cbMaxValueIDLen,
                               &cbMaxValueLen,
                               (DWORD *)&SecDescriptor,
                               &ft );

    if ( dwRc == ERROR_SUCCESS )
    {
        *pprvs = (SRegValueSet *) new BYTE [ sizeof(SRegValueSet)+
                                             cValues*sizeof(CRegValue *) ];
        if ( *pprvs == NULL )
        {
            dwErr = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        //   QueryInfo failed.
        dwErr = Creg_ERROR(dwRc);
    }
    if (dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    //  loop enumerating and creating a RegValue object for each value
    DWORD   dwIndex=0;

    do
    {
        CHAR   szValueID[MAX_PATH];
        ULONG   cbValueID = sizeof(szValueID);
        DWORD   dwTypeCode;
        CRegValue *pRegVal;

        if ((dwRc = RegEnumValue(_hkThis,         //  handle
                        dwIndex,        //  index
                        szValueID,     //  value id
                        &cbValueID,     //  length of value name
                        NULL,           //  title index
                        &dwTypeCode,    //  data type
                        NULL,           //  data buffer
                        NULL            //  size of data buffer
                      ))==ERROR_SUCCESS)
        {
            //  create the appropriate class of value object
            switch (dwTypeCode)
            {
            case REG_SZ:
                pRegVal = (CRegValue *) new CRegSZ((const CRegKey &)*this, szValueID);
                break;

            case REG_DWORD:
                pRegVal = (CRegValue *) new CRegDWORD((const CRegKey &)*this, szValueID);
                break;

            case REG_BINARY:
                pRegVal = (CRegValue *) new CRegBINARY((const CRegKey &)*this, szValueID);
                break;

            default:
                pRegVal = (CRegValue *) new CRegBINARY((const CRegKey &)*this, szValueID);
                break;
            }

            //  save ptr to value object and count another entry
            (*pprvs)->aprvValue[dwIndex++] = pRegVal;
        }
        else
        {
            //  error, we're done with the enumeration
            break;
        }

    } while (dwIndex < cValues);


    //  finished the enumeration, check the results
    if (dwRc == ERROR_NO_MORE_ITEMS || dwRc == ERROR_SUCCESS)
    {
        //  set the return count
        (*pprvs)->cValues = dwIndex;
    }
    else
    {
        //  Cleanup and return an error
        while (dwIndex)
        {
            delete (*pprvs)->aprvValue[--dwIndex];
        }

        delete [] *pprvs;

        dwErr = Creg_ERROR(dwRc);
    }

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::EnumKeys, public
//
//  Synopsis:   Enumerates the subkeys of an open registry key.
//
//  Arguments:  [pprks] - SRegKeySet allocated and returned by this method.
//                        The caller is responsible for releasing all the
//                        allocated CRegKey objects and the SRegKeySet
//                        structure.
//
//  Signals:    none
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CRegKey::EnumKeys(SRegKeySet **pprks)
{
    //  figure out how many keys are currently stored in this key
    //  and allocate a buffer to hold the return results.

    CHAR   szClass[MAX_PATH];
    ULONG   cbClass = sizeof(szClass);
    ULONG   cSubKeys, cbMaxSubKeyLen, cbMaxClassLen;
    ULONG   cValues, cbMaxValueIDLen, cbMaxValueLen;
    SECURITY_DESCRIPTOR SecDescriptor;
    FILETIME ft;
    DWORD  dwErr = ERROR_SUCCESS;

    DWORD dwRc = RegQueryInfoKey(_hkThis,
                     szClass,
                     &cbClass,
                     NULL,
                     &cSubKeys,
                     &cbMaxSubKeyLen,
                     &cbMaxClassLen,
                     &cValues,
                     &cbMaxValueIDLen,
                     &cbMaxValueLen,
                     (DWORD *)&SecDescriptor,
                     &ft);

    if ( dwRc == ERROR_SUCCESS )
    {
        *pprks = (SRegKeySet*) new BYTE [sizeof(SRegKeySet)+cSubKeys*sizeof(CRegKey *)];
        if ( *pprks == NULL )
        {
            dwErr = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        //  QueryInfo failed..
        dwErr = Creg_ERROR(dwRc);
    }

    if (dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }
    //  loop enumerating and creating a RegKey object for each subkey
    DWORD   dwIndex=0;

    do
    {
        CHAR   szKeyName[MAX_PATH];
        ULONG   cbKeyName = sizeof(szKeyName);
        CHAR   szClass[MAX_PATH];
        ULONG   cbClass = sizeof(szClass);
        FILETIME ft;

        if ((dwRc = RegEnumKeyEx(_hkThis,         //  handle
                                dwIndex,        //  index
                                szKeyName,     //  key name
                                &cbKeyName,     //  length of key name
                                NULL,           //  title index
                                szClass,       //  class
                                &cbClass,       //  length of class
                                &ft             //  last write time
                              ))==ERROR_SUCCESS)
        {
            //  Create a CRegKey object for the subkey
            CRegKey *pRegKey = (CRegKey *) new CRegKey((const CRegKey &)*this, szKeyName);
            if (ERROR_SUCCESS != (dwErr = pRegKey->QueryErrorStatus()))
            {
                break;
            }
            (*pprks)->aprkKey[dwIndex++] = pRegKey;
        }
        else
        {
            //  error, we're done with the enumeration
            break;
        }

    } while (dwIndex < cSubKeys);


    //  finished the enumeration, check the results
    if ((dwErr == ERROR_SUCCESS) &&
        ((dwRc == ERROR_NO_MORE_ITEMS || dwRc == ERROR_SUCCESS)))
    {
        //  set the return count
        (*pprks)->cKeys = dwIndex;
    }
    else
    {
        //  Cleanup and return an error
        while (dwIndex)
        {
            delete (*pprks)->aprkKey[--dwIndex];
        }

        delete [] *pprks;

        dwErr = Creg_ERROR(dwRc);
    }

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegValue::GetValue, public
//
//  Purpose:    Returns the data associated with a registry value.
//
//  Arguements: [pbData] - ptr to buffer supplied by caller.
//              [cbData] - size of data buffer supplied.
//              [pdwTypeCode] - type of data returned.
//
//  Signals:
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//
//
//--------------------------------------------------------------------------

DWORD CRegValue::GetValue(LPBYTE pbData, ULONG* pcbData, DWORD *pdwTypeCode)
{
    DWORD dwRc = RegQueryValueEx(GetParentHandle(),
                                    (LPSTR)_cszValueID,    //  value id
                                    NULL,        //  title index
                                    pdwTypeCode, //  type of data returned
                                    pbData,       //  data
                                    pcbData);       // size of data
    return(dwRc);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegValue::SetValue
//
//  Purpose:    Writes the data associated with a registry value.
//
//  Arguements: [pbData] - ptr to data to write.
//                      [cbData] - size of data to write.
//                      [dwTypeCode] - type of data to write.
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CRegValue::SetValue(const LPBYTE pbData, ULONG cbData, DWORD dwTypeCode)
{
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;
    if ((dwRc = RegSetValueEx(GetParentHandle(),        //  key handle
                             (LPSTR)_cszValueID,  //  value id
                              NULL,      //  title index
                              dwTypeCode,    //  type of info in buffer
                              pbData,        //  data
                              cbData)        //  size of data
                             )!= ERROR_SUCCESS)
    {
        dwErr = Creg_ERROR(dwRc);
    }
    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   DelRegKeyTree
//
//  Purpose:    Deletes a key and any of it's children. This is like
//              delnode for registry
//
//  Arguements: [hParent]      - Handle to Parent Key
//              [lpszKeyPath] - Path (relative to Parent) of the key
//
//  Signals:
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/93    AlokS  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD DelRegKeyTree ( HKEY hParent, LPSTR lpszKeyPath)
{
    DWORD dwErr = ERROR_SUCCESS;
    CRegKey cregKey ( hParent,
                      lpszKeyPath
                    );
    if (ERROR_SUCCESS != (dwErr = cregKey.QueryErrorStatus()))
    {
        return(dwErr);
    }

    // Enumerate the children of the key. We will
    // not propogate to the caller errors from enumeration
    SRegKeySet *pRegKeySet = NULL;
    if (ERROR_SUCCESS == (dwErr = cregKey.EnumKeys ( & pRegKeySet)))
    {
        // Now we have set of Keys which need to be deleted in depth
        // first manner
        for (ULONG i = 0; i < pRegKeySet->cKeys; i++ )
        {
            dwErr = DelRegKeyTree ( cregKey.GetHandle(),
                                    (LPSTR) pRegKeySet->aprkKey[i]->GetName()
                               );

            // Delete the key itself
            delete pRegKeySet->aprkKey[i];
        }

        // Delete the enumerator structure
        delete pRegKeySet;
    }

    // Finally delete this key
    dwErr = cregKey.Delete();

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\rpcex.cxx ===
/*++
   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        rpcex.cxx

   Abstract:

        This module defines K2 rpc support.

   Author:

        Johnson Apacible    (JohnsonA)      June-19-1996

--*/


#define INCL_INETSRV_INCS
#include "smtpinc.h"

#if 0
#include <timer.h>
#include <time.h>
#endif

#include "iiscnfg.h"
#include <mdmsg.h>
#include <commsg.h>
#include <imd.h>
#include <mb.hxx>


BOOL
IsSmtpEncryptionPermitted(
                VOID
                )
/*++

Routine Description:

    This routine checks whether encryption is getting the system default
    LCID and checking whether the country code is CTRY_FRANCE.

Arguments:

    none


Return Value:

    TRUE - encryption is permitted
    FALSE - encryption is not permitted


--*/

{
    LCID DefaultLcid;
    WCHAR CountryCode[10];
    ULONG CountryValue;

    DefaultLcid = GetSystemDefaultLCID();

    //
    // Check if the default language is Standard French
    //

    if (LANGIDFROMLCID(DefaultLcid) == 0x40c) {
        return(FALSE);
    }

    //
    // Check if the users's country is set to FRANCE
    //

    if (GetLocaleInfoW(DefaultLcid,LOCALE_ICOUNTRY,CountryCode,10) == 0) {
        return(FALSE);
    }

    CountryValue = (ULONG) wcstol(CountryCode,NULL,10);
    if (CountryValue == CTRY_FRANCE) {
        return(FALSE);
    }
    return(TRUE);

} // IsEncryptionPermitted



DWORD
SMTP_SERVER_INSTANCE::QueryEncCaps(
    VOID
    )
/*++

   Description

       Returns encryption capability

   Arguments:

       None

   Return:

       Encryption capability

--*/
{
    //
    //  Get the encryption capability bits.  SecurePort may be zero because
    //  no keys are installed or the locale does not allow encryption
    //

	return 0;
} // SMTP_SERVER_INSTANCE::QueryEncCaps



BOOL
SMTP_SERVER_INSTANCE::SetServiceConfig(
    IN PCHAR pBuffer
    )
/*++

   Description

       Sets the common service admin information for the servers specified
       in dwServerMask.

   Arguments:

       pConfig - Admin information to set

   Note:

--*/
{
    return TRUE;

} // SMTP_SERVER_INSTANCE::SetServiceConfig




BOOL
SMTP_SERVER_INSTANCE::GetServiceConfig(
    IN  PCHAR   pBuffer,
    IN  DWORD   dwLevel
    )
/*++

   Description

       Retrieves the admin information

   Arguments:

       pBuffer - Buffer to fill up.
       dwLevel - info level of information to return.

   Note:

--*/
{
    LPSMTP_CONFIG_INFO  pConfig = (LPSMTP_CONFIG_INFO)pBuffer;
    DWORD               err = NO_ERROR;
    MB                  MetaInfo( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    ZeroMemory( pConfig, sizeof( SMTP_CONFIG_INFO ) );

    // We want to open a read handle to the server instance
    // name, and then we'll read the indivdual info out next.
    //

    if ( !MetaInfo.Open( QueryMDVRPath() ))
    {
        return FALSE;
    }

    LockThisForRead();

    //
    //  Get always retrieves all of the parameters
    //

    pConfig->FieldControl = FC_SMTP_INFO_ALL;


    //
    //  Set the encryption capability bits.  SecurePort may be zero
    //  because no keys are installed or the locale does not allow
    //  encryption
    //



    UnlockThis();

    SetLastError(err);
    return(err==NO_ERROR);

} // W3_SERVER_INSTANCE::GetServiceConfig




BOOL
SMTP_SERVER_INSTANCE::EnumerateUsers(
    OUT PCHAR * pBuffer,
    OUT PDWORD  nRead
    )
/*++

   Description

       Enumerates the connected users.

   Arguments:

       pBuffer - Buffer to fill up.

--*/
{
    BOOL fRet = TRUE;

#if 0
    //
    //  Lock the user database.
    //

    LockUserDatabase();

    //
    //  Determine the necessary buffer size.
    //

    pBuffer->EntriesRead = 0;
    pBuffer->Buffer      = NULL;

    cbBuffer  = 0;
    err       = NERR_Success;

    EnumerateUsers( pBuffer, &cbBuffer );

    if( cbBuffer > 0 )
    {
        //
        //  Allocate the buffer.  Note that we *must*
        //  use midl_user_allocate/midl_user_free.
        //

        pBuffer->Buffer = (W3_USER_INFO *) MIDL_user_allocate( (unsigned int)cbBuffer );

        if( pBuffer->Buffer == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            //  Since we've got the user database locked, there
            //  *should* be enough room in the buffer for the
            //  user data.  If there isn't, we've messed up
            //  somewhere.
            //

            TCP_REQUIRE( ::EnumerateUsers( pBuffer, &cbBuffer ) );
        }
    }

    //
    //  Unlock the user database before returning.

    UnlockUserDatabase();

#endif //0

    return fRet;

} // EnumerateUsers


BOOL
SMTP_SERVER_INSTANCE::DisconnectUser(
                        IN DWORD dwIdUser
                        )
/*++

   Description

       Disconnect the user

   Arguments:

       dwIdUser - Identifies the user to disconnect.  If 0,
           then disconnect ALL users.

--*/
{
    BOOL fRet = TRUE;

    //
    //  Do it.
    //

    if( dwIdUser == 0 )
    {
        DisconnectAllConnections();
    }
    else
    {
#if 0
        if( !CLIENT_CONN::DisconnectUser( idUser ) )
        {
            err = NERR_UserNotFound;
        }
#endif
    }

    return fRet;

} // DisconnectUser


BOOL
SMTP_SERVER_INSTANCE::GetStatistics(
                        IN DWORD dwLevel,
                        OUT PCHAR* pBuffer
                        )
/*++

   Description

       Disconnect Queries the server statistics

   Arguments:

       dwLevel - Info level.  Currently only level 0 is
           supported.

       pBuffer - Will receive a pointer to the statistics
           structure.

--*/
{
    APIERR err = NO_ERROR;

    //
    //  Return the proper statistics based on the infolevel.
    //

    switch( dwLevel )
    {
    case 0 :
        {
            LPSMTP_STATISTICS_0 pstats1;

            pstats1 = (SMTP_STATISTICS_0 *) MIDL_user_allocate( sizeof(SMTP_STATISTICS_0) );

            if( pstats1 == NULL )
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                QueryStatsObj()->CopyToStatsBuffer( pstats1 );

                //pstats1->TimeOfLastClear = GetCurrentTimeInSeconds() -
                  //                         pstats1->TimeOfLastClear;

                //
                //  Copy Global statistics counter values
                //
                //pstats1->CurrentConnections =
                   // g_pSmtpStats->QueryStatsObj()->m_cCurrentConnections;
                //pstats1->MaxConnections =
                   // g_pSmtpStats->QueryStatsObj()->m_cMaxCurrentConnections;
                //pstats1->ConnectionAttempts =
                   // g_pSmtpStats->QueryStatsObj()->ConnectionAttempts;

                *pBuffer = (PCHAR)pstats1;
            }
        }
        break;

    default :
        err = ERROR_INVALID_LEVEL;
        break;
    }

    SetLastError(err);
    return(err == NO_ERROR);

} // QueryStatistics



BOOL
SMTP_SERVER_INSTANCE::ClearStatistics(
                        VOID
                        )
/*++

   Description

       Clears the server statistics

   Arguments:

        None.

--*/
{

    QueryStatsObj()->ClearStatistics();

    return TRUE;

} // ClearStatistics
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\remoteq.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        remoteq.cxx

   Abstract:
        Implements a derivation of the generic queue
        for internet mail delivery

   Author:

           Rohan Phillips    ( Rohanp )    24-JAN-1995

   Project:

          SMTP Server DLL

   Functions Exported:


   Revision History:


--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "dropdir.hxx"
#include "remoteq.hxx"
#include "smtpout.hxx"
#include <cdns.h>
#include "smtpdns.hxx"
#define INVALID_RCPT_IDX_VALUE 0xFFFFFFFF
extern char * MyStrChr(char *Line, unsigned char Val, DWORD LineSize);
extern void DeleteDnsRec(PSMTPDNS_RECS pDnsRec);
extern CTcpRegIpList g_TcpRegIpList;

///////////////////////////////////////////////////////////////////////////
#if 0
REMOTE_QUEUE::REMOTE_QUEUE(SMTP_SERVER_INSTANCE * pSmtpInst) 
    : PERSIST_QUEUE(pSmtpInst)
{
}
#endif

///////////////////////////////////////////////////////////////////////////
DWORD   g_dwFileCounter = 0;

#define MIN(a,b) ( (a) > (b) ? (b) : (a) )

///////////////////////////////////////////////////////////////////////////

/*++

    Name :
        REMOTE_QUEUE::ProcessQueueEvents

    Description:

        This function takes a pointer to a QUEUE_ENTRY,
        which contains all the information needed to
        deliver local mail, and delivers the mail to the
        remote site.

    Arguments:

        a pointer to a QUEUE_ENTRY class

    Returns:


--*/
BOOL REMOTE_QUEUE::ProcessQueueEvents(ISMTPConnection    *pISMTPConnection)
{
    DWORD Error = 0;
    char * FileName = NULL;
    DWORD IpAddress = 0;
    DWORD TransmitOptions = 0;
    HRESULT hr = S_OK;
    BOOL AsyncConnectStarted = FALSE;
    DomainInfo DomainParams;
    char * ConnectedDomain = NULL;

    TraceFunctEnterEx((LPARAM) this, "REMOTE_QUEUE::ProcessQueueEvents(PQUEUE_ENTRY pEntry)");

    _ASSERT(pISMTPConnection != NULL);

    ZeroMemory (&DomainParams, sizeof(DomainParams));

    if(pISMTPConnection == NULL)
    {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    //leave quickly if we are shutting down
    if(GetParentInst()->IsShuttingDown()
        || (GetParentInst()->QueryServerState( ) == MD_SERVER_STATE_STOPPED)
        || (GetParentInst()->QueryServerState( ) == MD_SERVER_STATE_INVALID))
    {
        HandleFailedConnection(pISMTPConnection);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    ZeroMemory(&DomainParams, sizeof(DomainParams));
    DomainParams.cbVersion = sizeof(DomainParams);
    hr = pISMTPConnection->GetDomainInfo(&DomainParams);
    if(!FAILED(hr))
    {
        if(DomainParams.dwDomainInfoFlags & DOMAIN_INFO_LOCAL_DROP)
        {
            AsyncCopyMailToDropDir(pISMTPConnection, DomainParams.szDropDirectory, GetParentInst());
            pISMTPConnection->Release();
            TraceFunctLeaveEx((LPARAM)this);
            return TRUE;
        }

        ConnectedDomain = DomainParams.szDomainName;

        if(DomainParams.szSmartHostDomainName != NULL)
        {
            ConnectedDomain = DomainParams.szSmartHostDomainName;
        }

        AsyncConnectStarted = StartAsyncConnect( (const char *)ConnectedDomain,
                                                 pISMTPConnection, 
                                                 DomainParams.dwDomainInfoFlags,
                                                 GetParentInst()->UseSmartHostAfterFail());
        if(AsyncConnectStarted)
        {
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
        }
    }

    HandleFailedConnection(pISMTPConnection);
    TraceFunctLeaveEx((LPARAM) this);
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
/*++

    Name :
        void HandleFailedConnection (PMAIL_ENTRY MailQEntry)

    Description:

        This function takes a pointer to a PMAIL_ENTRY,
        and either places it in the retry queue or the
        bad mail directory.

    Arguments:

        a pointer to a PMAIL_ENTRY class
        dwConnectionStatus... the status passed back to AQ

        
        11/11/98 - MikeSwa Added dwConnectionStatus

--*/
void REMOTE_QUEUE::HandleFailedConnection (ISMTPConnection *pISMTPConnection,
                                           DWORD dwConnectionStatus)
{
    HRESULT hrConnectionFailure = AQUEUE_E_HOST_NOT_RESPONDING;
    if(pISMTPConnection != NULL)
    {
        //We know the connection failed... lets add some additional diagnostic
        //information
        if (CONNECTION_STATUS_FAILED_LOOPBACK == dwConnectionStatus)
            hrConnectionFailure = AQUEUE_E_LOOPBACK_DETECTED;

        pISMTPConnection->SetDiagnosticInfo(hrConnectionFailure, NULL, NULL);
        pISMTPConnection->AckConnection(dwConnectionStatus);
        pISMTPConnection->Release();
    }
}

///////////////////////////////////////////////////////////////////////////
DWORD QueueDeleteFunction(PVOID ThisPtr)
{
    CAsyncMx * ThisQueue = (CAsyncMx *) ThisPtr;

    if(ThisQueue)
    {
        delete ThisQueue;
    }

    return 0;

}

///////////////////////////////////////////////////////////////////////////
//
// QueueCallBackFunction :
//
//Return TRUE - when we want the asyncmx object to be kept around
//Return FALSE - to delete the object when the thread exits
//

BOOL QueueCallBackFunction(PVOID ThisPtr, BOOLEAN fTimedOut)
{
    CAsyncMx * ThisQueue = (CAsyncMx *) ThisPtr;
    REMOTE_QUEUE * pRemoteQ = NULL;
    BOOL fSuccessfullConnect = TRUE;
    BOOL fAtqConnect = TRUE;
    char * NextMxPtr = NULL;
    SMTPDNS_RECS * pDnsRec = NULL;
    char szSmartHost[MAX_PATH + 1];
    char Scratch[256];
    DWORD Error = 0;
    DWORD dwFailedConnectionStatus = CONNECTION_STATUS_FAILED;
    int NumRecords = 0;
    DWORD IpAddress = 0;

    TraceFunctEnterEx((LPARAM) ThisQueue, "QueueCallBackFunction");

    Scratch[0] = '\0';

    if(ThisQueue->GetParentInst()->IsShuttingDown())
    {
        //takes care of the case where we are shutting down, but
        //a successful connection came in at the same time
        ThisQueue->SetCloseSocketFlag(TRUE);
        ThisQueue->CloseAsyncSocket();
        ThisQueue->AckMessage();
        pRemoteQ = (REMOTE_QUEUE *) ThisQueue->GetParentInst()->QueryRemoteQObj();
        _ASSERT(pRemoteQ != NULL);
        pRemoteQ->HandleFailedConnection(ThisQueue->GetSmtpConnectionObj());
        TraceFunctLeaveEx((LPARAM) ThisPtr);
        return FALSE;
    }

    if (!ThisQueue->GetDnsRec())
    {
        //See bug X5:120720 - This means that another thread has called back
        //on this object.  The call to OnConnect below will AV.  We do not 
        //have a repro scenario for this, and see if only once every few
        //months.  MilanS has recommended this non-intrusive check to
        //add additional protection against a double callback
        _ASSERT(0 && "Multiple threads calling back on CAsyncMx");

        //Return TRUE because first thread will handle deleting object
        return TRUE;
    }

    //get a pointer to the remote queue
    pRemoteQ = (REMOTE_QUEUE *) ThisQueue->GetParentInst()->QueryRemoteQObj();
    _ASSERT(pRemoteQ != NULL);

    IpAddress = ThisQueue->GetConnectedIpAddress();
    InetNtoa(*(struct in_addr *) &IpAddress, Scratch);

    //See if the connect was successful
    fSuccessfullConnect = ThisQueue->AsyncConnectSuccessfull();

    //Call record the state of this connection
    ThisQueue->OnConnect(fSuccessfullConnect);

    //Test the connect value
    if(fSuccessfullConnect)
    {
        DebugTrace((LPARAM)ThisQueue, "QueueCallBack called with successful connect!");

        pDnsRec = ThisQueue->GetDnsRec();

        ThisQueue->SetDnsRecToNull();

        fAtqConnect = pRemoteQ->MakeATQConnection( pDnsRec,
                                                   ThisQueue->GetSockethandle(),
                                                   ThisQueue->GetConnectedIpAddress(),
                                                   ThisQueue->GetSmtpConnectionObj(),
                                                   ThisQueue->GetDomainOptions(),
                                                   ThisQueue->GetSSLVerificationName());
        if(!fAtqConnect)
        {
            ErrorTrace((LPARAM)ThisQueue, "FAILED pRemoteQ->MakeATQConnection!!!");

            ThisQueue->AckMessage();
            
            if (ThisQueue->WasLoopback())
                dwFailedConnectionStatus = CONNECTION_STATUS_FAILED_LOOPBACK;
            
            pRemoteQ->HandleFailedConnection(ThisQueue->GetSmtpConnectionObj(),
                                             dwFailedConnectionStatus);
        }


        TraceFunctLeaveEx((LPARAM) ThisPtr);
        return FALSE;

    } else if (ThisQueue->WasLoopback()) {

        dwFailedConnectionStatus = CONNECTION_STATUS_FAILED_LOOPBACK;
        ThisQueue->GetSmtpConnectionObj()->SetDiagnosticInfo(AQUEUE_E_LOOPBACK_DETECTED, NULL, NULL);
    }

    ErrorTrace((LPARAM)ThisPtr,"connection to %s failed", Scratch);

    BUMP_COUNTER (ThisQueue->GetParentInst(), NumConnOutRefused);   

    IpAddress = ThisQueue->GetNextIpAddress();

    //
    //  A connect will cause QueueCallBack to be called again through a 
    //  completion event posted on FD_CONNECT. On each call to ConnectToHost 
    //  we try a new IP address till all the IP addresses for this MX host 
    //  are exhausted.
    //
    if((IpAddress != INADDR_NONE) && ThisQueue->ConnectToHost(IpAddress))
    {
        DebugTrace((LPARAM)ThisQueue, "Connecting to MX host: %08x", IpAddress);
        TraceFunctLeaveEx((LPARAM) ThisPtr);
        return TRUE;
    }

    ThisQueue->CloseAsyncSocket();

    DebugTrace((LPARAM) ThisQueue, "Ran out of IP addresses for MX host");
    //
    //  If we failed to connect to any of the IP addresses for the (current)
    //  MX host, try connecting to the next MX host for this destination.
    //
    while(!ThisQueue->GetParentInst()->IsShuttingDown())
    {
        if(ThisQueue->ConnectToNextMxHost())
        {
            DebugTrace((LPARAM)ThisQueue, "Trying ConnectToNextMxHost");
            TraceFunctLeaveEx((LPARAM) ThisPtr);
            return TRUE;
        }
        else
        {
            Error = GetLastError();
            ThisQueue->CloseAsyncSocket();
            if(Error == ERROR_NO_MORE_ITEMS)
            {
                DebugTrace((LPARAM)ThisQueue, "Failed ConnectToNextMxHost with ERROR_NO_MORE_ITEMS");
                break;
            }
            else
            {
                ErrorTrace((LPARAM)ThisQueue, "Failed ConnectToNextMxHost: Host not responding");
                ThisQueue->GetSmtpConnectionObj()->SetDiagnosticInfo(AQUEUE_E_HOST_NOT_RESPONDING, NULL, NULL);
            }
        }
    }

    ThisQueue->CloseAsyncSocket();
    DebugTrace((LPARAM)ThisQueue, "Ran out of MX hosts for destination. Trying new destination.");

    //
    //  If we failed to connect to any MX host for the destination server
    //  we need to try an alternate destination. ConnectToNextResolverHost
    //  uses the DNS_RESOLVER_RECORD (member of CAsyncMx *ThisQueue) to get
    //  the name of an alternative host and resolve it (get the MX records
    //  for it).
    //
    while(!ThisQueue->GetParentInst()->IsShuttingDown())
    {
        if(pRemoteQ->ConnectToNextResolverHost( ThisQueue ))
        {
            TraceFunctLeaveEx((LPARAM) ThisPtr);
            return TRUE;
        }
        else
        {
            Error = GetLastError();
            ThisQueue->CloseAsyncSocket();
            if(Error == ERROR_NO_MORE_ITEMS)
            {
                DebugTrace((LPARAM)ThisQueue, "Failed ConnectToNextResolverHost : ERROR_NO_MORE_ITEMS");
                break;
            }
            else
            {
                ErrorTrace((LPARAM)ThisQueue, "Failed ConnectToNextResolverHost. Error = %08x", Error);
                ThisQueue->GetSmtpConnectionObj()->SetDiagnosticInfo(AQUEUE_E_DNS_FAILURE, NULL, NULL);
            }
        }
    }

    ThisQueue->CloseAsyncSocket();
        

    

    //So we have tried all we could for the real destination
    //check  if we have a fallback smarthost and that we have not already tried it
    if( pRemoteQ->GetParentInst()->UseSmartHostAfterFail() &&
        pRemoteQ->GetParentInst()->GetSmartHost(szSmartHost) &&
        !ThisQueue->GetTriedOnFailHost())
    {

        if(pRemoteQ->StartAsyncConnect(szSmartHost, ThisQueue->GetSmtpConnectionObj(), ThisQueue->GetDomainOptions(), FALSE))
        {
            TraceFunctLeaveEx((LPARAM) ThisPtr);
            return TRUE;
        }
    }

    ThisQueue->AckMessage();

    pRemoteQ->HandleFailedConnection(ThisQueue->GetSmtpConnectionObj(), dwFailedConnectionStatus);
    
    TraceFunctLeaveEx((LPARAM) ThisPtr);
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
PSMTPDNS_RECS GetDnsRecordsFromHostFile(const char * HostName)
{
    PSMTPDNS_RECS   pDnsRec = NULL;
    MXIPLIST_ENTRY * pEntry = NULL; 
    struct hostent *hp = NULL;
    BOOL    fRet = TRUE;
    DWORD   Error = 0;

    TraceFunctEnterEx((LPARAM) NULL, "GetDnsRecordsFromHostFile");

    DebugTrace((LPARAM)NULL,"Using gethostbyname for hostname resolution - %s", HostName);

    hp = gethostbyname (HostName);
    if(hp == NULL)
    {
        Error = WSAGetLastError();
        ErrorTrace((LPARAM)NULL,"struct hostent *hp is NULL for %s - %x", HostName, Error);
        TraceFunctLeaveEx((LPARAM) NULL);
        return NULL;
    }

    pDnsRec = new SMTPDNS_RECS;
    if(pDnsRec == NULL)
    {
        ErrorTrace((LPARAM)NULL,"pDnsRec = new SMTPDNS_RECS failed for %s", HostName);
        TraceFunctLeaveEx((LPARAM) NULL);
        return NULL;
    }

    ZeroMemory(pDnsRec, sizeof(SMTPDNS_RECS));

    pDnsRec->DnsArray[0] = new MX_NAMES;
    if(pDnsRec->DnsArray[0] == NULL)
    {
        ErrorTrace((LPARAM)NULL,"new MX_NAMES failed for %s", HostName);
        delete pDnsRec;
        TraceFunctLeaveEx((LPARAM) NULL);
        return NULL;
    }

    pDnsRec->NumRecords = 1;
    pDnsRec->DnsArray[0]->NumEntries = 0;

    InitializeListHead(&pDnsRec->DnsArray[0]->IpListHead);
    lstrcpyn(pDnsRec->DnsArray[0]->DnsName, HostName, sizeof(pDnsRec->DnsArray[0]->DnsName));

    for (DWORD Loop = 0; (hp->h_addr_list[Loop] != NULL); Loop++)
    {
        pEntry = new MXIPLIST_ENTRY;
        if(pEntry != NULL)
        {
            pDnsRec->DnsArray[0]->NumEntries++;
            CopyMemory(&pEntry->IpAddress, hp->h_addr_list[Loop], 4);
            InsertTailList(&pDnsRec->DnsArray[0]->IpListHead, &pEntry->ListEntry);
        }
        else
        {
            ErrorTrace((LPARAM)NULL,"new MXIPLIST_ENTRY failed for %s", HostName);
            fRet = FALSE;
            break;
        }
    }

    if(fRet)
    {
        return pDnsRec;
    }
    else
    {
        DeleteDnsRec(pDnsRec);
        pDnsRec = NULL;
    }

    TraceFunctLeaveEx((LPARAM) NULL);
    return pDnsRec;
}

///////////////////////////////////////////////////////////////////////////
PSMTPDNS_RECS GetDnsRecordsFromLiteral(const char * HostName)
{
    PSMTPDNS_RECS   pDnsRec = NULL;
    MXIPLIST_ENTRY * pEntry = NULL; 
    BOOL    fRet = TRUE;
    DWORD   Error = 0;
    unsigned long InetAddr = 0;
    char * pEndIp = NULL;
    char * pRealHost = NULL;
    char OldChar = '\0';

    TraceFunctEnterEx((LPARAM) NULL, "GetDnsRecordsFromLiteral");

    pRealHost = (char *) HostName;

    //see if this is a domain literal
    if(pRealHost[0] == '[')
    {
        pEndIp = strchr(pRealHost, ']');
        if(pEndIp == NULL)
        {
            ErrorTrace((LPARAM)NULL,"Didn't find ] in literal for %s", HostName);
            TraceFunctLeaveEx((LPARAM) NULL);
            return NULL;
        }

        //save the old character
        OldChar = *pEndIp;

        //null terminate the string
        *pEndIp = '\0';
        pRealHost++;

        //Is this an ip address
        InetAddr = inet_addr( (char *) pRealHost );
    }

    //put back the old character
    if (pEndIp)
        *pEndIp = OldChar;

    if((InetAddr == INADDR_NONE) || (InetAddr == 0))
    {
        ErrorTrace((LPARAM)NULL,"InetAddr is invalid for %s", HostName);
        return NULL;
    }

    pDnsRec = new SMTPDNS_RECS;
    if(pDnsRec == NULL)
    {
        ErrorTrace((LPARAM)NULL,"new SMTPDNS_RECS2 failed for", HostName);
        TraceFunctLeaveEx((LPARAM) NULL);
        return NULL;
    }

    ZeroMemory(pDnsRec, sizeof(SMTPDNS_RECS));

    pDnsRec->DnsArray[0] = new MX_NAMES;
    if(pDnsRec->DnsArray[0] == NULL)
    {
        ErrorTrace((LPARAM)NULL,"new MX_NAMES2 failed for %s", HostName);
        delete pDnsRec;
        TraceFunctLeaveEx((LPARAM) NULL);
        return NULL;
    }

    pEntry = new MXIPLIST_ENTRY;
    if(pEntry == NULL)
    {
        ErrorTrace((LPARAM)NULL,"MXIPLIST_ENTRY2 failed for %s", HostName);
        DeleteDnsRec(pDnsRec);
        TraceFunctLeaveEx((LPARAM) NULL);
        return NULL;
    }

    pDnsRec->NumRecords = 1;
    pDnsRec->DnsArray[0]->NumEntries = 1;

    pEntry->IpAddress = InetAddr;

    InitializeListHead(&pDnsRec->DnsArray[0]->IpListHead);
    lstrcpyn(pDnsRec->DnsArray[0]->DnsName, HostName, sizeof(pDnsRec->DnsArray[0]->DnsName));
    InsertTailList(&pDnsRec->DnsArray[0]->IpListHead, &pEntry->ListEntry);

    TraceFunctLeaveEx((LPARAM) NULL);
    return pDnsRec;
}

///////////////////////////////////////////////////////////////////////////
PSMTPDNS_RECS GetDnsRecordsFromResolverInfo(const char * HostName, DWORD dwAddr )
{
    PSMTPDNS_RECS   pDnsRec = NULL;
    MXIPLIST_ENTRY * pEntry = NULL; 

    TraceFunctEnterEx((LPARAM) NULL, "GetDnsRecordsFromResolverInfo");


    pDnsRec = new SMTPDNS_RECS;
    if(pDnsRec == NULL)
    {
        ErrorTrace((LPARAM)NULL,"new SMTPDNS_RECS2 failed for", HostName);
        TraceFunctLeaveEx((LPARAM) NULL);
        return NULL;
    }

    ZeroMemory(pDnsRec, sizeof(SMTPDNS_RECS));

    pDnsRec->DnsArray[0] = new MX_NAMES;
    if(pDnsRec->DnsArray[0] == NULL)
    {
        ErrorTrace((LPARAM)NULL,"new MX_NAMES2 failed for %s", HostName);
        delete pDnsRec;
        TraceFunctLeaveEx((LPARAM) NULL);
        return NULL;
    }

    pEntry = new MXIPLIST_ENTRY;
    if(pEntry == NULL)
    {
        ErrorTrace((LPARAM)NULL,"MXIPLIST_ENTRY2 failed for %s", HostName);
        DeleteDnsRec(pDnsRec);
        TraceFunctLeaveEx((LPARAM) NULL);
        return NULL;
    }

    pDnsRec->NumRecords = 1;
    pDnsRec->DnsArray[0]->NumEntries = 1;

    pEntry->IpAddress = dwAddr;

    InitializeListHead(&pDnsRec->DnsArray[0]->IpListHead);
    lstrcpyn(pDnsRec->DnsArray[0]->DnsName, HostName, sizeof(pDnsRec->DnsArray[0]->DnsName));
    InsertTailList(&pDnsRec->DnsArray[0]->IpListHead, &pEntry->ListEntry);

    TraceFunctLeaveEx((LPARAM) NULL);
    return pDnsRec;
}

//-----------------------------------------------------------------------------
//  Decription:
//      This function is called when we have exhausted all the MX hosts for a
//      particular destination server. The only option is to see if there are 
//      any alternative destinations to which the mail may be forwarded. A list
//      of alternative hosts is maintained in the DNS resolver record (if it is
//      available. So we need to kick off a resolve for the next alternate host
//      if it exists.
//  Arguments:
//  Returns:
//  History:
//-----------------------------------------------------------------------------
BOOL REMOTE_QUEUE::ConnectToNextResolverHost( CAsyncMx    * pThisQ )
{
    DNS_RESOLVER_RECORD *pDNS_RESOLVER_RECORD;
    BOOL fRet;

    //  We embedded the resolver record into the MX records object
    pDNS_RESOLVER_RECORD = pThisQ->GetDnsResolverRecord();

    // Abdicate responsibility to delete DNS_RESOLVER_RECORD to ConnectToResolverHost()
    pThisQ->SetDnsResolverRecord(NULL);

    //  No alternate hosts.
    if( pDNS_RESOLVER_RECORD == NULL )
    {
        return( FALSE );
    }

    char              MyFQDNName[MAX_PATH + 1];

    GetParentInst()->LockGenCrit();
    lstrcpyn(MyFQDNName,GetParentInst()->GetFQDomainName(),MAX_PATH);
    GetParentInst()->UnLockGenCrit();

    fRet = ConnectToResolverHost( pThisQ->GetSSLVerificationName(), 
                                  MyFQDNName, 
                                  pThisQ->GetSmtpConnectionObj(), 
                                  pThisQ->GetDomainOptions(), 
                                  FALSE,
                                  pDNS_RESOLVER_RECORD );
    return fRet;
}

//-----------------------------------------------------------------------------
//  Description:
//      Basically this function tries to resolve one of the hosts in the DNS
//      resolver record (supplied by the sink) so that SMTP can send to that.
//      To do this it is called repeatedly, and each time around it tries a
//      different host till it succeeds in resolving it. If no DNS resolver
//      record is available (NULL) we try to resolve the HostName directly.
//      If DNS resolution is not needed --- ie if the resolution information
//      is available locally or from the resolver record, then this function
//      will kick off an async connect to the first MX host.
//  Arguments:
//      [IN] const char * HostName   - Hostname to resolve
//      [IN] LPSTR MyFQDNName        -
//      [IN] ISMTPConnection *pISMTPConnection -
//      [IN] DWORD DomainOptions     - Bitmask of options
//      [IN] BOOL fUseSmartHostAfterFail -
//      [IN] DNS_RESOLVER_RECORD *pDNS_RESOLVER_RECORD - This object must always
//              be associated with the current remote queue, till we succeed in
//              connecting to the remote SMTP server.
//  Returns:
//      TRUE on success.
//      FALSE on all errors.
//  History:
//      GPulla modified.
//-----------------------------------------------------------------------------
BOOL REMOTE_QUEUE::ConnectToResolverHost( const char * HostName,
                                          LPSTR MyFQDNName,
                                          ISMTPConnection *pISMTPConnection,
                                          DWORD DomainOptions,
                                          BOOL fUseSmartHostAfterFail,
                                          DNS_RESOLVER_RECORD *pDNS_RESOLVER_RECORD)
{
    DWORD             dwAddr = 0;
    PSMTPDNS_RECS     pDnsRec = NULL;
    BOOL              fRet = FALSE;
    BOOL              fUseDns = TRUE;
    BOOL              fIsLiteral = FALSE;
    DWORD             dwDnsFlags = 0;
    LPSTR             pszRealHostName = NULL;
    BOOL              fFreeHostName = FALSE;
    HRESULT           hr = S_OK;
    LPSTR             pszSSLVerificationName = NULL;
    BOOL              fSSLSubjectDisabled = FALSE;

    TraceFunctEnterEx((LPARAM)this, "ConnectToResolverHost (const char * HostName)");

    DebugTrace((LPARAM) this,"Finding MX records for %s with options %x", HostName, DomainOptions);

    if (HostName)
    {
        fIsLiteral = (HostName[0] == '[');
    }

    if(GetParentInst()->UseGetHostByName() || fIsLiteral)
    {
        fUseDns = FALSE;

        DebugTrace((LPARAM) this,"Not using DNS for resolution - literal, or GHBN");
    }
    else if(g_TcpRegIpList.GetCount() == 0)
    {
        fUseDns = FALSE;

        DebugTrace((LPARAM) this,"Not using DNS for resolution - No DNS servers");
    }

    if (!(DomainOptions | MUST_DO_TLS) || !GetParentInst()->RequiresSSLCertVerifySubject())
        fSSLSubjectDisabled = TRUE;

    dwDnsFlags = GetParentInst()->GetDnsFlags();

    pszRealHostName = (LPSTR)HostName;

    //
    //  If there is a DNS resolver record, retrieve the (next) possible
    //  destination host from it for resolution.
    //
    if( pDNS_RESOLVER_RECORD )
    {
        DWORD dwAddr = 0;
        LPSTR pszTmpHostName = NULL;

        DebugTrace((LPARAM) this, "Trying to get next host from DNS resolver record");
        if( FAILED( hr = pDNS_RESOLVER_RECORD->HrGetNextDestinationHost(&pszTmpHostName, &dwAddr) ) )
        {
            if( HRESULT_FROM_WIN32( ERROR_NO_MORE_ITEMS ) != hr )
            {
                ErrorTrace((LPARAM) this,"m_pIDnsResolverRecord->GetItem() failed hr = 0x%x failed", hr);
            }
            else
            {
                DebugTrace((LPARAM) this, "Tried all possible destination hosts. Failing ConnectToResolverHost.\n");
                SetLastError( ERROR_NO_MORE_ITEMS );
            }

            fRet = FALSE;
            goto Exit;
        }
        else
        {
            fFreeHostName = TRUE;
            pszRealHostName = pszTmpHostName;
            DebugTrace((LPARAM) this, "ConnectToResolverHost trying destination host : %s", pszRealHostName);

            if( dwAddr != 0 )
            {
                //
                // this means we don't have to call  DNS or GetHostByName to get the Ip addres
                //
            
                DebugTrace((LPARAM) this, "DNS records available, not calling DNS");
                pDnsRec = GetDnsRecordsFromResolverInfo( pszRealHostName, dwAddr );
            
                if(pDnsRec)
                {
            
                    //
                    //  This causes SMTP to successively try an connect to each of the MX hosts
                    //  for the destination host in turn till a connection succeeds. pDnsRec has
                    //  the MX hosts info.
                    //
                    DebugTrace((LPARAM) this, "Initializing async connect to MX hosts...");
                    

                    if (fSSLSubjectDisabled) {

                        pszSSLVerificationName = NULL;

                    } else if (ERROR_SUCCESS == DnsValidateName (HostName, DnsNameDomain)) {

                        DebugTrace ((LPARAM) this, "%s is a DNS name", HostName);
                        pszSSLVerificationName = (LPSTR) HostName;

                    } else {

                        DebugTrace ((LPARAM) this, "%s is not a DNS name", HostName);
                        pszSSLVerificationName = pszTmpHostName;
                    }

                    //
                    //  if HostName is not a DNS name ---  its a special name (like a
                    //  GUID for an Exchange connector, and we need to use pszTmpHostName,
                    //  the name returned by DNS sink as the SSL verification Name.
                    //
                    //  if HostName is a DNS name --- the the DNS sink resolved it to an
                    //  IP and pszTmpHostName was obtained by DNS indirection (MX record
                    //  or CNAME record). This is insecure and cannot be used for SSL subject
                    //  verification, so we use HostName instead.
                    //
                    fRet = BeginInitializeAsyncConnect(
                                                pDnsRec,
                                                pISMTPConnection,
                                                DomainOptions,
                                                pDNS_RESOLVER_RECORD,
                                                pszSSLVerificationName);

                    pDNS_RESOLVER_RECORD = NULL; //  Passed on delete responsibillity to BeginInitializeAsyncConnect

                    if(!fRet)
                    {
                        ErrorTrace((LPARAM) this, "Failed BeginInitializeAsyncConnect.");
                        DeleteDnsRec(pDnsRec);
                    }
                }
            
                CoTaskMemFree( pszRealHostName );
                pszRealHostName = NULL;
                goto Exit;
            }
            //
            // else go thru DNS or gethostbyname to get the address
            //   
            DebugTrace((LPARAM) this, "Querying DNS");
        }

    }
    else
    {
        _ASSERT( HostName );
    }
    
    if(fUseDns)
    {
        DebugTrace((LPARAM) this, "ConnectToResolverHost querying DNS to resolve host: %s", pszRealHostName);

        if (fSSLSubjectDisabled) {
                
            pszSSLVerificationName = NULL;

        } else {

            pszSSLVerificationName = (LPSTR) pszRealHostName;
        }
        //
        //  Using DNS to resolve destination host.
        //
        fRet = BeginInitializeAsyncDnsQuery( pszRealHostName,
                                             MyFQDNName,
                                             pISMTPConnection,
                                             dwDnsFlags,
                                             DomainOptions,
                                             fUseSmartHostAfterFail,
                                             pDNS_RESOLVER_RECORD,
                                             pszSSLVerificationName);

        pDNS_RESOLVER_RECORD = NULL; // Passed on delete responsibility to BeginInitializeAsyncDnsQuery
        DebugTrace((LPARAM) this, "BeginInitializeAsyncDnsQuery returned %s", fRet ? "TRUE" : "FALSE");
    }
    else
    {
        if(!fIsLiteral)
            pDnsRec = GetDnsRecordsFromHostFile(HostName);
        else
            pDnsRec = GetDnsRecordsFromLiteral(HostName);

        if(pDnsRec)
        {
            DebugTrace((LPARAM) this, "ConnectToResolverHost resolved %s locally", pszRealHostName);

            //
            //  The target host (before DNS) to which this server is connecting to... used by SSL
            //  If this is a literal, pass in NULL, as there is no hostname
            //
            pszSSLVerificationName = NULL;


            if (fSSLSubjectDisabled) {
                    
                pszSSLVerificationName = NULL;

            } else if (fIsLiteral) {
            
                pszSSLVerificationName = NULL;
            
            } else {

                pszSSLVerificationName = (LPSTR) HostName;
            }

            fRet = BeginInitializeAsyncConnect(
                                            pDnsRec,
                                            pISMTPConnection,
                                            DomainOptions,
                                            pDNS_RESOLVER_RECORD,
                                            pszSSLVerificationName);

            pDNS_RESOLVER_RECORD = NULL; // Passed on delete responsibility to BeginInitializeAsyncConnect

            if(!fRet)
            {
                ErrorTrace((LPARAM) this, "Failed BeginInitializeAsyncConnect");
                DeleteDnsRec(pDnsRec);
            }
        }
    }

    if( fFreeHostName )
    {
        CoTaskMemFree( pszRealHostName );
    }

Exit:
    if(pDNS_RESOLVER_RECORD)    // Non NULL => delete responsibility is still this function's
        delete pDNS_RESOLVER_RECORD;

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////
/*++

    Name :
        StartAsyncConnect

    Description:

        This function either does a straight gethostbyname(),
        or performs an MX record lookup to get the hostname/ip
        address to connect to.

    Arguments:

        char * SmartHost - This is either an IP address,
        or a hostname

    Returns:
        TRUE if an Async connection was started
        FALSE otherwise

--*/
BOOL REMOTE_QUEUE::StartAsyncConnect(
    const char *HostName,
    ISMTPConnection *pISMTPConnection,
    DWORD DomainOptions,
    BOOL fUseSmartHostAfterFail )
{

    DWORD    dwVirtualServerId = 0;
    HRESULT  hr = S_OK;
    char     MyFQDNName[MAX_PATH + 1];
    BOOL     fRet;
    IDnsResolverRecord *pIDnsResolverRecord = NULL;
    IDnsStatus *pIDnsStatus = NULL;
    DNS_RESOLVER_RECORD *pDNS_RESOLVER_RECORD;

    TraceFunctEnterEx((LPARAM)this, "StartAysncConnect (const char * HostName)");

    DebugTrace((LPARAM) this,"Finding MX records for %s with options %x", HostName, DomainOptions);

    GetParentInst()->LockGenCrit();
    lstrcpyn(MyFQDNName,GetParentInst()->GetFQDomainName(),MAX_PATH);
    dwVirtualServerId = GetParentInst()->QueryInstanceId();
    GetParentInst()->UnLockGenCrit();

    //
    //  Get the DNS resolver record from the DNS resolution sink. The resolver record is 
    //  basically a list of alternate hosts to which this mail may be sent to next. If the 
    //  sink does not have any suggestions to make the resolver record will remain NULL.
    //
    GetParentInst()->TriggerDnsResolverEvent( (LPSTR)HostName, 
                                              MyFQDNName, 
                                              dwVirtualServerId, 
                                              &pIDnsResolverRecord );
    
    pDNS_RESOLVER_RECORD = NULL;
    if(pIDnsResolverRecord)
    {
        //
        // IDnsStatus is an optional interface exposed by the DNS resolver record
        // object that contains additional information if something failed in the
        // DNS resolver. If resolution fails, we use it to check if the failure is
        // authoritative, and therefore we should NDR the messages.
        //

        hr = pIDnsResolverRecord->QueryInterface(IID_IDnsStatus, (PVOID *) &pIDnsStatus);
        if(SUCCEEDED(hr))
        {
            DWORD dwAck = 0;
            DWORD dwDiagnostic = 0;

            hr = pIDnsStatus->GetDnsStatus();
            if(HRESULT_FROM_WIN32(DNS_ERROR_RCODE_NAME_ERROR) == hr)
            {
                dwDiagnostic = AQUEUE_E_AUTHORITATIVE_HOST_NOT_FOUND;
                dwAck = CONNECTION_STATUS_FAILED_NDR_UNDELIVERED;
            }
            else if(FAILED(hr))
            {
                dwDiagnostic = AQUEUE_E_HOST_NOT_FOUND;
                dwAck = CONNECTION_STATUS_FAILED;
            }

            if(FAILED(hr))
            {
                pISMTPConnection->SetDiagnosticInfo(dwDiagnostic, NULL, NULL);
                pISMTPConnection->AckConnection(dwAck);
                pISMTPConnection->Release();

                fRet = TRUE;
                pIDnsStatus->Release();
                pIDnsResolverRecord->Release();
                goto Exit;
            }
            pIDnsStatus->Release();
        }
 
        DebugTrace((LPARAM) this, "DNS resolver sink returned pIDnsResolverRecord");
        pDNS_RESOLVER_RECORD = new DNS_RESOLVER_RECORD;
        if(!pDNS_RESOLVER_RECORD )
        {
            ErrorTrace((LPARAM) this, "Cannot allocate pDNS_RESOLVER_RECORD. Out of memory."); 
            pIDnsResolverRecord->Release();
            fRet = FALSE;
            goto Exit;
        }
        pDNS_RESOLVER_RECORD->SetDnsResolverRecord(pIDnsResolverRecord);
    }

    fRet = ConnectToResolverHost( HostName, 
                                  MyFQDNName, 
                                  pISMTPConnection, 
                                  DomainOptions, 
                                  fUseSmartHostAfterFail, 
                                  pDNS_RESOLVER_RECORD );

Exit:
    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

//-----------------------------------------------------------------------------
//  Description:
//      Wrapper for DnsQueryAsync (exists only to BUMP REMOTE_QUEUE counters).
//  Arguments:
//      These are simply passed in to DnsQueryAsync... see documentation of
//      DnsQueryAsync for details.
//  Returns:
//      TRUE    if query was successfully started.
//      FALSE   on errors.
//  History:
//      GPulla modified.
//-----------------------------------------------------------------------------
BOOL REMOTE_QUEUE::BeginInitializeAsyncDnsQuery( LPSTR pszHostName,
                                                 LPSTR pszFQDN,
                                                 ISMTPConnection *pISMTPConnection,
                                                 DWORD dwDnsFlags,
                                                 DWORD DomainOptions,
                                                 BOOL  fUseSmartHostAfterFail,
                                                 DNS_RESOLVER_RECORD *pDNS_RESOLVER_RECORD,
                                                 const char * pszSSLVerificationName) 
{
    BOOL fRet = FALSE;
    DWORD fUdp = TRUE;

    TraceFunctEnterEx((LPARAM) this, "REMOTE_QUEUE::BeginInitializeAsyncDnsQuery");

    if(dwDnsFlags & DNS_FLAGS_TCP_ONLY)
        fUdp = FALSE;

    fRet = DnsQueryAsync(
                GetParentInst(),
                pszHostName,
                pszFQDN,
                pISMTPConnection,
                dwDnsFlags,
                DomainOptions,
                fUseSmartHostAfterFail,
                pDNS_RESOLVER_RECORD,
                pszSSLVerificationName,
                fUdp);

    if(fRet)
        BUMP_COUNTER(GetParentInst(), NumDnsQueries);

    TraceFunctLeaveEx((LPARAM) this);
    return fRet;
}

//-----------------------------------------------------------------------------
//  Description:
//      Kicks off an async query to DNS to resolve pszHostName (ie get the MX
//      records for it). When the query is complete, and the MX records have
//      been retrieved, the completion thread will try to connect to the MX
//      hosts by posting a callback to QueueCallBackFunction().
//  Arguments:
//      [IN] pServiceInstance - PTR to ISMTPServerInstance for this queue
//
//      [IN] pszHostName - Host we're trying to lookup (this is copied over)
//
//      [IN] pszFQDN - My FQDN (this is copied over)
//
//      [IN] pISMTPConnection - Connection to ACK, get messages from. After
//          this is passed in, this funtion will handle acking and releasing it
//          if TRUE is returned. If FALSE is returned, the pISMTPConnection
//          is not touched and the caller must ACK and release it.
//
//      [IN] dwDnsFlags - DNS configuration flags.
//
//      [IN] DomainOptions - Use SSL, Verify SSL cert, etc. Various outbound options.
//
//      [IN] fUseSmartHostAfterFail  - DUH
//
//      [IN] DNS_RESOLVER_RECORD *   - Set of possible next hop destinations
//          returned by the DNS sink (may be NULL). If we fail DNS resolution 
//          for pszHostName (which is the first next hop in pDNS_RESOLVER_RECORD),
//          the others are tried in turn. After this is passed in... this function
//          handles deleting it (irrespective of whether TRUE or FALSE is returned).
//
//      [IN] pszSSLVerificationName  - Target host which we are trying to
//          resolve/connect. Could be NULL if there isn't a target host (such as
//          in the case of a literal IP address) (this is copied over).
//
//      [IN] fUdp - Issue query over UDP or TCP?
//-----------------------------------------------------------------------------
BOOL DnsQueryAsync(
    SMTP_SERVER_INSTANCE *pServiceInstance,
    LPSTR pszHostName,
    LPSTR pszFQDN,
    ISMTPConnection *pISMTPConnection,
    DWORD dwDnsFlags,
    DWORD DomainOptions,
    BOOL  fUseSmartHostAfterFail,
    DNS_RESOLVER_RECORD *pDNS_RESOLVER_RECORD,
    const char * pszSSLVerificationName,
    BOOL fUdp)
{
    PSMTPDNS_RECS   pDnsRec = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL fRet = FALSE;
    
    TraceFunctEnterEx((LPARAM)NULL, "REMOTE_QUEUE::BeginInitializeAsyncDnsQuery");

    CAsyncSmtpDns *pAsyncDns = new CAsyncSmtpDns(pServiceInstance, pISMTPConnection);
    if(!pAsyncDns)
    {
        DebugTrace((LPARAM) NULL, "Unable to allocate CAsyncSmtpDns object. Out of Memory");
        goto Exit;
    }

    //
    // From now on pAsyncDns will handle the deletion of pDNS_RESOLVER_RECORD and
    // the pISmtpConnection ack... initiation of the async DNS query has succeeded
    // as far as the caller is concerned.
    //
    fRet = TRUE;

    pAsyncDns->SetDnsResolverRecord(pDNS_RESOLVER_RECORD);
    pDNS_RESOLVER_RECORD = NULL; // Passed on delete responsibility to pAsyncDns object
    pISMTPConnection = NULL; // Passed on delete responsibility to pAsyncDns object

    pAsyncDns->SetDomainOptions(DomainOptions);
    pAsyncDns->SetSmartHostOption(fUseSmartHostAfterFail);

    if (!pAsyncDns->Init((LPSTR) pszSSLVerificationName))
    {
        delete pAsyncDns;
        goto Exit;
    }

    DebugTrace((LPARAM) NULL, "Issuing DNS query for pAsyncDns = 0x%08x", pAsyncDns);
    dwStatus = pAsyncDns->Dns_QueryLib(
                                pszHostName,
                                DNS_TYPE_MX,
                                dwDnsFlags,
                                pszFQDN,
                                fUdp);

    if(dwStatus != ERROR_SUCCESS)
    {
        ErrorTrace((LPARAM)NULL, "Failed to issue DNS query for pAsyncDns = 0x%08x", pAsyncDns);
        delete pAsyncDns;
    }
    else
    {
        DebugTrace((LPARAM) NULL, "DNS query outstanding on object pAsyncDns = 0x%08x", pAsyncDns);
    }

Exit:
    if(pDNS_RESOLVER_RECORD)    // Non NULL => delete responsibility is still this function's
        delete pDNS_RESOLVER_RECORD;

    TraceFunctLeaveEx((LPARAM)NULL);
    return( fRet );
}

//-----------------------------------------------------------------------------
//  Description:
//      This function kicks off a connection to the first of the MX hosts
//      (from pDnsRec). It calls InitializeAsyncConnect() which will call
//      back to QueueCallbackFunction() immediately.
//  Arguments:
//  Returns:
//  History:
//-----------------------------------------------------------------------------
BOOL REMOTE_QUEUE::BeginInitializeAsyncConnect( PSMTPDNS_RECS pDnsRec,
                                                ISMTPConnection *pISMTPConnection,
                                                DWORD DomainOptions,
                                                DNS_RESOLVER_RECORD *pDNS_RESOLVER_RECORD,
                                                const char *pszSSLVerificationName )
{
    MXPARAMS Params;
    BOOL fRet = FALSE;

    Params.HostName = pDnsRec->DnsArray[0]->DnsName;
    Params.PortNum = GetParentInst()->GetRemoteSmtpPort();
    Params.TimeOut = INFINITE;
    Params.CallBack = QueueCallBackFunction;
    Params.pISMTPConnection = pISMTPConnection;
    Params.pInstance = GetParentInst();
    Params.pDnsRec = pDnsRec;
    Params.pDNS_RESOLVER_RECORD = pDNS_RESOLVER_RECORD;
    CAsyncMx* pAsyncIo = new CAsyncMx (&Params);

    if(pAsyncIo)
    { 
        pDNS_RESOLVER_RECORD = NULL; // Passed on delete responsibility to pAsyncIo
        pAsyncIo->SetDomainOptions(DomainOptions);

        if(!pAsyncIo->Init((LPSTR) pszSSLVerificationName))
        {
            delete pAsyncIo;
        }
        else if(!pAsyncIo->InitializeAsyncConnect())
        {
            delete pAsyncIo;
            fRet = FALSE;
        }
        else
        {
            fRet = TRUE;
        }
    }
    else
    {
        fRet = FALSE;
    }

    if(pDNS_RESOLVER_RECORD)    // Non NULL => delete responsibility is still this function's
        delete pDNS_RESOLVER_RECORD;
    return fRet;
}

///////////////////////////////////////////////////////////////////////////
BOOL REMOTE_QUEUE::ReStartAsyncConnections(
    SMTPDNS_RECS    * pDnsRec,
    ISMTPConnection * pISMTPConnection,
    DWORD             DomainOptions,
    LPSTR             pszSSLVerificationName )
{
    CAsyncMx * pAsyncIo = NULL;
    MXPARAMS Params;
    BOOL fRet = FALSE;

    TraceFunctEnterEx((LPARAM)this, "ReStartAsyncConnections");

    Params.HostName = pDnsRec->DnsArray[pDnsRec->StartRecord]->DnsName;
    Params.PortNum = GetParentInst()->GetRemoteSmtpPort();
    Params.TimeOut = INFINITE;
    Params.CallBack = QueueCallBackFunction;
    Params.pISMTPConnection = pISMTPConnection;
    Params.pInstance = GetParentInst();
    Params.pDnsRec = pDnsRec;
    Params.pDNS_RESOLVER_RECORD = NULL;

    pAsyncIo = new CAsyncMx (&Params);
    if(pAsyncIo)
    {
        if (!pAsyncIo->Init(pszSSLVerificationName))
        {
            ErrorTrace ((LPARAM) this, "pAsyncIo->Init() failed");
            delete pAsyncIo;
            goto Exit;
        }

        pAsyncIo->SetDomainOptions(DomainOptions);

        if(!pAsyncIo->InitializeAsyncConnect())
        {
            ErrorTrace((LPARAM) this,"pAsyncIo->InitializeAsyncConnect()for %s failed", Params.HostName);
            delete pAsyncIo;
        }
        else
        {
            fRet = TRUE;
        }
    }
Exit:
    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

///////////////////////////////////////////////////////////////////////////
BOOL REMOTE_QUEUE::MakeATQConnection(
    SMTPDNS_RECS*    pDnsRec,
    SOCKET           Socket,
    DWORD            IpAddress,
    ISMTPConnection* pISMTPConnection,
    DWORD            Options,
    LPSTR            pszSSLVerificationName)
{
    sockaddr_in AddrRemote;
    SMTP_CONNOUT * SmtpConn = NULL;
    DWORD Error = 0;

    TraceFunctEnterEx((LPARAM) this, "REMOTE_QUEUE::MakeATQConnection");

    _ASSERT (Socket != INVALID_SOCKET);
    _ASSERT (GetParentInst() != NULL);
    //_ASSERT (IpAddress != 0);

    if(IpAddress == 0)
    {
        if(Socket != INVALID_SOCKET)
            closesocket(Socket);

        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;   
    }

    //set the remote IP address we connected to
    AddrRemote.sin_addr.s_addr = IpAddress;

    //create an outbound connection
    SmtpConn = SMTP_CONNOUT::CreateSmtpConnection(
                                        GetParentInst(),
                                        Socket,
                                        (SOCKADDR_IN *)&AddrRemote,
                                        (SOCKADDR_IN *)&AddrRemote,
                                        NULL,
                                        NULL,
                                        0,
                                        Options,
                                        pszSSLVerificationName);
    if(SmtpConn == NULL)
    {
        Error = GetLastError();
        pISMTPConnection->SetDiagnosticInfo(HRESULT_FROM_WIN32(Error), NULL, NULL);
        closesocket(Socket);
        DeleteDnsRec(pDnsRec);
        FatalTrace((LPARAM) this, "SMTP_CONNOUT::CreateSmtpConnection failed, error =%i", Error);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    SmtpConn->SetDnsRec(pDnsRec);

    DebugTrace((LPARAM) this, "alloced SMTPOUT pointer %X", SmtpConn);

    //add this connection object to the ATQ infrastructure
    if(!SmtpConn->AddToAtqHandles((HANDLE)Socket, NULL, GetParentInst()->GetRemoteTimeOut(), InternetCompletion))
    {
        Error = GetLastError();
        pISMTPConnection->SetDiagnosticInfo(HRESULT_FROM_WIN32(Error), NULL, NULL);
        closesocket(Socket);
        FatalTrace((LPARAM) this, "SmtpConn->AddToAtqHandles failed, error =%d", Error);
        SmtpConn->SetConnectionStatus(CONNECTION_STATUS_FAILED);
        delete SmtpConn;
        SmtpConn = NULL;
        SetLastError(Error);
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    //insert the outbound connection object into
    //our list of outbound conection objects
    if(!GetParentInst()->InsertNewOutboundConnection(SmtpConn))
    {
        Error = GetLastError();
        pISMTPConnection->SetDiagnosticInfo(HRESULT_FROM_WIN32(Error), NULL, NULL);
        FatalTrace((LPARAM) this, "GetParentInst()->InsertNewOutboundConnection failed, error =%d", Error);
        SmtpConn->DisconnectClient();
        SmtpConn->SetConnectionStatus(CONNECTION_STATUS_FAILED);
        delete SmtpConn;
        SmtpConn = NULL;
        SetLastError(Error);
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    SmtpConn->SetCurrentObject(pISMTPConnection);

    //start session will pend a read to pick
    //up the servers signon banner
    if(!SmtpConn->StartSession())
    {
        //get the error
        Error = GetLastError();

        //SmtpConn->SetCurrentObjectToNull();
        FatalTrace((LPARAM) this, "SmtpConn->StartSession failed, error =%d", Error);
        SmtpConn->DisconnectClient();
        GetParentInst()->RemoveOutboundConnection(SmtpConn);

        //An empty queue at this point is really not an error
        if (ERROR_EMPTY == Error)
            SmtpConn->SetConnectionStatus(CONNECTION_STATUS_OK);
        else
            SmtpConn->SetConnectionStatus(CONNECTION_STATUS_FAILED);

        delete SmtpConn;
        SmtpConn = NULL;
        SetLastError (Error);
        
        //TraceFunctLeaveEx((LPARAM) this);
        //return FALSE;
    }

    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
#define PRIVATE_OPTIMAL_BUFFER_SIZE             64 * 1024
#define PRIVATE_LINE_BUFFER_SIZE                1024
///////////////////////////////////////////////////////////////////////////
static BOOL CopyMessage(PFIO_CONTEXT hSrcFile, HANDLE hDstFile, HANDLE dwEventHandle)
{
    CHAR    acBuffer[PRIVATE_OPTIMAL_BUFFER_SIZE];
    DWORD   dwBytesRead;
    DWORD   dwBytesWritten;
    DWORD   dwTotalBytes = 0;

    CHAR    acCrLfDotCrLf[5] = { '\r', '\n', '.', '\r', '\n' };
    CHAR    acLastBytes[5] = { '\0', '\0', '\0', '\0', '\0' };

    FH_OVERLAPPED   Ov;
    BOOL fResult = TRUE;
    DWORD err = 0;

    ZeroMemory (&Ov, sizeof(Ov));
    Ov.hEvent = (HANDLE) ((ULONG_PTR) dwEventHandle | 1);

    // Copies from the current file pointer to the end of hSrcFile 
    // and appends to the current file pointer of hDstFile.
    _ASSERT(hSrcFile != NULL);
    _ASSERT(hDstFile != INVALID_HANDLE_VALUE);

    do 
    {
        fResult = FIOReadFile(hSrcFile, acBuffer, 
                        PRIVATE_OPTIMAL_BUFFER_SIZE,
                        &Ov);

        // if this returned TRUE then we want to go down the path which calls
        // GetOverlappedResult just so that we can get dwBytesRead.
        if (fResult) err = ERROR_IO_PENDING;
        else err = GetLastError();

        if(err == ERROR_IO_PENDING)
        {
            if(GetOverlappedResult(dwEventHandle, (OVERLAPPED *) &Ov, &dwBytesRead, INFINITE))
            {
                Ov.Offset += dwBytesRead;
                ResetEvent(dwEventHandle);
            }
            else
            {
                return FALSE;
            }
        } else {
            //SmtpLogEventEx(SMTP_EVENT_CANNOT_WRITE_FILE, MailF
            SetLastError (err); //preserve the last error
            if(err == ERROR_HANDLE_EOF)
                return TRUE;
            else
                return FALSE;
        }

        if (dwBytesRead)
        {
            if (!WriteFile(hDstFile, acBuffer, 
                            dwBytesRead,
                            &dwBytesWritten,
                            NULL))
                return(FALSE);

            // See if read equals written
            if (dwBytesRead != dwBytesWritten)
                return(FALSE);
        }
        else
        {
            dwBytesWritten = 0;
        }

        if (dwBytesWritten)
        {
            dwTotalBytes += dwBytesWritten;

            // Save the last two bytes ever written
            if (dwBytesWritten > 4)
            {
                CopyMemory(acLastBytes, &acBuffer[dwBytesWritten-5], 5);
            }
            else
            {
                MoveMemory(acLastBytes, &acLastBytes[dwBytesWritten], 5-dwBytesWritten);
                CopyMemory(&acLastBytes[5-dwBytesWritten], acBuffer, dwBytesWritten);
            }
        }

    } while (dwBytesRead);

    // Now, see if the file ends with a CRLF, if not, add it
    if ((dwTotalBytes > 1) && memcmp(&acLastBytes[3], &acCrLfDotCrLf[3], 2))
    {
        // Add the trailing CRLF        
        if (!WriteFile(hDstFile, acCrLfDotCrLf, 
                        2,
                        &dwBytesWritten,
                        NULL))
        {
            return(FALSE);
        }

        if (dwBytesWritten != 2)
        {
            return(FALSE);
        }

        dwTotalBytes+=2;

    }

    //If file ends with CRLF.CRLF, remove the trailing CRLF.CRLF
    //R.P - On 1/12/98 we decided to remove the CRLF.CRLF because
    //of a bug/feature in IMAP.  POP3 will add the CRLF.CRLF when
    //retrieving the mail.
    if ((dwTotalBytes > 4) && !memcmp(acLastBytes, acCrLfDotCrLf, 5))
    {
        // Remove the trailing CRLF.CRLF
        if ((SetFilePointer(hDstFile, -5, NULL, FILE_CURRENT) == 0xffffffff) ||
            !SetEndOfFile(hDstFile))
        {
            return(FALSE);
        }
    }
    else
    {
        // Remove the trailing CRLF
        if ((SetFilePointer(hDstFile, -2, NULL, FILE_CURRENT) == 0xffffffff) ||
            !SetEndOfFile(hDstFile))
        {
            return(FALSE);
        }

    }

    return(TRUE);
}

///////////////////////////////////////////////////////////////////////////
BOOL CreateXHeaders(
    IMailMsgProperties *pIMsg,
    IMailMsgRecipients *pIMsgRecips ,
    DWORD cRcpts,
    DWORD *rgRcptIndex,
    HANDLE hDrop)
{
    TraceFunctEnter("CreateXHeaders");

    #define X_SENDER_HEADER     "x-sender: "
    #define X_RECEIVER_HEADER   "x-receiver: "
    #define X_HEADER_EOLN       "\r\n"

    #define MAX_HEADER_SIZE     (sizeof(X_RECEIVER_HEADER))

    BOOL fRet = FALSE;
    HRESULT hr;
    DWORD i, cBytes;
    BOOL fContinue = TRUE;
    char szBuffer[
            MAX_HEADER_SIZE +
            MAX_INTERNET_NAME +
            1 + 2 + 1]; // Closing ">", CRLF, and NULL

    strcpy( szBuffer, X_SENDER_HEADER );

    hr = pIMsg->GetStringA(
            IMMPID_MP_SENDER_ADDRESS_SMTP,
            MAX_INTERNET_NAME,
            &szBuffer[ sizeof(X_SENDER_HEADER) - 1] );

    if(SUCCEEDED(hr))
    {
        strcat(szBuffer, X_HEADER_EOLN);

        if (!WriteFile(hDrop, szBuffer, strlen(szBuffer), &cBytes, NULL) ) {

            ErrorTrace(0, "Error %d writing x-sender line %s",
                GetLastError(), szBuffer);

            goto Cleanup;

        } else {

            _ASSERT( cBytes == strlen(szBuffer) );

        }

    } else {

        DebugTrace(0, "Could not get Sender Address %x", hr);

        SetLastError( ERROR_INVALID_DATA );

        goto Cleanup;

    }

    strcpy( szBuffer, X_RECEIVER_HEADER );


    
    
    for (i = 0; i < cRcpts && fContinue; i++)
    {
    
        DWORD dwRecipientFlags = 0;
        hr = pIMsgRecips->GetDWORD(rgRcptIndex[i], IMMPID_RP_RECIPIENT_FLAGS,&dwRecipientFlags);
        if( SUCCEEDED( hr ) )
        {
            if( RP_HANDLED != ( dwRecipientFlags & RP_HANDLED ) )
            {
    
                hr = pIMsgRecips->GetStringA(
                        rgRcptIndex[i],
                        IMMPID_RP_ADDRESS_SMTP,
                        MAX_INTERNET_NAME,
                        &szBuffer[ sizeof(X_RECEIVER_HEADER) - 1 ]);
    
                if (SUCCEEDED(hr)) {
                    
                    strcat(szBuffer, X_HEADER_EOLN);
    
                    if (!WriteFile(hDrop, szBuffer, strlen(szBuffer), &cBytes, NULL)) {
    
                        ErrorTrace(0, "Error %d writing recipient x-header %s",
                            GetLastError(), szBuffer);
    
                        fContinue = FALSE;
    
                    }
    
                }
                else
                {
                    SetLastError( ERROR_INVALID_DATA );
                    fContinue = FALSE;
                }
            }
        }
    
    }

    // If we got all recipients without error, we were successful

    if (i == cRcpts)
        fRet = TRUE;

                

Cleanup:

    TraceFunctLeave();

    return( fRet );

}

///////////////////////////////////////////////////////////////////////////
HANDLE REMOTE_QUEUE::CreateDropFile(const char * DropDir, char * szDropFile)
{
    HANDLE  FileHandle = INVALID_HANDLE_VALUE;
    DWORD           dwStrLen;
    FILETIME        ftTime;
    DWORD           Error = 0;

    TraceFunctEnterEx((LPARAM)this, "REMOTE_QUEUE::CreateDropFile");

    dwStrLen = lstrlen(DropDir);
    lstrcpy(szDropFile, DropDir); 

    do
    {
        GetSystemTimeAsFileTime(&ftTime);
        wsprintf(&szDropFile[dwStrLen],
                "%08x%08x%08x%s",
                ftTime.dwLowDateTime,
                ftTime.dwHighDateTime,
                InterlockedIncrement((PLONG)&g_dwFileCounter),
                ".eml");

        FileHandle = CreateFile(szDropFile, GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_NEW,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                                 NULL);
        if (FileHandle != INVALID_HANDLE_VALUE)
                break;

        if((Error = GetLastError()) !=  ERROR_FILE_EXISTS)
        {
                TraceFunctLeaveEx((LPARAM)this);
                return(INVALID_HANDLE_VALUE);
        }

    } while( (FileHandle == INVALID_HANDLE_VALUE) && !GetParentInst()->IsShuttingDown());

    return FileHandle;
}

///////////////////////////////////////////////////////////////////////////
/*++

    Name :
        CopyMailToDropDir()

    Description:

        This function copies a spooled file to the drop directory
        The drop file will be of the same name as the spooled file.
        This funciton translates the sender and recipient informaiton
        from the mail envelope into x-headers in the drop file.
        Both the message file and the stream file are assumed to be 
        opened upstream.

    Arguments:

        PMAIL_ENTRY lpMailEntry - Queue entry of the spooled file

    Returns:
      
      TRUE if the message was written successfully to the drop dir.
      FALSE in all other cases.  

--*/
BOOL REMOTE_QUEUE::CopyMailToDropDir(ISMTPConnection    *pISMTPConnection, const char * DropDirectory)
{
    DWORD           dwError = NO_ERROR;
    DWORD           dwBytesWritten = 0;
    DWORD           NumRcpts = 0;
    HANDLE          hDrop   = INVALID_HANDLE_VALUE;
    PFIO_CONTEXT    hMail   = NULL;
    HRESULT         hr = S_OK;
    PVOID           AdvContext = NULL;
    DWORD          *RcptIndexList = NULL;
    IMailMsgProperties          * pIMsg = NULL;
    IMailMsgBind * pBindInterface = NULL;
    BOOL            fRet = FALSE;
    MessageAck      MsgAck;
    HANDLE          hFileReadEvent = NULL;
    IMailMsgRecipients *pIMsgRecips = NULL;
    char szDropFile[MAX_PATH +1];

    TraceFunctEnterEx(NULL, "CopyMailToDropDir");

    hFileReadEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(hFileReadEvent == INVALID_HANDLE_VALUE)
    {
        ErrorTrace((LPARAM) this, "CreateEvent() failed for FileWriteFileEvent");
        goto ErrorExit;
    }

    while (!GetParentInst()->IsShuttingDown())
    {

        pBindInterface = NULL;
        AdvContext = NULL;
        RcptIndexList = NULL;
        pIMsg = NULL;

        fRet = FALSE;

        hr = pISMTPConnection->GetNextMessage(&pIMsg, (DWORD **)&AdvContext, &NumRcpts, &RcptIndexList);
        if(FAILED(hr))
        {
            fRet = TRUE;
            break;
        }

        if( NumRcpts == 0 )
        {
            fRet = TRUE;
            goto ErrorExit;
        }

        hr = pIMsg->QueryInterface( IID_IMailMsgRecipients, (PVOID *) &pIMsgRecips);
        if( FAILED( hr ) )
        {
            goto ErrorExit;
        }

        if( CheckIfAllRcptsHandled( pIMsgRecips, RcptIndexList, NumRcpts ) )
        {
            fRet = TRUE;
            goto ErrorExit;
        }
            

        hr = pIMsg->QueryInterface(IID_IMailMsgBind, (void **)&pBindInterface);
        if(FAILED(hr))
        {
            goto ErrorExit;
        }

        hr = pBindInterface->GetBinding(&hMail, NULL);
        if(FAILED(hr))
        {
            goto ErrorExit;
        }

        DebugTrace((LPARAM)NULL, "Dropping file to: %s", DropDirectory);

        hDrop = CreateDropFile(DropDirectory, szDropFile);
        if (hDrop == INVALID_HANDLE_VALUE)
        {
            dwError = GetLastError();
            ErrorTrace(NULL, "Unable to create drop directory (%s) : %u", 
                    DropDirectory,
                    dwError);
            SetLastError(dwError);
            goto ErrorExit;
        }

        // Output the x-headers

        if (!CreateXHeaders(pIMsg, pIMsgRecips, NumRcpts, RcptIndexList, hDrop)) {
            dwError = GetLastError();
            ErrorTrace(NULL, "Error %d while creating x-headers", dwError);
            goto ErrorExit;
        }

        ResetEvent(hFileReadEvent);

        // Copy the mail file over
        if (!CopyMessage(hMail, hDrop, hFileReadEvent))
        {
            dwError = GetLastError();
            ErrorTrace(NULL, "Unable to copy mail file into drop directory : %u", 
                    dwError);
            goto ErrorExit;
        }


        if( FAILED( hr = SetAllRcptsHandled( pIMsgRecips, RcptIndexList, NumRcpts ) ) )
        {
            goto ErrorExit;
        }

        fRet = TRUE;

ErrorExit:

        if( pIMsgRecips )
        {
            pIMsgRecips->Release();
            pIMsgRecips = NULL;
        }
        if(pBindInterface)
        {
            pBindInterface->ReleaseContext();
            pBindInterface->Release();
            pBindInterface = NULL;
        }

        MsgAck.pIMailMsgProperties = pIMsg;
        MsgAck.pvMsgContext = (DWORD *) AdvContext;

        if(fRet)
        {
            MsgAck.dwMsgStatus = MESSAGE_STATUS_ALL_DELIVERED;
        }
        else
        {
            MsgAck.dwMsgStatus = MESSAGE_STATUS_RETRY_ALL;      
        }

        MsgAck.dwStatusCode = 0;
        pISMTPConnection->AckMessage(&MsgAck);
        pIMsg->Release();
        pIMsg = NULL;

        if(hDrop != INVALID_HANDLE_VALUE)
        {
            _VERIFY(CloseHandle(hDrop));
            hDrop = INVALID_HANDLE_VALUE;
        }

        if(fRet)
            BUMP_COUNTER(GetParentInst(), DirectoryDrops);

    }

    if(fRet)
    {
        pISMTPConnection->AckConnection(CONNECTION_STATUS_OK);
    }
    else
    {
        DeleteFile(szDropFile);
        SetLastError(dwError);
        pISMTPConnection->AckConnection(CONNECTION_STATUS_FAILED);
    }

    if(hFileReadEvent != NULL)
    {
        CloseHandle(hFileReadEvent);
    }

    TraceFunctLeave();
    return(fRet);
}

//////////////////////////////////////////////////////////////////////////////
BOOL REMOTE_QUEUE::CheckIfAllRcptsHandled(
    IMailMsgRecipients *pIMsgRecips,
    DWORD              *RcptIndexList,
    DWORD              NumRcpts )
{
    BOOL fRet = TRUE;
    
    for( DWORD i = 0; i < NumRcpts; i++ )
    {
        if (RcptIndexList[i] != INVALID_RCPT_IDX_VALUE)
        {
            DWORD dwRecipientFlags = 0;
            HRESULT hr = pIMsgRecips->GetDWORD(RcptIndexList[i], IMMPID_RP_RECIPIENT_FLAGS,&dwRecipientFlags);
            if (FAILED(hr))
            {
                fRet = FALSE;
                break;
            }
    
            if( RP_HANDLED != ( dwRecipientFlags & RP_HANDLED ) )
            {
                fRet = FALSE;
                break;
            }
                
        }
    }

    return( fRet );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT REMOTE_QUEUE::SetAllRcptsHandled(
    IMailMsgRecipients *pIMsgRecips,
    DWORD              *RcptIndexList,
    DWORD               NumRcpts )
{
    HRESULT hr = S_OK;
    
    for( DWORD i = 0; i < NumRcpts; i++ )
    {
        if (RcptIndexList[i] != INVALID_RCPT_IDX_VALUE)
        {
            DWORD dwRecipientFlags = 0;
            hr = pIMsgRecips->GetDWORD(RcptIndexList[i], IMMPID_RP_RECIPIENT_FLAGS,&dwRecipientFlags);
            if (FAILED(hr))
            {
                break;
            }
    
            if( RP_HANDLED != ( dwRecipientFlags & RP_HANDLED ) )
            {
                dwRecipientFlags |= RP_DELIVERED;
            
    
                hr = pIMsgRecips->PutDWORD(RcptIndexList[i], IMMPID_RP_RECIPIENT_FLAGS,dwRecipientFlags);
                if (FAILED(hr))
                {
                    break;
                }
            }
                
        }
    }
    return( hr );
}


/*++

    ABSTRACT:

    This function Creates a CDropDir object which is associated with a MailMsg object.
    The job of the CDropDir object is to asynchronously write the Mail to the drop dir.

    Called by 
        ProcessQueueEvents()
        CDropDir::~CDropDir().

--*/

BOOL AsyncCopyMailToDropDir(
                            ISMTPConnection    *pISMTPConnection, 
                            const char * DropDirectory, 
                            SMTP_SERVER_INSTANCE *pParentInst
                            )
{
    PVOID               AdvContext = NULL;
    IMailMsgProperties *pIMsg = NULL;
    DWORD               NumRcpts = 0;
    DWORD              *RcptIndexList = NULL;
    CDropDir           *pDropDir = NULL;
    BOOL                fRet = TRUE;
    HRESULT             hr = S_OK;

    TraceFunctEnterEx(NULL, "newCopyMailToDropDir");

    if (!pParentInst->IsShuttingDown())
    {

        AdvContext = NULL;
        fRet = FALSE;

        hr = pISMTPConnection->GetNextMessage(&pIMsg, (DWORD **)&AdvContext, &NumRcpts, &RcptIndexList);
        if(FAILED(hr))
        {
            fRet = TRUE;
            goto Exit;
        }


        pDropDir = new CDropDir();

        if( NULL == pDropDir )
        {
            fRet = FALSE;
            goto Exit;
        }

        if( FAILED( hr = pDropDir->CopyMailToDropDir( pISMTPConnection,
                                                      DropDirectory,
                                                      pIMsg,
                                                      AdvContext,
                                                      NumRcpts,
                                                      RcptIndexList,
                                                      pParentInst) ) )
        {
            fRet = FALSE;
            goto Exit;
        }

        SAFE_RELEASE(pDropDir);
        SAFE_RELEASE(pIMsg );

        fRet = TRUE;
    }

Exit:
    SAFE_RELEASE(pDropDir);
    SAFE_RELEASE(pIMsg );
    TraceFunctLeave();
    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\queue.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        queue.cxx

   Abstract:
		Implements a queue

   Author:

           Rohan Phillips    ( Rohanp )    11-Dec-1995

   Project:

          SMTP Server DLL

   Functions Exported:


   Revision History:


--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "remoteq.hxx"
#include "timemath.h"

/*++

	Name :
		PERSIST_QUEUE::InitializeQueue

    Description:
	   This function initializes all the class
	   member functions.

    Arguments:
	pszQueueName - Name of the on disk queue
	Flags		 - Queue flags 
	Retry		 - How long we should retry failed deliveries
	FlushQ		 - How often we should flush the queue to disk

    Returns:

	TRUE if all memory allocations and all I/O operations pass
	FALSE otherwise

--*/
BOOL PERSIST_QUEUE::InitializeQueue (void)
{

	TraceFunctEnterEx((LPARAM)this, "PERSIST_QUEUE::InitializeQueue");
  
	// Now, initialize the queue structure:
	m_QData.Entries = 0;
	m_QData.RetryInterval = 0;
	m_QData.StoreInterval = 0;
	m_QData.Flags = 0;
	m_QData.LastStore = (LONGLONG) 0;

	//create the thread that processes things out of the
	//the queue
	DWORD ThreadId;
	DWORD  Loop = 0;

	for (Loop = 0; Loop < m_NumThreads; Loop++)
	{
		m_ThreadHandle[Loop] = CreateThread (NULL, 0, PERSIST_QUEUE::QueueThreadRoutine, this, 0, &ThreadId);
		if (m_ThreadHandle[Loop] == NULL)
		{
			TraceFunctLeaveEx((LPARAM)this);
			return FALSE;
		}
	}

	TraceFunctLeaveEx((LPARAM)this);
	return TRUE;
}
 
/*++

	Name :
		PERSIST_QUEUE::CreateQueue

    Description:
	   This is the static member function that creates the Queue

    Arguments:
	Qtype -	the type of queue to create (i.e Local, Remote, etc.)

    Returns:

	TRUE if all memory allocations and all I/O operaations pass
	FALSE otherwise

--*/
PERSIST_QUEUE * PERSIST_QUEUE::CreateQueue(QUEUE_TYPE Qtype, SMTP_SERVER_INSTANCE * pSmtpInst)
{
    PERSIST_QUEUE * pQueue = NULL;

   _ASSERT (pSmtpInst != NULL);

   if(Qtype == REMOTEQ)
   {
     pQueue = new REMOTE_QUEUE(pSmtpInst);
	 if(pQueue)
	 {
		pQueue->SetNumThreads(pSmtpInst->GetMaxRemoteQThreads());
	 }
	 else
	 {
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return(NULL);
	 }
   }
   else
   {
	   _ASSERT(FALSE);
	   return NULL;
   }

	//initialize the queue
	if(!pQueue->InitializeQueue())
	 {
	    delete pQueue;
		pQueue = NULL;
	 }

	return pQueue;
}


/*++

	Name :
		PERSIST_QUEUE::ProcessQueueEvents

    Description:
	   This is the virtual process function
	   that all derived classes must override
	   This function is different depending on
	   what it is suppose to do.  Take a look
	   at localq.cxx and remoteq.cxx for examples.

    Arguments:

    Returns:
	Always TRUE

--*/
BOOL PERSIST_QUEUE::ProcessQueueEvents(ISMTPConnection    *pISMTPConnection)
{
	return TRUE;
}

/*++

	Name :
		PERSIST_QUEUE::FlushQueueEvents

    Description:
	   This function deletes all entries from the queue

    Arguments:

    Returns:

--*/
void PERSIST_QUEUE::FlushQueueEvents(void)
{
	PLIST_ENTRY  pEntry;
	PQUEUE_ENTRY pQEntry;

  	TraceFunctEnterEx((LPARAM)this, "PERSIST_QUEUE::FlushQueueEvents");

	_ASSERT (GetParentInst() != NULL);

	LockQ();

	//delete all entries from the list
	while(!IsListEmpty (&m_QHead))
	{
		GetParentInst()->StopHint();
		pEntry = RemoveHeadList (&m_QHead);
		pQEntry = CONTAINING_RECORD( pEntry, PERSIST_QUEUE_ENTRY, m_QEntry);
		pQEntry->BeforeDelete();
		delete pQEntry;
	}

	//reset the stop hint
	GetParentInst()->SetStopHint(2);
	UnLockQ();
	TraceFunctLeaveEx((LPARAM)this);
}


/*++

	Name :
		PERSIST_QUEUE::QueueThreadRoutine

    Description:
	   This function is the static member
	   function that gets passed to CreateThread
	   to initialize the queue.

    Arguments:
		A pointer to a PERSIST_QUEUE

    Returns:

--*/
DWORD WINAPI PERSIST_QUEUE::QueueThreadRoutine(void * ThisPtr)
{
  PQUEUE QueuePtr = (PQUEUE) ThisPtr;
  HRESULT hr = S_OK;
  ISMTPConnection    *pISMTPConnection = NULL;

  TraceFunctEnterEx((LPARAM)QueuePtr, "PERSIST_QUEUE::QueueThreadRoutine");

  while(TRUE)
  {
	  pISMTPConnection = NULL;
	  hr = QueuePtr->GetParentInst()->GetConnManPtr()->GetNextConnection(&pISMTPConnection);
	  if(!FAILED(hr))
	  {
		//call the virtual process function
		QueuePtr->ProcessQueueEvents(pISMTPConnection);
		 
		 //if we are shutting down, break out of the loop
		 if (QueuePtr->GetParentInst()->IsShuttingDown())
			 goto Out;
	  }
	  else
	  {
		 //if we are shutting down, break out of the loop
		 if (QueuePtr->GetParentInst()->IsShuttingDown())
			 goto Out;
	  }
  }

Out:

  TraceFunctLeaveEx((LPARAM)QueuePtr);
  return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\rpcmain.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    main.cxx

        Library initialization for infocomm.dll  --
           Internet Information Services Common dll.

    FILE HISTORY:
        Johnl       06-Oct-1994 Created.
*/

#ifndef dllexp
#define dllexp __declspec( dllexport )
#endif

//
//  System include files.
//
#include "smtpinc.h"

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock2.h>
#include <lm.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

//#include "dbgutil.h"

//
//  Project include files.
//

//#include <inetcom.h>
//#include <inetamsg.h>
//#include <tcpproc.h>

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

//#include <svcloc.h>
//#define SECURITY_WIN32
//#include <sspi.h>           // Security Support Provider APIs
//#include <schnlsp.h>
//#include <lonsi.hxx>
//#include "globals.hxx"

#include <isrpc.hxx>

PISRPC		g_pIsrpc = NULL;
HINSTANCE	g_hDll = NULL;
PISRPC		sm_isrpc = NULL;

BOOL
InitializeSmtpServiceRpc(
				IN LPCSTR        pszServiceName,
                IN RPC_IF_HANDLE hRpcInterface
                );

BOOL CleanupSmtpServiceRpc(
                 VOID
                 );

#if 0
extern "C"
BOOL WINAPI DLLEntry( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    BOOL  fReturn = TRUE;

    switch ( dwReason )
    {
		case DLL_PROCESS_ATTACH:  

			g_hDll = hDll;
			break;

		case DLL_PROCESS_DETACH:
			break;

		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		default:
			break ;
    }

    return ( fReturn);

}  // main()

BOOL WINAPI DllMain (HANDLE hInst, ULONG dwReason, LPVOID lpvReserve)
{
  return DLLEntry((HINSTANCE) hInst, dwReason, lpvReserve);
}
#endif

#if 0
BOOL
InitDlls(
    VOID
    )
/*++
    Description:

        DLL Init and uninit functions that don't have to worry about the
        peb lock being taken during PROCESS_ATTACH/DETACH.

--*/
{
    BOOL fReturn = TRUE;

    if ( !InitializeServiceRpc(
                             NNTP_TEST_SERVICE_NAME,
                             nntptest_ServerIfHandle
                             ) )
    {
        fReturn = FALSE;

    }

    return fReturn;
}

BOOL
TerminateDlls(
    VOID
    )
{
    CleanupSmtpServiceRpc( );

    return TRUE;
}
#endif

BOOL
InitializeSmtpServiceRpc(
				IN LPCSTR        pszServiceName,
                IN RPC_IF_HANDLE hRpcInterface
                )
/*++
    Description:

        Initializes the rpc endpoint for the infocomm service.

    Arguments:
        pszServiceName - pointer to null-terminated string containing the name
          of the service.

        hRpcInterface - Handle for RPC interface.

    Returns:
        Win32 Error Code.

--*/
{

    DWORD dwError = NO_ERROR;
    PISRPC  pIsrpc;

    //DBG_ASSERT( pszServiceName != NULL);
    //DBG_ASSERT( sm_isrpc == NULL );

    pIsrpc = new ISRPC( pszServiceName);

    if ( pIsrpc == NULL) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    //  bind over Named pipe only.
    //  If needed to bind over TCP, bind with bit flag ISRPC_OVER_TCPIP on.
    //

    dwError = pIsrpc->AddProtocol( ISRPC_OVER_TCPIP
                                  | ISRPC_OVER_NP | ISRPC_OVER_LPC
                                  );

    if( (dwError == RPC_S_DUPLICATE_ENDPOINT) ||
       (dwError == RPC_S_OK)
       ) {

        dwError = pIsrpc->RegisterInterface(hRpcInterface);
    }

    if ( dwError != RPC_S_OK ) {
        goto exit;
    }

    //
    //  Start the RPC listen thread
    //
#if 0
    dwError = pIsrpc->StartServer( );
#endif

exit:

    if ( dwError != NO_ERROR ) {
        //DBGPRINTF(( DBG_CONTEXT,
        //           "Cannot start RPC Server for %s, error %lu\n",
        //           pszServiceName, dwError ));

        delete pIsrpc;
        SetLastError(dwError);
        return(FALSE);
    }

    sm_isrpc = pIsrpc;
    return(TRUE);

} // IIS_SERVICE::InitializeServiceRpc


BOOL CleanupSmtpServiceRpc(
                       VOID
                       )
/*++
    Description:

        Cleanup the data stored and services running.
        This function should be called only after freeing all the
         services running using this DLL.
        This function is called typically when the DLL is unloaded.

    Arguments:
        pszServiceName - pointer to null-terminated string containing the name
          of the service.

        hRpcInterface - Handle for RPC interface.


    Returns:
        Win32 Error Code.

--*/
{
    DWORD dwError = NO_ERROR;

    if ( sm_isrpc == NULL ) {
        //DBGPRINTF((DBG_CONTEXT,
        //    "no isrpc object to cleanup. Returning success\n"));
        return(TRUE);
    }

    //(VOID) sm_isrpc->StopServer( );
   // dwError = sm_isrpc->CleanupData();

   sm_isrpc->UnRegisterInterface();
   // if( dwError != RPC_S_OK ) {
        //DBGPRINTF(( DBG_CONTEXT,
        //           "ISRPC(%08x) Cleanup returns %lu\n", sm_isrpc, dwError ));
        //DBG_ASSERT( !"RpcServerUnregisterIf failure" );
      //  SetLastError( dwError);
    //}

    delete sm_isrpc;
    sm_isrpc = NULL;

    return TRUE;
} // CleanupSmtpServiceRpc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\shash.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       shash.cxx

   Abstract:

       This file contains type definitions hash table support

   Author:


   Revision History:

  		Rohan Phillips   (RohanP)		MARCH-08-1997 - modified for SMTP

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"

#include "shash.hxx"

CSMTP_HASH_TABLE::~CSMTP_HASH_TABLE()
{
	TraceFunctEnterEx((LPARAM)this, "CSMTP_HASH_TABLE::~CSMTP_HASH_TABLE");

	RemoveAllEntries();

	TraceFunctLeaveEx((LPARAM)this);
}

void CSMTP_HASH_TABLE::RemoveThisEntry(CHASH_ENTRY * pHashEntry, DWORD BucketNum)
{
	TraceFunctEnterEx((LPARAM)this, "CSMTP_HASH_TABLE::RemoveThisEntry");

	DebugTrace((LPARAM)this, "removing %s from hash table", pHashEntry->GetData());
	m_HashTable[BucketNum].m_Lock.ExclusiveLock();
	RemoveEntryList(&pHashEntry->QueryListEntry());
	m_HashTable[BucketNum].m_Lock.ExclusiveUnlock();

	TraceFunctLeaveEx((LPARAM)this);
}

void CSMTP_HASH_TABLE::RemoveAllEntries(void)
{
	DWORD LoopVar = 0;
	PLIST_ENTRY	HeadOfList = NULL;
	PLIST_ENTRY  pEntry = NULL;
	CHASH_ENTRY * pHashEntry = NULL;

	TraceFunctEnterEx((LPARAM)this, "CSMTP_HASH_TABLE::RemoveAllEntries");

	//say we don't have any wildcard entries anymore
	m_fWildCard = FALSE;

	for (LoopVar = 0; LoopVar < TABLE_SIZE; LoopVar++)
	{
		m_HashTable[LoopVar].m_Lock.ExclusiveLock();
		HeadOfList = &m_HashTable[LoopVar].m_ListHead;
		while (!IsListEmpty(HeadOfList))
		{
			//remove the entries from the list
			pEntry = RemoveHeadList (HeadOfList);
			pHashEntry = CONTAINING_RECORD(pEntry, CHASH_ENTRY, m_ListEntry);

			//clear inlist flag
			pHashEntry->ClearInList();

			DebugTrace((LPARAM)this, "removing %s from hash table. RefCnt = %d", pHashEntry->GetData(),  pHashEntry->QueryRefCount());

			//decrement the ref count.  If it hits 0, then the
			//entry will be deleted.  Else, it means some other
			//thread has a refernce to it and that thread will
			//delete the object when the ref count hits 0.
			pHashEntry->DecRefCount();

			//decrement entry counts
			m_HashTable[LoopVar].m_NumEntries--;
			InterlockedIncrement(&(m_HashTable[LoopVar].m_RefNum));
			InterlockedDecrement(&m_TotalEntries);
		}
		m_HashTable[LoopVar].m_Lock.ExclusiveUnlock();

	}

	TraceFunctLeaveEx((LPARAM)this);
}

void CSMTP_HASH_TABLE::PrintAllEntries(void)
{
	DWORD LoopVar = 0;
	PLIST_ENTRY	HeadOfList = NULL;
	PLIST_ENTRY  pEntry = NULL;
	PLIST_ENTRY  pentryNext = NULL;
	CHASH_ENTRY * pHashEntry = NULL;

	for (LoopVar = 0; LoopVar < TABLE_SIZE; LoopVar++)
	{
		m_HashTable[LoopVar].m_Lock.ExclusiveLock();

		HeadOfList = &m_HashTable[LoopVar].m_ListHead;
		pEntry = m_HashTable[LoopVar].m_ListHead.Flink;
		for(; pEntry != HeadOfList; pEntry = pentryNext)
		{
			pentryNext = pEntry->Flink;
			pHashEntry = CONTAINING_RECORD(pEntry, CHASH_ENTRY, m_ListEntry);
			printf("%s i n bucket %d\n", pHashEntry->GetData(), LoopVar);
		}

		m_HashTable[LoopVar].m_Lock.ExclusiveUnlock();
	}
}


BOOL CSMTP_HASH_TABLE::InsertIntoTable(CHASH_ENTRY * pHashEntry)
{
	unsigned int HashValue = 0;
	char * NewData = NULL;
	char * ExistingData = NULL;
	PLIST_ENTRY	HeadOfList = NULL;
	PLIST_ENTRY ListEntry =NULL;
	CHASH_ENTRY * pExistingEntry = NULL;
	int Result = 0;

	TraceFunctEnterEx((LPARAM)this, "CSMTP_HASH_TABLE::InsertIntoTable");

	_ASSERT(pHashEntry != NULL);

	if(pHashEntry == NULL)
	{
		TraceFunctLeaveEx((LPARAM)this);
		return FALSE;
	}

	//get the new data
	NewData = pHashEntry->GetData();

	_ASSERT(NewData != NULL);

	if(NewData == NULL)
	{
		TraceFunctLeaveEx((LPARAM)this);
		return FALSE;
	}

	//get the hash value
	HashValue = HashFunction (NewData);

	//lock the list exclusively
	m_HashTable[HashValue].m_Lock.ExclusiveLock();

	//insert the head of the list for this bucket
	//duplicates are not allowed
	HeadOfList = &m_HashTable[HashValue].m_ListHead;

	for (ListEntry = HeadOfList->Flink; ListEntry != HeadOfList;
		ListEntry = ListEntry->Flink)
	{
		pExistingEntry = CONTAINING_RECORD(ListEntry, CHASH_ENTRY, m_ListEntry);
		ExistingData = pExistingEntry->GetData();

		Result = lstrcmpi(NewData, ExistingData);
		if(Result < 0)
		{
			break;
		}
		else if(Result == 0)
		{
			ErrorTrace((LPARAM)this, "%s is already in hash table - returning FALSE", pHashEntry->GetData());

			if(!m_fDupesAllowed)
			{
				//duplicates are not allowed
				m_HashTable[HashValue].m_Lock.ExclusiveUnlock();
				SetLastError(ERROR_DUP_NAME);
				TraceFunctLeaveEx((LPARAM)this);
				return FALSE;
			}
			else
			{
				//duplicates are allowed
				break;
			}
		}
	}

	// Ok, insert here.

	//inc the ref count
	pHashEntry->IncRefCount();

	// QFE 123862 MarkH: insert before this item
	InsertTailList(ListEntry, &pHashEntry->QueryListEntry());

	//set inlist flag
	pHashEntry->SetInList();

	//update total entries in this bucket
	m_HashTable[HashValue].m_NumEntries++;

	DebugTrace((LPARAM)this, "inserted %s into hash table. RefCnt = %d", pHashEntry->GetData(), pHashEntry->QueryRefCount());

	//update numentries in this bucket
	InterlockedIncrement(&m_TotalEntries);

	//unlock this bucket
	m_HashTable[HashValue].m_Lock.ExclusiveUnlock();

	TraceFunctLeaveEx((LPARAM)this);
	return TRUE;
}

BOOL CSMTP_HASH_TABLE::InsertIntoTableEx(CHASH_ENTRY * pHashEntry, char * szDefaultDomain)
{
    return(CSMTP_HASH_TABLE::InsertIntoTable(pHashEntry));
}

BOOL CSMTP_HASH_TABLE::RemoveFromTable(const char * SearchData)
{
	unsigned int HashValue;
	char * ExistingData = NULL;
	PLIST_ENTRY	HeadOfList;
	PLIST_ENTRY ListEntry;
	CHASH_ENTRY * pExistingEntry;
	int Result = 0;

	TraceFunctEnterEx((LPARAM)this, "CSMTP_HASH_TABLE::RemoveFromTable");

	_ASSERT(SearchData != NULL);

	if(SearchData == NULL)
	{
		return FALSE;
	}

	CharLowerBuff((char *)SearchData, lstrlen(SearchData));

	//get the hash value
	HashValue = HashFunction (SearchData);

	m_HashTable[HashValue].m_Lock.ExclusiveLock();

	HeadOfList = &m_HashTable[HashValue].m_ListHead;

	for (ListEntry = HeadOfList->Flink; ListEntry != HeadOfList;
		ListEntry = ListEntry->Flink)
	{
		pExistingEntry = CONTAINING_RECORD(ListEntry, CHASH_ENTRY, m_ListEntry);
		ExistingData = pExistingEntry->GetData();

		Result = lstrcmpi(ExistingData, SearchData);
		if(Result == 0)
		{
			DebugTrace((LPARAM)this, "Removing %s from hash table", ExistingData);

			//found it
			RemoveEntryList(ListEntry);
			m_HashTable[HashValue].m_NumEntries--;
			InterlockedIncrement(&(m_HashTable[HashValue].m_RefNum));

			//clear inlist flag
			pExistingEntry->ClearInList();

			pExistingEntry->DecRefCount();

			InterlockedDecrement(&m_TotalEntries);

			m_HashTable[HashValue].m_Lock.ExclusiveUnlock();

			TraceFunctLeaveEx((LPARAM)this);
			return TRUE;
		}
	}

	//duplicates are not allowed
	SetLastError(ERROR_PATH_NOT_FOUND);
	m_HashTable[HashValue].m_Lock.ExclusiveUnlock();
	TraceFunctLeaveEx((LPARAM)this);
	return FALSE;
}

BOOL CSMTP_HASH_TABLE::RemoveFromTableNoDecRef(const char * SearchData)
{
	unsigned int HashValue;
	char * ExistingData = NULL;
	PLIST_ENTRY	HeadOfList;
	PLIST_ENTRY ListEntry;
	CHASH_ENTRY * pExistingEntry;
	int Result = 0;

	TraceFunctEnterEx((LPARAM)this, "CSMTP_HASH_TABLE::RemoveFromTableNoDecRef");

	_ASSERT(SearchData != NULL);

	if(SearchData == NULL)
	{
		return FALSE;
	}

	CharLowerBuff((char *)SearchData, lstrlen(SearchData));

	//get the hash value
	HashValue = HashFunction (SearchData);

	m_HashTable[HashValue].m_Lock.ExclusiveLock();

	HeadOfList = &m_HashTable[HashValue].m_ListHead;

	for (ListEntry = HeadOfList->Flink; ListEntry != HeadOfList;
		ListEntry = ListEntry->Flink)
	{
		pExistingEntry = CONTAINING_RECORD(ListEntry, CHASH_ENTRY, m_ListEntry);
		ExistingData = pExistingEntry->GetData();

		Result = lstrcmpi(ExistingData, SearchData);
		if(Result == 0)
		{
			DebugTrace((LPARAM)this, "Removing %s from hash table", ExistingData);

			//found it
			RemoveEntryList(ListEntry);
			m_HashTable[HashValue].m_NumEntries--;
			InterlockedIncrement(&(m_HashTable[HashValue].m_RefNum));
			m_HashTable[HashValue].m_Lock.ExclusiveUnlock();
			InterlockedDecrement(&m_TotalEntries);
			TraceFunctLeaveEx((LPARAM)this);
			return TRUE;
		}
	}

	//duplicates are not allowed
	SetLastError(ERROR_PATH_NOT_FOUND);
	m_HashTable[HashValue].m_Lock.ExclusiveUnlock();
	TraceFunctLeaveEx((LPARAM)this);
	return FALSE;
}


CHASH_ENTRY * CSMTP_HASH_TABLE::FindHashData(const char * SearchData, BOOL fUseShareLock, MULTISZ*  pmsz)
{
	unsigned int HashValue;
	char * ExistingData = NULL;
	PLIST_ENTRY	HeadOfList;
	PLIST_ENTRY ListEntry;
	CHASH_ENTRY * pExistingEntry;
	int Result = 0;

	TraceFunctEnterEx((LPARAM)this, "CSMTP_HASH_TABLE::FindHashData");

	CharLowerBuff((char *)SearchData, lstrlen(SearchData));

	//get the hash value
	HashValue = HashFunction (SearchData);

	if(fUseShareLock)
		m_HashTable[HashValue].m_Lock.ShareLock();
	else
		m_HashTable[HashValue].m_Lock.ExclusiveLock();

	//start search at the head of the list for this bucket
	HeadOfList = &m_HashTable[HashValue].m_ListHead;

	for (ListEntry = HeadOfList->Flink; ListEntry != HeadOfList;
		ListEntry = ListEntry->Flink)
	{
		pExistingEntry = CONTAINING_RECORD(ListEntry, CHASH_ENTRY, m_ListEntry);
		ExistingData = pExistingEntry->GetData();

		Result = lstrcmpi(SearchData, ExistingData);
		// QFE 123862 MarkH: List is ascending
		if(Result < 0)
		{
			break;
		}
		else if(Result == 0)
		{
			//found it
			pExistingEntry->IncRefCount();
			InterlockedIncrement((LPLONG)&m_CacheHits);

			DebugTrace((LPARAM)this, "found %s in hash table", SearchData);

			if(!pmsz)
			{
				if(fUseShareLock)
					m_HashTable[HashValue].m_Lock.ShareUnlock();
				else
					m_HashTable[HashValue].m_Lock.ExclusiveUnlock();

				TraceFunctLeaveEx((LPARAM)this);
				return pExistingEntry;
			}
			else
			{
				MultiszFunction(pExistingEntry, pmsz);
				pExistingEntry->DecRefCount();
				continue;
			}
		}
	}

	DebugTrace((LPARAM)this, "%s was not found in hash table", SearchData);

	if(fUseShareLock)
		m_HashTable[HashValue].m_Lock.ShareUnlock();
	else
		m_HashTable[HashValue].m_Lock.ExclusiveUnlock();

	InterlockedIncrement((LPLONG)&m_CacheMisses);
	SetLastError(ERROR_PATH_NOT_FOUND);
	TraceFunctLeaveEx((LPARAM)this);
	return NULL;
}

CHASH_ENTRY * CSMTP_HASH_TABLE::UnSafeFindHashData(const char * SearchData)
{
	unsigned int HashValue;
	char * ExistingData = NULL;
	PLIST_ENTRY	HeadOfList;
	PLIST_ENTRY ListEntry;
	CHASH_ENTRY * pExistingEntry;
	int Result = 0;

	//get the hash value
	HashValue = HashFunction (SearchData);

	//insert the head of the list for this bucket
	//duplicates are not allowed
	HeadOfList = &m_HashTable[HashValue].m_ListHead;

	for (ListEntry = HeadOfList->Flink; ListEntry != HeadOfList;
		ListEntry = ListEntry->Flink)
	{
		pExistingEntry = CONTAINING_RECORD(ListEntry, CHASH_ENTRY, m_ListEntry);
		ExistingData = pExistingEntry->GetData();

		Result = lstrcmpi(SearchData, ExistingData);
		if(Result < 0)
		{
			break;
		}
		else if(Result == 0)
		{
			//found it
			m_HashTable[HashValue].m_Lock.ShareUnlock();
			return pExistingEntry;
		}
	}

	//duplicates are not allowed
	SetLastError(ERROR_PATH_NOT_FOUND);
	return NULL;
}


CHASH_ENTRY * CSMTP_HASH_TABLE::WildCardFindHashData(const char * DomainName)
{
	CHASH_ENTRY * pHashEntry = NULL;
	char * SearchPtr = NULL;

	TraceFunctEnterEx((LPARAM)this, "CSMTP_HASH_TABLE::WildCardFindHashData");

	//perform the first level hash
	pHashEntry = FindHashData(DomainName, TRUE);

	if(pHashEntry != NULL)
	{
		TraceFunctLeaveEx((LPARAM)this);
		return pHashEntry;
	}
	else if(!m_fWildCard)
	{
		//if no wildcards are in the table,
		//just return NULL.  Else, perform
		//the multilevel hash
		TraceFunctLeaveEx((LPARAM)this);
		return NULL;
	}

	//try to find all sub-domains
	SearchPtr = strchr(DomainName, '.');
	while(SearchPtr)
	{
		//skip past '.'
		SearchPtr += 1;

		//hash this portion of the domain name
		pHashEntry = FindHashData(SearchPtr);
		if((pHashEntry != NULL) && (pHashEntry->IsWildCard()))
		{
			TraceFunctLeaveEx((LPARAM)this);
			return pHashEntry;
		}
		else if(pHashEntry)
		{
			pHashEntry->DecRefCount();
		}

		SearchPtr = strchr(SearchPtr, '.');
	}

	//didn't find it.
	TraceFunctLeaveEx((LPARAM)this);
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\smtpdata.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    smtpdata.h

Abstract:

    This module contains declarations for globals.

Author:

    Johnson Apacible (JohnsonA)     26-Sept-1995

Revision History:

--*/

#ifndef _SMTPDATA_
#define _SMTPDATA_

//
// tracing
//

#define INIT_TRACE              InitAsyncTrace( )
#define TERM_TRACE              TermAsyncTrace( )
#define ENTER( _x_ )            TraceFunctEnter( _x_ );
#define LEAVE                   TraceFunctLeave( );


#define SMTP_UNRECOG_COMMAND_CODE	500
#define SMTP_SYNTAX_ERROR_CODE		501
#define SMTP_NOT_IMPLEMENTED_CODE	502    
#define SMTP_BAD_SEQUENCE_CODE		503
#define SMTP_PARAM_NOT_IMPLEMENTED_CODE	504

#define SMTP_SYS_STATUS_CODE		211
#define SMTP_SERVICE_CLOSE_CODE		221
#define SMTP_SERVICE_READY_CODE		220
#define	SMTP_OK_CODE				250
#define	SMTP_USER_NOT_LOCAL_CODE	251
#define	SMTP_MBOX_BUSY_CODE			450
#define	SMTP_MBOX_NOTFOUND_CODE		550
#define	SMTP_ERROR_PROCESSING_CODE	451
#define	SMTP_USERNOTLOCAL_CODE		551
#define	SMTP_INSUFF_STORAGE_CODE	452
#define	SMTP_ACTION_ABORTED_CODE	552
#define	SMTP_ACTION_NOT_TAKEN_CODE 	553
#define	SMTP_START_MAIL_CODE		354
#define	SMTP_TRANSACT_FAILED_CODE 	554
	
#define	SMTP_SERVICE_UNAVAILABLE_CODE 421	
#define SMTP_COMPLETE_FAILURE_DWORD	5

enum RCPTYPE{LOCAL_NAME, REMOTE_NAME, ALIAS_NAME};

#define NORMAL_RCPT	(char)'R'
#define ERROR_RCPT	(char)'E'
//
// use the current command for transaction logging
//
#define USE_CURRENT         0xFFFFFFFF

static const char * LOCAL_TRANSCRIPT	= "ltr";
static const char * REMOTE_TRANSCRIPT	= "rtr";
static const char * ALIAS_EXT			= "dl";

#define ISNULLADDRESS(Address) ((Address[0] == '<') && (Address[1] == '>'))

typedef char RCPT_TYPE;


//
// Statistics
//

extern SMTP_STATISTICS_0 g_SmtpStat;
extern SMTPCONFIG * g_SmtpConfig;
extern TIME_ZONE_INFORMATION   tzInfo;
extern PERSIST_QUEUE * g_LocalQ;
extern PERSIST_QUEUE * g_RemoteQ;
extern BOOL g_IsShuttingDown;
extern BOOL g_QIsShuttingDown;
extern BOOL g_RetryQIsShuttingDown;

#define INITIALIZE_INBOUNDPOOL  0x00000001
#define INITIALIZE_OUTBOUNDPOOL 0x00000002
#define INITIALIZE_ADDRESSPOOL  0x00000004
#define INITIALIZE_MAILOBJPOOL  0x00000008
#define INITIALIZE_CBUFFERPOOL  0x00000010
#define INITIALIZE_CIOBUFFPOOL  0x00000020

extern  DWORD g_SmtpInitializeStatus;

 
#define	BUMP_COUNTER(counter) \
						InterlockedIncrement((LPLONG) &(g_SmtpStat. counter))

#define	DROP_COUNTER(counter) \
						InterlockedDecrement((LPLONG) &(g_SmtpStat. counter))

#define	ADD_COUNTER(counter, value)	\
		INTERLOCKED_ADD_CHEAP(&(g_SmtpStat. counter), value)

#define	ADD_BIGCOUNTER(counter, value) \
		INTERLOCKED_BIGADD_CHEAP(&(g_SmtpStat. counter), value)

/*++

		Returns a UniqueFilename for an e-mail message.
		The caller should loop through this call and a call to
		CreateFile with the CREATE_NEW flag. If the Create fails due
		to YYY, then the caller should loop again.

	Arguments:

		psz	- a buffer
		pdw	- IN the size of the buffer,
			  OUT: the size of the buffer needed (error == ERROR_MORE_DATA)
			  	   or the size of the filename.

	Returns:
	
		TRUE on SUCCESS
		FALSE if buffer isn't big enough.

--*/
BOOL	GetUniqueFilename(
	IN OUT	LPTSTR	psz,
	IN OUT	LPDWORD	pdw
	);

#endif // _SMTPDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\smtpinc.h ===
#ifndef	_SMTPINC_H_
#define	_SMTPINC_H_

#define  INCL_INETSRV_INCS
#include <atq.h>
#include <pudebug.h>
#include <inetcom.h>
#include <inetinfo.h>
#include <tcpdll.hxx>
#include <tsunami.hxx>

#include <tchar.h>
#include <iistypes.hxx>
#include <iisendp.hxx>
#include <metacach.hxx>

extern "C" {
#include <rpc.h>
#define SECURITY_WIN32
#include <wincrypt.h>
#include <sspi.h>
#include <spseal.h>
#include <issperr.h>
#include <ntlmsp.h>
}

#include <tcpproc.h>
#include <tcpcons.h>
#include <rdns.hxx>
#include <simauth2.h>

#include <smtpinet.h>
#include <stdio.h>
#include <stdlib.h>

#include <abtype.h>
#include <abook.h>
#include <string.h>
#include <time.h>
#include <lmcons.h>

#include <dbgtrace.h>
#include <cpool.h>
#include <address.hxx>
#include <ims.h>
#include <envdef.h>

#include <propstr.h>
#include <mailmsgprops.h>
#include <smtpevents.h>

/*
#define _ATL_NO_DEBUG_CRT
#define _ATL_STATIC_REGISTRY
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL
*/

#include "filehc.h"
#include "mailmsgi.h"
#include "aqueue.h"

//
// common headers from pop3/inc
//
#include <smtptype.h>
#include <smtps.h>
#include <smtpapi.h>

#include <listmacr.h>
#include <rwnew.h>

//
// local header files
//
#ifdef BUILDING_SMTP_DEBUG_EXTENTIONS
//Debugger extensions need access to private/protected members to 
//calculate their memory offsets
#define private public
#define protected public
#endif //BUILDING_SMTP_DEBUG_EXTENTIONS

#include "stats.hxx"
#include "smtpmsg.h"
#include "queue.hxx"
#include "evntwrap.h"
#include "globals.h"
#include "smtpinst.hxx"
#include "errorlog.hxx"
#include "smtpproc.h"


#ifdef UNICODE
#define	TSTRCPY	wcscpy
#define	TSTRCAT	wcscat
#define	TSTRLEN	wcslen
#else
#define	TSTRCPY	lstrcpy
#define	TSTRCAT	lstrcat
#define	TSTRLEN	lstrlen
#endif
typedef TCHAR	*PTCHAR;

#endif	// _SMTPINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\smtpdef.h ===
/*    Definitions for the SMTP commands

    SMTP commands can be added, and deleted by editing the header file
    smtpdef.h.  This header file should never be touched.  Smtpdef.h
    has a table describing every command the smtp serversupports.
    For instance, a few entries in this file contains :

SmtpDef(NEWSMTPCOMMAND1)
SmtpDef(NEWSMTPCOMMAND2)
SmtpDef(NEWSMTPCOMMAND3)
SmtpDef(NEWSMTPCOMMAND4)
SmtpDef(NEWSMTPCOMMANDETC)


    Other source files include atmdef.h, *AFTER* defining the AtmDef macro to extract only
    the value needed.  For instance, below we need an enumeration of all the counters (ATMCOUNTERS).
    Therefore, before including atmdef.h, we make a macro to extract the first element of
    the array :#define SmtpDef(a) a,.  Notice the comma at the end of the #define.  It is
    not a mistake.  It needs to be there to separate each element.

    To define an array of SDef, we do the following :
    enum smtpstate =
     {
      #undef SmtpDef
      #define SmtpDef(a) {a},
      #include "smtpdef.h"
      LastCounter
     };

    Notice that we first have to undefine the previous instance of SmtpDef, then make
    a new defination of the macro, which extracts all the element.  Again, notice the
    comma.  It needs to be there to separate each element.  Also, notice how the array
    is terminated.

    The beauty of doing it this way is because, to add or delete a command, only one file
    has to change.  Not two or three.

    I hope all of this makes sense.

    -Rohan

*/


SmtpDef(EHLO)
SmtpDef(HELO)
SmtpDef(RCPT)
SmtpDef(MAIL)
SmtpDef(AUTH)
SmtpDef(DATA)
SmtpDef(STARTTLS)
SmtpDef(TLS)
SmtpDef(QUIT)
SmtpDef(RSET)
SmtpDef(NOOP)
SmtpDef(VRFY)
SmtpDef(ETRN)
SmtpDef(TURN)
SmtpDef(BDAT)
SmtpDef(HELP)
SmtpDef(_EOD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\smtpcli.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        smtpcli.cxx

   Abstract:

        This module defines the functions for derived class of connections
        for Internet Services  ( class SMTP_CONNECTION)

   Author:

           Rohan Phillips    ( Rohanp )    11-Dec-1995

   Project:

          SMTP Server DLL

   Functions Exported:

          SMTP_CONNECTION::~SMTP_CONNECTION()
          BOOL SMTP_CONNECTION::ProcessClient( IN DWORD cbWritten,
                                                  IN DWORD dwCompletionStatus,
                                                  IN BOOL  fIOCompletion)

          BOOL SMTP_CONNECTION::StartupSession( VOID)

   Revision History:


--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
//
// ATL includes
//
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL

//
// SEO includes
//
#include "seo.h"
#include "seolib.h"

#include <memory.h>
#include <issperr.h>
#include "smtpcli.hxx"
#include "headers.hxx"
#include "timeconv.h"
#include "base64.hxx"

#include "smtpout.hxx"
#include <smtpevents.h>
#include <smtpevent.h>
#include <smtpguid.h>



//
// Dispatcher implementation
//
#include "pe_dispi.hxx"

int strcasecmp(char *s1, char *s2);
int strncasecmp(char *s1, char *s2, int n);

#define IMSG_PROGID L"Exchange.IMsg"
#define MAILMSG_PROGID          L"Exchange.MailMsg"

extern CHAR g_VersionString[];

// provide memory for static declared in SMTP_CONNECTION
CPool  SMTP_CONNECTION::Pool(CLIENT_CONNECTION_SIGNATURE_VALID);

static char * HelpText= "214-This server supports the following commands:\r\n"
                        "214 HELO EHLO STARTTLS RCPT DATA RSET MAIL QUIT HELP";

static char * Daynames[7] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

static const char * SMTP_TOO_MANY_RCPTS   = "Too many recipients";
static const char * PasswordParam = "Password:";
static const char * UserParam = "Username:";

static LONG g_NumRoutingThreads = 0;

LONG g_cProcessClientThreads = 0;

// Format strings for "Received:" lines
static const char szFormatReceivedFormatSuccess[] = "Received: from %s ([%s]) by %s%s with Microsoft SMTPSVC(%s);\r\n\t %s, %s\r\n";
static const char szFormatReceivedFormatUnverified[] = "Received: from %s ([%s] unverified) by %s%s with Microsoft SMTPSVC(%s);\r\n\t %s, %s\r\n";
static const char szFormatReceivedFormatFailed[] = "Received: from %s ([%s] RDNS failed) by %s%s with Microsoft SMTPSVC(%s);\r\n\t %s, %s\r\n";

// Search strings to identify our own "Received:" lines (subsections of above lines)
static const char szFormatReceivedServer[] = ") by %s";
static const char szFormatReceivedService[] = " with Microsoft SMTPSVC(";

// Amount of time (FILETIME / 100ns units) we wait if we detect a looping message
#define SMTP_LOOP_DELAY 6000000000 // == 10 minutes

#define SMTP_TIMEOUT 99
#define SMTP_CONTENT_FILE_IO_TIMEOUT 5*60*1000

#define ATQ_LOCATOR (DWORD)'Dd9D'

//ATQ Write file modes
#define BLOCKING 0
#define NONBLOCKING 1

//Trailer byte status
#define CRLF_NEEDED        0
#define CR_SEEN            1
#define CRLF_SEEN          2
#define CR_MISSING         3

#define WHITESPACE " \t\r\n"

/************************************************************
 *    Functions
 ************************************************************/

extern void GenerateMessageId (char * Buffer, DWORD BuffLen);
extern DWORD GetIncreasingMsgId();
extern VOID InternetCompletion(PVOID pvContext, DWORD cbWritten,
                        DWORD dwCompletionStatus, OVERLAPPED * lpo);

/*++

    Name:

    SMTP_CONNECTION::SMTP_CONNECTION

    Constructs a new SMTP connection object for the client
    connection given the client connection socket and socket
    address. This constructor is private.  Only the Static
    member funtion, declared below, can call it.

    Arguments:

      sClient       socket for communicating with client

      psockAddrRemote pointer to address of the remote client
                ( the value should be copied).
      psockAddrLocal  pointer to address for the local card through
                  which the client came in.
      pAtqContext      pointer to ATQ Context used for AcceptEx'ed conn.
      pvInitialRequest pointer to void buffer containing the initial request
      cbInitialData    count of bytes of data read initially.

--*/
SMTP_CONNECTION::SMTP_CONNECTION(
        IN PSMTP_SERVER_INSTANCE pInstance,
        IN SOCKET sClient,
        IN const SOCKADDR_IN *  psockAddrRemote,
        IN const SOCKADDR_IN *  psockAddrLocal /* = NULL */ ,
        IN PATQ_CONTEXT         pAtqContext    /* = NULL */ ,
        IN PVOID                pvInitialRequest/* = NULL*/ ,
        IN DWORD                cbInitialData  /* = 0    */
        )
 : m_encryptCtx(FALSE),
   m_securityCtx(pInstance,
                TCPAUTH_SERVER| TCPAUTH_UUENCODE,
                 ((PSMTP_SERVER_INSTANCE)pInstance)->QueryAuthentication()),
   CLIENT_CONNECTION ( sClient, psockAddrRemote,
                        psockAddrLocal,  pAtqContext,
                        pvInitialRequest, cbInitialData )
{

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::SMTP_CONNECTION");
    DebugTrace( (LPARAM)this, "New connection created");

    _ASSERT(pInstance != NULL);

    //
    // By default, we use the smallish receive buffer inherited from
    // the case CLIENT_CONNECTION object.
    //
    m_precvBuffer = m_recvBuffer;
    m_cbMaxRecvBuffer = sizeof(m_recvBuffer);
    m_pOutputBuffer = m_OutputBuffer;
    m_cbMaxOutputBuffer =  sizeof(m_OutputBuffer);

    m_pIMsg = NULL;
    m_pIMsgRecips = NULL;
    m_szHeloAddr[0] = '\0';
//    m_FromAddr = NULL;
    m_szFromAddress[0] = '\0';
    m_pszArgs = NULL;
    m_pInstance = pInstance;
    m_IMsgHandle = NULL;
    m_pBindInterface = NULL;
    m_cbRecvBufferOffset = 0;
    m_pFileWriteBuffer = NULL;
    m_pFileWriteBuffer = new CBuffer();

    m_HopCount = 0;
    m_LocalHopCount = 0;

    if(!m_pFileWriteBuffer)
    {
        ErrorTrace((LPARAM)this, "Failed to get the write buffer Err : %d",
                      GetLastError());
        _ASSERT(0);
    }
    m_AtqLocator = ATQ_LOCATOR;


    // inbound protocol extension related initializations
    m_fAsyncEventCompletion = FALSE;
    m_fAsyncEOD = FALSE;
    m_fIsPeUnderway = FALSE;
    m_pIEventRouter = NULL;
    m_pCInboundDispatcher = NULL;
    // m_CInboundContext is a data member
    m_fPeBlobReady = FALSE;
    m_pPeBlobCallback = NULL;

    ZeroMemory(&m_FileOverLapped, sizeof(m_FileOverLapped));

    m_FileOverLapped.SeoOverlapped.Overlapped.pfnCompletion = SmtpCompletionFIO;
    m_FileOverLapped.SeoOverlapped.ThisPtr = this;

    m_LineCompletionState = SEEN_NOTHING;
    m_Truncate = FALSE;
    m_BufrWasFull = FALSE;
    m_szUsedAuthKeyword[0] = '\0';
    m_szAuthenticatedUserNameFromSink[0] = '\0';

    //keep track of per instance connection object
    pInstance->IncConnInObjs();

    TraceFunctLeaveEx((LPARAM) this);
}

SMTP_CONNECTION::~SMTP_CONNECTION (void)
{
    PSMTP_SERVER_INSTANCE pInstance = NULL;
    CAddr * pAddress = NULL;
    char *pTempBuffer = NULL;
//    CBuffer * pBuff;

    TraceFunctEnterEx((LPARAM)this, "~SMTP_CONNECTION");

    ReleasImsg(TRUE);

    /*
    pAddress = (CAddr *) InterlockedExchangePointer((PVOID *) &m_FromAddr, (PVOID) NULL);
    if(pAddress != NULL)
    {
        delete pAddress;
    }*/

    pInstance = (PSMTP_SERVER_INSTANCE ) InterlockedExchangePointer((PVOID *) &m_pInstance, (PVOID) NULL);
    if(pInstance != NULL)
    {
        pInstance->DecrementCurrentConnections();
        pInstance->DecConnInObjs();
        pInstance->Dereference();
    }

    pTempBuffer = (char *) InterlockedExchangePointer((PVOID *) &m_precvBuffer, (PVOID) &m_recvBuffer[0]);
    if (pTempBuffer != m_recvBuffer) {
        delete [] pTempBuffer;
    }

    pTempBuffer = (char *) InterlockedExchangePointer((PVOID *) &m_pOutputBuffer, (PVOID) &m_OutputBuffer[0]);
    if (pTempBuffer != m_OutputBuffer) {
        delete [] pTempBuffer;
    }

    if(m_pFileWriteBuffer)
    {
        delete m_pFileWriteBuffer;
    }

    if ( NULL != m_pPeBlobCallback) {
        m_pPeBlobCallback->Release();
    }

    if(m_pCInboundDispatcher)
        m_pCInboundDispatcher->Release();

    DebugTrace( (LPARAM)this, "Connection deleted");
    TraceFunctLeaveEx((LPARAM)this);
}

/*++

    Name :
        SMTP_CONNECTION::InitializeObject

    Description:
       Initializes all member variables and pre-allocates
       a mail context class

    Arguments:


    Returns:

       TRUE if memory can be allocated.
       FALSE if no memory can be allocated
--*/
BOOL SMTP_CONNECTION::InitializeObject (BOOL IsSecureConnection)
{
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::InitializeObject");

    _ASSERT(m_pInstance != NULL);

    StartProcessingTimer();

    m_cbReceived = 0;
    m_cbParsable = 0;
    m_cbTempBDATLen = 0;
    m_OutputBufferSize = 0;
    m_cbCurrentWriteBuffer = 0;
    m_TotalMsgSize = 0;
    m_SessionSize = 0;
    m_cbDotStrippedTotalMsgSize = 0;
    m_ProtocolErrors = 0;
    m_dwUnsuccessfulLogons = 0;
    m_HeaderSize = 0;
    m_cPendingIoCount = 0;
    m_cActiveThreads = 0;
    m_CurrentOffset = 0;
    m_HelloSent = FALSE;
    m_RecvdMailCmd = FALSE;
    m_RecvdAuthCmd = FALSE;
    m_Nooped = FALSE;
    m_TimeToRewriteHeader = TRUE;
    m_RecvdRcptCmd = FALSE;
    m_InHeader = TRUE;
    m_LongBodyLine = FALSE;
    m_fFoundEmbeddedCrlfDotCrlf = FALSE;
    m_fScannedForCrlfDotCrlf = FALSE;
    m_fSeenRFC822FromAddress = FALSE;
    m_fSeenRFC822ToAddress = FALSE;
    m_fSeenRFC822CcAddress = FALSE;
    m_fSeenRFC822BccAddress = FALSE;
    m_fSeenRFC822Subject = FALSE;
    m_fSeenRFC822MsgId = FALSE;
    m_fSeenRFC822SenderAddress = FALSE;
    m_fSeenXPriority = FALSE;
    m_fSeenXOriginalArrivalTime = FALSE;
    m_fSeenContentType = FALSE;
    m_fSetContentType = FALSE;
    m_HeaderFlags = 0;
    m_MailBodyError = NO_ERROR;
    m_State = HELO;
    m_NeedToQuit = FALSE;
    m_pSmtpStats = NULL;
    m_WritingData = FALSE;
    //m_fReverseDnsFailed = FALSE;
    m_DNSLookupRetCode = SUCCESS;
    m_fUseMbsCta = FALSE;
    m_fAuthenticated = FALSE;
    m_fClearText = FALSE;
    m_fDidUserCmd = FALSE;
    m_fAuthAnon = FALSE;
    m_SecurePort = IsSecureConnection;
    m_fNegotiatingSSL = m_SecurePort;
    m_szUserName[0] = '\0';
    m_szUsedAuthKeyword[0] = '\0';
    m_cbRecvBufferOffset = 0;
    m_fPeBlobReady = FALSE;
    if ( NULL != m_pPeBlobCallback) {
        m_pPeBlobCallback->Release();
    }
    m_pPeBlobCallback = NULL;

    m_fIsLastChunk = FALSE;
    m_fIsBinaryMime = FALSE;
    m_fIsChunkComplete = FALSE;
    m_dwTrailerStatus = CRLF_SEEN;
    m_nChunkSize = 0;
    m_nBytesRemainingInChunk = 0;
    m_MailBodyDiagnostic = ERR_NONE;

    m_LineCompletionState = SEEN_NOTHING;
    m_Truncate = FALSE;
    m_BufrWasFull = FALSE;
    m_fBufferFullInBDAT = FALSE;

    m_pInstance->LockGenCrit();

    if(m_pInstance->QueryAuthentication() & INET_INFO_AUTH_ANONYMOUS)
    {
        m_fAuthAnon = TRUE;
    }

    //
    //   Initialize Security Context
    //
    if (!m_securityCtx.SetInstanceAuthPackageNames(
              m_pInstance->GetProviderPackagesCount(),
              m_pInstance->GetProviderNames(),
              m_pInstance->GetProviderPackages()))
     {
              ErrorTrace((LPARAM)this, "SetInstanceAuthPackageNames FAILED <Err=%u>",
                      GetLastError());
              fRet = FALSE;
     }

    //
    // We want to set up the Cleartext authentication package
    // for this connection based on the instance configuration.
    // To enable MBS CTA,
    // MD_SMTP_CLEARTEXT_AUTH_PROVIDER must be set to the package name.
    // To disable it, the md value must be set to "".
    //

    if(fRet)
    {
        m_securityCtx.SetCleartextPackageName(
        m_pInstance->GetCleartextAuthPackage(),
        m_pInstance->GetMembershipBroker());

        if (*m_pInstance->GetCleartextAuthPackage() == '\0' ||
        *m_pInstance->GetMembershipBroker() == '\0')
        {
            m_fUseMbsCta = FALSE;
        }
        else
        {
            m_fUseMbsCta = TRUE;
        }
    }

    //m_EventHandle = CreateEvent(NULL, TRUE, FALSE, NULL);

    m_pInstance->UnLockGenCrit();

  TraceFunctLeaveEx((LPARAM) this);
  return fRet;
}

/*++

    Name :
        SMTP_CONNECTION::CreateSmtpConnection

    Description:
       This is the static member function than is the only
       entity that is allowed to create an SMTP_CONNECTION
       class.  This class cannot be allocated on the stack.

    Arguments:

      sClient       socket for communicating with client

      psockAddrRemote pointer to address of the remote client
                ( the value should be copied).
      psockAddrLocal  pointer to address for the local card through
                  which the client came in.
      pAtqContext      pointer to ATQ Context used for AcceptEx'ed conn.
      pvInitialRequest pointer to void buffer containing the initial request
      cbInitialData    count of bytes of data read initially.


    Returns:

       A pointer to an SMTP_CONNECTION class or NULL
--*/
SMTP_CONNECTION * SMTP_CONNECTION::CreateSmtpConnection (IN PCLIENT_CONN_PARAMS ClientParams,
                                                         IN PSMTP_SERVER_INSTANCE pInst)
{
    SMTP_CONNECTION * pSmtpObj = NULL;
    PIIS_ENDPOINT   pTmpEndPoint = NULL;

    pSmtpObj = new SMTP_CONNECTION (pInst, ClientParams->sClient, (const SOCKADDR_IN *) ClientParams->pAddrRemote, (const SOCKADDR_IN *) ClientParams->pAddrLocal,
                                    ClientParams->pAtqContext, ClientParams->pvInitialBuff, ClientParams->cbInitialBuff);

    if(pSmtpObj == NULL)
     {
       SetLastError (ERROR_NOT_ENOUGH_MEMORY);
       return NULL;
     }

    pTmpEndPoint = (PIIS_ENDPOINT)ClientParams->pEndpoint;

    if(!pSmtpObj->InitializeObject(FALSE))
     {
        delete pSmtpObj;
        return NULL;
     }

    return pSmtpObj;
}


#define MAX_LOG_ERROR_LEN (500)

void SMTP_CONNECTION::TransactionLog(
        const char *pszOperation,
        const char *pszParameters,
        const char *pszTarget,
        DWORD dwWin32Error,
        DWORD dwServiceSpecificStatus
        )
{
    INETLOG_INFORMATION translog;
    DWORD  dwLog;
    DWORD cchError = MAX_LOG_ERROR_LEN;
    char VersionString[] = "SMTP";
    char szParametersBuffer[1024] = "";   //Data portion of buffer information

    ZeroMemory(&translog, sizeof(translog));

    translog.pszVersion = VersionString;
    translog.pszClientHostName = (char *) QueryClientHostName();
    translog.cbClientHostName = lstrlen(translog.pszClientHostName);
    translog.pszClientUserName = (char *) QueryClientUserName();
    translog.pszServerAddress = (char *) QueryLocalHostName();

    translog.pszOperation = (char *)pszOperation;
    translog.cbOperation = lstrlen ((char *)pszOperation);
    translog.pszTarget = (char *)pszTarget;
    translog.cbTarget = lstrlen ((char *)pszTarget);
    translog.pszParameters = (char *)pszParameters;

    if (pszParameters) {
        lstrcpyn(szParametersBuffer, pszParameters, sizeof(szParametersBuffer)-sizeof(CHAR));
        translog.pszParameters = szParametersBuffer;
    } else {
        translog.pszParameters = "";
    }

    translog.dwBytesSent = m_dwCmdBytesSent;
    translog.dwBytesRecvd = m_dwCmdBytesRecv;
    translog.dwWin32Status = dwWin32Error;

    translog.dwProtocolStatus = dwServiceSpecificStatus;
    translog.msTimeForProcessing = QueryProcessingTime();

    if(QuerySmtpInstance() != NULL)
      dwLog = QuerySmtpInstance()->m_Logging.LogInformation( &translog);
}

/*++

    Name :
        SMTP_CONNECTION::SendSmtpResponse

    Description:
       This function sends data that was queued in the internal
       m_pOutputBuffer buffer

    Arguments:
         SyncSend - Flag that signifies sync or async send

    Returns:

      TRUE if the string was sent. False otherwise
--*/
BOOL SMTP_CONNECTION::SendSmtpResponse(BOOL SyncSend)
{
  BOOL RetStatus = TRUE;
  DWORD cbMessage = m_OutputBufferSize;

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::SendSmtpResponse");

  //IncPendingIoCount();

  //if m_OutputBufferSize > 0that means there is
  //something in the buffer, therefore, we will send it.
  if (m_OutputBufferSize)
  {
      //
      // If we are using SSL, encrypt the output buffer now. Note that
      // FormatSmtpMsg already left header space for the seal header.
      //
      if (m_SecurePort && !m_fNegotiatingSSL)
      {
          char *Buffer = &(m_pOutputBuffer[m_encryptCtx.GetSealHeaderSize()]);

          RetStatus = m_encryptCtx.SealMessage(
                            (UCHAR *) Buffer,
                            m_OutputBufferSize,
                            (UCHAR *) m_pOutputBuffer,
                            &cbMessage);
      }

      if (RetStatus) {
          RetStatus = CLIENT_CONNECTION::WriteFile(m_pOutputBuffer, cbMessage);
      }
      if(RetStatus)
      {
        ADD_BIGCOUNTER(QuerySmtpInstance(), BytesSentTotal, cbMessage);
        AddCommandBytesSent(cbMessage);
      }
      else
      {
         DebugTrace((LPARAM) this, "WriteFile failed with error %d", GetLastError());
      }

      m_OutputBufferSize = 0;
  }

  //DecPendingIoCount();
  TraceFunctLeaveEx((LPARAM) this);
  return RetStatus;
}


BOOL SMTP_CONNECTION::WriteMailFile(char * Buffer, DWORD BuffSize, BOOL *lpfWritePended)
{
    BOOL fResult = FALSE;
    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::WriteMailFileBuffer");

    if(!BuffSize && !Buffer)
    {
        //Simply flush the buffers if we have something to flush
        if(!m_cbCurrentWriteBuffer)
        {//Aynsc WRITE succeeded. Let this thread go thru - atq will call back
            *lpfWritePended = FALSE;
            return TRUE;
        }

        if(!WriteMailFileAtq((char*)m_pFileWriteBuffer->GetData(), m_cbCurrentWriteBuffer, NONBLOCKING))
        {
            m_MailBodyError = GetLastError();
            ErrorTrace((LPARAM) this, "Async Write of to mail file failed : %d",m_MailBodyError);
            fResult = FALSE;
        }
        else
        {
            //Aynsc WRITE succeeded. Let this thread go thru - atq will call back
            *lpfWritePended = TRUE;
            fResult = TRUE;
        }
        TraceFunctLeaveEx((LPARAM) this);
        return fResult;
    }

    //If the data to be written can fit in we take it in and come back
    //else we pend a write
    //Though the var name is a result of its original use, we now use this
    //buffer as a WRITEFILE buffer
    if(m_cbCurrentWriteBuffer + BuffSize > SMTP_WRITE_BUFFER_SIZE)
    {
        //Update the input buffers so that we can
        //go back and start processing the input buffers
        //after the async WRITE completes
        //MoveMemory ((void *)QueryMRcvBuffer(), Buffer, m_cbReceived);

        if(!WriteMailFileAtq((char*)m_pFileWriteBuffer->GetData(), m_cbCurrentWriteBuffer, NONBLOCKING))
        {
            *lpfWritePended = FALSE;
            m_MailBodyError = GetLastError();
            ErrorTrace((LPARAM) this, "Async Write of to mail file failed : %d",m_MailBodyError);
            fResult = FALSE;
        }
        else
        {
            //Aynsc WRITE succeeded. Let this thread go thru - atq will call back
            *lpfWritePended = TRUE;
            fResult = TRUE;
        }
    }
    //Copy the data into the buffer only if we have the space to do so
    else
    {
        CopyMemory((m_pFileWriteBuffer->GetData() + m_cbCurrentWriteBuffer),Buffer,BuffSize);
        m_cbCurrentWriteBuffer += BuffSize;
        fResult = TRUE;
    }

    TraceFunctLeaveEx((LPARAM) this);
    return fResult;
}

/*++

    Name:
        SMTP_CONNECTION::WriteMailFileAtq

    Description:
        While chunking, once header parsing is done the data is
        dumped to the disk asynchronously using WriteMailFileAtq( )

    Arguments:
        None.

    Returns:
        TRUE if successfully pended a write to the file, FALSE otherwise

--*/

BOOL SMTP_CONNECTION::WriteMailFileAtq(char * InputLine, DWORD dwBytesToWrite, DWORD dwIoMode)
{
    TraceFunctEnterEx( (LPARAM)this, "SMTP_CONNECTION::WriteMailFileAtq");

    DebugTrace( (LPARAM)this, "WriteFile 0x%08X, len: %d, LPO: 0x%08X",
                     InputLine,
                     dwBytesToWrite,
                     m_FileOverLapped.SeoOverlapped );

    //ZeroMemory( (void*)&m_FileOverLapped, sizeof(OVERLAPPED) );
    //if(dwIoMode == BLOCKING)
    //    m_FileOverLapped.SeoOverlapped.Overlapped.hEvent = (HANDLE)1;

    m_FileOverLapped.SeoOverlapped.Overlapped.Offset = m_CurrentOffset;

    m_FileOverLapped.m_LastIoState = WRITEFILEIO;
    m_FileOverLapped.m_cbIoSize = dwBytesToWrite;
    m_FileOverLapped.m_pIoBuffer = (LPBYTE)InputLine;

    //
    // increment the overall pending io count for this session
    //
    IncPendingIoCount();

    _ASSERT(m_FileOverLapped.SeoOverlapped.Overlapped.pfnCompletion != NULL);
    m_FileOverLapped.SeoOverlapped.ThisPtr = this;

    if (FIOWriteFile(m_IMsgHandle,
                     InputLine,
                     dwBytesToWrite,
                     &(m_FileOverLapped.SeoOverlapped.Overlapped)) == FALSE)
#if 0
    if ( AtqWriteFile(m_pAtqFileContext,
                          InputLine,
                          dwBytesToWrite,
                          (OVERLAPPED *) &(m_FileOverLapped.SeoOverlapped.Overlapped) ) == FALSE)
#endif
    {
        DecPendingIoCount();
        ErrorTrace( (LPARAM)this, "AtqWriteFile failed.");
    }
    else
    {
        TraceFunctLeaveEx((LPARAM) this);
        return  TRUE;
    }

    ErrorTrace( (LPARAM)this, "WriteMailFileAtq failed. err: %d", GetLastError() );

    if(!HandleInternalError(GetLastError()))
        DisconnectClient();

    TraceFunctLeaveEx((LPARAM)this);

    return  FALSE;
}

/*++

    Name:
        SMTP_CONNECTION::HandleInternalError

    Description:
        Contains code to handle common error conditions during inbound message flow.

    Arguments:
        [IN] DWORD Error code

    Returns:
        TRUE if error was handled
        FALSE otherwise

--*/
BOOL SMTP_CONNECTION::HandleInternalError(DWORD dwErr)
{
    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::HandleInternalError");
    if(dwErr == ERROR_DISK_FULL)
    {
        FormatSmtpMessage(SMTP_RESP_NORESOURCES, NULL, " Unable to accept message because the server is out of disk space.\r\n");
        ErrorTrace((LPARAM) this, "Rejecting message: Out of disk space");
        SendSmtpResponse();
        DisconnectClient();
        return TRUE;
    }
    return FALSE;
}

#if 0
/*++

    Name :
        SMTP_CONNECTION::FreeAtqFileContext

    Description :
        Frees AtqContext associated with message file used for doing async writes
        in case of chunking.

    Arguments :
        None. Operates on m_pAtqFileContext

    Returns :
        Nothing

--*/

void SMTP_CONNECTION::FreeAtqFileContext( void )
{
    PFIO_CONTEXT    pFIO;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::FreeAtqFileContext");

    pFIO = (PATQ_CONTEXT)InterlockedExchangePointer( (PVOID *)&m_pIMsgHandle, NULL );
    if ( pFIO != NULL )
    {
        DebugTrace((LPARAM) this, "Freeing AtqFileContext!");
        ReleaseContext(pFIO);
    }

    TraceFunctLeaveEx((LPARAM) this);
}
#endif

void SMTP_CONNECTION::ReInitClassVariables(void)
{
    _ASSERT (m_pInstance != NULL);


    //reset all variables to their initial state
    m_HeaderFlags = 0;
    m_TotalMsgSize = 0;
    m_cbDotStrippedTotalMsgSize = 0;
    m_CurrentOffset = 0;
    m_State = HELO;
    m_RecvdMailCmd = FALSE;
    m_InHeader = TRUE;
    m_LongBodyLine = FALSE;
    m_fFoundEmbeddedCrlfDotCrlf = FALSE;
    m_fScannedForCrlfDotCrlf = FALSE;
    m_fSeenRFC822FromAddress = FALSE;
    m_fSeenRFC822ToAddress = FALSE;
    m_fSeenRFC822CcAddress = FALSE;
    m_fSeenRFC822BccAddress = FALSE;
    m_fSeenRFC822Subject = FALSE;
    m_fSeenRFC822MsgId = FALSE;
    m_fSeenXPriority = FALSE;
    m_fSeenXOriginalArrivalTime = FALSE;
    m_fSeenContentType = FALSE;
    m_fSetContentType = FALSE;
    m_fSeenRFC822SenderAddress = FALSE;
    m_TimeToRewriteHeader = TRUE;
    m_MailBodyError = NO_ERROR;
    m_RecvdRcptCmd = FALSE;
    m_WritingData = FALSE;
    m_fIsLastChunk = FALSE;
    m_fIsBinaryMime = FALSE;
    m_fIsChunkComplete = FALSE;
    m_dwTrailerStatus = CRLF_SEEN;
    m_nChunkSize = 0;
    m_nBytesRemainingInChunk = 0;
    m_MailBodyDiagnostic = ERR_NONE;
    m_cbCurrentWriteBuffer = 0;
    m_cbRecvBufferOffset = 0;
    m_fAsyncEOD = FALSE;

    m_LineCompletionState = SEEN_NOTHING;
    m_Truncate = FALSE;
    m_BufrWasFull = FALSE;
    m_fBufferFullInBDAT = FALSE;

    //Clear the senders address if it's
    //still there.

    m_szFromAddress[0] = '\0';

    ReleasImsg(TRUE);
}


/*++

    Name :
        SMTP_CONNECTION::SmtpGetCommand

    Description:
       This function determines which SMTP input command was sent
       by the client

    Arguments:
         Request - Buffer the client sent
         RequestLen - Length of the buffer

    Returns:

      Index into our array of function pointers
--*/
int SMTP_CONNECTION::SmtpGetCommand(const char * Request, DWORD RequestLen, LPDWORD CmdSize)
{
  DWORD Loop = 0;
  char Cmd[SMTP_MAX_COMMANDLINE_LEN];
  char * ptr = NULL;
  char *psearch = NULL;

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::SmtpGetCommand");

   //start out with no errors
  CommandErrorType = SMTP_COMMAND_NOERROR;

  //we will copy the command into Cmd starting from
  //the beginning
  ptr = Cmd;

  //start looking for the space from the beginning
  //of the buffer
  psearch = (char *) Request;

  //search for the command and copy it into Cmd.  We stop
  //looking when we encounter the first space.
  while (*psearch != '\0' && !isspace (*psearch) && ptr < &Cmd[SMTP_MAX_COMMANDLINE_LEN - 2])
      *ptr++ = *psearch++;

  //null terminate the buffer
  *ptr = '\0';

  //now, look through the list of SMTP commands
  //and compare it to what the client gave us.
  while (SmtpCommands[Loop] != NULL)
    {
        if (!::strcasecmp((char *) Cmd, (char * )SmtpCommands[Loop]))
        {
            goto Exit;
        }

        Loop++;
    }

    //set error to COMMAND_NOT FOUND if we do not recognize the command
    CommandErrorType = SMTP_COMMAND_NOT_FOUND;

Exit:

  //If no error, send back the index in the array
  //If there was an error, send back the index of
  //the last element in the array.  This is our
  //catch all error function.
  if (CommandErrorType == SMTP_COMMAND_NOERROR)
  {
    *CmdSize = DWORD (ptr - Cmd);
    TraceFunctLeaveEx((LPARAM) this);
    return Loop;
  }
  else
   {
    ErrorTrace((LPARAM) this, "Command %s was not found in command table", Cmd);
    TraceFunctLeaveEx((LPARAM) this);
    return (DWORD) LAST_SMTP_STATE;
   }

}


/*++

    Name :
        SMTP_CONNECTION::FormatSmtpMessage( IN const char * Format, ...)

    Description:
        This function will build a sting in the output buffer with
        the given input parameters.  If the new data cannot fit in the
        buffer, this function will send whatever data is in the buffer,
        then build the string.

    Arguments:
        String to send

    Returns:

      TRUE if response was queued
--*/
BOOL SMTP_CONNECTION::FormatSmtpMessage(DWORD dwCode, const char * szEnhancedCodes, IN const char * Format, ...)
{
    int BytesWritten;
    va_list arglist;
    char *Buffer;
    DWORD AvailableBytes;
    DWORD HeaderOffset = (m_SecurePort ? m_encryptCtx.GetSealHeaderSize() : 0);
    DWORD SealOverhead = (m_SecurePort ?
                            (m_encryptCtx.GetSealHeaderSize() +
                                m_encryptCtx.GetSealTrailerSize()) : 0);
    char RealFormat[MAX_PATH];
    RealFormat[0] = '\0';

    //If we get passed dwCode we use it
    //If we get passed enhance status code only if we advertise them
    //
    if(dwCode)
    {
        if(m_pInstance->AllowEnhancedCodes() && szEnhancedCodes)
        {
            sprintf(RealFormat,"%d %s",dwCode,szEnhancedCodes);
        }
        else
            sprintf(RealFormat,"%d",dwCode);
    }
    strcat(RealFormat,Format);

    Buffer = &(m_pOutputBuffer[m_OutputBufferSize + HeaderOffset]);

    AvailableBytes = m_cbMaxOutputBuffer - m_OutputBufferSize - SealOverhead;

    //if BytesWritten is < 0, that means there is no space
    //left in the buffer.  Therefore, we flush any pending
    //responses to make space.  Then we try to place the
    //information in the buffer again.  It should never
    //fail this time.
    va_start (arglist, Format);
    BytesWritten = _vsnprintf (Buffer, AvailableBytes, (const char *)RealFormat, arglist);
    if(BytesWritten < 0)
    {
      //flush any pending response
      SendSmtpResponse();
      _ASSERT (m_OutputBufferSize == 0);
      Buffer = &m_pOutputBuffer[HeaderOffset];
      AvailableBytes = m_cbMaxOutputBuffer - SealOverhead;
      BytesWritten = _vsnprintf (Buffer, AvailableBytes, Format, arglist);
      _ASSERT (BytesWritten > 0);
    }
    va_end(arglist);

    m_OutputBufferSize += (DWORD) BytesWritten;

    //m_OutputBufferSize += vsprintf (&m_pOutputBuffer[m_OutputBufferSize], Format, arglist);

    return TRUE;
}

BOOL SMTP_CONNECTION::FormatSmtpMessage(unsigned char *DataBuffer, DWORD dwBytes)
{
    int BytesWritten;
    char *Buffer;
    DWORD AvailableBytes = 0;
    DWORD HeaderOffset = (m_SecurePort ? m_encryptCtx.GetSealHeaderSize() : 0);
    DWORD SealOverhead = (m_SecurePort ?
                            (m_encryptCtx.GetSealHeaderSize() +
                                m_encryptCtx.GetSealTrailerSize()) : 0);

    Buffer = &(m_pOutputBuffer[m_OutputBufferSize + HeaderOffset]);

    AvailableBytes = m_cbMaxOutputBuffer - m_OutputBufferSize - SealOverhead;

    //if BytesWritten is < 0, that means there is no space
    //left in the buffer.  Therefore, we flush any pending
    //responses to make space.  Then we try to place the
    //information in the buffer again.  It should never
    //fail this time.
    if( dwBytes + 2 < AvailableBytes)//+2 for CRLF
    {
        CopyMemory(Buffer, DataBuffer, dwBytes);
        Buffer[dwBytes] = '\r';
        Buffer[dwBytes + 1] = '\n';
        BytesWritten  = dwBytes + 2;

    }
    else
    {
      //flush any pending response

      SendSmtpResponse();
      _ASSERT (m_OutputBufferSize == 0);
      Buffer = &m_pOutputBuffer[HeaderOffset];
      AvailableBytes = m_cbMaxOutputBuffer - SealOverhead;
      CopyMemory(Buffer, DataBuffer, dwBytes);
      Buffer[dwBytes] = '\r';
      Buffer[dwBytes + 1] = '\n';
      BytesWritten  = dwBytes + 2;
      _ASSERT (BytesWritten > 0);
    }

    m_OutputBufferSize += (DWORD) BytesWritten;
    return TRUE;
}

BOOL SMTP_CONNECTION::PE_FastFormatSmtpMessage(LPSTR pszBuffer, DWORD dwBytes)
{
    LPSTR    Buffer;
    DWORD    BytesWritten = 0;
    DWORD    AvailableBytes = 0;
    DWORD    HeaderOffset = (m_SecurePort ? m_encryptCtx.GetSealHeaderSize() : 0);
    DWORD    SealOverhead = (m_SecurePort ?
                            (m_encryptCtx.GetSealHeaderSize() +
                                m_encryptCtx.GetSealTrailerSize()) : 0);

    Buffer = &(m_pOutputBuffer[m_OutputBufferSize + HeaderOffset]);
    AvailableBytes = m_cbMaxOutputBuffer - m_OutputBufferSize - SealOverhead;

    // Write as many buffers as we need to
    while (BytesWritten < dwBytes)
    {
        if ((dwBytes - BytesWritten) <= AvailableBytes)
        {
            CopyMemory(Buffer, pszBuffer, dwBytes - BytesWritten);
            m_OutputBufferSize += (dwBytes - BytesWritten);
            BytesWritten = dwBytes; // BytesWritten += (dwBytes - BytesWritten)
        }
        else
        {
            // We don't have enough buffer space, so write whatever we have left
            CopyMemory(Buffer, pszBuffer, AvailableBytes);
            BytesWritten += AvailableBytes;
            m_OutputBufferSize += AvailableBytes;
            pszBuffer += AvailableBytes;

            //flush any pending response
            SendSmtpResponse();
            _ASSERT (m_OutputBufferSize == 0);

            Buffer = &m_pOutputBuffer[HeaderOffset];
            AvailableBytes = m_cbMaxOutputBuffer - SealOverhead;
        }
    }

    return(TRUE);
}

BOOL SMTP_CONNECTION::DoesClientHaveIpAccess()
{
    AC_RESULT       acIpAccess;
    ADDRESS_CHECK   acAccessCheck;
    METADATA_REF_HANDLER    rfAccessCheck;
    BOOL            fNeedDnsCheck = FALSE;
    BOOL            fRet = TRUE;
    struct hostent* pH = NULL;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::DoesClientHaveIpAccess");

    m_pInstance->LockGenCrit();

    acAccessCheck.BindAddr( (PSOCKADDR)&m_saClient );

    if ( !rfAccessCheck.CopyFrom( m_pInstance->QueryRelayMetaDataRefHandler() ) )
    {
        m_pInstance->UnLockGenCrit();
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    m_pInstance->UnLockGenCrit();

    acAccessCheck.BindCheckList( (LPBYTE)rfAccessCheck.GetPtr(), rfAccessCheck.GetSize() );

    acIpAccess = acAccessCheck.CheckIpAccess( &fNeedDnsCheck);
    if ( (acIpAccess == AC_IN_DENY_LIST) ||
                ((acIpAccess == AC_NOT_IN_GRANT_LIST) && !fNeedDnsCheck) )
    {
        fRet = FALSE;
    }
    else if (fNeedDnsCheck)
    {
        pH = gethostbyaddr( (char*)(&((PSOCKADDR_IN)(&m_saClient))->sin_addr),
                          4, PF_INET );
        if(pH != NULL)
        {
            acIpAccess = acAccessCheck.CheckName(pH->h_name);
        }
        else
        {
            acIpAccess = AC_IN_DENY_LIST;
        }
    }

    if ( (acIpAccess == AC_IN_DENY_LIST) ||
                (acIpAccess == AC_NOT_IN_GRANT_LIST))
    {
        fRet = FALSE;
    }

    acAccessCheck.UnbindCheckList();
    rfAccessCheck.Reset( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    if(!fRet)
    {
        SetLastError(ERROR_ACCESS_DENIED);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}


/*++

    Name :
        SMTP_CONNECTION::ProcessReadIO

    Description:
        This function gets a buffer from ATQ, parses the buffer to
        find out what command the client sent, then executes that
        cammnd.

    Arguments:
         InputBufferLen - Number of bytes that was written
         dwCompletionStatus -Holds error code from ATQ, if any
         lpo -  Pointer to overlapped structure

    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/

BOOL SMTP_CONNECTION::ProcessReadIO(IN      DWORD InputBufferLen,
                                    IN      DWORD dwCompletionStatus,
                                    IN OUT  OVERLAPPED * lpo)
{
    BOOL fReturn = TRUE;
    const char * InputLine;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::ProcessReadIO");

    _ASSERT (m_pInstance != NULL);

    m_cbReceived += InputBufferLen;

    // Firewall against bugs where we overflow the read buffer
    if(m_cbReceived > QueryMaxReadSize())
    {
        DisconnectClient();
        _ASSERT(0 && "Buffer overflow");
        return FALSE;
    }

    InputLine = QueryMRcvBuffer();
    ADD_BIGCOUNTER(QuerySmtpInstance(), BytesRcvdTotal, InputBufferLen);

    if (!m_fNegotiatingSSL)
    {

        if (m_SecurePort)
        {
            fReturn = DecryptInputBuffer();
        }
        else
        {
            m_cbParsable = m_cbReceived;
        }

        if (fReturn)
        {
            fReturn = ProcessInputBuffer();
        }

    }
    else // negotiating SSL
    {
        //
        // If we are still doing the handshake let CEncryptCtx::Converse handle it.
        // Converse returns in the following situations:
        //
        // o The negotiation succeeded. cbExtra returns the number of bytes that
        //      were not consumed by the SSL handshake. These bytes are "application
        //      data" which should be decrypted and processed by the SMTP protocol.
        //
        // o The negotiation failed. The connection will be dropped.
        //
        // o More data is needed from the client to complete the negotiation. A
        //      read should be posted.
        //

        DWORD   dw;
        BOOL    fMore;
        DWORD   dwBytes = MAX_SSL_FRAGMENT_SIZE;
        BOOL    fApplicationDataAvailable = FALSE;
        DWORD   cbExtra = 0;

        dw = m_encryptCtx.Converse( (LPVOID) InputLine,
                                    m_cbReceived,
                                    (PUCHAR) m_pOutputBuffer,
                                    &dwBytes,
                                    &fMore,
                                    (LPSTR) QueryLocalHostName(),
                                    (LPSTR) QueryLocalPortName(),
                                    (LPVOID) QuerySmtpInstance(),
                                    QuerySmtpInstance()->QueryInstanceId(),
                                    &cbExtra
                                    );

        if ( dw == NO_ERROR )
        {
            //
            // reset the read buffer
            //
            if ( cbExtra )
            {
                fApplicationDataAvailable = TRUE;
                MoveMemory( (PVOID)InputLine, InputLine + (m_cbReceived - cbExtra), cbExtra );
            }
            m_cbReceived = cbExtra;

            //
            // send any bytes required for the client
            //
            if ( dwBytes != 0 )
            {
                WriteFile( m_pOutputBuffer, dwBytes );
            }

            if ( fMore )
            {
                //
                // more handshaking required - repost the read
                //
                _ASSERT( dwBytes != 0 );
            }
            else
            {
                //
                // completed negotiation. Turn off the flag indicating thats
                // what we are doing
                //
                m_fNegotiatingSSL = FALSE;
            }
        }
        else if ( dw == SEC_E_INCOMPLETE_MESSAGE )
        {
            //
            // haven't received the full packet from the client
            //
            _ASSERT( dwBytes == 0 );
        }
        else
        {
            ErrorTrace((LPARAM)this, "SSL handshake failed, Error = %d", dw);
            DisconnectClient( dw );
            fReturn = FALSE;
        }

        if ( fApplicationDataAvailable )
        {
            //
            // Application data is already available, no need to post a read
            //
            fReturn = DecryptInputBuffer();

            if ( fReturn )
                fReturn = ProcessInputBuffer();
        }
        else if (fReturn)
        {
            //
            // If we are continuing, we need to post a read
            //
            _ASSERT (m_cbReceived < QueryMaxReadSize() );

            IncPendingIoCount();

            m_LastClientIo = READIO;
            fReturn = ReadFile( QueryMRcvBuffer() + m_cbReceived,
                                QueryMaxReadSize() - m_cbReceived );

            if (!fReturn)
            {
                DisconnectClient();
                DecPendingIoCount();
            }
        }
        else
        {
            m_CInboundContext.SetWin32Status(dw);
            ProtocolLog(STARTTLS, (char *) QueryClientUserName(), dw, SMTP_RESP_BAD_SEQ, 0, 0);
        }

    }

    return( fReturn );
}

/*++

    Name :
        SMTP_CONNECTION::ProcessFileWrite

    Description:
        Handles completion of an async Write issued against a message file by
        WriteMailFileAtq

    Arguments:
        cbRead              count of bytes read
        dwCompletionStatus  Error code for IO operation
        lpo                 Overlapped structure

    Returns:
        TRUE if connection should stay open
        FALSE if this object should be deleted

--*/
BOOL SMTP_CONNECTION::ProcessFileWrite(
    IN      DWORD       BytesWritten,
    IN      DWORD       dwCompletionStatus,
    IN OUT  OVERLAPPED  *lpo
    )
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::ProcessFileWrite");
    SMTPCLI_FILE_OVERLAPPED * lpFileOverlapped;

    _ASSERT(lpo);
    lpFileOverlapped = (SMTPCLI_FILE_OVERLAPPED*)lpo;


    // In case of async Write to disk file, a successsful completion
    // will always mean all the data has been written out
    // Check for partial completions or errors
    // and Disconnect if something failed
    if( BytesWritten != lpFileOverlapped->m_cbIoSize || dwCompletionStatus != NO_ERROR )
    {
        ErrorTrace( (LPARAM)this,
                    "Message WriteFile error: %d, bytes %d, expected %d",
                    dwCompletionStatus,
                    BytesWritten,
                    lpFileOverlapped->m_cbIoSize );

        //Close the file Handle and disconnect the client
        DisconnectClient();
        return( FALSE );
    }
    else
    {
        DebugTrace( (LPARAM)this,
                    "WriteFile complete. bytes %d, lpo: 0x%08X",
                    BytesWritten, lpo );
    }

    m_CurrentOffset += BytesWritten;


    //We write out of the Write buffer
    //We need throw away the data that was written out and
    //move the remaining data to the start of the buffer
//    if(m_cbReceived)
//      MoveMemory ((void *)QueryMRcvBuffer(), (void *)(QueryMRcvBuffer() + BytesWritten), m_cbReceived);
    m_cbCurrentWriteBuffer = 0;

    //Time to go back and process the remaining data in the buffer
    //Adjust the buffer for the next read only in case of Sync write
    return(ProcessInputBuffer());

}


BOOL SMTP_CONNECTION::PendReadIO(DWORD UndecryptedTailSize)
{
    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::PendReadIO");

    BOOL fReturn = TRUE;

    m_LastClientIo = READIO;

    m_cbReceived = m_cbParsable + UndecryptedTailSize;

    _ASSERT (m_cbReceived < QueryMaxReadSize());

    //increment this IO
    IncPendingIoCount();

    fReturn = ReadFile(QueryMRcvBuffer() + m_cbReceived, QueryMaxReadSize() - m_cbReceived);
    if(!fReturn)
    {
       DecPendingIoCount();
       DisconnectClient();
    }

    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;
}

/*++

    Name :
        SMTP_CONNECTION::ProcessInputBuffer

    Description:
        This function takes the receive buffer, parses the buffer to
        find out what command the client sent, then executes that
        command.

    Arguments:
        lpfMailQueued -- On return, TRUE if processing the client command
            caused a mail message to be queued.

    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.
--*/
BOOL SMTP_CONNECTION::ProcessInputBuffer(void)
{
    BOOL fReturn = TRUE;
    const char * InputLine;
    DWORD UndecryptedTailSize = m_cbReceived - m_cbParsable;
    BOOL fWritePended = FALSE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::ProcessInputBuffer");

    //Start processing at the point after the temporary BDAT chunk
    InputLine = QueryMRcvBuffer() + m_cbTempBDATLen + m_cbRecvBufferOffset;

    if ( TRUE == m_fPeBlobReady) {
        fReturn = ProcessPeBlob( InputLine, m_cbParsable);
        if ( FALSE == fReturn) {
            TraceFunctLeaveEx( ( LPARAM) this);
            return FALSE;
        }
        MoveMemory ( ( void *) QueryMRcvBuffer(), InputLine + m_cbParsable, UndecryptedTailSize);
        m_cbParsable = 0;
        m_cbReceived = UndecryptedTailSize;
        //  always pend a read in this state regardless of previous fReturn
        fReturn = PendReadIO( UndecryptedTailSize);
        TraceFunctLeaveEx( ( LPARAM) this);
        return fReturn;
    }

    if (m_State == DATA)
    {
        BOOL fAsyncOp = FALSE;

        fReturn = ProcessDATAMailBody(InputLine, UndecryptedTailSize, &fAsyncOp);
        if(!fReturn || fAsyncOp)
        {
            TraceFunctLeaveEx((LPARAM) this);
            return fReturn;
        }

        //
        // There is additional data pipelined behind the mailbody. DoDATACommandEx 
        // moves this to the beginning of the input buffer after processing the
        // mail body, so the place to begin parsing is m_pRecvBuffer.
        //

        InputLine = QueryMRcvBuffer();
        _ASSERT(m_State == HELO);
    }

PROCESS_BDAT:

    if(m_State == BDAT && !m_fIsChunkComplete)
    {
        BOOL fAsyncOp = FALSE;

        fReturn = ProcessBDATMailBody(InputLine, UndecryptedTailSize, &fAsyncOp);
        if(!fReturn || fAsyncOp)
        {
            TraceFunctLeaveEx((LPARAM) this);
            return fReturn;
        }

        //
        // All the mailbody was processed and the input buffer points to the
        // next SMTP command after readjusting for any *saved* BDAT data (If a
        // header spans 2 chunks, ProcessBDAT will save the partial header from
        // the previous chunk till it can complete it using the next chunk.
        // m_cbTempBdatLen represents the number of saved bytes)
        //
        
        InputLine = QueryMRcvBuffer() + m_cbTempBDATLen;
    }
    else if(m_State == AUTH)
    {
        fReturn = DoAuthNegotiation(InputLine, m_cbParsable);

        if(!fReturn)
        {
            ++m_ProtocolErrors;
        }

        if(m_State == AUTH)
        {
                fReturn = PendReadIO(UndecryptedTailSize);
                TraceFunctLeaveEx((LPARAM) this);
                return fReturn;
        }
    }

    _ASSERT(m_State != DATA);

     PCHAR pszSearch;
     DWORD IntermediateSize;
     DWORD CmdSize = 0;

     //if we got here, then a read completed.  Process the
     //entire buffer before returning(Pipelining).
     //use to be while ((pszSearch = strstr(QueryRcvBuffer(), CRLF)) != NULL)

     //Reset the the offset ptr into the recv buffer
     //we use this to keeo track of where to continue processing from
     m_cbRecvBufferOffset = 0;
     BOOL fAsyncOp = FALSE;

     while ((pszSearch = IsLineComplete(InputLine,m_cbParsable - m_cbTempBDATLen)) != NULL)
     {
            //Null terminate the end of the command
            *pszSearch = '\0';

            IntermediateSize = (DWORD)(pszSearch - InputLine);
            StartProcessingTimer();
            ResetCommandCounters();
            SetCommandBytesRecv( IntermediateSize );

            // ignore blank lines
            if (*InputLine == 0) {
                // update the counters into InputLine
                m_cbParsable -= (IntermediateSize + 2);
                m_cbReceived = m_cbParsable + UndecryptedTailSize;
                MoveMemory((PVOID)InputLine, pszSearch + 2, m_cbReceived - m_cbTempBDATLen);
                continue;
            }

            //
            // Error case when an overly long SMTP command has to be discarded because there
            // isn't enough space to hold it all in the buffer. Can happen while chunking (see
            // where this member variable is set). In this situation, all bytes received are
            // discarded without parsing, till a CRLF is encountered. Then IsLineComplete
            // succeeds and we execute this if-statement.
            //

            if(m_fBufferFullInBDAT) {

                m_fBufferFullInBDAT = FALSE;

                m_cbParsable -= (IntermediateSize + 2);
                m_cbReceived = m_cbParsable + UndecryptedTailSize;
                MoveMemory((PVOID)InputLine, pszSearch + 2, m_cbReceived - m_cbTempBDATLen);

                m_ProtocolErrors++;
                BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
                PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n","BDAT Expected" );
                PE_SendSmtpResponse();
                continue;
            }
            
            //
            // SMTP events are fired upon the _EOD event and "_EOD" appears in the SmtpDispatchTable
            // and SmtpCommands[] array. However it isn't an SMTP command. Ideally "_EOD" should never
            // be returned from SmtpGetCommand, but the event firing mechanism is tied to "_EOD" as a
            // string. So we firewall this case in the parser.
            //
            // Other strings unimplemented by SMTP should be handled by GlueDispatch which checks if
            // SMTP sinks are registered to handle that string and fires events for that string. "_EOD"
            // is the only string for which events must not be fired from the SMTP command parser.
            //

            if(!strncasecmp((char *)InputLine, "_EOD", sizeof("_EOD") - 1))
            {
                m_cbParsable -= (IntermediateSize + 2);
                m_cbReceived = m_cbParsable + UndecryptedTailSize;
                MoveMemory((PVOID)InputLine, pszSearch + 2, m_cbReceived - m_cbTempBDATLen);

                BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
                m_ProtocolErrors++;
                PE_CdFormatSmtpMessage (SMTP_RESP_BAD_CMD, ENOT_IMPLEMENTED," %s\r\n", SMTP_BAD_CMD_STR);
                PE_SendSmtpResponse();
                continue;
            }

            m_dwCurrentCommand = SmtpGetCommand(InputLine, IntermediateSize, &CmdSize);
            if(m_State == BDAT &&
               m_dwCurrentCommand != BDAT &&
               m_dwCurrentCommand != RSET &&
               m_dwCurrentCommand != QUIT &&
               m_dwCurrentCommand != NOOP) 
            {
                ErrorTrace((LPARAM)this, "Illegal command during BDAT: %s", InputLine);
                
                m_cbParsable -= (IntermediateSize + 2);
                m_cbReceived = m_cbParsable + UndecryptedTailSize;
                MoveMemory((PVOID)InputLine, pszSearch + 2, m_cbReceived - m_cbTempBDATLen);

                PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n","BDAT Expected" );
                BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
                ++m_ProtocolErrors;
                continue;
            }

            // we might run into a sink that does async operations
            // So update state data that the async thread could see
            m_cbRecvBufferOffset += (DWORD)(pszSearch - (QueryMRcvBuffer() + m_cbTempBDATLen) + 2);
            m_cbParsable -= (IntermediateSize + 2);
            m_cbReceived = m_cbParsable + UndecryptedTailSize;

            // before firing each command load any session properties from ISession
            HrGetISessionProperties();

            //
            // Increment the pending IO count in case this returns async
            //
            IncPendingIoCount();

            fReturn = GlueDispatch((char *)InputLine, IntermediateSize, CmdSize, &fAsyncOp);
            //
            // Assert check that fAsyncOp isn't true when GlueDispatch fails
            //
            _ASSERT( (!fAsyncOp) || fReturn );
            if(!fAsyncOp)
            {
                //
                // Decrement the pending IO count since GlueDispatch
                // returned sync (and we incremented the count above).
                // ProcessClient is above us in the callstack and always has a
                // pending IO reference, so this should never return zero
                //
                _VERIFY(DecPendingIoCount() > 0);
            }

            if (fReturn == TRUE)
            {
                //Check if some sink performed an async operation
                if(fAsyncOp)
                {
                    //We returned from Dispatcher because some sink did an async operation
                    //We need to simply leave. The thread on which the async operation completes
                    //will continue with the sink firing. The dispacther will keep the context
                    //which will allow it to do so..
                    //So as to keep the connection alive - bump up the ref count
                    TraceFunctLeaveEx((LPARAM) this);
                    return TRUE;
                }//end if(AsyncSink)

                // log this command and the response
                if (m_State != DATA &&
                    m_State != BDAT &&
                    m_State != AUTH &&
                    m_dwCurrentCommand != DATA &&
                    m_dwCurrentCommand != BDAT &&
                    m_dwCurrentCommand != AUTH)
                {
                    const char *pszCommand = SmtpCommands[m_dwCurrentCommand];
                    DWORD cCmd = (pszCommand) ? strlen(pszCommand) : 0;
                    ProtocolLog(m_dwCurrentCommand,
                                InputLine + cCmd,
                                m_CInboundContext.m_dwWin32Status,
                                m_CInboundContext.m_dwSmtpStatus,
                                0,
                                0);
                }

                //All Sinks completed synchronously
                m_cbRecvBufferOffset = 0;
                InputLine = pszSearch + 2; //skip CRLF
                if(m_State != DATA && m_State != BDAT)
                {
                    continue;
                }
                else if (m_State == BDAT && m_cbParsable)
                {
                    //We are in BDAT mode and there is some data that can be parsed
                    MoveMemory ((void *)(QueryMRcvBuffer() + m_cbTempBDATLen), InputLine, m_cbReceived - m_cbTempBDATLen );
                    InputLine = QueryMRcvBuffer();
                    goto PROCESS_BDAT;
                }
                else
                {
                    break; // no more data
                }
            }
            else
            {
                TraceFunctLeaveEx((LPARAM) this);
                return FALSE;
            }//end if(fReturn == TRUE)
     }//end while

     // if IsLineComplete failed because we passed in a negative length
     // than drop the session.  something is corrupt
     if ((int) m_cbParsable - (int) m_cbTempBDATLen < 0) {
        DisconnectClient();
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
     }

    _ASSERT(m_cbReceived <= QueryMaxReadSize());

    if(m_cbParsable != 0)
    {
        MoveMemory ((void *)(QueryMRcvBuffer() + m_cbTempBDATLen), InputLine, m_cbParsable+UndecryptedTailSize-m_cbTempBDATLen);
    }


    SendSmtpResponse();

    m_cbReceived = m_cbParsable + UndecryptedTailSize;

    //
    // The receive buffer can fill up if we have more than QueryMaxReadSize()
    // bytes in it that cannot be processed till more data is received from
    // the client. This does not happen in the normal processing of SMTP
    // commands, since each SMTP command is limited to 512 bytes, which can
    // comfortable fit in the recv buffer.
    //
    // However, while processing BDAT, CreateMailBodyFromChunk may save the
    // bytes of a partially received header line in the recv buffer by setting
    // m_cbTempBDATLen > 0. For example, suppose the client is sending BDAT
    // chunks, and the first chunk comprises of 500 bytes of data without a
    // CRLF. In this case, SMTP cannot determine whether or not these 500
    // bytes are part of a header. This is because unless the complete line
    // has been received we cannot decide whether or not the line follows
    // the header syntax. Therefore SMTP will save the 500 bytes by setting
    // m_cbTempBDATLen == 500, and any bytes sent by the client will be
    // appended at an offset of 500 in the recv buffer. When the next chunk
    // arrives, SMTP will again try to process the 500 saved bytes + the
    // bytes from the new chunk, as a complete header line.
    // 
    // A client cannot fill up the buffer by sending thousands of bytes like
    // this, without CRLFs, forcing SMTP to save the partial header. SMTP has
    // a maximum limit on how long a header line can be (this is 1000 bytes).
    // If this limit is exceeded, SMTP can determine that the line is not a
    // syntactically correct header, and it does not have to wait for the
    // terminating CRLF for the line so that it can parse the complete line
    // according to header syntax.
    //
    // Thus it is impossible to occupy > 999 bytes of space as a saved BDAT
    // partial header. However, even if we occupy the maximum possible 999
    // bytes, the recv buffer (being sized 1024) will have only 26 bytes
    // available for processing SMTP commands. This is clearly inadequate
    // (in theory anyway) because SMTP commands have a max size of 512. In
    // fact, we do not even have enough space to receive and reject illegal
    // commands which can exceed 26 bytes (since a command-line must be
    // completely received, till the terminating CRLF, before we can parse
    // and reject it, in the ordinary course of things).
    //
    // Fortunately, during BDAT, the only commands allowed to be issued are
    // all shorter than 26 bytes: BDAT, RSET and QUIT. We take advantage of
    // this fact if we are caught in the "out of space" scenario, and the
    // follwing if-statement sets m_fBufrFullInBDAT flag. When this flag is
    // set, SMTP will discard every byte it receives from the client
    // (following the saved m_cbTempBDATLen bytes) till a CRLF is received
    // (note that the CRLF marks the end of the illegal SMTP command). Then
    // SMTP responds with "BDAT expected" (see the command loop above) and
    // resets the m_fBufrFullInBDAT flag to the normal state.
    //
    // Note that if the buffer is full, then m_cbTempBDATLen *must* be > 0.
    // We only run out of recv buffer space during chunking. Thus the
    // additional check for m_cbTempBDATLen > 0 in the following if-statement.
    //

    if(QueryMaxReadSize() == m_cbReceived && m_cbTempBDATLen > 0)
    {
        // Flag error so we know what response to generate when we do get CRLF
        m_fBufferFullInBDAT = TRUE;

        // Discard everything after the saved BDAT chunk except Undecrypted tail
        PBYTE pbDiscardStart = (PBYTE) (QueryMRcvBuffer() + m_cbTempBDATLen); 
        PBYTE pbDiscardEnd = (PBYTE) (QueryMRcvBuffer() + m_cbParsable);
        DWORD cbBytesToDiscard = m_cbParsable - m_cbTempBDATLen;
        DWORD cbBytesToMove = UndecryptedTailSize;

        // Keep CR if it's at the end. If the next packet has LF as the
        // first byte we want to process the CRLF with IsLineComplete. 
        if(*(pbDiscardEnd - 1) == CR)
        {
            pbDiscardEnd--;
            cbBytesToDiscard--;
            cbBytesToMove++;
        }

        m_cbParsable -= cbBytesToDiscard;
        m_cbReceived -= cbBytesToDiscard;

        _ASSERT(pbDiscardEnd > pbDiscardStart);
        MoveMemory((PVOID)pbDiscardStart, pbDiscardEnd, cbBytesToMove);
    }

    _ASSERT (m_cbReceived < QueryMaxReadSize());

    //pend an I/O
    IncPendingIoCount();
    m_LastClientIo = READIO;
    fReturn = ReadFile(QueryMRcvBuffer() + m_cbReceived, QueryMaxReadSize() - m_cbReceived);
    if(!fReturn)
    {
        DisconnectClient();
        DecPendingIoCount();
    }

    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;
}

/*++

    Name:
        SMTP_CONNECTION::HrGetISessionProperties

    Description:
        A sink may set certain properties on the session
        which should control SMTP behaviour, this function
        pulls those properties from ISession and writes
        them as session parameters (members of SMTP_CONNECTION)

    Arguments:
        None.

    Returns:
        HRESULT - Success or Error
        If there isn't a sink or if a property was not
            set by sink, an error may be returned.

--*/
HRESULT SMTP_CONNECTION::HrGetISessionProperties()
{
    IMailMsgPropertyBag *pISessionProperties = NULL;
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::HrGetISessionProperties");
    //
    // This is for the EXPS (or any other) AUTH sink, which replaces SMTP
    // authentication --- if the session is authenticated using the sink
    // we should mark it as such. We pull the "AUTH" properties when we are
    // about to process a command that is affected by the AUTH settings. We
    // exclude commands like DATA and BDAT because they MUST have been
    // preceded by MAIL, for which the AUTH setting would have already been
    // checked.
    //
    if(!m_fAuthenticated &&
       (m_dwCurrentCommand == MAIL ||
        m_dwCurrentCommand == TURN ||
        m_dwCurrentCommand == ETRN ||
        m_dwCurrentCommand == VRFY ||
        m_dwCurrentCommand == HELP))
    {
        pISessionProperties = (IMailMsgPropertyBag *)GetSessionPropertyBag();
        //
        // Usage of ISESSION_PID_IS_SESSION_AUTHENTICATED property: The AUTH
        // sink sets this to TRUE when a successful authentication occurs.
        //
        hr = pISessionProperties->GetBool(
                ISESSION_PID_IS_SESSION_AUTHENTICATED,
                (DWORD *) &m_fAuthenticated);

        if(FAILED(hr))
        {
            DebugTrace((LPARAM)this, "Can't get authenticated property for Session. hr - %08x", hr);
            hr = S_OK;
            goto Exit;
        }

        hr = pISessionProperties->GetStringA(
                ISESSION_PID_AUTHENTICATED_USERNAME,
                sizeof(m_szAuthenticatedUserNameFromSink),
                m_szAuthenticatedUserNameFromSink);

        if(FAILED(hr))
        {
            m_szAuthenticatedUserNameFromSink[0] = '\0';
            DebugTrace((LPARAM)this, "Can't get username for Session. hr - %08x", hr);
            hr = S_OK;
        }

    }

Exit:
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}
/*++

    Name :
        SMTP_CONNECTION::ProcessClient

    Description:

       Main function for this class. Processes the connection based
        on current state of the connection.
       It may invoke or be invoked by ATQ functions.

    Arguments:

       cbWritten          count of bytes written

       dwCompletionStatus Error Code for last IO operation

       lpo                Overlapped stucture

    Returns:

       TRUE when processing is incomplete.
       FALSE when the connection is completely processed and this
        object may be deleted.

  Note :

--*/
BOOL SMTP_CONNECTION::ProcessClient( IN DWORD InputBufferLen, IN DWORD dwCompletionStatus, IN OUT OVERLAPPED * lpo)
{
    BOOL    fIsAtqThread = TRUE;
    BOOL    RetStatus;
    BOOL    fMailQueued     = FALSE;
    PSMTP_SERVER_INSTANCE pInstance = m_pInstance; //save the instance pointer

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::ProcessClient()");

    _ASSERT (m_pInstance != NULL);

    pInstance->IncProcessClientThreads();
    InterlockedIncrement(&g_cProcessClientThreads);
    //
    // increment the number of threads processing this client
    //
    IncThreadCount();

    //if lpo == NULL, then we timed out. Send an appropriate message
    //then close the connection
    if( (lpo == NULL) && (dwCompletionStatus == ERROR_SEM_TIMEOUT))
    {
        //
        // fake a pending IO as we'll dec the overall count in the
        // exit processing of this routine needs to happen before
        // DisconnectClient else completing threads could tear us down
        //
        IncPendingIoCount();

        FormatSmtpMessage (SMTP_RESP_ERROR, NULL," %s\r\n",SMTP_TIMEOUT_MSG );
        SendSmtpResponse(); //flush the response
        ProtocolLog(SMTP_TIMEOUT, (char *) QueryClientUserName(), inet_addr((char *)QueryClientHostName()), ERROR_SEM_TIMEOUT);

        DebugTrace( (LPARAM)this, "client timed out");

        DisconnectClient();
    }
    else if((InputBufferLen == 0) || (dwCompletionStatus != NO_ERROR))
    {
        //
        DebugTrace((LPARAM) this, "SMTP_CONNECTION::ProcessClient: InputBufferLen = %d dwCompletionStatus = %d  - Closing connection", InputBufferLen, dwCompletionStatus);

        //  If this is a mail file write then we handle error: if not a mailfile write or we are unable to
        //  handle the error, then we simply disconnect.
        if( lpo != &m_Overlapped && lpo != QueryAtqOverlapped() && !HandleInternalError(dwCompletionStatus))
            DisconnectClient();
    }
    else if (lpo == &m_Overlapped || lpo == QueryAtqOverlapped())
    {
        //
        // Is this a real IO completion or a completion status
        // posted to notify us an async sink completed?
        //
        if( m_fAsyncEventCompletion )
        {
            //
            // A portocol event sink completed async, called our
            // completion routine, posted a completion status which is
            // being dequeued here.  Our job is now to pend the next read
            // (via ProcessInputBuffer)
            //
            m_fAsyncEventCompletion = FALSE;
            RetStatus = ProcessInputBuffer();
        }
        else
        {
            //A client based async IO completed
            RetStatus = ProcessReadIO(InputBufferLen, dwCompletionStatus, lpo);

            if((m_pInstance->GetMaxErrors() > 0) && (m_ProtocolErrors >= m_pInstance->GetMaxErrors()))
            {
                //If there are too many error, break the connection
                FormatSmtpMessage (SMTP_RESP_SRV_UNAVAIL, NULL," %s\r\n",SMTP_TOO_MANY_ERR_MSG);
                FatalTrace((LPARAM) this, "Too many errors. Error count = %d", m_ProtocolErrors);
                SendSmtpResponse();
                DisconnectClient();
            }
        }
    }
    else
    {
        //A Mail File Write completed
        SMTPCLI_FILE_OVERLAPPED* lpFileOverlapped = (SMTPCLI_FILE_OVERLAPPED*)lpo;
        _ASSERT( lpFileOverlapped->m_LastIoState == WRITEFILEIO );

        if (lpFileOverlapped->m_LastIoState == WRITEFILEIO)
        {
            RetStatus = ProcessFileWrite(InputBufferLen, dwCompletionStatus, lpo);
        }
    }

    //
    // decrement the number of threads processing this client if the thread exiting
    // is an Atq pool thread
    //
    //if(fIsAtqThread)
        DecThreadCount();

    DebugTrace((LPARAM)this,"SMTPLCI - Pending IOs: %d", m_cPendingIoCount);
    DebugTrace((LPARAM)this,"SMTPCLI - Num Threads: %d", m_cActiveThreads);

    // Do NOT Touch the member variables past this POINT!
    // This object may be deleted!

    //
    // decrement the overall pending IO count for this session
    // tracing and ASSERTs if we're going down.
    //
    if (DecPendingIoCount() == 0)
    {
        ProtocolLog(QUIT, (char *) QueryClientUserName() , QuerySessionTime(), NO_ERROR);

        DebugTrace((LPARAM)this, "Pending IO count == 0, disconnecting.");
        if(m_DoCleanup)
            DisconnectClient();

        m_pInstance->RemoveConnection(this);
        delete this;
    }

    //if(fIsAtqThread)
    //{
        pInstance->DecProcessClientThreads();
        InterlockedDecrement(&g_cProcessClientThreads);
    //}

    // We are not the last thread, so we will return TRUE
    // to keep the object around
    //TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

 /*++

    Name :
        SMTP_CONNECTION::StartSession

    Description:

        Starts up a session for new client.
        starts off a receive request from client.

    Arguments:

    Returns:

       TRUE if everything is O.K
       FALSE if a write or a pended read failed
--*/
BOOL SMTP_CONNECTION::StartSession( void)
{
    SYSTEMTIME  st;
    BOOL fRet;
    char szDateBuf [cMaxArpaDate];
    char FullName[MAX_PATH + 1];

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::StartSession");

    StartSessionTimer();

    if(!m_pFileWriteBuffer || !m_pFileWriteBuffer->GetData())
    {
        ErrorTrace((LPARAM)this, "Failed to get the write buffer Err : %d",
                      GetLastError());
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    //
    // If we are negotiating SSL, we need to let the SSL handshake happen
    // first. Else, we are either done with the SSL handshake or we are
    // talking over the unsecured port, so just go ahead and send the server
    // greeting.
    //

    if (!m_fNegotiatingSSL)
    {
        _ASSERT (m_pInstance != NULL);

        //Dump the header line into the buffer to format the greeting
        GetLocalTime(&st);
        GetArpaDate(szDateBuf);

        m_pInstance->LockGenCrit();
        lstrcpy(FullName, m_pInstance->GetFQDomainName());
        m_pInstance->UnLockGenCrit();

        PE_CdFormatSmtpMessage(SMTP_RESP_READY,NULL," %s %s %s, %s \r\n",
                    FullName,
                    m_pInstance->GetConnectResponse(),
                    Daynames[st.wDayOfWeek],
                    szDateBuf);

        //send the greeting
        if(!PE_SendSmtpResponse())
        {
            DebugTrace( (LPARAM) this, "SendSmtpResponse() returned FALSE!");
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }

    }

    //kick off our first read
    m_LastClientIo = READIO;

    //
    // increment the overall pending io count for this session
    //

    _ASSERT(m_cPendingIoCount == 0);

    IncPendingIoCount();
    fRet = ReadFile(QueryMRcvBuffer(), QueryMaxReadSize());

    if(!fRet)
    {
        int err = GetLastError();

        ErrorTrace((LPARAM)this, "Readfile failed, err = %d", err);
        DecPendingIoCount();    //if one of these operations fail,
        PE_DisconnectClient();  //AND the ReadFile failed the "last error" is lost.

        if(err != ERROR_SUCCESS)
            SetLastError(err);  //restore last error that occurred so higher level routine knows what happened
    }

    DebugTrace((LPARAM)this, "SendSmtpResponse() returned %d", fRet);
    TraceFunctLeaveEx((LPARAM) this);

    return fRet;
}

/*++

    Name :
        SMTP_CONNECTION::CheckArguments

    Description:

        checks the arguments of what the client sends
        for the required space command et al.

    Arguments:

         Arguments from client

    Returns:

    NULL if arguments are not correct
    A pointer into the input buffer where
    the rest of the data is.

--*/
char * SMTP_CONNECTION::CheckArgument(char * Argument, BOOL WriteError)
{

  if(*Argument =='\0')
  {
    if(WriteError)
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS, " %s\r\n","Argument missing" );

    return NULL;
  }

  if(!isspace(*Argument))
  {
    if(WriteError)
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS, " %s\r\n",SMTP_BAD_CMD_STR);

    return NULL;
  }

    //get rid of white space
  while(isspace(*Argument))
      Argument++;

    //is there anything after here ?
  if(*Argument =='\0')
  {
    if(WriteError)
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS," %s\r\n", "Argument missing" );

    return NULL;
  }

  return Argument;
}

void SMTP_CONNECTION::FormatEhloResponse(void)
{
    char FullName [MAX_PATH + 1];
    unsigned char AuthPackages [500];
    DWORD BytesRet = 0;
    DWORD ConnectionStatus = 0;

    if(m_SecurePort)
        ConnectionStatus |= SMTP_IS_SSL_CONNECTION;
    if(m_fAuthenticated)
        ConnectionStatus |= SMTP_IS_AUTH_CONNECTION;

    m_pInstance->LockGenCrit();
    lstrcpy(FullName, m_pInstance->GetFQDomainName());
    m_pInstance->UnLockGenCrit();

    PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL, "-%s %s [%s]\r\n",  FullName,"Hello", QueryClientHostName());

    if(m_pInstance->AllowAuth())
    {
        if(m_pInstance->QueryAuthentication() != 0)
        {
            if(m_pInstance->QueryAuthentication() & INET_INFO_AUTH_NT_AUTH)
            {
                BytesRet = sizeof(AuthPackages);
                m_securityCtx.GetInstanceAuthPackageNames(AuthPackages, &BytesRet, PkgFmtSpace);
            }

            if(BytesRet > 0)
            {
                PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL,"-AUTH %s",AuthPackages);

                if(m_pInstance->AllowLogin(ConnectionStatus))
                {
                    PE_FormatSmtpMessage(" LOGIN\r\n");
                }
                else
                {
                    PE_FormatSmtpMessage("\r\n");
                }

                if(m_pInstance->AllowLogin(ConnectionStatus))
                {
                    //For backward compatibility
                    PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL,"-AUTH=%s\r\n","LOGIN");
                }
            }
            else if(m_pInstance->AllowLogin(ConnectionStatus))
            {

                PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL,"-AUTH=LOGIN\r\n");
                PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL,"-AUTH LOGIN\r\n");
            }

            if(g_SmtpPlatformType == PtNtServer && m_pInstance->AllowTURN())
            {
                PE_CdFormatSmtpMessage (SMTP_RESP_OK, NULL,"-%s\r\n","TURN");
            }

        }
    }

    if (m_pInstance->GetMaxMsgSize() > 0)
    {
       PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL,"-%s %u\r\n","SIZE", m_pInstance->GetMaxMsgSize());
    }
    else
    {
       PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL,"-%s\r\n","SIZE");
    }

    if(g_SmtpPlatformType == PtNtServer && m_pInstance->AllowETRN())
    {
        PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL,"-%s\r\n", "ETRN");
    }

    if(m_pInstance->ShouldPipeLineIn())
    {
        PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL,"-%s\r\n","PIPELINING");
    }

    if(m_pInstance->AllowDSN())
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_OK, NULL,"-%s\r\n", "DSN");
    }

    if(m_pInstance->AllowEnhancedCodes())
    {
        PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL,"-%s\r\n", "ENHANCEDSTATUSCODES");
    }

    if(m_pInstance->AllowEightBitMime())
    {
       PE_CdFormatSmtpMessage(SMTP_RESP_OK, NULL,"-%s\r\n", "8bitmime");
    }

    // Chunking related advertisements
    if(m_pInstance->AllowBinaryMime())
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_OK, NULL,"-%s\r\n", "BINARYMIME");
        PE_CdFormatSmtpMessage (SMTP_RESP_OK, NULL,"-%s\r\n", "CHUNKING");
    }
    else if(m_pInstance->AllowChunking())
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_OK, NULL,"-%s\r\n", "CHUNKING");
    }

    // verify - we need to advertise it whether we support it or not.
    PE_CdFormatSmtpMessage (SMTP_RESP_OK, NULL,"-%s\r\n","VRFY");

    // Expand
    if(m_pInstance->AllowExpand(ConnectionStatus))
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_OK, NULL,"-%s\r\n", "EXPN");
    }



    //
    // Check that we have a certificate installed with which we can negotiate
    // a SSL session
    //
    if (!m_SecurePort && // TLS is advertized only if we haven't already negotiated it
        m_encryptCtx.CheckServerCert(
        (LPSTR) QueryLocalHostName(),
            (LPSTR) QueryLocalPortName(),
                (LPVOID) QuerySmtpInstance(),
                    QuerySmtpInstance()->QueryInstanceId()))
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_OK, NULL,"-%s\r\n","TLS");
        PE_CdFormatSmtpMessage (SMTP_RESP_OK, NULL,"-%s\r\n", "STARTTLS");
    }

    PE_CdFormatSmtpMessage (SMTP_RESP_OK, NULL," %s\r\n","OK");

}


/*++

    Name :
        SMTP_CONNECTION::DoEHLOCommand

    Description:

        Responds to the SMTP EHLO command

    Arguments:
         Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoEHLOCommand(const char * InputLine, DWORD ParametSize)
{
  BOOL RetStatus = TRUE;
  char * Args = (char *) InputLine;
  CAddr * NewAddress = NULL;
  char ProtBuff[400];

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoEHLOCommand");

  _ASSERT (m_pInstance != NULL);

  //If the current state is BDAT the only command that can be received is BDAT
  if(m_State == BDAT)
  {
      PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n","BDAT Expected" );
      BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
      ++m_ProtocolErrors;
      ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - BDAT Expected");
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
  }

  // pgopi -- don't cound multiple ehlo's as error. This is per bug 82160
  //if (m_HelloSent)
  //    ++m_ProtocolErrors;

  Args = CheckArgument(Args, !m_pInstance->ShouldAcceptNoDomain());
  if(Args != NULL)
  {
      if(m_pInstance->ShouldValidateHeloDomain())
      {
          if(!ValidateDRUMSDomain(Args, lstrlen(Args)))
          {
              //Not a valid domain -
              SetLastError(ERROR_INVALID_DATA);
              HandleAddressError((char *)InputLine);
          }
          else
          {
              //Is reverse DNS lookup enabled
              if(m_pInstance->IsReverseLookupEnabled())
              {
                  m_DNSLookupRetCode = VerifiyClient (Args, QueryClientHostName());
                  if(m_DNSLookupRetCode == NO_MATCH)
                  {
                       //We failed in DNS lookup
                      if(m_pInstance->fDisconnectOnRDNSFail())
                      {
                          PE_CdFormatSmtpMessage (SMTP_RESP_TRANS_FAILED, ENO_SECURITY," %s\r\n",SMTP_RDNS_REJECTION);
                          wsprintf(ProtBuff, "RDNS failed -  %s", (char *)QueryClientHostName());
                          BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
                          ++m_ProtocolErrors;
                          ErrorTrace((LPARAM) this, "Rejected Connection RDNS failed for %s", Args);
                          TraceFunctLeaveEx((LPARAM) this);
                          return FALSE;
                      }
                  }
                  else if(m_DNSLookupRetCode == LOOKUP_FAILED)
                  {
                      //We had an internal DNS failure
                      if(m_pInstance->fDisconnectOnRDNSFail())
                      {
                          PE_CdFormatSmtpMessage (SMTP_RESP_SRV_UNAVAIL, EINTERNAL_ERROR," %s\r\n",SMTP_RDNS_FAILURE);
                          wsprintf(ProtBuff, "RDNS  DNS failure - Ip Address is %s", (char *)QueryClientHostName());
                          BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
                          ++m_ProtocolErrors;
                          ErrorTrace((LPARAM) this, "Rejected Connection RDNS DNS failure for %s", Args);
                          TraceFunctLeaveEx((LPARAM) this);
                          return FALSE;
                      }
                      else
                      {
                          //Network/Internal problem prevented a lookup
                          wsprintf(ProtBuff, "Reverse DNS lookup failed due to internal error- Ip Address is %s", (char *)QueryClientHostName());
                      }
                  }
                  else
                  {
                      wsprintf(ProtBuff, "Reverse DNS lookup succeeded - Ip Address is %s", (char *)QueryClientHostName());
                  }
              } else {
                  m_DNSLookupRetCode = SUCCESS;
              }

              FormatEhloResponse();

              strncpy(m_szHeloAddr, Args, MAX_INTERNET_NAME);
              m_szHeloAddr[MAX_INTERNET_NAME] = '\0';
              m_HelloSent = TRUE;
              m_State = HELO;
          }
      }
      else
      {
          FormatEhloResponse();
          strncpy(m_szHeloAddr, Args, MAX_INTERNET_NAME);
          m_szHeloAddr[MAX_INTERNET_NAME] = '\0';
          m_HelloSent = TRUE;
          m_State = HELO;
      }

  }
  else if(m_pInstance->ShouldAcceptNoDomain())
  {
      FormatEhloResponse();

      if(m_szHeloAddr[0] != '\0')
      {
          m_szHeloAddr[0] = '\0';
      }

      m_HelloSent = TRUE;
      m_State = HELO;

  }

  //we can either accept the HELO or EHLO as the 1st command
  RetStatus =  PE_SendSmtpResponse();
  TraceFunctLeaveEx((LPARAM) this);
  return RetStatus;
}

/*++

    Name :
        SMTP_CONNECTION::DoHELOCommand

    Description:

        Responds to the SMTP HELO command

    Arguments:
        Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoHELOCommand(const char * InputLine, DWORD ParameterSize)
{
  char * Args = (char *) InputLine;
  CAddr * NewAddress = NULL;
  char FullName[MAX_PATH + 1];
  char ProtBuff[400];

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoHELOCommand");

  _ASSERT (m_pInstance != NULL);

  //If the current state is BDAT the only command that can be received is BDAT
  if(m_State == BDAT)
  {
      PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n","BDAT Expected" );
      BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
      ++m_ProtocolErrors;
      ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - BDAT Expected");
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
  }

  // pgopi--don't cound multiple ehlo's as error. This is per bug 82160
  //if (m_HelloSent)
  //   ++m_ProtocolErrors;

  Args = CheckArgument(Args, !m_pInstance->ShouldAcceptNoDomain());
  if(Args != NULL)
  {
      if(m_pInstance->ShouldValidateHeloDomain())
      {
          if(!ValidateDRUMSDomain(Args, lstrlen(Args)))
          {
              //Not a valid domain -
              SetLastError(ERROR_INVALID_DATA);
              HandleAddressError((char *)InputLine);
          }
          else
          {
              if(m_pInstance->IsReverseLookupEnabled())
              {
                  m_DNSLookupRetCode = VerifiyClient (Args, QueryClientHostName());
                  if(m_DNSLookupRetCode == NO_MATCH)
                  {
                       //We failed in DNS lookup
                      if(m_pInstance->fDisconnectOnRDNSFail())
                      {
                          PE_CdFormatSmtpMessage (SMTP_RESP_TRANS_FAILED, ENO_SECURITY," %s\r\n",SMTP_RDNS_REJECTION);
                          wsprintf(ProtBuff, "RDNS failed -  %s", (char *)QueryClientHostName());
                          BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
                          ++m_ProtocolErrors;
                          ErrorTrace((LPARAM) this, "Rejected Connection RDNS failed for %s", Args);
                          TraceFunctLeaveEx((LPARAM) this);
                          return FALSE;
                      }
                  }
                  else if(m_DNSLookupRetCode == LOOKUP_FAILED)
                  {
                      //We had an internal DNS failure
                      if(m_pInstance->fDisconnectOnRDNSFail())
                      {
                          PE_CdFormatSmtpMessage (SMTP_RESP_SRV_UNAVAIL, EINTERNAL_ERROR," %s\r\n",SMTP_RDNS_FAILURE);
                          wsprintf(ProtBuff, "RDNS  DNS failure - Ip Address is %s", (char *)QueryClientHostName());
                          BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
                          ++m_ProtocolErrors;
                          ErrorTrace((LPARAM) this, "Rejected Connection RDNS DNS failure for %s", Args);
                          TraceFunctLeaveEx((LPARAM) this);
                          return FALSE;
                      }
                      else
                      {
                          //Network/Internal problem prevented a lookup
                          wsprintf(ProtBuff, "Reverse DNS lookup failed due to internal error- Ip Address is %s", (char *)QueryClientHostName());
                      }
                  }
                  else
                  {
                          wsprintf(ProtBuff, "Reverse DNS lookup succeeded - Ip Address is %s", (char *)QueryClientHostName());
                  }
              } else {
                  m_DNSLookupRetCode = SUCCESS;
              }

              m_pInstance->LockGenCrit();
              strcpy(FullName, m_pInstance->GetFQDomainName());
              m_pInstance->UnLockGenCrit();

              PE_CdFormatSmtpMessage (SMTP_RESP_OK,NULL," %s %s [%s]\r\n", FullName,
                           "Hello", QueryClientHostName());

              strncpy(m_szHeloAddr, Args, MAX_INTERNET_NAME);
              m_szHeloAddr[MAX_INTERNET_NAME] = '\0';
              m_HelloSent = TRUE;
              m_State = HELO;
          }
      }
      else
      {
          m_pInstance->LockGenCrit();
          strcpy(FullName, m_pInstance->GetFQDomainName());
          m_pInstance->UnLockGenCrit();
          PE_CdFormatSmtpMessage (SMTP_RESP_OK,NULL," %s %s [%s]\r\n", FullName,
                           "Hello", QueryClientHostName());
          strncpy(m_szHeloAddr, Args, MAX_INTERNET_NAME);
          m_szHeloAddr[MAX_INTERNET_NAME] = '\0';
          m_HelloSent = TRUE;
          m_State = HELO;
      }
  }
  else if(m_pInstance->ShouldAcceptNoDomain())
  {
    m_pInstance->LockGenCrit();
    lstrcpy(FullName, m_pInstance->GetFQDomainName());
    m_pInstance->UnLockGenCrit();

    PE_CdFormatSmtpMessage (SMTP_RESP_OK,NULL," %s %s [%s]\r\n", FullName,
                       "Hello", QueryClientHostName());

    if(m_szHeloAddr[0] != '\0')
    {
       m_szHeloAddr[0] = '\0';
    }

    m_HelloSent = TRUE;
    m_State = HELO;

  }

  TraceFunctLeaveEx((LPARAM) this);
  return TRUE;
}

/*++

    Name :
        SMTP_CONNECTION::DoRSETCommand

    Description:

        Responds to the SMTP RSET command.
        Deletes all stored info, and resets
        all flags.

    Arguments:
        Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoRSETCommand(const char * InputLine, DWORD parameterSize)
{

    BOOL RetStatus;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoRSETCommand");

    _ASSERT (m_pInstance != NULL);

    m_State = HELO;
    m_TotalMsgSize = 0;
    m_cbDotStrippedTotalMsgSize = 0;
    m_RecvdMailCmd = FALSE;
    m_HeaderSize = 0;
    m_InHeader = TRUE;
    m_LongBodyLine = FALSE;
    m_fFoundEmbeddedCrlfDotCrlf = FALSE;
    m_fScannedForCrlfDotCrlf = FALSE;
    m_fSeenRFC822FromAddress = FALSE;
    m_fSeenRFC822ToAddress = FALSE;
    m_fSeenRFC822CcAddress = FALSE;
    m_fSeenRFC822BccAddress = FALSE;
    m_fSeenRFC822Subject = FALSE;
    m_fSeenRFC822MsgId = FALSE;
    m_fSeenXPriority = FALSE;
    m_fSeenXOriginalArrivalTime = FALSE;
    m_fSeenContentType = FALSE;
    m_fSetContentType = FALSE;
    m_TimeToRewriteHeader = TRUE;
    m_MailBodyError = NO_ERROR;
    m_RecvdRcptCmd = FALSE;
    m_CurrentOffset = 0;
    m_HopCount = 0;
    m_LocalHopCount = 0;
    m_fIsLastChunk = FALSE;
    m_fIsBinaryMime = FALSE;
    m_fIsChunkComplete = FALSE;
    m_dwTrailerStatus = CRLF_SEEN;
    m_nChunkSize = 0;
    m_nBytesRemainingInChunk = 0;
    m_MailBodyDiagnostic = ERR_NONE;
    m_cbRecvBufferOffset = 0;
    m_ProtocolErrors = 0;
    m_fBufferFullInBDAT = FALSE;

    if(m_cbTempBDATLen)
    {
        m_cbParsable -= m_cbTempBDATLen;
        m_cbTempBDATLen = 0;
    }

    m_szFromAddress[0] = '\0';


    //Free the possible ATQ context associated with this File handle
    //This will be if we were processing BDAT before RSET
    //FreeAtqFileContext();

    ReleasImsg(TRUE);

    PE_CdFormatSmtpMessage (SMTP_RESP_OK, EPROT_SUCCESS," %s\r\n",SMTP_RSET_OK_STR);

    RetStatus= PE_SendSmtpResponse();
    TraceFunctLeaveEx((LPARAM) this);
    return RetStatus;
}

/*++

    Name :
        SMTP_CONNECTION::DoNOOPCommand

    Description:

        Responds to the SMTP NOOP command.

    Arguments:
        Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoNOOPCommand(const char * InputLine, DWORD parameterSize)
{
  BOOL RetStatus;

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoNOOPCommand");

  _ASSERT (m_pInstance != NULL);

  //send an OK
  PE_CdFormatSmtpMessage (SMTP_RESP_OK, EPROT_SUCCESS," OK\r\n");
  RetStatus = PE_SendSmtpResponse();

  if(!m_Nooped)
  {
      m_Nooped = TRUE;
  }
  else
  {
      m_ProtocolErrors++;
  }

  TraceFunctLeaveEx((LPARAM) this);
  return RetStatus;
}


/*++

    Name :
        SMTP_CONNECTION::DoETRNCommand

    Description:

        Responds to the SMTP ETRN command.

    Arguments:
        Parsed to determine the ETRN domain(s) to send mail to.

    Returns:

      TRUE in all cases. We are agreeing to give our best effort to the ETRN command
      re the protocol. Mail is not necessarily in the retry queue so it may not be delivered.


--*/
BOOL SMTP_CONNECTION::DoETRNCommand(const char * InputLine, DWORD parameterSize)
{

  BOOL      RetStatus;
  char *    Ptr = NULL;
  CHAR      szNode[SMTP_MAX_DOMAIN_NAME_LEN];
  DWORD     Ret = 0;
//  DWORD     strLen;
  BOOL      bSubDomain;
  DWORD        dwMessagesQueued;
  HRESULT    hr;
//  BOOL          bWildCard;
//  DOMAIN_ROUTE_ACTION_TYPE action;

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoETRNCommand");

  _ASSERT (m_pInstance != NULL);

  bSubDomain = FALSE;
  dwMessagesQueued = 0;
//  bWildCard = FALSE;

  //If the current state is BDAT the only command that can be received is BDAT
  if(m_State == BDAT)
  {
      PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n","BDAT Expected" );
      BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
      ++m_ProtocolErrors;
      ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - BDAT Expected");
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
  }

  //
  // check that the hello has been sent, and that we are not in the middle of sending
  // a message
  //NimishK : removed the check for HELO EHLO


  //Check if the client is secure enough
  if (!IsClientSecureEnough()) {
      ErrorTrace((LPARAM) this, "DoETRNCommand - SMTP_RESP_MUST_SECURE, Must do STARTTLS first");
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
  }

  if(!m_fAuthAnon && !m_fAuthenticated)
  {
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY, " %s\r\n", "Client was not authenticated");
        ErrorTrace((LPARAM) this, "DoDataCommand - SMTP_RESP_MUST_SECURE, user not authenticated");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
  }
  if(m_RecvdMailCmd)
  {
     PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR," %s\r\n", SMTP_NO_ETRN_IN_MSG);
     BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
     ++m_ProtocolErrors;
     ErrorTrace((LPARAM) this, "In DoETRNCommand():SMTP_RESP_BAD_SEQ, SMTP_NO_ETRN_IN_MSG");
     TraceFunctLeaveEx((LPARAM) this);
     return TRUE;
  }

  //start parsing from the beginning of the line
  Ptr = (char *) InputLine;

  //check if argument have the right format (at least one parameter)
  Ptr = CheckArgument(Ptr);
  if (Ptr == NULL)
  {
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
  }

  // remove any whitespace
  while((isspace (*Ptr)))
  {
      Ptr++;
  }


  // check for ETRN subdomain character
  if (*Ptr == '@')
  {
      //We could probably move this check to aqueue or keep it here
    if (!(QuerySmtpInstance()->AllowEtrnSubDomains()))
    {
     PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS," %s\r\n", "Invalid domain name");
     BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
     ++m_ProtocolErrors;
     ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_ARGS - Invalid domain name");
     TraceFunctLeaveEx((LPARAM) this);
     return TRUE;
    }

    bSubDomain = TRUE;
  }

  // for @ command, check that this is at least a second tier domain (to avoid @com attack)
  if (bSubDomain)
  {
    if (!strchr(Ptr,'.'))
    {
     PE_CdFormatSmtpMessage (SMTP_RESP_NODE_INVALID, EINVALID_ARGS," Node %s not allowed: First tier domain\r\n", Ptr);
     BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
     ++m_ProtocolErrors;
     ErrorTrace((LPARAM) this, "SMTP_RESP_NODE_INVALID - First tier domains are not allowed");
     TraceFunctLeaveEx((LPARAM) this);
     return TRUE;
    }

  }

  lstrcpyn(szNode, Ptr, AB_MAX_DOMAIN);
  char *szTmp;
  if (bSubDomain)
      szTmp = szNode + 1;
  else
      szTmp = szNode;

  if(!ValidateDRUMSDomain(szTmp, lstrlen(szTmp)))
  {
     //Not a valid domain -
     SetLastError(ERROR_INVALID_DATA);

     PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS," %s\r\n", "Invalid domain name");
     BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
     ++m_ProtocolErrors;
     ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_ARGS - Invalid domain name");
     TraceFunctLeaveEx((LPARAM) this);
     return TRUE;
  }

  //So we have a valid domain
  //Call into connection manager to start the queue
  //If multiple domains were dequed because the domain name was either wild card
  //or specifed with the @ sign
  hr = m_pInstance->GetConnManPtr()->ETRNDomain(lstrlen(szNode),szNode, &dwMessagesQueued);

  if(!FAILED(hr))
  {
      //We know about this ETRN domain
      if(!dwMessagesQueued)
      {
          if (bSubDomain || hr == AQ_S_SMTP_WILD_CARD_NODE)
          {
              PE_CdFormatSmtpMessage (SMTP_RESP_ETRN_ZERO_MSGS, EPROT_SUCCESS," Ok, no messages waiting for node %s and sub nodes\r\n",
                                                         szNode);
          }
          else
          {
              PE_CdFormatSmtpMessage (SMTP_RESP_ETRN_ZERO_MSGS, EPROT_SUCCESS," Ok, no messages waiting for node %s\r\n", szNode);
          }
      }
      else
      {
          if (bSubDomain || hr == AQ_S_SMTP_WILD_CARD_NODE)
          {
                PE_CdFormatSmtpMessage (SMTP_RESP_ETRN_N_MSGS, EPROT_SUCCESS,
                                    " OK, %d pending messages for wildcard node %s started\r\n", dwMessagesQueued, szNode);
          }
          else
          {
                PE_CdFormatSmtpMessage (SMTP_RESP_ETRN_N_MSGS, EPROT_SUCCESS,
                                    " OK, %d pending messages for node %s started\r\n",dwMessagesQueued, szNode);
          }
      }
  }
  else
  {
      if (hr == AQ_E_SMTP_ETRN_NODE_INVALID)
      {
          PE_CdFormatSmtpMessage (SMTP_RESP_NODE_INVALID, EINVALID_ARGS," Node %s not allowed: not configured as ETRN domain\r\n", szNode);
          BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
            ++m_ProtocolErrors;
            ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_ARGS - Domain not allowed");
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
      }
      else
      {
          PE_CdFormatSmtpMessage (SMTP_RESP_ERROR, EINTERNAL_ERROR," Action aborted - internal error\r\n");
          BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
            ErrorTrace((LPARAM) this, "Internal error ETRN processing");
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
      }
  }


  RetStatus = PE_SendSmtpResponse();

  TraceFunctLeaveEx((LPARAM) this);
  return RetStatus;

}

/*++

    Name :
        SMTP_CONNECTION::DoSTARTTLSCommand

    Description:

        Responds to the SMTP STARTTLS command.

    Arguments:
        Parsed to determine the TLS protocol to use.

    Returns:

      TRUE normally. A FALSE return indicates to the caller that the
      client connection should be dropped.

--*/
BOOL SMTP_CONNECTION::DoSTARTTLSCommand(const char * InputLine, DWORD parameterSize)
{
  BOOL RetStatus, fStartSSL;
  char * Ptr = NULL;

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoSTARTTLSCommand");

  _ASSERT (m_pInstance != NULL);

  fStartSSL = FALSE;

  //
  // check that the hello has been sent, and that we are not in the middle of sending
  // a message
  //
  if(!m_pInstance->AllowMailFromNoHello() && !m_HelloSent)
  {
     PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n","Send hello first" );
     ProtocolLog(STARTTLS, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
     BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
     ++m_ProtocolErrors;
     ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - Send hello first");
     TraceFunctLeaveEx((LPARAM) this);
     return TRUE;
  }

  //
  // Check that we have a certificate installed with which we can negotiate
  // a SSL session
  //

  if (!m_encryptCtx.CheckServerCert(
        (LPSTR) QueryLocalHostName(),
            (LPSTR) QueryLocalPortName(),
                (LPVOID) QuerySmtpInstance(),
                    QuerySmtpInstance()->QueryInstanceId())) {
     PE_CdFormatSmtpMessage (SMTP_RESP_TRANS_FAILED, ENO_SECURITY," %s\r\n", SMTP_NO_CERT_MSG);
     ProtocolLog(STARTTLS, (char *)InputLine, NO_ERROR, SMTP_RESP_TRANS_FAILED, 0, 0);
     ErrorTrace((LPARAM) this, "In DoSTARTTLSCommand():SMTP_RESP_TRANS_FAILED, SMTP_NO_CERT_MSG");
     TraceFunctLeaveEx((LPARAM) this);
     return TRUE;
  }

  //
  // if we are already secure, reject the request
  //
  if(m_SecurePort)
  {
     PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR," %s\r\n", SMTP_ONLY_ONE_TLS_MSG);
     ProtocolLog(STARTTLS, (char *)InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
     BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
     ++m_ProtocolErrors;
     ErrorTrace((LPARAM) this, "In DoSTARTTLSCommand():SMTP_RESP_BAD_SEQ, SMTP_ONLY_ONE_TLS_MSG");
     TraceFunctLeaveEx((LPARAM) this);
     return TRUE;
  }

  //
  // Switch over to using a large receive buffer, because a SSL fragment
  // may be up to 32K big.
  fStartSSL = SwitchToBigSSLBuffers();
  if (fStartSSL) {
      PE_CdFormatSmtpMessage(SMTP_RESP_READY, EPROT_SUCCESS," %s\r\n",  SMTP_READY_STR);
      ProtocolLog(STARTTLS, (char *) InputLine, NO_ERROR, SMTP_RESP_READY, 0, 0);
  } else {
      PE_CdFormatSmtpMessage(SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n", SMTP_NO_MEMORY);
      ProtocolLog(STARTTLS, (char *) InputLine, NO_ERROR, SMTP_RESP_NORESOURCES, 0, 0);
  }
  fStartSSL = TRUE;

  RetStatus = PE_SendSmtpResponse();

  if (fStartSSL)
      m_SecurePort = m_fNegotiatingSSL = TRUE;

  TraceFunctLeaveEx((LPARAM) this);
  return RetStatus;
}

BOOL SMTP_CONNECTION::DoTLSCommand(const char * InputLine, DWORD parameterSize)
{
    return DoSTARTTLSCommand(InputLine, parameterSize);
}

//
// the default handler for end of data.  commit the recipients list and
// insert the message into the queue
//
BOOL SMTP_CONNECTION::Do_EODCommand(const char * InputLine, DWORD parameterSize)
{
    TraceFunctEnter("SMTP_CONNECTION::Do_EODCommand");

    HRESULT hr;
    char MessageId[1024];
    BOOL fQRet;

    MessageId[0] = 0;

    if( m_pIMsg )
    {
        m_pIMsg->GetStringA( IMMPID_MP_RFC822_MSG_ID, sizeof( MessageId ), MessageId );
    }

    MessageId[sizeof(MessageId)-1] = 0; // NULL terminate it.

    if(m_HopCount >= m_pInstance->GetMaxHopCount())
    {
        fQRet = m_pInstance->SubmitFailedMessage(m_pIMsg, MESSAGE_FAILURE_HOP_COUNT_EXCEEDED, 0);
        FatalTrace((LPARAM) this, "Hop count exceeded");
    }
    else
    {
        // check to see if we need to hold this message
        if (m_LocalHopCount >= 2) // if we're hitting this server for the 3rd time (or more)
        {
            if( m_pIMsg )
            {
                // Update the deferred delivery time property for this message
                SYSTEMTIME      SystemTime;
                ULARGE_INTEGER  ftDeferred; // == FILETIME
                DWORD           cbProp = 0;
                BOOL            fSuccess;

                // Get the current system time
                GetSystemTime (&SystemTime);

                // Convert it to a file time
                fSuccess = SystemTimeToFileTime(&SystemTime, (FILETIME*)&ftDeferred);
                _ASSERT(fSuccess);

                // Add 10 minutes
                ftDeferred.QuadPart += SMTP_LOOP_DELAY;

                hr = m_pIMsg->PutProperty(IMMPID_MP_DEFERRED_DELIVERY_FILETIME,
                                          sizeof(FILETIME), (BYTE *) &ftDeferred);

                DebugTrace( (LPARAM)this, "Possible Loop : Delaying message 10 minutes");
            }
        }

        fQRet = m_pInstance->InsertIntoQueue(m_pIMsg);
    }

    if(fQRet)
    {
       ReleasImsg(FALSE);
    }
    else
    {
          m_MailBodyError = GetLastError();
          //FatalTrace((LPARAM) this, "SetEndOfFile failed on file %s !!! (err=%d)", MailInfo->GetMailFileName(), m_MailBodyError);
          m_CInboundContext.SetWin32Status(m_MailBodyError);
          FormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_STORAGE );
          SendSmtpResponse();
          TraceFunctLeaveEx((LPARAM) this);
          return FALSE;
    }

    //Get the offset of the filename and send it back to the client
    //we send the status back to the client immediately, just incase
    //the session breaks abnormally, or because the client times out.
    //If the client times out, it would send another message and we
    //would get duplicate mail messages.

    //Note that the response string is limited in length, so we'll truncate
    //the MessageId if it is too long. Otherwise the reponse will be truncated
    //elsewhere, like before the SMTP_QUEUE_MAIL string which will be confusing.
    //MAX_REWRITTEN_MSGID is actually the maximum possible length of the entire
    //"Message-ID: xxx" header in a message.

    _ASSERT(sizeof(MessageId)/sizeof(char) > MAX_REWRITTEN_MSGID);
    MessageId[MAX_REWRITTEN_MSGID] = '\0';
    PE_CdFormatSmtpMessage (SMTP_RESP_OK, EMESSAGE_GOOD, " %s %s\r\n",MessageId, SMTP_QUEUE_MAIL);

    return TRUE;
}

/*++

    Name :
        SMTP_CONNECTION::DoQUITCommand

    Description:

        Responds to the SMTP QUIT command.
        This function always returns false.
        This will stop all processing and
        delete this object.

    Arguments:
        Are ignored
    Returns:

      Always return FALSE

--*/
BOOL SMTP_CONNECTION::DoQUITCommand(const char * InputLine, DWORD parameterSize)
{

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoQUITCommand");

  _ASSERT (m_pInstance != NULL);

  //set our state
  m_State = QUIT;

  //send the quit response
  m_pInstance->LockGenCrit();
  PE_CdFormatSmtpMessage (SMTP_RESP_CLOSE, E_GOODBYE, " %s %s\r\n",m_pInstance->GetFQDomainName(), SMTP_QUIT_OK_STR);
  m_pInstance->UnLockGenCrit();

  PE_SendSmtpResponse();

  //disconnect the client
  PE_DisconnectClient();

  TraceFunctLeaveEx((LPARAM) this);
  return FALSE;
}

BOOL SMTP_CONNECTION::DoSizeCommand(char * Value, char * InputLine)
{
    DWORD EstMailSize = 0;
    DWORD EstSessionSize = 0;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoSizeCommand");

    _ASSERT (m_pInstance != NULL);

    EstMailSize = atoi (Value);
    EstSessionSize = m_SessionSize + EstMailSize;

    if (EstMailSize == 0)
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS, " %s\r\n","Invalid arguments" );
        ErrorTrace((LPARAM) this, "SMTP_RESP_MBX_SYNTAX, SMTP_BAD_CMD_STR. Client sent 0 in SIZE command");
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    //check to make sure we are going over the servers max file size
    if((m_pInstance->GetMaxMsgSize() > 0) && (EstMailSize > m_pInstance->GetMaxMsgSize()))
    {
        BOOL fShouldImposeLimit = TRUE;
        if( FAILED( m_pInstance->TriggerMaxMsgSizeEvent( GetSessionPropertyBag(), m_pIMsg, &fShouldImposeLimit ) )  || fShouldImposeLimit )
        {
            PE_CdFormatSmtpMessage (SMTP_RESP_NOSTORAGE, EMESSAGE_TOO_BIG," %s\r\n", SMTP_MAX_MSG_SIZE_EXCEEDED_MSG );
            ErrorTrace((LPARAM) this, "SMTP_RESP_NOSTORAGE, SMTP_MAX_MSG_SIZE_EXCEEDED_MSG -  %d", EstMailSize);
            ++m_ProtocolErrors;
            BUMP_COUNTER(QuerySmtpInstance(), MsgsRefusedDueToSize);
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }
    }

    // Check that the maximum session size has not been exceeded
    if((m_pInstance->GetMaxMsgSizeBeforeClose() > 0) && (EstSessionSize > m_pInstance->GetMaxMsgSizeBeforeClose()))
    {
        BOOL fShouldImposeLimit = TRUE;
        if( FAILED( m_pInstance->TriggerMaxMsgSizeEvent( GetSessionPropertyBag(), m_pIMsg, &fShouldImposeLimit ) )  || fShouldImposeLimit )
        {
            ErrorTrace((LPARAM) this, "SMTP_RESP_NOSTORAGE, SMTP_MAX_SESSION_SIZE_EXCEEDED_MSG -  %d", EstMailSize);
            BUMP_COUNTER(QuerySmtpInstance(), MsgsRefusedDueToSize);
            DebugTrace((LPARAM) this, "GetMaxMsgSizeBeforeClose()  exceeded - closing connection");
            DisconnectClient();
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }
    }


    return TRUE;
}

BOOL SMTP_CONNECTION::DoBodyCommand (char * Value, char * InputLine)
{
    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoBodyCommand");

    _ASSERT (m_pInstance != NULL);

    if(!_strnicmp(Value, (char * )"8bitmime", 8))
    {
        m_pIMsg->PutDWORD(IMMPID_MP_EIGHTBIT_MIME_OPTION, 1);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }
    else if((!_strnicmp(Value, (char * )"BINARYMIME", 10)) && m_pInstance->AllowBinaryMime())
    {
        m_fIsBinaryMime = TRUE;  //Need to get rid of this **
        m_pIMsg->PutDWORD(IMMPID_MP_BINARYMIME_OPTION, 1);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }
    else if(!_strnicmp(Value, (char * )"7bit", 4))
    {
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }
    else
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS," %s\r\n", SMTP_BAD_BODY_TYPE_STR );
        ErrorTrace((LPARAM) this, "SMTP_RESP_MBX_SYNTAX, SMTP_BAD_BODY_TYPE_STR.");
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }
}

BOOL SMTP_CONNECTION::DoRetCommand (char * Value, char * InputLine)
{
    char RetDsnValue[10];
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoRetCommand");

    _ASSERT (m_pInstance != NULL);

    //strict size checking
    if(strlen(Value) < 5)
    {
        hr = m_pIMsg->GetStringA(IMMPID_MP_DSN_RET_VALUE, sizeof(RetDsnValue), RetDsnValue);
        if(FAILED(hr))
        {
            if(!_strnicmp(Value, (char * )"FULL", 4) ||
                !_strnicmp(Value, (char * )"HDRS", 4))
            {
                hr = m_pIMsg->PutStringA(IMMPID_MP_DSN_RET_VALUE, Value);
                if(!FAILED(hr))
                {
                    TraceFunctLeaveEx((LPARAM) this);
                    return TRUE;
                }
                else
                {
                    PE_CdFormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_STORAGE );
                    ErrorTrace((LPARAM) this, "Failed to set RET value to IMSG");
                    TraceFunctLeaveEx((LPARAM) this);
                    return FALSE;
                }
            }
        }
    }

    PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS," %s\r\n","Invalid arguments" );
    ErrorTrace((LPARAM) this, "SMTP_RESP_MBX_SYNTAX, SMTP_BAD_CMD_STR. Client sent bad RET value");
    ++m_ProtocolErrors;
    TraceFunctLeaveEx((LPARAM) this);
    return FALSE;
}

BOOL SMTP_CONNECTION::IsXtext(char * Xtext)
{
    char * StartPtr = Xtext;
    char NextChar = '\0';

    while((NextChar = *StartPtr++) != '\0')
    {
        if(NextChar == '+')
        {
            NextChar = *StartPtr++;
            if(!isascii(NextChar) || !isxdigit(NextChar))
            {
                return FALSE;
            }
        }
        else if(NextChar < '!' || NextChar > '~' || NextChar == '=')
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL SMTP_CONNECTION::DoEnvidCommand (char * Value, char * InputLine)
{
    HRESULT hr = S_OK;
    char EnvidValue[105];

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoEnvidCommand");

    _ASSERT (m_pInstance != NULL);
    _ASSERT (Value != NULL);
    _ASSERT (InputLine != NULL);

    hr = m_pIMsg->GetStringA(IMMPID_MP_DSN_ENVID_VALUE, sizeof(EnvidValue), EnvidValue);
    if(FAILED(hr))
    {
        DWORD ValueLength = lstrlen(Value);

        if((ValueLength != 0) && (ValueLength <= 100))
        {
            if(IsXtext(Value))
            {
                hr = m_pIMsg->PutStringA(IMMPID_MP_DSN_ENVID_VALUE, Value);
                if(!FAILED(hr))
                {
                    TraceFunctLeaveEx((LPARAM) this);
                    return TRUE;
                }
                else
                {
                    PE_CdFormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_STORAGE );
                    ErrorTrace((LPARAM) this, "Failed to set ENVID value to IMSG");
                    TraceFunctLeaveEx((LPARAM) this);
                    return FALSE;
                }
            }
        }
    }

    PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS," %s\r\n","Invalid arguments" );
    ErrorTrace((LPARAM) this, "SMTP_RESP_MBX_SYNTAX, SMTP_BAD_CMD_STR. Client sent bad envid value");
    ++m_ProtocolErrors;
    TraceFunctLeaveEx((LPARAM) this);
    return FALSE;
}

BOOL SMTP_CONNECTION::DoNotifyCommand (char * Value, DWORD * pdwNotifyValue)
{
    *pdwNotifyValue = 0;
    char * SearchPtr = NULL;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoNotifyCommand");

    _ASSERT (Value != NULL);

    if(!strcasecmp(Value, "NEVER"))
    {
        *pdwNotifyValue = RP_DSN_NOTIFY_NEVER;
    }
    else
    {
        for(SearchPtr = Value; SearchPtr != NULL; Value = SearchPtr)
        {
            SearchPtr = strchr(SearchPtr, ',');
            if(SearchPtr != NULL)
            {
                *SearchPtr++ = '\0';
            }

            if(!strcasecmp(Value, "SUCCESS"))
            {
                *pdwNotifyValue |= RP_DSN_NOTIFY_SUCCESS;
            }
            else if(!strcasecmp(Value, "FAILURE"))
            {
                *pdwNotifyValue |= RP_DSN_NOTIFY_FAILURE;
            }
            else if(!strcasecmp(Value, "DELAY"))
            {
                *pdwNotifyValue |= RP_DSN_NOTIFY_DELAY;
            }
            else
            {
                *pdwNotifyValue = RP_DSN_NOTIFY_INVALID;
                break;
            }
        }

        if(!*pdwNotifyValue)
        {
            *pdwNotifyValue = RP_DSN_NOTIFY_INVALID;
        }
    }

    if(*pdwNotifyValue == RP_DSN_NOTIFY_INVALID)
    {
        return FALSE;
    }

    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}

BOOL SMTP_CONNECTION::DoOrcptCommand (char * Value)
{
    char * XtextPtr = NULL;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoOrcptCommand");

    _ASSERT (m_pInstance != NULL);

    DWORD ValueLength = lstrlen(Value);

    if((ValueLength != 0) && (ValueLength <= 500))
    {
        //NK** : Parse out the address type and validate it against IANA registered
        // mail address type
        if(XtextPtr = strchr(Value,';'))
        {
            if(IsXtext(XtextPtr+1))
            {
                TraceFunctLeaveEx((LPARAM) this);
                return TRUE;
            }
        }
    }

    TraceFunctLeaveEx((LPARAM) this);
    return FALSE;
}

BOOL SMTP_CONNECTION::DoSmtpArgs (char *InputLine)
{
    char * Value = NULL;
    char * EndOfLine = NULL;
    char * Cmd = NULL;
    char * LinePtr = InputLine;
    char * SearchPtr = NULL;

    while(LinePtr && *LinePtr != '\0')
    {
        //find the beginning of the keyword
        LinePtr = (char *) strchr (LinePtr, '=');
        if(LinePtr != NULL)
        {

            SearchPtr = LinePtr;
            //Cmd = LinePtr - 4;
            while( (*SearchPtr != ' ') && (*SearchPtr != '\0'))
            {
                SearchPtr--;
            }

            Cmd = SearchPtr + 1;

            *LinePtr++ = '\0';
            Value = LinePtr;

            //Back track to the beginning of the byte
            //before the size command.  If that character
            //is a space, then we need to Null terminate
            //the string there.  If it's not a space, then
            //this is an error.
            EndOfLine = Cmd - 1;
            if(*EndOfLine == ' ')
                *EndOfLine = '\0';
            else if(*EndOfLine != '\0')
            {
                continue;
            }

            LinePtr = (char *) strchr(LinePtr, ' ');
            if(LinePtr != NULL)
            {
                *LinePtr++ = '\0';
            }

            if(!strcasecmp(Cmd, "SIZE"))
            {
                if(!DoSizeCommand(Value, InputLine))
                    return FALSE;
            }
            else if(!strcasecmp(Cmd, "BODY"))
            {
                if(!DoBodyCommand (Value, InputLine))
                    return FALSE;
            }
            else if(!strcasecmp(Cmd, "RET") && m_pInstance->AllowDSN())
            {
                if(!DoRetCommand (Value, InputLine))
                    return FALSE;
            }
            else if(!strcasecmp(Cmd, "ENVID") && m_pInstance->AllowDSN())
            {
                if(!DoEnvidCommand (Value, InputLine))
                    return FALSE;
            }
            else if(!strcasecmp(Cmd, "AUTH"))
            {
                //
                //  We do not handle the AUTH= parameter on the MAIL command
                //  If the client sends this, just ignore it and keep processing
                //  In the future consider setting Value as a MailMsg prop so
                //  we can use it outbound and thus support RFC 2554 completely.
                //
            }
            else
            {
                PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS, " %s\r\n","Invalid arguments" );
                ++m_ProtocolErrors;
                return FALSE;
            }
        }
        else
        {
            PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS, " %s\r\n","Invalid arguments" );
            ++m_ProtocolErrors;
            return FALSE;
        }
    }

    return TRUE;
}

BOOL SMTP_CONNECTION::DoRcptArgs (char *InputLine, char * szORCPTval, DWORD * pdwNotifyVal)
{
    char * Value = NULL;
    char * EndOfLine = NULL;
    char * Cmd = NULL;
    char * LinePtr = InputLine;
    char * SearchPtr = NULL;
    *pdwNotifyVal = 0;
    BOOL fDoneOrcptCmd = FALSE;
    BOOL fDoneNotifyCmd = FALSE;


    while(LinePtr && *LinePtr != '\0')
    {
        if(!m_pInstance->AllowDSN())
            return FALSE;

        //find the beginning of the keyword
        LinePtr = (char *) strchr (LinePtr, '=');
        if(LinePtr != NULL)
        {

            SearchPtr = LinePtr;
            //Cmd = LinePtr - 4;
            while( (*SearchPtr != ' ') && (*SearchPtr != '\0'))
            {
                SearchPtr--;
            }

            Cmd = SearchPtr + 1;

            *LinePtr++ = '\0';
            Value = LinePtr;

            //Back track to the beginning of the byte
            //before the size command.  If that character
            //is a space, then we need to Null terminate
            //the string there.  If it's not a space, then
            //this is an error.
            EndOfLine = Cmd - 1;
            if(*EndOfLine == ' ')
                *EndOfLine = '\0';
            else if(*EndOfLine != '\0')
            {
                continue;
            }

            LinePtr = (char *) strchr(LinePtr, ' ');
            if(LinePtr != NULL)
            {
                *LinePtr++ = '\0';
            }

            if(!strcasecmp(Cmd, "NOTIFY") )
            {

                if( fDoneNotifyCmd || ( !DoNotifyCommand( Value, pdwNotifyVal ) ) )
                {
                    return FALSE;
                }

                fDoneNotifyCmd = TRUE;
            }
            else if(!strcasecmp(Cmd, "ORCPT"))
            {
                if( ( !fDoneOrcptCmd ) && DoOrcptCommand(Value))
                {
                    strcpy(szORCPTval,Value);
                    fDoneOrcptCmd = TRUE;
                }
                else
                {
                    *szORCPTval = '\0';
                    return FALSE;
                }
            }
            else
            {
                return FALSE;
            }
        }
        else
        {
            return FALSE;
        }
    }

    return TRUE;

}

//NK** : Receive header always completes sync
BOOL SMTP_CONNECTION::WriteRcvHeader(void)
{
    char * Address = NULL;
    char * VersionNum = NULL;
    CHAR  szText[2024];
    char szDateBuf [cMaxArpaDate];
    DWORD cbText =  0;
    DWORD Error = NO_ERROR;
    DWORD EstMailSize = 0;
    SYSTEMTIME  st;
    HRESULT hr;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::WriteRcvHeader");

    if(m_IMsgHandle == NULL)
    {
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    //get the name of the sender to place into the mail header
    Address =  (char *) QueryClientUserName();
    _ASSERT (Address != NULL);

    //Dump the header line into the buffer
    GetLocalTime(&st);
    GetArpaDate(szDateBuf);

    VersionNum = strchr(g_VersionString, ':');
    if(VersionNum)
    {
        VersionNum += 2;
    }
    else
    {
        VersionNum = "";
    }

    m_pInstance->LockGenCrit();
    if(m_DNSLookupRetCode == SUCCESS)
    {
        m_HeaderSize = wsprintf(szText,szFormatReceivedFormatSuccess,
                    Address, QueryClientHostName(), m_pInstance->GetFQDomainName(),
                    (m_SecurePort ? " over TLS secured channel" : ""),VersionNum,
                    Daynames[st.wDayOfWeek], szDateBuf);
    }
    else if ( m_DNSLookupRetCode == LOOKUP_FAILED)
    {
        m_HeaderSize = wsprintf(szText,szFormatReceivedFormatUnverified,
                    Address, QueryClientHostName(), m_pInstance->GetFQDomainName(),
                    (m_SecurePort ? " over TLS secured channel" : ""),VersionNum,
                    Daynames[st.wDayOfWeek], szDateBuf);
    }
    else
    {
        m_HeaderSize = wsprintf(szText,szFormatReceivedFormatFailed,
                    Address, QueryClientHostName(), m_pInstance->GetFQDomainName(),
                    (m_SecurePort ? " over TLS secured channel" : ""),VersionNum,
                    Daynames[st.wDayOfWeek], szDateBuf);
    }

    m_pInstance->UnLockGenCrit();



    //if EstMailSize > 0, then the size command was given.  If the size command was
    //given and the value was 0, we would have caught it above and would skip over
    //this peice of code.
    if (EstMailSize > 0)
    {
        if(SetFilePointer(m_IMsgHandle->m_hFile, EstMailSize + cbText,
                      NULL, FILE_BEGIN) == 0xFFFFFFFF)
        {
            Error = GetLastError();
            DWORD Offset = EstMailSize + cbText;

            //FormatSmtpMessage ("%d %s %s\r\n",SMTP_RESP_NORESOURCES, ENO_RESOURCES, SMTP_NO_STORAGE );
            //ProtocolLog(MAIL, (char *)InputLine, Error, SMTP_RESP_NORESOURCES, 0, 0);
            FatalTrace((LPARAM) this, " SetFilePointer failed - %d", GetLastError());
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }

        if(!SetEndOfFile(m_IMsgHandle->m_hFile))
        {
            Error = GetLastError();

            //ProtocolLog(MAIL, (char *)InputLine, Error, SMTP_RESP_NORESOURCES, 0, 0);
            //PE_CdFormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_STORAGE );
            FatalTrace((LPARAM) this, " SetEndOfFile failed - %d", GetLastError());
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }

        DWORD dwPointer;
        dwPointer = SetFilePointer(m_IMsgHandle->m_hFile, 0, NULL, FILE_BEGIN);

        //if we get here, this should always pass
        _ASSERT (dwPointer != 0xFFFFFFFF);
    }

    _ASSERT(m_pFileWriteBuffer);
    _ASSERT(m_pFileWriteBuffer->GetData());
    CopyMemory((m_pFileWriteBuffer->GetData() + m_cbCurrentWriteBuffer),szText,m_HeaderSize);
    m_cbCurrentWriteBuffer += m_HeaderSize;

    wsprintf(szText,"%s, %s",Daynames[st.wDayOfWeek], szDateBuf);

    hr = m_pIMsg->PutStringA(IMMPID_MP_ARRIVAL_TIME, szText);
    if(FAILED(hr))
    {
        Error = GetLastError();
        //FormatSmtpMessage ("%d %s %s\r\n",SMTP_RESP_NORESOURCES, ENO_RESOURCES, SMTP_NO_STORAGE );
        FatalTrace((LPARAM) this, " MailInfo->SetSenderToStream");
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    return TRUE;
}


/*++

    Name :
        SMTP_CONNECTION::DoMAILCommand

    Description:

        Responds to the SMTP MAIL command.
    Arguments:
        Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoMAILCommand(const char * InputLine, DWORD ParameterSize)
{
  char * Ptr = NULL;
  char * SizeCmd = NULL;
  //char * Address = NULL;
  char * Value = NULL;
  CAddr * NewAddress = NULL;
  DWORD EstMailSize = 0;
  DWORD cbText =  0;
  DWORD Error = NO_ERROR;
  BOOL FoundSizeCmd = FALSE;
  HRESULT hr = S_OK;

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoMAILCommand");

  _ASSERT (m_pInstance != NULL);

  //If the current state is BDAT the only command that can be received is BDAT
  if(m_State == BDAT)
  {
      PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n","BDAT Expected" );
      BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
      ++m_ProtocolErrors;
      ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - BDAT Expected");
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
  }

  //Check if HELO or EHELO
  if(!m_pInstance->AllowMailFromNoHello() && !m_HelloSent)
  {
     PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n", "Send hello first" );
     ErrorTrace((LPARAM) this, "DoMAILCommand - SMTP_RESP_BAD_SEQ, Send hello first");
     BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
     ++m_ProtocolErrors;
     TraceFunctLeaveEx((LPARAM) this);
     return TRUE;
  }

  if(!m_HelloSent)
  {
     m_HelloSent = TRUE;
  }

  //Check if the client is secure enough
  if (!IsClientSecureEnough())
  {
      ErrorTrace((LPARAM) this, "DoMAILCommand - SMTP_RESP_MUST_SECURE, Must do STARTTLS first");
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
  }

  if(!m_fAuthAnon && !m_fAuthenticated)
  {
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY, " %s\r\n", "Client was not authenticated");
        ErrorTrace((LPARAM) this, "DoMAILCommand - SMTP_RESP_MUST_SECURE, user not authenticated");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
  }
  //disallow mail from more than once
  if(m_RecvdMailCmd)
  {
     ++m_ProtocolErrors;
      PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n", "Sender already specified" );
      ErrorTrace((LPARAM) this, "DoMAILCommand - SMTP_RESP_BAD_SEQ, Sender already specified");
      BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
  }

  //We should reset the current hop count when we get a new mail.  If we don't
  //do this, we might NDR the mail that comes later in the session.
  m_HopCount = 0;
  m_LocalHopCount = 0;

  //start parsing from the beginning of the line
  Ptr = (char *) InputLine;

  //check if argument have the right format
  Ptr = CheckArgument(Ptr);
  if (Ptr == NULL)
  {
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
  }
  //skip over from:
  Ptr = SkipWord (Ptr, "From", 4);
  if (Ptr == NULL)
  {
    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
  }

    DWORD dwAddressLen = 0;
    DWORD dwCanonAddrLen = 0;
    char * ArgPtr = NULL;
    char * AddrPtr = NULL;
    char * CanonAddrPtr = NULL;
    char * DomainPtr = NULL;
    m_szFromAddress[0] = '\0';

    //Parse out the address and possible argumets from the input line
    if(!Extract821AddressFromLine(Ptr,&AddrPtr,&dwAddressLen,&ArgPtr))
    {
        SetLastError(ERROR_INVALID_DATA);
        HandleAddressError((char *)InputLine);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //Check if we have valid tail and address
    if(!AddrPtr)
    {
        SetLastError(ERROR_INVALID_DATA);
        HandleAddressError((char *)InputLine);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //Check for the special case <> from address
    if(dwAddressLen == 2 && *AddrPtr == '<' && *(AddrPtr+1) == '>')
    {
        //simply copy this as the validated address
        lstrcpy(m_szFromAddress,"<>");
    }
    else
    {
        //Extract the canonical address in the <local-part> "@" <domain> form
        if(!ExtractCanonical821Address(AddrPtr,dwAddressLen,&CanonAddrPtr,&dwCanonAddrLen))
        {
            SetLastError(ERROR_INVALID_DATA);
            HandleAddressError((char *)InputLine);
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
        }

        //If we have a Canonical addr - validate it
        if(CanonAddrPtr)
        {
            strncpy(m_szFromAddress,CanonAddrPtr,dwCanonAddrLen);
            *(m_szFromAddress + dwCanonAddrLen) = '\0';

            if(!Validate821Address(m_szFromAddress, dwCanonAddrLen))
            {
                HandleAddressError((char *)InputLine);
                TraceFunctLeaveEx((LPARAM) this);
                return TRUE;
            }

            //Extract
            if(!Get821AddressDomain(m_szFromAddress,dwCanonAddrLen,&DomainPtr))
            {
                SetLastError(ERROR_INVALID_DATA);
                HandleAddressError((char *)InputLine);
                TraceFunctLeaveEx((LPARAM) this);
                return TRUE;
            }
            else
            {
                //Is the RDNS enabled for MAILFROM command
                if(m_pInstance->IsRDNSEnabledForMAIL())
                {
                    DWORD dwDNSLookupRetCode = SUCCESS;
                    char  ProtBuff[255];
                    //If we have the RDNS option on MAIL from domain
                    //we cannot get a NULL domain on MAIL from
                    if(DomainPtr)
                    {
                        dwDNSLookupRetCode = VerifiyClient (DomainPtr,DomainPtr);
                        if(dwDNSLookupRetCode == NO_MATCH)
                        {
                            PE_CdFormatSmtpMessage (SMTP_RESP_REJECT_MAILFROM, ENO_SECURITY_TMP," %s\r\n",SMTP_RDNS_REJECTION);
                            wsprintf(ProtBuff, "RDNS failed -  %s", DomainPtr);
                            BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
                            ++m_ProtocolErrors;
                            ErrorTrace((LPARAM) this, "Rejected Mail From : RDNS failed for %s", DomainPtr);
                            TraceFunctLeaveEx((LPARAM) this);
                            return TRUE;
                        }
                        else if(m_DNSLookupRetCode == LOOKUP_FAILED)
                        {
                            //We had an internal DNS failure
                            PE_CdFormatSmtpMessage (SMTP_RESP_REJECT_MAILFROM, EINTERNAL_ERROR," %s\r\n",SMTP_RDNS_FAILURE);
                            wsprintf(ProtBuff, "RDNS  DNS failure - %s", DomainPtr);
                            BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
                            ++m_ProtocolErrors;
                            ErrorTrace((LPARAM) this, "Rejected MAILFROM : RDNS DNS failure for %s", DomainPtr);
                            TraceFunctLeaveEx((LPARAM) this);
                            return TRUE;
                        }
                    }
                    else
                    {
                        PE_CdFormatSmtpMessage (SMTP_RESP_REJECT_MAILFROM, ENO_SECURITY_TMP," %s\r\n",SMTP_RDNS_REJECTION);
                        wsprintf(ProtBuff, "RDNS failed - no domain specified");
                        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
                        ++m_ProtocolErrors;
                        ErrorTrace((LPARAM) this, "Rejected Mail From : no domain specified");
                        TraceFunctLeaveEx((LPARAM) this);
                        return TRUE;
                    }
                }
            }

        }
        else
        {
            SetLastError(ERROR_INVALID_DATA);
            HandleAddressError((char *)InputLine);
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
        }



        //rewrite the address if it's not the NULL address,
        //and the masquerading option is on
        if(m_pInstance->ShouldMasquerade() && !ISNULLADDRESS(m_szFromAddress)
          && (!DomainPtr || m_pInstance->IsALocalDomain(DomainPtr)))
        {
            if(!m_pInstance->MasqueradeDomain(m_szFromAddress, DomainPtr))
            {
                //it failed.  Inform the user
                SetLastError(ERROR_INVALID_DATA);
                HandleAddressError((char *)InputLine);
                TraceFunctLeaveEx((LPARAM) this);
                return TRUE;
            }
        }
        else if(!DomainPtr && !ISNULLADDRESS(m_szFromAddress))
        {
            //If there is no domain on this address,
            //then append the current domain to this
            //address. However, if we get the <>
            //address, don't append a domain

            if(!m_pInstance->AppendLocalDomain (m_szFromAddress))
            {
                //it failed.  Inform the user
                SetLastError(ERROR_INVALID_DATA);
                HandleAddressError((char *)InputLine);
                TraceFunctLeaveEx((LPARAM) this);
                return TRUE;
            }
        }
    }


    //parse the arguments, if any
    if(!DoSmtpArgs (ArgPtr))
    {
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    _ASSERT (m_szFromAddress != NULL);
    _ASSERT (m_szFromAddress[0] != '\0');

    hr = m_pIMsg->PutStringA(IMMPID_MP_SENDER_ADDRESS_SMTP, m_szFromAddress);
    if(FAILED(hr))
    {
        Error = GetLastError();
        PE_CdFormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_STORAGE );
        m_CInboundContext.SetWin32Status(Error);
        FatalTrace((LPARAM) this, " MailInfo->SetSenderToStream");
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    hr = m_pIMsg->PutStringA(IMMPID_MP_HELO_DOMAIN, QueryClientUserName());
    if(FAILED(hr))
    {
        Error = GetLastError();
        //FatalTrace((LPARAM) this, "SetEndOfFile failed on file %s !!! (err=%d)", MailInfo->GetMailFileName(), m_MailBodyError);
        m_CInboundContext.SetWin32Status(Error);
        PE_CdFormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_STORAGE);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;

    }

    m_RecvdMailCmd = TRUE;
    m_State = MAIL;

    PE_CdFormatSmtpMessage (SMTP_RESP_OK, ESENDER_ADDRESS_VALID," %s....Sender OK\r\n", m_szFromAddress);

    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}

/*++

    Name :
        SMTP_CONNECTION::DoRCPTCommand

    Description:

        Responds to the SMTP RCPT command.
        This funcion gets the addresses and
        places then into a linked list.
    Arguments:

        InputLine - Buffer received from client
        paramterSize - amount of data in buffer
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoRCPTCommand(const char * InputLine, DWORD ParameterSize)
{
    char * ToName = NULL;
    char * ThisAddress = NULL;
    CAddr * NewAddress = NULL;
    CAddr * TempAddress = NULL;
    BOOL IsDomainValid = TRUE; //assume everyone is O.K
    BOOL RelayThisMail = FALSE;
    BOOL DropQuotaExceeded = FALSE;

    DWORD    dwPropId = IMMPID_RP_ADDRESS_SMTP;
    DWORD dwNewRecipIndex = 0;
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoRCPTCommand");

    _ASSERT(m_pInstance != NULL);

    //If the current state is BDAT the only command that can be received is BDAT
    if(m_State == BDAT)
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR," %s\r\n", "BDAT Expected" );
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - BDAT Expected");
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    if(!m_HelloSent)
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR," %s\r\n", "Send hello first" );
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - Send hello first");
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //Check if the client is secure enough
    if (!IsClientSecureEnough()) {
        ErrorTrace((LPARAM) this, "DoRcptCommand - SMTP_RESP_MUST_SECURE, Must do STARTTLS first");
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    if(!m_fAuthAnon && !m_fAuthenticated)
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY, " %s\r\n","Client was not authenticated");
        ErrorTrace((LPARAM) this, "DoRCPTCommand - SMTP_RESP_MUST_SECURE, user not authenticated");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //see if we got a valid return path before going on
    if(!m_RecvdMailCmd || !m_pIMsg || !m_pIMsgRecips || (m_szFromAddress[0] == '\0') )
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR," %s\r\n", SMTP_NEED_MAIL_FROM_MSG);
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        ErrorTrace((LPARAM) this, "In DoRCPTCommand():SMTP_RESP_BAD_SEQ, SMTP_NEED_MAIL_FROM_MSG");
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //start at inputline
    ToName = (char *) InputLine;

    //set the state
    m_State = RCPT;

    m_RecvdRcptCmd = TRUE;

    //check if argument have the right format
    ToName = CheckArgument(ToName);
    if (ToName == NULL)
    {
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    ToName = SkipWord (ToName, "To", 2);
    if (ToName == NULL)
    {
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    char * DomainPtr = NULL;
    char * ArgPtr = NULL;
    char   szRcptAddress[MAX_INTERNET_NAME + 1];
    szRcptAddress[0] = '\0';

    DWORD  dwNotifyVal;
    char   szOrcptVal[MAX_INTERNET_NAME];
    szOrcptVal[0] = '\0';


    if(!ExtractAndValidateRcpt(ToName, &ArgPtr, szRcptAddress, &DomainPtr ))
    {
        // If failed.  Inform the user
        SetLastError(ERROR_INVALID_DATA);
        HandleAddressError((char *)InputLine);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //Parse out the DSN values if any
    //parse the arguments, if any
    if(!DoRcptArgs (ArgPtr, szOrcptVal, &dwNotifyVal))
    {
        //it failed.  Inform the user
        DWORD dwError = GetLastError();
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS, " %s\r\n","Invalid arguments" );
        m_CInboundContext.SetWin32Status(dwError);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //check to see if there is any room in the inn.
    //if the remote queue entry is allocated, check
    //that also.
    DWORD TotalRcpts = 0;
    hr = m_pIMsgRecips->Count(&TotalRcpts);

    if( FAILED(hr) ||  ((m_pInstance->GetMaxRcpts() > 0) && ((TotalRcpts + 1) > m_pInstance->GetMaxRcpts())))
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_NOSTORAGE, ETOO_MANY_RCPTS, " %s\r\n",SMTP_TOO_MANY_RCPTS);
        ErrorTrace((LPARAM) this, "Exceeded MaxRcpts %d", TotalRcpts + 1);
        // don't count too many rcpts as protocol errors as this will
        // close the connection.
        //++m_ProtocolErrors;
        delete NewAddress;
        NewAddress = NULL;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //If the relay check feature is enabled make sure that this
    //recipient is to be accepted for relay
    if(m_pInstance->IsRelayEnabled())
    {
        RelayThisMail = ShouldAcceptRcpt(DomainPtr);
    }

    if (m_pInstance->IsDropDirQuotaCheckingEnabled())
    {
        //We only enforce drop dir quota checking on local and alias domains.  Since
        //this is turned on by default, we assume that anyone who has setup there own
        //non-default drop domain is has some agent the will process mail put in it.
        if (m_pInstance->IsADefaultOrAliasDropDomain(DomainPtr))
            DropQuotaExceeded = m_pInstance->IsDropDirQuotaExceeded();
    }

    ThisAddress = szRcptAddress;
    if(RelayThisMail && !DropQuotaExceeded)
    {
        hr = m_pIMsgRecips->AddPrimary(1, (LPCTSTR *) &ThisAddress, &dwPropId,
            &dwNewRecipIndex, NULL, 0);
        if(!FAILED(hr))
        {
            //If we have any associated DSn values set them
            if(szOrcptVal && szOrcptVal[0] != '\0')
            {
                hr = m_pIMsgRecips->PutStringA(dwNewRecipIndex, IMMPID_RP_DSN_ORCPT_VALUE,(LPCSTR)szOrcptVal);
                if(FAILED(hr))
                {
                    PE_CdFormatSmtpMessage (SMTP_RESP_NOSTORAGE, ENO_RESOURCES, " %s\r\n",SMTP_NO_STORAGE);
                    ErrorTrace((LPARAM) this, "Exceeded MaxRcpts %d", TotalRcpts + 1);
                }
            }

            //If we have any associated DSn values set them
            //If we have any associated DSn values set them
            if(!FAILED(hr) && dwNotifyVal & RP_DSN_NOTIFY_MASK)
            {
                //hr = m_pIMsgRecips->PutDWORD(dwNewRecipIndex, IMMPID_RP_DSN_NOTIFY_VALUE, dwNotifyVal);
                hr = m_pIMsgRecips->PutDWORD(dwNewRecipIndex,IMMPID_RP_RECIPIENT_FLAGS, dwNotifyVal);
                if(FAILED(hr))
                {
                    PE_CdFormatSmtpMessage (SMTP_RESP_NOSTORAGE, ENO_RESOURCES, " %s\r\n", SMTP_NO_STORAGE);
                    ErrorTrace((LPARAM) this, "Exceeded MaxRcpts %d", TotalRcpts + 1);
                }
            }

            if(!FAILED(hr))
            {
                PE_CdFormatSmtpMessage (SMTP_RESP_OK, EVALID_DEST_ADDRESS, " %s \r\n",szRcptAddress);
            }
        }
        else
        {
            PE_CdFormatSmtpMessage (SMTP_RESP_NOSTORAGE, ENO_RESOURCES, " %s\r\n",SMTP_NO_STORAGE);
            ErrorTrace((LPARAM) this, "Exceeded MaxRcpts %d", TotalRcpts + 1);
        }
    }
    else if (DropQuotaExceeded)
    {
        PE_CdFormatSmtpMessage (SMTP_INSUFF_STORAGE_CODE, EMAILBOX_FULL, " Mailbox full\r\n");
    }
    else
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_NOT_FOUND, ENO_FORWARDING, " Unable to relay for %s\r\n", szRcptAddress);
    }

    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}

BOOL SMTP_CONNECTION::ShouldAcceptRcpt(char * szDomainName )
{
    HRESULT     hr;
    DWORD       dwDomainInfoFlags;

    hr = m_pInstance->HrGetDomainInfoFlags(szDomainName, &dwDomainInfoFlags);
    if (SUCCEEDED(hr)) {
        if ( (dwDomainInfoFlags & DOMAIN_INFO_LOCAL_MAILBOX) ||
             (dwDomainInfoFlags & DOMAIN_INFO_ALIAS) ||
             (dwDomainInfoFlags & DOMAIN_INFO_LOCAL_DROP)) {
            return TRUE;
        }
        else if(dwDomainInfoFlags & DOMAIN_INFO_DOMAIN_RELAY) {
            return TRUE;
        }
        else if( (m_fAuthenticated && (dwDomainInfoFlags & DOMAIN_INFO_AUTH_RELAY)) ||
            DoesClientHaveIpAccess() ) {
            return TRUE;
        }
    }
    else
    {
        if(DoesClientHaveIpAccess() ||
            (m_fAuthenticated && m_pInstance->RelayForAuthUsers())) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL SMTP_CONNECTION::ExtractAndValidateRcpt(char * ToName, char ** ppArgument, char * szRcptAddress, char ** ppDomain )
{
    DWORD dwAddressLen = 0;
    DWORD dwCanonAddrLen = 0;

    char * AddrPtr = NULL;
    char * CanonAddrPtr = NULL;

    //Parse out the address and possible argumets from the input line
    if(!Extract821AddressFromLine(ToName,&AddrPtr,&dwAddressLen,ppArgument))
    {
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    //Check if we have valid tail and address
    if(!AddrPtr)
    {
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    //Extract the canonical address in the <local-part> "@" <domain> form
    if(!ExtractCanonical821Address(AddrPtr,dwAddressLen,&CanonAddrPtr,&dwCanonAddrLen))
    {
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    //If we have a Canonical addr - validate it
    if(CanonAddrPtr)
    {
        strncpy(szRcptAddress,CanonAddrPtr,dwCanonAddrLen);
        *(szRcptAddress + dwCanonAddrLen) = '\0';

        if(!Validate821Address(szRcptAddress, dwCanonAddrLen))
        {
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }

        //Extract
        if(!Get821AddressDomain(szRcptAddress,dwCanonAddrLen,ppDomain))
        {
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }
    }
    else
    {
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    if(!(*ppDomain) && !ISNULLADDRESS(szRcptAddress))
    {
        //If there is no domain on this address,
        //then append the current domain to this
        //address.
        if(!m_pInstance->AppendLocalDomain (szRcptAddress))
        {
            return FALSE;
        }
        //Update the DomainPtr to be after the '@' sign
        //we could be safer and do a strchr
        (*ppDomain) = szRcptAddress + dwCanonAddrLen + 1;
    }
    return TRUE;
}

BOOL SMTP_CONNECTION::BindToStoreDrive(void)
{
    SMTP_ALLOC_PARAMS AllocParams;
    DWORD Error = 0;
    BOOL fRet = FALSE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::BindToStore");

    AllocParams.BindInterfacePtr = (PVOID) m_pBindInterface;
    AllocParams.IMsgPtr = (PVOID) m_pIMsg;
    AllocParams.hContent = NULL;
    AllocParams.hr = S_OK;
    //For client context pass in something that will stay around the lifetime of the
    //atqcontext -
    AllocParams.pAtqClientContext = m_pInstance;

    if(m_pInstance->AllocNewMessage (&AllocParams) && !FAILED(AllocParams.hr))
    {
        m_IMsgHandle = AllocParams.hContent;

        if(WriteRcvHeader())
        {
            fRet = TRUE;
        }
        else
        {
            Error = GetLastError();
            //ProtocolLog(, (char *)InputLine, Error, SMTP_RESP_NORESOURCES, 0, 0);
            FatalTrace((LPARAM) this, "WriteRcvHeader failed %d", Error);
            SetLastError(Error);
        }
    }

    TraceFunctLeaveEx((LPARAM) this);
    return fRet;
}

/*++

    Name :
        SMTP_CONNECTION::DoDATACommand

    Description:

        Responds to the SMTP DATA command.
    Arguments:

        InputLine - Buffer received from client
        paramterSize - amount of data in buffer

        both are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoDATACommand(const char * InputLine, DWORD parameterSize)
{
    HRESULT hr = S_OK;
    DWORD TotalRcpts = 0;
    DWORD fIsBinaryMime = 0;
    DWORD Error = 0;

  _ASSERT(m_pInstance != NULL);

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoDATACommand");

  //If the current state is BDAT the only command that can be received is BDAT
  if(m_State == BDAT)
  {
      PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n","BDAT Expected" );
      ProtocolLog(DATA, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
      BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
      ++m_ProtocolErrors;
      ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - BDAT Expected");
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
  }

  if(m_pIMsgRecips && m_pIMsg)
  {
    hr = m_pIMsgRecips->Count(&TotalRcpts);

    if(!FAILED(hr))
    {
        m_pIMsg->PutDWORD( IMMPID_MP_NUM_RECIPIENTS, TotalRcpts );

        hr = m_pIMsg->GetDWORD(IMMPID_MP_BINARYMIME_OPTION, &fIsBinaryMime);
    }
  }



  // Cannot use the DATA command if the body type was BINARYMIME
  if(!FAILED(hr) && fIsBinaryMime)
  {
    PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n", "Body type BINARYMIME requires BDAT" );
    ProtocolLog(DATA, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
    ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_ARGS - Body type BINARYMIME requires BDAT");
    BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
    ++m_ProtocolErrors;
  }

  //Only save data if HELO was sent and there is at least one recipient.
  //send a message stating "no good recepients",
  //or something like that if both lists are empty.
  else if(!m_HelloSent)
  {
     PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n", "Send hello first" );
     ProtocolLog(DATA, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
     ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - Send hello first");
     BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
     ++m_ProtocolErrors;
  }
  else if (!IsClientSecureEnough())
  {
        ErrorTrace((LPARAM) this, "DoDataCommand - SMTP_RESP_MUST_SECURE, Must do STARTTLS first");
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
  }
  else if(!m_fAuthAnon && !m_fAuthenticated)
  {
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY, " %s\r\n", "Client was not authenticated");
        ProtocolLog(DATA, (char *) InputLine, NO_ERROR, SMTP_RESP_MUST_SECURE, 0, 0);
        ErrorTrace((LPARAM) this, "DoDataCommand - SMTP_RESP_MUST_SECURE, user not authenticated");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
  }
  else if (!m_RecvdMailCmd || !m_pIMsg)
  {
    PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n","Need mail command." );
    ProtocolLog(DATA, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
    ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - Need mail command.");
    BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
    ++m_ProtocolErrors;
  }
  else if(TotalRcpts)
  {
    m_cbCurrentWriteBuffer = 0;
    if(BindToStoreDrive())
    {
        m_State = DATA;
        if(!m_pInstance->ShouldParseHdrs())
        {
            m_TimeToRewriteHeader = FALSE;
            m_InHeader = FALSE;
        }
        PE_CdFormatSmtpMessage (SMTP_RESP_START, NULL," %s\r\n",SMTP_START_MAIL_STR);
    }
    else
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_MEMORY);
        m_CInboundContext.SetWin32Status(ERROR_NOT_ENOUGH_MEMORY);
        ProtocolLog(DATA, (char *)InputLine, ERROR_NOT_ENOUGH_MEMORY, SMTP_RESP_NORESOURCES, 0, 0);
        SmtpLogEventEx(SMTP_EVENT_INVALID_MAIL_QUEUE_DIR, "Invalid MailQueue Directory", GetLastError());
        ErrorTrace((LPARAM) this, "DoDataCommand - SMTP_RESP_NORESOURCES, SMTP_NO_MEMORY - MailInfo = new MAILQ_ENTRY () failed");
    }
  }
  else if (!m_RecvdRcptCmd)
  {
     PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR," %s\r\n", "Need Rcpt command." );
     ProtocolLog(DATA, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
     ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - Need Rcpt command.");
     BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
     ++m_ProtocolErrors;
  }
  else
  {
    PE_CdFormatSmtpMessage (SMTP_RESP_TRANS_FAILED, ESYNTAX_ERROR," %s\r\n", SMTP_NO_VALID_RECIPS );
    ProtocolLog(DATA, (char *) InputLine, NO_ERROR, SMTP_RESP_TRANS_FAILED, 0, 0);
    ErrorTrace((LPARAM) this, "SMTP_RESP_TRANS_FAILED, SMTP_NO_VALID_RECIPS");
    ++m_ProtocolErrors;
  }

  TraceFunctLeaveEx((LPARAM) this);
  return TRUE;
}

/*++

    Name :
        SMTP_CONNECTION::DoBDATCommand

    Description:

        Responds to the SMTP BDAT command. Parses to check if this
        is the last BDAT.

        Error processing for BDAT is more complex than other SMTP commands
        because the RFC forbids a response to BDAT (even error responses that
        the server cannot process BDAT). If we try to send an error  response
        immediately after a BDAT command, we will go out of sync with the
        client because the client is not expecting a response... it is trying
        to send us chunk data, and the client expects us to have posted a TCP
        read to receive the chunk data.

        Errors handled by this function fall into 2 categories:

        (1) Errors by the client, such as sending improperly formatted
            chunksizes, bad syntax for the BDAT command.

        (2) Errors such as failure to allocate memory, restrictions on session
            size and message size, client must authenticate first, client must
            negotiate TLS first, etc.

        In the first case, we can reject the command with an error response,
        if the BDAT command is garbled, there's not much we can do.


        In the second case, we can generate a reasonable error response to be
        sent to the client. We should wait for our turn before doing so, i.e.
        we should accept and discard the BDAT chunks sent by the client, and
        when it it time to ack the chunk, then we send the error response. This
        is implemented by setting the m_MailBodyDiagnostic to the appropriate error, and
        calling AcceptAndDiscardBDAT which handles receiving and discarding
        chunk data and generating error responses when appropriate.
            
    Arguments:

        InputLine - Buffer received from client
        paramterSize - amount of data in buffer

    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoBDATCommand(const char * InputLine, DWORD parameterSize)
{

  HRESULT hr = S_OK;
  DWORD TotalRcpts = 0;
  MailBodyDiagnosticCode mailBodyDiagnostic = ERR_NONE;

  _ASSERT(m_pInstance != NULL);

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoBDATCommand");

  if(m_pIMsgRecips && m_pIMsg)
  {
      hr = m_pIMsgRecips->Count(&TotalRcpts);
      m_pIMsg->PutDWORD( IMMPID_MP_NUM_RECIPIENTS, TotalRcpts );
  }

  //We parse this command ONLY if we advertise either chunking or binarymime
  if(!m_pInstance->AllowChunking() && !m_pInstance->AllowBinaryMime())
  {
      PE_CdFormatSmtpMessage (SMTP_RESP_BAD_CMD, EINVALID_COMMAND," %s\r\n", SMTP_NOT_IMPL_STR);
      ErrorTrace((LPARAM) this, "DoBDATCommand - SMTP_RESP_BAD_CMD, SMTP_NOT_IMPL_STR");
      BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
      ++m_ProtocolErrors;
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
  }

  if(!m_HelloSent)
  {
      ProtocolLog(BDAT, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
      ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - Send hello first");
      BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
      ++m_ProtocolErrors;
      mailBodyDiagnostic = ERR_HELO_NEEDED;
  }
  else if(!m_fAuthAnon && !m_fAuthenticated)
  {
        ProtocolLog(BDAT, (char *) InputLine, NO_ERROR, SMTP_RESP_MUST_SECURE, 0, 0);
        ErrorTrace((LPARAM) this, "DoBDATCommand - SMTP_RESP_MUST_SECURE, user not authenticated");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        mailBodyDiagnostic = ERR_AUTH_NEEDED;
  }
  else if (!m_RecvdMailCmd || !m_pIMsg)
  {
      ProtocolLog(BDAT, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
      ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - Need mail command.");
      BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
      ++m_ProtocolErrors;
      mailBodyDiagnostic = ERR_MAIL_NEEDED;
  }
  else if (!m_RecvdRcptCmd)
  {
      ProtocolLog(BDAT, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
      ErrorTrace((LPARAM) this, "SMTP_RESP_BAD_SEQ - Need Rcpt command.");
      BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
      ++m_ProtocolErrors;
      mailBodyDiagnostic = ERR_RCPT_NEEDED;
  }
  else if (FAILED(hr) || 0 == TotalRcpts)
  {
    ProtocolLog(BDAT, (char *) InputLine, NO_ERROR, SMTP_RESP_TRANS_FAILED, 0, 0);
    ErrorTrace((LPARAM) this, "SMTP_RESP_TRANS_FAILED, SMTP_NO_VALID_RECIPS");
    ++m_ProtocolErrors;
    mailBodyDiagnostic = ERR_NO_VALID_RCPTS;
  }

    char * Argument = (char *) InputLine;
    DWORD dwEstMsgSize = 0;
    DWORD dwEstSessionSize = 0;

    m_nChunkSize = 0;
    m_nBytesRemainingInChunk = 0;

    // Just parse for size and if this is last chunk
    Argument = CheckArgument(Argument);
    if (Argument == NULL)
    {
        ProtocolLog(BDAT, (char *)InputLine, NO_ERROR, SMTP_RESP_MBX_SYNTAX, 0,0);
        ErrorTrace((LPARAM) this, "DoBDATCommand - SMTP_RESP_MBX_SYNTAX, Client sent no CHUNK SIZE");
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    // make sure the argument is all digits
    BOOL fBadChunkSize = FALSE;
    for( int i=0; ( ( Argument[i] != 0 ) && ( Argument[i] != ' ' ) ) ; i++ )
    {
        if( !isdigit( Argument[i] ) )
        {
            fBadChunkSize = TRUE;
            break;
        }
    }



    // Get the chunk size
    m_nChunkSize = atoi (Argument);
    m_nBytesRemainingInChunk = m_nChunkSize + m_cbTempBDATLen;

    if( ( m_nChunkSize <= 0 ) || fBadChunkSize )
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_MBX_SYNTAX, ESYNTAX_ERROR," %s\r\n","Invalid CHUNK size value" );
        ProtocolLog(BDAT, (char *)InputLine, NO_ERROR, SMTP_RESP_MBX_SYNTAX, 0,0);
        ErrorTrace((LPARAM) this, "DoBDATCommand - SMTP_RESP_MBX_SYNTAX, Client sent 0 as CHUNK SIZE");
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    // Add this to the mail already received
    // check to make sure we are not going over the servers max message size

    dwEstSessionSize = m_nChunkSize + m_SessionSize;
    dwEstMsgSize = m_nChunkSize +  m_TotalMsgSize;

    if(ERR_NONE == mailBodyDiagnostic)
    {
        if((m_pInstance->GetMaxMsgSize() > 0) && (dwEstMsgSize > m_pInstance->GetMaxMsgSize()))
        {
            BOOL fShouldImposeLimit = TRUE;
            if( FAILED( m_pInstance->TriggerMaxMsgSizeEvent( GetSessionPropertyBag(), m_pIMsg, &fShouldImposeLimit ) ) || fShouldImposeLimit )
            {
                ProtocolLog(BDAT, (char *)InputLine, NO_ERROR, SMTP_RESP_NOSTORAGE, 0, 0);
                ErrorTrace((LPARAM) this, "SMTP_RESP_NOSTORAGE, SMTP_MAX_MSG_SIZE_EXCEEDED_MSG -  %d", dwEstMsgSize);
                ++m_ProtocolErrors;
                BUMP_COUNTER(QuerySmtpInstance(), MsgsRefusedDueToSize);
                mailBodyDiagnostic = ERR_MAX_MSG_SIZE;
            }
        }
    }

    // Check that we are below the max session size allowed on the Server.
    if((m_pInstance->GetMaxMsgSizeBeforeClose() > 0) && (dwEstSessionSize > m_pInstance->GetMaxMsgSizeBeforeClose()))
    {
        BOOL fShouldImposeLimit = TRUE;
        if( FAILED( m_pInstance->TriggerMaxMsgSizeEvent( GetSessionPropertyBag(), m_pIMsg, &fShouldImposeLimit ) ) || fShouldImposeLimit )
        {
            ProtocolLog(BDAT, (char *)InputLine, NO_ERROR, SMTP_RESP_NOSTORAGE, 0, 0);
            ErrorTrace((LPARAM) this, "SMTP_RESP_NOSTORAGE, SMTP_MAX_SESSION_SIZE_EXCEEDED_MSG -  %d", dwEstSessionSize);
            BUMP_COUNTER(QuerySmtpInstance(), MsgsRefusedDueToSize);
            DisconnectClient();
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
        }
    }

    //Check for the presence of the LAST keyword
    Argument = strchr(Argument,' ');
    if(Argument != NULL)
    {
        //get rid of white space
        while(isspace(*Argument))
            Argument++;

        if(*Argument != '\0')
        {
            if(!_strnicmp(Argument,(char *)"LAST",4))
            {
                //This is the last BDAT chunk
                m_fIsLastChunk = TRUE;
            }

            else
            {
                PE_CdFormatSmtpMessage (SMTP_RESP_MBX_SYNTAX, ESYNTAX_ERROR," %s\r\n", "Invalid CHUNK size value" );
                ProtocolLog(BDAT, (char *)InputLine, NO_ERROR, SMTP_RESP_MBX_SYNTAX, 0,0);
                ErrorTrace((LPARAM) this, "DoBDATCommand - SMTP_RESP_MBX_SYNTAX, Client sent 0 as CHUNK SIZE");
                ++m_ProtocolErrors;
                TraceFunctLeaveEx((LPARAM) this);
                return TRUE;
            }
        }
    }

    m_fIsChunkComplete = FALSE;

    if(m_State != BDAT)
    {
        //we are here for the first time
        m_State = BDAT;
        m_cbCurrentWriteBuffer = 0;

        // If there was an error while processing this BDAT command, flag it (m_MailBodyDiagnostic) & exit.
        m_MailBodyDiagnostic = mailBodyDiagnostic;

        if(mailBodyDiagnostic != ERR_NONE)
            goto Exit;

        if(!BindToStoreDrive())
        {
            //
            // Cannot process BDAT due to error accessing mail-store. Flag the error & exit.
            //

            m_MailBodyError = ERROR_NOT_ENOUGH_MEMORY;
            m_MailBodyDiagnostic = ERR_OUT_OF_MEMORY;
            m_CInboundContext.SetWin32Status(ERROR_NOT_ENOUGH_MEMORY);
            ProtocolLog(BDAT, (char *)InputLine, ERROR_NOT_ENOUGH_MEMORY, SMTP_RESP_NORESOURCES, 0, 0);
            ErrorTrace((LPARAM) this, "DoBDATCommand - SMTP_RESP_NORESOURCES, SMTP_NO_MEMORY - Allocating stream failed");
            SmtpLogEventEx(SMTP_EVENT_INVALID_MAIL_QUEUE_DIR , "Invalid Mail Queue Directory", GetLastError());
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
        }
    }

    //
    // If there was an error during this BDAT, flag it... but if there was an error in a
    // previous BDAT command (within the same group of BDATs), preserve it. Once a BDAT fails,
    // all subsequent BDATs will fail. m_MailBodyDiagnostic is reset only when a new BDAT group is
    // started (the first BDAT in a group of BDATs or RSET).
    //

    if(m_MailBodyDiagnostic == ERR_NONE) // Don't overwrite
        m_MailBodyDiagnostic = mailBodyDiagnostic; // Error during this BDAT

    if(m_MailBodyDiagnostic != ERR_NONE) // Should this BDAT succeed?
        goto Exit;


    // There is no response for BDAT command
    if(!m_pInstance->ShouldParseHdrs())
    {
        m_TimeToRewriteHeader = FALSE;
        m_InHeader = FALSE;
    }

Exit:
  TraceFunctLeaveEx((LPARAM) this);
  return TRUE;
}

void SMTP_CONNECTION::ReleasRcptList(void)
{
    IMailMsgRecipients * pRcptList = NULL;
    IMailMsgRecipientsAdd * pRcptListAdd = NULL;

    pRcptListAdd = (IMailMsgRecipientsAdd *) InterlockedExchangePointer((PVOID *) &m_pIMsgRecips, (PVOID) NULL);
    if (pRcptListAdd != NULL)
    {
        pRcptListAdd->Release();
    }

    pRcptList = (IMailMsgRecipients *) InterlockedExchangePointer((PVOID *) &m_pIMsgRecipsTemp, (PVOID) NULL);
    if (pRcptList != NULL)
    {
        pRcptList->Release();
    }
}

void SMTP_CONNECTION::ReleasImsg(BOOL DeleteIMsg)
{
    IMailMsgProperties * pMsg = NULL;
    IMailMsgQueueMgmt * pMgmt = NULL;
    HRESULT hr = S_OK;

    pMsg = (IMailMsgProperties *) InterlockedExchangePointer((PVOID *) &m_pIMsg, (PVOID) NULL);
    if (pMsg != NULL)
    {
        ReleasRcptList();

        if(m_pBindInterface)
        {
            //if(DeleteIMsg)
            //{
            //    m_pBindAtqInterface->ReleaseATQHandle();
            //}

            m_pBindInterface->Release();
        }

        if(DeleteIMsg)
        {
            hr = pMsg->QueryInterface(IID_IMailMsgQueueMgmt, (void **)&pMgmt);
            if(!FAILED(hr))
            {
                pMgmt->Delete(NULL);
                pMgmt->Release();
            }
        }

        pMsg->Release();
    }
}

/*++

    Name :
        SMTP_CONNECTION::HandleCompletedMessage

    Description:

        This function gets called when the client
        sends the CRLF.CRLF sequence saying the
        message is complete.  The function truncates
        the message to the current size, if the client
        lied and gave us a larger size in the FROM command,
        and them queues the message to the Local/Remote
        queues for processing.
    Arguments:

        None.

    Returns:

      TRUE if the message was written to disk and queued.
      FALSE in all other cases.

--*/
BOOL SMTP_CONNECTION::HandleCompletedMessage(DWORD dwCommand, BOOL *pfAsyncOp)
{

    DWORD AbOffset = 0;
    char MessageId[1024];
    HRESULT hr = S_OK;
    DWORD TrailerSize = 0;    //used to strip out the trailing ".CRLF"
    BOOL fPended = FALSE;
    BOOL fQRet = TRUE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::HandleCompletedMessage(void)");

    _ASSERT(m_pInstance != NULL);

    //hack to make transaction logging work
    AddCommandBytesRecv(m_TotalMsgSize);

    MessageId[0] = 0;

    if( m_pIMsg )
    {
        m_pIMsg->GetStringA( IMMPID_MP_RFC822_MSG_ID, sizeof( MessageId ), MessageId );
        m_pIMsg->PutDWORD( IMMPID_MP_MSG_SIZE_HINT, m_TotalMsgSize );
    }

    MessageId[sizeof(MessageId)-1] = 0; // NULL terminate it.


    //Depending on dwCommand the TrailerSize will vary
    //For BDAT = 0
    //For DATA = 3
    if(dwCommand == BDAT )
        TrailerSize = 0;

    DWORD cbTotalMsgSize = 0;

    if( m_fFoundEmbeddedCrlfDotCrlf )
    {
        cbTotalMsgSize = m_cbDotStrippedTotalMsgSize;
    }
    else
    {
        cbTotalMsgSize = m_TotalMsgSize;
    }

    if(SetFilePointer(m_IMsgHandle->m_hFile, (cbTotalMsgSize + m_HeaderSize) - TrailerSize, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
          m_MailBodyError = GetLastError();
          //FatalTrace((LPARAM) this, "SetFilePointer failed on file %s !!! (err=%d)", MailInfo->GetMailFileName(), m_MailBodyError);
          m_CInboundContext.SetWin32Status(m_MailBodyError);
          ProtocolLog(DATA, MessageId, m_MailBodyError, SMTP_RESP_NORESOURCES, 0, 0);
          FormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_STORAGE );
          SendSmtpResponse();
          TraceFunctLeaveEx((LPARAM) this);
          return FALSE;
    }

    if(!SetEndOfFile(m_IMsgHandle->m_hFile))
    {
          m_MailBodyError = GetLastError();
         // FatalTrace((LPARAM) this, "SetEndOfFile failed on file %s !!! (err=%d)", MailInfo->GetMailFileName(), m_MailBodyError);
          m_CInboundContext.SetWin32Status(m_MailBodyError);
          ProtocolLog(DATA, MessageId, m_MailBodyError, SMTP_RESP_NORESOURCES, 0, 0);
          FormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_STORAGE );
          SendSmtpResponse();
          TraceFunctLeaveEx((LPARAM) this);
          return FALSE;
    }

    hr = m_pIMsgRecipsTemp->WriteList(m_pIMsgRecips);
    if(FAILED(hr))
    {
        m_MailBodyError = GetLastError();
        //FatalTrace((LPARAM) this, "SetEndOfFile failed on file %s !!! (err=%d)", MailInfo->GetMailFileName(), m_MailBodyError);
        m_CInboundContext.SetWin32Status(m_MailBodyError);
        ProtocolLog(DATA, MessageId, m_MailBodyError, SMTP_RESP_NORESOURCES, 0, 0);
        FormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_STORAGE );
        SendSmtpResponse();
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;

    }

    m_pIMsg->PutDWORD( IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF, m_fScannedForCrlfDotCrlf );
    m_pIMsg->PutDWORD( IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF, m_fFoundEmbeddedCrlfDotCrlf );

    hr = m_pIMsg->Commit(NULL);

    if(FAILED(hr))
    {
        m_MailBodyError = GetLastError();
        //FatalTrace((LPARAM) this, "SetEndOfFile failed on file %s !!! (err=%d)", MailInfo->GetMailFileName(), m_MailBodyError);
        m_CInboundContext.SetWin32Status(m_MailBodyError);
        ProtocolLog(DATA, MessageId, m_MailBodyError, SMTP_RESP_NORESOURCES, 0, 0);
        FormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_STORAGE );
        SendSmtpResponse();
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;

    }

    ReleasRcptList();

    // Fire the end of data event.  The default implementation of this
    // commits the message
    char szVerb[] = "_EOD";
    DWORD CmdSize;
    BOOL fAsyncOp;
    m_dwCurrentCommand = SmtpGetCommand(szVerb, sizeof(szVerb), &CmdSize);
    BOOL fReturn =
        GlueDispatch((char *)szVerb, sizeof(szVerb), CmdSize, pfAsyncOp);
    if (!fReturn) {
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    if (*pfAsyncOp) {
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    SendSmtpResponse();

    ProtocolLog(DATA, MessageId, NO_ERROR, SMTP_RESP_OK, 0, 0);

    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}


/*++

    Name :
        BOOL SMTP_CONNECTION::RewriteHeader(void)

    Description:

          This function adds a message ID, and other
          headers if they are missing

    Arguments:
        none

    Returns:

      FALSE if WriteFile failed
      TRUE otherwise

--*/
BOOL SMTP_CONNECTION::RewriteHeader(void)
{
  char Buffer [MAX_REWRITTEN_HEADERS];
  char szMsgId[MAX_REWRITTEN_MSGID];
  char MessageId [REWRITTEN_GEN_MSGID_BUFFER];
  int NumToWrite;
  int MsgIdSize = 0;
  int CurrentRewriteBufferSize = 0;
  BOOL fPended = FALSE;

  //***NOTE***
  //If you add *anything* to this function, make sure you update MAX_REWRITTEN_HEADERS
  //to support allow room for this as well.

  //Rewrite header creates its own buffer and writes out

   //add the mail from field if we did not see it.
   if(!(m_HeaderFlags & H_FROM))
   {
       _ASSERT(m_szFromAddress[0] != '\0');

        NumToWrite = sprintf(Buffer + CurrentRewriteBufferSize, "From: %s\r\n",  m_szFromAddress);
        CurrentRewriteBufferSize += NumToWrite;
        m_pIMsg->PutStringA( IMMPID_MP_RFC822_FROM_ADDRESS, m_szFromAddress );
        char szSmtpFromAddress[MAX_INTERNET_NAME + 6] = "smtp:";
        strncat(szSmtpFromAddress, m_szFromAddress, MAX_INTERNET_NAME);
        m_pIMsg->PutStringA( IMMPID_MP_FROM_ADDRESS, szSmtpFromAddress );
   }

   _ASSERT(MAX_REWRITTEN_HEADERS > CurrentRewriteBufferSize);

  if(!(m_HeaderFlags & H_RCPT))
   {
        NumToWrite = sprintf(Buffer + CurrentRewriteBufferSize, "Bcc:\r\n");
        CurrentRewriteBufferSize += NumToWrite;
   }

   _ASSERT(MAX_REWRITTEN_HEADERS > CurrentRewriteBufferSize);
   //add the return path field if we did not see it.
  if(!(m_HeaderFlags & H_RETURNPATH))
  {
        _ASSERT(m_szFromAddress[0] != '\0');

        NumToWrite = sprintf(Buffer + CurrentRewriteBufferSize, "Return-Path: %s\r\n", m_szFromAddress);
        CurrentRewriteBufferSize += NumToWrite;
  }

   //add the message ID field if we did not see it.
  _ASSERT(MAX_REWRITTEN_HEADERS > CurrentRewriteBufferSize);
  if(!(m_HeaderFlags & H_MID))
  {
       GenerateMessageId (MessageId, sizeof(MessageId));

       m_pInstance->LockGenCrit();
       MsgIdSize = sprintf( szMsgId, "<%s%8.8x@%s>", MessageId, GetIncreasingMsgId(), m_pInstance->GetFQDomainName());
       m_pInstance->UnLockGenCrit();

       _ASSERT(MsgIdSize < MAX_REWRITTEN_MSGID);

       NumToWrite = sprintf(Buffer + CurrentRewriteBufferSize, "Message-ID: %s\r\n", szMsgId);
       szMsgId[sizeof(szMsgId)-1]=0;

       CurrentRewriteBufferSize += NumToWrite;
       if( FAILED( m_pIMsg->PutStringA( IMMPID_MP_RFC822_MSG_ID, szMsgId ) ) )
           return FALSE;
  }

  if( !( m_HeaderFlags & H_X_ORIGINAL_ARRIVAL_TIME ) )
  {
      char szOriginalArrivalTime[64];

      GetSysAndFileTimeAsString( szOriginalArrivalTime );

      NumToWrite = sprintf(Buffer + CurrentRewriteBufferSize, "X-OriginalArrivalTime: %s\r\n", szOriginalArrivalTime);
      szOriginalArrivalTime[sizeof(szOriginalArrivalTime)-1]=0;

      CurrentRewriteBufferSize += NumToWrite;
      if( FAILED( m_pIMsg->PutStringA( IMMPID_MP_ORIGINAL_ARRIVAL_TIME, szOriginalArrivalTime ) ) )
          return FALSE;
  }



  //add the Date field if we did not see it.
  _ASSERT(MAX_REWRITTEN_HEADERS > CurrentRewriteBufferSize);
  if(!(m_HeaderFlags & H_DATE))
  {
    char szDateBuf [cMaxArpaDate];

    GetArpaDate(szDateBuf);
    NumToWrite = sprintf(Buffer + CurrentRewriteBufferSize, "Date: %s\r\n", szDateBuf);
    CurrentRewriteBufferSize += NumToWrite;
  }

  //Did we see the seperator. If not add one
  //blank line to the message
  _ASSERT(MAX_REWRITTEN_HEADERS > CurrentRewriteBufferSize);
  if(!(m_HeaderFlags & H_EOH))
  {
    sprintf(Buffer + CurrentRewriteBufferSize,"\r\n", 2);
    CurrentRewriteBufferSize += 2;

  }

  _ASSERT(MAX_REWRITTEN_HEADERS > CurrentRewriteBufferSize);
  m_HeaderSize += CurrentRewriteBufferSize;


  if(CurrentRewriteBufferSize)
  {
      //Write out the data
      //NK** : Assumption with 32K buffers we should never need to
      //write file to disk so the last param is ignored
      if(!WriteMailFile(Buffer, CurrentRewriteBufferSize, &fPended))
        {
          m_MailBodyError = GetLastError();
          return FALSE;
        }

      _ASSERT(!fPended);



  }

  return TRUE;
}

/*++

    Name :
        SMTP_CONNECTION::CreateMailBody

    Description:

        Responds to the SMTP data command.
        This funcion spools the mail to a
        directory
    Arguments:

        InputLine - Buffer received from client
        paramterSize - amount of data in buffer
        UndecryptedTailSize -- amount of undecrypted data at end of buffer
    Returns:

      TRUE if all data(incliding terminating .)
           has been received
      FALSE on all errors (disk full, etc.)

--*/

BOOL SMTP_CONNECTION::CreateMailBody(char * InputLine, DWORD ParameterSize,
                                      DWORD UndecryptedTailSize, BOOL  *lfWritePended)
{
    BOOL MailDone = FALSE;
    DWORD IntermediateSize = 0;
    PCHAR pszSearch = NULL;
    DWORD TotalMsgSize = 0;
    DWORD SessionSize = 0;
    char c1, c2;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::CreateMailBody");

    _ASSERT (m_pInstance != NULL);
    _ASSERT (m_cbParsable <= QueryMaxReadSize());


    // 7/2/99 MILANS
    // The following if statement is completely unnecessary. One should not adjust the line
    // state at the beginning of this function - rather, they should do so as a line is scanned
    // and, for the final (potentially partial) line at the end, when they move the (partial) line
    // as the last step in this function.
    // Nevertheless, in the light of the time, I am leaving the if statement in place.

    //the state of the line completion parsing automaton is to be set to the initial state if
    //for each line except the following case:

    //if the buffer was full in the last iteration --- the data got shifted out and now we are
    //parsing the newly read data. so the state of the line completion automaton must
    if(!m_BufrWasFull)
        m_LineCompletionState = SEEN_NOTHING;   //automaton state for IsLineCompleteRFC822

    m_BufrWasFull = FALSE;
    while ((pszSearch = IsLineCompleteRFC822(InputLine, m_cbParsable, UndecryptedTailSize, &m_BufrWasFull)) != NULL)
    {
        //If the buffer is full and we are not using the entire buffer; then some of the data in the full
        //buffer is data that we have already parsed and processed in preceding iterations. we can discard
        //this data and read in fresh data which may have the CRLFx we are looking for. to do this, break
        //out of this loop, move inputline to the beginning of buffer (done outside loop) and just return.
        //a read is pended and this function is called with freshly read data appended to the "inadequate
        //data". If even then the no CRLFx is found, and the buffer is filled up, we need to start truncation.

        if(m_BufrWasFull && InputLine > QueryMRcvBuffer())
            break;

        _ASSERT (m_cbParsable <= QueryMaxReadSize());

        //stuff in CRLF if it wasn't there
        if(!m_Truncate && m_BufrWasFull)
        {
            c1                  = *pszSearch;
            c2                  = *(pszSearch+1);
            *pszSearch          = CR;
            *(pszSearch+1)      = LF;
        }

        IntermediateSize = (DWORD)(pszSearch - InputLine);
        TotalMsgSize = m_TotalMsgSize + (IntermediateSize + 2);
        SessionSize = m_SessionSize + (IntermediateSize + 2);

        //don't write the '.' to the file
        if( (InputLine [0] == '.') && (IntermediateSize == 1) && !m_LongBodyLine )
        {
            //the minimum message size is 3 (.CRLF).  If we are done, and the size
            //of the message is 3 bytes, that means that the body of the message
            //is missing. So, just write the headers and go.
            if(TotalMsgSize == 3 && m_TimeToRewriteHeader)
            {
                m_TimeToRewriteHeader = FALSE;
                if(!RewriteHeader())
                {
                    m_MailBodyDiagnostic = ERR_RETRY;
                    m_MailBodyError = GetLastError();
                    return TRUE;
                }
            }

            //We are at the end of the message flush our write buffer
            //if there is something in it
            if(!WriteMailFile(NULL, 0, lfWritePended))
            {
                m_MailBodyDiagnostic = ERR_RETRY;
                m_MailBodyError = GetLastError();
                return TRUE;
            }
            else if(*lfWritePended)
            {
                //Go away - Atq will call us back when the write file completes
                TraceFunctLeaveEx((LPARAM) this);
                return FALSE;
            }

            m_cbParsable -= 3; // 1for the . + 2 for CRLF
            m_cbReceived = m_cbParsable + UndecryptedTailSize;

            if(m_cbReceived)
            {
                //we need to +2 to pszSearch because it points to the CR character
                MoveMemory ((void *)QueryMRcvBuffer(), pszSearch + 2, m_cbReceived);
            }

            //DebugTrace((LPARAM) this, "got ending dot for file %s", MailInfo->GetMailFileName());
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
        }

        if(!m_Truncate && m_InHeader && ( m_MailBodyError == NO_ERROR ))
        {

            //the code I stole from SendMail assumes the
            //line has a terminating '\0', so we terminate
            //the line.  We will put back the carriage
            //return later.

            *pszSearch = '\0';
            char *pszValueBuf = NULL;

            //remove header. return false if the line is not a header or the line is NULL
            //chompheader returns everything after ":" into pszValueBuf
            if( m_InHeader = ChompHeader( InputLine, m_HeaderFlags, &pszValueBuf) )
            {
                GetAndPersistRFC822Headers( InputLine, pszValueBuf);
                if(FAILED(m_MailBodyError))
                {
                    ErrorTrace((LPARAM) this, "Error persisting 822 headers 0x%08x", m_MailBodyError);
                    m_MailBodyDiagnostic = ERR_RETRY;
                    *pszSearch = CR;
                    TraceFunctLeaveEx((LPARAM) this);
                    return TRUE;
                }
            }
            else
            {
                //in case we have <header><CRLF><CRLF><sp><body><CRLF><x> we have seen
                //an end of header after the 1st <CRLF> but because IsLineComplete822 halts at
                //the third <CRLF> the inputstring to ChompHeader() is
                //<CRLF><sp><body><NULL> rather than just <NULL> had there been no <sp> after
                //the second <CRLF>. Thus ChompHeader will not set the EOH flag correctly.
                //we do this here.
                if( InputLine[0] == CR &&
                    InputLine[1] == LF &&
                    (InputLine[2] == ' ' || InputLine[2] == '\t') )
                    m_HeaderFlags |= H_EOH;
            }

            *pszSearch = CR;
        }


        //If we are not in the header and this is
        //the first time m_TimeToRewriteHeader is
        //TRUE, then add any missing headers we
        //care about.  Set m_TimeToRewriteHeader
        //to false so that we don't enter this
        //part of the code again.  If ReWriteHeader
        //fails, we are probably out of disk space,
        //so set m_NoStorage to TRUE such that we
        //don't waste our time writing to disk.
        //We still have to accept the mail, but we
        //throw it away.  We will send a message
        //back to our client when all is done.
        if(!m_InHeader && m_TimeToRewriteHeader && (m_MailBodyError == NO_ERROR))
        {
            //So there was nothing to write so now write headers
            m_TimeToRewriteHeader = FALSE;
            if(!RewriteHeader())
            {
                m_MailBodyDiagnostic = ERR_RETRY;
                m_MailBodyError = GetLastError();
                return TRUE;
            }
        }

        //restore InputLine for mail file write, if we put in a CRLF
        if(!m_Truncate && m_BufrWasFull)
        {
            *pszSearch          = c1;
            *(pszSearch + 1)    = c2;
        }

        char *pInputLine = InputLine;
        DWORD cbIntermediateSize = IntermediateSize + 2;

        if(m_MailBodyError == NO_ERROR)
        {

            //if we had a full buffer without CRLFx in the previous iteration, we did a
            //MoveMemory() and the beginning of the buffer is not the beginning of the line.
            //dot stripping is only done for the beginning of the line.
            if( !m_LongBodyLine )
            {
                if( *pInputLine == '.' )
                {
                    pInputLine++;
                    cbIntermediateSize --;
                    m_fFoundEmbeddedCrlfDotCrlf = TRUE;
                }
            }

            //write to the file if we have not gone over our alloted limit
            //and if WriteFile did not give us back any errors
            if((m_pInstance->GetMaxMsgSize() > 0) ||
               (m_pInstance->GetMaxMsgSizeBeforeClose() > 0))
            {
                BOOL fShouldImposeLimit = TRUE;

                // if the total msg size is not exceeded continue writing to file.
                // Else, trigger the MaxMsgSize event to see
                // if we can continue to write to the file.

                if ( m_pInstance->GetMaxMsgSize() > 0 && TotalMsgSize > m_pInstance->GetMaxMsgSize() )
                {
                    if( FAILED( m_pInstance->TriggerMaxMsgSizeEvent( GetSessionPropertyBag(), m_pIMsg, &fShouldImposeLimit ) ) || fShouldImposeLimit )
                    {
                        m_MailBodyError = ERROR_ALLOTTED_SPACE_EXCEEDED;
                        m_MailBodyDiagnostic = ERR_MAX_MSG_SIZE;
                        ProtocolLog(BDAT, (char *)InputLine, NO_ERROR, SMTP_RESP_NOSTORAGE, 0, 0);
                        ErrorTrace((LPARAM) this, "SMTP_RESP_NOSTORAGE, SMTP_MAX_MSG_SIZE_EXCEEDED_MSG -  %d", TotalMsgSize);
                        ++m_ProtocolErrors;
                        BUMP_COUNTER(QuerySmtpInstance(), MsgsRefusedDueToSize);
                        TraceFunctLeaveEx((LPARAM) this);
                        return TRUE;
                    }
                }

                if ( m_pInstance->GetMaxMsgSizeBeforeClose() >0 && SessionSize > m_pInstance->GetMaxMsgSizeBeforeClose() )
                {
                    if( FAILED( m_pInstance->TriggerMaxMsgSizeEvent( GetSessionPropertyBag(), m_pIMsg, &fShouldImposeLimit ) )  || fShouldImposeLimit )
                    {
                        m_MailBodyError = ERROR_ALLOTTED_SPACE_EXCEEDED;
                        ProtocolLog(MAIL, (char *)InputLine, NO_ERROR, SMTP_RESP_NOSTORAGE, 0, 0);
                        ErrorTrace((LPARAM) this, "SMTP_RESP_NOSTORAGE, SMTP_MAX_SESSION_SIZE_EXCEEDED_MSG -  %d", SessionSize);
                        BUMP_COUNTER(QuerySmtpInstance(), MsgsRefusedDueToSize);
                        m_cbParsable = 0;
                        m_cbReceived = 0;
                        DisconnectClient();
                        TraceFunctLeaveEx((LPARAM) this);
                        return FALSE;
                    }
                }

                if(!WriteMailFile(pInputLine, cbIntermediateSize , lfWritePended))
                {
                    m_MailBodyError = GetLastError();
                    m_MailBodyDiagnostic = ERR_RETRY;
                    return TRUE;
                }
                else if(*lfWritePended)
                {
                    //Go away - Atq will call us back when the write file completes
                    TraceFunctLeaveEx((LPARAM) this);
                    return FALSE;
                }
            }
            else if (!WriteMailFile(pInputLine, cbIntermediateSize, lfWritePended))
            {
                m_MailBodyError = GetLastError();
                m_MailBodyDiagnostic = ERR_RETRY;
                return TRUE;
            }
            else if(*lfWritePended)
            {
                //Go away - Atq will call us back when the write file completes
                TraceFunctLeaveEx((LPARAM) this);
                return FALSE;
            }
        }
        else if(m_pInstance->GetMaxMsgSizeBeforeClose() > 0 && SessionSize > m_pInstance->GetMaxMsgSizeBeforeClose())
        {
            BOOL fShouldImposeLimit = TRUE;
            if( FAILED( m_pInstance->TriggerMaxMsgSizeEvent( GetSessionPropertyBag(),m_pIMsg, &fShouldImposeLimit ) ) || fShouldImposeLimit )
            {
                ErrorTrace((LPARAM) this, "GetMaxMsgSizeBeforeClose()  exceeded - closing connection");
                m_cbParsable = 0;
                m_cbReceived = 0;
                BUMP_COUNTER(QuerySmtpInstance(), MsgsRefusedDueToSize);
                DisconnectClient();
                TraceFunctLeaveEx((LPARAM) this);
                return TRUE;
            }
        }

        //We managed to copy data to write buffer without having to write
        //out
        m_cbParsable -= IntermediateSize + 2;
        m_cbReceived -= IntermediateSize + 2;
        m_TotalMsgSize += IntermediateSize + 2;
        m_SessionSize += IntermediateSize + 2;
        m_cbDotStrippedTotalMsgSize += cbIntermediateSize;
        m_cbRecvBufferOffset += IntermediateSize + 2;

        _ASSERT (m_cbParsable <= QueryMaxReadSize());

        InputLine = pszSearch + 2;  //if m_BufrWasFull && UndecryptedTailSize == 0 then InputLine is pointing
                                    //1 byte beyond end of allocated storage; this is not an error.

        //if the buffer is filled up:
        //since we are done parsing it, we can discard it. this is done by setting m_cbParsable to 0
        //then we quit the IsLineComplete loop so that we can exit this function and pend a read for
        //fresh data. If the buffer was filled up, it also means that a CRLFx was not found, so we
        //ought to enter truncation mode (unless we have already done so) because this line was too
        //long.

        if(m_BufrWasFull)
        {
            m_cbParsable = 0;
            m_LongBodyLine = TRUE;  //Next return of pszSearch in while() is not beginning of a new line.
            if(!m_Truncate)
                m_Truncate = TRUE;  //this looks silly... but the point is simply that we are "switching"
            break;                  //states, to truncation mode. The if() reminds you that it is possible
        }                           //to be in truncation mode already.

        //if the buffer still has room:
        //IsLineComplete returned because it found a CRLFx. in normal (non truncation mode) processing
        //this case means nothing, but if we were in truncation mode, then it means that we have hit the
        //end of the header we were truncating, so we need to get back to normal mode.
        else
        {
            m_LongBodyLine = FALSE;
            if(m_Truncate)
                m_Truncate = FALSE;
        }
    }

    if(m_cbParsable != 0)
    {
        //if there is stuff left in the buffer, move it up
        //to the top, then pend a read at the end of where
        //the last data left off

         _ASSERT (m_cbParsable <= QueryMaxReadSize());

         m_cbReceived = m_cbParsable + UndecryptedTailSize;
         MoveMemory ((void *)QueryMRcvBuffer(), InputLine, m_cbReceived);
         m_cbRecvBufferOffset = 0;
         m_LineCompletionState = SEEN_NOTHING;
    }
    else
    { // m_cbParsable == 0
         m_cbReceived = UndecryptedTailSize;
         if(m_cbReceived > 0) //anything to move?
             MoveMemory ((void *)QueryMRcvBuffer(), InputLine, m_cbReceived);
         m_cbRecvBufferOffset = 0;
         m_LineCompletionState = SEEN_NOTHING;
    }

    TraceFunctLeaveEx((LPARAM) this);
    return FALSE;
}



/*++

    NAME:   SMTP_CONNECTION::IsLineCompleteRFC822

    DESCRIPTION:

        Parses InputLine till it encounters a CRLFx where x is a nontab
        and nonspace character. When CRLFx is found it means that the true
        end of a line has been found, in other words ... there are no more
        continuations of this line.

        Implementation is as a finite state machine (FSM).

        The SMTP_CONNECTION member m_LineCompletion keeps track of the
        state of the FSM between calls so that if the FSM does not hit
        its exit state (CRLFx found) by the time it has scanned the input,
        the caller may obtain more input data and resume the parsing. Thus
        this member variable is "implicitly" passed to the function.

        If the message receive buffer (returned by QueryMRcvBuffer()) is
        filled up, so that the caller has no chance of getting more data
        (since there is no space), this function returns a pointer to the
        last but one item in InputLine and sets the flag FullBuffer. The
        purpose being that the caller can put a CRLF at the position
        returned and proceed as though CRLFx had been found.

        A special condition occurs if the InputLine starts off as .CRLF
        and the initial state is 1. This means that either the message is
        just .CRLF or a CRLF.CRLF has been found. Thus the end of the message
        has been found and the function returns.

    PARAMETERS:

        InputLine               Input data
        nBytes                  Bytes to parse
        UndecryptedTailSize     Data that occupies buffer space but can't
                                be parsed
        p_FullBuffer            If the function fails to find CRLFx, is there
                                enough room left in the buffer so that we can
                                get more input from the user?

        m_LineCompletionState   Implicit parameter... you need to Initialize
                                this.

    RETURNS:
        Pointer to CR if CRLFx found
        Pointer to second last byte of buffer if there is no CRLFx
        NULL if there is no CRLFx and the buffer is not full.

--*/

char * SMTP_CONNECTION::IsLineCompleteRFC822(
                                             IN char *InputLine,
                                             IN DWORD nBytes,
                                             IN DWORD UndecryptedTailSize,
                                             OUT BOOL *p_FullBuffer
                                             )
{
    ASSERT(InputLine);

    char *pCh;
    char *pLastChar = InputLine + nBytes - 1;   //end of input

    //One exceptional case : the last line of input
    if(nBytes >= 3)
    {
        if(InputLine[0] == '.' && InputLine[1] == CR && InputLine[2] == LF)
        {
            *p_FullBuffer = FALSE;
            return &InputLine[1];
        }
    }


    for(pCh = InputLine; pCh <= pLastChar; pCh++)
    {
        switch(m_LineCompletionState)
        {
        case SEEN_NOTHING:                        //need CR
            if(*pCh == CR)
                m_LineCompletionState = SEEN_CR;  //seen CR go on to state_2
            break;

        case SEEN_CR:                                //seen CR need LF
            if(*pCh == LF)
                m_LineCompletionState = SEEN_CRLF;   //seen LF goto state_3
            else if(*pCh != CR)
                m_LineCompletionState = SEEN_NOTHING;//if CR stay in this state, else go back to 1
            break;

        case SEEN_CRLF:                                 //seen CRLF, need x
            if(*pCh != ' ' && *pCh != '\t')             //CRLFx found
            {
                *p_FullBuffer = FALSE;
                m_LineCompletionState = SEEN_NOTHING;     //seen CRLFx, go back to initial state
                return pCh - 2;                           //returning pointer to the CR
            }
            else
                m_LineCompletionState = SEEN_NOTHING;   //didn't get either x or CR, nothing matched --- start over again.
            break;
        }
    }

    //buffer is full && CRLFx not found.
    if(*p_FullBuffer = (pLastChar >= QueryMRcvBuffer() + QueryMaxReadSize() - UndecryptedTailSize - 1))
       return pLastChar - 1;   //assumption: nbytes is atleast 2
    return NULL;    //buffer has room left && CRLFx not found
}

/*++

    Name :
        SMTP_CONNECTION::CreateMailBodyFromChunk

    Description:

        Responds to the SMTP BDAT command.
        This function spools the mail to a
        directory keeping track of chunk size
    Arguments:

        InputLine - Buffer received from client
        paramterSize - amount of data in buffer
        UndecryptedTailSize -- amount of undecrypted data at end of buffer
    Returns:

      TRUE if all data(incliding terminating .)
           has been received
      FALSE on all errors (disk full, etc.)

--*/
BOOL SMTP_CONNECTION::CreateMailBodyFromChunk (char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize, BOOL *lpfWritePended)
{
    BOOL MailDone = FALSE;
    DWORD IntermediateSize = 0;
    PCHAR pszSearch = NULL;
    char MailFileName[MAX_PATH];
    DWORD TotalMsgSize = 0;
    DWORD SessionSize = 0;

    //  HRESULT hr;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::CreateMailBodyFromChunk");

    _ASSERT (m_pInstance != NULL);
    _ASSERT (m_cbParsable <= QueryMaxReadSize());


    MailFileName[0] = '\0';

    //
    // m_cbTempBDATLen is used to save BDAT chunk bytes for headers spanning multiple
    // BDAT chunks. So we need to parse from the very beginning of the buffer if there
    // are saved BDAT header bytes.
    //

    if(m_cbTempBDATLen)
    {
      InputLine = QueryMRcvBuffer();
    }

    //
    // Process the chunk data line-by-line till a line is encountered which is not a
    // header. At this point m_InHeader is set to FALSE and we never enter this loop
    // again. Instead all chunk data will be directly dumped to disk as the mail body.
    //
    // It can be determined that a line is either header/non-header if:
    //  - It is CRLF terminated (it can be examined for the header syntax)
    //  - If we have 1000+ bytes without a CRLF it is not a header
    //
    // If it does not meet either condition, we must save the data (set m_cbTempBDATLen)
    // and post a read for the next chunk hoping that with the fresh data, either of the
    // two conditions will apply.
    //

    while (m_InHeader &&
           ((pszSearch = IsLineComplete((const char *)InputLine, m_cbParsable)) != NULL ||
                                       m_cbParsable > 1000  ||
                                       m_cbParsable >= (DWORD)m_nBytesRemainingInChunk))
    {
        _ASSERT (m_cbParsable <= QueryMaxReadSize());

        // Found a CRLF in the received data
        if(pszSearch != NULL)
        {
            IntermediateSize = (DWORD)(pszSearch - InputLine);
            TotalMsgSize = m_TotalMsgSize + (IntermediateSize + 2);
            SessionSize = m_SessionSize + (IntermediateSize + 2);

            //
            // There are IntermediateSize+2 bytes in this CRLF terminated line.
            // If that is > the number of bytes in the current BDAT chunk:
            // - The chunk was fully received
            // - Some extra bytes (pipelined SMTP command) were received after it.
            // - The CRLF found by IslineComplete is outside this chunk.
            //

            if(( m_nBytesRemainingInChunk - ((int)IntermediateSize + 2) ) < 0)
            {
                if(m_fIsLastChunk || m_nBytesRemainingInChunk > 1000)
                {
                    //
                    // We're done with header parsing because either:
                    // - This is the last BDAT chunk OR
                    // - We have 1000 bytes of mailbody data without a CRLF
                    //

                    m_InHeader = FALSE;
                }
                else
                {
                    //
                    // In this else-block the following is true:
                    // - This is not the last BDAT chunk
                    // - We have < 1000 bytes in the current BDAT chunk
                    // - The CRLF (pszSearch) is outside the current BDAT chunk
                    // - We still haven't hit a non-header line
                    //
                    // We do not know if this is a header. This chunk is saved
                    // as the first m_cbTempBDATLen bytes in the recv buffer. The
                    // next chunk is appended to this and both will be processed
                    // together.
                    //

                    m_cbTempBDATLen = m_nBytesRemainingInChunk;
                    m_nBytesRemainingInChunk = 0;
                    break;
                }
            }

            //look for all the headers we care about.
            //If we are out of storage, forget it.
            if(m_InHeader && (m_MailBodyError == NO_ERROR))
            {
                //For parsing we terminate the line.
                //We will put back the carraige return later
                *pszSearch = '\0';

                //skip over continuation lines
                if((InputLine[0] != ' ') && (InputLine[0] != '\t'))
                {
                    char *pszValueBuf = NULL;
                    //see if we are still in the header portion
                    //of the body
                    if (m_InHeader = ChompHeader(InputLine, m_HeaderFlags, &pszValueBuf))
                    {
                        //Process and Promote RFC822 Headers
                        GetAndPersistRFC822Headers( InputLine, pszValueBuf );
                    }

                }
                //put back the carraige return
                *pszSearch = CR;
            }
        }

        else if((m_cbParsable > 1000) || m_fIsLastChunk)
        {
            //We could not parse the line inspite of having 1000 parsable bytes
            //That tells me it is not a 822 header
            m_InHeader = FALSE;
        }
        else
        {
            //We do not have a parsed line and we have not exceeded the 1000byte
            //limit - looks like what we have is a partial header line
            //Keep the data around
            m_cbTempBDATLen = m_nBytesRemainingInChunk;
            m_nBytesRemainingInChunk = 0;
            break;
        }

        //if we are done with headers break
        if(!m_InHeader)
            break;

        //We are still processing headers
        if(m_MailBodyError == NO_ERROR)
        {
            if(!WriteMailFile(InputLine, IntermediateSize + 2, lpfWritePended))
            {
                m_MailBodyDiagnostic = ERR_RETRY;
                m_MailBodyError = GetLastError();
                m_InHeader = FALSE;
            }
            else if(*lpfWritePended)
            {
                //Go away - Atq will call us back when the write file completes
                TraceFunctLeaveEx((LPARAM) this);
                return FALSE;
            }
            //Update the remaining bytes expected in this chunk
            else
            {
                //Once we write out chunk data - we should no longer have any saved of portion of chunk
                //
                m_cbTempBDATLen = 0;
                m_nBytesRemainingInChunk -= IntermediateSize + 2;
            }
        }
        else
            m_InHeader = FALSE;

        InputLine = pszSearch + 2;
        m_cbParsable -= (IntermediateSize + 2);
        m_cbReceived -= IntermediateSize + 2;
        m_TotalMsgSize += IntermediateSize + 2;
        m_SessionSize += IntermediateSize + 2;
        m_cbRecvBufferOffset += (IntermediateSize + 2);
        _ASSERT (m_cbParsable < QueryMaxReadSize());
    }//end while

    // If we are done with headers - it is time to write any missing headers
    if(!m_InHeader && m_TimeToRewriteHeader && (m_MailBodyError == NO_ERROR))
    {
        //So there was nothing to write so now write headers
        m_TimeToRewriteHeader = FALSE;
        if(!RewriteHeader())
        {
            m_MailBodyDiagnostic = ERR_RETRY;
            m_MailBodyError = GetLastError();
            ErrorTrace( (LPARAM)this, "Rewrite headers failed. err: %d",m_MailBodyError);
        }
    }

    //If we did write something during our header parsing we need to update m_cbReceived
    m_cbReceived = m_cbParsable + UndecryptedTailSize;

    // Now that we are thru with headers and there is more data in the buffer
    // that is part of the chunk - simply dump it to disk asynchronously
    if(!m_InHeader && m_nBytesRemainingInChunk && m_cbParsable)
    {
        DWORD dwBytesToWrite = m_nBytesRemainingInChunk;

        // Simply write the parsable data or the remaining bytes in this chunk
        // to the file - which ever is smaller
        if(m_nBytesRemainingInChunk > (int) m_cbParsable)
            dwBytesToWrite = m_cbParsable;

        if(m_MailBodyError == NO_ERROR)
        {
            //write to the file if we ahve had no errors
            if(!WriteMailFile(InputLine, dwBytesToWrite, lpfWritePended))
            {
                m_MailBodyDiagnostic = ERR_RETRY;
                m_MailBodyError = GetLastError();
            }
            else if(*lpfWritePended)
            {
                //Go away - Atq will call us back when the write file completes
                TraceFunctLeaveEx((LPARAM) this);
                return FALSE;
            }

            //Now that we have copied stuff to out buffer
            //update the state data
            m_TotalMsgSize += dwBytesToWrite;
            m_SessionSize += dwBytesToWrite;

            m_nBytesRemainingInChunk -= dwBytesToWrite;
            //We are down to last bytes - keep a track of trailing CRLF
            if(m_fIsLastChunk && (m_nBytesRemainingInChunk < 2) )
            {
                //We have the second last byte - there is one more byte to be read.
                if(m_nBytesRemainingInChunk)
                {
                    if(*(InputLine + dwBytesToWrite -1) == '\r')
                        m_dwTrailerStatus = CR_SEEN;
                    else
                        m_dwTrailerStatus = CR_MISSING;
                }
                else if(dwBytesToWrite > 1)   //We got the last byte
                {
                    //We have last two bytes together
                    if(!strncmp((InputLine + dwBytesToWrite - 2),"\r\n", 2))
                        m_dwTrailerStatus = CRLF_SEEN;
                    else
                        m_dwTrailerStatus = CRLF_NEEDED;
                }
                else if(m_dwTrailerStatus == CR_SEEN && (*(InputLine + dwBytesToWrite -1) == '\n'))
                    m_dwTrailerStatus = CRLF_SEEN;
                else
                    m_dwTrailerStatus = CRLF_NEEDED;

            }

            //Update IO buffer parameters to reflect the state after WRITE
            m_cbReceived -= dwBytesToWrite;
            m_cbParsable -= dwBytesToWrite;

            //Once we write out chunk data - we should no longer have any saved of portion of chunk
            //
            m_cbTempBDATLen = 0;
            m_cbRecvBufferOffset = 0;

        }

        InputLine += dwBytesToWrite;
        _ASSERT (m_cbParsable < QueryMaxReadSize());
    }

    //Adjust the buffer for the next read only if did comsume any data
    //and there is more data remaining in the input buffer
    //

    if(m_cbReceived && (QueryMRcvBuffer() != InputLine))
    {
        MoveMemory ((void *)QueryMRcvBuffer(), InputLine, m_cbReceived);
    }
    m_cbRecvBufferOffset = 0;

    //If we are done with current chunk
    if(!m_nBytesRemainingInChunk)
    {
        if(m_MailBodyError == NO_ERROR)
        {
            if(m_fIsLastChunk)
            {
                //we are done with all the chunks
                //We have written the Last chunk and need to see if we need to put the trailing CRLF
                if(m_dwTrailerStatus == CRLF_NEEDED)
                {

                    if(!WriteMailFile("\r\n", 2, lpfWritePended))
                    {
                        m_MailBodyDiagnostic = ERR_RETRY;
                        m_MailBodyError = GetLastError();
                    }
                    else if(*lpfWritePended)
                    {
                        //Go away - Atq will call us back when the write file completes
                        TraceFunctLeaveEx((LPARAM) this);
                        return FALSE;
                    }
                    m_TotalMsgSize += 2;
                    m_SessionSize += 2;
                    m_dwTrailerStatus = CRLF_SEEN;
                }

                //Flush all the data to disk
                if(!WriteMailFile(NULL, 0, lpfWritePended))
                {
                  m_MailBodyDiagnostic = ERR_RETRY;
                  m_MailBodyError = GetLastError();
                }
                else if(*lpfWritePended)
                {
                    //Go away - Atq will call us back when the write file completes
                    TraceFunctLeaveEx((LPARAM) this);
                    return FALSE;
                }

                //Go back to HELO state
                m_State = HELO;
                m_fIsChunkComplete = FALSE;
                TraceFunctLeaveEx((LPARAM) this);
                return TRUE;
            }
            else
            {
                //Chunk completion response
                ProtocolLog(BDAT, (char *) MailFileName, NO_ERROR, SMTP_RESP_OK, 0, 0);
                FormatSmtpMessage  (SMTP_RESP_OK, EMESSAGE_GOOD," %s, %d Octets\r\n", SMTP_BDAT_CHUNK_OK_STR, m_nChunkSize );
            }
            m_fIsChunkComplete = TRUE;
        }
        else
        {
            // We had error during handling the Chunk, now that chunk has been consumed
            //we can respond with an error
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
        }

    }
    TraceFunctLeaveEx((LPARAM) this);
    return FALSE;



}

/*++

    Name :
        SMTP_CONNECTION::DoDATACommandEx

    Description:

        Responds to the SMTP data command.
        This funcion spools the mail to a
        directory
    Arguments:

        InputLine - Buffer received from client
        paramterSize - amount of data in buffer
    Returns:

        Currently this function always returns TRUE.

--*/
BOOL SMTP_CONNECTION::DoDATACommandEx(const char * InputLine1, DWORD ParameterSize, DWORD UndecryptedTailSize,BOOL *lpfWritePended, BOOL *pfAsyncOp)
{
  LPSTR InputLine = (LPSTR) InputLine1;
  BOOL fRet = TRUE;
  BOOL fProcess = TRUE;
  PSMTP_IIS_SERVICE     pService = (PSMTP_IIS_SERVICE) g_pInetSvc;

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoDATACommandEx");

  _ASSERT (m_pInstance != NULL);

  //
  // we scan for <CRLF>.<CRLF> when processing the msg body of the DATA
  // command.
  //

  m_fScannedForCrlfDotCrlf = TRUE;

  if(CreateMailBody(InputLine, ParameterSize, UndecryptedTailSize, lpfWritePended))
  {
      if(m_MailBodyDiagnostic != NO_ERROR)
      {
          TraceFunctLeaveEx((LPARAM) this);
          return TRUE;
      }

      //increment our counters
      //make sure the size of the file is proper.
      //subtract 3 bytes accounting for the .CRLF.
      //We don't write that portion to the file.

      ADD_BIGCOUNTER(QuerySmtpInstance(), BytesRcvdMsg, (m_TotalMsgSize - 3));
      BUMP_COUNTER(QuerySmtpInstance(), NumMsgRecvd);

      //if there was no error while parsing the
      //header, and writimg the file to disk,
      //then save the rest of the file, send
      //a message id back to the client, and
      //queue the message
      if(m_MailBodyError == NO_ERROR)
      {

        //call HandleCompletedMessage() to see
        //if we should process this message
        HandleCompletedMessage(DATA, pfAsyncOp);
        if (*pfAsyncOp) {
            m_fAsyncEOD = TRUE;
            return TRUE;
        }

        //We got all the data and written it to disk.
        //Now, we'll pend a read to pick up the quit
        //response, to get any other mail the client
        //sends.  We need to re-initialize our class
        //variables first.

        ReInitClassVariables();

        _ASSERT (m_cbReceived < QueryMaxReadSize());

      }
      else
      {
        //else, format the appropriate message,
        //and delete all objects pertaining to
        //this file.

        //flush any pending responses
        SendSmtpResponse();

        //re-initialize out class variables
        ReInitClassVariables();

        _ASSERT (m_cbReceived < QueryMaxReadSize());
      }
  }


  TraceFunctLeaveEx((LPARAM) this);
  return fRet;
}

//-----------------------------------------------------------------------------
//  Description:
//      This function handles receiving the mailbody sent by a client using the
//      DATA command. It wraps the functionality of DoDATACommandEx (the
//      function to parse and process the mailbody) and AcceptAndDiscardDATA
//      (the function that handles errors that occur during DoDATACommandEx).
//
//      The reason for a separate function to do error processing for mailbody
//      errors is that when a mailbody error occurs, SMTP cannot directly abort
//      the transaction and return an error response. Instead it must continue
//      to post reads for the mailbody, and after the mailbody has been completely
//      received, respond with the appropriate error.
//
//      So when an error occurs during DoDATACommandEx, it stops processing and
//      sets m_MailBodyDiagnostic. AcceptAndDiscardData takes over and keeps
//      posting reads till the body has been sent by the client. Then it uses
//      m_MailBodyDiagnostic to generate the error response.
//
//  Arguments:
//      IN char *InputLine - Pointer to data being processed
//      IN DWORD UndecryptedTailSize - If using SSL, this is the encrypted tail
//      OUT BOOL *pfAsyncOp - Set to TRUE if a read of write was pended. In
//          this case.
//  Returns:
//      TRUE - Success. All received data must be passed into this function
//          till the state goes to HELO after which data should be parsed as
//          SMTP commands. Failures while processing DATA are caught internally
//          (flagged by m_MailBodyDiagnostic and m_MailBodyError) and we still
//          return TRUE.
//      FALSE - A failure occurred that cannot be handled (like a TCP/IP
//          failure). In this case we should disconnect.
//
//-----------------------------------------------------------------------------
BOOL SMTP_CONNECTION::ProcessDATAMailBody(const char *InputLine, DWORD UndecryptedTailSize, BOOL *pfAsyncOp)
{
    BOOL fReturn = TRUE;
    BOOL fWritePended = FALSE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::ProcessDATA");

    _ASSERT(m_State == DATA);

    *pfAsyncOp = FALSE;

    if(m_MailBodyDiagnostic != ERR_NONE)
        goto MAILBODY_ERROR;

    //
    // DoDATACommandEx handles parsing the mailbody, processing the headers and
    // persisting them to the IMailMsg, and writing the mailbody to a file. In
    // addition, when the mailbody has been received, it triggers the _EOD event
    // which may return async (due to installed event handlers). We pre-increment
    // the pending IO count to cover this case.
    //

    IncPendingIoCount();

    fReturn = DoDATACommandEx(InputLine, m_cbParsable, UndecryptedTailSize, &fWritePended, pfAsyncOp);
    _ASSERT(fReturn && "All errors are flagged by m_MailBodyDiagnostic and m_MailBodyError");

    //
    // DoDATACommandEx/CreateMailBody always return immediately after they pend I/Os
    // (expecting the I/O completion threads to resume processing). So if the I/O pend
    // succeeds, DoDATACommandEx must have succeeded.
    //

    if(*pfAsyncOp || fWritePended)
        _ASSERT(m_MailBodyDiagnostic == ERR_NONE);

    if(*pfAsyncOp)
    {
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //
    // Decrement the pending IO count since DoDataCommandEx returned sync (and
    // we incremented the count above). ProcessClient is above us in the
    // callstack and always has a pending IO reference, so this should never
    // return zero
    //

    _VERIFY(DecPendingIoCount() > 0);

    //
    // If a Write was pended we simply want to release this thread back to IIS
    // The completion thread will continue with the processing
    //

    if(fWritePended)
    {
        *pfAsyncOp = TRUE;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    if(m_MailBodyDiagnostic != ERR_NONE)
    {
        _ASSERT(!*pfAsyncOp && !fWritePended);

        //
        // Shift out bytes that already got parsed during DoDATACommandEx.
        //

        MoveMemory(QueryMRcvBuffer(), QueryMRcvBuffer() + m_cbRecvBufferOffset, m_cbParsable);
        m_cbRecvBufferOffset = 0;
        goto MAILBODY_ERROR;
    }

    if(m_State == DATA)
    {
        //
        // If the state is still equal to DATA, then we need to keep
        // pending reads to pickup the rest of the message.  When the
        // state changes to HELO, then we can stop pending reads, and
        // go back into parsing commands.
        //

        fReturn = PendReadIO(UndecryptedTailSize);
        *pfAsyncOp = TRUE;
        TraceFunctLeaveEx((LPARAM) this);
        return fReturn;
    }

    //
    // Done with mail body. Go back to parsing commands.
    //

    _ASSERT(m_State == HELO);
    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;

MAILBODY_ERROR:

    _ASSERT(m_MailBodyDiagnostic != ERR_NONE);

    //
    // DoBDATCommandEx (and other parts of smtpcli) use m_cbRecvBufferOffset to
    // keep track of bytes in the beginning of the recv buffer that have been
    // processed, but have not been shifted out (this is needed for header parsing).
    // All reads/processing therefore start at (recv buffer + offset). During error
    // processing however there's no parsing of headers, so this offset should be
    // set to 0 before calling into discard, and the saved bytes shifted out. The
    // ASSERT below verifies this.
    //

    _ASSERT(m_cbRecvBufferOffset == 0 && "All of recv buffer is not being used");

    fReturn = AcceptAndDiscardDATA(QueryMRcvBuffer(), UndecryptedTailSize, pfAsyncOp);

    //
    // If something failed during error processing, disconnect with an error
    // (this violates the RFC, but there's no option). If we succeeded and a
    // read was pended, all data in the input buffer has been consumed. The
    // read I/O completion thread will pick up processing.
    //

    if(!fReturn || *pfAsyncOp)
    {
        TraceFunctLeaveEx((LPARAM) this);
        return fReturn;
    }

    //
    // All the mailbody was processed and the input buffer contains only SMTP
    // commands. Fall through the the command parsing code.
    //

    _ASSERT(m_State == HELO);

    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;
}

//-----------------------------------------------------------------------------
//  Description:
//      Analogous to ProcessDATAMailBody
//  Arguments:
//      Same as ProcessDATAMailBody
//  Returns:
//      Same as ProcessDATAMailBody
//-----------------------------------------------------------------------------
BOOL SMTP_CONNECTION::ProcessBDATMailBody(const char *InputLine, DWORD UndecryptedTailSize, BOOL *pfAsyncOp)
{
    BOOL fWritePended = FALSE;
    BOOL fReturn = FALSE;
    _ASSERT(!m_fIsChunkComplete && m_State == BDAT);

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::ProcessBDATMailBody");

    *pfAsyncOp = FALSE;

    //
    // We are in the midst of error processing, skip right to it.
    //

    if(m_MailBodyDiagnostic != ERR_NONE)
        goto MAILBODY_ERROR;

    //
    // Increment the pending IO count in case DoBDATCommandEx returns async.
    // When the message is completely received, DoBDATCommandEx will trigger
    // into the _EOD event, which may optionally return async. This increment
    // serves to keep track of that.
    //

    IncPendingIoCount();

    fReturn = DoBDATCommandEx(InputLine, m_cbParsable, UndecryptedTailSize, &fWritePended, pfAsyncOp);

    if(m_MailBodyDiagnostic != ERR_NONE)
    {
        _ASSERT(!fWritePended && !*pfAsyncOp && "Shouldn't be pending read/write on failure");
        _VERIFY(DecPendingIoCount() > 0);
        goto MAILBODY_ERROR;
    }

    // The completion thread will call us when more data arrives
    if (*pfAsyncOp)
    {
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //
    // Decrement the pending IO count since DoBDATCommandEx returned sync (and
    // we incremented the count above). ProcessClient is above us in the
    // callstack and always has a pending IO reference, so this should never
    // return zero
    //

    _VERIFY(DecPendingIoCount() > 0);

    //
    // If a Write was pended we simply want to release this thread back to IIS
    // The completion thread will continue with the processing
    //

    if(fWritePended)
    {
        *pfAsyncOp = TRUE;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    if(m_State == BDAT && !m_fIsChunkComplete)
    {
        //
        // We still are not done with current chunk So Pend read to pickup the
        // rest of the chunk.  When the state changes to HELO or the current
        // chunk completes, then we can stop pending reads, and go back into
        // parsing commands.
        //

        fReturn = PendReadIO(UndecryptedTailSize);
        *pfAsyncOp = TRUE;
        TraceFunctLeaveEx((LPARAM) this);
        return fReturn;
    }
    else if(m_cbTempBDATLen)
    {
        //
        // Flush the response to the chunk just processed (why is this needed
        // specifically for m_cbTempBDATLen > 0 only? Shouldn't all responses
        // be treated equally -- gpulla).
        //

        SendSmtpResponse();
    }

    //
    // Done with current chunk. Go back to parsing commands.
    //

    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;

MAILBODY_ERROR:

    _ASSERT(m_MailBodyDiagnostic != ERR_NONE);

    //
    // m_cbTempBDATLen is an offset into the recv buffer. It is set to > 0 when
    // DoBDATCommandEx needs to save the start of a header that spans multiple
    // chunks. Since discard does no header parsing, this is unneccessary, and
    // the "offset" number of bytes (if non-zero) should be reset and shifted
    // out before calling into discard.
    //

    if(m_cbTempBDATLen)
    {
        MoveMemory(QueryMRcvBuffer(), QueryMRcvBuffer() + m_cbTempBDATLen, m_cbReceived);
        m_cbTempBDATLen = 0;
    }

    fReturn = AcceptAndDiscardBDAT(QueryMRcvBuffer(), UndecryptedTailSize, pfAsyncOp);

    //
    // If something failed during error processing, disconnect with an error
    // (this violates the RFC, but there's no option). If we succeeded and a
    // read was pended, all data in the input buffer has been consumed. The
    // read I/O completion thread will pick up processing.
    //

    if(!fReturn || *pfAsyncOp)
    {
        TraceFunctLeaveEx((LPARAM) this);
        return fReturn;
    }

    _ASSERT(m_nBytesRemainingInChunk == 0 && "Expected chunk to be done");

    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;
}

/*++

    Name :
        SMTP_CONNECTION::DoBDATCommandEx

    Description:

        Handles the data chunks received after a valid BDAT command.
        This funcion spools the mail to a directory.
                In the first chunk it parses for header.
                Once the header is written in current chunk and subsequent chunks it simply
                dumps the data to the disk
    Arguments:
        InputLine - Buffer received from client
        paramterSize - amount of data in buffer
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoBDATCommandEx(const char * InputLine1, DWORD ParameterSize, DWORD UndecryptedTailSize, BOOL *lpfWritePended, BOOL *pfAsyncOp)
{
  LPSTR InputLine = (LPSTR) InputLine1;
  BOOL fRet = TRUE;
  BOOL fProcess = TRUE;
  PSMTP_IIS_SERVICE     pService = (PSMTP_IIS_SERVICE) g_pInetSvc;

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoBDATCommandEx");

  _ASSERT (m_pInstance != NULL);

  *lpfWritePended = FALSE;

  // We make this call only while we are parsing the headers
  // Once we are done parsing the headers
  if(CreateMailBodyFromChunk (InputLine, ParameterSize, UndecryptedTailSize, lpfWritePended))
  {

      m_WritingData = FALSE;
      //increment our counters
      //make sure the size of the file is proper.
      //subtract 3 bytes accounting for the .CRLF.
      //We don't write that portion to the file.

      ADD_BIGCOUNTER(QuerySmtpInstance(), BytesRcvdMsg, (m_TotalMsgSize - 3));
      BUMP_COUNTER(QuerySmtpInstance(), NumMsgRecvd);

      //if there was no error while parsing the
      //header, and writimg the file to disk,
      //then save the rest of the file, send
      //a message id back to the client, and
      //queue the message
      if(m_MailBodyError == NO_ERROR)
      {

        //call HandleCompletedMessage() to see
        //if we should process this message
        fProcess = HandleCompletedMessage(BDAT, pfAsyncOp);
        if (*pfAsyncOp) {
            m_fAsyncEOD = TRUE;
            return TRUE;
        }

        //We got all the data and written it to disk.
        //Now, we'll pend a read to pick up the quit
        //response, to get any other mail the client
        //sends.  We need to re-initialize our class
        //variables first.

        ReInitClassVariables();

        _ASSERT (m_cbReceived < QueryMaxReadSize());
      }
      else
      {
        //else, format the appropriate message,
        //and delete all objects pertaining to
        //this file.

        if(m_MailBodyError == ERROR_BAD_LENGTH)
            FormatSmtpMessage (SMTP_RESP_MBX_SYNTAX,ESYNTAX_ERROR," %s\r\n","Badly formed BDAT Chunk");
        else
            FormatSmtpMessage (SMTP_RESP_NORESOURCES,ENO_RESOURCES," %s\r\n", SMTP_NO_STORAGE);

        //flush any pending responses
        SendSmtpResponse();

        //re-initialize out class variables
        ReInitClassVariables();

        _ASSERT (m_cbReceived < QueryMaxReadSize());
      }
  }


  TraceFunctLeaveEx((LPARAM) this);
  return fRet;
}

/*++

    Name :
        SMTP_CONNECTION::DoHELPCommand

    Description:

        Responds to the SMTP HELP command.
        send a help text description

    Arguments:
        Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoHELPCommand(const char * InputLine, DWORD parameterSize)
{
    BOOL RetStatus;
    char szHelpCmds[MAX_PATH];
    DWORD ConnectionStatus = 0;

    if(m_SecurePort)
        ConnectionStatus |= SMTP_IS_SSL_CONNECTION;
    if(m_fAuthenticated)
        ConnectionStatus |= SMTP_IS_AUTH_CONNECTION;

    _ASSERT (m_pInstance != NULL);

    //Check if the client is secure enough
    if (!IsClientSecureEnough()) {
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY," %s\r\n",SMTP_MSG_MUST_SECURE);
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        return TRUE;
    }

    if(!m_fAuthAnon && !m_fAuthenticated)
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY," %s\r\n", "Client was not authenticated");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        return TRUE;
    }

    strcpy(szHelpCmds,HelpText);

    if(m_pInstance->AllowAuth())
    {
        if(m_pInstance->QueryAuthentication() != 0)
        {
            strcat(szHelpCmds, " AUTH");

            if(g_SmtpPlatformType == PtNtServer && m_pInstance->AllowTURN())
            {
                strcat(szHelpCmds, " TURN");
            }
        }
    }

    if(g_SmtpPlatformType == PtNtServer && m_pInstance->AllowETRN())
    {
        strcat(szHelpCmds, " ETRN");
    }

    // Chunking related advertisements
    if(m_pInstance->AllowBinaryMime() || m_pInstance->AllowChunking())
    {
        strcat(szHelpCmds, " BDAT");
    }
    // verify
    if(m_pInstance->AllowVerify(ConnectionStatus))
    {
        strcat(szHelpCmds, " VRFY");
    }
    // Expand
    if(m_pInstance->AllowExpand(ConnectionStatus))
    {
        strcat(szHelpCmds, " EXPN");
    }

    PE_FormatSmtpMessage ("%s\r\n", szHelpCmds);

    RetStatus = PE_SendSmtpResponse();
    return RetStatus;
}

/*++

    Name :
        SMTP_CONNECTION::DoVRFYCommand

    Description:

        Responds to the SMTP VRFY command.
        send a help text description.  We
        do not really verify an address here.
        This function is just a stub.

    Arguments:
        The name to verify from the client

    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoVRFYCommand(const char * InputLine, DWORD ParameterSize)
{

    BOOL RetStatus = TRUE;
    char * VrfyAddr = NULL;
    char * DomainPtr = NULL;
    char * ArgPtr = NULL;
    char    szAddr[MAX_INTERNET_NAME + 1];

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoVRFYCommand");

    szAddr[0] = '\0';
    DWORD ConnectionStatus = 0;

    _ASSERT (m_pInstance != NULL);

    //Check if the client is secure enough
    if (!IsClientSecureEnough()) {
        ErrorTrace((LPARAM) this, "DoVrfyCommand - SMTP_RESP_MUST_SECURE, Must do STARTTLS first");
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

   if(!m_fAuthAnon && !m_fAuthenticated)
   {
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY," %s\r\n","Client was not authenticated");
        ErrorTrace((LPARAM) this, "DoVrfyCommand - SMTP_RESP_MUST_SECURE, user not authenticated");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
   }

    //start at the beginning;
    VrfyAddr = (char *) InputLine;

    //check the arguments for good form
    VrfyAddr = CheckArgument(VrfyAddr);
    if (VrfyAddr == NULL)
    {
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    if(ExtractAndValidateRcpt(VrfyAddr, &ArgPtr, szAddr, &DomainPtr))
    {
        //The address is valid
        //Do we allow verify
        if(m_SecurePort)
            ConnectionStatus |= SMTP_IS_SSL_CONNECTION;
        if(m_fAuthenticated)
            ConnectionStatus |= SMTP_IS_AUTH_CONNECTION;

        if(!m_pInstance->AllowVerify(ConnectionStatus))
        {
            PE_CdFormatSmtpMessage (SMTP_RESP_VRFY_CODE, EVALID_DEST_ADDRESS," %s <%s>\r\n", "Cannot VRFY user, but will accept message for", szAddr);
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
        }
        //Check the domain to be either belonging to a ALIAS,DEFAULT,DROP,DELIVER
        //We also check the relay restrictions
        if(!ShouldAcceptRcpt(DomainPtr))
        {
           PE_CdFormatSmtpMessage (SMTP_RESP_NOT_FOUND, ENO_FORWARDING, " Cannot relay to <%s>\r\n",szAddr);
        }
        else
        {
           PE_CdFormatSmtpMessage (SMTP_RESP_VRFY_CODE, EVALID_DEST_ADDRESS," %s <%s>\r\n", "Cannot VRFY user, but will take message for", szAddr);
        }
    }
    else
    {
        //it failed.  Inform the user
        HandleAddressError((char *)InputLine);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}

//
// Reply strings
//

typedef struct _AUTH_REPLY {
    LPSTR Reply;
    DWORD Len;
} AUTH_REPLY, *PAUTH_REPLY;

char *
SzNextSeparator(IN char * sz, IN CHAR ch1, IN CHAR ch2)
{
        char *   sz1 = NULL;
        char *   sz2 = NULL;
        sz1 = strchr(sz, ch1);
        sz2 = strchr(sz, ch2);

        if (sz1 == sz2)
                return sz1;
        else if (sz1 > sz2)
                return sz2 ? sz2 : sz1;
        else
                return sz1 ? sz1 : sz2;
}

BOOL SMTP_CONNECTION::DoUSERCommand(const CHAR *InputLine, DWORD dwLineSize, unsigned char * OutputBuffer, DWORD * dwBytes, DWORD * ResponseCode, char * szECode)
{
    char    szUserName[MAX_USER_NAME_LEN + MAX_SERVER_NAME_LEN +1];
    char    szLogonDomainAndUserName[MAX_USER_NAME_LEN + (2 * (MAX_SERVER_NAME_LEN + 1))];
    char    lpszDefaultLogonDomain [MAX_SERVER_NAME_LEN + 1];
    char *  pSeparator1 = NULL;
    char *  pSeparator2 = NULL;
    BUFFER BuffData;
    DWORD DecodedLen = 0;
    DWORD BuffLen = 0;
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::DoUSERCommand");

    *ResponseCode = SMTP_RESP_AUTH1_PASSED;;

    m_pInstance->LockGenCrit();

    lstrcpyn(lpszDefaultLogonDomain, m_pInstance->GetDefaultLogonDomain(), MAX_SERVER_NAME_LEN);

    m_pInstance->UnLockGenCrit();

    if(!uudecode ((char *) InputLine, &BuffData, &DecodedLen, FALSE) ||
        (DecodedLen == 0))
    {
        *ResponseCode = SMTP_RESP_BAD_ARGS;
        lstrcpy((char *)szECode, "5.7.3");
        lstrcpy((char *) OutputBuffer, "Cannot decode arguments");
        m_securityCtx.Reset();
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    lstrcpyn(szUserName, (char *) BuffData.QueryPtr(), sizeof(szUserName) - 1);
    lstrcpyn(m_szUserName, (char *) BuffData.QueryPtr(), sizeof(m_szUserName) - 1);

    if (UseMbsCta())
    {
        // MBS clear text authentication, does not support domain
        m_pInstance->LockGenCrit();
        lstrcpyn(m_szUsedAuthMechanism, m_pInstance->GetCleartextAuthPackage(), MAX_PATH);
        m_pInstance->UnLockGenCrit();

        lstrcpy(szLogonDomainAndUserName, szUserName);
    }
    else
    {
        // if NT clear text authentication is used, we do some special operations:
        lstrcpyn(m_szUsedAuthMechanism, "NT_BASIC", MAX_PATH);

        // if no default logon domain is not present in user name, and default
        // logon domain is set, then prepend default logon domain to username
        pSeparator1 = SzNextSeparator(szUserName,'\\','/');

        if(pSeparator1 == NULL && (lpszDefaultLogonDomain[0] != '\0'))
        {
            wsprintf(szLogonDomainAndUserName, "%s/%s", lpszDefaultLogonDomain, szUserName);
        }
        else
        {
            if( pSeparator1 != NULL )
            {
                //
                // HACK-O-RAMA: bug 74776 hack, if a username comes in with "REDMOND\\user"
                // allow it. This is to allow buggy Netscape 4.0 browser client to work.
                //

                if( ( (*pSeparator1) == '\\' ) && ( (*(pSeparator1+1)) == '\\' ) )
                {
                    MoveMemory( pSeparator1, pSeparator1+1, strlen( pSeparator1 ) );
                }


                //check if we have the mailbox name at the end
                pSeparator2 = SzNextSeparator(pSeparator1 + 1,'\\','/');


                if(pSeparator2 != NULL)
                {
                    //If we do simply ignore it by terminating the user string there
                    *pSeparator2 = '\0';
                }
            }
            lstrcpy(szLogonDomainAndUserName, szUserName);
        }
    }

    DebugTrace((LPARAM)this, "LogonDomainAndUser: %s", szLogonDomainAndUserName);

    fRet = ProcessAuthInfo(AuthCommandUser, szLogonDomainAndUserName, OutputBuffer, &BuffLen);
    if(!fRet)
    {
        *ResponseCode = SMTP_RESP_AUTH_REJECT;
        lstrcpy((char *)szECode, "5.7.3");
        lstrcpy((char *) OutputBuffer, "5.7.3 Invalid user name");
        *dwBytes = lstrlen("Invalid user name");
    }
    else
    {
        *dwBytes = BuffLen;
    }

    return fRet;
}


//+---------------------------------------------------------------
//
//  Function:   SMTP_CONNECTION::DoPASSCommand
//
//  Synopsis:   Valid in the Authorization State.
//              pswd for clear-text logon
//
//              PASS password\r\n
//
//  Arguments:  const CHAR *:   argument line
//              DWORD:          sizeof argument line
//
//  Returns:    BOOL:   continue processing
//
//----------------------------------------------------------------
BOOL SMTP_CONNECTION::DoPASSCommand(const CHAR *InputLine, DWORD dwLineSize, unsigned char * OutputBuffer, DWORD * dwBytes, DWORD *ResponseCode, char * szECode)
{
    BOOL    fStatus = TRUE;
    BUFFER BuffData;
    DWORD DecodedLen = 0;
    DWORD BuffLen = 0;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::DoPASSCommand");

    *ResponseCode = SMTP_RESP_AUTHENTICATED;

    if(!uudecode ((char *)InputLine, &BuffData, &DecodedLen, FALSE))
    {
        m_RecvdAuthCmd = FALSE;
        m_fClearText = FALSE;
        m_State = HELO;
        *ResponseCode = SMTP_RESP_BAD_ARGS;

        if ( ++m_dwUnsuccessfulLogons >= m_pInstance->GetMaxLogonFailures() )
        {
            ErrorTrace((LPARAM)this, "Logon failed");
            DisconnectClient( ERROR_LOGON_FAILURE );
        }

        lstrcpy((char *)szECode, "5.7.3");
        lstrcpy((char *) OutputBuffer, "Cannot decode password");
        m_securityCtx.Reset();
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    OutputBuffer[0] = '\0';
    fStatus = ProcessAuthInfo( AuthCommandPassword, (char *) BuffData.QueryPtr(), OutputBuffer, &BuffLen );
    if (!fStatus)
    {
        ErrorTrace( (LPARAM)this, "Bad pswd %s", QueryClientUserName() );
        *ResponseCode = SMTP_RESP_AUTH_REJECT;
        lstrcpy((char *)szECode, "5.7.3");
        lstrcpy((char *) OutputBuffer, "Authentication unsuccessful");

        if ( ++m_dwUnsuccessfulLogons >= m_pInstance->GetMaxLogonFailures() )
        {
            ErrorTrace((LPARAM)this, "Logon failed");
            DisconnectClient( ERROR_LOGON_FAILURE );
        }
        else
        {
            m_RecvdAuthCmd = FALSE;
            m_fClearText = FALSE;
            m_State = HELO;
        }
    }

    *dwBytes = BuffLen;
    TraceFunctLeaveEx((LPARAM)this);
    return fStatus;
}

BOOL SMTP_CONNECTION::ProcessAuthInfo(AUTH_COMMAND Command, LPSTR Blob, unsigned char * OutBuff, DWORD * dwBytes)
{
    DWORD                   nbytes = 0;
    REPLY_LIST              replyID;
    BOOL                    f = TRUE;

    m_pInstance->LockGenCrit();
    f = m_securityCtx.ProcessAuthInfo(m_pInstance, Command, Blob,
        OutBuff, &nbytes, &replyID);
    m_pInstance->UnLockGenCrit();

    *dwBytes = nbytes;

    //
    // if replyID == NULL we're conversing for challenge/response logon
    //
    if ( replyID == SecNull )
    {
        _ASSERT( nbytes != 0 );
    }

    if (m_securityCtx.IsAuthenticated())
    {
        f = TRUE;
    }

    if ( f == FALSE )
    {
        //
        // if we fail for any reason reset the state to accept user/auth/apop
        //
        m_securityCtx.Reset();
    }

    return  f;
}


//+---------------------------------------------------------------
//
//  Function:   SMTP_CONNECTION::DoAuthNegotiation
//
//  Synopsis:   process base64/uuendcoded blobs in AUTH_NEGOTIATE
//
//              base64 text\r\n
//
//  Arguments:  const CHAR *:   argument line
//              DWORD:          sizeof argument line
//
//  Returns:    BOOL:   continue processing
//
//----------------------------------------------------------------
BOOL SMTP_CONNECTION::DoAuthNegotiation(const CHAR *InputLine, DWORD dwLineSize)
{
    //The size of the output buffer should vary with the package being used.
    //Currently we use a quickfix which should work for LOGIN and NTLM but will
    //fail for other (new) packages if the response string > 25*255+1. Replace
    //this by a CBuffer later. Size of the CBuffer should be the max token size
    //for the package from CACHED_CREDENTIAL::GetCachedCredential.
    //GPulla, 6/15/1999

    unsigned char OutputBuff[MAX_REPLY_SIZE];
    char szECode[25];
    BOOL fAuthed = TRUE;
    BUFFER BuffData;
    DWORD ResponseCode;
    DWORD dwBytes = 0;
    BOOL fDoBase64 = FALSE;
    char * pszSearch = NULL;

    TraceFunctEnterEx((LPARAM)this, "DoAuthNegotiation");

    if (m_cbParsable >= QueryMaxReadSize())
    {
        m_cbParsable = 0;
        m_ProtocolErrors++;
    }

    pszSearch = IsLineComplete(InputLine,m_cbParsable);
    if(pszSearch == NULL)
    {
        TraceFunctLeaveEx((LPARAM)this);
        return TRUE;
    }

    *pszSearch = '\0';
    m_cbParsable = 0;
    if(!lstrcmp(InputLine, "*"))
    {
        FormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS, " %s\r\n", "Auth command cancelled");
        m_fDidUserCmd = FALSE;
        m_RecvdAuthCmd = FALSE;
        m_fClearText = FALSE;
        m_State = HELO;
        m_securityCtx.Reset();
        SendSmtpResponse();
        ProtocolLog(AUTH, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_ARGS, 0, 0);
        TraceFunctLeaveEx((LPARAM)this);
        return TRUE;
    }

    if(m_fClearText)
    {
        if(m_fDidUserCmd)
        {
            if(DoPASSCommand(InputLine, dwLineSize, OutputBuff, &dwBytes, &ResponseCode, szECode))
            {
                m_State = HELO;
                m_fAuthenticated = TRUE;
                lstrcpy((char *)szECode, "2.7.0");
                lstrcpy((char *)OutputBuff, "Authentication successful");
            }
            else
            {
                fAuthed = FALSE;
//                lstrcpy((char *)OutputBuff, "5.7.3 Authentication unsuccessful");
            }
        }
        else
        {
            if(DoUSERCommand(InputLine, dwLineSize, OutputBuff, &dwBytes, &ResponseCode, szECode))
            {
                lstrcpy((char *)OutputBuff, PasswordParam);
                m_fDidUserCmd = TRUE;
                fDoBase64 = TRUE;
            }
            else
            {
                fAuthed = FALSE;
            }
        }

        if(fDoBase64)
        {
            if(!uuencode ((unsigned char *)OutputBuff, lstrlen((char *) OutputBuff), &BuffData, FALSE))
            {
                TraceFunctLeaveEx((LPARAM)this);
                return FALSE;
            }
            else
            {
               FormatSmtpMessage  (ResponseCode,NULL," %s\r\n", BuffData.QueryPtr());
            }
        }
        else
        {
           FormatSmtpMessage  (ResponseCode,szECode," %s\r\n", OutputBuff);
        }

        ProtocolLog(AUTH, (char *) QueryClientUserName(), NO_ERROR, ResponseCode, 0, 0);
    }
    else
    {
        fAuthed = ProcessAuthInfo( AuthCommandTransact, (LPSTR)InputLine, OutputBuff, &dwBytes );
        if(fAuthed)
        {
            if(m_securityCtx.IsAuthenticated())
            {
                m_State = HELO;
                m_fAuthenticated = TRUE;
                fAuthed = TRUE;
                PE_CdFormatSmtpMessage (SMTP_RESP_AUTHENTICATED, ESEC_SUCCESS," %s\r\n", "Authentication successful");
                ProtocolLog(AUTH, (char *) QueryClientUserName(), NO_ERROR, SMTP_RESP_AUTHENTICATED, 0, 0);
            }
            else
            {
                FormatSmtpMessage (SMTP_RESP_AUTH1_PASSED,NULL," ");
                FormatSmtpMessage(OutputBuff, dwBytes);
            }
        }
        else
        {
            FormatSmtpMessage (SMTP_RESP_AUTH_REJECT, ENO_SECURITY, " %s\r\n", "Authentication unsuccessful");
            ProtocolLog(AUTH, (char *) QueryClientUserName(), NO_ERROR, SMTP_RESP_AUTH_REJECT, 0, 0);
        }
    }

    if(!fAuthed)
    {
        m_State = HELO;
        m_RecvdAuthCmd = FALSE;
        m_fDidUserCmd = FALSE;
    }

    SendSmtpResponse();
    TraceFunctLeaveEx((LPARAM)this);
    return fAuthed;
}

/*++

    Name :
        SMTP_CONNECTION::DoAUTHCommand

    Description:
        This function performs authentication
        for the SMTP service
    Arguments:
        Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoAUTHCommand(const char * InputLine, DWORD ParameterSize)
{
    BOOL fAuthPassed = TRUE;
    char * pMechanism = NULL;
    char * pInitialResponse = NULL;

    //The size of the output buffer should vary with the package being used.
    //Currently we use a quickfix which should work for LOGIN and NTLM but will
    //fail for other (new) packages if the response string > 25*255+1. Replace
    //this by a CBuffer later. Size of the CBuffer should be the max token size
    //for the package from CACHED_CREDENTIAL::GetCachedCredential.
    //GPulla, 6/15/1999

    unsigned char OutputBuffer[MAX_REPLY_SIZE];
    char szECode[16];
    BUFFER BuffData;
    DWORD DecodedLen = 0;
    DWORD dwBytes = 0;
    DWORD ResponseCode;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoAUTHCommand");

    //Do we allow AUTH command
    if(!m_pInstance->AllowAuth())
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_CMD, ENOT_IMPLEMENTED," %s\r\n", SMTP_BAD_CMD_STR);
        ProtocolLog(AUTH, (char *) QueryClientUserName(), NO_ERROR, SMTP_RESP_BAD_CMD, 0, 0);
        ++m_ProtocolErrors;
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;

    }

    //check if helo was sent
    if(!m_pInstance->AllowMailFromNoHello() && !m_HelloSent)
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n", "Send hello first" );
        ProtocolLog(AUTH, (char *) QueryClientUserName(), NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
        ++m_ProtocolErrors;
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    OutputBuffer[0] = '\0';

    //Check if the client is secure enough
    if (!IsClientSecureEnough())
    {
      ProtocolLog(AUTH, (char *) QueryClientUserName(), NO_ERROR, SMTP_RESP_MUST_SECURE, 0, 0);
      ErrorTrace((LPARAM) this, "DoAuthCommand - SMTP_RESP_MUST_SECURE, Must do STARTTLS first");
      TraceFunctLeaveEx((LPARAM) this);
      return TRUE;
    }

    //disallow mail from more than once
    if(m_RecvdAuthCmd)
    {
        ++m_ProtocolErrors;
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR," %s\r\n", "Auth already specified" );
        ProtocolLog(AUTH, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
        ErrorTrace((LPARAM) this, "DoAuthCommand - SMTP_RESP_BAD_SEQ, Sender already specified");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //
    // Check syntax: one required parameter, and one optional parameter
    //

    pMechanism = strtok((char *) InputLine, WHITESPACE);
    pInitialResponse = strtok(NULL, WHITESPACE);

    if(pMechanism == NULL)
    {
        ++m_ProtocolErrors;
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS, " %s\r\n","No mechanism" );
        ProtocolLog(AUTH, (char *) InputLine, NO_ERROR, SMTP_RESP_BAD_SEQ, 0, 0);
        ErrorTrace((LPARAM) this, "DoAuthCommand - SMTP_RESP_BAD_SEQ, Sender already specified");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    strncpy(m_szUsedAuthKeyword, pMechanism, sizeof(m_szUsedAuthKeyword)-1);
    if(!lstrcmpi(pMechanism, "login"))
    {
        if(m_pInstance->QueryAuthentication() & INET_INFO_AUTH_CLEARTEXT)
        {
            m_fClearText = TRUE;

            if(pInitialResponse)
            {
                if(DoUSERCommand((const char *) pInitialResponse, lstrlen(pInitialResponse), OutputBuffer, &dwBytes, &ResponseCode, szECode))
                {
                    m_fDidUserCmd = TRUE;
                }
                else
                {
                    PE_CdFormatSmtpMessage (ResponseCode, szECode," %s\r\n",OutputBuffer );
                    ProtocolLog(AUTH, (char *) QueryClientUserName(), NO_ERROR, SMTP_RESP_PARM_NOT_IMP, 0, 0);
                    fAuthPassed = FALSE;
                }
            }
        }
        else
        {
            PE_CdFormatSmtpMessage (SMTP_RESP_PARM_NOT_IMP, ENO_SEC_PACKAGE, " %s \r\n","Unrecognized authentication type" );
            ProtocolLog(AUTH, (char *) QueryClientUserName(), NO_ERROR, SMTP_RESP_PARM_NOT_IMP, 0, 0);
            fAuthPassed = FALSE;
        }
    }
    else
    {
        /*
        //
        // Switch over to using a large receive buffer, because a AUTH blob
        // may be up to 32K big.
        BOOL fStartSASL = SwitchToBigSSLBuffers();
        if (fStartSASL) {
        //PE_CdFormatSmtpMessage(SMTP_RESP_READY, EPROT_SUCCESS," %s\r\n",  SMTP_READY_STR);
        ProtocolLog(AUTH, (char *) InputLine, NO_ERROR, SMTP_RESP_READY, 0, 0);
        } else {
          PE_CdFormatSmtpMessage(SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n", SMTP_NO_MEMORY);
          ProtocolLog(AUTH, (char *) InputLine, NO_ERROR, SMTP_RESP_NORESOURCES, 0, 0);
        }
        */

        //
        // Register our principal names, if necessary
        //

        QuerySmtpInstance()->RegisterServicePrincipalNames(TRUE);

        if(ProcessAuthInfo( AuthCommandTransact, pMechanism, OutputBuffer, &dwBytes ) == FALSE )
        {
            fAuthPassed = FALSE;
            PE_CdFormatSmtpMessage (SMTP_RESP_PARM_NOT_IMP, ENO_SEC_PACKAGE, " %s \r\n", "Unrecognized authentication type" );
            ProtocolLog(AUTH, (char *) QueryClientUserName(), NO_ERROR, SMTP_RESP_PARM_NOT_IMP, 0, 0);
        }
        else if(pInitialResponse)
        {
            if(ProcessAuthInfo( AuthCommandTransact, pInitialResponse, OutputBuffer, &dwBytes ) == FALSE )
            {
                PE_CdFormatSmtpMessage (SMTP_RESP_AUTH_REJECT, EINVALID_ARGS, " %s\r\n","Cannot authenticate parameter" );
                ProtocolLog(AUTH, (char *) QueryClientUserName(), NO_ERROR, SMTP_RESP_AUTH_REJECT, 0, 0);
                fAuthPassed = FALSE;
            }
        }
    }

    if(fAuthPassed)
    {
        m_RecvdAuthCmd = TRUE;
        m_State = AUTH;

        if(!pInitialResponse)
        {
            if(!m_fClearText)
            {
                PE_CdFormatSmtpMessage (SMTP_RESP_AUTH1_PASSED,NULL," %s supported\r\n", pMechanism);
            }
            else
            {
                if(!uuencode ((unsigned char *)UserParam, lstrlen(UserParam), &BuffData, FALSE))
                {
                    TraceFunctLeaveEx((LPARAM)this);
                    return TRUE;
                }
                else
                {
                    PE_CdFormatSmtpMessage (SMTP_RESP_AUTH1_PASSED,NULL," %s\r\n", BuffData.QueryPtr());
                }

            }
        }
        else
        {
            if(!m_fClearText)
            {
                PE_CdFormatSmtpMessage (SMTP_RESP_AUTH1_PASSED,NULL," ");
                OutputBuffer[dwBytes] = '\0';
                PE_FormatSmtpMessage("%s\r\n",OutputBuffer);
            }
            else
            {
                if(!uuencode ((unsigned char *)PasswordParam, lstrlen(PasswordParam), &BuffData, FALSE))
                {
                    TraceFunctLeaveEx((LPARAM)this);
                    return TRUE;
                }

                PE_CdFormatSmtpMessage (SMTP_RESP_AUTH1_PASSED,NULL," %s\r\n", BuffData.QueryPtr());
            }
        }

    }
    else
        m_ProtocolErrors++; //even though we kick out the connection
                            //after MaxLogonFailures, count this as a
                            //protocol error


    TraceFunctLeaveEx((LPARAM) this);
    return(TRUE);
}

BOOL SMTP_CONNECTION::DoTURNCommand(const char * InputLine, DWORD parameterSize)
{
    sockaddr_in AddrRemote;
    SMTP_CONNOUT * SmtpConn = NULL;
    DWORD Error = 0;
    DWORD Options = 0;
    char * pszUserName = "";
    MULTISZ*  pmsz = NULL;
    TURN_DOMAIN_LIST TurnDomainList;

    LPSTR pszAuthenticatedUserName = NULL;
    const char * StartPtr = NULL;
    BOOL Found = FALSE;

    ISMTPConnection    *pISMTPConnection = NULL;
    char Domain[MAX_INTERNET_NAME];
    Domain[0] = '\0';
    DWORD DomainOptions = 0;
    HRESULT hr = S_OK;
    DomainInfo DomainParams;
    ZeroMemory (&DomainParams, sizeof(DomainParams));
    DomainParams.cbVersion = sizeof(DomainParams);

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoTurnCommand");

    //check if helo was sent
    if(!m_pInstance->AllowMailFromNoHello() && !m_HelloSent)
    {
        ErrorTrace((LPARAM) this, "In TURN - Hello not sent");
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR, " %s\r\n","Send hello first" );
        ++m_ProtocolErrors;
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //Check if the client is secure enough
    if (!IsClientSecureEnough())
    {
        ErrorTrace((LPARAM) this, "DoTURNCommand - SMTP_RESP_MUST_SECURE, Must do STARTTLS first");
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    if(!m_fAuthenticated)
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY, " %s\r\n", "Client was not authenticated");
        ErrorTrace((LPARAM) this, "DoTURNCommand - SMTP_RESP_MUST_SECURE, user not authenticated");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    if(m_securityCtx.QueryUserName())
        ErrorTrace((LPARAM) this, "Looking up user %s in TURN table", m_securityCtx.QueryUserName());

    pmsz = new MULTISZ();
    if(pmsz == NULL)
    {
        Error = GetLastError();
        PE_CdFormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_MEMORY );
        FatalTrace((LPARAM) this, "SMTP_CONNOUT::CreateSmtpConnection failed for TURN");
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    pmsz->Reset();

    // Do we have a username from an AUTH sink? If not use anything from SMTP auth
    pszAuthenticatedUserName =
        m_szAuthenticatedUserNameFromSink[0] ?
        m_szAuthenticatedUserNameFromSink : m_securityCtx.QueryUserName();

    QuerySmtpInstance()->IsUserInTurnTable(pszAuthenticatedUserName, pmsz);
    //QuerySmtpInstance()->IsUserInTurnTable("joe", &msz);

    if(pmsz->IsEmpty())
    {
        delete pmsz;
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY," %s\r\n","This authenticated user is not allowed to issue TURN");
        ErrorTrace((LPARAM) this, "DoTURNCommand - SMTP_RESP_MUST_SECURE, user not in turn table");
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    //Determine the primary domain in the list of domains that are to be turned
    //The primary domain is one that matches the domain name specified in the EHLO command
    //NimishK : What if EHLO is not provided
    //
    for (StartPtr = pmsz->First();
        ( (StartPtr != NULL) && !QuerySmtpInstance()->IsShuttingDown());
            StartPtr = pmsz->Next( StartPtr ))
    {
        ErrorTrace((LPARAM) this, "looking for %s in TURN domains", QueryClientUserName());
        if(!lstrcmpi(QueryClientUserName(), StartPtr))
        {
            Found = TRUE;
            break;
        }
    }

    //If we can determine the primary domain - we get the ISMTPCONNECTION for that domain
    //else we get the first domain in the list and get the ISMTPCONNECTION for it
    BOOL fPrimaryDomain = FALSE;
    if(!Found)
        StartPtr = pmsz->First();
    else
        fPrimaryDomain = TRUE;

    //We need to keep walking the list of domains that are to be turned
    //till we get a valid ISMTPCONN or run out of domains
    while(StartPtr && !QuerySmtpInstance()->IsShuttingDown())
    {
        hr = QuerySmtpInstance()->GetConnManPtr()->GetNamedConnection(lstrlen(StartPtr), (CHAR*)StartPtr, &pISMTPConnection);
        if(FAILED(hr))
        {
            //Something bad happened on this call
            //report to client
            delete pmsz;
            PE_CdFormatSmtpMessage (SMTP_ERROR_PROCESSING_CODE, ENO_RESOURCES," %s\r\n", "Error processing the command");
            ErrorTrace((LPARAM) this, "DoTURNCommand - SMTP_ERROR_PROCESSING_CODE, GetNamedConnection failed %d",hr);
            BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
            ++m_ProtocolErrors;
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
        }

        //If the link corresponding to this domain does not exist in AQ, we get a NULL
        //ISMTPConnection at this point
        //If we do there is nothing to TURN
        if(pISMTPConnection)
            break;
        else
        {
            if(fPrimaryDomain)
            {
                StartPtr = pmsz->First();
                fPrimaryDomain = FALSE;
            }
            else
            {
                StartPtr = pmsz->Next( StartPtr );
            }
            continue;
        }

    }
    if(pISMTPConnection == NULL && StartPtr == NULL)
    {
        //We ran out of the domains and there is not a single link
        PE_CdFormatSmtpMessage (250, EPROT_SUCCESS, " %s\r\n", "Server was turned");
        PE_SendSmtpResponse();

        PE_FormatSmtpMessage ("%s\r\n","QUIT");
        PE_SendSmtpResponse();

        //we will disconnect indirectly by returning false
        //DisconnectClient();

        return FALSE;

    }
    else
    {
        //leave quickly if we are shutting down
        if(QuerySmtpInstance()->IsShuttingDown()
            || (QuerySmtpInstance()->QueryServerState( ) == MD_SERVER_STATE_STOPPED)
            || (QuerySmtpInstance()->QueryServerState( ) == MD_SERVER_STATE_INVALID))
        {
            if(pISMTPConnection)
            {
                //Ack the last connection
                pISMTPConnection->AckConnection((eConnectionStatus)CONNECTION_STATUS_OK);
                pISMTPConnection->Release();
                pISMTPConnection = NULL;
            }
            delete pmsz;
            TraceFunctLeaveEx((LPARAM)this);
            return FALSE;
        }

        DomainParams.szDomainName = Domain;
        DomainParams.cbDomainNameLength = sizeof(Domain);
        hr = pISMTPConnection->GetDomainInfo(&DomainParams);


        TurnDomainList.pmsz = pmsz;
        //If we just got the ISMTPCOnn for the primary domain then we probably
        //jumped over a few domains in the domain list.
        //Set the ptr to start of the domain list
        //That way we will look at all the domains, once we are done with the
        //current primary domain
        if(fPrimaryDomain)
        {
            TurnDomainList.szCurrentDomain = pmsz->First();
            fPrimaryDomain = FALSE;
        }
        else
        {
            //Looks like we failed to get primary domain
            //so got to have started from the top - continue that
            TurnDomainList.szCurrentDomain = StartPtr;
        }

        //If we could not determine a primary domain - use the base
        //connection options
        if(!Found)
            DomainOptions = 0;
        else
            DomainOptions = DomainParams.dwDomainInfoFlags;

        //set the remote IP address we connected to
        AddrRemote.sin_addr.s_addr = 0;

        //
        //  Create an outbound connection
        //  Note: The last parameter, m_pSSLVerificationName is NULL. This is the
        //  name used to match against the SSL certificate that the server gives
        //  us during an outbound session. Setting it to NULL skips certificate
        //  subject validation, which is fine in the case of TURN, since either
        //  the server is already authenticated through other means (if ATRN) or
        //  we don't care about authentication (if TURN is configured).
        //
        SmtpConn = SMTP_CONNOUT::CreateSmtpConnection(
                                        QuerySmtpInstance(),
                                        (SOCKET) m_pAtqContext->hAsyncIO,
                                        (SOCKADDR_IN *)&AddrRemote,
                                        (SOCKADDR_IN *)&AddrRemote,
                                        NULL,
                                        (PVOID)&TurnDomainList,
                                        0,
                                        DomainOptions,
                                        NULL);
        if(SmtpConn == NULL)
        {
            delete pmsz;
            Error = GetLastError();
            PE_CdFormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_MEMORY );
            FatalTrace((LPARAM) this, "SMTP_CONNOUT::CreateSmtpConnection failed for TURN");
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            TraceFunctLeaveEx((LPARAM) this);
            return TRUE;
        }

        //from here on, the smtpout class is responsible for
        //cleaning up the AtqContext
        m_DoCleanup = FALSE;

        SmtpConn->SetAtqContext(m_pAtqContext);

        //copy the real domain we are connected to.
        SmtpConn->SetConnectedDomain((char *) Domain);
        AtqContextSetInfo(m_pAtqContext, ATQ_INFO_COMPLETION, (DWORD_PTR) InternetCompletion);
        AtqContextSetInfo(m_pAtqContext, ATQ_INFO_COMPLETION_CONTEXT, (DWORD_PTR) SmtpConn);
        AtqContextSetInfo(m_pAtqContext, ATQ_INFO_TIMEOUT, m_pInstance->GetRemoteTimeOut());


        //insert the outbound connection object into
        //our list of outbound conection objects
        if(!QuerySmtpInstance()->InsertNewOutboundConnection(SmtpConn, TRUE))
        {
            Error = GetLastError();
            FatalTrace((LPARAM) this, "m_pInstance->InsertNewOutboundConnection failed for TURN");
            SmtpConn->DisconnectClient();
            delete SmtpConn;
            SmtpConn = NULL;
            SetLastError(Error);
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }

        SmtpConn->SetCurrentObject(pISMTPConnection);
        PE_CdFormatSmtpMessage (250, EPROT_SUCCESS, " %s\r\n", "Server was turned");
        PE_SendSmtpResponse();

    }

    //start session will pend a read to pick
    //up the servers signon banner
    if(!SmtpConn->StartSession())
    {
        //get the error
        Error = GetLastError();
        FatalTrace((LPARAM) this, "SmtpConn->StartSession failed for TURN");
        SmtpConn->DisconnectClient();
        QuerySmtpInstance()->RemoveOutboundConnection(SmtpConn);
        delete SmtpConn;
        SmtpConn = NULL;
        SetLastError (Error);
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    m_State = TURN;

    TraceFunctLeaveEx((LPARAM) this);
    return(FALSE);

}

/*++

    Name :
        SMTP_CONNECTION::DoLASTCommand

    Description:
        This is our catch all error function.
        It will determin what kind of error
        made it execute and send an appropriate
        message back to the client.
    Arguments:
        Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNECTION::DoLASTCommand(const char * InputLine, DWORD parameterSize)
{
  BOOL RetStatus = TRUE;

  TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoLASTCommand");

  _ASSERT (m_pInstance != NULL);

   PE_CdFormatSmtpMessage (SMTP_RESP_BAD_CMD, ENOT_IMPLEMENTED," %s\r\n", SMTP_BAD_CMD_STR);
   BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
   m_ProtocolErrors++;
   PE_SendSmtpResponse();

   TraceFunctLeaveEx((LPARAM) this);
   return RetStatus;
}

/*++

    Name :
        SMTP_CONNECTION::VerifiyClient

    Description:
        This function compares the IP address the connection
        was made on to the IP address of the name given with
        the HELO or EHLO commands

    Arguments:
        ClientHostName - from HELO or EHLO command
        KnownIpAddress - from accept
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
DWORD SMTP_CONNECTION::VerifiyClient (const char * ClientHostName, const char * KnownIpAddress)
{
    in_addr UNALIGNED * P_Addr = NULL;
    PHOSTENT Hp = NULL;
    DWORD KnownClientAddress = 0;
    DWORD dwRet = SUCCESS;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::VerifiyClient");

    Hp = gethostbyname (ClientHostName);
    if (Hp == NULL)
    {
        DWORD dwErr = WSAGetLastError();
        if(dwErr == WSANO_DATA)
            dwRet = NO_MATCH;
        else
            dwRet = LOOKUP_FAILED;

        TraceFunctLeaveEx((LPARAM) this);
        return dwRet;
    }

    KnownClientAddress = inet_addr (KnownIpAddress);
    if (KnownClientAddress == INADDR_NONE)
    {
        dwRet = LOOKUP_FAILED;
        TraceFunctLeaveEx((LPARAM) this);
        return dwRet;
    }

    while( (P_Addr = (in_addr UNALIGNED *)*Hp->h_addr_list++) != NULL)
    {
        if (P_Addr->s_addr == KnownClientAddress)
        {
            TraceFunctLeaveEx((LPARAM) this);
            return dwRet;
        }
    }

    dwRet = NO_MATCH;
    TraceFunctLeaveEx((LPARAM) this);
    return dwRet;
}

/*++

    Name :
        void SMTP_CONNECTION::HandleAddressError(char * InputLine)

    Description:
        common code to determine what error occurred
        as a result of address validation/allocation failure failure
    Arguments:

        none
    Returns:

        none
--*/
void SMTP_CONNECTION::HandleAddressError(char * InputLine)
{
    DWORD Error = GetLastError();

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::HandleAddressError");

    if(Error == ERROR_NOT_ENOUGH_MEMORY)
      {
        BUMP_COUNTER(QuerySmtpInstance(), MsgsRefusedDueToNoCAddrObjects);
        PE_CdFormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_MEMORY );
        m_CInboundContext.SetWin32Status(Error);
        FatalTrace((LPARAM) this, "HandleAddressError - SMTP_RESP_NORESOURCES, SMTP_NO_MEMORY");
      }
    else if (Error == ERROR_INVALID_DATA)
      {
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS, EINVALID_ARGS," %s\r\n",SMTP_INVALID_ADDR_MSG);
        FatalTrace((LPARAM) this, "HandleAddressError - SMTP_RESP_BAD_ARGS, SMTP_INVALID_ADDR_MSG");
        m_ProtocolErrors++;
      }
    else
      {
        PE_CdFormatSmtpMessage (SMTP_RESP_MBX_SYNTAX, ESYNTAX_ERROR," %s\r\n","Unknown Error");
        m_CInboundContext.SetWin32Status(Error);
        FatalTrace((LPARAM) this, "HandleAddressError - SMTP_RESP_MBX_SYNTAX, Unknown Error");
        m_ProtocolErrors++;
      }

    TraceFunctLeaveEx((LPARAM) this);
}

/*++

    Name :
        void SMTP_CONNECTION::SkipWord

    Description:
        skips over words in a buffer and
        returns pointer to next word
    Arguments:

        none
    Returns:

        none
--*/
char * SMTP_CONNECTION::SkipWord (char * Buffer, char * WordToSkip, DWORD WordLen)
{

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::SkipWord");

    //find string
    if (strncasecmp(Buffer, WordToSkip, WordLen))
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS , EINVALID_ARGS," %s %s\r\n",  "Unrecognized parameter", Buffer);
        ProtocolLog(USE_CURRENT, Buffer, NO_ERROR, SMTP_RESP_BAD_ARGS, 0, 0);
        return NULL;
    }

    //skip past word
    Buffer += WordLen;

    //skip white spaces looking for the ":" character
    while( (*Buffer != '\0') && (isspace (*Buffer) || (*Buffer == '\t')))
      Buffer++;

    if( (*Buffer == '\0') || (*Buffer != ':'))
    {
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_ARGS , EINVALID_ARGS," %s %s\r\n", "Unrecognized parameter", Buffer);
        ProtocolLog(USE_CURRENT, Buffer, NO_ERROR, SMTP_RESP_BAD_ARGS, 0, 0);
        return NULL;
    }

    //add one to skip the ":"
    Buffer++;

    TraceFunctLeaveEx((LPARAM) this);
    return Buffer;
}

VOID SMTP_CONNECTION::ProtocolLog(DWORD dwCommand, LPCSTR pszParameters, DWORD dwWin32Error,
                                  DWORD dwSmtpError, DWORD BytesSent, DWORD BytesRecv, LPSTR pszTarget)
{
    LPCSTR   pszCmd = "";
    char szKeyword[100];

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::ProtocolLog");

    _ASSERT (m_pInstance != NULL);

    //
    // verify if we should use the current command
    //
    if ( dwCommand == USE_CURRENT )
    {
        dwCommand = m_dwCurrentCommand;
    }

    if(dwCommand == SMTP_TIMEOUT)
    {
        strcpy(szKeyword, "TIMEOUT");
        pszCmd = szKeyword;
    }
    else
    {
        pszCmd = (LPSTR)SmtpCommands[ dwCommand ];
        if ( pszCmd == NULL )
        {
            // if this is a PE word then its the first word in the
            // parameters
            char *pszSpace = strchr(pszParameters, ' ');
            if (pszSpace) {
                DWORD_PTR cToCopy = (DWORD_PTR) pszSpace - (DWORD_PTR) pszParameters;
                if (cToCopy >= sizeof(szKeyword)) cToCopy = sizeof(szKeyword) - 1;
                strncpy(szKeyword, pszParameters, cToCopy);
                szKeyword[cToCopy] = 0;
                pszParameters += cToCopy;
                pszCmd = szKeyword;
            } else {
                pszCmd = pszParameters;
                pszParameters = NULL;
            }
        }
    }

    //
    // filter so we only get the desired commands
    //
    DebugTrace( (LPARAM)this,
                "Allow cmds: 0x%08X, cmd: 0x%08X",
                m_pInstance->GetCmdLogFlags(),
                (1<<dwCommand) );

    if ( m_pInstance->GetCmdLogFlags() & (1<<dwCommand) )
    {
        TransactionLog(
                pszCmd,
                pszParameters,
                pszTarget,
                dwWin32Error,
                dwSmtpError);
    }

    TraceFunctLeaveEx((LPARAM) this);
}


BOOL
SMTP_CONNECTION::BindInstanceAccessCheck(
    )
/*++

Routine Description:

    Bind IP/DNS access check for this request to instance data

Arguments:

    None

Returns:

    BOOL  - TRUE if success, otherwise FALSE.

--*/
{
     m_pInstance->LockGenCrit();

    if ( m_rfAccessCheck.CopyFrom( m_pInstance->QueryMetaDataRefHandler() ) )
    {
        m_acAccessCheck.BindCheckList( (LPBYTE)m_rfAccessCheck.GetPtr(), m_rfAccessCheck.GetSize() );
        m_pInstance->UnLockGenCrit();
        return TRUE;
    }

    m_pInstance->UnLockGenCrit();
    return FALSE;
}


VOID
SMTP_CONNECTION::UnbindInstanceAccessCheck()
/*++

Routine Description:

    Unbind IP/DNS access check for this request to instance data

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_acAccessCheck.UnbindCheckList();
    m_rfAccessCheck.Reset( (IMDCOM*) g_pInetSvc->QueryMDObject() );
}

/*++

    Name :
        void SMTP_CONNECTION::SwitchToBigReceiveBuffer

    Description:
        Helper routine to allocate a 32K buffer and use it for posting reads.
        SSL fragments can be up to 32K large, and we need to accumulate an
        entire fragment to be able to decrypt it.

    Arguments:
        none

    Returns:
        TRUE if the receive buffer was successfully allocated, FALSE otherwise

--*/

BOOL SMTP_CONNECTION::SwitchToBigSSLBuffers(void)
{
    char *pTempBuffer;

    pTempBuffer = new char [MAX_SSL_FRAGMENT_SIZE];

    if (pTempBuffer != NULL) {

        m_precvBuffer = pTempBuffer;
        m_cbMaxRecvBuffer = MAX_SSL_FRAGMENT_SIZE;

                pTempBuffer = new char [MAX_SSL_FRAGMENT_SIZE];
                if (pTempBuffer != NULL) {

                        m_pOutputBuffer = pTempBuffer;
                        m_cbMaxOutputBuffer =  MAX_SSL_FRAGMENT_SIZE;

                        return( TRUE );
                }
    }

    return( FALSE );
}

/*++

    Name :
        void SMTP_CONNECTION::DecryptInputBuffer

    Description:
        Helper routine to decrypt the recieve buffer when session is SSL
        encypted.

    Arguments:
        none

    Returns:
        TRUE if the receive buffer was successfully decrypted, FALSE otherwise

--*/

BOOL SMTP_CONNECTION::DecryptInputBuffer(void)
{
    TraceFunctEnterEx( (LPARAM)this, "SMTP_CONNECTION::DecryptInputBuffer");

    DWORD   cbExpected;
    DWORD   cbReceived;
    DWORD   cbParsable;
    DWORD   dwError;

    dwError = m_encryptCtx.DecryptInputBuffer(
                        (LPBYTE) QueryMRcvBuffer() + m_cbParsable,
                        m_cbReceived - m_cbParsable,
                        &cbReceived,
                        &cbParsable,
                        &cbExpected );

    if ( dwError == NO_ERROR )
    {
        //
        // new total received size is the residual from last processing
        // and whatever is left in the current decrypted read buffer
        //
        m_cbReceived = m_cbParsable + cbReceived;


        //
        // new total parsable size is the residual from last processing
        // and whatever was decrypted from this read io operation
        //
        m_cbParsable += cbParsable;
    }
    else
    {
        //
        // errors from this routine indicate that the stream has been
        // tampered with or we have an internal error
        //
        ErrorTrace( (LPARAM)this,
                    "DecryptInputBuffer failed: 0x%08X",
                    dwError );

        DisconnectClient( dwError );
    }

    return( dwError == NO_ERROR );
}

/*++

    Name :
        void SMTP_CONNECTION::IsClientSecureEnough

    Description:
        Finds out whether the client has negotiated the appropriate security
        level for the server instance for which this connection was
        created.

    Arguments:
        none

    Returns:
        TRUE if the client has negotiated appropriate level of security

--*/
BOOL SMTP_CONNECTION::IsClientSecureEnough(void)
{
    BOOL fRet = TRUE;

    if (QuerySmtpInstance()->RequiresSSL() && !m_SecurePort) {
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, E_TLSNEEDED, " %s\r\n", SMTP_MSG_MUST_SECURE);
        fRet = FALSE;
    }
    else if (m_SecurePort &&
             QuerySmtpInstance()->Requires128Bits() &&
                 m_encryptCtx.QueryKeySize() < 128) {
        PE_CdFormatSmtpMessage (SMTP_RESP_TRANS_FAILED, E_TLSNEEDED, " %s\r\n", SMTP_MSG_NOT_SECURE_ENOUGH);
        fRet = FALSE;
    }

    if(!fRet)
    {
        BUMP_COUNTER(QuerySmtpInstance(), NumProtocolErrs);
        ++m_ProtocolErrors;
    }

    return fRet;
}



/*++

    Name :
        BOOL SMTP_CONNECTION::OnEvent

    Description:
        Is invoked from GlueDispatch.  Micro-manages sink firing scenarios.

    Arguments:
        char *    InputLine            null terminated chunk of inbound input buffer from beginning of cmd to CRLF
        DWORD    IntermediateSize    length of the above
        DWORD    CmdSize                length of command keyword

    Returns:
        TRUE                        if native handler did or by default
        FALSE                        if native handler did

--*/

HRESULT SMTP_CONNECTION::OnEvent(
        IUnknown * pIserver,
        IUnknown * pISession,
        IMailMsgProperties *pIMessage,
        LPPE_COMMAND_NODE    pCommandNode,
        LPPE_BINDING_NODE    pBindingNode,
        char * szArgs
        )
{
    PMFI PointerToMemberFunction = SmtpDispatchTable[m_dwCurrentCommand];
    HRESULT hr = S_OK;
    BOOL fResult;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::OnEvent");

    _ASSERT(pCommandNode);
    _ASSERT(pBindingNode);
    m_CInboundContext.m_pCurrentBinding = pBindingNode;

    // If this is not a native command
    if (SmtpCommands[m_dwCurrentCommand] == NULL)
    {
        hr = m_pCInboundDispatcher->ChainSinks(
                pIserver,
                pISession,
                pIMessage,
                &m_CInboundContext,
                PRIO_LOWEST,
                pCommandNode,
                &(m_CInboundContext.m_pCurrentBinding)
                );
        if (hr == MAILTRANSPORT_S_PENDING)
            goto AsyncCompletion;
    }
    else
    {
        if (pBindingNode->dwPriority <= PRIO_DEFAULT)
        {
            if (pBindingNode->dwFlags & PEBN_DEFAULT)
            {
                // We are firing the default handler, skip the pre-loop
                m_CInboundContext.m_pCurrentBinding = pBindingNode->pNext;
            }
            else
            {
                hr = m_pCInboundDispatcher->ChainSinks(
                        pIserver,
                        pISession,
                        pIMessage,
                        &m_CInboundContext,
                        PRIO_DEFAULT,
                        pCommandNode,
                        &(m_CInboundContext.m_pCurrentBinding)
                        );
                if (hr == MAILTRANSPORT_S_PENDING)
                    goto AsyncCompletion;
            }

            if (FAILED(hr))
                return hr;

            if((hr != EXPE_S_CONSUMED) && (hr != S_FALSE)) {
                fResult = (this->*PointerToMemberFunction)(szArgs,strlen(szArgs));

                if (!fResult)
                    m_CInboundContext.SetCommandStatus(EXPE_DROP_SESSION);
                else
                    m_CInboundContext.SetCommandStatus(EXPE_SUCCESS);
            }
        }

        if ((m_CInboundContext.m_pCurrentBinding) &&
            (hr != EXPE_S_CONSUMED) && (hr != S_FALSE))
        {
            hr = m_pCInboundDispatcher->ChainSinks(
                    pIserver,
                    pISession,
                    pIMessage,
                    &m_CInboundContext,
                    PRIO_LOWEST,
                    pCommandNode,
                    &(m_CInboundContext.m_pCurrentBinding)
                    );
            if (hr == MAILTRANSPORT_S_PENDING)
                goto AsyncCompletion;
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hr);

AsyncCompletion:

    DebugTrace((LPARAM)this, "Leaving because of S_PENDING");
    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}

HRESULT SMTP_CONNECTION::OnNotifyAsyncCompletion(
    HRESULT    hrResult
    )
{
    HRESULT    hr = S_OK;
    LPSTR    pArgs = NULL;
    CHAR    chTerm = '\0';

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::OnNotifyAsyncCompletion");

    // Make sure the sink did not call back with S_PENDING
    if (hrResult == MAILTRANSPORT_S_PENDING)
        hrResult = S_OK;

    // See if we have to continue chaining
    if (hrResult == S_OK)
    {
        LPPE_BINDING_NODE    pNextBinding;
        PE_BINDING_NODE        bnDefault;

        // If we have more bindings, or if we are before a native command, we have to
        // go in again
        _ASSERT(m_CInboundContext.m_pCurrentBinding);
        pNextBinding = m_CInboundContext.m_pCurrentBinding->pNext;

        // Now see if we have a native handler
        if (SmtpDispatchTable[m_dwCurrentCommand] &&
                (m_CInboundContext.m_pCurrentBinding->dwPriority <= PRIO_DEFAULT))
        {
            if (!pNextBinding || (pNextBinding->dwPriority > PRIO_DEFAULT))
            {
                bnDefault.dwPriority = PRIO_DEFAULT;
                bnDefault.pNext = pNextBinding;
                bnDefault.dwFlags = PEBN_DEFAULT;
                pNextBinding = &bnDefault;
            }
        }

        if (pNextBinding != NULL)
        {
            // Call the OnEvent to resume chaining ...
            pArgs = strchr(m_CInboundContext.m_cabCommand.Buffer(), ' ');
            if (!pArgs)
                pArgs = &chTerm;
            hrResult = OnEvent(
                        m_pInstance->GetInstancePropertyBag(),
                        GetSessionPropertyBag(),
                        m_pIMsg,
                        m_CInboundContext.m_pCurrentCommandContext,
                        pNextBinding,
                        pArgs
                        );
            // We have scenarios:
            // 1) S_OK, S_FALSE: We send the response and do the
            // next command
            // 2) ERROR: Drop the connection
            // 3) S_PENDING: Just let the thread return
        }
        else
            hrResult = S_OK;
    }

    if (hrResult != MAILTRANSPORT_S_PENDING)
    {
        // It's not another async operation
        if (SUCCEEDED(hrResult))
        {
            // Send the response and process the next command
            if (!ProcessAndSendResponse())
                hrResult = E_FAIL;

            // Disconnect client if needed
            if (m_CInboundContext.m_dwCommandStatus & EXPE_DROP_SESSION)
            {
                DisconnectClient();
                hrResult = E_FAIL;
            }

            // do things unique to handling the end of a message
            if (m_fAsyncEOD) {
                ReInitClassVariables();
            }
        }

        if (SUCCEEDED(hrResult)) {
            //
            // ProcessClient usually posts an async ReadFile --
            // This can be a problem since ntos actuall completes the
            // read with the thread that issued it.  If the sink
            // writer has the thread exit before the read completes,
            // we would get an error.  To get around this, we call
            // PostQueuedCompleteionStatus with the sink's thread and
            // then post the next async read with an atq thread.
            //
            //ProcessClient(0, NO_ERROR,
            //(LPOVERLAPPED)&m_CInboundContext);
             m_fAsyncEventCompletion = TRUE;

            if(
                PostCompletionStatus(
                    1 // Post 1 byte (a zero byte completion means the
                      // remote host disconnected
                ) == FALSE) {
                //
                // We were unable to post completion status, fail
                // below
                //
                hrResult = E_FAIL;
                m_fAsyncEventCompletion = FALSE;
            }
        }
        if(FAILED(hrResult))
            ProcessClient(0, ERROR_OPERATION_ABORTED, NULL);
    }

    TraceFunctLeaveEx((LPARAM)this);
    // We always keep the sink happy
    return(S_OK);

}

BOOL SMTP_CONNECTION::ProcessAndSendResponse()
{
    BOOL    fResult = TRUE;
    DWORD    dwResponseSize = 0;
    LPSTR    pszResponse = NULL;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::ProcessAndSendResponse");


    // See if we have a custom response from sinks
    dwResponseSize = m_CInboundContext.m_cabResponse.Length();
    pszResponse = m_CInboundContext.m_cabResponse.Buffer();
    if (!dwResponseSize || !*pszResponse)
    {
        // Try the native buffer
        dwResponseSize = m_CInboundContext.m_cabNativeResponse.Length();
        pszResponse = m_CInboundContext.m_cabNativeResponse.Buffer();
        // If the response buffer is NULL, we won't send any response.
        // For example BDAT exhibits this behavior
    }

    if (dwResponseSize && *pszResponse)
        PE_FastFormatSmtpMessage(pszResponse, dwResponseSize - 1);

    // SendResponse if needed
    if (!(m_CInboundContext.m_dwCommandStatus & EXPE_PIPELINED))
        fResult = SendSmtpResponse();

    TraceFunctLeaveEx((LPARAM)this);
    return(fResult);
}

/*++

    Name :
        BOOL SMTP_CONNECTION::GlueDispatch

    Description:
        Is invoked from ProcessInputBuffer as if it were native handler for SMTP command.
        Finds out if the command is native/non-native, and,if native, extended/non-extended.
        Then, fires the corresponding mix of native handler and inbound sinks.

    Arguments:
        char *    InputLine            null terminated chunk of inbound input buffer from beginning of cmd to CRLF
        DWORD    IntermediateSize    length of the above
        DWORD    CmdSize                length of command keyword

    Returns:
        TRUE                        if native handler did or by default
        FALSE                        if native handler did

--*/
BOOL SMTP_CONNECTION::GlueDispatch(char * InputLine, DWORD IntermediateSize, DWORD CmdSize, BOOL * pfAsyncOp)
{
    HRESULT hr;
    PMFI    PointerToMemberFunction = SmtpDispatchTable[m_dwCurrentCommand];
    BOOL    fSinksInstalled = FALSE;
    BOOL    fResult = TRUE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::GlueDispatch");

    _ASSERT(InputLine);
    _ASSERT(m_pInstance);
    _ASSERT(pfAsyncOp);
    if (!InputLine || !m_pInstance || !pfAsyncOp)
        return(FALSE);

    // Default is no async operation
    *pfAsyncOp = FALSE;

    if(m_pCInboundDispatcher == NULL) {
        m_pIEventRouter = m_pInstance->GetRouter();

        _ASSERT(m_pIEventRouter);
        if (!m_pIEventRouter)
            return(FALSE);

        hr = m_pIEventRouter->GetDispatcherByClassFactory(
            CLSID_CInboundDispatcher,
            &g_cfInbound,
            CATID_SMTP_ON_INBOUND_COMMAND,
            IID_ISmtpInboundCommandDispatcher,
            (IUnknown **)&m_pCInboundDispatcher);


        if (!SUCCEEDED(hr)){
            ErrorTrace((LPARAM) this, "Unable to get dispatcher by CLF on router");
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }
    }

    // pre-loading per command buffer into the context object...
    m_CInboundContext.ResetInboundContext();

    // null-terminating the command keyword...
    char * szTemp;
    char * szTemp2;
    char * szArgs;
    BOOL fSpaceReplaced = FALSE;

    szTemp = strstr(InputLine, " ");
    if (szTemp == NULL)
    {
        szTemp = InputLine + strlen(InputLine);
        _ASSERT(szTemp);
        szArgs = szTemp;
    }
    else
    {
        *szTemp='\0';
        szArgs = szTemp;
        fSpaceReplaced = TRUE;
    }
    szTemp2 = InputLine;
    while (szTemp2 < szTemp)
    {
        *szTemp2 = (CHAR)tolower(*szTemp2);
        szTemp2++;
    }

    // OK, we know we're dealing with native...
    hr = m_pCInboundDispatcher->SinksInstalled(
                    InputLine,
                    &(m_CInboundContext.m_pCurrentCommandContext));
    if (hr == S_OK)
        fSinksInstalled = TRUE;

    if (fSpaceReplaced)
        *szTemp = ' ';

    hr = m_CInboundContext.m_cabCommand.Append(
                    (char *)InputLine,
                    strlen(InputLine) + 1,
                    NULL);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "Unable to set command buffer");
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }


    // Make sure IMsg is instantiated...if it's not, instantiate it !!!
    if (m_dwCurrentCommand == MAIL)
    {
        BOOL    fCreateIMsg = TRUE;

        if (m_pIMsg != NULL)
        {
            char    b;

            // If we have an allocated IMailMsg but we don't have a valid
            // sender address yet, we will release the object and re-allocate it.
            // Otherwise, we will skip the creation of another message object.
            hr = m_pIMsg->GetStringA(IMMPID_MP_SENDER_ADDRESS_SMTP, 1, &b);
            if(hr == MAILMSG_E_PROPNOTFOUND)
                ReleasImsg(TRUE);
            else
                fCreateIMsg = FALSE;
        }

        if (fCreateIMsg)
        {
            // Create a new MailMsg
            hr = CoCreateInstance(CLSID_MsgImp,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IMailMsgProperties,
                            (LPVOID *)&m_pIMsg);

            // Next, check if we are over the inbound cutoff limit. If so, we will release the message
            // and not proceed.
            if (SUCCEEDED(hr))
            {
                DWORD    dwCreationFlags;
                hr = m_pIMsg->GetDWORD(
                            IMMPID_MPV_MESSAGE_CREATION_FLAGS,
                            &dwCreationFlags);
                if (FAILED(hr) ||
                    (dwCreationFlags & MPV_INBOUND_CUTOFF_EXCEEDED))
                {
                    // If we fail to get this property of if the inbound cutoff
                    // exceeded flag is set, discard the message and return failure
                    if (SUCCEEDED(hr))
                    {
                        DebugTrace((LPARAM)this, "Failing because inbound cutoff reached");
                        hr = E_OUTOFMEMORY;
                    }
                    m_pIMsg->Release();
                    m_pIMsg = NULL;
                }
            }

            if (SUCCEEDED(hr))
            {
                hr = m_pIMsg->QueryInterface(IID_IMailMsgRecipients, (void **) &m_pIMsgRecipsTemp);
                if (SUCCEEDED(hr))
                {
                    hr = m_pIMsg->QueryInterface(IID_IMailMsgBind, (void **)&m_pBindInterface);
                    if (SUCCEEDED(hr))
                    {
                        hr = m_pIMsgRecipsTemp->AllocNewList(&m_pIMsgRecips);
                        if (FAILED(hr))
                        {
                            FormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_MEMORY);
                            m_CInboundContext.SetWin32Status(ERROR_NOT_ENOUGH_MEMORY);
                            ErrorTrace((LPARAM) this, "GlueDispatch - SMTP_RESP_NORESOURCES, SMTP_NO_MEMORY - MailInfo = new MAILQ_ENTRY () failed");
                            fResult = FALSE;
                            goto ErrorCleanup;
                        }

                        hr = SetAvailableMailMsgProperties();
                        if(FAILED(hr))
                        {
                            m_CInboundContext.SetWin32Status(ERROR_NOT_ENOUGH_MEMORY);
                            FormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_STORAGE);
                            ErrorTrace((LPARAM) this, "GlueDispatch - SMTP_RESP_NORESOURCES, SMTP_NO_MEMORY - MailInfo = new MAILQ_ENTRY () failed");
                            fResult = FALSE;
                            goto ErrorCleanup;

                        }


                    }
                    else
                    {
                        FormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_MEMORY);
                        m_CInboundContext.SetWin32Status(ERROR_NOT_ENOUGH_MEMORY);
                        ErrorTrace((LPARAM) this, "GlueDispatch - SMTP_RESP_NORESOURCES, SMTP_NO_MEMORY - MailInfo = new MAILQ_ENTRY () failed");
                        fResult = FALSE;
                        goto ErrorCleanup;
                    }
                }
                else
                {
                    FormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_MEMORY);
                    m_CInboundContext.SetWin32Status(ERROR_NOT_ENOUGH_MEMORY);
                    ErrorTrace((LPARAM) this, "GlueDispatch - SMTP_RESP_NORESOURCES, SMTP_NO_MEMORY - MailInfo = new MAILQ_ENTRY () failed");
                    fResult = FALSE;
                    goto ErrorCleanup;
                }
            }
            else
            {
                BUMP_COUNTER(QuerySmtpInstance(), MsgsRefusedDueToNoMailObjects);
                FormatSmtpMessage (SMTP_RESP_NORESOURCES, ENO_RESOURCES," %s\r\n", SMTP_NO_MEMORY);
                m_CInboundContext.SetWin32Status(ERROR_NOT_ENOUGH_MEMORY);
                ErrorTrace((LPARAM) this, "GlueDispatch - SMTP_RESP_NORESOURCES, SMTP_NO_MEMORY - MailInfo = new MAILQ_ENTRY () failed");
                fResult = FALSE;
                goto ErrorCleanup;
            }
        }
    }

    // Mark the start fo protocol event processing
    m_fIsPeUnderway = TRUE;

    if (PointerToMemberFunction != NULL)
    {
        // This is native
        if (fSinksInstalled)
        {
            LPPE_BINDING_NODE    pBinding;
            PE_BINDING_NODE        bnDefault;

            pBinding = m_CInboundContext.m_pCurrentCommandContext->pFirstBinding;
            _ASSERT(pBinding);

            // Now if the first sink is a post sink, we must create a sentinel
            // so we know not to miss the native handler
            if (pBinding->dwPriority > PRIO_DEFAULT)
            {
                bnDefault.dwPriority = PRIO_DEFAULT;
                bnDefault.pNext = pBinding;
                bnDefault.dwFlags = PEBN_DEFAULT;
                pBinding = &bnDefault;
            }

            hr = OnEvent(
                m_pInstance->GetInstancePropertyBag(),
                GetSessionPropertyBag(),
                m_pIMsg,
                m_CInboundContext.m_pCurrentCommandContext,
                pBinding,
                szArgs
                );
            if (hr == MAILTRANSPORT_S_PENDING)
                goto AsyncCompletion;
        }
        else
        {
            //OK, it's native, not extended command...
            // So we just run the native handler on it
            fResult = (this->*PointerToMemberFunction)(szArgs, strlen(szArgs));
            // all changes got dumped into context automatically...
            // the interpreter will see the default response nonempty
            // and sink response empty, and it will flush just that...
            // for conformity with onevent
            hr = S_OK;
            // however, we need to modify command status here to signify if
            // we need to keep connection open
            if (!fResult)
                m_CInboundContext.SetCommandStatus(EXPE_DROP_SESSION);
            else
                m_CInboundContext.SetCommandStatus(EXPE_SUCCESS);
        }
    }
    else
    {
        // This is not a native command
        if (fSinksInstalled)
        {
            hr = OnEvent(
                m_pInstance->GetInstancePropertyBag(),
                GetSessionPropertyBag(),
                m_pIMsg,
                m_CInboundContext.m_pCurrentCommandContext,
                m_CInboundContext.m_pCurrentCommandContext->pFirstBinding,
                szArgs
                );
            if (hr == MAILTRANSPORT_S_PENDING)
                goto AsyncCompletion;
        }
        // once again, all info now sits in the context
        // the only thing left is just to check if any sinks were chained for this command,
        // and, if not, run a chain of *-sinks on it.  If they did not pick it up, either,
        // we call on DoLASTCommand and that's all!
        //
        // jstamerj 1998/10/29 18:01:53: Check the command status code
        // to see if we need to continue (in addition to smtp status)
        //
        if ((m_CInboundContext.m_dwSmtpStatus == 0) &&
            (m_CInboundContext.m_dwCommandStatus == EXPE_UNHANDLED))
        {
            hr = m_pCInboundDispatcher->SinksInstalled(
                        "*",&(m_CInboundContext.m_pCurrentCommandContext));
            if (hr == S_OK)
            {
                hr = OnEvent(
                    m_pInstance->GetInstancePropertyBag(),
                    GetSessionPropertyBag(),
                    m_pIMsg,
                    m_CInboundContext.m_pCurrentCommandContext,
                    m_CInboundContext.m_pCurrentCommandContext->pFirstBinding,
                    szArgs
                    );
                if (hr == MAILTRANSPORT_S_PENDING)
                    goto AsyncCompletion;
            }

            if ((m_CInboundContext.m_dwSmtpStatus == 0) &&
                (m_CInboundContext.m_dwCommandStatus == EXPE_UNHANDLED))
            {
                fResult=(this->DoLASTCommand)(szArgs, strlen(szArgs));

                // the context at this point does not contain anything meaningful, so just return
                if (!fResult)
                    m_CInboundContext.m_dwCommandStatus = EXPE_DROP_SESSION;
                else
                    m_CInboundContext.m_dwCommandStatus = EXPE_SUCCESS;
                hr = S_OK;
            }
        }
    }

    // first, we interpret the hr-logic
    // if chaining was normal, proceed, otherwise...
    if ((hr != S_OK) &&
        (hr != EXPE_S_CONSUMED))
    {
        ErrorTrace((LPARAM) this, "Error occured during chaining of sinks (%08x)", hr);
    }

    if (SUCCEEDED(hr))
    {
        // Format the message if needed
        fResult = ProcessAndSendResponse();

        // Disconnect client if needed
        if (m_CInboundContext.m_dwCommandStatus & EXPE_DROP_SESSION)
        {
            //Special case for TURN
            //where we do not diconnect the connection but simply destroy smtpcli
            if(m_DoCleanup)
                DisconnectClient();
            fResult = FALSE;
        }

        if ( ( m_CInboundContext.m_dwCommandStatus & EXPE_BLOB_READY) &&
             ( NULL != m_CInboundContext.m_pICallback))
        {
            m_fPeBlobReady = TRUE;
            m_pPeBlobCallback = m_CInboundContext.m_pICallback;
        }

        // do things unique to handling the end of a message
        if (m_fAsyncEOD) {
            ReInitClassVariables();
        }
    }
    else
        fResult = FALSE;

    // Final cleanup
    m_fIsPeUnderway = FALSE;
    TraceFunctLeaveEx((LPARAM)this);
    return(fResult);

AsyncCompletion:

    DebugTrace((LPARAM)this, "Leaving because of S_PENDING");
    *pfAsyncOp = TRUE;
    TraceFunctLeaveEx((LPARAM)this);
    return(TRUE);

ErrorCleanup:

    // Cleanup on error. This includes sending out all final
    // responses
    SendSmtpResponse();

    m_fIsPeUnderway = FALSE;
    TraceFunctLeaveEx((LPARAM)this);
    return(fResult);
}

/*++

    Name :
        BOOL SMTP_CONNECTION::ProcessPeBlob

    Description:
        Calls the protocol extension sink callback with a blob buffer.

    Arguments:
        pbInputLine
        cbSize

    Returns:
        BOOL    :   continue processing

--*/

BOOL SMTP_CONNECTION::ProcessPeBlob(const char * pbInputLine, DWORD cbSize)
{
    BOOL fResult;
    HRESULT hr;

    TraceQuietEnter( "SMTP_CONNECTION::ProcessPeBlob");

    _ASSERT( m_fPeBlobReady);
    if ( NULL == m_pPeBlobCallback) {
        ErrorTrace( ( LPARAM) this, "Sink provided no callback interface");
        fResult = FALSE;
        goto cleanup;
    }

    m_CInboundContext.ResetInboundContext();
    m_CInboundContext.m_pbBlob = ( PBYTE) pbInputLine;
    m_CInboundContext.m_cbBlob = cbSize;

    hr = m_pPeBlobCallback->OnSmtpInCallback(
            m_pInstance->GetInstancePropertyBag(),
            GetSessionPropertyBag(),
            m_pIMsg,
            ( ISmtpInCallbackContext *) &m_CInboundContext);

    if ( FAILED( hr)) {
        ErrorTrace( ( LPARAM) this, "Sink callback failed, hr=%x", hr);
        fResult = FALSE;
        goto cleanup;
    }

    fResult = ProcessAndSendResponse();
    if ( FALSE == fResult) {
        ErrorTrace( ( LPARAM) this, "ProcessAndSendResponse failed");
        goto cleanup;
    }

    if ( m_CInboundContext.m_dwCommandStatus & EXPE_BLOB_DONE) {
        m_fPeBlobReady = FALSE;
        m_pPeBlobCallback->Release();
        m_pPeBlobCallback = NULL;
    }

cleanup:
    if ( fResult == FALSE) {
        m_fPeBlobReady = FALSE;
        if ( NULL != m_pPeBlobCallback) {
            m_pPeBlobCallback->Release();
            m_pPeBlobCallback = NULL;
        }
        FormatSmtpMessage( SMTP_RESP_ERROR, NULL, " %s\r\n", "Sink problem processing blob");
        SendSmtpResponse();
    }

    return fResult;
}

/*++

    Name :
        BOOL SMTP_CONNECTION::PE_FormatSmtpMessage

    Description:
        If we are processing non-native or extended native command, caches response in
        context object, otherwise passes it along to native FormatSmtpMessage.

    Arguments:
        As in FormatSmtpMessage.

    Returns:
        TRUE always
--*/
BOOL SMTP_CONNECTION::PE_FormatSmtpMessage(IN const char * Format, ...)
{
    va_list arglist;
    char Buffer[MAX_NATIVE_RESPONSE_SIZE];
    int BytesWritten;
    DWORD AvailableBytes = MAX_NATIVE_RESPONSE_SIZE;

    va_start(arglist, Format);
    BytesWritten = _vsnprintf (Buffer, AvailableBytes, Format, arglist);
    va_end(arglist);

    if (!m_fIsPeUnderway)
    {
        //pass in 0 for the code and NULL for the enhanced staus code
        //
        FormatSmtpMessage(0,NULL,"%s", Buffer);
    }
    else
    {
        m_CInboundContext.AppendNativeResponse(Buffer, strlen(Buffer) + 1);
    }
    return TRUE;
}

/*++

    Name :
        BOOL SMTP_CONNECTION::PE_CdFormatSmtpMessage

    Description:
        As PE_FormatSmtpMessage above, except intercepts the SMTP return code.

    Arguments:
        As in PE_FormatSmtpMessage above, except add'l slot for SMTP return code.

    Returns:
        TRUE always

--*/
BOOL SMTP_CONNECTION::PE_CdFormatSmtpMessage(DWORD dwCode, const char * szEnhancedCodes, IN const char * Format,...)
{
    va_list arglist;
    char Buffer[MAX_NATIVE_RESPONSE_SIZE];
    int BytesWritten;
    DWORD AvailableBytes = MAX_NATIVE_RESPONSE_SIZE;
    char RealFormat[MAX_PATH];

    if(m_pInstance->AllowEnhancedCodes() && szEnhancedCodes)
    {
        sprintf(RealFormat,"%d %s",dwCode,szEnhancedCodes);
    }
    else
        sprintf(RealFormat,"%d",dwCode);

    strcat(RealFormat,Format);

    va_start(arglist, Format);
    BytesWritten = _vsnprintf (Buffer, AvailableBytes, (const char * )RealFormat, arglist);
    if(BytesWritten == -1) {
        //
        // If response is too long, forcibly truncate it
        // This might mean that the human readable part of the response may be
        // incomplete... but there's nothing we can do about that easily.
        //
        Buffer[MAX_NATIVE_RESPONSE_SIZE-3] = '\r';
        Buffer[MAX_NATIVE_RESPONSE_SIZE-2] = '\n';
        Buffer[MAX_NATIVE_RESPONSE_SIZE-1] = '\0';
    }
    if (m_fIsPeUnderway)
    {
        PE_FormatSmtpMessage("%s",Buffer);
        m_CInboundContext.SetSmtpStatusCode(dwCode);
    }
    else
    {
        //pass in 0 for the code and NULL for the enhanced staus code
        //
        FormatSmtpMessage(0,NULL,"%s",Buffer);
    }
    va_end(arglist);
    return TRUE;
}

/*++

    Name :
        BOOL SMTP_CONNECTION::PE_DisconnectClient

    Description:
        If we are processing non-native or extended native command, caches DisconnectClient
        calls' occurences in context object, otherwise passes it along to native
        DisconnectClient.

    Arguments:
        none

    Returns:
        TRUE always

--*/
BOOL SMTP_CONNECTION::PE_DisconnectClient()
{
    if (m_fIsPeUnderway)
    {
        m_CInboundContext.m_dwCommandStatus = m_CInboundContext.m_dwCommandStatus | EXPE_DROP_SESSION;
    }
    else
    {
        DisconnectClient();
    }
    return TRUE;
}

/*++

    Name :
        BOOL SMTP_CONNECTION::PE_SendSmtpResponse

    Description:
        If we are processing non-native or extended native command, caches SendSmtpResponse
        calls' occurences in context object, otherwise passes it along to native
        SendSmtpResponse.

    Arguments:
        none

    Returns:
        TRUE always if we're called from GlueDispatch callee's
        SendSmtpResponse return otherwise

--*/
BOOL SMTP_CONNECTION::PE_SendSmtpResponse()
{
    if (m_fIsPeUnderway)
    {
        m_CInboundContext.m_dwCommandStatus = m_CInboundContext.m_dwCommandStatus & (~EXPE_PIPELINED);
        return TRUE;
    }
    else
    {
        return SendSmtpResponse();
    };
}

//////////////////////////////////////////////////////////////////////////////
//---[ SMTP_CONNECTION::GetAndPersistRFC822Headers ]--------------------------
//
//
//  Description:
//      Parses and RFC822 headers, and promotes them to the P2 if neccessary
//  Parameters:
//      IN  InputLine       String with start of link (processed by ChompHeader)
//      IN  psValueBuf      String with value of header
//  Returns:
//      -
//  History:
//      2/8/99 - MikeSwa Updated - moved received header parsing to this function
//
//-----------------------------------------------------------------------------
void SMTP_CONNECTION::GetAndPersistRFC822Headers(
    char* InputLine,
    char* pszValueBuf
    )
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNECTION::GetAndPersistRFC822Headers");

    HRESULT hr = S_OK;

    //count the number of received lines for hop count
    //analysis later
    if(!strncasecmp(InputLine, "Received:", strlen("Received:")) ||
       !strncasecmp(InputLine, "Received :", strlen("Received :")))
    {
        m_HopCount++;

        CHAR    szText[2024];
        CHAR *  pszTemp;

        // Check if this string represents the local server - if it does we might be
        // looping around and we need to keep track of how many times this server has
        // seen the message
        sprintf(szText,szFormatReceivedServer, m_pInstance->GetFQDomainName());
        pszTemp = strstr(InputLine, szText);
        if (pszTemp)
        {
            // we found the string, make sure we also find "with Microsoft SMTPSVC"
            sprintf(szText,szFormatReceivedService);
            pszTemp = strstr(InputLine, szText);
            if (pszTemp)
            {
                // we found that string too - we've been here before,
                // increment m_LocalHopCount
                m_LocalHopCount++;
            }
        }
    }

    //
    // Get the message ID and persist it
    //
    if( !m_fSeenRFC822MsgId &&
        ( !strncasecmp( InputLine, "Message-ID:", strlen("Message-ID:") ) ||
          !strncasecmp( InputLine, "Message-ID :", strlen("Message-ID :") ) ) )
    {
        m_fSeenRFC822MsgId = TRUE;

        if( pszValueBuf )
        {
            //
            // Some MTAs fold Message-IDs. Embedded CRLFs in a Message-ID can cause trouble since
            // we use it for message tracking, and in the "Queued" response, so we unfold the
            // Message-ID prior to using it.
            //

            CHAR *pszUnfolded = NULL;

            if(!UnfoldHeader(pszValueBuf, &pszUnfolded))
            {
                m_MailBodyError = E_OUTOFMEMORY;
                TraceFunctLeaveEx((LPARAM) this);
                return;
            }

            if(pszUnfolded)
                pszValueBuf = pszUnfolded;

            if( FAILED( hr = m_pIMsg->PutStringA( IMMPID_MP_RFC822_MSG_ID, pszValueBuf ) ) )
                m_MailBodyError = hr;

            if(pszUnfolded)
                FreeUnfoldedHeader(pszUnfolded);

            TraceFunctLeaveEx((LPARAM) this);
            return;
        }

    }

    //
    // get the Subject:  & persist it
    //

    if( !m_fSeenRFC822Subject &&
        ( !strncasecmp( InputLine, "Subject:", strlen("Subject:") ) ||
          !strncasecmp( InputLine, "Subject :", strlen("Subject :") ) ) )
    {
        m_fSeenRFC822Subject = TRUE;

        if( pszValueBuf )
        {
            if( FAILED( hr = m_pIMsg->PutStringA( IMMPID_MP_RFC822_MSG_SUBJECT, pszValueBuf ) ) )
                m_MailBodyError = hr;
        }

    }

    //
    // get the To: address & persist it
    //

    if( !m_fSeenRFC822ToAddress &&
        ( !strncasecmp( InputLine, "To:", strlen("To:") ) ||
          !strncasecmp( InputLine, "To :", strlen("To :") ) ) )
    {
        m_fSeenRFC822ToAddress = TRUE;

        if( pszValueBuf )
        {
            if( FAILED( hr = m_pIMsg->PutStringA( IMMPID_MP_RFC822_TO_ADDRESS, pszValueBuf ) ) )
                m_MailBodyError = hr;
        }

    }

    //
    // get the Cc: address & persist it
    //

    if( !m_fSeenRFC822CcAddress &&
        ( !strncasecmp( InputLine, "Cc:", strlen("Cc:") ) ||
          !strncasecmp( InputLine, "Cc :", strlen("Cc :") ) ) )
    {
        m_fSeenRFC822CcAddress = TRUE;

        if( pszValueBuf )
        {
            if( FAILED( hr = m_pIMsg->PutStringA( IMMPID_MP_RFC822_CC_ADDRESS, pszValueBuf ) ) )
                m_MailBodyError = hr;
        }

    }

    //
    // get the Bcc: address & persist it
    //

    if( !m_fSeenRFC822BccAddress &&
        ( !strncasecmp( InputLine, "Bcc:", strlen("Bcc:") ) ||
          !strncasecmp( InputLine, "Bcc :", strlen("Bcc :") ) ) )
    {
        m_fSeenRFC822BccAddress = TRUE;

        if( pszValueBuf )
        {
            if( FAILED( hr = m_pIMsg->PutStringA( IMMPID_MP_RFC822_BCC_ADDRESS, pszValueBuf ) ) )
                m_MailBodyError = hr;
        }
    }

    //
    // get the From: address & persist it
    //

    if( !m_fSeenRFC822FromAddress &&
        ( !strncasecmp( InputLine, "From:", strlen("From:") ) ||
          !strncasecmp( InputLine, "From :", strlen("From :") ) ) )
    {
        m_fSeenRFC822FromAddress = TRUE;

        if( pszValueBuf )
        {
            if( FAILED( hr = m_pIMsg->PutStringA( IMMPID_MP_RFC822_FROM_ADDRESS, pszValueBuf ) ) )
                m_MailBodyError = hr;

            char szSmtpFromAddress[MAX_INTERNET_NAME + 6] = "smtp:";
            char *pszDomainOffset;
            DWORD cAddr;
            if (CAddr::ExtractCleanEmailName(szSmtpFromAddress + 5, &pszDomainOffset, &cAddr, pszValueBuf)) {
                if (FAILED(hr = m_pIMsg->PutStringA(IMMPID_MP_FROM_ADDRESS, szSmtpFromAddress))) {
                    m_MailBodyError = hr;
                }
            }
        }

    }

    if( !m_fSeenRFC822SenderAddress &&
        ( !strncasecmp( InputLine, "Sender:", strlen("Sender:") ) ||
          !strncasecmp( InputLine, "Sender :", strlen("Sender :") ) ) )
    {
        m_fSeenRFC822SenderAddress = TRUE;

        if( pszValueBuf )
        {
            char szSmtpSenderAddress[MAX_INTERNET_NAME + 6] = "smtp:";
            char *pszDomainOffset;
            DWORD cAddr;
            if (CAddr::ExtractCleanEmailName(szSmtpSenderAddress + 5, &pszDomainOffset, &cAddr, pszValueBuf)) {
                if (FAILED(hr = m_pIMsg->PutStringA(IMMPID_MP_SENDER_ADDRESS, szSmtpSenderAddress))) {
                    m_MailBodyError = hr;
                }
            }
        }
    }

    //
    // get the X-Priority & persist it
    //

    if( !m_fSeenXPriority &&
        ( !strncasecmp( InputLine, "X-Priority:", strlen("X-Priority:") ) ||
          !strncasecmp( InputLine, "X-Priority :", strlen("X-Priority :") ) ) )
    {
        m_fSeenXPriority = TRUE;

        if( pszValueBuf )
        {
            DWORD dwPri = (DWORD)atoi( pszValueBuf );
            if( FAILED( hr = m_pIMsg->PutDWORD( IMMPID_MP_X_PRIORITY, dwPri ) ) )
                m_MailBodyError = hr;
        }

    }

    //
    // get the X-OriginalArrivalTime & persist it
    //

    if( !m_fSeenXOriginalArrivalTime &&
        ( !strncasecmp( InputLine, "X-OriginalArrivalTime:", strlen("X-OriginalArrivalTime:") ) ||
          !strncasecmp( InputLine, "X-OriginalArrivalTime :", strlen("X-OriginalArrivalTime :") ) ) )
    {
        m_fSeenXOriginalArrivalTime = TRUE;

        if( pszValueBuf )
        {
            if( FAILED( hr = m_pIMsg->PutStringA( IMMPID_MP_ORIGINAL_ARRIVAL_TIME, pszValueBuf ) ) )
                m_MailBodyError = hr;
        }
    }

    //
    // get the content type & persist it
    //

    if( !m_fSeenContentType &&
        ( !strncasecmp( InputLine, "Content-Type:", strlen("Content-Type:") ) ||
          !strncasecmp( InputLine, "Content-Type :", strlen("Content-Type :") ) ) )
    {
        m_fSeenContentType = TRUE;
        m_fSetContentType = TRUE;
        DWORD dwContentType = 0;

        if( pszValueBuf )
        {
            if( !strncasecmp( pszValueBuf, "multipart/signed", strlen("multipart/signed") ) )
            {
                dwContentType = 1;
            }
            else if( !strncasecmp( pszValueBuf, "application/x-pkcs7-mime", strlen("application/x-pkcs7-mime") ) ||
                     !strncasecmp( pszValueBuf, "application/pkcs7-mime", strlen("application/pkcs7-mime") ) )
            {
                dwContentType = 2;
            }

            if( FAILED( hr = m_pIMsg->PutStringA( IMMPID_MP_CONTENT_TYPE, pszValueBuf ) ) )
                m_MailBodyError = hr;

        }

        if( FAILED( hr = m_pIMsg->PutDWORD( IMMPID_MP_ENCRYPTION_TYPE, dwContentType ) ) )
            m_MailBodyError = hr;
    }

    if( !m_fSetContentType )
    {
        m_fSetContentType = TRUE;
        if( FAILED( hr = m_pIMsg->PutDWORD( IMMPID_MP_ENCRYPTION_TYPE, 0 ) ) )
            m_MailBodyError = hr;
    }

    TraceFunctLeaveEx((LPARAM) this);
}

//////////////////////////////////////////////////////////////////////////////
HRESULT SMTP_CONNECTION::SetAvailableMailMsgProperties()
{

    //set IPaddress that is already available
    HRESULT hr = m_pIMsg->PutStringA(IMMPID_MP_CONNECTION_IP_ADDRESS, QueryClientHostName());
    if(FAILED(hr))
    {
        return( hr );
    }

    hr = m_pIMsg->PutStringA(IMMPID_MP_CONNECTION_SERVER_IP_ADDRESS, QueryLocalHostName());
    if(FAILED(hr))
    {
        return( hr );
    }

    hr = m_pIMsg->PutStringA(IMMPID_MP_SERVER_NAME, g_ComputerName);
    if(FAILED(hr))
    {
        return( hr );
    }

    hr = m_pIMsg->PutStringA(IMMPID_MP_SERVER_VERSION, g_VersionString);
    if(FAILED(hr))
    {
        return( hr );
    }

    if (QueryLocalPortName())
    {
        DWORD dwPortNum = atoi(QueryLocalPortName());
        hr = m_pIMsg->PutDWORD(IMMPID_MP_CONNECTION_SERVER_PORT, dwPortNum);
        if (FAILED(hr))
            return ( hr );
    }

    if (m_fAuthenticated)
    {

        //Get username
        if (m_securityCtx.QueryUserName())
        {
            hr = m_pIMsg->PutStringA(IMMPID_MP_CLIENT_AUTH_USER,
                                    m_securityCtx.QueryUserName());
            if (FAILED(hr))
                return hr;
        }

        //Get type of authentication
        if (m_szUsedAuthKeyword[0])
        {
            hr = m_pIMsg->PutStringA(IMMPID_MP_CLIENT_AUTH_TYPE, m_szUsedAuthKeyword);
            if (FAILED(hr))
                return hr;
        }

    }
    return( hr );
}

//-----------------------------------------------------------------------------
//  Description:
//      If a failure occurs after a client issues the BDAT command, SMTP cannot
//      respond with a failure code (since the RFC forbids a BDAT response). So
//      SMTP calls this function which will read BDAT chunks from the socket
//      and discard them. When the chunk has been received, and it is time to
//      ACK the chunk, this function calls DoBDATErrorProcessing() to send the
//      correct error response.
//      
//  Arguments:
//      IN const char *InputLine - Ptr to data from client
//      IN DWORD UndecryptedTailSize - # of undecrypted bytes in buffer (TLS)
//
//      OUT BOOL *pfAsyncOp - If this function succeeded, this is set to TRUE
//          if all the data in the input buffer was consumed and we pended a
//          read to pick up more. If this is FALSE, and the function succeeded
//          there is extra (pipelined) data in the input buffer, and it must
//          be parsed as an SMTP command.
//
//  Notes:
//      If there is data left in the input buffer after this function is done,
//      that data should be parsed as an SMTP command.
//
//  Returns:
//      TRUE - Keep connection alive.
//      FALSE - Drop connection, there was a fatal error.
//
//-----------------------------------------------------------------------------
BOOL SMTP_CONNECTION::AcceptAndDiscardBDAT(
    const char *InputLine,
    DWORD UndecryptedTailSize,
    BOOL *pfAsyncOp)
{
    BOOL fReturn = FALSE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::AcceptAndDiscardBDAT");

    _ASSERT(m_MailBodyDiagnostic != ERR_NONE);
    _ASSERT(m_nBytesRemainingInChunk > 0 && "No chunk data");

    *pfAsyncOp = FALSE;

    if((DWORD)m_nBytesRemainingInChunk <= m_cbParsable)
    {
        //
        // Chunk completely received, discard it, do error processing.
        //

        DebugTrace((LPARAM) this, "Chunk completed");

        MoveMemory((PVOID) InputLine, InputLine + m_nBytesRemainingInChunk,
            m_cbReceived - m_nBytesRemainingInChunk);

        m_cbParsable -= m_nBytesRemainingInChunk;
        m_cbReceived -= m_nBytesRemainingInChunk;
        m_nBytesRemainingInChunk = 0;
        m_fIsChunkComplete = TRUE;

        if(!MailBodyErrorProcessing()) {
            fReturn = FALSE;
            goto Exit;
        }

        //
        // If we're done with all BDAT chunks, reset state. If this is NOT the last
        // BDAT chunk, then either more BDAT commands/chunks are already buffered
        // in the input buffer due to pipelining, or they're on their way. We need
        // to accept and discard all of them. m_fIsLastChunk is set by DoBDATCommand.
        //

        if(m_fIsLastChunk)
        {
            DebugTrace((LPARAM) this, "Last chunk");

            //
            // Note: This doesn't flush the input buffer, so any pipelined data is
            // still kept around. Thus the check for m_cbParsable below is valid.
            //

            ReInitClassVariables(); 
        }

#if 0
        //
        // All data in buffer was consumed. Pend a read to pick up more.
        // NOTE: Don't really have to do this... the parsing code already does
        // this for us.
        //

        if(m_cbParsable == 0)
        {
            fReturn = PendReadIO(UndecryptedTailSize);
            *pfAsyncOp = fReturn;
            goto Exit;
        }
#endif

        //
        // If we got here, there is additional data left in the buffer. This must
        // be pipelined data sent by the client, along with the just discarded  
        // chunk.
        //

        *pfAsyncOp = FALSE;
        fReturn = TRUE;
    }
    else
    {
        //
        // The complete chunk has not been received, discard whatever we got, update
        // the counts of bytes received/expected and pend a read to pick up more.
        //

        DebugTrace((LPARAM) this, "Processing partial chunk");
        MoveMemory((PVOID) InputLine, InputLine + m_cbParsable, m_cbReceived - m_cbParsable);

        m_nBytesRemainingInChunk -= m_cbParsable;
        m_cbReceived -= m_cbParsable;
        m_cbParsable = 0;
        _ASSERT(!m_fIsChunkComplete);

        fReturn = PendReadIO(UndecryptedTailSize);
        *pfAsyncOp = fReturn;
        goto Exit;
    }

Exit:

    //
    // If we succeeded, one of the following is true:
    // (1) Either there wasn't enough data to complete the chunk and we pended a read.
    // (2) There was enough data to complete the chunk, and the remaining bytes are
    //     to be interpreted as an SMTP command (m_nBytesRemainingInChunk == 0).
    //

    if(fReturn && !*pfAsyncOp)
        _ASSERT(m_nBytesRemainingInChunk == 0);

    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;
}

BOOL SMTP_CONNECTION::AcceptAndDiscardDATA(
    const char *InputLine,
    DWORD UndecryptedTailSize,
    BOOL *pfAsyncOp)
{
    DWORD IntermediateSize = 0;
    BOOL fRet = FALSE;
    char *pszSearch = NULL;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::AcceptAndDiscardDATA");

    _ASSERT(m_MailBodyDiagnostic != ERR_NONE);

    *pfAsyncOp = FALSE;

    //
    // Discard data line by line until we hit an incomplete line. Then break
    // out of loop and pend a read to pick up more data. If we hit a line that
    // has only a "." in it, that is the end of the mailbody. Kick off error
    // processing, reinit the state and return.
    //

    while(pszSearch = IsLineComplete(InputLine, m_cbParsable))
    {
        IntermediateSize = (DWORD) (pszSearch - InputLine);

        if(IntermediateSize == 1 &&
            InputLine[0] == '.' && InputLine[1] == '\r' && InputLine[2] == '\n')
        {
            m_cbReceived -= IntermediateSize + 2; // +2 for CRLF since pszSearch points->CR
            m_cbParsable -= IntermediateSize + 2;
            MoveMemory((PVOID *)InputLine, pszSearch + 2, m_cbReceived);
            
            if(MailBodyErrorProcessing())
            {
                ReInitClassVariables();
                fRet = TRUE;
            }

            TraceFunctLeaveEx((LPARAM) this);
            return fRet;
        }

        m_cbReceived -= IntermediateSize + 2; // +2 for CRLF since pszSearch points->CR
        m_cbParsable -= IntermediateSize + 2;
        MoveMemory((PVOID *)InputLine, pszSearch + 2, m_cbReceived);
    }

    //
    // Pend a read to pick up rest of the mail body.
    //

    fRet = PendReadIO(UndecryptedTailSize);
    *pfAsyncOp = fRet;
    TraceFunctLeaveEx((LPARAM) this);
    return fRet;
}

//-----------------------------------------------------------------------------
//  Description:
//      Based on m_MailBodyDiagnostic, this function performs error processing for
//      errors that occurred during BDAT. BDAT errors that occur when BDAT
//      is issued are not processed as soon as the error occurs, but after
//      SMTP has accepted the BDAT chunk (see AcceptAndDiscardBDAT()).
//  Arguments:
//      None.
//  Returns:
//      TRUE - Success, error response sent.
//      FALSE - Drop connection. Either there was an error, or error processing
//          requires dropping the connection (This is an RFC violation if there
//          is pipelined data in the input buffer).
//-----------------------------------------------------------------------------
BOOL SMTP_CONNECTION::MailBodyErrorProcessing()
{
    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNECTION::DoBDATErrorProcessing");

    switch(m_MailBodyDiagnostic) {

    case ERR_RETRY:
    case ERR_OUT_OF_MEMORY:
        PE_CdFormatSmtpMessage(SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_MEMORY);
        break;

    case ERR_MAX_MSG_SIZE:
        PE_CdFormatSmtpMessage(SMTP_RESP_NOSTORAGE, ENO_RESOURCES, " %s\r\n", SMTP_MAX_MSG_SIZE_EXCEEDED_MSG );
        break;

    case ERR_AUTH_NEEDED:
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY, " %s\r\n", "Client was not authenticated");
        break;

    case ERR_TLS_NEEDED:
        PE_CdFormatSmtpMessage (SMTP_RESP_MUST_SECURE, ENO_SECURITY, " %s\r\n", SMTP_MSG_MUST_SECURE);
        break;

    case ERR_HELO_NEEDED:
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR," %s\r\n", "Send hello first" );
        break;

    case ERR_MAIL_NEEDED:
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR," %s\r\n", "Need mail command." );
        break;

    case ERR_RCPT_NEEDED:
        PE_CdFormatSmtpMessage (SMTP_RESP_BAD_SEQ, ESYNTAX_ERROR," %s\r\n", "Need Rcpt command." );
        break;

    case ERR_NO_VALID_RCPTS:
        PE_CdFormatSmtpMessage (SMTP_RESP_TRANS_FAILED, ESYNTAX_ERROR," %s\r\n", SMTP_NO_VALID_RECIPS );
        break;

    default:
        _ASSERT(0 && "Bad err value");
        PE_CdFormatSmtpMessage(SMTP_RESP_NORESOURCES, ENO_RESOURCES, " %s\r\n",SMTP_NO_MEMORY);
        ErrorTrace((LPARAM) this, "BUG: bad value");
    }

    TraceFunctLeaveEx((LPARAM) this);
    return SendSmtpResponse(); // Error responses are not pipelined
}

//////////////////////////////////////////////////////////////////////////////
BOOL SMTP_CONNECTION::WriteLine (char * TextToWrite, DWORD TextSize)
{
/*#if 0

    char * SavedLine = TextToWrite;
    char * EndOfLine = &SavedLine[TextSize];
    DWORD LineSize = 0;

    while( (LineSize = (EndOfLine - SavedLine)) > 78)
    {
        char * RealEndOfLine = &TextToWrite[78 - 2];

        if(!WriteMailFile(TextToWrite, RealEndOfLine - SavedLine))
            return FALSE;

        m_TotalMsgSize += (RealEndOfLine - SavedLine);

        if(!WriteMailFile("\r\n", 2))
            return FALSE;

        m_TotalMsgSize += 2;

        if(!WriteMailFile("\t", 1))
            return FALSE;

        m_TotalMsgSize += 1;

        SavedLine = RealEndOfLine;
    }

    if(LineSize > 0)
    {
        if(!WriteMailFile(TextToWrite, LineSize))
            return FALSE;

        m_TotalMsgSize += LineSize;
    }

    if(!WriteMailFile("\r\n", 2))
            return FALSE;

    m_TotalMsgSize += 2;

    return TRUE;
#endif*/
    return FALSE;
}

BOOL SMTP_CONNECTION::AddToField(void)
{
/*#if 0

    char szWriteBuffer [1000];
    char szNameBuf[MAX_INTERNET_NAME + 100];
    int LineSize = 0;
    int PrevLineSize = 0;
    DWORD NumAddress = 0;
    DWORD BuffOffSet = 0;
    DWORD MaxLineSize = 78;
    CAddr * pCAddr = NULL;
    PLIST_ENTRY pentry = NULL;
    char * HeadChar ="";

    //write the "To: " first.  This includes the space
    BuffOffSet = (DWORD) wsprintf(szWriteBuffer, "To: ");

    //get the first address
    pCAddr = MailInfo->GetFirstAddress(&pentry);

    while(pCAddr != NULL)
    {

        if(NumAddress)
        {
            HeadChar = ", ";
        }

        LineSize = wsprintf(szNameBuf, "%s<%s>", HeadChar, pCAddr->GetAddress());
        if( (DWORD)(LineSize + PrevLineSize) < MaxLineSize)
        {
            CopyMemory(&szWriteBuffer[BuffOffSet], szNameBuf, LineSize);
            PrevLineSize += LineSize;
            BuffOffSet += LineSize;
        }
        else
        {
            szWriteBuffer[BuffOffSet++] = CR;
            szWriteBuffer[BuffOffSet++] = LF;
            if(!WriteMailFile(szWriteBuffer, BuffOffSet))
                return FALSE;

            m_TotalMsgSize += BuffOffSet;
            szWriteBuffer[0] = '\t';
            CopyMemory(&szWriteBuffer[1], szNameBuf, LineSize);
            BuffOffSet = LineSize + 1;
            PrevLineSize = BuffOffSet;
        }

        NumAddress++;

        //get the first address
        pCAddr = MailInfo->GetNextAddress(&pentry);
    }

    szWriteBuffer[BuffOffSet++] = CR;
    szWriteBuffer[BuffOffSet++] = LF;

    if(WriteMailFile(szWriteBuffer, BuffOffSet))
    {
        m_TotalMsgSize += BuffOffSet ;
        return TRUE;
    }

    return FALSE;
#endif*/

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\smtpdns.cxx ===
/*++

   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        asynccon.cxx

   Abstract:


   Author:

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "remoteq.hxx"
#include <asynccon.hxx>
#include <dnsreci.h>
#include <cdns.h>
#include "smtpdns.hxx"
#include "asyncmx.hxx"
#include "smtpmsg.h"

extern BOOL QueueCallBackFunction(PVOID ThisPtr, BOOLEAN fTimedOut);
extern void DeleteDnsRec(PSMTPDNS_RECS pDnsRec);
extern BOOL GetIpAddressFromDns(char * HostName, PSMTPDNS_RECS pDnsRec, DWORD Index);

CPool  CAsyncSmtpDns::Pool(SMTP_ASYNCMX_SIGNATURE);

CAsyncSmtpDns::CAsyncSmtpDns(SMTP_SERVER_INSTANCE * pServiceInstance, 
                             ISMTPConnection    *pSmtpConnection)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncSmtpDns::CAsyncSmtpDns");
    DebugTrace((LPARAM) this, "Creating CAsyncSmtpDns object = 0x%08x", this);

    m_Signature = SMTP_ASYNCMX_SIGNATURE;
    m_DomainOptions = 0;
    m_fConnectToSmartHost = FALSE;
    m_pServiceInstance = pServiceInstance;
    m_pISMTPConnection = pSmtpConnection;
    m_pDNS_RESOLVER_RECORD = NULL;
    m_fInitCalled = FALSE;
    m_pszSSLVerificationName = NULL;
    pServiceInstance->InsertAsyncDnsObject(this);
}

BOOL CAsyncSmtpDns::Init (LPSTR pszSSLVerificationName)
{
    BOOL fRet = FALSE;

    TraceFunctEnterEx ((LPARAM) this, "CAsyncSmtpDns::Init");

    m_fInitCalled = TRUE;

    if (pszSSLVerificationName) {
        m_pszSSLVerificationName = new char [lstrlen(pszSSLVerificationName) + 1];
        if (!m_pszSSLVerificationName)
            goto Exit;

        lstrcpy (m_pszSSLVerificationName, pszSSLVerificationName);
    }

    fRet = TRUE;
Exit:
    TraceFunctLeaveEx ((LPARAM) this);
    return fRet;
}

CAsyncSmtpDns::~CAsyncSmtpDns()
{
    DWORD dwAck = 0;

    TraceFunctEnterEx((LPARAM) this, "CAsyncSmtpDns::~CAsyncSmtpDns");

    DebugTrace((LPARAM) this, "Destructing CAsyncSmtpDns object = 0x%08x", this);

    _ASSERT (m_fInitCalled && "Init not called on CAsyncSmtpDns");

    //
    // If we did not succeed, we need to ack the connection here (m_dwDiagnostic holds
    // the error code to use). On the other hand, if we succeeded, then HandleCompletedData
    // must have kicked off an async connection to the server SMTP, and the ISMTPConnection
    // will be acked by the "async connect" code -- we don't need to do anything. The
    // m_pISMTPConnection may also be legally set to NULL (see HandleCompletedData).
    //
    if(m_dwDiagnostic != ERROR_SUCCESS && m_pISMTPConnection)
    {
        if(AQUEUE_E_AUTHORITATIVE_HOST_NOT_FOUND == m_dwDiagnostic)
            dwAck = CONNECTION_STATUS_FAILED_NDR_UNDELIVERED;
        else
            dwAck = CONNECTION_STATUS_FAILED;

        DebugTrace((LPARAM) this, "Connection status: %d, Failure: %d", dwAck, m_dwDiagnostic);
        m_pISMTPConnection->AckConnection(dwAck);
        m_pISMTPConnection->SetDiagnosticInfo(m_dwDiagnostic, NULL, NULL);
        m_pISMTPConnection->Release();
        m_pISMTPConnection = NULL;
    }

    if(m_pDNS_RESOLVER_RECORD != NULL)
    {
        DebugTrace((LPARAM) this, "Deleting DNS_RESOLVER_RECORD in Async SMTP obj");
        delete m_pDNS_RESOLVER_RECORD;
        m_pDNS_RESOLVER_RECORD = NULL;
    }
    DBG_CODE(else DebugTrace((LPARAM) this, "No DNS_RESOLVER_RECORD set for Async SMTP obj"));

    if(m_pszSSLVerificationName)
        delete [] m_pszSSLVerificationName;

    m_pServiceInstance->RemoveAsyncDnsObject(this);
    TraceFunctLeaveEx((LPARAM) this);
}

//-----------------------------------------------------------------------------
//  Description:
//      Given a pDnsRec (array of host IP pairs) and an index into it, this
//      tries to resolve the host at the Index position. It is assumed that
//      the caller (GetMissingIpAddresses) has checked that the host at that
//      index lacks an IP address.
//  Arguments:
//      IN PSMTPDNS_RECS pDnsRec --- Array of (host, IP) pairs.
//      IN DWORD Index --- Index of host in pDnsRec to set IP for.
//  Returns:
//      TRUE --- Success IP was filled in for host.
//      FALSE --- Either the host was not resolved from DNS or an error
//          occurred (like "out of memory").
//-----------------------------------------------------------------------------
BOOL CAsyncSmtpDns::GetIpFromDns(PSMTPDNS_RECS pDnsRec, DWORD Index)
{
    struct hostent *hp = NULL;
    MXIPLIST_ENTRY * pEntry = NULL;
    BOOL fReturn = FALSE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncSmtpDns::GetIpFromDns");

    if(m_pServiceInstance->GetNameResolution() == RESOLUTION_UNCACHEDDNS)
    {
        fReturn = GetIpAddressFromDns(pDnsRec->DnsArray[Index]->DnsName, pDnsRec, Index);
        TraceFunctLeaveEx((LPARAM) this);
        return fReturn;
    }

    hp = gethostbyname (pDnsRec->DnsArray[Index]->DnsName);
    if(hp != NULL)
    {
        fReturn = TRUE;
        for (DWORD Loop = 0; !m_pServiceInstance->IsShuttingDown() && (hp->h_addr_list[Loop] != NULL); Loop++)
        {
            pEntry = new MXIPLIST_ENTRY;
            if(pEntry != NULL)
            {
                pDnsRec->DnsArray[Index]->NumEntries++;
                CopyMemory(&pEntry->IpAddress, hp->h_addr_list[Loop], 4);
                InsertTailList(&pDnsRec->DnsArray[Index]->IpListHead, &pEntry->ListEntry);
            }
            else
            {
                fReturn = FALSE;
                ErrorTrace((LPARAM) this, "Not enough memory");
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                break;
            }
        }
    }
    else
    {
        ErrorTrace((LPARAM) this, "gethostbyname failed on %s", pDnsRec->DnsArray[Index]->DnsName);
        SetLastError(ERROR_NO_MORE_ITEMS);
    }

    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;
}

//-----------------------------------------------------------------------------
//  Description:
//      This runs through the list of hosts (MX hosts, or if no MX records were
//      returned, the single target host) and verifies that they all have been
//      resolved to IP addresses. If any have been found that do not have IP
//      addresses, it will call GetIpFromDns to resolve it.
//  Arguments:
//      IN PSMTPDNS_RECS pDnsRec -- Object containing Host-IP pairs. Hosts
//          without and IP are filled in.
//  Returns:
//      TRUE -- Success, all hosts have IP addresses.
//      FALSE -- Unable to resolve all hosts to IP addresses, or some internal
//          error occurred (like "out of memory" or "shutdown in progress".
//-----------------------------------------------------------------------------
BOOL CAsyncSmtpDns::GetMissingIpAddresses(PSMTPDNS_RECS pDnsRec)
{
    DWORD    Count = 0;
    DWORD    Error = 0;
    BOOL    fSucceededOnce = FALSE;

    if(pDnsRec == NULL)
    {
        return FALSE;
    }

    while(!m_pServiceInstance->IsShuttingDown() && pDnsRec->DnsArray[Count] != NULL)
    {
        if(IsListEmpty(&pDnsRec->DnsArray[Count]->IpListHead))
        {
            SetLastError(NO_ERROR);
            if(!GetIpFromDns(pDnsRec, Count))
            {
                Error = GetLastError();
                if(Error != ERROR_NO_MORE_ITEMS)
                {
                    return FALSE;
                }
            }
            else
            {
                fSucceededOnce = TRUE;
            }
                
        }
        else
        {
            fSucceededOnce = TRUE;
        }
            

        Count++;
    }

    return ( fSucceededOnce );

}

//-----------------------------------------------------------------------------
//  Description:
//      HandleCompletedData is called when the DNS resolve is finished. It
//      does the final processing after DNS is finished, and sets the
//      m_dwDiagnostic flag appropriately. It does one of three things based
//      on the DnsStatus and m_AuxList:
//
//      (1) If the resolve was successful, it kicks off a connection to the
//          server and set the m_dwDiagnostic to ERROR_SUCCESS.
//      (2) If the resolve failed authoritatively, it set the m_dwDiagnostic
//          to NDR the messages (after checking for a smarthost) ==
//          AQUEUE_E_AUTHORITATIVE_HOST_NOT_FOUND.
//      (3) If the resolve failed (from dwDnsStatus and m_AuxList) or if
//          something fails during HandleCompletedData, the m_dwDiagnostic is
//          not modified (it remains initialized to AQUEUE_E_DNS_FAILURE, the
//          default error code).
//
//      m_dwDiagnostic is examined in ~CAsyncSmtpDns.
//  Arguments:
//      DNS_STATUS dwDnsStatus - Status code from DnsParseMessage
//  Returns:
//      Nothing.
//-----------------------------------------------------------------------------
void CAsyncSmtpDns::HandleCompletedData(DNS_STATUS dwDnsStatus)
{
    BOOL fRet = FALSE;
    PSMTPDNS_RECS TempList = NULL;
    CAsyncMx * pAsyncCon = NULL;
    MXPARAMS Params;

    TempList = m_AuxList;

    //
    // The DNS lookup failed authoritatively. The messages will be NDR'ed unless there
    // is a smarthost configured. If there is a smarthost, we will kick off a resolve
    // for it.
    //
    if(ERROR_NOT_FOUND == dwDnsStatus)
    {
        if(m_fConnectToSmartHost)
        {
            char szSmartHost[MAX_PATH+1];

            m_pServiceInstance->GetSmartHost(szSmartHost);
            ((REMOTE_QUEUE *)m_pServiceInstance->QueryRemoteQObj())->StartAsyncConnect(szSmartHost, 
                m_pISMTPConnection, m_DomainOptions, FALSE);

            //Do not release this ISMTPConnection object! We passed it on to 
            //StartAsyncConnect so that it can try to associate this object with 
            //a connection with the smart host. We set it to null here so that we
            //will not release it or ack it in the destructor of this object.
            m_pISMTPConnection = NULL;
            m_dwDiagnostic = ERROR_SUCCESS;
            return;
        } else {
            //No smart host, messages will be NDR'ed. Return value is meaningless.
            m_dwDiagnostic = AQUEUE_E_AUTHORITATIVE_HOST_NOT_FOUND;
            return;
        }
    }

    //Successful DNS lookup.
    if(m_AuxList)
    {
        m_AuxList = NULL;

        //
        // Make a last ditch effort to fill in the IP addresses for any hosts
        // that are still unresolved.
        //
        if( !GetMissingIpAddresses(TempList) )
        {
            m_dwDiagnostic = AQUEUE_E_HOST_NOT_FOUND;
            DeleteDnsRec(TempList);
            return;
        }
            

        Params.HostName = "";
        Params.PortNum = m_pServiceInstance->GetRemoteSmtpPort();
        Params.TimeOut = INFINITE;
        Params.CallBack = QueueCallBackFunction;
        Params.pISMTPConnection = m_pISMTPConnection;
        Params.pInstance = m_pServiceInstance;
        Params.pDnsRec = TempList;
        Params.pDNS_RESOLVER_RECORD = m_pDNS_RESOLVER_RECORD; 

        pAsyncCon = new CAsyncMx (&Params);
        if(pAsyncCon != NULL)
        {
            //  Abdicate responsibility for deleting/releasing the dns resolver record
            m_pDNS_RESOLVER_RECORD = NULL;

            //  Outbound SSL: Set name against which server cert. should matched
            fRet = pAsyncCon->Init(m_pszSSLVerificationName);
            if(!fRet)
            {
                delete pAsyncCon;
                goto Exit;
            }
            
            if(!m_fConnectToSmartHost)
            {
                pAsyncCon->SetTriedOnFailHost();
            }

            pAsyncCon->SetDomainOptions(m_DomainOptions);

            fRet = pAsyncCon->InitializeAsyncConnect();
            if(!fRet)
            {
                delete pAsyncCon;
            }
            else
            {
                m_dwDiagnostic = ERROR_SUCCESS;
            }
        }
        else
        {
            DeleteDnsRec(TempList);
        }
    }
Exit:
    return;
}

//------------------------------------------------------------------------------
//  Description:
//      Simple wrapper function for DnsQueryAsync. This is a virtual function
//      called from CAsyncDns but implemented in CAsyncSmtpDns. In order to retry
//      a DNS query we need all the parameters of the old query. These are members
//      of CAsyncSmtpDns. Thus the virtual function based implementation.
//
//  Arguments:
//      BOOL fUdp -- Use UDP as transport for retry query?
//
//  Returns:
//      TRUE on success. In this situation the ISMTPConnection ack (and release of
//          pDNS_RESOLVER_RECORD) is handled by the new CAsyncSmtpDns object created
//          by DnsQueryAsync. The diagnostic code of this object is cleared.
//
//      FALSE on error. In this case, the cleanup for ISMTPConnection and
//          pDNS_RESOLVER_RECORD must be done by "this" CAsyncSmtpDns. The
//          diagnostic code is not touched.
//------------------------------------------------------------------------------
BOOL CAsyncSmtpDns::RetryAsyncDnsQuery(BOOL fUdp)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncSmtpDns::RetryAsyncDnsQuery");
    BOOL fRet = FALSE;

    //
    //  If we do not have a connection object, then the requery attempt
    //  is doomed to fail. This can happen when we disconnect and 
    //  ATQ calls our completion function with ERROR_OPERATION_ABORTED
    //  If we don't have a connection object, there is no way to 
    //  ack the connection or get messages to send.
    //
    if (!m_pISMTPConnection) {
        DebugTrace((LPARAM) this, 
            "RetryAsyncDnsQuery called without connection object - aborting");
        //should be cleared by same code path
        _ASSERT(!m_pDNS_RESOLVER_RECORD); 
        fRet = FALSE; //there is nothing to Ack.
        goto Exit;
    }
    fRet = DnsQueryAsync(
                m_pServiceInstance,
                m_HostName,
                m_FQDNToDrop,
                m_pISMTPConnection,
                m_dwFlags,
                m_DomainOptions,
                m_fConnectToSmartHost,
                m_pDNS_RESOLVER_RECORD,
                m_pszSSLVerificationName,
                fUdp);

    if(fRet) {
        m_pDNS_RESOLVER_RECORD = NULL;
        m_pISMTPConnection = NULL;
        m_dwDiagnostic = ERROR_SUCCESS;
    }

  Exit:
    TraceFunctLeave();
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\smtpproc.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    smtpproc.h

Abstract:

    This module contains function prototypes used by the SMTP server.

Author:

    Johnson Apacible (JohnsonA)     12-Sept-1995

Revision History:

--*/

#ifndef	_SMTPPROC_
#define	_SMTPPROC_

//
// smtpdata.cpp
//

APIERR
InitializeGlobals(
            VOID
            );

VOID
TerminateGlobals(
            VOID
            );

//
//  Socket utilities.
//

APIERR InitializeSockets( VOID );

VOID TerminateSockets( VOID );

VOID
SmtpOnConnect(
    SOCKET        sNew,
    SOCKADDR_IN * psockaddr
    );

VOID
SmtpOnConnectEx(
    VOID * pAtqContext,
    DWORD  cdWritten,
    DWORD  err,
    OVERLAPPED * lpo
    );

VOID
SmtpCompletion(
    PVOID        Context,
    DWORD        BytesWritten,
    DWORD        CompletionStatus,
    OVERLAPPED * lpo
    );

VOID
SmtpCompletionFIO(
	PFIO_CONTEXT		pFIOContext,
	FH_OVERLAPPED		*pOverlapped,
	DWORD				cbWritten,
	DWORD				dwCompletionStatus
    );

//
//  IPC functions.
//

APIERR InitializeIPC( VOID );
VOID TerminateIPC( VOID );

//
// svcstat.c
//

VOID
ClearStatistics(
        VOID
        );

#endif // _SMTPPROC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\smtpout.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        smtpout.cxx

   Abstract:

        This module defines the functions for derived class of connections
        for Internet Services  ( class SMTP_CONNOUT)

   Author:

           Rohan Phillips    ( Rohanp )    02-Feb-1996

   Project:

          SMTP Server DLL

   Functions Exported:

          SMTP_CONNOUT::~SMTP_CONNOUT()
          BOOL SMTP_CONNOUT::ProcessClient( IN DWORD cbWritten,
                                                  IN DWORD dwCompletionStatus,
                                                  IN BOOL  fIOCompletion)

          BOOL SMTP_CONNOUT::StartupSession( VOID)

   Revision History:


--*/


/************************************************************
 *     Include Headers
 ************************************************************/


#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "remoteq.hxx"
#include "smtpmsg.h"

//
// ATL includes
//
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL

//
// SEO includes
//
#include "seo.h"
#include "seolib.h"

#include <memory.h>
#include "smtpcli.hxx"
#include "smtpout.hxx"
#include <smtpevent.h>
#include <smtpguid.h>

//
// Dispatcher implementation
//
#include "pe_dispi.hxx"


    int strcasecmp(char *s1, char *s2);
    int strncasecmp(char *s1, char *s2, int n);

extern CHAR g_VersionString[];

static char * IsLineCompleteBW(IN OUT char *  pchRecvd, IN  DWORD cbRecvd, IN DWORD cbMaxRecvBuffer);

#define SMTP_DUMMY_FAILURE  (0x1000 | SMTP_ACTION_ABORTED_CODE)
#define SMTPOUT_CONTENT_FILE_IO_TIMEOUT 2*60*1000

static const char * TO_MANY_RCPTS_ERROR = "552 Too many recipients";

#define KNOWN_AUTH_FLAGS ((DWORD)(DOMAIN_INFO_USE_NTLM | DOMAIN_INFO_USE_PLAINTEXT | DOMAIN_INFO_USE_DPA \
        | DOMAIN_INFO_USE_KERBEROS))

#define INVALID_RCPT_IDX_VALUE 0xFFFFFFFF

// provide memory for static declared in SMTP_CONNOUT
CPool  SMTP_CONNOUT::Pool(CLIENT_CONNECTION_SIGNATURE_VALID);

//
// Statics for outbound protocol events
//
CInboundDispatcherClassFactory    g_cfInbound;
COutboundDispatcherClassFactory    g_cfOutbound;
CResponseDispatcherClassFactory    g_cfResponse;

/************************************************************
 *    Functions
 ************************************************************/

#define MAX_LOG_ERROR_LEN (500)

extern void DeleteDnsRec(PSMTPDNS_RECS pDnsRec);

VOID
SmtpCompletion(
              PVOID        pvContext,
              DWORD        cbWritten,
              DWORD        dwCompletionStatus,
              OVERLAPPED * lpo
              );

/*++
    Name :
        InternetCompletion

    Description:

        Handles a completed I/O for outbound connections.

    Arguments:

        pvContext:          the context pointer specified in the initial IO
        cbWritten:          the number of bytes sent
        dwCompletionStatus: the status of the completion (usually NO_ERROR)
        lpo:                the overlapped structure associated with the IO

    Returns:

        nothing.

--*/
VOID InternetCompletion(PVOID pvContext, DWORD cbWritten,
                        DWORD dwCompletionStatus, OVERLAPPED * lpo)
{
    BOOL WasProcessed;
    SMTP_CONNOUT *pCC = (SMTP_CONNOUT *) pvContext;

    _ASSERT(pCC);
    _ASSERT(pCC->IsValid());
    _ASSERT(pCC->QuerySmtpInstance() != NULL);

    TraceFunctEnterEx((LPARAM) pCC, "InternetCompletion");

    // if we could not process a command, or we were
    // told to destroy this object, close the connection.
    WasProcessed = pCC->ProcessClient(cbWritten, dwCompletionStatus, lpo);
    if (!WasProcessed) {
        pCC->DisconnectClient();
        pCC->QuerySmtpInstance()->RemoveOutboundConnection(pCC);
        delete pCC;
        pCC = NULL;
    }

    //TraceFunctLeaveEx((LPARAM)pCC);
}

VOID FIOInternetCompletion(PFIO_CONTEXT pFIOContext,
                           PFH_OVERLAPPED lpo,
                           DWORD cbWritten,
                           DWORD dwCompletionStatus)
{
    BOOL WasProcessed;
    SMTP_CONNOUT *pCC = (SMTP_CONNOUT *) (((SERVEREVENT_OVERLAPPED *) lpo)->ThisPtr);

    _ASSERT(pCC);
    _ASSERT(pCC->IsValid());
    _ASSERT(pCC->QuerySmtpInstance() != NULL);

    TraceFunctEnterEx((LPARAM) pCC, "InternetCompletion");

    // if we could not process a command, or we were
    // told to destroy this object, close the connection.
    WasProcessed = pCC->ProcessClient(cbWritten, dwCompletionStatus, (OVERLAPPED *) lpo);

    if (!WasProcessed) {
        pCC->DisconnectClient();
        pCC->QuerySmtpInstance()->RemoveOutboundConnection(pCC);
        delete pCC;
        pCC = NULL;
    }

    //TraceFunctLeaveEx((LPARAM)pCC);
}

void SMTP_CONNOUT::ProtocolLogCommand(LPSTR pszCommand,
                                      DWORD cParameters,
                                      LPCSTR pszIpAddress,
                                      FORMAT_SMTP_MESSAGE_LOGLEVEL eLogLevel)
{
    char *pszCR = NULL, *pszParameters = NULL, *pszSpace = NULL;
    DWORD cBytesSent;

    if (eLogLevel == FSM_LOG_NONE) return;

    if (pszCR = strchr(pszCommand, '\r')) *pszCR = 0;

    if (pszSpace = strchr(pszCommand, ' ')) {
        *pszSpace = 0;
        pszParameters = (eLogLevel == FSM_LOG_ALL) ? pszSpace + 1 : NULL;
    }

    cBytesSent = strlen(pszCommand);

    LogRemoteDeliveryTransaction(
        pszCommand,
        NULL,
        pszParameters,
        pszIpAddress,
        0,
        0,
        cBytesSent,
        0,
        FALSE);

    if (pszCR) *pszCR = '\r';
    if (pszSpace) *pszSpace = ' ';
}

void SMTP_CONNOUT::ProtocolLogResponse(LPSTR pszResponse,
                                       DWORD cParameters,
                                       LPCSTR pszIpAddress)
{
    char *pszCR = NULL;
    DWORD cBytesReceived;

    if (pszCR = strchr(pszResponse, '\r')) *pszCR = 0;
    cBytesReceived = strlen(pszResponse);

    LogRemoteDeliveryTransaction(
        NULL,
        NULL,
        pszResponse,
        pszIpAddress,
        0,
        0,
        cBytesReceived,
        0,
        TRUE);

    if (pszCR) *pszCR = '\r';
}

void SMTP_CONNOUT::LogRemoteDeliveryTransaction(
                                               LPCSTR pszOperation,
                                               LPCSTR pszTarget,
                                               LPCSTR pszParameters,
                                               LPCSTR pszIpAddress,
                                               DWORD dwWin32Error,
                                               DWORD dwServiceSpecificStatus,
                                               DWORD dwBytesSent,
                                               DWORD dwBytesReceived,
                                               BOOL fResponse
                                               )
{
    INETLOG_INFORMATION translog;
    DWORD  dwLog;
    LPSTR lpNull = "";
    DWORD cchError = MAX_LOG_ERROR_LEN;
    char VersionString[] = "SMTP";
    char szClientUserNameCommand[] = "OutboundConnectionCommand";
    char szClientUserNameResponse[] = "OutboundConnectionResponse";

    //Buffers to prevent overwrite by IIS logging
    //which does evil things like change '<sp>' to '+'
    //      6/23/99 - MikeSwa
    char szOperationBuffer[20]    = "";   //This is the protocol verb
    char szTargetBuffer[20]       = "";   //Currently unused by all callers
    char szParametersBuffer[1024] = "";   //Data portion of buffer information

    ZeroMemory(&translog, sizeof(translog));

    if (pszParameters == NULL)
        pszParameters = lpNull;

    if (pszIpAddress == NULL)
        pszIpAddress = lpNull;

    translog.pszVersion = VersionString;
    translog.msTimeForProcessing = QueryProcessingTime();;
    if (fResponse) {
        translog.pszClientUserName = szClientUserNameResponse;
    } else {
        translog.pszClientUserName = szClientUserNameCommand;
    }

    translog.pszClientHostName = m_ConnectedDomain;
    translog.cbClientHostName = lstrlen(m_ConnectedDomain);

    //Make sure we log the correct port number
    if (IsSecure()) {
        translog.dwPort = QuerySmtpInstance()->GetRemoteSmtpSecurePort();
    } else {
        translog.dwPort = QuerySmtpInstance()->GetRemoteSmtpPort();
    }

    //Copy buffers
    if (pszOperation) {
        lstrcpyn(szOperationBuffer, pszOperation, sizeof(szOperationBuffer)-sizeof(CHAR));
        translog.pszOperation = szOperationBuffer;
        translog.cbOperation = lstrlen(szOperationBuffer);
    } else {
        translog.pszOperation = "";
        translog.cbOperation = 0;
    }

    if (pszTarget) {
        lstrcpyn(szTargetBuffer, pszTarget, sizeof(szTargetBuffer)-sizeof(CHAR));
        translog.pszTarget = szTargetBuffer;
        translog.cbTarget = lstrlen(szTargetBuffer);
    } else {
        translog.pszTarget = "";
        translog.cbTarget = 0;
    }

    if (pszParameters) {
        lstrcpyn(szParametersBuffer, pszParameters, sizeof(szParametersBuffer)-sizeof(CHAR));
        translog.pszParameters = szParametersBuffer;
    } else {
        translog.pszParameters = "";
    }

    //Detect if usage drastically changes... but don't check parameters, because
    //we don't care about logging more than 1K per command
    _ASSERT(sizeof(szOperationBuffer) > lstrlen(pszOperation));
    _ASSERT(sizeof(szTargetBuffer) > lstrlen(pszTarget));

    translog.dwBytesSent = dwBytesSent;
    translog.dwBytesRecvd = dwBytesReceived;
    translog.dwWin32Status = dwWin32Error;
    translog.dwProtocolStatus = dwServiceSpecificStatus;

    dwLog = QuerySmtpInstance()->m_Logging.LogInformation( &translog);
}

/*++

    Name:

    SMTP_CONNOUT::SMTP_CONNOUT

    Constructs a new SMTP connection object for the client
    connection given the client connection socket and socket
    address. This constructor is private.  Only the Static
    member funtion, declared below, can call it.

    Arguments:

      sClient       socket for communicating with client

      psockAddrRemote pointer to address of the remote client
                ( the value should be copied).
      psockAddrLocal  pointer to address for the local card through
                  which the client came in.
      pAtqContext      pointer to ATQ Context used for AcceptEx'ed conn.
      pvInitialRequest pointer to void buffer containing the initial request
      cbInitialData    count of bytes of data read initially.

--*/
SMTP_CONNOUT::SMTP_CONNOUT(
                          IN PSMTP_SERVER_INSTANCE pInstance,
                          IN SOCKET sClient,
                          IN const SOCKADDR_IN *  psockAddrRemote,
                          IN const SOCKADDR_IN *  psockAddrLocal /* = NULL */ ,
                          IN PATQ_CONTEXT         pAtqContext    /* = NULL */ ,
                          IN PVOID                pvInitialRequest/* = NULL*/ ,
                          IN DWORD                cbInitialData  /* = 0    */
                          )
:  m_encryptCtx( TRUE ),
m_securityCtx(pInstance,
              TCPAUTH_CLIENT| TCPAUTH_UUENCODE,
              ((PSMTP_SERVER_INSTANCE)pInstance)->QueryAuthentication()),
CLIENT_CONNECTION ( sClient, psockAddrRemote,
                    psockAddrRemote,  pAtqContext,
                    pvInitialRequest, cbInitialData )
{

    _ASSERT(pInstance != NULL);

    m_cActiveThreads = 0;
    m_cPendingIoCount = 0;
    m_MsgOptions = 0;
    m_AuthToUse = 0;
    m_pInstance = pInstance;
    m_UsingSSL = FALSE;
    m_fCanTurn = TRUE;
    m_pIMsg = NULL;
    m_pIMsgRecips = NULL;
    m_pISMTPConnection = NULL;
    m_AdvContext = NULL;
    m_pDnsRec = NULL;
    m_EhloSent = FALSE;

    pInstance->IncConnOutObjs();

    //
    // By default, we use the smallish receive buffer inherited from
    // the base CLIENT_CONNECTION object and a smallish output buffer defined in
    // SMTP_CONNOUT
    //
    m_precvBuffer = m_recvBuffer;
    m_cbMaxRecvBuffer =  sizeof(m_recvBuffer);
    m_pOutputBuffer = m_OutputBuffer;
    m_cbMaxOutputBuffer =  sizeof(m_OutputBuffer);

    m_OutboundContext.m_cabNativeCommand.SetBuffer(
                                                  m_NativeCommandBuffer,
                                                  SMTP_MAX_COMMAND_LENGTH);

    m_pmszTurnList = NULL;
    m_szCurrentTURNDomain = NULL;
    m_IMsgDotStuffedFileHandle = NULL;

    m_ConnectedDomain [0] = '\0';

    m_pBindInterface = NULL;

    m_SeoOverlapped.ThisPtr = (PVOID) this;
    m_SeoOverlapped.pfnCompletion = InternetCompletion;
    //initialize this error in case the connection gets
    //broken early.
    m_Error =  ERROR_BROKEN_PIPE;

    m_fNeedRelayedDSN = FALSE;
    m_fHadHardError = FALSE;
    m_fHadTempError = FALSE;
    m_fHadSuccessfulDelivery = FALSE;


    //
    // Protocol Events
    //
    m_fNativeHandlerFired    = FALSE;
    m_pOutboundDispatcher    = NULL;
    m_pResponseDispatcher    = NULL;

    //
    // Diagnostic Information
    //
    m_hrDiagnosticError      = S_OK;
    m_szDiagnosticVerb       = NULL;
    m_szDiagnosticResponse[0]= '\0';

    m_szCurrentETRNDomain = NULL;
    m_pszSSLVerificationName = NULL;
}

/*++

    Name :
        SMTP_CONNOUT::~SMTP_CONNOUT (void)

    Description:

        Destructor for outbound connection object.
        This routine checks to see if there was a
        current mail object that was being processed
        before this destructor was called and does
        whatever is necessary to clean up its' memory.
        Then it checks the mailbag and cleans up any
        mail objects it finds in there.


    Arguments:

        none

    Returns:

        none

--*/

SMTP_CONNOUT::~SMTP_CONNOUT (void)
{
    PSMTP_SERVER_INSTANCE pInstance = NULL;
    HRESULT hrDiagnostic = S_OK;
    char * pTempBuffer = NULL;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::~SMTP_CONNOUT (void)");

    //We need to call our cleanup function... so that the ATQ context will be
    //freed. We do this first, because a message ack or connection ack may
    //trigger DSN generation, which may take long enough to cause the context
    //to time out and complete on us (causing one thread to AV).
    Cleanup();

    //catch all message ack call
    //NK** : Need to substitute it with an HRESULT based on the actual internal error
    //mikeswa - 9/11/98 - Add check recips to flags

    HandleCompletedMailObj(MESSAGE_STATUS_RETRY_ALL | MESSAGE_STATUS_CHECK_RECIPS, "451 Remote host dropped connection", 0);


    //if we were doing a TLS transmission that got interrupted, we need to
    //destroy the AtqContext we created for reading from the mail file.
    //FreeAtqFileContext();

    if (m_pISMTPConnection) {
        //Ack the connection
        m_pISMTPConnection->AckConnection((eConnectionStatus)m_dwConnectionStatus);

        if (FAILED(m_hrDiagnosticError))
        {
            m_pISMTPConnection->SetDiagnosticInfo(m_hrDiagnosticError,
                    m_szDiagnosticVerb, m_szDiagnosticResponse);
        }
        else if (CONNECTION_STATUS_OK != m_dwConnectionStatus)
        {
            //Report appropriate diagnostic information if we don't have specific failures
            switch (m_dwConnectionStatus)
            {
                case CONNECTION_STATUS_DROPPED:
                    hrDiagnostic = AQUEUE_E_CONNECTION_DROPPED;
                    break;
                case CONNECTION_STATUS_FAILED:
                    hrDiagnostic = AQUEUE_E_CONNECTION_FAILED;
                    break;
                default:
                    hrDiagnostic = E_FAIL;
            }
            m_pISMTPConnection->SetDiagnosticInfo(hrDiagnostic, NULL, NULL);
        }

        m_pISMTPConnection->Release();
        m_pISMTPConnection = NULL;
    }

    //If we had a TURN list free it up
    if (m_pmszTurnList) {
        delete m_pmszTurnList;
        m_pmszTurnList = NULL;
        m_szCurrentTURNDomain = NULL;
    }

    pInstance = (PSMTP_SERVER_INSTANCE ) InterlockedExchangePointer((PVOID *) &m_pInstance, (PVOID) NULL);
    if (pInstance != NULL) {
        pInstance->DecConnOutObjs();
    }

    pTempBuffer = (char *) InterlockedExchangePointer((PVOID *) &m_precvBuffer, (PVOID) &m_recvBuffer[0]);
    if (pTempBuffer != m_recvBuffer) {
        delete [] pTempBuffer;
    }

    pTempBuffer = (char *) InterlockedExchangePointer((PVOID *) &m_pOutputBuffer, (PVOID) &m_OutputBuffer[0]);
    if (pTempBuffer != m_OutputBuffer) {
        delete [] pTempBuffer;
    }

    // Protocol events: Release the dispatchers
    if (m_pOutboundDispatcher)
        m_pOutboundDispatcher->Release();

    if (m_pResponseDispatcher)
        m_pResponseDispatcher->Release();

    if (m_pDnsRec) {
        DeleteDnsRec(m_pDnsRec);
        m_pDnsRec = NULL;
    }

    if (m_pszSSLVerificationName) {
        delete [] m_pszSSLVerificationName;
        m_pszSSLVerificationName;
    }

    DebugTrace((LPARAM) this,"%X was deleted", this);
    TraceFunctLeaveEx((LPARAM)this);
}

/*++

    Name :
        SMTP_CONNOUT::DisconnectClient(DWORD dwErrorCode)

    Description:

        Disconnects from the remote server. It first calls
        CLIENT_CONNECTION::DisconnectClient, and then shuts down any mail-file
        read handles we may be pending reads on.

    Arguments:

        dwErrorCode -- Passed through to CLIENT_CONNECTION::Disconnect

    Returns:

        nothing

--*/

VOID SMTP_CONNOUT::DisconnectClient(DWORD dwErrorCode)
{
    TraceFunctEnter("SMTP_CONNOUT::DisconnectClient");

    if (m_DoCleanup)
        CLIENT_CONNECTION::DisconnectClient();
}

/*++

    Name :
        SMTP_CONNOUT::HandleCompletedMailObj


    Description:

        This routinr gets called after the mail file
        has been sent. It will either requeue the object
        in the outbound queue, retry queue, BadMail,etc.

    Arguments:

        none

    Returns:

        none

--*/
void SMTP_CONNOUT::HandleCompletedMailObj(DWORD MsgStatus, char * szExtendedStatus, DWORD cbExtendedStatus)
{
    MessageAck MsgAck;
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::HandleCompletedMailObj");

    _ASSERT(IsValid());

    if (m_pISMTPConnection) {
        if (m_pIMsgRecips) {
            //Uncheck all marked recipients if the connection has been dropped
            if (((m_dwConnectionStatus != CONNECTION_STATUS_OK) || (szExtendedStatus[0] != SMTP_COMPLETE_SUCCESS)) &&
                m_NumRcptSentSaved) {
                UnMarkHandledRcpts();
            }
            m_pIMsgRecips->Release();
            m_pIMsgRecips = NULL;

        }

        if (m_pIMsg) {
            MsgAck.pvMsgContext = (DWORD *) m_AdvContext;
            MsgAck.pIMailMsgProperties = m_pIMsg;

            if ( (MsgStatus & MESSAGE_STATUS_RETRY_ALL) ||
                 (MsgStatus & MESSAGE_STATUS_NDR_ALL)) {
                //DebugTrace((LPARAM) this,"CompObj:file %s going to %s was retryed", FileName, m_ConnectedDomain);

            } else {
                //DebugTrace((LPARAM) this,"CompObj:file %s going to %s was delivered", FileName, m_ConnectedDomain);

            }

            MsgAck.dwMsgStatus = MsgStatus;
            MsgAck.dwStatusCode = 0;

            //We will have an extended status string to go along with the Status code
            //in case of some major failure that makes us fail the complete message
            if (MsgStatus & MESSAGE_STATUS_EXTENDED_STATUS_CODES ) {
                MsgAck.cbExtendedStatus = cbExtendedStatus;
                MsgAck.szExtendedStatus = szExtendedStatus;
            }

            if (m_pBindInterface) {
                m_pBindInterface->ReleaseContext();
                m_pBindInterface->Release();
                m_pBindInterface = NULL;

                if( NULL != m_IMsgDotStuffedFileHandle )
                {
                    ReleaseContext( m_IMsgDotStuffedFileHandle );
                    m_IMsgDotStuffedFileHandle = NULL;
                }
            }

            //
            // Do Message Tracking
            //

            MSG_TRACK_INFO msgTrackInfo;
            ZeroMemory( &msgTrackInfo, sizeof( msgTrackInfo ) );

            msgTrackInfo.dwEventId = MTE_END_OUTBOUND_TRANSFER;
            msgTrackInfo.pszPartnerName = m_ConnectedDomain;
            if( MsgStatus & MESSAGE_STATUS_RETRY_ALL )
            {
                msgTrackInfo.dwRcptReportStatus = MP_STATUS_RETRY;
            }
            else if( MsgStatus & MESSAGE_STATUS_NDR_ALL )
            {
                msgTrackInfo.dwEventId = MTE_NDR_ALL;
                msgTrackInfo.pszPartnerName = NULL;
                msgTrackInfo.dwRcptReportStatus = MP_STATUS_ABORT_DELIVERY;
            }

            m_pInstance->WriteLog( &msgTrackInfo, m_pIMsg, NULL, NULL );

            m_pISMTPConnection->AckMessage(&MsgAck);
            m_pIMsg->Release();
            m_pIMsg = NULL;
        }
    }

    TraceFunctLeaveEx((LPARAM) this);
}

/*++

    Name :
        SMTP_CONNOUT::UnMarkHandledRcpts


    Description:

        When we send out recipients we assumptively mark the recipients as
        delivered or failed based on the responses. Later if it turns out that we
        could never completely send the message. we need to rset the status of
        successful recipients.  However, if we have a hard per-recipient error,
        we should leave the error code intact (otherwise the sender may receive
        a DELAY DSN with a 500-level status code).

    Arguments:

        none

    Returns:

        none

--*/

BOOL SMTP_CONNOUT::UnMarkHandledRcpts(void)
{
    DWORD i;
    HRESULT hr = S_OK;
    DWORD dwRecipientFlags;
    DWORD dwRcptsSaved = m_NumRcptSentSaved;

    //
    //  It is possible for this to be called after HandleCompletedMailObj (after
    //  a 421 response to a DATA command for example).  We should bail if we
    //  do not have a mailmsg ptr.
    //
    if (!m_pIMsgRecips)
        return (TRUE);

    for (i = m_FirstAddressinCurrentMail; (i < m_NumRcpts) && dwRcptsSaved;i++) {
        //Get to the next rcpt that we send out this time
        if (m_RcptIndexList[i] != INVALID_RCPT_IDX_VALUE) {
            //
            //  The ideal way to handle this situation is to use the
            //  RP_VOLATILE_FLAGS_MASK bits in the recipient flags a tmp
            //  storage and then "commit" the handled bit after a successful
            //  connection. Given how mailmsg works, this is not a problem
            //   -  While we are processing the message... it is not possible
            //      for it to be saved to disk until we are done with it.
            //   -  If we can write a property once before committing... we
            //      can always rewrite a property of the same size (since
            //      the required portion of the property stream is already
            //      in memory.
            //  I have added the ASSERT(SUCEEDED(hr)) below
            //      - mikeswa 9/11/98 (updated 10/05/2000)
            dwRecipientFlags = 0;
            hr = m_pIMsgRecips->GetDWORD(m_RcptIndexList[i], IMMPID_RP_RECIPIENT_FLAGS,&dwRecipientFlags);
            if (FAILED(hr)) {
                //Problemmo
                SetLastError(ERROR_OUTOFMEMORY);
                return (FALSE);
            }

            //Check to see if we marked it as delivered... and unmark it if we did
            if (RP_DELIVERED == (dwRecipientFlags & RP_DELIVERED)) {
                dwRecipientFlags &= ~RP_DELIVERED;

                hr = m_pIMsgRecips->PutDWORD(m_RcptIndexList[i], IMMPID_RP_RECIPIENT_FLAGS,dwRecipientFlags);
                if (FAILED(hr)) {
                    //
                    //  We need to understand how this can fail... mailmsg
                    //  is designed so this should not happen.
                    //
                    ASSERT(FALSE && "Potential loss of recipient");
                    SetLastError(ERROR_OUTOFMEMORY);
                    return (FALSE);
                }
            }
            dwRcptsSaved--;
        }
    }

    return (TRUE);
}



/*++

    Name :
        SMTP_CONNOUT::InitializeObject

    Description:
       Initializes all member variables and pre-allocates
       a mail context class

    Arguments:
        Options - SSL etc.
        pszSSLVerificationName - Subject name to look for in server certificate
            if using SSL
    Returns:

       TRUE if memory can be allocated.
       FALSE if no memory can be allocated
--*/
BOOL SMTP_CONNOUT::InitializeObject (
    DWORD Options,
    LPSTR pszSSLVerificationName)
{
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::InitializeObject");

    m_szCurrentETRNDomain = NULL;
    m_cbReceived = 0;
    m_cbParsable = 0;
    m_OutputBufferSize = 0;
    m_NumRcptSent = 0;
    m_FirstAddressinCurrentMail = 0;
    m_NumRcptSentSaved = 0;
    m_SizeOptionSize = 0;
    m_Flags = 0;
    m_NumFailedAddrs = 0;
    m_cActiveThreads = 0;
    m_cPendingIoCount = 0;
    m_FileSize = 0;

    m_NextAddress = 0;
    m_FirstPipelinedAddress = 0;
    m_First552Address = -1;
    m_NextState = NULL;
    m_HeloSent = FALSE;
    m_EhloFailed = FALSE;
    m_FirstRcpt = FALSE;
    m_SendAgain = FALSE;
    m_Active = TRUE;
    m_HaveDataResponse = FALSE;

    m_SecurePort = FALSE;
    m_fNegotiatingSSL = FALSE;

    m_MsgOptions = Options;
    m_dwConnectionStatus = CONNECTION_STATUS_OK;

    m_fUseBDAT = FALSE;

    m_fNeedRelayedDSN = FALSE;
    m_fHadHardError = FALSE;
    m_fHadTempError = FALSE;
    m_fHadSuccessfulDelivery = FALSE;

    if (Options & KNOWN_AUTH_FLAGS) {
        m_pInstance->LockGenCrit();

        //   Initialize Security Context
        //
        if (!m_securityCtx.SetInstanceAuthPackageNames(
                                                      m_pInstance->GetProviderPackagesCount(),
                                                      m_pInstance->GetProviderNames(),
                                                      m_pInstance->GetProviderPackages())) {
            m_Error = GetLastError();
            ErrorTrace((LPARAM)this, "SetInstanceAuthPackageNames FAILED <Err=%u>",
                       m_Error);
            fRet = FALSE;
        }

        //
        // We want to set up the Cleartext authentication package
        // for this connection based on the instance configuration.
        // To enable MBS CTA,
        // MD_SMTP_CLEARTEXT_AUTH_PROVIDER must be set to the package name.
        // To disable it, the md value must be set to "".
        //

        if (fRet) {
            m_securityCtx.SetCleartextPackageName(
                                                 m_pInstance->GetCleartextAuthPackage(),
                                                 m_pInstance->GetMembershipBroker());

            if (*m_pInstance->GetCleartextAuthPackage() == '\0' ||
                *m_pInstance->GetMembershipBroker() == '\0') {
                m_fUseMbsCta = FALSE;
            } else {
                m_fUseMbsCta = TRUE;
            }
        }

        m_pInstance->UnLockGenCrit();
    }

    m_pmszTurnList = NULL;
    m_szCurrentTURNDomain = NULL;

    m_UsingSSL = (Options & DOMAIN_INFO_USE_SSL);
    m_TlsState = (Options & DOMAIN_INFO_USE_SSL) ? MUST_DO_TLS : DONT_DO_TLS;

    m_TransmitTailBuffer[0] = '.';
    m_TransmitTailBuffer[1] = '\r';
    m_TransmitTailBuffer[2] = '\n';

    m_TransmitBuffers.Head = NULL;
    m_TransmitBuffers.HeadLength = 0;
    m_TransmitBuffers.Tail = m_TransmitTailBuffer;
    m_TransmitBuffers.TailLength = 3;

    //
    // Protocol events: get the response dispatcher for the session
    //
    m_pIEventRouter = m_pInstance->GetRouter();
    if (m_pIEventRouter) {
        HRESULT hr = m_pIEventRouter->GetDispatcherByClassFactory(
                                                                 CLSID_CResponseDispatcher,
                                                                 &g_cfResponse,
                                                                 CATID_SMTP_ON_SERVER_RESPONSE,
                                                                 IID_ISmtpServerResponseDispatcher,
                                                                 (IUnknown **)&m_pResponseDispatcher);
        if (!SUCCEEDED(hr)) {
            // If we fail, we don't process protocol events
            m_pResponseDispatcher = NULL;
            ErrorTrace((LPARAM) this,
                       "Unable to get response dispatcher from router (%08x)",    hr);
        }
    }

    if (pszSSLVerificationName) {
        m_pszSSLVerificationName = new char [lstrlen (pszSSLVerificationName) + 1];
        if (!m_pszSSLVerificationName) {
            fRet = FALSE;
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto Exit;
        }

        lstrcpy (m_pszSSLVerificationName, pszSSLVerificationName);
    }
    StartProcessingTimer();

Exit:
    TraceFunctLeaveEx((LPARAM) this);
    return fRet;
}

BOOL SMTP_CONNOUT::GoToWaitForConnectResponseState(void)
{
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::GoToWaitForConnectResponseState( void)");

    SetNextState (&SMTP_CONNOUT::WaitForConnectResponse);

    m_Error = NO_ERROR;
    m_LastClientIo = SMTP_CONNOUT::READIO;
    IncPendingIoCount();
    fRet = ReadFile(QueryMRcvBuffer(), m_cbMaxRecvBuffer);
    if (!fRet) {
        m_Error = GetLastError();
        DebugTrace((LPARAM) this, "SMTP_CONNOUT::WaitForConnectResponseState - ReadFile failed with error %d", m_Error);
        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
        DisconnectClient();
        DecPendingIoCount();
        SetLastError(m_Error);
        SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
        fRet = FALSE;
    }

    return fRet;
}

BOOL SMTP_CONNOUT::GetNextTURNConnection(void)
{
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::GetNextTURNConnection( void)");
    //We are on a TURNed connection and need to start the queue for next
    //domain in the turn list if it exists
    //Before getting the next connection release the current one.
    //
    if (m_pISMTPConnection) {
        //Ack the last connection
        m_dwConnectionStatus = CONNECTION_STATUS_OK;
        m_pISMTPConnection->AckConnection((eConnectionStatus)m_dwConnectionStatus);
        m_pISMTPConnection->Release();
        m_pISMTPConnection = NULL;
    }

    m_szCurrentTURNDomain = m_pmszTurnList->Next( m_szCurrentTURNDomain );
    while (m_szCurrentTURNDomain && !QuerySmtpInstance()->IsShuttingDown()) {
        //We have another domain to start
        hr = QuerySmtpInstance()->GetConnManPtr()->GetNamedConnection(lstrlen(m_szCurrentTURNDomain), (CHAR*)m_szCurrentTURNDomain, &m_pISMTPConnection);
        if (FAILED(hr)) {
            //Something bad happened on this call
            ErrorTrace((LPARAM) this, "StartSession - SMTP_ERROR_PROCESSING_CODE, GetNamedConnection failed %d",hr);
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }

        //If the link corresponding to this domain does not exist in AQ, we get a NULL
        //ISMTPConnection at this point
        if (m_pISMTPConnection)
            break;
        else {
            m_szCurrentTURNDomain = m_pmszTurnList->Next( m_szCurrentTURNDomain );
            continue;
        }
    }

    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}

/*++

   Name :
       SMTP_CONNOUT::StartSession

   Description:

       Starts up a session for new client.
       starts off a receive request from client.

   Arguments:

   Returns:

      TRUE if everything is O.K
      FALSE if a write or a pended read failed
--*/

BOOL SMTP_CONNOUT::StartSession( void)
{
    HRESULT hr = S_OK;
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::StartSession( void)");

    _ASSERT(IsValid());

    //We do not do s restart if the connection is a tunr connection
    if (!m_pmszTurnList || !m_szCurrentTURNDomain) {
        if (m_pDnsRec->pMailMsgObj) {
            fRet = ReStartSession();
            TraceFunctLeaveEx((LPARAM) this);
            return fRet;
        }
    }

    //
    // We are either not doing SSL or are done establishing an SSL session.
    // Lets do the real work of starting a session with a remote SMTP server.
    //

    m_IMsgFileHandle = NULL;
    m_IMsgDotStuffedFileHandle = NULL;

    //get the next object to send
    //This is in loop because - we might have to pickup a new connection in case
    //we are handling a TURN list
    while (1) {
        // we can't call into GetNextMessage if we are on a TURN-only
        // connection.  if we did and a message queued up between the
        // last time we were in StartSession and now then we would
        // get back into the waitforconnect state, which would be really
        // bad.  so if we see the m_Flags set to TURN_ONLY_OPTION then we
        // know that this is an empty TURN and we just pretend that there
        // is no message to pick up.
        if (!(m_Flags & TURN_ONLY_OPTION)) {
            hr = m_pISMTPConnection->GetNextMessage(&m_pIMsg, (DWORD **) &m_AdvContext, &m_NumRcpts, &m_RcptIndexList);
        } else {
            m_pIMsg = NULL;
            hr = HRESULT_FROM_WIN32(ERROR_EMPTY);
        }
        if(FAILED(hr) || (m_pIMsg == NULL))
        {
            m_fCanTurn = FALSE;

            if (m_pmszTurnList && m_szCurrentTURNDomain) {
                //We have valid TURN list - Try and get the connetion for next domain to TURN
                if (GetNextTURNConnection()) {
                    //We loop back if we got a valid connection. Otherwise we drop thru
                    if (m_pISMTPConnection)
                        continue;
                } else {    //some error happened
                    TraceFunctLeaveEx((LPARAM) this);
                    return FALSE;
                }
            }

            if (m_MsgOptions & DOMAIN_INFO_SEND_TURN) {
                if (m_HeloSent || m_EhloSent) {
                    // we will fall into this if we have already sent
                    // the helo
                    FormatSmtpMessage(FSM_LOG_ALL, "TURN\r\n");

                    m_cbReceived = 0;
                    m_cbParsable = 0;
                    m_pmszTurnList = NULL;
                    m_szCurrentTURNDomain = NULL;

                    SendSmtpResponse();
                    SetNextState (&SMTP_CONNOUT::DoTURNCommand);
                    TraceFunctLeaveEx((LPARAM) this);
                    return TRUE;
                } else {
                    // we fall into this if we are sending TURN on an
                    // otherwise empty connection.  At this point we have
                    // not yet sent EHLO, so it is not safe to send TURN.
                    m_Flags |= TURN_ONLY_OPTION;
                    return GoToWaitForConnectResponseState();
                }
            } else if ((m_MsgOptions & DOMAIN_INFO_SEND_ETRN) &&
                       (m_NextState == NULL) &&
                       !IsOptionSet(ETRN_SENT)) {
                m_Flags |= ETRN_ONLY_OPTION;
                return GoToWaitForConnectResponseState();
            } else if (!(m_EhloSent)) {
                // This is an empty connection
                m_MsgOptions |= EMPTY_CONNECTION_OPTION;
                return GoToWaitForConnectResponseState();
            } else {
                //      1/11/99 - MikeSwa
                //There just happened to be no mail at this time.  Could
                //have been serviced by another connection, or just link
                //state detection
                if (HRESULT_FROM_WIN32(ERROR_EMPTY) == hr)
                    SetLastError(ERROR_EMPTY); //AQueue does not setlast error
                else
                {
                    SetDiagnosticInfo(hr, NULL, NULL);
                }

                DebugTrace((LPARAM) this,"Mailbag empty - returning FALSE");
                TraceFunctLeaveEx((LPARAM)this);
                return FALSE;

            }

        }
        else
        {
            //
            // The actual file may have been deleted from the queue. If so, we
            // need to ack the message and get the next one.
            //

            hr = m_pIMsg->QueryInterface(IID_IMailMsgBind, (void **)&m_pBindInterface);
            if (FAILED(hr))
            {
                MessageAck MsgAck;

                ErrorTrace((LPARAM)this, "Unable to Queryinterface message, going on to next one.");

                m_IMsgFileHandle = NULL;

                MsgAck.pvMsgContext = (DWORD *) m_AdvContext;
                MsgAck.pIMailMsgProperties = m_pIMsg;
                MsgAck.dwMsgStatus = MESSAGE_STATUS_RETRY;
                MsgAck.dwStatusCode = 0;

                m_pISMTPConnection->AckMessage(&MsgAck);
                SetDiagnosticInfo(AQUEUE_E_BIND_ERROR, NULL, NULL);

                m_pIMsg->Release();
                m_pIMsg = NULL;
                continue;
            }

            hr = m_pBindInterface->GetBinding(&m_IMsgFileHandle, NULL);
            if (SUCCEEDED(hr))
            {
                MSG_TRACK_INFO msgTrackInfo;
                ZeroMemory( &msgTrackInfo, sizeof( msgTrackInfo ) );
                msgTrackInfo.pszServerName = g_ComputerName;
                msgTrackInfo.dwEventId = MTE_BEGIN_OUTBOUND_TRANSFER;
                m_pInstance->WriteLog( &msgTrackInfo, m_pIMsg, NULL, NULL );
                break;
            }
            else if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {

                MessageAck MsgAck;

                DebugTrace(NULL,
                    "Message from queue has been deleted - ignoring it");

                m_pBindInterface->Release();
                m_IMsgFileHandle = NULL;

                MsgAck.pvMsgContext = (DWORD *) m_AdvContext;
                MsgAck.pIMailMsgProperties = m_pIMsg;
                MsgAck.dwMsgStatus = MESSAGE_STATUS_ALL_DELIVERED;
                MsgAck.dwStatusCode = 0;

                m_pISMTPConnection->AckMessage(&MsgAck);
                m_pIMsg->Release();
                m_pIMsg = NULL;

            }
            else
            {
                ASSERT(FAILED(hr));
                MessageAck MsgAck;

                ErrorTrace((LPARAM)this, "Unable to Bind message, going on to next one.");

                m_pBindInterface->Release();
                m_IMsgFileHandle = NULL;

                MsgAck.pvMsgContext = (DWORD *) m_AdvContext;
                MsgAck.pIMailMsgProperties = m_pIMsg;
                MsgAck.dwMsgStatus = MESSAGE_STATUS_RETRY;
                MsgAck.dwStatusCode = 0;

                m_pISMTPConnection->AckMessage(&MsgAck);
                SetDiagnosticInfo(AQUEUE_E_BIND_ERROR, NULL, NULL);

                m_pIMsg->Release();
                m_pIMsg = NULL;
                continue;
            }
        }
    }

    // Bump both the remote and total recipient counters
    ADD_COUNTER (QuerySmtpInstance(), NumRcptsRecvdRemote, m_NumRcpts);
    ADD_COUNTER (QuerySmtpInstance(), NumRcptsRecvd, m_NumRcpts);

    hr = m_pIMsg->QueryInterface(IID_IMailMsgRecipients, (void **) &m_pIMsgRecips);
    if (FAILED(hr)) {
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }


    m_FirstPipelinedAddress = 0;

    //Nk** I moved this here from PerRcptEvent
    m_NextAddress = 0;


    //if m_NextState is NULL, this is the
    //first time this routine has been called
    //as a result of a connection.  If m_NextState
    //is not NULL, this means we just finished
    //sending mail and we are about to send another
    //mail message
    if (m_NextState == NULL) {
        m_Error = NO_ERROR;
        DebugTrace((LPARAM) this,"start session called because of new connection");

        m_FirstPipelinedAddress = 0;

        SetNextState (&SMTP_CONNOUT::WaitForConnectResponse);

        m_LastClientIo = SMTP_CONNOUT::READIO;
        IncPendingIoCount();

        fRet = ReadFile(QueryMRcvBuffer(), m_cbMaxRecvBuffer);
        if (!fRet) {
            m_Error = GetLastError();
            DebugTrace((LPARAM) this, "SMTP_CONNOUT::StartSession - ReadFile failed with error %d", m_Error);
            m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
            DisconnectClient();
            DecPendingIoCount();
            SetLastError(m_Error);

            SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
        }
    } else {
        DebugTrace((LPARAM) this,"start session called because item was found in mailbag");

        m_cbReceived = 0;
        m_cbParsable = 0;
        m_OutputBufferSize = 0;
        m_Error = NO_ERROR;
        m_NumRcptSent = 0;
        m_FirstAddressinCurrentMail = 0;
        m_NumRcptSentSaved = 0;
        m_NumFailedAddrs = 0;
        m_SendAgain = FALSE;
        m_HaveDataResponse = FALSE;
        m_FirstPipelinedAddress = 0;

        m_FirstRcpt = FALSE;

        m_TransmitTailBuffer[0] = '.';
        m_TransmitTailBuffer[1] = '\r';
        m_TransmitTailBuffer[2] = '\n';

        m_TransmitBuffers.Head = NULL;
        m_TransmitBuffers.HeadLength = 0;
        m_TransmitBuffers.Tail = m_TransmitTailBuffer;
        m_TransmitBuffers.TailLength = 3;

        //send a reset
        m_fNativeHandlerFired    = FALSE;
        m_RsetReasonCode = BETWEEN_MSG;
        fRet = DoRSETCommand(NULL, 0, 0);
        if (!fRet) {
            m_Error = GetLastError();
            DebugTrace((LPARAM) this,"reset command failed in StartSession");
            TraceFunctLeaveEx((LPARAM) this);

            SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
            return FALSE;
        }

        // WaitForRSETResponse is smart and will raise the message
        // start event
        SetNextState (&SMTP_CONNOUT::WaitForRSETResponse);
    }

    TraceFunctLeaveEx((LPARAM) NULL);
    return fRet;
}

BOOL SMTP_CONNOUT::DecPendingIoCountEx(void)
{
    BOOL fRet = FALSE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::DecPendingIoCountEx");

    _ASSERT(IsValid());

    if (InterlockedDecrement( &m_cPendingIoCount ) == 0) {
        DebugTrace((LPARAM) this, "DecPendingIoCountEx deleting Smtp_Connout");
        fRet = TRUE;
        DisconnectClient();
        QuerySmtpInstance()->RemoveOutboundConnection(this);
        delete this;
    }

    TraceFunctLeaveEx((LPARAM) NULL);
    return fRet;
}


BOOL SMTP_CONNOUT::ConnectToNextIpAddress(void)
{
    BOOL fRet = TRUE;
    REMOTE_QUEUE * pRemoteQ = NULL;
    PSMTPDNS_RECS  pDnsRec = NULL;
    ISMTPConnection * pISMTPConnection = NULL;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::ConnectToNextIpAddress( void)");

    if (m_pmszTurnList && m_szCurrentTURNDomain) {
        ErrorTrace((LPARAM) this, "Failing ConnectToNextIpAddress because of TURN");
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    if (!m_fCanTurn) {
        ErrorTrace((LPARAM) this, "Failing ConnectToNextIpAddress because of m_fCanTurn");
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    if (m_pDnsRec == NULL) {
        ErrorTrace((LPARAM) this, "Failing ConnectToNextIpAddress becuase m_pDnsRec is NULL");
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    if (m_pDnsRec->StartRecord > m_pDnsRec->NumRecords) {
        ErrorTrace((LPARAM) this, "Failing ConnectToNextIpAddress because StartRecord > NumRecords");
        TraceFunctLeaveEx((LPARAM) NULL);
        return FALSE;
    }

    if (m_pDnsRec->StartRecord == m_pDnsRec->NumRecords) {
        if (IsListEmpty(&m_pDnsRec->DnsArray[m_pDnsRec->NumRecords - 1]->IpListHead)) {
            ErrorTrace((LPARAM) this, "Failing ConnectToNextIpAddress because list is empty");
            TraceFunctLeaveEx((LPARAM) NULL);
            return FALSE;
        }

        m_pDnsRec->StartRecord = m_pDnsRec->NumRecords - 1;
    } else if (IsListEmpty(&m_pDnsRec->DnsArray[m_pDnsRec->StartRecord]->IpListHead)) {
        m_pDnsRec->StartRecord++;

        if (m_pDnsRec->StartRecord > m_pDnsRec->NumRecords) {
            TraceFunctLeaveEx((LPARAM) NULL);
            return FALSE;
        }

        if (m_pDnsRec->StartRecord == m_pDnsRec->NumRecords) {
            if (IsListEmpty(&m_pDnsRec->DnsArray[m_pDnsRec->NumRecords - 1]->IpListHead)) {
                TraceFunctLeaveEx((LPARAM) NULL);
                return FALSE;
            }

            m_pDnsRec->StartRecord = m_pDnsRec->NumRecords - 1;
        }

    }

    if (m_NumRcptSentSaved) {
        UnMarkHandledRcpts();
    }

    m_pDnsRec->pMailMsgObj = (PVOID) m_pIMsg;
    m_pDnsRec->pAdvQContext = m_AdvContext;
    m_pDnsRec->pRcptIdxList = (PVOID) m_RcptIndexList;
    m_pDnsRec->dwNumRcpts = m_NumRcpts;

    pDnsRec = m_pDnsRec;
    m_pDnsRec = NULL;

    pISMTPConnection = m_pISMTPConnection;

    if (m_pIMsgRecips) {
        m_pIMsgRecips->Release();
        m_pIMsgRecips = NULL;
    }

    if (m_pBindInterface) {
        m_pBindInterface->ReleaseContext();
        m_pBindInterface->Release();
        m_pBindInterface = NULL;

        if( NULL != m_IMsgDotStuffedFileHandle )
        {
            ReleaseContext( m_IMsgDotStuffedFileHandle );
            m_IMsgDotStuffedFileHandle = NULL;
        }
    }

    pRemoteQ = (REMOTE_QUEUE *) QuerySmtpInstance()->QueryRemoteQObj();
    fRet = pRemoteQ->ReStartAsyncConnections(
                                        pDnsRec,
                                        pISMTPConnection,
                                        m_MsgOptions,
                                        m_pszSSLVerificationName);
    if (fRet) {
        m_pISMTPConnection = NULL;
        ErrorTrace((LPARAM)this, "RestartAsyncConnections failed.");

        //close the socket
        DisconnectClient();
    }

    TraceFunctLeaveEx((LPARAM) this);
    return fRet;
}

BOOL SMTP_CONNOUT::ReStartSession(void)
{
    BOOL fRet = TRUE;
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::ReStartSession( void)");

    DebugTrace((LPARAM) this,"restart session called because of new connection");

    m_cbReceived = 0;
    m_cbParsable = 0;
    m_OutputBufferSize = 0;
    m_Error = NO_ERROR;
    m_NumRcptSent = 0;
    m_NumRcptSentSaved = 0;
    m_NumFailedAddrs = 0;
    m_SendAgain = FALSE;
    m_HaveDataResponse = FALSE;
    m_FirstPipelinedAddress = 0;

    m_FirstRcpt = FALSE;

    m_TransmitTailBuffer[0] = '.';
    m_TransmitTailBuffer[1] = '\r';
    m_TransmitTailBuffer[2] = '\n';

    m_TransmitBuffers.Head = NULL;
    m_TransmitBuffers.HeadLength = 0;
    m_TransmitBuffers.Tail = m_TransmitTailBuffer;
    m_TransmitBuffers.TailLength = 3;

    SetNextState (&SMTP_CONNOUT::WaitForConnectResponse);

    m_pIMsg = (IMailMsgProperties *) m_pDnsRec->pMailMsgObj;
    m_AdvContext = m_pDnsRec->pAdvQContext;
    m_RcptIndexList = (DWORD *) m_pDnsRec->pRcptIdxList;
    m_NumRcpts = m_pDnsRec->dwNumRcpts;

    m_pDnsRec->pMailMsgObj = NULL;
    m_pDnsRec->pAdvQContext = NULL;
    m_pDnsRec->pRcptIdxList = NULL;
    m_pDnsRec->dwNumRcpts = 0;

    // Bump both the remote and total recipient counters
    ADD_COUNTER (QuerySmtpInstance(), NumRcptsRecvdRemote, m_NumRcpts);
    ADD_COUNTER (QuerySmtpInstance(), NumRcptsRecvd, m_NumRcpts);

    hr = m_pIMsg->QueryInterface(IID_IMailMsgRecipients, (void **) &m_pIMsgRecips);
    if (FAILED(hr)) {
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    hr = m_pIMsg->QueryInterface(IID_IMailMsgBind, (void **)&m_pBindInterface);
    if (FAILED(hr)) {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    hr = m_pBindInterface->GetBinding(&m_IMsgFileHandle, NULL);

    if(FAILED(hr))
    {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    DWORD fFoundEmbeddedCrlfDot = FALSE;
    DWORD fScanned = FALSE;

    m_LastClientIo = SMTP_CONNOUT::READIO;
    IncPendingIoCount();
    fRet = ReadFile(QueryMRcvBuffer(), m_cbMaxRecvBuffer);
    if (!fRet) {
        m_Error = GetLastError();
        DebugTrace((LPARAM) this, "SMTP_CONNOUT::StartSession - ReadFile failed with error %d", m_Error);
        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
        DisconnectClient();
        DecPendingIoCount();
        SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
        SetLastError(m_Error);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

/*++

    Name :
        SMTP_CONNOUT::CreateSmtpConnection

    Description:
       This is the static member function than is the only
       entity that is allowed to create an SMTP_CONNOUT
       class.  This class cannot be allocated on the stack.

    Arguments:

      sClient       socket for communicating with client

      psockAddrRemote pointer to address of the remote client
                ( the value should be copied).
      psockAddrLocal  pointer to address for the local card through
                  which the client came in.
      pAtqContext      pointer to ATQ Context used for AcceptEx'ed conn.
      pvInitialRequest pointer to void buffer containing the initial request
      cbInitialData    count of bytes of data read initially.
      fUseSSL          Indiates whether the connection is to use SSL


    Returns:

       A pointer to an SMTP_CONNOUT class or NULL
--*/
SMTP_CONNOUT * SMTP_CONNOUT::CreateSmtpConnection (
                                                  IN PSMTP_SERVER_INSTANCE pInstance,
                                                  IN SOCKET sClient,
                                                  IN const SOCKADDR_IN *  psockAddrRemote,
                                                  IN const SOCKADDR_IN *  psockAddrLocal /* = NULL */ ,
                                                  IN PATQ_CONTEXT         pAtqContext    /* = NULL */ ,
                                                  IN PVOID                pTurnList/* = NULL*/ ,
                                                  IN DWORD                cbInitialData  /* = 0    */,
                                                  IN DWORD                Options /* = 0 */,
                                                  IN LPSTR                pszSSLVerificationName)
{
    SMTP_CONNOUT * pSmtpObj;

    TraceFunctEnter("SMTP_CONNOUT::CreateSmtpConnection");

    pSmtpObj = new SMTP_CONNOUT (pInstance, sClient, psockAddrRemote, psockAddrLocal, pAtqContext,
                                 pTurnList, cbInitialData);
    if (pSmtpObj == NULL) {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        FatalTrace(NULL, "new SMTP_CONNOUT failed (err=%d)", GetLastError());
        TraceFunctLeave();
        return NULL;
    }

    if (!pSmtpObj->InitializeObject(Options, pszSSLVerificationName)) {
        ErrorTrace(NULL, "InitializeObject failed (err=%d)", GetLastError());
        delete pSmtpObj;
        TraceFunctLeave();
        return NULL;
    }


    if (pTurnList) {
        //Set the TURN domainlist
        pSmtpObj->SetTurnList((PTURN_DOMAIN_LIST)pTurnList);
    }

    TraceFunctLeave();
    return pSmtpObj;
}


/*++

    Name :
        SMTP_CONNOUT::SendSmtpResponse

    Description:
       This function sends data that was queued in the internal
       m_pOutputBuffer buffer

    Arguments:
         SyncSend - Flag that signifies sync or async send

    Returns:

      TRUE is the string was sent. False otherwise
--*/
BOOL SMTP_CONNOUT::SendSmtpResponse(BOOL SyncSend)
{
    BOOL RetStatus = TRUE;
    DWORD cbMessage = m_OutputBufferSize;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::SendSmtpResponse");

    //if m_OutputBufferSize > 0that means there is
    //something in the buffer, therefore, we will send it.

    if (m_OutputBufferSize) {
        //
        // If we are using SSL, encrypt the output buffer now. Note that
        // FormatSmtpMsg already left header space for the seal header.
        //
        if (m_SecurePort) {
            char *Buffer = &m_pOutputBuffer[m_encryptCtx.GetSealHeaderSize()];

            RetStatus = m_encryptCtx.SealMessage(
                                                (UCHAR *) Buffer,
                                                m_OutputBufferSize,
                                                (UCHAR *) m_pOutputBuffer,
                                                &cbMessage);
            if (!RetStatus)
            {
                ErrorTrace ((LPARAM)this, "Sealmessage failed");
                SetLastError(AQUEUE_E_SSL_ERROR);
            }
        }

        if (RetStatus) {
            RetStatus = CLIENT_CONNECTION::WriteFile(m_pOutputBuffer, cbMessage);
        }

        if (RetStatus) {
            ADD_BIGCOUNTER(QuerySmtpInstance(), BytesSentTotal, m_OutputBufferSize);
        } else {
            DebugTrace((LPARAM) this, "WriteFile failed with error %d", GetLastError());
        }

        m_OutputBufferSize = 0;
    }

    TraceFunctLeaveEx((LPARAM) this);

    return ( RetStatus );
}


/*++

    Name :
        SMTP_CONNOUT::FormatSmtpMessage( IN const char * Format, ...)

    Description:
        This function operates likes sprintf, printf, etc. It
        just places it's data in the output buffer.

    Arguments:
         Format - Data to place in the buffer

    Returns:


--*/
BOOL SMTP_CONNOUT::FormatSmtpMessage( FORMAT_SMTP_MESSAGE_LOGLEVEL eLogLevel, IN const char * Format, ...)
{
    int BytesWritten;
    va_list arglist;
    char *Buffer;
    DWORD AvailableBytes;

    DWORD HeaderOffset = (m_SecurePort ? m_encryptCtx.GetSealHeaderSize() : 0);
    DWORD SealOverhead = (m_SecurePort ?
                          (m_encryptCtx.GetSealHeaderSize() +
                           m_encryptCtx.GetSealTrailerSize()) : 0);

    Buffer = &m_pOutputBuffer[m_OutputBufferSize + HeaderOffset];

    AvailableBytes = m_cbMaxOutputBuffer - m_OutputBufferSize - SealOverhead;

    //if BytesWritten is < 0, that means there is no space
    //left in the buffer.  Therefore, we flush any pending
    //responses to make space.  Then we try to place the
    //information in the buffer again.  It should never
    //fail this time.
    va_start (arglist, Format);
    BytesWritten = _vsnprintf (Buffer, AvailableBytes, Format, arglist);

    if (BytesWritten < 0) {
        //flush any pending response
        SendSmtpResponse();
        _ASSERT (m_OutputBufferSize == 0);
        Buffer = &m_pOutputBuffer[HeaderOffset];
        AvailableBytes = m_cbMaxOutputBuffer - SealOverhead;
        BytesWritten = _vsnprintf (Buffer, AvailableBytes, Format, arglist);
        _ASSERT (BytesWritten > 0);
    }
    va_end(arglist);

    // log this transaction
    ProtocolLogCommand(Buffer, BytesWritten, QueryClientHostName(), eLogLevel);

    m_OutputBufferSize += (DWORD) BytesWritten;

    //m_OutputBufferSize += vsprintf (&m_OutputBuffer[m_OutputBufferSize], Format, arglist);

    return TRUE;
}


/*++

    Name :
        SMTP_CONNOUT::FormatBinaryBlob(IN PBYTE pbBlob, IN DWORD cbSize)

    Description:
        Places pbBlob of size cbSize into buffer

    Arguments:
        pbBlob - blob to place in the buffer
        cbSize - blob size

    Returns:
        BOOL

--*/
BOOL SMTP_CONNOUT::FormatBinaryBlob( IN PBYTE pbBlob, IN DWORD cbSize)
{
    char *Buffer;
    DWORD AvailableBytes;

    TraceQuietEnter( "SMTP_CONNOUT::FormatBinaryBlob");

    DWORD HeaderOffset = ( m_SecurePort ? m_encryptCtx.GetSealHeaderSize() : 0);
    DWORD SealOverhead = ( m_SecurePort ?
                          ( m_encryptCtx.GetSealHeaderSize() +
                           m_encryptCtx.GetSealTrailerSize()) : 0);

    Buffer = &m_pOutputBuffer[ m_OutputBufferSize + HeaderOffset];
    AvailableBytes = m_cbMaxOutputBuffer - m_OutputBufferSize - SealOverhead;

    while ( AvailableBytes < cbSize) {
        memcpy( Buffer, pbBlob, AvailableBytes);
        pbBlob += AvailableBytes;
        cbSize -= AvailableBytes;
        m_OutputBufferSize += AvailableBytes;
        SendSmtpResponse();
        _ASSERT ( m_OutputBufferSize == 0);
        Buffer = &m_pOutputBuffer[ HeaderOffset];
        AvailableBytes = m_cbMaxOutputBuffer - SealOverhead;
    }

    memcpy( Buffer, pbBlob, cbSize);
    m_OutputBufferSize += cbSize;

    return TRUE;
}


/*++

    Name :
        SMTP_CONNOUT::ProcessWriteIO

    Description:
         Handles an async write completion event.

    Arguments:
         InputBufferLen - Number of bytes that was written
         dwCompletionStatus -Holds error code from ATQ, if any
         lpo -  Pointer to overlapped structure

    Returns:
      TRUE if the object should continue to survive
      FALSE if the object should be deleted
--*/
BOOL SMTP_CONNOUT::ProcessWriteIO ( IN DWORD InputBufferLen, IN DWORD dwCompletionStatus, IN OUT OVERLAPPED * lpo)
{
    CBuffer* pBuffer;

    TraceQuietEnter("SMTP_CONNOUT::ProcessWriteIO");

    _ASSERT(IsValid());
    _ASSERT(lpo);
    pBuffer = ((DIRNOT_OVERLAPPED*)lpo)->pBuffer;


    //
    // check for partial completions or errors
    //
    if ( pBuffer->GetSize() != InputBufferLen || dwCompletionStatus != NO_ERROR ) {
        ErrorTrace( (LPARAM)this,
                    "WriteFile error: %d, bytes %d, expected: %d, lpo: 0x%08X",
                    dwCompletionStatus,
                    InputBufferLen,
                    pBuffer->GetSize(),
                    lpo );

        m_Error = dwCompletionStatus;
        SetDiagnosticInfo(HRESULT_FROM_WIN32(dwCompletionStatus), NULL, NULL);

        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
        DisconnectClient();
        return ( FALSE );
    } else {
        DebugTrace( (LPARAM)this,
                    "WriteFile complete. bytes %d, lpo: 0x%08X",
                    InputBufferLen, lpo );
    }

    //
    // free up IO buffer
    //
    delete  pBuffer;

    //
    // increment only after write completes
    //
    ADD_BIGCOUNTER(QuerySmtpInstance(), BytesSentMsg, InputBufferLen);
    ADD_BIGCOUNTER(QuerySmtpInstance(), BytesSentTotal, InputBufferLen);

    DebugTrace( (LPARAM)this, "m_bComplete: %s",
                m_bComplete ? "TRUE" : "FALSE" );

    return ( TRUE );
}

/*++

    Name :
        SMTP_CONNOUT::ProcessTransmitFileIO

    Description:
         processes the return from TransmitFile.
         Right not it just posts a read.

    Arguments:

    Returns:

      TRUE
--*/

BOOL SMTP_CONNOUT::ProcessTransmitFileIO ( IN DWORD InputBufferLen, IN DWORD dwCompletionStatus, IN OUT OVERLAPPED * lpo)
{
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::ProcessTransmitFileIO");

    _ASSERT(IsValid());

    //we need to set this outside of the if statement,
    //because we will always have a read pended
    m_LastClientIo = SMTP_CONNOUT::READIO;

    if (dwCompletionStatus != NO_ERROR) {
        m_Error = dwCompletionStatus;
        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
        DebugTrace((LPARAM) this, "TranmitFile in ProcessTransmitFileIO failed with error %d !!!!", dwCompletionStatus);
        SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
        DisconnectClient();
        TraceFunctLeave();
        return FALSE;
    }

    ADD_BIGCOUNTER(QuerySmtpInstance(), BytesSentMsg, InputBufferLen);
    ADD_BIGCOUNTER(QuerySmtpInstance(), BytesSentTotal, InputBufferLen);

    //pend an IO to pickup the "250 XXXX queued for delivery response"
    IncPendingIoCount();
    fRet = ReadFile(QueryMRcvBuffer(), m_cbMaxRecvBuffer);
    if (!fRet) {
        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
        m_Error = GetLastError();
        DebugTrace((LPARAM) this, "ReadFile in ProcessTransmitFileIO failed with error %d !!!!", m_Error);
        SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
        DisconnectClient();
        DecPendingIoCount();
    }

    TraceFunctLeave();
    return fRet;
}

/*++

    Name :
        SMTP_CONNOUT::WaitForConnectResponse

    Description:
         This function gets called when the SMTP
         server sends it's opening response

    Arguments:
        InputLine - Buffer containing opening response
        ParameterSize - Size of opening response

    Returns:

      TRUE if Object is not to be destroyed
      FALSE if Object is to be destroyed
--*/
BOOL SMTP_CONNOUT::WaitForConnectResponse(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    char * pszSearch = NULL;
    DWORD IntermediateSize = 0;
    BOOL IsNextLine;
    DWORD    Error;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::WaitForConnectResponse");

    //get rid of all continuation lines
    while ((pszSearch = IsLineComplete(InputLine, ParameterSize))) {
        *pszSearch = '\0';

        //check to see if there is a continuation line
        IsNextLine = (InputLine[3] == '-');

        //calculate the length of the line, with the CRLF
        IntermediateSize = (DWORD)((pszSearch - InputLine) + 2);
        ShrinkBuffer(
                    pszSearch + 2,
                    ParameterSize - IntermediateSize + UndecryptedTailSize);
        ParameterSize -= IntermediateSize;
    }

    //If ParameterSize is > 0 but pszSearch == NULL, this means
    //there is data in the buffer, but it does not have a CRLF
    //to delimit it, therefore, we need more data to continue.
    //set m_cbReceived equal to where in our input buffer we
    //should pend another read and then return TRUE to pend
    //that read.

    if (ParameterSize != 0) {
        //if we need more data, move the remaining data to the
        //front of the buffer

        MoveMemory(
                  (void *)QueryMRcvBuffer(),
                  InputLine,
                  ParameterSize + UndecryptedTailSize);
        m_cbParsable = ParameterSize;
        m_cbReceived = ParameterSize + UndecryptedTailSize;
        return (TRUE);
    } else if (IsNextLine) {
        m_cbParsable = 0;
        m_cbReceived = UndecryptedTailSize;
        return (TRUE);
    } else {
        BOOL    fResult = TRUE;

        //we got a line that is not a continuation line.
        // Process the connect response
        switch (InputLine [0]) {
        case SMTP_COMPLETE_FAILURE:
            SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, NULL, NULL);
            DisconnectClient();
            InputLine [3] = '\0';
            Error = atoi (InputLine);
            InputLine [3] = ' ';
            SaveToErrorFile(InputLine, ParameterSize);
            SaveToErrorFile("\r\n", 2);
            fResult = FALSE;
            break;

        case SMTP_COMPLETE_SUCCESS: {
            //If the domain has been specified to use only HELO then we
            //fake it such that EHLO has been already sentand failed
            if (m_MsgOptions & DOMAIN_INFO_USE_HELO )
                m_EhloFailed = TRUE;

            // copy the domain name from the ehlo banner
            strncpy(m_ConnectedDomain, &InputLine[4], sizeof(m_ConnectedDomain)-1);
            // trunc at the first space
            char *pszSpace = strchr(m_ConnectedDomain, ' ');
            if (pszSpace) *pszSpace = 0;

            fResult = DoSessionStartEvent(InputLine, ParameterSize, UndecryptedTailSize);
            break;
        }

        default:
            DebugTrace( (LPARAM) this,
                        "SMTP_CONNOUT::WaitForConnectResponse executing quit command err = %c%c%c",
                        InputLine [0],
                        InputLine [1],
                        InputLine [2]);
            fResult = DoCompletedMessage(InputLine, ParameterSize, UndecryptedTailSize);
            break;
        }

        TraceFunctLeaveEx((LPARAM)this);
        return fResult;
    }
}


/*++

    Name :
        SMTP_CONNOUT::ProcessReadIO

    Description:
        This function gets a buffer from ATQ, parses the buffer to
        find out what command the client sent, then executes that
        command.

    Arguments:
         InputBufferLen - Number of bytes that was written
         dwCompletionStatus -Holds error code from ATQ, if any
         lpo -  Pointer to overlapped structure

    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.
--*/
BOOL SMTP_CONNOUT::ProcessReadIO ( IN DWORD InputBufferLen, IN DWORD dwCompletionStatus, IN OUT OVERLAPPED * lpo)
{
    BOOL fReturn = TRUE;
    char * InputLine = NULL;
    char * pszSearch = NULL;
    DWORD IntermediateSize = 0;
    DWORD UndecryptedTailSize = 0;
    PMFI  PreviousState = NULL;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::ProcessReadIO");

    //make sure the next state is not NULL
    _ASSERT(m_NextState != NULL || m_fNegotiatingSSL);
    _ASSERT(IsValid());

    //get a pointer to our buffer
    InputLine = (char *) QueryMRcvBuffer();

    //add up the number of bytes we received thus far
    m_cbReceived += InputBufferLen;

    ADD_BIGCOUNTER(QuerySmtpInstance(), BytesRcvdTotal, InputBufferLen);

    //if we are in the middle of negotiating a SSL session, handle it now.
    if (m_fNegotiatingSSL) {

        fReturn = DoSSLNegotiation(QueryMRcvBuffer(),InputBufferLen, 0);

        if (!fReturn) {
            m_Error = GetLastError();
            m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
            DisconnectClient();
        }

        return ( fReturn );
    }

    //if we are using the secure port, decrypt the input buffer now.
    if (m_SecurePort) {

        fReturn = DecryptInputBuffer();

        if (!fReturn) {
            m_Error = GetLastError();
            SetDiagnosticInfo(AQUEUE_E_SSL_ERROR, NULL, NULL);
            return ( fReturn );
        }
    } else {
        m_cbParsable = m_cbReceived;
    }


    //we only process lines that have CRLFs at the end, so if
    //we don't find the CRLF pair, pend another read.  Note
    //that we start at the end of the buffer looking for the
    //CRLF pair.  We just need to know if atleast one line
    //has a CRLF to continue.
    if ((pszSearch = IsLineCompleteBW(InputLine,m_cbParsable, m_cbMaxRecvBuffer)) == NULL) {
        if (m_cbReceived >= m_cbMaxRecvBuffer)
            m_cbReceived = 0;

        IncPendingIoCount();
        fReturn = ReadFile(QueryMRcvBuffer() + m_cbReceived, m_cbMaxRecvBuffer - m_cbReceived);
        if (!fReturn) {
            m_Error = GetLastError();
            DebugTrace((LPARAM) this, "SMTP_CONNOUT::ProcessReadIO - ReadFile # 1 failed with error %d", m_Error);
            m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
            SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
            DisconnectClient();
            DecPendingIoCount();
        }

        TraceFunctLeaveEx((LPARAM)this);
        return fReturn;
    }

    //save the number of bytes that we received,
    //so we can pass it to the function call below.
    //we set m_cbReceived = 0, because other functions
    //will set it the offset in the buffer where we
    //should pend the next read.
    IntermediateSize = m_cbParsable;
    UndecryptedTailSize = m_cbReceived - m_cbParsable;
    m_cbParsable = 0;
    m_cbReceived = 0;

    //save the previous state
    PreviousState = m_NextState;

    ProtocolLogResponse(InputLine, IntermediateSize, QueryClientHostName());

    //execute the next state
    fReturn = (this->*m_NextState)(InputLine, IntermediateSize, UndecryptedTailSize);
    if (fReturn) {
        //if we are in STARTTLS state, don't pend a read since
        //DoSSLNegotiation would have pended a read
        if ((m_NextState == &SMTP_CONNOUT::DoSTARTTLSCommand) &&
            (m_TlsState == SSL_NEG)) {
            DebugTrace((LPARAM) this, "SMTP_CONNOUT::ProcessReadIO - leaving because we are in middle of SSL negotiation");
            TraceFunctLeaveEx((LPARAM)this);
            return fReturn;
        }

        //do't pend a read if the previous state was
        //DoDataCommandEx.  We want either the transmitfile
        //or the read to fail.  Not both.  Later, we will fix
        //it right for both to complete concurrently.
        if (PreviousState == &SMTP_CONNOUT::DoDATACommandEx) {
            DebugTrace((LPARAM) this, "SMTP_CONNOUT::ProcessReadIO - leaving because we did a transmitfile");
            TraceFunctLeaveEx((LPARAM)this);
            return fReturn;
        } else if (m_fUseBDAT) {
            //We also don't want to pend a read if we did BDAT processing
            //It is a special case, because of the fact that DoBDATCommand synchronously
            //calls DoDATACommandEx without pending a read. So we never come thru here and get
            //chance to set PreviousState = DoDATACommandEx
            //So I have to hack it

            if ((m_NextState == &SMTP_CONNOUT::DoContentResponse) ||
                (m_SendAgain && (m_NextState == &SMTP_CONNOUT::DoMessageStartEvent))) {
                DebugTrace((LPARAM) this, "SMTP_CONNOUT::ProcessReadIO - leaving because we did a transmitfile");
                TraceFunctLeaveEx((LPARAM)this);
                return fReturn;
            }
        }

        if (m_cbReceived >= m_cbMaxRecvBuffer)
            m_cbReceived = 0;

        IncPendingIoCount();
        fReturn = ReadFile(QueryMRcvBuffer() + m_cbReceived, m_cbMaxRecvBuffer - m_cbReceived);
        if (!fReturn) {
            m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
            m_Error = GetLastError();
            SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
            DisconnectClient();
            DecPendingIoCount();
            DebugTrace((LPARAM) this, "SMTP_CONNOUT::ProcessReadIO - ReadFile # 2 failed with error %d", m_Error);
        }

    }

    TraceFunctLeaveEx((LPARAM)this);
    return fReturn;
}

/*++

    Name :
        SMTP_CONNOUT::ProcessFileIO

    Description:
        Handles completion of an async read issued against a message file by
        MessageReadFile

    Arguments:
        cbRead              count of bytes read
        dwCompletionStatus  Error code for IO operation
        lpo                 Overlapped structure

    Returns:
        TRUE if connection should stay open
        FALSE if this object should be deleted

--*/
BOOL SMTP_CONNOUT::ProcessFileIO(
                                IN      DWORD       BytesRead,
                                IN      DWORD       dwCompletionStatus,
                                IN OUT  OVERLAPPED  *lpo
                                )
{
    CBuffer* pBuffer;

    TraceFunctEnterEx((LPARAM)this, "SMTP_CONNOUT::ProcessFileIO");

    _ASSERT(lpo);
    pBuffer = ((DIRNOT_OVERLAPPED*)lpo)->pBuffer;

    //
    // check for partial completions or errors
    //
    if ( BytesRead != pBuffer->GetSize() || dwCompletionStatus != NO_ERROR ) {
        ErrorTrace( (LPARAM)this,
                    "Message ReadFile error: %d, bytes %d, expected %d",
                    dwCompletionStatus,
                    BytesRead,
                    pBuffer->GetSize() );

        m_Error = dwCompletionStatus;
        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
        DisconnectClient();
        SetDiagnosticInfo(HRESULT_FROM_WIN32(m_dwConnectionStatus), NULL, NULL);
        return ( FALSE );
    } else {
        DebugTrace( (LPARAM)this,
                    "ReadFile complete. bytes %d, lpo: 0x%08X",
                    BytesRead, lpo );
    }

    m_bComplete = (m_dwFileOffset + BytesRead) >= m_FileSize;

    m_dwFileOffset += BytesRead;

    //
    // If anything to write to the client
    //
    if ( BytesRead > 0 ) {
        //
        // set buffer specific IO state
        //
        pBuffer->SetIoState( CLIENT_WRITE );
        pBuffer->SetSize( BytesRead );

        ZeroMemory( (void*)&pBuffer->m_Overlapped.SeoOverlapped, sizeof(OVERLAPPED) );

        DebugTrace( (LPARAM)this, "WriteFile 0x%08X, len: %d, LPO: 0x%08X",
                    pBuffer->GetData(),
                    BytesRead,
                    &pBuffer->m_Overlapped.SeoOverlapped.Overlapped );

        //
        // If we're on the SSL port, encrypt the data.
        //
        if ( m_SecurePort ) {
            //
            // Seal the message in place as we've already reserved room
            // for both the header and trailer
            //
            if ( m_encryptCtx.SealMessage(  pBuffer->GetData() +
                                            m_encryptCtx.GetSealHeaderSize(),
                                            BytesRead,
                                            pBuffer->GetData(),
                                            &BytesRead ) == FALSE ) {
                m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
                m_Error = GetLastError();
                ErrorTrace( (LPARAM)this, "SealMessage failed. err: %d", m_Error);
                SetDiagnosticInfo(AQUEUE_E_SSL_ERROR, NULL, NULL);
                DisconnectClient();
            } else {
                //
                // adjust the byte count to include header and trailer
                //
                _ASSERT(BytesRead == pBuffer->GetSize() +
                        m_encryptCtx.GetSealHeaderSize() +
                        m_encryptCtx.GetSealTrailerSize() );

                pBuffer->SetSize( BytesRead );
            }
        }

        IncPendingIoCount();
        if ( WriteFile( pBuffer->GetData(),
                        BytesRead,
                        (LPOVERLAPPED)&pBuffer->m_Overlapped ) == FALSE ) {
            m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
            m_Error = GetLastError();
            //
            // reset the bytes read so we drop out
            //
            BytesRead = 0;
            ErrorTrace( (LPARAM)this, "WriteFile failed (err=%d)", m_Error );
            delete  pBuffer;

            SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);

            //
            // treat as fatal error
            //
            DisconnectClient( );
            //
            // cleanup after write failure
            //
            DecPendingIoCount();

        }
    }

    if ( m_bComplete ) {
        BOOL fRet = TRUE;

        //FreeAtqFileContext();

        //We do not have any trailers to write if we are processing BDAT
        //
        if (!m_fUseBDAT) {
            if (m_SecurePort) {
                //Nimishk : Is this right ***
                m_OutputBufferSize = m_cbMaxOutputBuffer;

                fRet = m_encryptCtx.SealMessage(
                                               (LPBYTE) m_TransmitBuffers.Tail,
                                               m_TransmitBuffers.TailLength,
                                               (LPBYTE) m_pOutputBuffer,
                                               &m_OutputBufferSize);

                if (fRet)
                    fRet = WriteFile(m_pOutputBuffer, m_OutputBufferSize);
            } else {
                fRet = WriteFile(
                                (LPVOID)m_TransmitBuffers.Tail,
                                m_TransmitBuffers.TailLength );
            }
        }
        m_OutputBufferSize = 0;

        IncPendingIoCount();
        if (fRet) {
            //pend an IO to pickup the "250 XXXX queued for delivery response"
            m_LastClientIo = SMTP_CONNOUT::READIO;
            fRet = ReadFile(QueryMRcvBuffer(), m_cbMaxRecvBuffer);
        }
        if (!fRet) {
            m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
            m_Error = GetLastError();
            DebugTrace((LPARAM) this, "Error %d sending tail or posting read", m_Error);
            SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
            DisconnectClient();
            DecPendingIoCount();
        }
        return ( fRet );
    } else {
        return (MessageReadFile());
    }
}

/*++

    Name :
        SMTP_CONNOUT::ProcessClient

    Description:

       Main function for this class. Processes the connection based
        on current state of the connection.
       It may invoke or be invoked by ATQ functions.

    Arguments:

       cbWritten          count of bytes written

       dwCompletionStatus Error Code for last IO operation

       lpo                Overlapped stucture

    Returns:

       TRUE when processing is incomplete.
       FALSE when the connection is completely processed and this
        object may be deleted.

--*/
BOOL SMTP_CONNOUT::ProcessClient( IN DWORD InputBufferLen, IN DWORD dwCompletionStatus, IN OUT OVERLAPPED * lpo)
{
    BOOL RetStatus;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::ProcessClient");

    IncThreadCount();

    //if lpo == NULL, then we timed out. Send an appropriate message
    //then close the connection
    if ((lpo == NULL) && (dwCompletionStatus == ERROR_SEM_TIMEOUT)) {
        //
        // fake a pending IO as we'll dec the overall count in the
        // exit processing of this routine needs to happen before
        // DisconnectClient else completing threads could tear us down
        //

        SetDiagnosticInfo(HRESULT_FROM_WIN32(ERROR_SEM_TIMEOUT), NULL, NULL);
        IncPendingIoCount();

        m_Error = dwCompletionStatus;
        DebugTrace((LPARAM) this, "SMTP_CONNOUT::ProcessClient: -  Timing out");
        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;

        DisconnectClient();
    } else if ((InputBufferLen == 0) || (dwCompletionStatus != NO_ERROR)) {
        //if InputBufferLen == 0, then the connection was closed.
        if (m_Error == NO_ERROR)
            m_Error = ERROR_BROKEN_PIPE;

        SetDiagnosticInfo(AQUEUE_E_CONNECTION_DROPPED, NULL, NULL);

        //
        // If the lpo points to an IO buffer allocated for SSL IO, delete it
        //

        if (lpo != NULL &&
            lpo != &m_Overlapped &&
            lpo != &QueryAtqContext()->Overlapped) {
            CBuffer* pBuffer = ((DIRNOT_OVERLAPPED*)lpo)->pBuffer;

            delete pBuffer;
        }

        DebugTrace((LPARAM) this, "SMTP_CONNOUT::ProcessClient: InputBufferLen = %d dwCompletionStatus = %d  - Closing connection", InputBufferLen, dwCompletionStatus);
        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
        DisconnectClient();
    } else if (lpo == &m_Overlapped || lpo == &QueryAtqContext()->Overlapped
               || lpo == (OVERLAPPED *) &m_SeoOverlapped) {

        switch (m_LastClientIo) {
        case SMTP_CONNOUT::READIO:
            RetStatus = ProcessReadIO (InputBufferLen, dwCompletionStatus, lpo);
            break;
        case SMTP_CONNOUT::TRANSFILEIO:
            RetStatus = ProcessTransmitFileIO (InputBufferLen, dwCompletionStatus, lpo);
            break;
        default:
            _ASSERT (FALSE);
            RetStatus = FALSE;
            break;
        }
    } else {
        //
        // This lpo belongs to a CBuffer allocated for message transfers using
        // async reads and writes.
        //

        CBuffer* pBuffer = ((DIRNOT_OVERLAPPED*)lpo)->pBuffer;

        if (pBuffer->GetIoState() == MESSAGE_READ) {
            RetStatus = ProcessFileIO(InputBufferLen, dwCompletionStatus, lpo);
        } else {
            _ASSERT( pBuffer->GetIoState() == CLIENT_WRITE );
            RetStatus = ProcessWriteIO(InputBufferLen, dwCompletionStatus, lpo);
        }

    }

    DecThreadCount();

    //
    // decrement the overall pending IO count for this session
    // tracing and ASSERTs if we're going down.
    //
    if ( DecPendingIoCount() == 0 ) {
        if (m_dwConnectionStatus == CONNECTION_STATUS_DROPPED) {
            if (!QuerySmtpInstance()->IsShuttingDown())
                ConnectToNextIpAddress();
        }

        DebugTrace( (LPARAM)this,"Num Threads: %d",m_cActiveThreads);
        _ASSERT( m_cActiveThreads == 0 );
        m_Active = FALSE;
        RetStatus = FALSE;
    } else {
        DebugTrace( (LPARAM)this,"SMTP_CONNOUT::ProcessClient Pending IOs: %d",m_cPendingIoCount);
        DebugTrace( (LPARAM)this,"SMTP_CONNOUT::ProcessClient Num Threads: %d",m_cActiveThreads);
        RetStatus = TRUE;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return RetStatus;
}

/*++

    Name :
        SMTP_CONNOUT::DoSSLNegotiation

    Description:
        Does the SSL Handshake with a remote SMTP server.

    Arguments:

    Returns:
        TRUE if successful so far
        FALSE if this object should be deleted

--*/

BOOL SMTP_CONNOUT::DoSSLNegotiation(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    BOOL fRet = TRUE, fMore, fPostRead;
    DWORD dwErr;
    HRESULT hr = S_OK;
    ULONG cbExtra = 0;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::DoSSLNegotiations");

    m_OutputBufferSize = m_cbMaxOutputBuffer;

    dwErr = m_encryptCtx.Converse(
                                 QueryMRcvBuffer(),
                                 m_cbReceived,
                                 (LPBYTE) m_pOutputBuffer,
                                 &m_OutputBufferSize,
                                 &fMore,
                                 (LPSTR) QueryLocalHostName(),
                                 (LPSTR) QueryLocalPortName(),
                                 (LPVOID) QuerySmtpInstance(),
                                 QuerySmtpInstance()->QueryInstanceId(),
                                 &cbExtra
                                 );

    if (dwErr == NO_ERROR) {

        //
        // reset the receive buffer
        //
        if (cbExtra)
            MoveMemory (QueryMRcvBuffer(), QueryMRcvBuffer() + (m_cbReceived - cbExtra), cbExtra);
        m_cbReceived = cbExtra;

        if (m_OutputBufferSize != 0) {
            // Send the last negotiation blob to the server and start with Encrypting.
            // Reset the output buffer size
            fRet = WriteFile(m_pOutputBuffer, m_OutputBufferSize);
            m_OutputBufferSize = 0;
        }

        if (fMore) {
            fPostRead = TRUE;
        } else {
            m_fNegotiatingSSL = FALSE;

            if (ValidateSSLCertificate ()) {
                m_TlsState = CHANNEL_SECURE;

                //If we negotiated because of STARTTLS, we need to send EHLO and get the
                //options all over again. According to jump_thru_hoops draft
                if (IsOptionSet(STARTTLS)) {
                    //Do ehlo again - this to get the response
                    _ASSERT(m_EhloFailed == FALSE);
                    char szInput[25];
                    strcpy(szInput,"220 OK");
                    fRet = DoSessionStartEvent(szInput, strlen(szInput), 0);

                } else if (!(m_MsgOptions & KNOWN_AUTH_FLAGS)) {
                    if (m_MsgOptions & EMPTY_CONNECTION_OPTION) {
                        fRet = DoSessionEndEvent(InputLine, ParameterSize, UndecryptedTailSize);
                    } else {
                        fRet = DoMessageStartEvent(InputLine, ParameterSize, UndecryptedTailSize);
                    }
                } else {
                    fRet = DoSASLCommand(InputLine, ParameterSize, UndecryptedTailSize);
                }

                fPostRead = fRet;
            } else {
                fPostRead = fRet = FALSE;
                //Fill in the response context buffer so as to generate the right response
                // Get the error code
                m_ResponseContext.m_dwSmtpStatus = SMTP_RESP_BAD_CMD;
                hr = m_ResponseContext.m_cabResponse.Append(
                                                           (char *)SMTP_REMOTE_HOST_REJECTED_SSL,
                                                           strlen(SMTP_REMOTE_HOST_REJECTED_SSL),
                                                           NULL);
            }
        }

        if (fPostRead) {
            //
            // The negotiation is going well so far, but there is still more
            // negotiation to do. So post a read to receive the next leg of
            // the negotiation.
            //

            DebugTrace((LPARAM) this,"StartSession negotiating SSL");

            IncPendingIoCount();
            m_LastClientIo = SMTP_CONNOUT::READIO;
            fRet = ReadFile(QueryMRcvBuffer() + cbExtra, m_cbMaxRecvBuffer - cbExtra);
            if (!fRet) {
                dwErr = GetLastError();
                DebugTrace((LPARAM) this, "SMTP_CONNOUT::DoSSLNegotiation failed %d", m_Error);
                DecPendingIoCount();
                SetLastError(dwErr);
                SetDiagnosticInfo(HRESULT_FROM_WIN32(dwErr), NULL, NULL);
                //Fill in the response context buffer so as to generate the right response
                // Get the error code
            }
        }

    } else {
        fRet = FALSE;
        SetLastError(ERROR_NO_SECURITY_ON_OBJECT);
        SetDiagnosticInfo(AQUEUE_E_TLS_NOT_SUPPORTED_ERROR, NULL, NULL);
    }

    TraceFunctLeaveEx((LPARAM) this);
    return ( fRet );
}

//----------------------------------------------------------------------------------
//  Description:
//      Check to see if the SSL cert is valid:
//       (1) Always check if it has expired.
//       (2) If configured, check if the issuer is trusted.
//       (3) If configured, check if the subject matches who we are sending to. This
//           is not simply the server-fqdn we are connected to. Since the server-fqdn
//           may have been obtained via DNS (through MX or CNAME indirection), and
//           since DNS is an insecure protocol, we cannot trust that for the subject.
//           Instead we will use the domain we were passed in prior to DNS... the
//           one passed into the REMOTE_QUEUE. This domain name is passed into
//           SMTP_CONNOUT when it is created as m_pszSSLVerificationDomain. We will
//           do some wildcard matching as well if the certificate subject has the
//           '*' character in it (see simssl.cpp). m_pszSSLVerificationName may be
//           NULL if there is no target hostname --- such as in the case of a literal
//           IP address. In this case, subject verification is skipped.
//  Returns:
//      TRUE - success, certificate verified
//      FALSE - failure, stick queue into retry
//----------------------------------------------------------------------------------
BOOL SMTP_CONNOUT::ValidateSSLCertificate ()
{
    BOOL fRet = FALSE;
    DWORD dwAQDiagnostic = 0;

    TraceFunctEnterEx ((LPARAM) this, "SMTP_CONNECTION::ValidateCertificate");

    fRet = m_encryptCtx.CheckCertificateExpired();
    if (!fRet) {
        ErrorTrace ((LPARAM) this, "SSL Certificate Expired");
        dwAQDiagnostic = AQUEUE_E_SSL_CERT_EXPIRED;
        goto Exit;
    }
    
    if (m_pInstance->RequiresSSLCertVerifyIssuer()) {

        DebugTrace ((LPARAM) this, "Verifying certificate issuing authority");

        //
        //  Failure in these checks could occur due to temporary conditions (like
        //  out of memory). So the AQueue diagnostic is not 100% accurate, but it's
        //  OK as we don't NDR message. Anyway we DID fail during cert validation.
        //

        fRet = m_encryptCtx.CheckCertificateTrust();
        if (!fRet) {
            ErrorTrace ((LPARAM) this, "SSL Certificate trust verification failure");
            dwAQDiagnostic = AQUEUE_E_SSL_CERT_ISSUER_UNTRUSTED;
            goto Exit;
        }
    } 

    if (!m_pszSSLVerificationName) {
        DebugTrace ((LPARAM) this,
            "Skipping certificate subject validation, no name to validate against");
        goto Exit;
    }

    DebugTrace ((LPARAM) this,
        "Validating certificate subject against: %s", m_pszSSLVerificationName);

    fRet = m_encryptCtx.CheckCertificateSubjectName (m_pszSSLVerificationName);
    if (!fRet) {
        ErrorTrace ((LPARAM) this, "SSL certificate subject verification failure");
        dwAQDiagnostic = AQUEUE_E_SSL_CERT_SUBJECT_MISMATCH;
    }
Exit:
    if (!fRet && dwAQDiagnostic)
        SetDiagnosticInfo(dwAQDiagnostic, NULL, NULL);

    TraceFunctLeaveEx ((LPARAM) this);
    return fRet;

}

/*++

    Name :
        void SMTP_CONNECTION::SkipWord

    Description:
        skips over words in a buffer and
        returns pointer to next word

    Arguments:
        none

    Returns:
        TRUE if the receive buffer was successfully decrypted, FALSE otherwise

--*/

BOOL SMTP_CONNOUT::DecryptInputBuffer(void)
{
    TraceFunctEnterEx( (LPARAM)this, "SMTP_CONNOUT::DecryptInputBuffer");

    DWORD   cbExpected;
    DWORD   cbReceived;
    DWORD   cbParsable;
    DWORD   dwError;

    dwError = m_encryptCtx.DecryptInputBuffer(
                                             (LPBYTE) QueryMRcvBuffer() + m_cbParsable,
                                             m_cbReceived - m_cbParsable,
                                             &cbReceived,
                                             &cbParsable,
                                             &cbExpected );

    if ( dwError == NO_ERROR ) {
        //
        // new total received size is the residual from last processing
        // and whatever is left in the current decrypted read buffer
        //
        m_cbReceived = m_cbParsable + cbReceived;


        //
        // new total parsable size is the residual from last processing
        // and whatever was decrypted from this read io operation
        //
        m_cbParsable += cbParsable;
    } else {
        //
        // errors from this routine indicate that the stream has been
        // tampered with or we have an internal error
        //
        ErrorTrace( (LPARAM)this,
                    "DecryptInputBuffer failed: 0x%08X",
                    dwError );
        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;

        DisconnectClient( dwError );
    }

    TraceFunctLeaveEx((LPARAM)this);
    return ( dwError == NO_ERROR );
}

BOOL SMTP_CONNOUT::DoSASLNegotiation(char *InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    BUFFER BuffOut;
    DWORD BytesRet = 0;
    BOOL fMoreData = FALSE;
    BOOL fRet = TRUE;
    BOOL fReturn = TRUE;
    DomainInfo DomainParams;
    LPSTR szClearTextPassword = NULL;
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoSASLNegotiation");

    //we need to receive a 354 from the server to go on
    if (InputLine[0] == SMTP_INTERMEDIATE_SUCCESS) {

        if (m_AuthToUse & SMTP_AUTH_NTLM || m_AuthToUse & SMTP_AUTH_KERBEROS) {

            if (m_securityCtx.ClientConverse(
                    InputLine + 4, ParameterSize - 4, &BuffOut, &BytesRet,
                        &fMoreData, &AuthInfoStruct, m_szAuthPackage,
                            NULL, NULL, (PIIS_SERVER_INSTANCE) m_pInstance)) {

                if (BytesRet) {
                    FormatSmtpMessage(FSM_LOG_NONE, "%s\r\n", BuffOut.QueryPtr());
                    SendSmtpResponse();
                }

            } else {

                DebugTrace((LPARAM) this, "m_securityCtx.Converse failed - %d",
                    GetLastError());

                m_Error = ERROR_LOGON_FAILURE;

                //Fill in the response context buffer so as to generate the right response
                // Get the error code

                m_ResponseContext.m_dwSmtpStatus = SMTP_RESP_BAD_CMD;

                hr = m_ResponseContext.m_cabResponse.Append(
                           (char *)SMTP_REMOTE_HOST_REJECTED_AUTH,
                           strlen(SMTP_REMOTE_HOST_REJECTED_AUTH),
                           NULL);

                fRet = FALSE;

                SetDiagnosticInfo(AQUEUE_E_SASL_REJECTED, NULL, NULL);
            }
        } else {

            ZeroMemory (&DomainParams, sizeof(DomainParams));

            DomainParams.cbVersion = sizeof(DomainParams);

            hr = m_pISMTPConnection->GetDomainInfo(&DomainParams);

            if (FAILED(hr)) {

                m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
                DisconnectClient();
                SetLastError(m_Error = ERROR_LOGON_FAILURE);
                SetDiagnosticInfo(AQUEUE_E_SASL_REJECTED, NULL, NULL);
                TraceFunctLeaveEx((LPARAM)this);
                return FALSE;

            }

            szClearTextPassword = DomainParams.szPassword;
            if (!szClearTextPassword) szClearTextPassword = "";

            fReturn = uuencode ((unsigned char *)szClearTextPassword,
                            lstrlen(szClearTextPassword), &BuffOut, FALSE);

            if (fReturn) {

                FormatSmtpMessage(FSM_LOG_NONE, "%s\r\n", BuffOut.QueryPtr());
                SendSmtpResponse();

            } else {

                m_Error = GetLastError();
                SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
                fRet = FALSE;

            }
        }
    } else if (InputLine[0] == SMTP_COMPLETE_SUCCESS) {

        if (m_MsgOptions & EMPTY_CONNECTION_OPTION) {
            fRet = DoSessionEndEvent(InputLine, ParameterSize, UndecryptedTailSize);
        } else {
            fRet = DoMessageStartEvent(InputLine, ParameterSize, UndecryptedTailSize);
        }

    } else {

        fRet = FALSE;
        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
        m_Error = ERROR_LOGON_FAILURE;
        SetDiagnosticInfo(AQUEUE_E_SASL_REJECTED, NULL, NULL);
        DisconnectClient();

    }

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

/*++

    Name :
        SMTP_CONNOUT::DoEHLOCommand

    Description:

        Responds to the SMTP EHLO command

    Arguments:
         Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoEHLOCommand(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoEHLOCommand");

    if (m_EhloFailed)
    {
        //server did not understand EHLO command, so
        //just send the HELO command
        m_HeloSent = TRUE;
        QuerySmtpInstance()->LockGenCrit();
        PE_FormatSmtpMessage("HELO %s\r\n", QuerySmtpInstance()->GetFQDomainName());
        QuerySmtpInstance()->UnLockGenCrit();
    } else {
        QuerySmtpInstance()->LockGenCrit();
        PE_FormatSmtpMessage("EHLO %s\r\n", QuerySmtpInstance()->GetFQDomainName());
        QuerySmtpInstance()->UnLockGenCrit();
    }
    m_OutboundContext.m_dwCommandStatus = EXPE_SUCCESS;
    m_EhloSent = TRUE;
    TraceFunctLeaveEx((LPARAM)this);
    return (TRUE);
}


/*++

    Name :
        SMTP_CONNOUT::DoEHLOResponse

    Description:

        Responds to the SMTP EHLO command

    Arguments:
         Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoEHLOResponse(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    BOOL    fGotAllOptions;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoEHLOResponse");
    char chInputGood = 0;
    BOOL fEndSession = FALSE;

    if ( isdigit( (UCHAR)InputLine[1] ) &&  isdigit( (UCHAR)InputLine[2] ) &&   ( ( InputLine[3] == ' '  ) || ( InputLine[3] == '-' ) ) ) {
        chInputGood = InputLine[0];
    } else {
        chInputGood = SMTP_COMPLETE_FAILURE;
        fEndSession = TRUE;
    }


    //get the response
    switch ( chInputGood ) {
    case SMTP_COMPLETE_SUCCESS:

        m_ResponseContext.m_dwResponseStatus = EXPE_SUCCESS;
        fGotAllOptions = GetEhloOptions(
                                       InputLine,
                                       ParameterSize,
                                       UndecryptedTailSize,
                                       m_HeloSent);
        _ASSERT(fGotAllOptions);
        if (IsOptionSet(ETRN_ONLY_OPTION) && !IsOptionSet(ETRN_OPTION)) {
            //We have no messages to send... only ETRN, but ETRN is not
            //supported by the remote server, we should send quit
            m_ResponseContext.m_dwResponseStatus = EXPE_CHANGE_STATE;
            m_ResponseContext.m_dwNextState = PE_STATE_SESSION_END;
            m_OutboundContext.m_pCurrentCommandContext = NULL;
        }

        break;

    case SMTP_COMPLETE_FAILURE:

        //if the HELO was sent and we got a 55X reply,
        //just quit. This server is hosed.
        if ( m_HeloSent || fEndSession ) {
            DebugTrace((LPARAM) this,
                       "SMTP_CONNOUT::DoEHLOCommand executing quit command err from client = %c%c%c",
                       InputLine [0],InputLine [1],InputLine [2]);
            m_ResponseContext.m_dwResponseStatus = EXPE_CHANGE_STATE;
            m_ResponseContext.m_dwNextState = PE_STATE_SESSION_END;
            m_OutboundContext.m_pCurrentCommandContext = NULL;
            SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, m_HeloSent ? "HELO" : "EHLO", InputLine);
        } else {
            //server did not understand EHLO command, so
            //just send the HELO command
            m_EhloFailed = TRUE;
            m_ResponseContext.m_dwResponseStatus = EXPE_REPEAT_COMMAND;
        }
        break;

    default:
        DebugTrace((LPARAM) this,
                   "SMTP_CONNOUT::DoEHLOCommand executing quit command err = %c%c%c",
                   InputLine [0],InputLine [1],InputLine [2]);
        m_ResponseContext.m_dwResponseStatus = EXPE_CHANGE_STATE;
        m_ResponseContext.m_dwNextState = PE_STATE_SESSION_END;
        m_OutboundContext.m_pCurrentCommandContext = NULL;
        SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, m_HeloSent ? "HELO" : "EHLO", InputLine);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return (TRUE);
}

/*++

    Name :

        SMTP_CONNOUT::GetEhloOptions(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)

    Description:

        Parses the response from the EHLO command

    Arguments:
        Line containing the response and line size

    Returns:
        TRUE if it parses all data
        FALSE if it needs more data to continue parsing

--*/
BOOL SMTP_CONNOUT::GetEhloOptions(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize, BOOL fIsHelo)
{
    register char * pszValue = NULL;
    register char * pszSearch = NULL;
    DWORD IntermediateSize = 0;
    BOOL IsNextLine = FALSE;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::GetEhloOptions");

    //get each line and parse the commands
    while ((pszSearch = IsLineComplete(InputLine, ParameterSize)) != NULL) {
        //Null terminate the end of the option
        *pszSearch = '\0';

        //check to see if there is a continuation line
        IsNextLine = (InputLine[3] == '-');

        IntermediateSize= (DWORD)((pszSearch - InputLine) + 2); //+2 for CRLF


        // Only process if it is an EHLO command, otherwise, just
        // eat up all the response data.
        if (!fIsHelo) {
            //skip over code and space
            //look for a space in the line.
            //options that have paramters
            //need to have a space after
            //their name
            pszValue = strchr(InputLine + 4, ' ');

            //does the server support the SIZE option ???
            if (strncasecmp(InputLine + 4, (char * )"SIZE", 4) == 0) {
                //yes sireee bob. If the server advertised
                //a maximum file size, get it while we are
                //here.
                m_Flags |= SIZE_OPTION;
                if (pszValue != NULL)
                    m_SizeOptionSize = atoi (pszValue);
            } else if (strcasecmp(InputLine + 4, (char * )"PIPELINING") == 0) {
                m_Flags |= PIPELINE_OPTION;
            } else if (strcasecmp(InputLine + 4, (char * )"8bitmime") == 0) {
                m_Flags |= EBITMIME_OPTION;
            } else if (strcasecmp(InputLine + 4, (char * )"dsn") == 0) {
                m_Flags |= DSN_OPTION;
            } else if (strncasecmp(InputLine + 4, (char *)"TLS", 3) == 0) {
                m_Flags |= TLS_OPTION;
            } else if (strncasecmp(InputLine + 4, (char *)"STARTTLS", 8) == 0) {
                m_Flags |= STARTTLS_OPTION;
            } else if (strncasecmp(InputLine + 4, (char *)"ETRN", 4) == 0) {
                m_Flags |= ETRN_OPTION;
            } else if (strcasecmp(InputLine + 4, (char *)"CHUNKING") == 0) {
                m_Flags |= CHUNKING_OPTION;
            } else if (strcasecmp(InputLine + 4, (char *)"BINARYMIME") == 0) {
                m_Flags |= BINMIME_OPTION;
            } else if (strcasecmp(InputLine + 4, (char *)"ENHANCEDSTATUSCODES") == 0) {
                m_Flags |= ENHANCEDSTATUSCODE_OPTION;
            } else if (strncasecmp(InputLine + 4, (char *)"AUTH", 4) == 0) {
                pszValue = strchr(InputLine + 4, '=');

                if (pszValue == NULL)
                    pszValue = strchr(InputLine + 4, ' ');

                while (pszValue != NULL) {
                    if (strncasecmp(pszValue + 1, (char *)"NTLM", 4) == 0) {
                        m_Flags |= AUTH_NTLM;

                    } else if (strncasecmp(pszValue + 1, (char *)"LOGIN", 5) == 0) {
                        m_Flags |= AUTH_CLEARTEXT;

                    } else if (strncasecmp(pszValue + 1, (char *)"DPA", 3) == 0) {
                        m_Flags |= AUTH_NTLM;

                    } else if (strncasecmp(pszValue + 1, (char *)"GSSAPI", 6) == 0) {
                        m_Flags |= AUTH_GSSAPI;
                    }

                    pszValue = strchr(pszValue + 1, ' ');
                }

            }

        }

        InputLine += IntermediateSize;
        ParameterSize -= IntermediateSize;
    }

    // We don't want to bail out for weird responses, but we want to
    // note such occurrences.
    if ((ParameterSize > 1) ||
        (!ParameterSize) ||
        (*InputLine)) {
        ErrorTrace((LPARAM)this, "Weird response tail <%*s>",
                   ParameterSize, InputLine);
        _ASSERT(FALSE);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

BOOL SMTP_CONNOUT::DoSASLCommand(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    BOOL fRet = TRUE;
    BOOL fMoreData = TRUE;
    BUFFER BuffOut;
    DWORD BytesRet = 0;
    DomainInfo DomainParams;
    LPSTR szUserName = NULL;
    LPSTR szPassword = NULL;
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoSASLCommand");

    ZeroMemory (&DomainParams, sizeof(DomainParams));

    if ((m_MsgOptions & DOMAIN_INFO_USE_NTLM ||
        m_MsgOptions & DOMAIN_INFO_USE_KERBEROS)) {
        if (!IsOptionSet(AUTH_NTLM) && !(IsOptionSet(AUTH_GSSAPI))) {
            //
            // We were told to do secure connection, but the remote server doesn't
            // support any form of login authentication! We have to drop this connection now.
            //
            m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
            DebugTrace((LPARAM) this, "SMTP_CONNOUT::DoSASLCommand: ERROR! Remote server does not support AUTH!");
            DisconnectClient();
            SetLastError(m_Error = ERROR_NO_SUCH_PACKAGE);

            SetDiagnosticInfo(AQUEUE_E_SASL_REJECTED, "AUTH", InputLine);

            TraceFunctLeaveEx((LPARAM)this);
            return ( FALSE );
        }
    }

    if (m_MsgOptions & DOMAIN_INFO_USE_PLAINTEXT) {
        if (!IsOptionSet(AUTH_CLEARTEXT)) {
            //
            // We were told to do secure connection, but the remote server doesn't
            // support any form of login authentication! We have to drop this connection now.
            //
            DebugTrace((LPARAM) this, "SMTP_CONNOUT::DoSASLCommand: ERROR! Remote server does not support AUTH!");
            DisconnectClient();
            SetLastError(m_Error = ERROR_NO_SUCH_PACKAGE);

            SetDiagnosticInfo(AQUEUE_E_SASL_REJECTED, "AUTH", InputLine);

            TraceFunctLeaveEx((LPARAM)this);
            return ( FALSE );
        }
    }

    //set the next state
    SetNextState (&SMTP_CONNOUT::DoSASLNegotiation);

    ZeroMemory (&DomainParams, sizeof(DomainParams));
    DomainParams.cbVersion = sizeof(DomainParams);
    hr = m_pISMTPConnection->GetDomainInfo(&DomainParams);

    if (FAILED(hr)) {
        DisconnectClient();
        SetLastError(m_Error = ERROR_LOGON_FAILURE);
        SetDiagnosticInfo(AQUEUE_E_SASL_LOGON_FAILURE, "AUTH", InputLine);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    szUserName = DomainParams.szUserName;
    szPassword = DomainParams.szPassword;

    //If a username is specified, but NULL password, IIS will attempt
    //anonymous logon.  Force "" password so the correct user is
    //used.
    if (szUserName && !szPassword)
        szPassword = "";

    if (m_MsgOptions & DOMAIN_INFO_USE_NTLM ||
            m_MsgOptions & DOMAIN_INFO_USE_KERBEROS) {

        m_szAuthPackage[0] = '\0';
        BOOL fReturn = FALSE;
        char    szTarget[MAX_INTERNET_NAME + 1];

        if ((m_MsgOptions & DOMAIN_INFO_USE_KERBEROS) && (IsOptionSet(AUTH_GSSAPI))) {
            m_AuthToUse = SMTP_AUTH_KERBEROS;
            strcpy(m_szAuthPackage,"GSSAPI");

            //
            // For Kerberos, we need to set the target server SPN, for which we
            // pickup info from m_pDnsRec
            //
            MX_NAMES *pmx;

            _ASSERT( m_pDnsRec != NULL );
            _ASSERT( m_pDnsRec->StartRecord < m_pDnsRec->NumRecords );

            pmx = m_pDnsRec->DnsArray[m_pDnsRec->StartRecord];
            _ASSERT( pmx != NULL );
            _ASSERT( pmx->DnsName != NULL );

            m_securityCtx.SetTargetPrincipalName(
                SMTP_SERVICE_PRINCIPAL_PREFIX,pmx->DnsName);

            DebugTrace((LPARAM) this, "Setting Target Server SPN to %s",
                       pmx->DnsName);

        } else {
            m_AuthToUse = SMTP_AUTH_NTLM;
            strcpy(m_szAuthPackage,"NTLM");
        }

        DebugTrace((LPARAM) this, "Using NTLM/KERBEROS for user %s",
            DomainParams.szUserName);

        fReturn = m_securityCtx.ClientConverse(
                                    NULL, 0, &BuffOut, &BytesRet,
                                    &fMoreData, &AuthInfoStruct,
                                    m_szAuthPackage,
                                    (char *) szUserName,
                                    (char *) szPassword,
                                    (PIIS_SERVER_INSTANCE) m_pInstance);

        if (fReturn) {
            if (BytesRet) {
                FormatSmtpMessage(FSM_LOG_ALL, "AUTH %s %s\r\n", m_szAuthPackage,
                    BuffOut.QueryPtr());
            }

            if (!fMoreData && (m_MsgOptions & DOMAIN_INFO_USE_NTLM)) {
                fRet = FALSE;
            }
        } else {
            m_Error = GetLastError();
            DebugTrace((LPARAM) this, "m_securityCtx.Converse for user %s - %d",
                szUserName, m_Error);
            DisconnectClient();
            m_Error = ERROR_LOGON_FAILURE;
            SetDiagnosticInfo(AQUEUE_E_SASL_LOGON_FAILURE, "AUTH", NULL); //Should not pass param Inputline: encrypted
            fRet = FALSE;
        }
    } else {
        BOOL fReturn = FALSE;
        m_AuthToUse = SMTP_AUTH_CLEARTEXT;

        if (!szUserName) szUserName = "";
        if (!szPassword) szPassword = "";

        DebugTrace((LPARAM) this, "Using ClearText for user %s",
            szUserName);
        fReturn = uuencode ((unsigned char *)szUserName,
                    lstrlen(szUserName), &BuffOut, FALSE);

        if (fReturn) {
            FormatSmtpMessage(FSM_LOG_VERB_ONLY, "AUTH LOGIN %s\r\n", (char *)
                BuffOut.QueryPtr());
            BytesRet = lstrlen((char *) BuffOut.QueryPtr());
        } else {
            DisconnectClient();
            m_Error = ERROR_LOGON_FAILURE;
            SetDiagnosticInfo(AQUEUE_E_SASL_LOGON_FAILURE, "AUTH", NULL); //Should not pass param Inputline: uuencoded
            fRet = FALSE;
        }
    }

    if (fRet && BytesRet) {
        SendSmtpResponse();
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}


/*++

    Name :
        SMTP_CONNOUT::DoSTARTTLSCommand

    Description:

        Negotiates use of SSL via the STARTTLS command

    Arguments:
        InputLine -- Indicates response of remote server
        ParameterSize -- Size of Inputline
        UndecryptedTailSize -- The part of the received buffer that could not
            be decrypted.

    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoSTARTTLSCommand(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoSTARTTLSCommand");

    if (m_TlsState == MUST_DO_TLS) {
        if (IsOptionSet(TLS_OPTION) || IsOptionSet(STARTTLS_OPTION)) {
            FormatSmtpMessage(FSM_LOG_ALL, "STARTTLS\r\n");
            SendSmtpResponse();
            DebugTrace((LPARAM) this, "SMTP_CONNOUT::DoSTARTTLSCommand: STARTTLS command sent");
            m_TlsState = STARTTLS_SENT;
            TraceFunctLeaveEx((LPARAM)this);
            return ( TRUE );
        } else {
            //
            // We were told to do secure connection, but the remote server doesn't
            // support TLS! We have to drop this connection now.
            //
            DebugTrace((LPARAM) this, "SMTP_CONNOUT::DoSTARTTLSCommand: ERROR! Remote server does not support TLS!");
            m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
            SetDiagnosticInfo(AQUEUE_E_TLS_NOT_SUPPORTED_ERROR, "STARTTLS", InputLine);
            DisconnectClient();
            SetLastError(m_Error = ERROR_NO_SECURITY_ON_OBJECT);
            TraceFunctLeaveEx((LPARAM)this);
            return ( FALSE );
        }
    } else {
        //
        // We sent the STARTTLS command, and InputLine has the server's response
        // Handle the server's response
        //
        _ASSERT(m_TlsState == STARTTLS_SENT);

        DebugTrace((LPARAM) this, "SMTP_CONNOUT::DoSTARTTLSCommand: Server response to STARTTLS is \"%s\"", InputLine);
        switch (InputLine[0]) {
        case SMTP_COMPLETE_FAILURE:
            {
                DebugTrace((LPARAM) this, "SMTP_CONNOUT::DoSTARTTLSCommand: Server returned error");
                m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
                SetDiagnosticInfo(AQUEUE_E_TLS_ERROR, "STARTTLS", InputLine);
                DisconnectClient();
                SetLastError(m_Error = ERROR_NO_SECURITY_ON_OBJECT);
                TraceFunctLeaveEx((LPARAM)this);
                return ( FALSE );
            }
            break;

        case SMTP_COMPLETE_SUCCESS:
            {
                m_SecurePort = TRUE;
                m_fNegotiatingSSL = TRUE;
                m_TlsState = SSL_NEG;
                DebugTrace((LPARAM) this, "SMTP_CONNOUT::DoSTARTTLSCommand: Server accepted, beginning SSL handshake");

                //
                // Switch over to using a large receive buffer, because a SSL fragment
                // may be up to 32K big.

                if (!SwitchToBigSSLBuffers()) {
                    DebugTrace((LPARAM) this,
                               "SMTP_CONNOUT::DoSTARTTLSCommand: Failed to allocate Big SSL buffers %d\n",
                               GetLastError());
                    DisconnectClient();
                    TraceFunctLeaveEx((LPARAM)this);
                    return ( FALSE );
                }

                if (!DoSSLNegotiation(NULL, 0, 0)) {
                    DebugTrace(
                              (LPARAM) this,
                              "SMTP_CONNOUT::DoSTARTTLSCommand: SSL Client Hello failed %d!\n",
                              GetLastError());
                    DisconnectClient();
                    SetLastError(m_Error = ERROR_NO_SECURITY_ON_OBJECT);
                    TraceFunctLeaveEx((LPARAM)this);
                    return ( FALSE );
                }

            }
            break;

        default:
            {
                DebugTrace((LPARAM) this, "SMTP_CONNOUT::DoSTARTTLSCommand: Server sent malformed response to STARTTLS");
                SetDiagnosticInfo(AQUEUE_E_TLS_ERROR, "STARTTLS", InputLine);
                DisconnectClient();
                SetLastError(m_Error = ERROR_NO_SECURITY_ON_OBJECT);
                TraceFunctLeaveEx((LPARAM)this);
                return ( FALSE );
            }
            break;
        }
    }


    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;

}

/*++

    Name :
        SMTP_CONNOUT::DoRSETCommand

    Description:

        Sends the SMTP RSET command.

    Arguments:
        Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoRSETCommand(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    FormatSmtpMessage(FSM_LOG_ALL, "RSET\r\n");

    m_cbReceived = 0;
    m_cbParsable = 0;
    m_fUseBDAT = FALSE;

    //If we are issuing rset during the Per rcpt event due to some problem
    //we need to preserve the state till we handle the
    //this message and ack it
    if (m_RsetReasonCode != ALL_RCPTS_FAILED) {
        m_fNeedRelayedDSN = FALSE;
        m_fHadHardError = FALSE;
        m_fHadTempError = FALSE;
    }

    return SendSmtpResponse();
}


/*++

    Name :
        SMTP_CONNOUT::SendRemainingRecipients

    Description:

    SendRemainingRecipients
    gets called when we get a 552 error during the
    RCPT to command.  This means that the server we connected
    to has a fixed max amount of rcpts that it accepts, and we
    went over that limit.  Therefore, we send the mail file to
    the recipients that it accepted and then start over sending
    the mail to the remaining recipients.  However, before doing
    this, check the response to see if the server took the previous
    mail O.K.

    Arguments:

          none

    Returns:
        nothing

--*/
void SMTP_CONNOUT::SendRemainingRecipients (void)
{
#if 0
    CAddr * pwalk = NULL;
    PLIST_ENTRY pListTemp = NULL;

    //increment our counter
    BUMP_COUNTER(QuerySmtpInstance(), NumMsgsSent);

    //yea, baby. Save the start address
    //so we can walk the list deleting
    //any addresses that were successfully
    //sent.
    pwalk = m_StartAddress;
    pListTemp = m_StartAddressLink;

    _ASSERT (pwalk != NULL);

    //set the start address to NULL, so
    //that we can set it to a known good
    //address below.  See the other comment
    //below.
    m_StartAddress = NULL;
    m_StartAddressLink = NULL;

    //step through all the previously sent addresses.
    //If they have an error code of 250, then they
    //were received correctly.  An error code of
    //552 means that we sent too many, so we are
    //going to attempt to send the remaining recipients.
    //We will not attempt to send a rcpt that has any
    //other error code.
    while (pwalk && (pwalk->GetErrorCode() != SMTP_DUMMY_FAILURE)) {
        if ((pwalk->GetErrorCode() == SMTP_OK_CODE) ||
            (pwalk->GetErrorCode() == SMTP_USER_NOT_LOCAL_CODE)) {
            MailInfo->RemoveAddress(pwalk);
            delete pwalk;
        }

        //get the next address
        pwalk = MailInfo->GetNextAddress(&pListTemp);
    }

    _ASSERT (pwalk != NULL);
    _ASSERT (pwalk->GetErrorCode() == SMTP_DUMMY_FAILURE);

    m_StartAddress = pwalk;
    m_StartAddressLink = pListTemp;

    _ASSERT (m_StartAddress != NULL);
    _ASSERT (m_StartAddressLink != NULL);

    //update the queue file to reflect the remaining
    //recipients, if any
    MailInfo->UpdateQueueFile(REMOTE_NAME);

    //save the current RCPT address
    m_NextAddress = pwalk;
    m_NextAddressLink = pListTemp;
#endif

}

BOOL SMTP_CONNOUT::DoETRNCommand(void)
{
    DWORD WaitRes = WAIT_TIMEOUT;
    DWORD TimeToWait = 0;
    HRESULT hr = S_OK;
    DomainInfo DomainParams;
    char  szETRNDomainBuffer[MAX_PATH+1];
    char *szNextETRNDomain = NULL;
    const char *szETRNDomain = szETRNDomainBuffer;
    DWORD cbETRNDomain = 0;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoETRNCommand");

    ZeroMemory(&DomainParams, sizeof(DomainParams));

    ZeroMemory (&DomainParams, sizeof(DomainParams));
    DomainParams.cbVersion = sizeof(DomainParams);
    hr = m_pISMTPConnection->GetDomainInfo(&DomainParams);
    if (FAILED(hr) || (DomainParams.szETRNDomainName == NULL)) {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    if (!m_szCurrentETRNDomain) {
        m_szCurrentETRNDomain = DomainParams.szETRNDomainName;
    }

    //Find next in comma-delimited list of domains
    szNextETRNDomain = strchr(m_szCurrentETRNDomain, ',');

    if (!szNextETRNDomain) {
        //We are done... this is the last domain
        szETRNDomain = m_szCurrentETRNDomain;
        m_Flags |= ETRN_SENT;
    } else {
        //There are more domains left... we need to copy the domain
        //to our buffer where we can NULL terminate it.
        cbETRNDomain = (DWORD) (sizeof(char)*(szNextETRNDomain-m_szCurrentETRNDomain));
        if ((cbETRNDomain >= sizeof(szETRNDomainBuffer)) ||
            (cbETRNDomain > DomainParams.cbETRNDomainNameLength)) {
            //There is not enough room for this domain
            ErrorTrace((LPARAM) this, "Domain configured for ETRN is greater than MAX_PATH");
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }
        memcpy(szETRNDomainBuffer, m_szCurrentETRNDomain, cbETRNDomain);
        szETRNDomainBuffer[cbETRNDomain/sizeof(char)] = '\0';

        //Skip to beginning of next domain
        m_szCurrentETRNDomain = szNextETRNDomain;
        while (isspace((UCHAR)*m_szCurrentETRNDomain) || *m_szCurrentETRNDomain == ',') {
            if (!(*m_szCurrentETRNDomain)) {
                //End of string... we're done
                m_Flags |= ETRN_SENT;
                break;
            }
            m_szCurrentETRNDomain++;
        }
    }

#if 0
    TimeToWait = m_pHashEntry->GetEtrnWaitTime() * 60 * 1000; //time in milliseconds

    if (TimeToWait) {
        WaitRes = WaitForSingleObject(QuerySmtpInstance()->GetQStopEvent(), m_pHashEntry->GetEtrnWaitTime());
    }

    if (WaitRes == WAIT_OBJECT_0) {
        DisconnectClient();
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }
#endif

    FormatSmtpMessage(FSM_LOG_ALL, "ETRN %s\r\n", szETRNDomain);

    SendSmtpResponse();

    //Keep on sending ETRNs until we are out of domains.
    if (!IsOptionSet(ETRN_ONLY_OPTION) || !(m_Flags & ETRN_SENT)) {
        SetNextState (&SMTP_CONNOUT::DoMessageStartEvent);
    } else {
        SetNextState (&SMTP_CONNOUT::DoCompletedMessage);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

/*++

    Name :
        SMTP_CONNOUT::DoMAILCommand

    Description:

        Responds to the SMTP MAIL command.
    Arguments:
        Are ignored

    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoMAILCommand(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    char Options[1024] = "";
    char BodySize[32];
    char Address[MAX_INTERNET_NAME];
    DWORD MsgOption = 0;
    HRESULT hr = S_OK;
    BOOL fFailedDueToBMIME = FALSE;
    _ASSERT(m_pIMsg);

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoMAILCommand");

    m_OutboundContext.m_dwCommandStatus = EXPE_SUCCESS;

    //clear the options
    Options[0] = '\0';

    //If the message has 8bitmime, make sure the
    //server also supports it.

    hr = m_pIMsg->GetDWORD(IMMPID_MP_EIGHTBIT_MIME_OPTION, &MsgOption);
    if (MsgOption) {
        if (IsOptionSet(EBITMIME_OPTION)) {
            lstrcat(Options, " BODY=8bitmime");
        } else {
            // SetLastError(SMTP_OPTION_NOT_SUPPORTED_8BIT);
            DebugTrace((LPARAM) this, "Message has 8bitmime but server does not support it");
            m_OutboundContext.m_dwCommandStatus = EXPE_COMPLETE_FAILURE;
            //Fill in the response context buffer so as to generate the right response
            // Get the error code
            m_ResponseContext.m_dwSmtpStatus = SMTP_RESP_BAD_CMD;
            hr = m_ResponseContext.m_cabResponse.Append(
                                                       (char *)SMTP_REMOTE_HOST_REJECTED_FOR_TYPE,
                                                       strlen(SMTP_REMOTE_HOST_REJECTED_FOR_TYPE),
                                                       NULL);
            TraceFunctLeaveEx((LPARAM)this);
            return (TRUE);
        }
    } else {
        MsgOption = 0;
        hr = m_pIMsg->GetDWORD(IMMPID_MP_BINARYMIME_OPTION, &MsgOption);
        if (MsgOption) {
            //Check if we allow BINARYMIME outbound at domain level
            if (m_MsgOptions & DOMAIN_INFO_DISABLE_BMIME) {
                fFailedDueToBMIME = TRUE;
            } else {
                //Do we disallow it globally
                if (QuerySmtpInstance()->AllowOutboundBMIME()) {
                    if (IsOptionSet(BINMIME_OPTION) && IsOptionSet(CHUNKING_OPTION)) {
                        lstrcat(Options, " BODY=BINARYMIME");
                        m_fUseBDAT = TRUE;
                    } else {
                        fFailedDueToBMIME = TRUE;
                    }
                } else {
                    fFailedDueToBMIME = TRUE;
                }
            }
        }

    }

    if (fFailedDueToBMIME) {
        // SetLastError(SMTP_OPTION_NOT_SUPPORTED_BMIME);
        DebugTrace((LPARAM) this, "Message has BINARYMIME but server does not support it");
        m_OutboundContext.m_dwCommandStatus = EXPE_COMPLETE_FAILURE;
        //Fill in the response context buffer so as to generate the right response
        // Get the error code
        m_ResponseContext.m_dwSmtpStatus = SMTP_RESP_BAD_CMD;
        hr = m_ResponseContext.m_cabResponse.Append(
                                                   (char *)SMTP_REMOTE_HOST_REJECTED_FOR_TYPE,
                                                   strlen(SMTP_REMOTE_HOST_REJECTED_FOR_TYPE),
                                                   NULL);
        TraceFunctLeaveEx((LPARAM)this);
        return (TRUE);
    }
    //See if CHUNKING is preferred on this connection
    //If it is and the remote site advertised chunking then we set the UseBDAT flag
    else if (!m_fUseBDAT) {
        //Does the remote server advertises chunking
        if (IsOptionSet(CHUNKING_OPTION)) {
            //Do we disallow chunking at domain level
            if (m_MsgOptions & DOMAIN_INFO_DISABLE_CHUNKING) {
                DebugTrace((LPARAM) this, "We disable chunking for this domain");

            } else if ((m_MsgOptions & DOMAIN_INFO_USE_CHUNKING) || QuerySmtpInstance()->ShouldChunkOut()) {
                m_fUseBDAT = TRUE;
            }
        } else if (m_MsgOptions & DOMAIN_INFO_USE_CHUNKING)
            DebugTrace((LPARAM) this, "Remote server does not advertise chunking");
    }

    // produce a dot-stuffed handle if we aren't using bdat
    if (!m_fUseBDAT) {
        DWORD fFoundEmbeddedCrlfDot = FALSE;
        DWORD fScanned = FALSE;

        //
        // get the properties to see if we have scanned for crlf.crlf, and
        // to see if the message contained crlf.crlf when it was scanned.
        // if either of these lookups fail then we will set fScanned to
        // FALSE
        //
        if (FAILED(m_pIMsg->GetDWORD(IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF,
                                     &fScanned)) ||
            FAILED(m_pIMsg->GetDWORD(IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF,
                                     &fFoundEmbeddedCrlfDot)))
        {
            fScanned = FALSE;
        }


        //
        // if we didn't scan, or if we found an embedded crlf.crlf then
        // produce a dot stuff context
        //
        if (!fScanned || fFoundEmbeddedCrlfDot) {
            if (!m_IMsgDotStuffedFileHandle) {
                m_IMsgDotStuffedFileHandle = ProduceDotStuffedContext(
                                                                  m_IMsgFileHandle,
                                                                  NULL,
                                                                  TRUE );
                if (NULL == m_IMsgDotStuffedFileHandle)
                {
                    SetDiagnosticInfo(AQUEUE_E_BIND_ERROR , NULL, NULL);
                    ErrorTrace((LPARAM) this, "Failed to get dot stuffed context");
                    TraceFunctLeaveEx((LPARAM)this);
                    return FALSE;
                }
            }
        }
    }

    //get the size of the file
    DWORD dwSizeHigh;
    m_FileSize = GetFileSizeFromContext( (m_IMsgDotStuffedFileHandle && !m_fUseBDAT) ? m_IMsgDotStuffedFileHandle : m_IMsgFileHandle, &dwSizeHigh);
    _ASSERT(dwSizeHigh == 0);

    //if the server supports the size command
    // give him the size of the file
    if (IsOptionSet(SIZE_OPTION) && (m_SizeOptionSize > 0)) {
        if ((m_FileSize != 0XFFFFFFFF) && (m_FileSize <= m_SizeOptionSize))
        {
            wsprintf(BodySize, " SIZE=%d", m_FileSize);
            lstrcat(Options, BodySize);
        }
        else {
            // SetLastError(SMTP_MSG_LARGER_THAN_SIZE);
            DebugTrace((LPARAM) this, "(m_FileSize != 0XFFFFFFFF) && (m_FileSize <= m_SizeOptionSize) failed");
            DebugTrace((LPARAM) this, "m_FileSize = %d, m_SizeOptionSize = %d - quiting", m_FileSize, m_SizeOptionSize );
            m_OutboundContext.m_dwCommandStatus = EXPE_COMPLETE_FAILURE;

            //Fill in the response context buffer so as to generate the right response
            // Get the error code
            m_ResponseContext.m_dwSmtpStatus = SMTP_RESP_BAD_CMD;
            hr = m_ResponseContext.m_cabResponse.Append(
                                                       (char *)SMTP_REMOTE_HOST_REJECTED_FOR_SIZE,
                                                       strlen(SMTP_REMOTE_HOST_REJECTED_FOR_SIZE),
                                                       NULL);

            TraceFunctLeaveEx((LPARAM)this);
            return (TRUE);
        }
    }

    if (IsOptionSet(DSN_OPTION)) {
        char RetDsnValue[200];
        BOOL fDSNDisallowed = TRUE;

        //Do we disallow DSN at domain level
        if (m_MsgOptions & DOMAIN_INFO_DISABLE_DSN) {
            DebugTrace((LPARAM) this, "We disable DSN for this domain");
        } else if (QuerySmtpInstance()->AllowOutboundDSN()) {
            fDSNDisallowed = FALSE;
        }

        lstrcpy(RetDsnValue, " RET=");
        hr = m_pIMsg->GetStringA(IMMPID_MP_DSN_RET_VALUE, sizeof(RetDsnValue) - lstrlen(RetDsnValue), RetDsnValue + lstrlen(RetDsnValue));
        if (!FAILED(hr) && !fDSNDisallowed) {
            lstrcat(Options, RetDsnValue);
        }

        lstrcpy(RetDsnValue, " ENVID=");
        hr = m_pIMsg->GetStringA(IMMPID_MP_DSN_ENVID_VALUE, sizeof(RetDsnValue) - lstrlen(RetDsnValue), RetDsnValue + lstrlen(RetDsnValue));
        if (!FAILED(hr) && !fDSNDisallowed) {
            lstrcat(Options, RetDsnValue);
        }
    }

    hr = m_pIMsg->GetStringA(IMMPID_MP_SENDER_ADDRESS_SMTP, sizeof(Address), Address);
    if (!FAILED(hr)) {
        //format the MAIL FROM command, with SIZE extension if necessary.
        if ( (Address[0] == '<') && (Address[1] == '>'))
            PE_FormatSmtpMessage("MAIL FROM:<>%s\r\n", Options);
        else
            PE_FormatSmtpMessage("MAIL FROM:<%s>%s\r\n", Address, Options);
    } else {
        DebugTrace((LPARAM) this, "Could not get Sender Address %x", hr);
        m_OutboundContext.m_dwCommandStatus = EXPE_COMPLETE_FAILURE;
        TraceFunctLeaveEx((LPARAM)this);
        return (TRUE);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

/*++

    Name :
        SMTP_CONNOUT::DoMAILResponse

    Description:

        Responds to the SMTP MAIL command

    Arguments:
         Are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoMAILResponse(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoMAILResponse");

    m_ResponseContext.m_dwResponseStatus = EXPE_SUCCESS;

    char chInputGood = 0;

    if ( isdigit( (UCHAR)InputLine[1] ) &&  isdigit( (UCHAR)InputLine[2] ) &&   ( ( InputLine[3] == ' '  ) || ( InputLine[3] == '-' ) ) ) {
        chInputGood = InputLine[0];
    } else {
        chInputGood = SMTP_COMPLETE_FAILURE;
    }

    //the MAIL FROM: was rejected
    if ( chInputGood != SMTP_COMPLETE_SUCCESS) {
        // We expect either a 4xx or 5xx response. If it's 4xx we return
        // a transient, all others will become a complete failure.
        SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, "MAIL", InputLine);
        if ( chInputGood == SMTP_TRANSIENT_FAILURE) {
            m_ResponseContext.m_dwResponseStatus = EXPE_TRANSIENT_FAILURE;
            m_OutboundContext.m_pCurrentCommandContext = NULL;
        } else {
            m_ResponseContext.m_dwResponseStatus = EXPE_COMPLETE_FAILURE;
            m_OutboundContext.m_pCurrentCommandContext = NULL;
            DebugTrace((LPARAM) this,
                       "SMTP_CONNOUT::DoMAILResponse executing quit command err = %c%c%c",
                       InputLine [0],InputLine [1],InputLine [2]);
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return (TRUE);
}

BOOL SMTP_CONNOUT::AddRcptsDsns(DWORD NotifyOptions, char * OrcptVal, char * AddrBuf, int& AddrSize)
{
    BOOL FirstOption = TRUE;

    if (NotifyOptions & ~(RP_DSN_NOTIFY_NEVER | RP_DSN_NOTIFY_SUCCESS | RP_DSN_NOTIFY_FAILURE | RP_DSN_NOTIFY_DELAY)) {
        NotifyOptions = 0;
    }

    if (NotifyOptions) {
        lstrcat(AddrBuf, " NOTIFY=");
        AddrSize += 8;

        if (NotifyOptions & RP_DSN_NOTIFY_SUCCESS) {
            lstrcat(AddrBuf, "SUCCESS");
            AddrSize += 7;
            FirstOption = FALSE;
        }

        if (NotifyOptions & RP_DSN_NOTIFY_FAILURE) {
            if (!FirstOption) {
                lstrcat(AddrBuf, ",");
                AddrSize += 1;
            }

            lstrcat(AddrBuf, "FAILURE");
            AddrSize += 7;
            FirstOption = FALSE;
        }

        if (NotifyOptions & RP_DSN_NOTIFY_DELAY) {
            if (!FirstOption) {
                lstrcat(AddrBuf, ",");
                AddrSize += 1;
            }

            lstrcat(AddrBuf, "DELAY");
            AddrSize += 5;
            FirstOption = FALSE;
        }

        if (FirstOption) {
            lstrcat(AddrBuf, "NEVER");
            AddrSize += 5;
        }
    }

    if (*OrcptVal != '\0') {
        lstrcat(AddrBuf, " ORCPT=");
        AddrSize += 7;

        lstrcat(AddrBuf, OrcptVal);
        AddrSize += lstrlen(OrcptVal);
    }

    return TRUE;
}

/*++

    Name :
        SMTP_CONNOUT::SaveToErrorFile

    Description:

        This function saves all errors to
        a file so the NDR thread can send
        a transcript of what tranpired back
        to the original user

    Arguments:

        Buffer with recipient data, size of buffer,

    Returns:

      TRUE if we were able to open and write to the file
      FALSE otherwise

--*/
BOOL SMTP_CONNOUT::SaveToErrorFile(char * Buffer, DWORD BufSize)
{
    return TRUE;
}

/*++

    Name :
        SMTP_CONNOUT::DoRCPTCommand

    Description:

        This function sends the SMTP RCPT command.
    Arguments:
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoRCPTCommand(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    char AddrBuf [MAX_INTERNET_NAME + 2024];
    char szRecipName[MAX_INTERNET_NAME];
    char szOrcptVal[501];
    BOOL fOrcptSpecified;
    BOOL fFoundUnhandledRcpt = FALSE;
    int AddrSize = 0;
    HRESULT hr = S_OK;
    DWORD NextAddress = 0;

    _ASSERT(QuerySmtpInstance() != NULL);

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoRCPTCommand");

    //MessageTrace((LPARAM) this, (LPBYTE) InputLine, ParameterSize);

    // We report success
    m_OutboundContext.m_dwCommandStatus = EXPE_SUCCESS;

    //format as much of the recipients that could fit into
    //the output buffer
    NextAddress = m_NextAddress;
    while (NextAddress < m_NumRcpts) {
        DWORD dwRecipientFlags = 0;
        hr = m_pIMsgRecips->GetDWORD(m_RcptIndexList[NextAddress], IMMPID_RP_RECIPIENT_FLAGS,&dwRecipientFlags);
        if (FAILED(hr) && hr != MAILMSG_E_PROPNOTFOUND) {
            //Problemmo
            // Get property shouldn't fail since we've come this far
            //_ASSERT(FALSE);
            goto RcptError;
        }

        //NK** : I am moving this out as it breaks us when the first recipient is a handled recipient
        // Default is pipelined
        m_OutboundContext.m_dwCommandStatus = EXPE_PIPELINED | EXPE_REPEAT_COMMAND;

        //check to see if this recipient needs to be looked at
        if ((dwRecipientFlags & RP_HANDLED) ) {
            //This recipient can be skipped over
            //Mark it inaccesible so that when we sweep the tried recipient
            //in case of connection drop we do not touch the guys we did not send
            //We need to get atleast one guy each time we come in.
            m_RcptIndexList[NextAddress] = INVALID_RCPT_IDX_VALUE;
            m_NextAddress = NextAddress + 1;
            NextAddress ++;
            continue;
        } else {
            hr = m_pIMsgRecips->GetStringA(m_RcptIndexList[NextAddress], IMMPID_RP_ADDRESS_SMTP, sizeof(szRecipName), szRecipName);
            if (!FAILED(hr)) {
                //Format the first recipient
                AddrSize = wsprintf (AddrBuf, "RCPT TO:<%s>", szRecipName);

                fOrcptSpecified = FALSE;
                hr = m_pIMsgRecips->GetStringA(m_RcptIndexList[NextAddress], IMMPID_RP_DSN_ORCPT_VALUE, sizeof(szOrcptVal), szOrcptVal);
                if (!FAILED(hr) && (szOrcptVal[0] != '\0')) {
                    fOrcptSpecified = TRUE;

                } else if (FAILED(hr) && hr != MAILMSG_E_PROPNOTFOUND) {
                    //Problemmo
                    // Get property shouldn't fail since we've come this far
                    //_ASSERT(FALSE);
                    goto RcptError;
                } else {
                    szOrcptVal[0] = '\0';
                }

                //If some DSN property is set then
                if ((dwRecipientFlags & RP_DSN_NOTIFY_MASK) || fOrcptSpecified) {
                    BOOL fAllowDSN = FALSE;

                    //Do we disallow DSN at domain level
                    if (m_MsgOptions & DOMAIN_INFO_DISABLE_DSN) {
                        DebugTrace((LPARAM) this, "We disable DSN for this domain");
                    } else if (QuerySmtpInstance()->AllowOutboundDSN()) {
                        fAllowDSN = TRUE;
                    }

                    if (IsOptionSet(DSN_OPTION) && fAllowDSN) {
                        AddRcptsDsns(dwRecipientFlags, szOrcptVal, AddrBuf, AddrSize);
                        m_fNeedRelayedDSN = FALSE;
                    } else {
                        //let AQ know that the remote server did not advertise DSN
                        m_fNeedRelayedDSN = TRUE;
                        dwRecipientFlags |= RP_REMOTE_MTA_NO_DSN;
                        hr = m_pIMsgRecips->PutDWORD(m_RcptIndexList[NextAddress],
                                                     IMMPID_RP_RECIPIENT_FLAGS,dwRecipientFlags);
                        if (FAILED(hr)) {
                            //Problemmo
                            goto RcptError;
                        }
                    }
                }

                lstrcat(AddrBuf, "\r\n");
                AddrSize += 2;

                if (PE_FormatSmtpMessage("%s", AddrBuf)) {
                    DebugTrace((LPARAM) this,"Sending %s", szRecipName);
                    m_NumRcptSent++;
                    m_NextAddress = NextAddress + 1;

                    if (!IsOptionSet(PIPELINE_OPTION))
                        m_OutboundContext.m_dwCommandStatus = EXPE_NOT_PIPELINED;
                } else {
                    //no more space in the buffer, send what we have;
                    //_ASSERT(FALSE);
                    m_OutboundContext.m_dwCommandStatus = EXPE_NOT_PIPELINED;
                    return (TRUE);
                }
            } else {
                //Problemmo
                // Get property shouldn't fail since we've come this far
                //_ASSERT(FALSE);
                goto RcptError;
            }
        }
        NextAddress ++;
        break;
    }

    // If we are done, we will not pipeline further, this will save a loop
    if (m_NumRcpts == NextAddress)
        m_OutboundContext.m_dwCommandStatus = EXPE_NOT_PIPELINED;

    TraceFunctLeaveEx((LPARAM)this);
    return (TRUE);

RcptError:

    m_OutboundContext.m_dwCommandStatus = EXPE_TRANSIENT_FAILURE;
    TraceFunctLeaveEx((LPARAM)this);
    return (FALSE);
}

/*++

    Name :
        SMTP_CONNOUT::DoRCPTResponse

    Description:

        This function handles the SMTP RCPT response.
    Arguments:
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoRCPTResponse(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    HRESULT    hr = S_OK;
    DWORD    NextAddress = 0;
    DWORD dwRecipientFlags;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoRCPTResponse");

    _ASSERT(QuerySmtpInstance() != NULL);

    //MessageTrace((LPARAM) this, (LPBYTE) InputLine, ParameterSize);

    m_ResponseContext.m_dwResponseStatus = EXPE_SUCCESS;

    //start at the beginning of the last
    //pipelined address
    NextAddress = m_FirstPipelinedAddress;

    DebugTrace((LPARAM)this, "Response: %*s", ParameterSize, InputLine);

    //step through the returned recipients and check
    //their error code.
    if (m_NumRcptSent) {
        //Get to the next rcpt that we send out this time
        while ((NextAddress < m_NumRcpts) && (m_RcptIndexList[NextAddress] == INVALID_RCPT_IDX_VALUE))
            NextAddress++;

        _ASSERT(NextAddress < m_NumRcpts);
        if (NextAddress >= m_NumRcpts) {
            //Problemo
            SetLastError(ERROR_INVALID_DATA);
            TraceFunctLeaveEx((LPARAM)this);
            return (FALSE);
        }

        dwRecipientFlags = 0;

        hr = m_pIMsgRecips->GetDWORD(m_RcptIndexList[NextAddress], IMMPID_RP_RECIPIENT_FLAGS,&dwRecipientFlags);

        if (FAILED(hr) && hr != MAILMSG_E_PROPNOTFOUND) {
            //Problemmo
            SetLastError(ERROR_OUTOFMEMORY);
            TraceFunctLeaveEx((LPARAM)this);
            return (FALSE);
        }

        m_NumRcptSent--;

        //Once we get 552 Too many recipients error .. we do not bother to look at the real responses
        //Logically they will all be 552 as well
        if (m_SendAgain)
            m_ResponseContext.m_dwSmtpStatus = SMTP_ACTION_ABORTED_CODE;

        // If we have no response status code set, we will abort action
        if (m_ResponseContext.m_dwSmtpStatus == 0) {
            m_NumFailedAddrs++;
            m_NumRcptSentSaved ++;
            hr = m_pIMsgRecips->PutDWORD(m_RcptIndexList[NextAddress], IMMPID_RP_ERROR_CODE, SMTP_ACTION_ABORTED_CODE);
            if (FAILED(hr)) {
                //Problemmo
                SetLastError(ERROR_OUTOFMEMORY);
                TraceFunctLeaveEx((LPARAM)this);
                return (FALSE);
            }

            //Create the temp error string
            char sztemp[100];
            sprintf(sztemp,"%d %s",SMTP_ACTION_ABORTED_CODE, "Invalid recipient response");
            hr = m_pIMsgRecips->PutStringA(m_RcptIndexList[NextAddress], IMMPID_RP_SMTP_STATUS_STRING,sztemp);
            if (FAILED(hr)) {
                //Problemmo
                SetLastError(ERROR_OUTOFMEMORY);
                TraceFunctLeaveEx((LPARAM)this);
                return (FALSE);
            }
            //real bad error.  SCuttle this message
            MessageTrace((LPARAM) this, (LPBYTE) InputLine, ParameterSize);
            SetLastError(ERROR_CAN_NOT_COMPLETE);
            m_ResponseContext.m_dwResponseStatus = EXPE_TRANSIENT_FAILURE;
            m_OutboundContext.m_pCurrentCommandContext = NULL;
            SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, "RCPT", InputLine);
            return (TRUE);
        } else {
            //save the number of recipients sent so that
            //we can compare this number to the number of
            //failed recipients.
            m_NumRcptSentSaved ++;

            BUMP_COUNTER(QuerySmtpInstance(), NumRcptsSent);

            // Save the error code (if there was an error)
            // We do not want to save "250 OK" or "251 OK" responses because
            // it wastes increases the memory footprint of messages in
            // the queue
            if ((SMTP_OK_CODE != m_ResponseContext.m_dwSmtpStatus) &&
                (SMTP_USER_NOT_LOCAL_CODE != m_ResponseContext.m_dwSmtpStatus)) {

                ErrorTrace((LPARAM)this,
                           "Saving rcpt error code %u - %s",
                           m_ResponseContext.m_dwSmtpStatus, InputLine);

                hr = m_pIMsgRecips->PutDWORD(
                                            m_RcptIndexList[NextAddress],
                                            IMMPID_RP_ERROR_CODE,
                                            m_ResponseContext.m_dwSmtpStatus);
                if (FAILED(hr)) {
                    //Problemmo
                    SetLastError(ERROR_OUTOFMEMORY);
                    TraceFunctLeaveEx((LPARAM)this);
                    return (FALSE);
                }

                //Set the ful response as error string
                hr = m_pIMsgRecips->PutStringA(m_RcptIndexList[NextAddress], IMMPID_RP_SMTP_STATUS_STRING, InputLine);
                if (FAILED(hr)) {
                    //Problemmo
                    SetLastError(ERROR_OUTOFMEMORY);
                    TraceFunctLeaveEx((LPARAM)this);
                    return (FALSE);
                }
            } else {
                //Recipient successful... trace it
                DebugTrace((LPARAM) this,
                    "Recipient %d OK with response %s",
                    NextAddress, InputLine);
            }

            switch (m_ResponseContext.m_dwSmtpStatus) {
            //4XX level code will lead to retry
            case SMTP_ERROR_PROCESSING_CODE:
            case SMTP_MBOX_BUSY_CODE:
            case SMTP_SERVICE_UNAVAILABLE_CODE:
                //Buffer[3] = ' '; put back the space character
                m_fHadTempError = TRUE;
                dwRecipientFlags |= (RP_ERROR_CONTEXT_MTA);
                m_NumFailedAddrs++;
                break;

            case SMTP_ACTION_ABORTED_CODE:
                //this means we sent too many recipients.
                //set the m_SendAgain flag which tells us
                //to send whatever we have now, then start
                //sending to the other recipients afterwards.
                //We have to switch the error code because 552
                //means different things depending on what operation
                //we are doing.

                if (!m_SendAgain) {
                    if (m_fHadSuccessfulDelivery) {
                        m_NumFailedAddrs++;
                        m_SendAgain = TRUE;

                        if( m_NumFailedAddrs >= m_NumRcptSentSaved )
                        {
                            m_fHadHardError = TRUE;
                        }

                        if (m_First552Address == -1)
                            m_First552Address = NextAddress;
                        break;
                    }
                } else {
                    m_NumFailedAddrs++;
                    break;
                }
                //A 552 response is treated as failure if we did not even send
                //a single recipient
                //fall thru

                //5XX level codes will lead to NDR for the rcpt
            case SMTP_UNRECOG_COMMAND_CODE:
            case SMTP_SYNTAX_ERROR_CODE:
            case SMTP_NOT_IMPLEMENTED_CODE:
            case SMTP_BAD_SEQUENCE_CODE :
            case SMTP_PARAM_NOT_IMPLEMENTED_CODE:
            case SMTP_MBOX_NOTFOUND_CODE:
            case SMTP_USERNOTLOCAL_CODE:
            case SMTP_ACTION_NOT_TAKEN_CODE:
            case SMTP_TRANSACT_FAILED_CODE:

                // Buffer[3] = ' '; //put back the space character
                //SaveToErrorFile(Buffer, IntermediateSize);
                // DebugTrace((LPARAM) this, "User %s failed because of %d", pwalk->GetAddress(), Error);
                SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, "RCPT", InputLine);
                m_fHadHardError = TRUE;
                dwRecipientFlags |= (RP_FAILED | RP_ERROR_CONTEXT_MTA);
                m_NumFailedAddrs++;
                break;
            case SMTP_OK_CODE:
            case SMTP_USER_NOT_LOCAL_CODE:
                m_fHadSuccessfulDelivery = TRUE;
                BUMP_COUNTER(QuerySmtpInstance(), NumRcptsSent);
                dwRecipientFlags |= (RP_DELIVERED | RP_ERROR_CONTEXT_MTA);
                break;
            case SMTP_SERVICE_CLOSE_CODE:
            case SMTP_INSUFF_STORAGE_CODE:
                //fall through.  This is deliberate.
                //we don't want to continue if we get
                //these errors
            default:
                //real bad error.  Copy this error to the
                //front of the input buffer, because this
                //buffer will be passed to DoCompletedMessage
                //to do the right thing.
                {
                    SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, "RCPT", InputLine);
                    char chInputGood = 0;

                    if ( isdigit( (UCHAR)InputLine[1] ) &&
                         isdigit( (UCHAR)InputLine[2] ) &&
                         ( ( InputLine[3] == ' '  ) || ( InputLine[3] == '-' ) ) ) {
                        chInputGood = InputLine[0];
                    } else {
                        chInputGood = SMTP_COMPLETE_FAILURE;
                    }


                    MessageTrace((LPARAM) this, (LPBYTE) InputLine, ParameterSize);
                    SetLastError(ERROR_CAN_NOT_COMPLETE);
                    if ( chInputGood == SMTP_TRANSIENT_FAILURE) {
                        m_ResponseContext.m_dwResponseStatus = EXPE_TRANSIENT_FAILURE;
                        m_OutboundContext.m_pCurrentCommandContext = NULL;
                    } else {
                        m_ResponseContext.m_dwResponseStatus = EXPE_COMPLETE_FAILURE;
                        m_OutboundContext.m_pCurrentCommandContext = NULL;
                    }
                    return (TRUE);
                }
            }
        }

        //Set the flags back
        hr = m_pIMsgRecips->PutDWORD(m_RcptIndexList[NextAddress], IMMPID_RP_RECIPIENT_FLAGS,dwRecipientFlags);
        if (FAILED(hr)) {
            //Problemmo
            SetLastError(ERROR_OUTOFMEMORY);
            TraceFunctLeaveEx((LPARAM)this);
            return (FALSE);
        }

        NextAddress++;
    }

    // Mark where we should pick up next time ...
    m_FirstPipelinedAddress = NextAddress;

    // No more unprocessed recipients, we are either done or we have to
    // issue more RCPT commands
    if ((NextAddress < m_NumRcpts) && !m_SendAgain)
        m_ResponseContext.m_dwResponseStatus = EXPE_REPEAT_COMMAND;


    TraceFunctLeaveEx((LPARAM)this);
    return (TRUE);
}



/*++

    Name :
        SMTP_CONNOUT::DoDATACommand

    Description:

        Responds to the SMTP DATA command.
    Arguments:

        InputLine - Buffer received from client
        paramterSize - amount of data in buffer

        both are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoDATACommand(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    _ASSERT(QuerySmtpInstance() != NULL);

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoDATACommand");

    SetNextState (&SMTP_CONNOUT::DoDATACommandEx);

    FormatSmtpMessage(FSM_LOG_ALL, "DATA\r\n");
    TraceFunctLeaveEx((LPARAM)this);
    return SendSmtpResponse();
}

/*++

    Name :
        SMTP_CONNOUT::DoBDATCommand

    Description:

        Send out the SMTP BDAT command.
    Arguments:

        InputLine - Buffer received from client
        paramterSize - amount of data in buffer

        both are ignored
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoBDATCommand(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    _ASSERT(QuerySmtpInstance() != NULL);

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoBDATCommand");

    SetNextState (&SMTP_CONNOUT::DoDATACommandEx);

    //We send the whole mesage file as a single BDAT chunk
    //Verify if the CHUNK size should be FileSize or +2 for trailing CRLF
    //
    FormatSmtpMessage(FSM_LOG_ALL, "BDAT %d LAST\r\n", m_FileSize);
    if (!SendSmtpResponse()) {
        //BDAT command failed for some reason
        DebugTrace((LPARAM) this, "Failed to send BDAT command");
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return DoDATACommandEx(InputLine, ParameterSize, UndecryptedTailSize);
}


/*++

    Name :
        SMTP_CONNOUT::DoDATACommandEx

    Description:

        This funcion sends the message body to remote server
        after the DATA or BDAT command
    Arguments:

        InputLine - Buffer received from remote Server
        paramterSize - amount of data in buffer
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoDATACommandEx(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    LARGE_INTEGER LSize = {0,0};
    BOOL fRet = TRUE;
    HRESULT hr = S_OK;
    char szResponse[] = "123";
    LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoDATACommandEx");

    //we need to receive a 354 from the server to go on in case of DATA command
    // In case of BDAT, the remote server never responds and so ignore the input line
    //
    if (InputLine[0] == SMTP_INTERMEDIATE_SUCCESS || m_fUseBDAT) {
        SetNextState (&SMTP_CONNOUT::DoContentResponse);

        LSize.HighPart = 0;
        LSize.LowPart = m_FileSize;
        m_LastClientIo = SMTP_CONNOUT::TRANSFILEIO;
        //use the trailer buffers only for DATA command
        lpTransmitBuffers = (m_fUseBDAT) ?  NULL : &m_TransmitBuffers;

        fRet = TransmitFileEx ((!m_fUseBDAT && m_IMsgDotStuffedFileHandle) ? m_IMsgDotStuffedFileHandle->m_hFile : m_IMsgFileHandle->m_hFile,
                               LSize,
                               0,
                               lpTransmitBuffers);
        if (!fRet) {
            m_Error = GetLastError();
            DebugTrace((LPARAM) this, "TranmitFile in DoDATACommandEx failed with error %d !!!!", m_Error);
            DisconnectClient();
            return FALSE;
        }

        //need to reset the ATQ timeout thread since we pended two
        //I/Os back to back.
        AtqContextSetInfo(QueryAtqContext(), ATQ_INFO_RESUME_IO, 0);

    } else { //quit if we don't get the 354 response
        SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, "DATA", InputLine);
        ErrorTrace((LPARAM) this, "DoDATACommandEx executing quit command err = %c%c%c", InputLine [0],InputLine [1],InputLine [2]);

        if (InputLine[0] == SMTP_COMPLETE_SUCCESS) {
            CopyMemory(InputLine, "599", 3);
            DebugTrace((LPARAM) this, "DoDATACommandEx executing quit command err = %c%c%c", InputLine [0],InputLine [1],InputLine [2]);
        }

        //DoCompletedMessage uses the m_ResponseContext to get the error
        if ((ParameterSize > 3) &&
            ((InputLine[3] == ' ') || (InputLine[3] == CR))) {
            //Try to get error from 3 digit code on input line
            //In some cases (DoDataCommandEx), the m_ResponseContext is not
            //used
            memcpy(szResponse, InputLine, sizeof(szResponse)-sizeof(char));
            m_ResponseContext.m_dwSmtpStatus = atoi(szResponse);
            hr = m_ResponseContext.m_cabResponse.Append(
                                           InputLine + sizeof(szResponse)/sizeof(char),
                                           ParameterSize-sizeof(szResponse),
                                           NULL);
            if (FAILED(hr))
            {
                ErrorTrace((LPARAM) this,
                    "Unable to append Input line to Response Context", hr);

                //Really nothing we can do about this... DoCompletedMailObj
                //will send RSET and try again
            }
        }

        fRet = DoCompletedMessage(InputLine, ParameterSize, UndecryptedTailSize);

        //If DoCompletedMessage returns TRUE... then we must post a read for the
        //response. Functions that call into this function expect it to handle
        //the IO state if it returns TRUE.
        if (fRet)
        {
            if (m_cbReceived >= m_cbMaxRecvBuffer)
                m_cbReceived = 0;

            IncPendingIoCount();
            m_LastClientIo = SMTP_CONNOUT::READIO;
            fRet = ReadFile(QueryMRcvBuffer() + m_cbReceived,
                               m_cbMaxRecvBuffer - m_cbReceived);
            if (!fRet) {
                m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
                m_Error = GetLastError();
                SetDiagnosticInfo(HRESULT_FROM_WIN32(m_Error), NULL, NULL);
                DisconnectClient();
                DecPendingIoCount();
                DebugTrace((LPARAM) this, "ReadFile in DoDataCommandEx failed with error %d", m_Error);
            }
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

/*++

    Name :
        SMTP_CONNOUT::DoContentResponse

    Description:

        This function catches the final response after transmitting
        the message content

    Arguments:

        InputLine - Buffer received from remote Server
        paramterSize - amount of data in buffer
    Returns:

      TRUE if the connection should stay open.
      FALSE if this object should be deleted.

--*/
BOOL SMTP_CONNOUT::DoContentResponse(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoContentResponse");

    //send again gets sent when we get a 552 error during the
    //RCPT to command.  This means that the server we connected
    //to has a fixed max amount of rcpts that it accepts, and we
    //went over that limit.  Therefore, we send the mail file to
    //the recipients that it accepted and then start over sending
    //the mail to the remaining recipients.  However, before doing
    //this, check the response to see if the server took the previous
    //mail O.K.
    if (m_SendAgain) {
        m_cbReceived = 0;
        m_OutputBufferSize = 0;
        m_Error = NO_ERROR;
        m_NumRcptSent = 0;
        m_NumRcptSentSaved = 0;
        m_NumFailedAddrs = 0;

        //NK** : I am moving this down as the check below seems
        //meaningless with this in here
        //m_SendAgain = FALSE;
        m_FirstRcpt = FALSE;

        _ASSERT(m_First552Address != -1);

        //NK** : I am not sure what we are trying to do here by setting pipelined addr to 552addr.
        //I am going to leave this in - but also assign this value to NextAddr which decides
        //from where we should really start
        m_FirstPipelinedAddress  = (DWORD) m_First552Address;
        m_NextAddress  = (DWORD) m_First552Address;
        m_FirstAddressinCurrentMail = (DWORD) m_First552Address;

        m_First552Address = -1;

        m_TransmitTailBuffer[0] = '.';
        m_TransmitTailBuffer[1] = '\r';
        m_TransmitTailBuffer[2] = '\n';

        m_TransmitBuffers.Head = NULL;
        m_TransmitBuffers.HeadLength = 0;
        m_TransmitBuffers.Tail = m_TransmitTailBuffer;
        m_TransmitBuffers.TailLength = 3;

        BUMP_COUNTER(QuerySmtpInstance(), NumMsgsSent);

        //reset the file pointer to the beginning
        if (SetFilePointer(m_IMsgDotStuffedFileHandle ? m_IMsgDotStuffedFileHandle->m_hFile: m_IMsgFileHandle->m_hFile, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF)
        {
            m_Error = GetLastError();
            DebugTrace((LPARAM) this, "SetFilePointer failed--err = %d", m_Error);
            m_SendAgain = FALSE;
        } else if (InputLine [0] != SMTP_COMPLETE_SUCCESS) {
            //something went wrong before, so let's quit
            DebugTrace((LPARAM) this,
                       "SMTP_CONNOUT::DoMAILCommand executing quit command err = %c%c%c",
                       InputLine [0],InputLine [1],InputLine [2]);
            m_SendAgain = FALSE;
        }
    }

    // Note the if clause above might change this flag so a simple
    // else won't cut it
    if (!m_SendAgain) {
        fRet = DoCompletedMessage(InputLine, ParameterSize, UndecryptedTailSize);
    } else {
        m_SendAgain = FALSE;
        fRet = DoMessageStartEvent(InputLine, ParameterSize, UndecryptedTailSize);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return (fRet);
}

BOOL SMTP_CONNOUT::TransmitFileEx (HANDLE hFile, LARGE_INTEGER  &liSize,
                                   DWORD Offset, LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers)

{
    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::TransmitFileEx");

    BOOL fRet;

    _ASSERT(hFile != INVALID_HANDLE_VALUE);
    _ASSERT(liSize.QuadPart > 0);

    QueryAtqContext()->Overlapped.Offset = Offset;

    if (!m_SecurePort) {
        DebugTrace((LPARAM) this, "Calling AtqTransmitFile");

        TraceFunctLeaveEx((LPARAM)this);

        IncPendingIoCount();

        fRet = AtqTransmitFile(
                              QueryAtqContext(),          // Atq context
                              hFile,                      // file data comes fro
                              liSize.LowPart,                     // Bytes To Send
                              lpTransmitBuffers,          // header/tail buffers
                              0
                              );

        if (!fRet) {
            DecPendingIoCount();
        }

        return ( fRet );

    } else {

        //
        // If we are connected over an SSL port, we cannot use TransmitFile,
        // since the data has to be encrypted first.
        //

        DebugTrace((LPARAM)this, "Doing async reads and writes on handle %x", hFile);

        DebugTrace( (DWORD_PTR)this, "hfile  %x", hFile );

        //
        // Send the transmit buffer header synchronously
        //

        fRet = TRUE;

        //We have no headers or Trailers if we are doing BDAT processing
        if (lpTransmitBuffers && m_TransmitBuffers.HeadLength > 0) {
            m_OutputBufferSize = m_cbMaxOutputBuffer;

            //NimishK : We look for Head length and then send Tail
            //Dosn't seem right.
            fRet = m_encryptCtx.SealMessage(
                                           (LPBYTE) m_TransmitBuffers.Tail,
                                           m_TransmitBuffers.TailLength,
                                           (LPBYTE) m_pOutputBuffer,
                                           &m_OutputBufferSize);

            if (fRet)
                fRet = WriteFile(m_pOutputBuffer, m_OutputBufferSize);
            else
                SetLastError(AQUEUE_E_SSL_ERROR);
        }

        if (fRet) {
            //
            // issue the first async read against the file
            //
            m_dwFileOffset = 0;
            m_bComplete = FALSE;

            if ( MessageReadFile() ) {
                TraceFunctLeaveEx((LPARAM) this);
                return  TRUE;
            }
        }

        //
        // WriteFile\MessageReadFile will teardown the connection on errors
        //
        TraceFunctLeaveEx((LPARAM) this);
        return  FALSE;

    }

}

/*++

    Name:
        SMTP_CONNOUT::MessageReadFile

    Description:
        When TransmitFile cannot be used to transfer a message (for example,
        when using SSL), the message is transferred in chunks using
        MessageReadFile to retrieve chunks of the file and issueing
        corresponding asynchronous WriteFiles to the remote server.

    Arguments:
        None.

    Returns:
        TRUE if successfully read the next chunk of the file, FALSE otherwise

--*/

BOOL SMTP_CONNOUT::MessageReadFile( void )
{
    TraceFunctEnterEx( (LPARAM)this, "SMTP_CONNOUT::MessageReadFile");

    //
    // Main line code path
    //
    CBuffer*    pBuffer = new CBuffer();
    if ( pBuffer != NULL ) {
        LPBYTE  lpData = pBuffer->GetData();
        if ( lpData != NULL ) {
            DWORD cbBufSize = CIoBuffer::Pool.GetInstanceSize();
            // we never want to make SSL data > 16k
            if (cbBufSize > 16*1024) cbBufSize = 16*1024;
            DWORD cb =  cbBufSize -
                        m_encryptCtx.GetSealHeaderSize() -
                        m_encryptCtx.GetSealTrailerSize();

            lpData += m_encryptCtx.GetSealHeaderSize();

            cb = min( cb, m_FileSize - m_dwFileOffset );

            //
            // set buffer specific IO state
            //
            pBuffer->SetIoState( MESSAGE_READ );
            pBuffer->SetSize( cb );

            DebugTrace( (LPARAM)this, "ReadFile 0x%08X, len: %d, LPO: 0x%08X",
                        lpData,
                        cb,
                        &pBuffer->m_Overlapped.SeoOverlapped.Overlapped );

            ZeroMemory( (void*)&pBuffer->m_Overlapped.SeoOverlapped, sizeof(OVERLAPPED) );
            pBuffer->m_Overlapped.SeoOverlapped.Overlapped.Offset = m_dwFileOffset;

            pBuffer->m_Overlapped.SeoOverlapped.Overlapped.pfnCompletion = FIOInternetCompletion;
            pBuffer->m_Overlapped.SeoOverlapped.ThisPtr = this;

//            pBuffer->m_Overlapped.m_pIoBuffer = (LPBYTE)InputLine;

            //
            // increment the overall pending io count for this session
            //
            IncPendingIoCount();

            if ( FIOReadFile(m_IMsgDotStuffedFileHandle ? m_IMsgDotStuffedFileHandle : m_IMsgFileHandle,
                             lpData,
                             cb,
                             &pBuffer->m_Overlapped.SeoOverlapped.Overlapped ) == FALSE ) {
                DecPendingIoCount();
                ErrorTrace( (LPARAM)this, "AtqReadFile failed.");
            } else {
                TraceFunctLeaveEx((LPARAM) this);
                return  TRUE;
            }
        }
        delete  pBuffer;
    }

    m_Error = GetLastError();

    ErrorTrace( (LPARAM)this, "MessageReadFile failed. err: %d", m_Error );
    DisconnectClient();
    TraceFunctLeaveEx((LPARAM)this);

    return  FALSE;
}

/*++

    Name :
        SMTP_CONNOUT::FreeAtqFileContext

    Description :
        Frees AtqContext associated with message files transfered using
        async reads and writes.

    Arguments :
        None. Operates on m_pAtqFileContext

    Returns :
        Nothing

--*/

void SMTP_CONNOUT::FreeAtqFileContext( void )
{
    PATQ_CONTEXT    pAtq;

    TraceFunctEnterEx((LPARAM) this, "SMTP_CONNOUT::FreeAtqFileContext");

#if 0
    pAtq = (PATQ_CONTEXT)InterlockedExchangePointer( (PVOID *)&m_pAtqFileContext, (PVOID) NULL );
    if ( pAtq != NULL ) {
        DebugTrace((LPARAM) this, "Freeing AtqFileContext!");
        pAtq->hAsyncIO = NULL;
        AtqFreeContext( pAtq, FALSE );
    }
#endif

    TraceFunctLeaveEx((LPARAM) this);
}

/*++

    Name :
        SMTP_CONNOUT::DoCompletedMessage

    Description:

        Sends the SMTP QUIT command.
        This function always returns false.
        This will stop all processing and
        delete this object.

    Arguments:
        Are ignored
    Returns:

      Always return FALSE

--*/
BOOL SMTP_CONNOUT::DoCompletedMessage(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    BOOL fRet = TRUE;
    DWORD MsgStatus = 0;
    DWORD Error = 0;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoCompletedMessage");

    //see if the response received has some bad code
    if (InputLine[0] != SMTP_COMPLETE_SUCCESS) {
        //  NimishK :
        //Assumption : If I get 5XX response that leads to DOQUIT it means something real bad happened.
        //We will consider this as a permanent error and NDR all recipients
        //If the code is 4XX we will Retry all recipients
        if (InputLine[0] == SMTP_COMPLETE_FAILURE) {
            MsgStatus = MESSAGE_STATUS_NDR_ALL | MESSAGE_STATUS_EXTENDED_STATUS_CODES;
        } else {
            MsgStatus = MESSAGE_STATUS_RETRY_ALL | MESSAGE_STATUS_EXTENDED_STATUS_CODES;
            if (m_fHadHardError) {
                MsgStatus |= MESSAGE_STATUS_CHECK_RECIPS;
            }
        }
        if (m_ResponseContext.m_cabResponse.Length() > 1) {
            InputLine = m_ResponseContext.m_cabResponse.Buffer();
            ParameterSize = m_ResponseContext.m_cabResponse.Length();
            Error = m_ResponseContext.m_dwSmtpStatus;
        }

    } else if (m_Error == NO_ERROR) {
        //if the message was delivered successfully
        //then bump up our counter
        BUMP_COUNTER(QuerySmtpInstance(), NumMsgsSent);

        if (!IsOptionSet(DSN_OPTION)) {
            MsgStatus |= MESSAGE_STATUS_DSN_NOT_SUPPORTED;
        }

        //If we have generate DELAY DSN or NDR DSN we need to tell
        //AQ to look at the recipients
        if (m_fNeedRelayedDSN || m_fHadHardError) {
            MsgStatus |= MESSAGE_STATUS_CHECK_RECIPS;
        }

        //If we had no failures we can set this special status for optimization
        //if only error we had was a hard error - there is no reason to report anything
        if (!m_fHadTempError && !m_fHadHardError )
            MsgStatus |= MESSAGE_STATUS_ALL_DELIVERED;
        else if (m_fHadTempError)
            MsgStatus |= MESSAGE_STATUS_RETRY_ALL;

    } else {
        //The remote server did not have a problem, but we had internal
        //problem
        //NimishK : Add an extended Status
        MsgStatus = MESSAGE_STATUS_RETRY_ALL;
    }

    //figure out what to do with the completed
    //message(e.g. send to retryq, remoteq, badmail,
    //etc.)

    //Includes per recipient 4xx level errors
    if (InputLine[0] == SMTP_TRANSIENT_FAILURE) {
        //If we cannot connect to the next IpAddress, then ack the message as is
        if (ConnectToNextIpAddress()) {
            //$$REVIEW - mikeswa 9/11/98
            //In this case we will attempt to connect to another IP address.
            //Most of the state is reset at this point (except for recipient
            //failures and status strings).  What happens if we fail to connect?
            //Do we:
            //  - Ack the message as RETRY (current implementation)
            //  - Attempt to ack the message with CHECK_RECIPS as well and
            //    let the per-recip flags be enought detail for the DSN code?
            TraceFunctLeaveEx((LPARAM)this);
            return (FALSE);
        }
    }

    HandleCompletedMailObj(MsgStatus, InputLine, ParameterSize);

    if ((Error == SMTP_SERVICE_UNAVAILABLE_CODE)
        || (Error == SMTP_INSUFF_STORAGE_CODE)|| (Error == SMTP_SERVICE_CLOSE_CODE)
        || QuerySmtpInstance()->IsShuttingDown()) {
        //No point in continuing with other messages in this connection
        //Set the connection ack status to DROPPED - AQ will look at my last
        //Msg Ack and determine what to do with remaining messages
        m_dwConnectionStatus = CONNECTION_STATUS_DROPPED;
        m_Active = FALSE;

        DebugTrace( (LPARAM)this, "got this error %u on response, calling DoSessionEndEvent", Error );
        fRet = DoSessionEndEvent(InputLine, ParameterSize, UndecryptedTailSize);
    } else {
        fRet = StartSession();
        if (!fRet) {
            //Set the connection Ack status
            m_dwConnectionStatus = CONNECTION_STATUS_OK;
            DebugTrace( (LPARAM)this, "StartSession failed, calling DoSessionEndEvent", Error );
            fRet = DoSessionEndEvent(InputLine, ParameterSize, UndecryptedTailSize);
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return (fRet);
}

/*++

    Name :
        SMTP_CONNOUT::DoQUITCommand

    Description:

    Just generates a QUIT command

    Arguments:
        Are ignored
    Returns:

      Always return FALSE

--*/
BOOL SMTP_CONNOUT::DoQUITCommand(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoQUITCommand");

    m_OutboundContext.m_dwCommandStatus = EXPE_SUCCESS;

    fRet = PE_FormatSmtpMessage("QUIT\r\n");

    TraceFunctLeaveEx((LPARAM)this);
    return (fRet);
}


/*++

    Name :
        SMTP_CONNOUT::WaitForRSETResponse

    Description:
        Waits for the response to the quit command

    Arguments:
        Are ignored

    Returns:

      FALSE always

--*/
BOOL SMTP_CONNOUT::WaitForRSETResponse(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    BOOL    fRet = TRUE;
    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::WaitForRSETResponse");

    _ASSERT (QuerySmtpInstance() != NULL);

    if (m_RsetReasonCode == BETWEEN_MSG)
        fRet = DoMessageStartEvent(InputLine, ParameterSize, UndecryptedTailSize);
    else if (m_RsetReasonCode == ALL_RCPTS_FAILED) {
        DebugTrace( (LPARAM)this, "m_RsetReasonCode = ALL_RCPTS_FAILED calling DoCompletedMessage" );

        //Check to see if all of the failures were hard (and not transient)
        //If so, set the error code to '5' instead of '4'
        if (!m_fHadTempError) { //no temp errors
            _ASSERT(m_fHadHardError); //therefore all errors must have been 5xx

            //Must have had as many failures as processed RCPT TO's
            _ASSERT(m_NumFailedAddrs >= m_NumRcptSentSaved);
            InputLine[0] = SMTP_COMPLETE_FAILURE;
        } else {
            InputLine[0] = SMTP_TRANSIENT_FAILURE;
        }
        fRet = DoCompletedMessage(InputLine, ParameterSize, UndecryptedTailSize);
    } else if (m_RsetReasonCode == NO_RCPTS_SENT) {
        DebugTrace( (LPARAM)this, "m_RsetReasonCode = NO_RCPTS_SENT calling DoCompletedMessage" );
        InputLine[0] = '2';
        fRet = DoCompletedMessage(InputLine, ParameterSize, UndecryptedTailSize);
    } else if (m_RsetReasonCode == FATAL_ERROR) {
        DebugTrace( (LPARAM)this, "m_RsetReasonCode = FATAL_ERROR calling DoCompletedMessage" );
        //make sure the quit code does not think everything is O.K.
        InputLine[0] = '4';
        fRet = DoCompletedMessage(InputLine, ParameterSize, UndecryptedTailSize);
    }
    return (fRet);
}

/*++

    Name :
        SMTP_CONNOUT::WaitForQuitResponse

    Description:
        Waits for the response to the quit command

    Arguments:
        Are ignored

    Returns:

      FALSE always

--*/
BOOL SMTP_CONNOUT::WaitForQuitResponse(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    _ASSERT (QuerySmtpInstance() != NULL);
    DisconnectClient();
    return (FALSE);
}

BOOL SMTP_CONNOUT::DoTURNCommand(char * InputLine, DWORD ParameterSize, DWORD UndecryptedTailSize)
{
    CLIENT_CONN_PARAMS clientParams;
    SMTP_CONNECTION * SmtpConnIn = NULL;
    DWORD Error = 0;

    TraceFunctEnterEx((LPARAM) this,"SMTP_CONNOUT::DoTURNCommand");

    if (InputLine[0] != SMTP_COMPLETE_SUCCESS) {
        SetDiagnosticInfo(AQUEUE_E_SMTP_PROTOCOL_ERROR, "TURN", InputLine);
        FormatSmtpMessage(FSM_LOG_ALL, "QUIT\r\n");
        SendSmtpResponse();
        DisconnectClient();
        return FALSE;
    }

    SOCKADDR_IN  sockAddr;
    int cbAddr = sizeof( sockAddr);

    if ( getsockname((SOCKET) m_pAtqContext->hAsyncIO,
                     (struct sockaddr *) &sockAddr,
                     &cbAddr )) {

    }

    clientParams.sClient = (SOCKET) m_pAtqContext->hAsyncIO;
    clientParams.pAtqContext = m_pAtqContext;
    clientParams.pAddrLocal = (PSOCKADDR) NULL;
    clientParams.pAddrRemote = (PSOCKADDR)&sockAddr;
    clientParams.pvInitialBuff = NULL;
    clientParams.cbInitialBuff = 0 ;
    clientParams.pEndpoint = (PIIS_ENDPOINT)NULL;

    QuerySmtpInstance()->Reference();
    QuerySmtpInstance()->IncrementCurrentConnections();

    SmtpConnIn = (SMTP_CONNECTION *) QuerySmtpInstance()->CreateNewConnection( &clientParams);
    if (SmtpConnIn == NULL) {
        Error = GetLastError();
        SendSmtpResponse();
        DisconnectClient();
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    //from here on, the smtpout class is responsible for
    //cleaning up the AtqContext
    m_DoCleanup = FALSE;

    //copy the real domain we are connected to.
    AtqContextSetInfo(m_pAtqContext, ATQ_INFO_COMPLETION, (DWORD_PTR) InternetCompletion);
    AtqContextSetInfo(m_pAtqContext, ATQ_INFO_COMPLETION_CONTEXT, (DWORD_PTR) SmtpConnIn);
    AtqContextSetInfo(m_pAtqContext, ATQ_INFO_TIMEOUT, QuerySmtpInstance()->GetRemoteTimeOut());

    if (SmtpConnIn->StartSession()) {

    }

    return ( FALSE );
}

/*++

    Name :
        BOOL SMTP_CONNOUT::SwitchToBigReceiveBuffer

    Description:
        Helper routine to allocate a 32K buffer and use it for posting reads.
        SSL fragments can be up to 32K large, and we need to accumulate an
        entire fragment to be able to decrypt it.

    Arguments:
        none

    Returns:
        TRUE if the receive buffer was successfully allocated, FALSE otherwise

--*/

BOOL SMTP_CONNOUT::SwitchToBigSSLBuffers(void)
{
    char *pTempBuffer;

    pTempBuffer = new char [MAX_SSL_FRAGMENT_SIZE];
    if (pTempBuffer != NULL) {

        m_precvBuffer = pTempBuffer;
        m_cbMaxRecvBuffer = MAX_SSL_FRAGMENT_SIZE;

        pTempBuffer = new char [MAX_SSL_FRAGMENT_SIZE];
        if (pTempBuffer != NULL) {

            m_pOutputBuffer = pTempBuffer;
            m_cbMaxOutputBuffer =  MAX_SSL_FRAGMENT_SIZE;
            return ( TRUE );
        }
    }
    return ( FALSE );
}

/*++

    Name :
        char * IsLineCompleteBW

    Description:

        Looks for a CRLF starting at the back
        of the buffer. This is from some Gibraltar
        code.

    Arguments:

        pchRecv - The buffer to be scanned
        cbRecvd - size of data in the buffer
    Returns:

      A pointer where the CR is if both CRLF is found,
      or NULL

--*/
char * IsLineCompleteBW(IN OUT char *  pchRecvd, IN  DWORD cbRecvd, IN DWORD cbMaxRecvBuffer)
{
    register int Loop;

    _ASSERT( pchRecvd != NULL);

    if (cbRecvd == 0)
        return NULL;

    if (cbRecvd > cbMaxRecvBuffer)
        return NULL;
    //
    //  Scan the entire buffer ( from back) looking for pattern <cr><lf>
    //
    for ( Loop = (int) (cbRecvd - 2); Loop >= 0; Loop-- ) {
        //
        //  Check if consecutive characters are <cr> <lf>
        //

        if ( ( pchRecvd[Loop]   == '\r')  &&
             ( pchRecvd[Loop + 1]== '\n')) {
            //return where the CR is in the buffer
            return &pchRecvd[Loop];
        }

    } // for

    return (NULL);
}

/*++

    Name :
        SMTP_CONNOUT::PE_FormatSmtpMessage( IN const char * Format, ...)

    Description:
        This function operates likes sprintf, printf, etc. It
        just places it's data in the native command output buffer.

    Arguments:
         Format - Data to place in the buffer

    Returns:


--*/
BOOL SMTP_CONNOUT::PE_FormatSmtpMessage( IN const char * Format, ...)
{
    int BytesWritten;
    va_list arglist;

    //if BytesWritten is < 0, that means there is no space
    //left in the buffer.  Therefore, we flush any pending
    //responses to make space.  Then we try to place the
    //information in the buffer again.  It should never
    //fail this time.
    va_start (arglist, Format);

    _ASSERT(m_OutboundContext.m_cabNativeCommand.Buffer());
    BytesWritten = _vsnprintf(
                             (char *)m_OutboundContext.m_cabNativeCommand.Buffer(),
                             m_OutboundContext.m_cabNativeCommand.MaxLength(),
                             Format,
                             arglist);
    va_end(arglist);
    if (BytesWritten < 0)
        return (FALSE);

    m_OutboundContext.m_cabNativeCommand.SetLength(BytesWritten);
    return (TRUE);
}

//---[ SMTP_CONNOUT::SetDiagnosticInfo ]---------------------------------------
//
//
//  Description:
//      Sets member diagnostic information that is later Ack'd back to AQueue
//  Parameters:
//      IN      hrDiagnosticError       Error code... if SUCCESS we thow away
//                                      the rest of the information
//      IN      szDiagnosticVerb        Constant String pointing to the SMTP
//                                      verb that caused the failure or NULL
//                                      if it was not a protocol failure.
//      IN      szDiagnosticResponse    String that contains the remote
//                                      servers response or NULL if the
//                                      failure was not a protocol failure.
//  Returns:
//      -
//  History:
//      2/18/99 - MikeSwa Created
//      7/12/99 - GPulla Modified
//
//-----------------------------------------------------------------------------
void SMTP_CONNOUT::SetDiagnosticInfo(IN  HRESULT hrDiagnosticError,
                                     IN  LPCSTR szDiagnosticVerb,
                                     IN  LPCSTR szDiagnosticResponse)
{
    m_hrDiagnosticError = hrDiagnosticError;
    m_szDiagnosticVerb = szDiagnosticVerb; //this should be a constant

    ZeroMemory(&m_szDiagnosticResponse, sizeof(m_szDiagnosticResponse));

    //Force terminating NULL
    m_szDiagnosticResponse[sizeof(m_szDiagnosticResponse)-1] = '\0';

    //Not an SMTP protocol failure
    if(!szDiagnosticResponse) return;

    //copy buffers
    strncpy(m_szDiagnosticResponse, szDiagnosticResponse,
            sizeof(m_szDiagnosticResponse)-1);

}

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\spinlock.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: spinlock.h
//
// Contents: Spinlock package
//
// Classes:
//
// Functions:
//
// History:
// jstamerj 980511 17:25:05: Created.
//
//-------------------------------------------------------------
#include <windows.h>

//
// Simple spinlock package used by CLdapConnection
//

typedef LONG SPIN_LOCK;
typedef LPLONG PSPIN_LOCK;

typedef VOID (__stdcall *PFN_ACQUIRESPINLOCK)(PSPIN_LOCK);

extern PFN_ACQUIRESPINLOCK g_AcquireSpinLock;

VOID InitializeSpinLock(
    PSPIN_LOCK psl);

#define AcquireSpinLock (*g_AcquireSpinLock)

VOID AcquireSpinLockSingleProc(
    PSPIN_LOCK psl);
VOID AcquireSpinLockMultipleProc(
    PSPIN_LOCK psl);
VOID ReleaseSpinLock(
    PSPIN_LOCK psl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\smtpinst.cxx ===
/*++

   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        smtpinst.cxx

   Abstract:

        This module defines the SMTP_SERVER_INSTANCE class

   Author:

        Johnson Apacible    (JohnsonA)      June-04-1996


    Revision History:

        David Howell        (dhowell)       May-1997    Added Etrn Logic
        Nimish Khanolkar    (NimishK)       Jan - 1998 - modified for CAPI store ce


--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include <iis64.h>
#include "iiscnfg.h"
#include <mdmsg.h>
#include <commsg.h>
#include <imd.h>
#include <mb.hxx>

#include <nsepname.hxx>
#include "smtpcli.hxx"
#include "dirnot.hxx"
#include <smtpinet.h>

// SEO Header files
#define _ATL_NO_DEBUG_CRT
#define _ATL_STATIC_REGISTRY 1
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL

#include "smtpsvr.h"
#include "seo.h"
#include "seolib.h"
#include "smtpdisp.h"
#include "seodisp.h"

#include "seo_i.c"
#include "tran_evntlog.h"

extern "C" {
    int strcasecmp(char *s1, char *s2);
    int strncasecmp(char *s1, char *s2, int n);
}

#define STORE_DRIVER_PROGID L"Exchange.NtfsDrv"
#define SMTPSERVER_PROGID L"SMTPServer.SMTPServer.1"

#if 0
extern VOID
ServerEventCompletion(
                     PVOID        pvContext,
                     DWORD        cbWritten,
                     DWORD        dwCompletionStatus,
                     OVERLAPPED * lpo
                     );
#endif

//extern "C++" {
//BOOL g_IsShuttingDown = FALSE;
//}

DWORD BuildInitialQueueProc(void *lpThis);
VOID ProcessInitialQueueObjects(PVOID       pvContext,
                                DWORD       cbWritten,
                                DWORD       dwCompletionStatus,
                                OVERLAPPED  *lpo);

DWORD EnumAllDomains(void *ptr);

//
//  Constants
//

//
// Globals
//

#define MAX_CONNECTION_OBJECTS 5000
#define DEFAULT_LOGON_METHOD   LOGON32_LOGON_INTERACTIVE
#define DEFAULT_USE_SUBAUTH    TRUE
#define DEFAULT_ANONYMOUS_PWD           ""

PFN_SF_NOTIFY   g_pSslKeysNotify = NULL;
extern STORE_CHANGE_NOTIFIER *g_pCAPIStoreChangeNotifier;

SmtpMappingSupportFunction(
                          PVOID pvInstance,
                          PVOID pData,
                          DWORD dwPropId);

SERVICE_MAPPING_CONTEXT g_SmtpSMC = { SmtpMappingSupportFunction};

//
//  Prototypes
//
BOOL
SetSslKeysNotify(
                PFN_SF_NOTIFY pFn
                );


/************************************************************
 *  Symbolic Constants
 ************************************************************/

static TCHAR    szServicePath[] = TEXT("System\\CurrentControlSet\\Services\\");
static TCHAR    szParametersKey[] = TEXT("\\Parameters");
static TCHAR    szParamPath[] = TEXT("System\\CurrentControlSet\\Services\\SmtpSvc\\Parameters");
static WCHAR    szParamPathW[] = L"System\\CurrentControlSet\\Services\\SmtpSvc\\Parameters";
static TCHAR    szTcpipPath[] = TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters");
static TCHAR    szTcpipTransient[] = TEXT("Transient");
static TCHAR    szMaxSmtpErrors[] = TEXT("MaxErrors");
static WCHAR    szMaxSmtpErrorsW[] = L"MaxErrors";
static TCHAR    szMaxRemoteTimeOut[] = TEXT("MaxRemoteTimeOut");
static WCHAR    szMaxRemoteTimeOutW[] = L"MaxRemoteTimeOut";
static TCHAR    szMaxMsgSize[] = TEXT("MaxMsgSize");
static WCHAR    szMaxMsgSizeW[] = L"MaxMsgSize";
static TCHAR    szMaxMsgSizeBeforeClose[] = TEXT("MaxMsgSizeBeforeClose");
static WCHAR    szMaxMsgSizeBeforeCloseW[] = L"MaxMsgSizeBeforeClose";
static TCHAR    szMaxRcpts[] = TEXT("MaxRcpts");
static WCHAR    szMaxRcptsW[] = L"MaxRcpts";
static TCHAR    szEnableReverseLookup[] = TEXT("EnableReverseLookup");
static WCHAR    szEnableReverseLookupW[] = L"EnableReverseLookup";
static TCHAR    szDomains[] = TEXT("Domains");
static WCHAR    szDomainsW[] = L"Domains";
static TCHAR    szNameResolution[] = TEXT("NameResolution");
static WCHAR    szNameResolutionW[] = L"NameResolution";
static TCHAR    szSmartHostType[] = TEXT("SmartHostUseType");
static WCHAR    szSmartHostTypeW[] = L"SmartHostUseType";
static TCHAR    szRetryAttempts[] = TEXT("MaxRetryAttempts");
static WCHAR    szRetryAttemptsW[] = L"MaxRetryAttempts";
static TCHAR    szRetryMinutes[] = TEXT("MaxRetryMinutes");
static WCHAR    szRetryMinutesW[] = L"MaxRetryMinutes";
static TCHAR    szShouldPipelineOut[] = TEXT("PipelineOutput");
static WCHAR    szShouldPipelineOutW[] = L"PipelineOutput";
static TCHAR    szShouldPipelineIn[] = TEXT("PipelineInput");
static WCHAR    szShouldPipelineInW[] = L"PipelineInput";
static TCHAR    szMaxHopCount[] = TEXT("MaxHopCount");
static WCHAR    szMaxHopCountW[] = L"MaxHopCount";
static TCHAR    szMaxOutConnections[] = TEXT("MaxOutConnections");
static WCHAR    szMaxOutConnectionsW[] = L"MaxOutConnections";
static TCHAR    szSendBadToAdmin[] = TEXT("SendBadToAdmin");
static WCHAR    szSendBadToAdminW[] = L"SendBadToAdmin";
static TCHAR    szSendNDRToAdmin[] = TEXT("SentNDRToAdmin");
static WCHAR    szSendNDRToAdminW[] = L"SentNDRToAdmin";
static TCHAR    szRoutingSources[] = TEXT("RoutingSources");
static WCHAR    szRoutingSourcesW[] = L"RoutingSources";
static TCHAR    szRoutingThreads[] = TEXT("RoutingThreads");
static WCHAR    szRoutingThreadsW[] = L"RoutingThreads";
static TCHAR    szDirBuffers[] = TEXT("MaxDirectoryBuffers");
static WCHAR    szDirBuffersW[] = L"MaxDirectoryBuffers";
static TCHAR    szDirBuffersSize[] = TEXT("DirectoryBuffSize");
static WCHAR    szDirBuffersSizeW[] = L"DirectoryBufferSize";
static TCHAR    szDirPendingIos[] = TEXT("NumDirPendingIos");
static WCHAR    szDirPendingIosW[] = L"NumDirPendingIos";
static TCHAR    szBadMailDir[] = TEXT("BadMailDir");
static WCHAR    szBadMailDirW[] = L"BadMailDir";

static TCHAR    szMailQueueDir[] = TEXT("MailQueueDir");
static WCHAR    szMailQueueDirW[] = L"MailQueueDir";
static TCHAR    szShouldDeliver[] = TEXT("ShouldDeliver");
static WCHAR    szShouldDeliverW[] = L"ShouldDeliver";
static TCHAR    szShouldDelete[] = TEXT("ShouldDelete");
static WCHAR    szShouldDeleteW[] = L"ShouldDelete";
static TCHAR    szDeleteDir[] = TEXT("DeleteDir");
static WCHAR    szDeleteDirW[] = L"DeleteDir";
static TCHAR    szMaxAddrObjects[] = TEXT("MaxAddressObjects");
static WCHAR    szMaxAddrObjectsW[] = L"MaxAddressObjects";
static TCHAR    szMaxMailObjects[] = TEXT("MaxMailObjects");
static WCHAR    szMaxMailObjectsW[] = L"MaxMailObjects";
static TCHAR    szRoutingDll[] = TEXT("RoutingDll");
static WCHAR    szRoutingDllW[] = L"RoutingDll";
static TCHAR    szUseFileLinks[] = TEXT("UseFileLinks");
static WCHAR    szUseFileLinksW[] = L"UseFileLinks";
static TCHAR    szMsgBatchLimit[] = TEXT("BatchMsgLimit");
static WCHAR    szMsgBatchLimitW[] = L"BatchMsgLimit";
static TCHAR    szMailPickupDir[] = TEXT("MailPickupDir");
static WCHAR    szMailPickupDirW[] = L"MailPickupDir";
static TCHAR    szMailDropDir[] = TEXT("MailDropDir");
static WCHAR    szMailDropDirW[] = L"MailDropDir";
static TCHAR    szShouldPickupMail[] = TEXT("ShouldPickupMail");
static WCHAR    szShouldPickupMailW[] = L"ShouldPickupMail";
static TCHAR    szCommandLogMask[] = TEXT("CommandLogMask");
static WCHAR    szCommandLogMaskW[] = L"CommandLogMask";
static TCHAR    szShowEightBitMime[] = TEXT("ShowEightBitMime");
static WCHAR    szShowEightBitMimeW[] = L"ShowEightBitMime";
static TCHAR    szShowBinaryMime[] = TEXT("ShowBinaryMime");
static WCHAR    szShowBinaryMimeW[] = L"ShowBinaryMime";
static TCHAR    szShowChunking[] = TEXT("ShowChunking");
static WCHAR    szShowChunkingW[] = L"ShowChunking";
static TCHAR    szFlushMailFiles[] = TEXT("FlushMailFiles");
static WCHAR    szFlushMailFilesW[] = L"FlushMailFiles";
static TCHAR    szVirtualRoot[] = TEXT("Virtual Roots");
static WCHAR    szVirtualRootW[] = L"Virtual Roots";

static TCHAR    szRRetryAttempts[] = TEXT("MaxRemoteRetryAttempts");
static WCHAR    szRRetryAttemptsW[] = L"MaxRemoteRetryAttempts";
static TCHAR    szRRetryMinutes[] = TEXT("MaxRemoteRetryMinutes");
static WCHAR    szRRetryMinutesW[] = L"MaxRemoteRetryMinutes";

static TCHAR    szShareRetryMinutes[] = TEXT("MaxShareRetryMinutes");
static WCHAR    szShareRetryMinutesW[] = L"MaxShareRetryMinutes";


// Always use ANSI for Internet compatibility, even if UNICODE is defined
static WCHAR    szDefaultDomainW[] = L"DefaultDomain";
static TCHAR    szDefaultDomain[] = TEXT("DefaultDomain");
static WCHAR    szConnectResponseW[] = L"ConnectResponse";
static TCHAR    szConnectResponse[] = TEXT("ConnectResponse");
static WCHAR    szSmartHostNameW[] = L"SmartHost";
static TCHAR    szSmartHostName[] = TEXT("SmartHost");


//
// Added by keithlau on 7/12/96
//
#define SMTP_EVENTLOG_MAX_ITEMS     10

#define SMTP_INIT_ABSORT          0x00000001
#define SMTP_INIT_CSLOCK          0x00000002
#define SMTP_INIT_OUTLOCK         0x00000004
#define SMTP_INIT_GENLOCK         0x00000008


const LPSTR     pszPackagesDefault = "NTLM\0GSSAPI\0";
const DWORD     ccbPackagesDefault = sizeof( "NTLM\0GSSAPI\0" );

extern AQ_INITIALIZE_EX_FUNCTION g_pfnInitializeAQ;
extern AQ_DEINITIALIZE_EX_FUNCTION g_pfnDeinitializeAQ;

extern HRESULT CallInstanceInitStoreDriver(DWORD InstanceId, IAdvQueue *pIAq, char * UserName,
                                           char * DomainName, char * Password, char * DnToUse);

extern void CallInstanceDeInitStoreDriver(DWORD InstanceId);

//extern HRESULT HrGetGatewayDN(IN OUT DWORD *pcbBuffer,
//                       IN     LPSTR szBuffer);

inline BOOL
ConvertToMultisz(LPSTR szMulti, DWORD *pdwCount, LPSTR szAuthPack)
{
    CHAR *pcStart = szAuthPack, *pc;
    DWORD dw = 0;

    pc = pcStart;
    if (*pc == '\0' || *pc == ',')
        return FALSE;

    *pdwCount = 0;
    while (TRUE) {
        if (*pc == '\0') {
            strcpy(&szMulti[dw], pcStart);
            (*pdwCount)++;
            dw += lstrlen(pcStart);
            szMulti[dw + 1] = '\0';
            return TRUE;
        } else if (*pc == ',') {
            *pc = '\0';
            lstrcpy(&szMulti[dw], pcStart);
            (*pdwCount)++;
            dw += lstrlen(pcStart);
            dw++;
            *pc = ',';
            pcStart = ++pc;
        } else {
            pc++;
        }
    }
}


//
// Quick and dirty range check using inlines (KeithLau 7/28/96)
//
static inline BOOL pValidateRange(DWORD dwValue, DWORD dwLower, DWORD dwUpper)
{
    // Inclusive
    if ((dwValue >= dwLower) && (dwValue <= dwUpper))
        return (TRUE);

    SetLastError(ERROR_INVALID_PARAMETER);
    return (FALSE);
}

//
// Quick and dirty string validation
//
static inline BOOL pValidateStringPtr(LPWSTR lpwszString, DWORD dwMaxLength)
{
    if (IsBadStringPtr((LPCTSTR)lpwszString, dwMaxLength))
        return (FALSE);
    while (dwMaxLength--)
        if (*lpwszString++ == 0)
            return (TRUE);
    return (FALSE);
}


static inline BOOL ConvertFromUnicode(LPWSTR pwsz, char * psz, DWORD cchMax)
/*++
    Converts a given string into unicode string
    Returns FALSE on failure. Use GetLastError() for details.
--*/
{
    DWORD   cch;

    cch = lstrlenW(pwsz) + 1;
    if (cchMax < cch) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    int iRet;

    iRet = WideCharToMultiByte(CP_ACP, 0, pwsz, cch, psz, cchMax, NULL, NULL);

    return (iRet != 0);
} // ConvertToUnicode()

//
// Enumeration stuff
//
DWORD WINAPI EnumBuildQProc(LPVOID  pvContext)
{
    SMTP_SERVER_INSTANCE    *pInst = (SMTP_SERVER_INSTANCE *)pvContext;

    _ASSERT(pInst);

    pInst->TriggerStoreServerEvent(SMTP_STOREDRV_ENUMMESS_EVENT);

    return (NO_ERROR);
}

DWORD
InitializeInstances(
                   PSMTP_IIS_SERVICE pService
                   )
/*++

Routine Description:

    Reads the instances from the metabase

Arguments:

    pService - Server instances added to.

Return Value:

    Win32

--*/
{
    DWORD   i;
    DWORD   cInstances = 0;
    MB      mb( (IMDCOM*) pService->QueryMDObject() );
    CHAR    szKeyName[MAX_PATH+1];
    DWORD   err = NO_ERROR;
    BUFFER  buff;
    BOOL    fMigrateRoots = FALSE;


    //
    //  Open the metabase for write to get an atomic snapshot
    //

    ReOpen:

    if ( !mb.Open( "/LM/SMTPSVC/",
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE )) {
        DBGPRINTF(( DBG_CONTEXT,
                    "InitializeInstances: Cannot open path %s, error %lu\n",
                    "/LM/SMTPSVC/", GetLastError() ));

        //
        //  If the web service key isn't here, just create it
        //

        if ( !mb.Open(METADATA_MASTER_ROOT_HANDLE,
                      METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ||
             !mb.AddObject( "/LM/SMTPSVC/" )) {
            err = GetLastError();
            return err;
        }

        DBGPRINTF(( DBG_CONTEXT,
                    "/LM/SMTPSvc not found, auto-created\n" ));

        mb.Close();
        goto ReOpen;
    }

    //_VERIFY(mb.SetString("", MD_NTAUTHENTICATION_PROVIDERS, IIS_MD_UT_SERVER, "NTLM,LOGIN"));
    DWORD dwVersion;
    if (!mb.GetDword("", MD_SMTP_SERVICE_VERSION, IIS_MD_UT_SERVER, &dwVersion)) {
        _VERIFY(mb.SetDword("", MD_SMTP_SERVICE_VERSION, IIS_MD_UT_SERVER, g_ProductType));
    }
    //_VERIFY(mb.SetDword("", MD_SMTP_AUTHORIZATION, IIS_MD_UT_SERVER, 7));
    //_VERIFY(mb.SetDword("", MD_AUTHORIZATION, IIS_MD_UT_SERVER, 7));



    //
    // Loop through instance keys and build a list.  We don't keep the
    // metabase open because the instance instantiation code will need
    // to write to the metabase
    //

    TryAgain:
    i = 0;
    while ( mb.EnumObjects( "",
                            szKeyName,
                            i++ )) {
        DWORD dwInstance;

        //
        // Get the instance id
        //

        DBGPRINTF((DBG_CONTEXT,"instance key %s\n",szKeyName));

        dwInstance = atoi( szKeyName );
        if ( dwInstance == 0 ) {
            continue;
        }

        if ( buff.QuerySize() < (cInstances + 1) * sizeof(DWORD) ) {
            if ( !buff.Resize( (cInstances + 10) * sizeof(DWORD)) ) {
                return GetLastError();
            }
        }

        ((DWORD *) buff.QueryPtr())[cInstances++] = dwInstance;
    }

    if ( cInstances == 0 ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "No defined instances\n" ));

        if ( !mb.AddObject( "1" )) {
            DBGPRINTF(( DBG_CONTEXT,
                        "Unable to create first instance, error %d\n",
                        GetLastError() ));

            return GetLastError();
        }

        fMigrateRoots = TRUE; // Force reg->metabase migration of virtual directories
        goto TryAgain;
    }

    DBG_REQUIRE( mb.Close() );
    mb.Save();

    for ( i = 0; i < cInstances; i++ ) {
        DWORD dwInstance = ((DWORD *)buff.QueryPtr())[i];

        if ( !g_pInetSvc->AddInstanceInfo( dwInstance, fMigrateRoots ) ) {
            err = GetLastError();

            DBGPRINTF((DBG_CONTEXT,
                       "InitializeInstances: cannot create instance %lu, error %lu\n",
                       dwInstance, err));

            //break;
        }

    }

    return err;

} // InitializeInstances


//+---------------------------------------------------------------
//
//  Function:   StopInstance
//
//  Synopsis:   Callback from IIS_SERVICE iterator
//
//  Arguments:  void
//
//  Returns:    TRUE is success, else FALSE
//
//  History:    HowardCu    Created         23 May 1995
//
//----------------------------------------------------------------

BOOL
StopSmtpInstances(
                 PVOID                   pvContext,
                 PVOID                   pvContext1,
                 PIIS_SERVER_INSTANCE    pInstance
                 )
{
    PSMTP_SERVER_INSTANCE pSmtpInstance = (PSMTP_SERVER_INSTANCE)pInstance;

    if ( !pSmtpInstance->Stop() ) {

    }

    return TRUE;
}

/*++

Routine Description:

    Shutdown each instance and terminate all global cpools

Arguments:

    pService - Server instances added to.

Return Value:

    Win32

--*/
VOID
TerminateInstances( PSMTP_IIS_SERVICE pService)
{
    PFN_INSTANCE_ENUM pfnInstanceEnum = NULL;

    TraceFunctEnter("TerminateInstances");

    //
    //  Iterate over all instances
    //  StopInstance callback calls SMTP_SERVER_INSTANCE::Stop()
    //
    pfnInstanceEnum = (PFN_INSTANCE_ENUM)&StopSmtpInstances;
    if ( !pService->EnumServiceInstances(
                                        NULL,
                                        NULL,
                                        pfnInstanceEnum
                                        ) ) {

        ErrorTrace(0,"Error enumerating instances");
    }

    TraceFunctLeave();
}


SMTP_SERVER_INSTANCE::SMTP_SERVER_INSTANCE(
                                          IN PSMTP_IIS_SERVICE pService,
                                          IN DWORD  dwInstanceId,
                                          IN USHORT Port,
                                          IN LPCSTR lpszRegParamKey,
                                          IN LPWSTR lpwszAnonPasswordSecretName,
                                          IN LPWSTR lpwszVirtualRootsSecretName,
                                          IN BOOL   fMigrateRoots
                                          )
:   IIS_SERVER_INSTANCE(pService,
                        dwInstanceId,
                        Port,
                        lpszRegParamKey,
                        lpwszAnonPasswordSecretName,
                        lpwszVirtualRootsSecretName,
                        fMigrateRoots)
//m_signature (SMTP_SERVER_INSTANCE_SIGNATURE)
{

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE" );

    m_pSmtpStats                = NULL;

    m_IsShuttingDown            = FALSE;
    m_QIsShuttingDown           = FALSE;
    m_RetryQIsShuttingDown      = FALSE;
    m_IsFileSystemNtfs          = TRUE;
    m_fShouldStartAcceptingConnections = TRUE;
    m_SmtpInitializeStatus      = 0;

    m_cCurrentConnections       = 0;
    m_cMaxCurrentConnections    = 0;
    m_cCurrentOutConnections    = 0;
    m_dwNextInboundClientId     = 1;
    m_dwNextOutboundClientId    = 1;
    m_dwStopHint                = 2;
    m_cProcessClientThreads     = 0;
    m_cNumConnInObjsAlloced     = 0;
    m_cNumConnOutObjsAlloced    = 0;
    m_cNumCBufferObjsAlloced    = 0;
    m_cNumAsyncObjsAlloced      = 0;
    m_cNumAsyncDnsObjsAlloced   = 0;
    m_cchConnectResponse        = 0;
    m_cCurrentRoutingThreads    = 0;
    m_cMaxOutConnectionsPerDomain = 0;
    m_cMaxOutConnections        = 0;
    m_cMaxHopCount              = 0;
    m_RemoteSmtpPort            = 0;
    m_cMaxRcpts                 = 0;
    m_fMasquerade               = FALSE;
    m_fIgnoreTime               = FALSE;
    m_fStartRetry               = FALSE;
    m_fRequiresSSL              = FALSE;
    m_fRequires128Bits          = FALSE;
    m_fRequiresCertVerifySubject= FALSE;
    m_fRequiresCertVerifyIssuer = FALSE;
    m_pSSLInfo                  = NULL;
    m_fLimitRemoteConnections   = TRUE;
    m_RDNSOptions               = 0;
    m_fAllowVerify              = FALSE;
    m_InstBooted                = FALSE;
    m_fStoreDrvStartEventCalled  = FALSE;
    m_fStoreDrvPrepShutDownEventCalled = FALSE;
    m_fScheduledConnection      = FALSE;
    m_fIsRoutingTable           = TRUE;
    m_fHaveRegisteredPrincipalNames = FALSE;

    m_fHelloNoValidate          = FALSE;
    m_fMailNoValidate           = FALSE;
    m_fRcptNoValidate           = FALSE;
    m_fEtrnNoValidate           = FALSE;
    m_fPickupNoValidate         = FALSE;
    m_ProviderPackages          = NULL;
    fInitializedAQ = FALSE;
    fInitializedStoreDriver = FALSE;

    // Raid 174038
    m_fDisablePickupDotStuff = FALSE;

    m_szMasqueradeName [0] = '\0';
    m_szMailQueueDir[0] = '\0';
    m_szMailPickupDir[0] = '\0';
    m_szMailDropDir[0] = '\0';
    m_szBadMailDir[0] = '\0';
    m_szMyDomain[0] = '\0';
    m_szDefaultDomain[0] = '\0';
    m_szFQDomainName[0] = '\0';
    m_szSmartHostName[0] = '\0';
    m_AdminName[0] = '\0';
    m_BadMailName[0] = '\0';
    m_DefaultRemoteUserName[0] = '\0';
    m_DefaultRemotePassword[0] = '\0';

    SmtpDir = NULL;
    DirPickupThreadHandle = NULL;
    StopHandle = NULL;
    m_hEnumDomainThreadHandle = NULL;
    m_pChangeObject = NULL;

    m_IAQ = NULL;
    m_ICM = NULL;
    m_pvAQInstanceContext = NULL;
    m_pIAdvQueueConfig = NULL;
    m_RemoteQ = NULL;
    m_ComSmtpServer = NULL;
    m_pSmtpInfo = NULL;

    m_dwEventlogLevel = LOGEVENT_LEVEL_MEDIUM;
    m_dwDnsFlags = 0;

    InitializeCriticalSection( &m_critBoot ) ;
    m_fInitAsyncCS = FALSE;

    m_signature = SMTP_INSTANCE_SIGNATURE;

    TraceFunctLeaveEx((LPARAM)this);
    return;

} // SMTP_SERVER_INSTANCE::SMTP_SERVER_INSTANCE



SMTP_SERVER_INSTANCE::~SMTP_SERVER_INSTANCE(
                                           VOID
                                           )
{
    TraceFunctEnterEx((LPARAM)this, "~SMTP_SERVER_INSTANCE" );

    EnterCriticalSection( &m_critBoot );

    if ( m_InstBooted && !m_fShutdownCalled) {
        InitiateShutDown();
    } else
        ErrorTrace((LPARAM) this, "Shutdown for instance %d was already called", QueryInstanceId());

    LeaveCriticalSection( &m_critBoot );

    DeleteCriticalSection( &m_critBoot ) ;

    TraceFunctLeaveEx((LPARAM) this);
}

//---------------------------------------------------------------------------------------
//  Description:
//      Called by InitiateStartup() to initialize members of SMTP_SERVER_INSTANCE when
//      a VSI is started up. InitiateStartup() is called by IIS to start a VSI.
//  Arguments:
//      None.
//  Returns:
//      None.
//---------------------------------------------------------------------------------------
void SMTP_SERVER_INSTANCE::InitializeClassVariables(void)
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE:InitializeClassVariables" );

    m_pSmtpStats                = NULL;

    m_IsShuttingDown            = FALSE;
    m_QIsShuttingDown           = FALSE;
    m_RetryQIsShuttingDown      = FALSE;
    m_fShouldStartAcceptingConnections = TRUE;
    m_SmtpInitializeStatus      = 0;

    m_cCurrentConnections       = 0;
    m_cMaxCurrentConnections    = 0;
    m_cCurrentOutConnections    = 0;
    m_dwNextInboundClientId     = 1;
    m_dwNextOutboundClientId    = 1;
    m_dwStopHint                = 2;
    m_cProcessClientThreads     = 0;
    m_cNumConnInObjsAlloced     = 0;
    m_cNumConnOutObjsAlloced    = 0;
    m_cNumCBufferObjsAlloced    = 0;
    m_cNumAsyncObjsAlloced      = 0;
    m_cNumAsyncDnsObjsAlloced   = 0;
    m_cchConnectResponse        = 0;
    m_fMasquerade               = FALSE;
    m_fIgnoreTime               = FALSE;
    m_fStartRetry               = FALSE;
    m_fLimitRemoteConnections   = TRUE;
    m_fShutdownCalled           = FALSE;
    m_fSendNDRToAdmin           = FALSE;
    m_fSendBadToAdmin           = FALSE;
    m_fRequiresSASL             = FALSE;
    m_szDefaultLogonDomain[0]   = '\0';
    m_fStoreDrvStartEventCalled  = FALSE;
    m_fStoreDrvPrepShutDownEventCalled = FALSE;

    //directory pickup stuff
    SmtpDir = NULL;
    DirPickupThreadHandle = NULL;
    StopHandle = NULL;
    m_hEnumDomainThreadHandle = NULL;

    // Raid 174038
    m_fDisablePickupDotStuff = FALSE;

    m_QStopEvent = NULL;
    m_hEnumBuildQ = NULL;

    InitializeListHead( &m_ConnectionsList);
    InitializeListHead( &m_OutConnectionsList);
    InitializeListHead( &m_leVRoots);
    InitializeListHead( &m_AsynConnectList);
    InitializeListHead( &m_AsyncDnsList);

    InitializeCriticalSection( &m_csLock);
    m_SmtpInitializeStatus |= SMTP_INIT_CSLOCK;

    _ASSERT(!m_fInitAsyncCS && "Doubly initialized critsec");
    if(!m_fInitAsyncCS) {
        InitializeCriticalSection( &m_csAsyncDns );
        InitializeCriticalSection( &m_csAsyncConnect ) ;
        m_fInitAsyncCS = TRUE;
    }

    m_szConnectResponse[0] = '\0';

    // Set the logging handle
    m_InstancePropertyBag.SetLogging(&m_Logging);

    TraceFunctLeaveEx((LPARAM) this);
}

BOOL SMTP_SERVER_INSTANCE::AllocNewMessage(SMTP_ALLOC_PARAMS * Params)
{
    TraceFunctEnterEx((LPARAM)this, "AllocNewMessage");

    HRESULT  hr = S_OK;
    BOOL fRet = TRUE;

    Params->m_InstanceId = QueryInstanceId();
    Params->m_EventSmtpServer = (PVOID *) m_ComSmtpServer;
    Params->m_pNotify = NULL;

    hr = TriggerServerEvent(SMTP_STOREDRV_ALLOC_EVENT, (PVOID) Params);

    if (FAILED(hr)) {
        fRet = FALSE;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;

}

HRESULT SMTP_SERVER_INSTANCE::SinkReadMetabaseDword(DWORD MetabaseId, DWORD * dwValue)
{
    DWORD tmp = 0;
    HRESULT hr = S_FALSE;
    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );

    if (mb.Open(QueryMDPath())) {
        if ( dwValue && mb.GetDword("", MetabaseId, IIS_MD_UT_SERVER, &tmp)) {
            *dwValue = tmp;
            hr = S_OK;
        }
    }

    return hr;
}

HRESULT SMTP_SERVER_INSTANCE::SinkReadMetabaseString(DWORD MetabaseId, char * Buffer, DWORD * BufferSize, BOOL fSecure)
{
    STR         TempString;
    HRESULT     hr = S_OK;
    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );
    DWORD   MetaOptions = METADATA_INHERIT;

    TempString.Reset();

    if (fSecure) {
        MetaOptions |= METADATA_SECURE;
    }

    if (mb.Open(QueryMDPath())) {
        if (!mb.GetStr("", MetabaseId, IIS_MD_UT_SERVER, &TempString, MetaOptions) ||
            TempString.IsEmpty()) {
            hr = S_FALSE;
        } else {
            lstrcpyn(Buffer,TempString.QueryStr(), MAX_PATH);
        }
    }

    return hr;
}

//---[ SMTP_SERVER_INSTANCE::SinkReadMetabaseData -----------------------------
//
//
//  Description:
//      Reads arbitraty binary Metabase data (like an ACL)
//  Parameters:
//      IN      MetabaseId      ID to read data from
//      IN OUT  pBuffer         Buffer to read data into
//      IN OUT  pcbBufferSize   Size of buffer/valid data in buffer
//  Returns:
//      S_OK on success
//      HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) if buffer size is not
//                              not large enough for requested data.
//  History:
//      6/7/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT SMTP_SERVER_INSTANCE::SinkReadMetabaseData(DWORD MetabaseId,
                                                   BYTE *pBuffer,
                                                   DWORD *pcbBufferSize)
{
    HRESULT     hr = S_OK;
    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );

    if (!pcbBufferSize)
        return E_INVALIDARG;

    if (mb.Open(QueryMDPath())) {
        if (!mb.GetData("",
                        MetabaseId,
                        IIS_MD_UT_SERVER,
                        BINARY_METADATA,
                        pBuffer,
                        pcbBufferSize,
                        METADATA_INHERIT)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    } else {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


HRESULT SMTP_SERVER_INSTANCE::TriggerLocalDelivery(IMailMsgProperties *pMsg, DWORD dwRecipientCount, DWORD * pdwRecipIndexes, IMailMsgNotify *pNotify)
{
    HRESULT hr = S_FALSE;
    SMTP_ALLOC_PARAMS AllocParams;

    AllocParams.IMsgPtr = (PVOID) pMsg;
    AllocParams.m_InstanceId = QueryInstanceId();
    AllocParams.m_RecipientCount = dwRecipientCount;
    AllocParams.pdwRecipIndexes = pdwRecipIndexes;
    AllocParams.m_EventSmtpServer = (PVOID *) m_ComSmtpServer;
    AllocParams.hr = S_OK;
    AllocParams.m_pNotify = (PVOID) pNotify;

    _ASSERT(pMsg != NULL);
    _ASSERT(pdwRecipIndexes != NULL);
    _ASSERT(dwRecipientCount != 0);

    ADD_COUNTER (this, NumRcptsRecvdLocal, dwRecipientCount);
    ADD_COUNTER (this, NumRcptsRecvd, dwRecipientCount);

    hr = TriggerServerEvent(SMTP_STOREDRV_DELIVERY_EVENT, (PVOID) &AllocParams);

    //
    // jstamerj 1998/08/04 17:45:15:
    // If a sink returned a special error, return that to the caller of TriggerLocalDelivery
    //
    if (SUCCEEDED(hr) && FAILED(AllocParams.hr))
        hr = AllocParams.hr;

    return hr;
}

HRESULT SMTP_SERVER_INSTANCE::TriggerDirectoryDrop(IMailMsgProperties *pMsg, DWORD dwRecipientCount, DWORD * pdwRecipIndexes,
                                                   LPCSTR DropDirectory)
{
    HRESULT hr = S_FALSE;
    SMTP_ALLOC_PARAMS AllocParams;

    AllocParams.IMsgPtr = (PVOID) pMsg;
    AllocParams.m_InstanceId = QueryInstanceId();
    AllocParams.m_RecipientCount = dwRecipientCount;
    AllocParams.pdwRecipIndexes = pdwRecipIndexes;
    AllocParams.m_EventSmtpServer = (PVOID *) m_ComSmtpServer;
    AllocParams.m_DropDirectory = DropDirectory;
    AllocParams.m_pNotify = NULL;

    _ASSERT(pMsg != NULL);
    _ASSERT(pdwRecipIndexes != NULL);
    _ASSERT(DropDirectory != NULL);
    _ASSERT(dwRecipientCount != 0);

    if (DropDirectory != NULL) {
        //  hr = TriggerServerEvent(SMTP_MAIL_DROP_EVENT, (PVOID) &AllocParams);

    } else {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT SMTP_SERVER_INSTANCE::TriggerStoreServerEvent(DWORD EventType)
{
    HRESULT hr = S_FALSE;
    SMTP_ALLOC_PARAMS AllocParams;

    AllocParams.m_InstanceId = QueryInstanceId();
    AllocParams.m_EventSmtpServer = (PVOID *) m_ComSmtpServer;
    AllocParams.m_dwStartupType = SMTP_INIT_VSERVER_STARTUP;
    AllocParams.m_pNotify = NULL;

    hr = TriggerServerEvent(EventType, (PVOID) &AllocParams);

    return hr;
}

/////////////////////////////////////////////////////////////////
HRESULT SMTP_SERVER_INSTANCE::TriggerDnsResolverEvent(
    LPSTR HostName,
    LPSTR pszFQDN,
    DWORD dwVirtualServerId,
    IDnsResolverRecord **ppIDnsResolverRecord )
{
    HRESULT hr = S_FALSE;

    EVENTPARAMS_DNSRESOLVERRECORD params;
    params.pszHostName = HostName;
    params.pszFQDN = pszFQDN;
    params.dwVirtualServerId = dwVirtualServerId;
    params.ppIDnsResolverRecord = ppIDnsResolverRecord;

    hr = TriggerServerEvent( SMTP_DNSRESOLVERRECORDSINK_EVENT, (PVOID) &params);

    return hr;
}

/////////////////////////////////////////////////////////////////
HRESULT SMTP_SERVER_INSTANCE::TriggerMaxMsgSizeEvent(
    IUnknown      *pIUnknown,
    IMailMsgProperties *pIMailMsg,
    BOOL          *pfShouldImposeLimit )
{
    HRESULT hr = S_FALSE;

    EVENTPARAMS_MAXMSGSIZE params;
    params.pIUnknown = pIUnknown;
    params.pIMailMsg = pIMailMsg;
    params.pfShouldImposeLimit = pfShouldImposeLimit;

    hr = TriggerServerEvent( SMTP_MAXMSGSIZE_EVENT, (PVOID)&params );

    return( hr );
}

/////////////////////////////////////////////////////////////////
void SMTP_SERVER_INSTANCE::WriteLog(
    LPMSG_TRACK_INFO pMsgTrackInfo,
    IMailMsgProperties *pMsgProps,
    LPEVENT_LOG_INFO pEventLogInfo,
    LPSTR pszProtocolLog )
{
    //
    // do the message tracking stuff
    //

    if( pMsgTrackInfo || pMsgProps )
    {
        EVENTPARAMS_MSGTRACKLOG msgTrackLogParams;

        msgTrackLogParams.pIServer = GetInstancePropertyBag();
        msgTrackLogParams.pIMailMsgProperties = pMsgProps;
        msgTrackLogParams.pMsgTrackInfo = pMsgTrackInfo;
        TriggerServerEvent( SMTP_MSGTRACKLOG_EVENT, (PVOID)&msgTrackLogParams );
    }

    //
    // do the event log stuff
    //

    if( pEventLogInfo )
    {
        SmtpLogEventEx( pEventLogInfo->dwEventId, pEventLogInfo->pszEventLogMsg, pEventLogInfo->dwErrorCode );
    }

    //
    // do protocol logging stuff
    //

    if( pszProtocolLog )
    {
        INETLOG_INFORMATION translog;
        ZeroMemory( &translog, sizeof( translog ) );
        translog.pszOperation = "SMTPSVC_LOG";
        translog.cbOperation = strlen ("SMTPSVC_LOG");
        translog.pszHTTPHeader = pszProtocolLog;
        translog.cbHTTPHeaderSize = strlen( pszProtocolLog );

        m_Logging.LogInformation( &translog );
    }
}

/////////////////////////////////////////////////////////////////
HRESULT SMTP_SERVER_INSTANCE::TriggerLogEvent(
        IN DWORD                    idMessage,
        IN WORD                     idCategory,
        IN WORD                     cSubstrings,
        IN LPCSTR                   *rgszSubstrings,
        IN WORD                     wType,
        IN DWORD                    errCode,
        IN WORD                     iDebugLevel,
        IN LPCSTR                   szKey,
        IN DWORD                    dwOptions,
        IN DWORD                    iMessageString,
        IN HMODULE                  hModule)
{
    HRESULT hr = S_OK;

    EVENTPARAMS_LOG         LogParms;
    SMTP_LOG_EVENT_INFO     LogEventInfo;

    // Construct the log event info
    LogEventInfo.idMessage = idMessage;
    LogEventInfo.idCategory = idCategory;
    LogEventInfo.cSubstrings = cSubstrings;
    LogEventInfo.rgszSubstrings = rgszSubstrings;
    LogEventInfo.wType = wType;
    LogEventInfo.errCode = errCode;
    LogEventInfo.iDebugLevel = iDebugLevel;
    LogEventInfo.szKey = szKey;
    LogEventInfo.dwOptions = dwOptions;
    LogEventInfo.iMessageString = iMessageString;
    LogEventInfo.hModule = hModule;

    // Construct the event context
    LogParms.pSmtpEventLogInfo = &LogEventInfo;
    LogParms.pDefaultEventLogHandler = &g_EventLog;
    LogParms.iSelectedDebugLevel = m_dwEventlogLevel;
    TriggerServerEvent( SMTP_LOG_EVENT, (PVOID)&LogParms );

    return hr;
}

/////////////////////////////////////////////////////////////////
HRESULT SMTP_SERVER_INSTANCE::ResetLogEvent(
        IN DWORD                    idMessage,
        IN LPCSTR                   szKey)
{
    HRESULT hr = S_OK;

    hr = g_EventLog.ResetEvent(idMessage, szKey);

    return hr;
}

/////////////////////////////////////////////////////////////////
HRESULT SMTP_SERVER_INSTANCE::HrTriggerGetAuxDomainInfoFlagsEvent(
        IN  LPCSTR  pszDomainName,
        OUT DWORD  *pdwDomainInfoFlags )
{
    HRESULT                                 hr          = S_OK;
    EVENTPARAMS_GET_AUX_DOMAIN_INFO_FLAGS   EventParams;
    DWORD   dwStartTicks, dwStopTicks;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE:HrTriggerGetAuxDomainInfoFlagsEvent" );

    _ASSERT(pdwDomainInfoFlags);

    // Before we trigger the event, let's pre-set pdwDomainInfoFlags
    // to be "DOMAIN_INFO_INVALID" so we get the right result if there
    // were no sinks
    *pdwDomainInfoFlags = DOMAIN_INFO_INVALID;

    // Construct the event params
    EventParams.pIServer = GetInstancePropertyBag();
    EventParams.pszDomainName = pszDomainName;
    EventParams.pdwDomainInfoFlags = pdwDomainInfoFlags;

    DebugTrace((LPARAM)this, "Triggering event SMTP_GET_AUX_DOMAIN_INFO_FLAGS_EVENT ...");

    // Count ticks for calling this event
    dwStartTicks = GetTickCount();

    hr = TriggerServerEvent( SMTP_GET_AUX_DOMAIN_INFO_FLAGS_EVENT, (PVOID)&EventParams );
    if(FAILED(hr)) {
        goto Exit;
    }

    dwStopTicks = GetTickCount();

    DebugTrace((LPARAM)this, "Event SMTP_GET_AUX_DOMAIN_INFO_FLAGS_EVENT took %d ms.",
                    dwStopTicks - dwStartTicks);

    if (*EventParams.pdwDomainInfoFlags & DOMAIN_INFO_INVALID) {
        // domain info not found ... the caller can interpret the flags
        DebugTrace((LPARAM)this, "Event SMTP_GET_AUX_DOMAIN_INFO_FLAGS_EVENT did NOT return data");
        hr = S_OK;
    }
    else {
        DebugTrace((LPARAM)this, "Event SMTP_GET_AUX_DOMAIN_INFO_FLAGS_EVENT returned flags : %d", *EventParams.pdwDomainInfoFlags);
        hr = S_OK;
    }

Exit:
    TraceFunctLeaveEx((LPARAM) this);
    return hr;
}

/////////////////////////////////////////////////////////////////
HRESULT SMTP_SERVER_INSTANCE::TriggerServerEvent(DWORD dwEventID, PVOID pvContext)
{
    return m_CSMTPSeoMgr.HrTriggerServerEvent(dwEventID, pvContext);
}

/////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//  Description:
//      Performs per-startup initialization of SMTP_SERVER_INSTANCE. All initialization
//      in here is de-inited by InitiateShutDown(). IIS calls this function each time
//      a VSI is started up.
//  Arguments:
//      None.
//  Returns:
//      TRUE on success, FALSE otherwise.
//  Notes:
//      InitiateStartup() and InitiateShutdown() could be called multiple times for the
//      same SMTP_SERVER_INSTANCE by IIS. If this fails, IIS will shutdown the VSI by
//      calling InitiateShutdown().
//--------------------------------------------------------------------------------------
BOOL SMTP_SERVER_INSTANCE::InitiateStartup(void)
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE:InitiateStartup" );

    DWORD error = NO_ERROR, err = NO_ERROR;
    CSMTPServer * Ptr = NULL;
    HRESULT hr = S_OK;

    EnterCriticalSection( &m_critBoot );

    InitializeClassVariables();

    Ptr = new CSMTPServer();
    if (Ptr != NULL) {
        Ptr->Init(this);
        hr = Ptr->QueryInterface(IID_ISMTPServer, (void **) &m_ComSmtpServer);
        if (FAILED(hr) || !m_ComSmtpServer) {
            err = GetLastError();
            ErrorTrace((LPARAM) this, "QueryInterface for m_ComSmtpServer failed - %x", hr);
            goto error_exit;
        }
    } else {
        ErrorTrace((LPARAM) this, "new CSMTPServer() failed");
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    m_QStopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (m_QStopEvent == NULL) {
        err = GetLastError();
        ErrorTrace((LPARAM) this, "Creating stop event failed - %d", err);
        goto error_exit;
    }

    //
    // Create statistics object before initializing the queues
    //

    m_pSmtpStats = new SMTP_SERVER_STATISTICS(this);
    if ( m_pSmtpStats == NULL ) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        ErrorTrace((LPARAM) this, "new SMTP_SERVER_STATISTICS(this) failed - %d", err);
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        goto error_exit;
    }

    //
    // initialize the info list - used to collect performance info (a bit of a backdoor
    // to get the information back
    //
    if (!(m_pSmtpInfo = new SMTP_INSTANCE_LIST_ENTRY)) {
        ErrorTrace((LPARAM) this, "new SMTP_INSTANCE_LIST_ENTRY failed");
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto error_exit;
    }

    m_pSmtpInfo->dwInstanceId = QueryInstanceId();
    m_pSmtpInfo->pSmtpServerStatsObj = m_pSmtpStats;

    ((PSMTP_IIS_SERVICE) g_pInetSvc)->AcquireServiceExclusiveLock();
    InsertTailList((((PSMTP_IIS_SERVICE) g_pInetSvc)->GetInfoList()), &(m_pSmtpInfo->ListEntry));
    ((PSMTP_IIS_SERVICE) g_pInetSvc)->ReleaseServiceExclusiveLock();

    ((PSMTP_IIS_SERVICE) g_pInetSvc)->StartHintFunction();

    //
    // shinjuku initialization
    //
    hr = m_CSMTPSeoMgr.HrInit(QueryInstanceId());

    if (FAILED(hr)) {
        char szInst[10];

        _itoa((int)QueryInstanceId(), szInst, 10);
        ErrorTrace((LPARAM)this, "Error: Failed to initialize SEO for instance %u",
                   QueryInstanceId());
        SmtpLogEventEx(SEO_INIT_FAILED_INSTANCE,
                       szInst,
                       hr);
        goto error_exit;
    }

    if (!InitFromRegistry()) {
        err= GetLastError();
        ErrorTrace((LPARAM) this, "init from registry failed. err = %d", err);
        if (err == NO_ERROR)
            err = ERROR_INVALID_PARAMETER;

        SetLastError(err);
        goto error_exit;
    }

    ((PSMTP_IIS_SERVICE) g_pInetSvc)->StartHintFunction();

    TriggerStoreServerEvent(SMTP_STOREDRV_STARTUP_EVENT);
    m_fStoreDrvStartEventCalled = TRUE;

    // Enumerate files ...
    DWORD dwThreadId;
    m_hEnumBuildQ = CreateThread(
                                NULL,
                                0,
                                EnumBuildQProc,
                                (LPVOID)this,
                                0,
                                &dwThreadId);
    if (m_hEnumBuildQ == NULL) {
        err = GetLastError();
        ErrorTrace((LPARAM) this, "Creating startup enumeration thread failed - %d", err);
        goto error_exit;
    }

    // Initialize the mail pickup stuff, only if enabled
    if (ShouldPickupMail() && !InitDirectoryNotification()) {
        err = GetLastError();
        ErrorTrace((LPARAM) this, "InitDirectoryNotification() failed. err: %u", error);
        if (err == NO_ERROR)
            err = ERROR_INVALID_PARAMETER;

        SetLastError(err);
        goto error_exit;
    }

    LeaveCriticalSection( &m_critBoot );
    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;

    error_exit:

    LeaveCriticalSection( &m_critBoot );
    TraceFunctLeaveEx((LPARAM) this);
    return FALSE;
}

PSMTP_INSTANCE_LIST_ENTRY SMTP_SERVER_INSTANCE::GetSmtpInstanceInfo(void)
{
    AQPerfCounters AqPerf;
    HRESULT hr = S_FALSE;

    if (m_pIAdvQueueConfig != NULL) {
        AqPerf.cbVersion = sizeof(AQPerfCounters);
        hr = m_pIAdvQueueConfig->GetPerfCounters(
            &AqPerf,
            (m_pSmtpInfo) ?
                &(m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->CatPerfBlock) :
                NULL);
    }

    if(!FAILED(hr))
    {
        if(m_pSmtpInfo)
        {
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->RemoteQueueLength = AqPerf.cCurrentQueueMsgInstances;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->NumMsgsDelivered = AqPerf.cMsgsDeliveredLocal;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->LocalQueueLength = AqPerf.cCurrentMsgsPendingLocalDelivery;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->RemoteRetryQueueLength = AqPerf.cCurrentMsgsPendingRemoteRetry;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->NumSendRetries = AqPerf.cTotalMsgRemoteSendRetries;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->NumNDRGenerated = AqPerf.cNDRsGenerated;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->RetryQueueLength = AqPerf.cCurrentMsgsPendingLocalRetry;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->NumDeliveryRetries = AqPerf.cTotalMsgLocalRetries;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->ETRNMessages = AqPerf.cTotalMsgsTURNETRN;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->CatQueueLength = AqPerf.cCurrentMsgsPendingCat;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->MsgsBadmailNoRecipients = AqPerf.cTotalMsgsBadmailNoRecipients;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->MsgsBadmailHopCountExceeded = AqPerf.cTotalMsgsBadmailHopCountExceeded;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->MsgsBadmailFailureGeneral = AqPerf.cTotalMsgsBadmailFailureGeneral;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->MsgsBadmailBadPickupFile = AqPerf.cTotalMsgsBadmailBadPickupFile;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->MsgsBadmailEvent = AqPerf.cTotalMsgsBadmailEvent;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->MsgsBadmailNdrOfDsn = AqPerf.cTotalMsgsBadmailNdrOfDsn;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->MsgsPendingRouting = AqPerf.cCurrentMsgsPendingRouting;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->MsgsPendingUnreachableLink = AqPerf.cCurrentMsgsPendingUnreachableLink;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->SubmittedMessages = AqPerf.cTotalMsgsSubmitted;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->DSNFailures = AqPerf.cTotalDSNFailures;
            m_pSmtpInfo->pSmtpServerStatsObj->QueryStatsMember()->MsgsInLocalDelivery = AqPerf.cCurrentMsgsInLocalDelivery;

        }
    }
    return m_pSmtpInfo;
}

//---[ SMTP_SERVER_INSTANCE::HrGetDomainInfoFlags ]----------------------------
//
//
//  Description:
//      Gets domain info flags for specified domain if present
//  Parameters:
//      IN  szDomainName          Name of domain to check for
//      OUT pdwDomainInfoFlags    DomainInfo flags for this domain
//  Returns:
//      S_OK on success
//      E_INVALIDARG if szDomainName or pdwDomainInfoFlags is NULL
//      E_FAIL if other failure
//  History:
//      10/6/2000 - dbraun, Created.
//
//-----------------------------------------------------------------------------
HRESULT SMTP_SERVER_INSTANCE::HrGetDomainInfoFlags(
                IN  LPSTR szDomainName,
                OUT DWORD *pdwDomainInfoFlags)
{
    HRESULT                 hr  = S_OK;
    IAdvQueueDomainType   * pIAdvQueueDomainType = NULL;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE:HrGetDomainInfoFlags" );

    // Make sure we have a valid IAdvQueue interface
    if (!m_IAQ) {
        ErrorTrace((LPARAM) this, "Member m_IAQ is not valid");
        _ASSERT(m_IAQ);
        hr = E_FAIL;
        goto exit;
    }

    // Get the IAdvQueueDomainType interface
    hr = m_IAQ->QueryInterface(IID_IAdvQueueDomainType, (void **) &pIAdvQueueDomainType);
    if (FAILED(hr) || !pIAdvQueueDomainType) {
        ErrorTrace((LPARAM) this, "QueryInterface for IID_IAdvQueueDomainType failed - %x", hr);
        hr = E_FAIL;
        goto exit;
    }

    // Got the interface, now check for the domain
    hr = pIAdvQueueDomainType->GetDomainInfoFlags(szDomainName, pdwDomainInfoFlags);

exit:

    if (pIAdvQueueDomainType)
        pIAdvQueueDomainType->Release();

    TraceFunctLeaveEx((LPARAM) this);

    return hr;
}


BOOL SMTP_SERVER_INSTANCE::Stop(void)
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE:Stop" );

    //set the global termination flag
    m_IsShuttingDown = TRUE;

    EnterCriticalSection( &m_critBoot );

    if (m_ICM) {
        m_ICM->ReleaseWaitingThreads();
    }

    if (!m_InstBooted) {
        LeaveCriticalSection( &m_critBoot );
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    if (m_fShutdownCalled) {
        LeaveCriticalSection( &m_critBoot );
        TraceFunctLeaveEx((LPARAM) this);
        return TRUE;
    }

    if (m_QStopEvent) {
        SetEvent(m_QStopEvent);
    }

    //disconnect all inbound connections
    DisconnectAllConnections();

    DisconnectAllAsyncDnsConnections();

    //disconnect all outbound connections
    DisconnectAllOutboundConnections();

    DisconnectAllAsyncConnections();

    //we need to disconnect all outbound connections again here,
    //incase one slipped past the remote queue shutdown code
    DisconnectAllOutboundConnections();

    m_rfAccessCheck.Reset( (IMDCOM*)m_Service->QueryMDObject() );
    LeaveCriticalSection( &m_critBoot );

    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}

//-----------------------------------------------------------------------------------
//  Description:
//      Function called by IIS to deinitialize SMTP_SERVER_INSTANCE when the VSI is
//      stopping. Note that this function can be called multiple times for the same
//      SMTP_SERVER_INSTANCE. A matching call to InitializeClassVariables() and
//      InitiateStartup() do is made by IIS (to start SMTP_SERVER_INSTANCE).
//  Arguments:
//      None.
//  Returns:
//      None.
//-----------------------------------------------------------------------------------
void SMTP_SERVER_INSTANCE::InitiateShutDown(void)
{
    char IntBuffer [20];

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE:InitiateShutDown" );

    EnterCriticalSection( &m_critBoot );

    Stop();

    // Wait for the enum buildq thread to die ...
    if (m_hEnumBuildQ) {
        DWORD   dwWait;
        do {
            dwWait = WaitForSingleObject(m_hEnumBuildQ, 1000);
            if (dwWait == WAIT_TIMEOUT)
                StopHint();

        } while (dwWait != WAIT_OBJECT_0);

        CloseHandle(m_hEnumBuildQ);
        m_hEnumBuildQ = NULL;
    }

    // Wait for the enum domains thread to die ...
    if (m_hEnumDomainThreadHandle) {
        DWORD   dwWait;
        do {
            dwWait = WaitForSingleObject(m_hEnumDomainThreadHandle, 1000);
            if (dwWait == WAIT_TIMEOUT)
                StopHint();

        } while (dwWait != WAIT_OBJECT_0);

        CloseHandle(m_hEnumDomainThreadHandle);
        m_hEnumDomainThreadHandle = NULL;
    }

    //make sure directory notification threads are shut down
    if (ShouldPickupMail())
        DestroyDirectoryNotification();

    //Prepare for shutdown *must* be called before StopQDrivers... otherwise
    //we may have stray threads calling into submit messages... which could
    //AV.
    if(m_fStoreDrvStartEventCalled && !m_fStoreDrvPrepShutDownEventCalled)
    {
        TriggerStoreServerEvent(SMTP_STOREDRV_PREPSHUTDOWN_EVENT);
        m_fStoreDrvPrepShutDownEventCalled = TRUE;
    }

    // After this NOBODY can submit to the queue, the pointers are GONE
    StopQDrivers();

    if( m_fStoreDrvStartEventCalled )
    {
        TriggerStoreServerEvent(SMTP_STOREDRV_SHUTDOWN_EVENT);
    }

    //now that all the queues have stopped receiving data,
    //flush each queue, by removing all data and then delete
    //the queues.

    if (m_RemoteQ != NULL) {
        delete m_RemoteQ;
        m_RemoteQ = NULL;
    }


    DebugTrace((LPARAM)this, "removing and delete the Info List");

    if (m_pSmtpInfo != NULL) {
        ((PSMTP_IIS_SERVICE)g_pInetSvc)->AcquireServiceExclusiveLock();
        RemoveEntryList(&(m_pSmtpInfo->ListEntry));
        ((PSMTP_IIS_SERVICE)g_pInetSvc)->ReleaseServiceExclusiveLock();

        delete (m_pSmtpInfo);
        m_pSmtpInfo = NULL;
    }

    DebugTrace((LPARAM)this, "deleting statistics obj");

    //
    // delete statistics object
    //

    if ( m_pSmtpStats != NULL ) {
        delete m_pSmtpStats;
        m_pSmtpStats = NULL;
    }


    FreeVRootList(&m_leVRoots);

    DebugTrace((LPARAM)this, "deleting crit sects");

    //Delete the critical section objects

    if (m_SmtpInitializeStatus & SMTP_INIT_CSLOCK) {
        DeleteCriticalSection( &m_csLock);
        m_SmtpInitializeStatus &= ~SMTP_INIT_CSLOCK;
    }

    if (m_ProviderPackages != NULL ) {
        LocalFree((HANDLE)m_ProviderPackages);
        m_ProviderPackages = NULL;
    }

    //free the SSL info object
    if ( m_pSSLInfo != NULL ) {
        //If the refcount is not zero - we have a problem
        DWORD dwCount = IIS_SSL_INFO::Release( m_pSSLInfo );

        m_pSSLInfo = NULL;
    }

    ResetRelayIpSecList();

    //
    // shutdown shinjuku
    // this causes SEO to drop all loaded objects
    //
    m_CSMTPSeoMgr.Deinit();

    if (m_ComSmtpServer != NULL) {
        m_ComSmtpServer->Release();
        m_ComSmtpServer = NULL;
    }

    if (m_QStopEvent != NULL) {
        CloseHandle(m_QStopEvent);
        m_QStopEvent = NULL;
    }

    //
    // here we see if we are getting shutdown because we are being
    // deleted.  if so then we'll remove all of our bindings from
    // the shinjuku event binding database
    //
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    StopHint();

    if (mb.Open(QueryMDPath())) {
        // our metabase path still exists, so we aren't being deleted
        mb.Close();
    } else {
        StopHint();

        // our metabase path is gone, delete the shinjuku binding
        // database
        HRESULT hr = UnregisterPlatSEOInstance(QueryInstanceId());
        if (FAILED(hr)) {
            char szInst[10];

            _itoa((int)QueryInstanceId(), szInst, 10);
            ErrorTrace(0, "UnregisterSEOInstance(%lu) failed with %x",
                       QueryInstanceId(), hr);
            SmtpLogEventEx(SEO_DELETE_INSTANCE_FAILED,
                           szInst,
                           hr);
        }
    }

    _ASSERT(m_fInitAsyncCS && "Deleting un-initialized critsec");
    if(m_fInitAsyncCS) {
        DeleteCriticalSection( &m_csAsyncDns);
        DeleteCriticalSection( &m_csAsyncConnect);
        m_fInitAsyncCS = FALSE;
    }

    m_fShutdownCalled = TRUE;

    LeaveCriticalSection( &m_critBoot );

    TraceFunctLeaveEx((LPARAM) this);
}

DWORD SMTP_SERVER_INSTANCE::PauseInstance()
{
    DWORD err = NO_ERROR ;
    char IntBuffer [20];

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::PauseInstance");

    err = IIS_SERVER_INSTANCE::PauseInstance() ;

    if (err == NO_ERROR) {
        _itoa(QueryInstanceId(), IntBuffer, 10);

        SmtpLogEventEx(SMTP_EVENT_SERVICE_INSTANCE_PAUSED, IntBuffer, 0);
    }

    TraceFunctLeaveEx((LPARAM)this);

    return err ;
}
/*++

Routine Description:

    Sets instance to RUNNING

Arguments:

    NewState - Receives the new state.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/

DWORD SMTP_SERVER_INSTANCE::StartInstance(void)
{
    DWORD RetCode = ERROR_INVALID_SERVICE_CONTROL;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::StartInstance(void)" );

    _ASSERT(QueryServerState( ) == MD_SERVER_STATE_STOPPED);

    //initiate our startup first
    if ( InitiateStartup() ) {

        RetCode = IIS_SERVER_INSTANCE::StartInstance();

        if (RetCode != ERROR_SUCCESS) {
            // shutdown the instance
            InitiateShutDown();
            DebugTrace((LPARAM)this, "StartInstance() failed, err= %d", RetCode);
        }
        else
        {
            m_InstBooted = TRUE;
        }


    } else {
        //shutdown everything
        InitiateShutDown();
    }



    TraceFunctLeaveEx((LPARAM)this);
    return RetCode;
}

DWORD SMTP_SERVER_INSTANCE::StopInstance(void)
{
    DWORD RetCode = NO_ERROR;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::StopInstance(void)" );

    //call the IIS stuff first.
    RetCode = IIS_SERVER_INSTANCE::StopInstance();

    if (RetCode == NO_ERROR) {
        //shutdown everything
        InitiateShutDown();
    } else {
        DebugTrace((LPARAM)this, "StopInstance() failed, err= %d", RetCode);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return RetCode;
}

BOOL SMTP_SERVER_INSTANCE::InitQueues(void)
{
    DWORD error = NO_ERROR;
    BOOL fReturn = FALSE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::InitQueues" );

    m_RemoteQ = PERSIST_QUEUE::CreateQueue(REMOTEQ, this);
    if (m_RemoteQ != NULL) {
        fReturn = TRUE;
    } else {
        error = GetLastError();
        ErrorTrace((LPARAM)this, "new failed for PERSIST_QUEUE::CreateQueue(REMOTEQ). err: %u", error);
        if (error == NO_ERROR)
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
    }

    return fReturn;
}

void SMTP_SERVER_INSTANCE::FreeVRootList(PLIST_ENTRY pleHead)
{
    PLIST_ENTRY             pEntry;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::FreeVRootList" );

    while (!IsListEmpty(pleHead)) {
        pEntry = RemoveHeadList(pleHead);
        TCP_FREE(CONTAINING_RECORD(pEntry, SMTP_VROOT_ENTRY, list));
    }

    TraceFunctLeaveEx((LPARAM)this);
}



BOOL
GetVroots(
         PVOID          pvContext,
         MB *           pmb,
         VIRTUAL_ROOT * pvr
         )
/*++

Routine Description:

    Virtual directory enumerater callback that allocates and builds the
    virtual directory structure list

Arguments:
    pvContext is a pointer to the midl allocated memory

Return:

    TRUE if success, otherwise FALSE

--*/
{
    //LPINET_INFO_VIRTUAL_ROOT_LIST  pvrl = (LPINET_INFO_VIRTUAL_ROOT_LIST) pv
    //DWORD                          i = pvrl->cEntries;
    //LPINET_INFO_VIRTUAL_ROOT_ENTRY pvre = &pvrl->aVirtRootEntry[i];

    //_ASSERT( pvr->pszMetaPath[0] == '/' &&
    //          pvr->pszMetaPath[1] == '/' );


    return TRUE;
}

BOOL SMTP_SERVER_INSTANCE::FindBestVRoot(LPSTR szVRoot)
{
    PLIST_ENTRY             pEntry;
    HANDLE                  hToken;
    DWORD                   cbRoot;
    char                    szRoot[MAX_PATH + 1];
    DWORD                   dwErr;
    DWORD                   dwBytes;
    DWORD                   dwSectors;
    DWORD                   dwFree;
    DWORD                   dwTotal;
    DWORD                   dwRatio;
    DWORD                   dwRatioKeep;
    PLIST_ENTRY             pKeep = NULL;
    LPSTR                   szT;
    DWORD                   cSlash;
    DWORD                   dwAccessMask = 0;
    SMTP_VROOT_ENTRY        *pVrEntry = NULL;

    TraceFunctEnterEx((LPARAM)this, "SMTPCONFIG::FindBestVRoot");

    if (IsListEmpty(&m_leVRoots)) {
        ErrorTrace((LPARAM)this, "Vroots list empty");
        return FALSE;
    }

    for (pEntry = m_leVRoots.Flink ; pEntry != &m_leVRoots ; pEntry = pEntry->Flink) {
        cbRoot = sizeof(szRoot);

        pVrEntry = (SMTP_VROOT_ENTRY *) CONTAINING_RECORD(pEntry, SMTP_VROOT_ENTRY, list);

        if (!QueryVrootTable()->LookupVirtualRoot(pVrEntry->szVRoot,
                                                  szRoot, &cbRoot, &dwAccessMask, NULL, NULL,
                                                  &hToken, NULL)) {
            dwErr = GetLastError();
            ErrorTrace(NULL, "ResolveVirtualRoot failed for %s, %u",
                       CONTAINING_RECORD(pEntry, SMTP_VROOT_ENTRY, list)->szVRoot, dwErr);
        } else {
            cSlash = 0;
            if (szRoot[0] == '\\' && szRoot[1] == '\\') {
                // UNC Name
                DebugTrace((LPARAM)this, "Found UNC path %s", szRoot);
                szT = szRoot;

                while (*szT) {
                    if (*szT == '\\') {
                        cSlash++;
                        if (cSlash == 4) {
                            *(szT + 1) = '\0';
                        }
                    }

                    szT++;
                }

                if (cSlash != 4) {
                    lstrcat(szRoot, "\\");
                }
            } else {
                DebugTrace((LPARAM)this, "Found normal directory: %s", szRoot);
                szRoot[3] = '\0';
            }

            DebugTrace((LPARAM)this, "Getting free disk ratio on %s", szRoot);
            if (hToken == 0 || ImpersonateLoggedOnUser(hToken)) {
                if (GetDiskFreeSpace(szRoot, &dwSectors, &dwBytes, &dwFree, &dwTotal)) {
                    dwSectors *= dwBytes;
                    dwRatio = MulDiv(dwSectors, dwTotal, dwFree);
                    if (pKeep == NULL) {
                        dwRatioKeep = dwRatio;
                        pKeep = pEntry;
                    } else {
                        if (dwRatioKeep > dwRatio) {
                            dwRatioKeep = dwRatio;
                            pKeep = pEntry;
                        }
                    }
                }

                if (hToken != 0)
                    _VERIFY(RevertToSelf());
            }
        }
    }

    if (pKeep != NULL)
        lstrcpy(szVRoot, CONTAINING_RECORD(pKeep, SMTP_VROOT_ENTRY, list)->szVRoot);
    else
        lstrcpy(szVRoot, pVrEntry->szVRoot);

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}



//+---------------------------------------------------------------
//
//  Function:   SMTPCONFIG::WriteRegParams
//
//  Synopsis:   Writes parameters from a config info structure
//              into the registry
//
//  Arguments:  SMTP_CONFIG_INFO *: pointer to config information
//
//  Returns:    BOOL - TRUE on SUCCESS, FALSE on FAIL
//
//----------------------------------------------------------------
BOOL SMTP_SERVER_INSTANCE::WriteRegParams(SMTP_CONFIG_INFO *pconfig)
{

    //TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

DWORD ReadMetabaseDword (MB& mb, DWORD Key, DWORD DefaultValue)
{
    DWORD tmp = 0;

    if ( !mb.GetDword("", Key, IIS_MD_UT_SERVER, &tmp)) {
        //mb.SetDword("", Key, IIS_MD_UT_SERVER, DefaultValue);
        tmp = DefaultValue;
    }

    return tmp;

}

BOOL SMTP_SERVER_INSTANCE::SetProviderPackages()
{
    TraceFunctEnter( "SMTP_SERVER_INSTANCE::SetProviderPackages" );

    LPSTR   psz;
    DWORD   i;

    PAUTH_BLOCK pBlock = NULL;

    if ( m_ProviderNames == NULL || m_cProviderPackages == 0) {
        ErrorTrace((LPARAM)this, "Invalid Parameters: 0x%08X, %d",
                   m_ProviderNames, m_cProviderPackages );
        return FALSE;
    }

    pBlock = (PAUTH_BLOCK)LocalAlloc(0, m_cProviderPackages * sizeof(AUTH_BLOCK));
    if (pBlock == NULL) {
        ErrorTrace( 0, "AUTH_BLOCK LocalAlloc failed: %d", GetLastError() );
        return FALSE;
    }

    //
    // start at 1 since 0 indicates the Invalid protocol
    //
    for ( i=0, psz = (LPSTR)m_ProviderNames; i< m_cProviderPackages; i++ ) {
        //
        // this would be the place to check whether the package was valid
        //
        DebugTrace( 0, "Protocol: %s", psz);

        pBlock[i].Name = psz;

        psz += lstrlen(psz) + 1;
    }

    //
    // if we're replacing already set packages; free their memory
    //
    if (m_ProviderPackages != NULL ) {
        LocalFree((HANDLE)m_ProviderPackages );
        m_ProviderPackages = NULL;
    }

    m_ProviderPackages = pBlock;

    return  TRUE;

} // SetAuthPackageNames


/*******************************************************************

    NAME:       GetDefaultDomainName

    SYNOPSIS:   Fills in the given array with the name of the default
                domain to use for logon validation.

    ENTRY:      pszDomainName - Pointer to a buffer that will receive
                    the default domain name.

                cchDomainName - The size (in charactesr) of the domain
                    name buffer.

    RETURNS:    APIERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     05-Dec-1994 Created.

********************************************************************/

APIERR
GetDefaultDomainName(
                    STR * pstrDomainName
                    )
{

    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    INT                         Result;
    APIERR                      err             = 0;
    LSA_HANDLE                  LsaPolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo      = NULL;

    TraceFunctEnter("GetDefaultDomainName");

    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  // object attributes
                                NULL,               // name
                                0L,                 // attributes
                                NULL,               // root directory
                                NULL );             // security descriptor

    NtStatus = LsaOpenPolicy( NULL,                 // system name
                              &ObjectAttributes,    // object attributes
                              POLICY_EXECUTE,       // access mask
                              &LsaPolicyHandle );   // policy handle

    if ( !NT_SUCCESS( NtStatus ) ) {
        DebugTrace(0,"cannot open lsa policy, error %08lX\n",NtStatus );
        err = LsaNtStatusToWinError( NtStatus );
        goto Cleanup;
    }

    //
    //  Query the domain information from the policy object.
    //

    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *)&DomainInfo );

    if ( !NT_SUCCESS( NtStatus ) ) {
        DebugTrace(0,"cannot query lsa policy info, error %08lX\n",NtStatus );
        err = LsaNtStatusToWinError( NtStatus );
        goto Cleanup;
    }

    //
    //  Compute the required length of the ANSI name.
    //

    Result = WideCharToMultiByte( CP_ACP,
                                  0,                    // dwFlags
                                  (LPCWSTR)DomainInfo->DomainName.Buffer,
                                  DomainInfo->DomainName.Length /sizeof(WCHAR),
                                  NULL,                 // lpMultiByteStr
                                  0,                    // cchMultiByte
                                  NULL,                 // lpDefaultChar
                                  NULL                  // lpUsedDefaultChar
                                );

    if ( Result <= 0 ) {
        err = GetLastError();
        goto Cleanup;
    }

    //
    //  Resize the output string as appropriate, including room for the
    //  terminating '\0'.
    //

    if ( !pstrDomainName->Resize( (UINT)Result + 1 ) ) {
        err = GetLastError();
        goto Cleanup;
    }

    //
    //  Convert the name from UNICODE to ANSI.
    //

    Result = WideCharToMultiByte( CP_ACP,
                                  0,                    // flags
                                  (LPCWSTR)DomainInfo->DomainName.Buffer,
                                  DomainInfo->DomainName.Length /sizeof(WCHAR),
                                  pstrDomainName->QueryStr(),
                                  pstrDomainName->QuerySize() - 1,  // for '\0'
                                  NULL,
                                  NULL
                                );

    if ( Result <= 0 ) {
        err = GetLastError();

        DebugTrace(0,"cannot convert domain name to ANSI, error %d\n",err );
        goto Cleanup;
    }

    //
    //  Ensure the ANSI string is zero terminated.
    //

    _ASSERT( (DWORD)Result < pstrDomainName->QuerySize() );

    pstrDomainName->QueryStr()[Result] = '\0';

    //
    //  Success!
    //

    _ASSERT( err == 0 );

    DebugTrace(0,"GetDefaultDomainName: default domain = %s\n",pstrDomainName->QueryStr() );

    Cleanup:

    if ( DomainInfo != NULL ) {
        LsaFreeMemory( (PVOID)DomainInfo );
    }

    if ( LsaPolicyHandle != NULL ) {
        LsaClose( LsaPolicyHandle );
    }

    return err;

}   // GetDefaultDomainName()

DWORD
SMTP_SERVER_INSTANCE::ReadAuthentInfo(void)

/*++

    Reads per-instance authentication info from the metabase.

    Arguments:

        ReadAll - If TRUE, then all authentication related items are
            read from the metabase. If FALSE, then only a single item
            is read.

        SingleItemToRead - The single authentication item to read if
            ReadAll is FALSE. Ignored if ReadAll is TRUE.

        Notify - If TRUE, this is a MB notification

    Returns:

        DWORD - 0 if successful, !0 otherwise.

--*/
{

    DWORD err = NO_ERROR;
    BOOL rebuildAcctDesc = FALSE;
    TCP_AUTHENT_INFO* pTcpAuthentInfo = NULL;
    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );

    TraceFunctEnter("SMTP_SERVER_INSTANCE::ReadAuthentInfo");

    //
    // Lock our configuration (since we'll presumably be making changes)
    // and open the metabase.
    //
    m_GenLock.ExclusiveLock();


    if ( !mb.Open( QueryMDPath() ) ) {
        err = GetLastError();
        DebugTrace(0,"ReadAuthentInfo: cannot open metabase, error %lx\n",err);
        m_GenLock.ExclusiveUnlock();
        return ERROR_PATH_NOT_FOUND;
    }

    pTcpAuthentInfo = &m_TcpAuthentInfo ;

    //
    // Read the anonymous username if necessary. Note this is a REQUIRED
    // property. If it is missing from the metabase, bail.
    //


    if ( mb.GetStr("",MD_ANONYMOUS_USER_NAME, IIS_MD_UT_SERVER,&(pTcpAuthentInfo->strAnonUserName)
                  ) ) {

        rebuildAcctDesc = TRUE;

    } else {

        err = GetLastError();
        DebugTrace(0,"ReadAuthentInfo: cannot read MD_ANONYMOUS_USER_NAME, error %lx\n",err);

    }

    //
    // Read the "use subauthenticator" flag if necessary. This is an
    // optional property.
    //

    if ( err == NO_ERROR) {
        (pTcpAuthentInfo->fDontUseAnonSubAuth) = ReadMetabaseDword (mb, MD_ANONYMOUS_USE_SUBAUTH, DEFAULT_USE_SUBAUTH);
    }

    //
    // Read the anonymous password if necessary. This is an optional
    // property.
    //

    if ( err == NO_ERROR ) {

        if ( mb.GetStr(
                      "",
                      MD_ANONYMOUS_PWD,
                      IIS_MD_UT_SERVER,
                      &(pTcpAuthentInfo->strAnonUserPassword),
                      METADATA_INHERIT,
                      DEFAULT_ANONYMOUS_PWD
                      ) ) {

            rebuildAcctDesc = TRUE;

        } else {

            //
            // Since we provided a default value to mb.GetStr(), it should
            // only fail if something catastrophic occurred, such as an
            // out of memory condition.
            //

            err = GetLastError();
            DebugTrace(0,"ReadAuthentInfo: cannot read MD_ANONYMOUS_PWD, error %lx\n",err);
        }
    }

    //
    // Read the default logon domain if necessary. This is an optional
    // property.
    //

    if ( err == NO_ERROR ) {

        if ( !mb.GetStr(
                       "",
                       MD_DEFAULT_LOGON_DOMAIN,
                       IIS_MD_UT_SERVER,
                       &(pTcpAuthentInfo->strDefaultLogonDomain)
                       ) ) {

            //
            // Generate a default domain name.
            //

            err = GetDefaultDomainName( &(pTcpAuthentInfo->strDefaultLogonDomain) );

            if ( err != NO_ERROR ) {

                DebugTrace(0,"ReadAuthentInfo: cannot get default domain name, error %d\n",err);

            }

        }

    }

    //
    // Read the logon method if necessary. This is an optional property.
    //

    if ( err == NO_ERROR) {
        pTcpAuthentInfo->dwLogonMethod = ReadMetabaseDword (mb, MD_LOGON_METHOD, DEFAULT_LOGON_METHOD);
    }

    //
    // If anything changed that could affect the anonymous account
    // descriptor, then rebuild the descriptor.
    //

    if ( err == NO_ERROR && rebuildAcctDesc ) {

        if ( !BuildAnonymousAcctDesc( pTcpAuthentInfo ) ) {

            DebugTrace(0,"ReadAuthentInfo: BuildAnonymousAcctDesc() failed\n");
            err = ERROR_NOT_ENOUGH_MEMORY;  // SWAG

        }

    }

    m_GenLock.ExclusiveUnlock();
    return err;

}   // SMTP_SERVER_INSTANCE::ReadAuthentInfo

//+---------------------------------------------------------------
//
//  Function:   SMTPCONFIG::ReadRegParams
//
//  Synopsis:   Reads parameters from the registry into the config
//              class member variables and IServer (m_InstancePropertyBag)
//
//  Arguments:  FIELD_CONTROL: Bit-field defining what params to
//                  read.
//
//  Returns:    BOOL - TRUE on SUCCESS, FALSE on FAIL
//
//  Note:       BOOL fInit argument removed by KeithLau on 7/15/96
//
//----------------------------------------------------------------
BOOL SMTP_SERVER_INSTANCE::ReadRegParams(
    FIELD_CONTROL fc, BOOL fRebuild, BOOL fShowEvents)
{
    BOOL        fRet = TRUE;
    DWORD       dwErr = NO_ERROR;
    DWORD       dwAttr;
    DWORD       dwLen;
    DWORD       dwTempVar;
    DWORD       dwAqueueWait = 0;
    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );
    char        ScratchBuffer [400];
    STR         TempString;
    const CHAR * apszSubStrings[4];
    CHAR pchAddr1[32] = "";
    AQConfigInfo AQConfig;
    HRESULT      hr;

    char szDomainName[MAX_PATH + 1] = {0};

    TraceFunctEnterEx((LPARAM)this, "SMTPCONFIG::SMTP_SERVER_INSTANCE");

    SetLastError(NO_ERROR);

    m_fDefaultInRt = FALSE;

    ZeroMemory(&AQConfig, sizeof(AQConfig));

    // Make sure we've got a valid field control input
    _ASSERT(fc != 0 && !(fc & ~(FC_SMTP_INFO_ALL)));

    m_GenLock.ExclusiveLock();

    _itoa(QueryInstanceId(), pchAddr1, 10);

    //
    //  Read metabase data.
    //

    if ( !mb.Open( QueryMDPath(), METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE) ) {
        m_GenLock.ExclusiveUnlock();
        return FALSE;
    }


    if (IsFieldSet(fc, FC_SMTP_INFO_ROUTING)) {
        GetCatInfo(mb, AQConfig);
    }

    ZeroMemory(&AQConfig, sizeof(AQConfig));

    if (IsFieldSet(fc, FC_SMTP_INFO_REVERSE_LOOKUP)) {
        dwTempVar = 0;
        dwTempVar = ReadMetabaseDword(mb, MD_REVERSE_NAME_LOOKUP, 0);

        // If the value is changing, generate an information NT event...
        if (dwTempVar != m_RDNSOptions) {
            apszSubStrings[0] = pchAddr1;

            if (fShowEvents) {
                if (dwTempVar)
                    SmtpLogEvent(SMTP_EVENT_SET_REVERSE_LOOKUP_ENABLED, 1, apszSubStrings, 0);
                else
                    SmtpLogEvent(SMTP_EVENT_SET_REVERSE_LOOKUP_DISABLED, 1, apszSubStrings, 0);
            }

            m_RDNSOptions = dwTempVar;

            StateTrace((LPARAM)this, "m_fEnableReverseLookup = %u", m_RDNSOptions);
        }
    }

    //I am isung this for all commands
    if (IsFieldSet(fc, FC_SMTP_INFO_INBOUND_SUPPORT_OPTIONS)) {
        m_InboundCmdOptions = ReadMetabaseDword(mb, MD_INBOUND_COMMAND_SUPPORT_OPTIONS, SMTP_DEFAULT_CMD_SUPPORT);
        m_OutboundCmdOptions = ReadMetabaseDword(mb, MD_OUTBOUND_COMMAND_SUPPORT_OPTIONS, SMTP_DEFAULT_OUTBOUND_SUPPORT);

        m_fAddNoHdrs = !!ReadMetabaseDword(mb, MD_ADD_NOHEADERS, FALSE);
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_SSL_PERM)) {

        BOOL fRequiresCertVerifySubject;
        BOOL fRequiresCertVerifyIssuer;

        fRequiresCertVerifyIssuer =
            ReadMetabaseDword (mb, MD_SMTP_SSL_REQUIRE_TRUSTED_CA, FALSE);

        fRequiresCertVerifySubject =
            ReadMetabaseDword (mb, MD_SMTP_SSL_CERT_HOSTNAME_VALIDATION, FALSE);

        m_fRequiresCertVerifySubject = fRequiresCertVerifySubject;
        m_fRequiresCertVerifyIssuer = fRequiresCertVerifyIssuer;

        BOOL fRequiresSSL, fRequires128Bits;

        dwTempVar = ReadMetabaseDword(mb, MD_SSL_ACCESS_PERM, FALSE);

        fRequiresSSL = IsFieldSet(dwTempVar, MD_ACCESS_SSL);
        fRequires128Bits = IsFieldSet(dwTempVar, MD_ACCESS_SSL128);

        apszSubStrings[0] = pchAddr1;

        // If the value is changing, generate an information NT event...
        if (fShowEvents && (fRequiresSSL != m_fRequiresSSL)) {
            SmtpLogEvent(
                        fRequiresSSL ?
                        SMTP_EVENT_REQUIRE_SSL_INBOUND_ENABLE :
                        SMTP_EVENT_REQUIRE_SSL_INBOUND_DISABLE, 1, apszSubStrings, 0);
        }
        m_fRequiresSSL = fRequiresSSL;

        if (fShowEvents && (fRequires128Bits != m_fRequires128Bits)) {
            SmtpLogEvent(
                        fRequires128Bits ?
                        SMTP_EVENT_REQUIRE_128BIT_SSL_INBOUND_ENABLE :
                        SMTP_EVENT_REQUIRE_128BIT_SSL_INBOUND_DISABLE, 1, apszSubStrings, 0);
        }
        m_fRequires128Bits = fRequires128Bits;

        StateTrace((LPARAM)this,
                   "m_fRequiresSSL = %s, m_fRequires128Bits = %s",
                   m_fRequiresSSL ? "TRUE" : "FALSE",
                   m_fRequires128Bits ? "TRUE" : "FALSE");

    }

    if (IsFieldSet(fc, FC_SMTP_INFO_COMMON_PARAMS)) {
        DWORD   dwDomainValidationFlags = 0;
        DWORD   dwNameResolution = 0;

        m_dwDnsFlags = ReadMetabaseDword(mb, MD_SMTP_USE_TCP_DNS, 0);

        m_dwNameResolution = ReadMetabaseDword(mb, MD_NAME_RESOLUTION_TYPE, 1);

        StateTrace((LPARAM)this, "m_dwNameResolution = %u", m_dwNameResolution);

        m_cMaxBatchLimit = ReadMetabaseDword(mb, MD_BATCH_MSG_LIMIT, 20);

        AQConfig.cMinMessagesPerConnection = m_cMaxBatchLimit;
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MIN_MSG;

        AQConfig.dwConnectionWaitMilliseconds = ReadMetabaseDword(mb, MD_SMTP_AQUEUE_WAIT, 60000);
        //AQConfig.dwConnectionWaitMilliseconds = INFINITE;

        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_CON_WAIT;

        StateTrace((LPARAM)this, "m_cMaxBatchLimit = %u", m_cMaxBatchLimit);

        m_fRelayForAuthUsers = !!ReadMetabaseDword(mb, MD_SMTP_RELAY_FOR_AUTH_USERS, TRUE);

        m_fIsRelayEnabled = !!ReadMetabaseDword(mb, MD_SMTP_DISABLE_RELAY, TRUE);
        m_fHelloNoDomain = !!ReadMetabaseDword(mb, MD_SMTP_HELO_NODOMAIN, TRUE);
        m_fMailFromNoHello = !!ReadMetabaseDword(mb, MD_SMTP_MAIL_NO_HELO, FALSE);

        //Per spec these two are related
        if (m_fMailFromNoHello)
            m_fHelloNoDomain = TRUE;

        m_fNagleIn = !!ReadMetabaseDword(mb, MD_SMTP_INBOUND_NAGLE, FALSE);
        m_fNagleOut = !!ReadMetabaseDword(mb, MD_SMTP_OUTBOUND_NAGLE, FALSE);

        dwDomainValidationFlags = !!ReadMetabaseDword(mb, MD_DOMAIN_VALIDATION_FLAGS, 0);
        m_fHelloNoValidate = dwDomainValidationFlags & SMTP_NOVALIDATE_EHLO;
        m_fMailNoValidate = dwDomainValidationFlags & SMTP_NOVALIDATE_MAIL;
        m_fRcptNoValidate = dwDomainValidationFlags & SMTP_NOVALIDATE_RCPT;
        m_fEtrnNoValidate = dwDomainValidationFlags & SMTP_NOVALIDATE_ETRN;
        m_fPickupNoValidate = dwDomainValidationFlags & SMTP_NOVALIDATE_PKUP;

        ReadRouteDomainIpSecList(mb);
        // Raid 174038
        m_fDisablePickupDotStuff = !!ReadMetabaseDword(mb, MD_SMTP_DISABLE_PICKUP_DOT_STUFF, FALSE);
        StateTrace((LPARAM)this, "m_fDisablePickupDotStuff = %u", m_fDisablePickupDotStuff);
        m_dwEventlogLevel = ReadMetabaseDword(mb, 
                                              MD_SMTP_EVENTLOG_LEVEL, 
                                              LOGEVENT_LEVEL_MEDIUM);

    }

    if (IsFieldSet(fc, FC_SMTP_INFO_MAX_OUT_CONN_PER_DOMAIN)) {
        dwTempVar = ReadMetabaseDword(mb, MD_MAX_OUT_CONN_PER_DOMAIN, 20);

        if (fShowEvents && (dwTempVar != m_cMaxOutConnectionsPerDomain)) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = ScratchBuffer;
            SmtpLogEvent(SMTP_EVENT_SET_MAX_CONN_PER_DOMAIN, 2, apszSubStrings, 0);
        }

        m_cMaxOutConnectionsPerDomain = dwTempVar;
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MAX_LINK;
        AQConfig.cMaxLinkConnections = dwTempVar;

        StateTrace((LPARAM)this, "m_cMaxOutConnectionsPerDomain = %u", m_cMaxOutConnectionsPerDomain);
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_AUTHORIZATION)) {
        m_dwAuth = ReadMetabaseDword(mb, MD_AUTHORIZATION, DEFAULT_AUTHENTICATION);
        DebugTrace((LPARAM)this, "m_dwAuth=%u", m_dwAuth);
    }

    //
    // update the following data members:
    //  m_ProviderPackages
    //  m_ProviderNames
    //  m_cProviderPackages
    if (IsFieldSet(fc, FC_SMTP_INFO_NTAUTHENTICATION_PROVIDERS)) {
        CHAR szAuthPack[MAX_PATH + 1];
        DWORD dwLen;

        TempString.Reset();

        if (mb.GetStr("", MD_NTAUTHENTICATION_PROVIDERS, IIS_MD_UT_SERVER, &TempString, METADATA_INHERIT, "")) {
            lstrcpyn(szAuthPack, TempString.QueryStr(), MAX_PATH);
            dwLen = lstrlen(szAuthPack);
            DebugTrace((LPARAM)this, "Authentication packages=%s", szAuthPack);
            if (!ConvertToMultisz(m_ProviderNames, &m_cProviderPackages, szAuthPack)) {
                CopyMemory(m_ProviderNames, pszPackagesDefault, ccbPackagesDefault);
                m_cProviderPackages = 2;
            }
        } else {
            DebugTrace((LPARAM)this, "Use default authentication packages=%s", pszPackagesDefault);
            CopyMemory(m_ProviderNames, pszPackagesDefault, ccbPackagesDefault);
            m_cProviderPackages = 1;
        }

        // set the AUTH_BLOCK info
        if (!SetProviderPackages()) {
            ErrorTrace((LPARAM)this, "Unable to allocate AUTH_BLOCK");
        }
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_SASL_LOGON_DOMAIN)) {
        TempString.Reset();

        if (mb.GetStr("", MD_SASL_LOGON_DOMAIN, IIS_MD_UT_SERVER, &TempString, METADATA_INHERIT, "")) {
            lstrcpyn(m_szDefaultLogonDomain, TempString.QueryStr(), MAX_SERVER_NAME_LEN);
            DebugTrace((LPARAM)this, "SASL logon domain =%s", m_szDefaultLogonDomain);
        } else {
            m_szDefaultLogonDomain[0] = '\0';
            DebugTrace((LPARAM)this, "no SASL default logon domain was found");
        }
    }

    if (IsFieldSet(fc, FC_SMTP_CLEARTEXT_AUTH_PROVIDER)) {
        TempString.Reset();

        m_cbCleartextAuthPackage = sizeof(m_szCleartextAuthPackage);
        if (mb.GetStr("", MD_SMTP_CLEARTEXT_AUTH_PROVIDER, IIS_MD_UT_SERVER, &TempString, METADATA_INHERIT, "")) {
            lstrcpy(m_szCleartextAuthPackage, TempString.QueryStr());
            m_cbCleartextAuthPackage = lstrlen(m_szCleartextAuthPackage) + 1;

            StateTrace((LPARAM)this, "Cleartext authentication provider: <%s>, length %u",
                       m_szCleartextAuthPackage,
                       m_cbCleartextAuthPackage);
        } else {
            m_szCleartextAuthPackage[0] = '\0';
            m_cbCleartextAuthPackage = 0;
            StateTrace((LPARAM)this, "No default cleartext authentication provider specified, using CleartextLogon");
        }

        TempString.Reset();

        if (mb.GetStr("", MD_MD_SERVER_SS_AUTH_MAPPING, IIS_MD_UT_SERVER, &TempString, METADATA_INHERIT, "")) {
            lstrcpyn(m_szMembershipBroker, TempString.QueryStr(), MAX_PATH);
            StateTrace((LPARAM)this, "Membership Broker name is set to %s", m_szMembershipBroker);
        } else {
            m_szMembershipBroker[0] = '\0';
            StateTrace((LPARAM)this, "No Membership Broker name configured");
        }
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_MAX_HOP_COUNT)) {
        dwTempVar = ReadMetabaseDword(mb, MD_HOP_COUNT, 15);
        StateTrace((LPARAM)this, "m_cMaxHopCount = %u", dwTempVar);

        if (fShowEvents && (dwTempVar != m_cMaxHopCount)) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = ScratchBuffer;
            SmtpLogEvent(SMTP_EVENT_SET_MAX_HOPCOUNT, 2, apszSubStrings, 0);
        }

        m_cMaxHopCount = dwTempVar;
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_REMOTE_PORT)) {
        dwTempVar = ReadMetabaseDword(mb, MD_REMOTE_SMTP_PORT, 25);
        if (fShowEvents && (dwTempVar != m_RemoteSmtpPort)) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = ScratchBuffer;
            SmtpLogEvent(SMTP_EVENT_SET_REMOTE_PORT, 2, apszSubStrings, 0);
        }

        m_RemoteSmtpPort = dwTempVar;

        StateTrace((LPARAM)this, "m_RemoteSmtpPort = %u", m_RemoteSmtpPort);
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_MAX_ERRORS)) {
        dwTempVar = ReadMetabaseDword(mb, MD_MAX_SMTP_ERRORS, 10);
        if (dwTempVar == 0)
            dwTempVar = 10;

        if (fShowEvents && (dwTempVar != m_cMaxErrors)) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = ScratchBuffer;
            SmtpLogEvent(SMTP_EVENT_SET_MAX_ERRORS, 2, apszSubStrings, 0);
        }

        m_cMaxErrors = dwTempVar;
        StateTrace((LPARAM)this, "m_cMaxErrors = %u", m_cMaxErrors);

        dwTempVar = ReadMetabaseDword(mb, MD_MAX_SMTP_AUTHLOGON_ERRORS, 4);
        if (dwTempVar == 0)
            dwTempVar = 4;

        if (fShowEvents && (dwTempVar != m_dwMaxLogonFailures)) {
            //_itoa(dwTempVar, ScratchBuffer, 10);
            // apszSubStrings[0] = pchAddr1;
            // apszSubStrings[1] = ScratchBuffer;
            //SmtpLogEvent(SMTP_EVENT_SET_MAX_ERRORS, 2, apszSubStrings, 0);

        }

        m_dwMaxLogonFailures = dwTempVar;
        StateTrace((LPARAM)this, "m_dwMaxLogonFailures = %u", m_dwMaxLogonFailures);
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_MAX_SIZE)) {
        dwTempVar = ReadMetabaseDword(mb, MD_MAX_MSG_SIZE, 2 * 1024);

        if (fShowEvents && (dwTempVar != m_cbMaxMsgSize)) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = ScratchBuffer;
            SmtpLogEvent(SMTP_EVENT_SET_MAX_SIZE_ACCEPTED, 2, apszSubStrings, 0);
        }

        m_cbMaxMsgSize = dwTempVar;
        StateTrace((LPARAM)this, "m_cbMaxMsgSize = %u", m_cbMaxMsgSize);

        dwTempVar = ReadMetabaseDword(mb, MD_MAX_MSG_SIZE_B4_CLOSE, 10 * 1024);
        if (fShowEvents && (dwTempVar != m_cbMaxMsgSizeBeforeClose)) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = ScratchBuffer;
            SmtpLogEvent(SMTP_EVENT_SET_MAX_SIZE_BEFORE_CLOSE, 2, apszSubStrings, 0);
        }

        m_cbMaxMsgSizeBeforeClose = dwTempVar;
        StateTrace((LPARAM)this, "m_cbMaxMsgSizeBeforeClose = %u", m_cbMaxMsgSizeBeforeClose);
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_REMOTE_TIMEOUT)) {
        dwTempVar = ReadMetabaseDword(mb, MD_REMOTE_TIMEOUT, 600);

        if (fShowEvents && (dwTempVar != m_cMaxRemoteTimeOut)) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = ScratchBuffer;
            SmtpLogEvent(SMTP_EVENT_SET_MAX_REMOTE_TIMEOUT, 2, apszSubStrings, 0);
        }

        m_cMaxRemoteTimeOut = dwTempVar;
        StateTrace((LPARAM)this, "m_cMaxRemoteTimeOut = %u", m_cMaxRemoteTimeOut);

        m_ConnectTimeout = ReadMetabaseDword(mb, MD_SMTP_CONNECT_TIMEOUT, 150);

        if (m_ConnectTimeout == 0)
            m_ConnectTimeout = 1;

        // Calculate timeout in milliseconds from timeout in seconds.
        m_ConnectTimeout = m_ConnectTimeout * 60 * 1000;

        m_MailFromTimeout = ReadMetabaseDword(mb, MD_SMTP_MAILFROM_TIMEOUT, 600);
        m_RcptToTimeout = ReadMetabaseDword(mb, MD_SMTP_RCPTTO_TIMEOUT, 600);
        m_DataTimeout = ReadMetabaseDword(mb, MD_SMTP_DATA_TIMEOUT, 600);
        m_AuthTimeout = ReadMetabaseDword(mb, MD_SMTP_AUTH_TIMEOUT, 600);
        m_SaslTimeout = ReadMetabaseDword(mb, MD_SMTP_SASL_TIMEOUT, 600);
        m_HeloTimeout = ReadMetabaseDword(mb, MD_SMTP_HELO_TIMEOUT, 600);
        m_BdatTimeout = ReadMetabaseDword(mb, MD_SMTP_BDAT_TIMEOUT, 600);
        m_TurnTimeout = ReadMetabaseDword(mb, MD_SMTP_TURN_TIMEOUT, 600);
        m_RSetTimeout = ReadMetabaseDword(mb, MD_SMTP_RSET_TIMEOUT, 600);
        m_QuitTimeout = ReadMetabaseDword(mb, MD_SMTP_RSET_TIMEOUT, 600);
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_MAX_OUTBOUND_CONN)) {
        dwTempVar = ReadMetabaseDword(mb, MD_MAX_OUTBOUND_CONNECTION, 100);
        if (fShowEvents && (dwTempVar != m_cMaxOutConnections)) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = ScratchBuffer;
            SmtpLogEvent(SMTP_EVENT_SET_MAX_OUTBOUND_CONNECTIONS, 2, apszSubStrings, 0);
        }

        m_cMaxOutConnections = dwTempVar;
        AQConfig.cMaxConnections = dwTempVar;
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MAX_CON;

        StateTrace((LPARAM)this, "m_cMaxOutConnections = %u", m_cMaxOutConnections);
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_MAX_RECIPS)) {
        dwTempVar = ReadMetabaseDword(mb, MD_MAX_RECIPIENTS, 100);
        if (fShowEvents && (dwTempVar != m_cMaxRcpts)) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = ScratchBuffer;
            SmtpLogEvent(SMTP_EVENT_SET_MAX_RECIPIENTS, 2, apszSubStrings, 0);
        }

        m_cMaxRcpts = dwTempVar;
        StateTrace((LPARAM)this, "m_cMaxRcpts = %u", m_cMaxRcpts);
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_ETRN_SUBDOMAINS)) {
        m_fAllowEtrnSubDomains = !!ReadMetabaseDword(mb, MD_ETRN_SUBDOMAINS, TRUE);
        StateTrace((LPARAM)this, "m_fAllowEtrnSubDomains = %u", m_fAllowEtrnSubDomains);
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_RETRY)) {
        DWORD dwTempVar2 = 0;
        char ScratchBuffer2[50];

        dwTempVar = ReadMetabaseDword(mb, MD_LOCAL_RETRY_ATTEMPTS, 48);
        dwTempVar2 = ReadMetabaseDword(mb, MD_LOCAL_RETRY_MINUTES, 60);

        if (fShowEvents && ((m_cRetryAttempts != dwTempVar) ||(m_cRetryMinutes != dwTempVar2))) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            _itoa(dwTempVar2, ScratchBuffer2, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = "Local";
            apszSubStrings[2] = ScratchBuffer;
            apszSubStrings[3] = ScratchBuffer2;
            SmtpLogEvent(SMTP_EVENT_SET_RETRY_PARAMETERS, 4, apszSubStrings, 0);
        }


        m_cRetryAttempts = dwTempVar;
        m_cRetryMinutes = dwTempVar2;

        StateTrace((LPARAM)this, "m_cRetryAttempts = %u", m_cRetryAttempts);
        StateTrace((LPARAM)this, "m_cRetryMinutes = %u", m_cRetryMinutes);

        dwTempVar = ReadMetabaseDword(mb, MD_REMOTE_RETRY_ATTEMPTS, 48);
        dwTempVar2 = ReadMetabaseDword(mb, MD_REMOTE_RETRY_MINUTES, 60);
        if ( fShowEvents && ((m_cRemoteRetryAttempts != dwTempVar) ||(m_cRemoteRetryMinutes != dwTempVar2))) {
            _itoa(dwTempVar, ScratchBuffer, 10);
            _itoa(dwTempVar2, ScratchBuffer2, 10);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = "Remote";
            apszSubStrings[2] = ScratchBuffer;
            apszSubStrings[3] = ScratchBuffer2;
            SmtpLogEvent(SMTP_EVENT_SET_RETRY_PARAMETERS, 4, apszSubStrings, 0);
        }

        m_cRemoteRetryAttempts = dwTempVar;
        m_cRemoteRetryMinutes = dwTempVar2;

        StateTrace((LPARAM)this, "m_cRetryAttempts = %u", m_cRemoteRetryAttempts);
        StateTrace((LPARAM)this, "m_cRetryMinutes = %u", m_cRemoteRetryMinutes);

        TempString.Reset();

        m_cbProgressiveRetryMinutes = sizeof(m_szProgressiveRetryMinutes);
        if (mb.GetStr("", MD_SMTP_REMOTE_PROGRESSIVE_RETRY_MINUTES, IIS_MD_UT_SERVER, &TempString, METADATA_INHERIT, "")) {
            lstrcpy(m_szProgressiveRetryMinutes, TempString.QueryStr());
            m_cbProgressiveRetryMinutes = lstrlen(m_szProgressiveRetryMinutes) + 1;

            StateTrace((LPARAM)this, "Progressive retry minutes: <%s>, length %u",
                       m_szProgressiveRetryMinutes,
                       m_cbProgressiveRetryMinutes);
        }

        //Parse out the string to get at most 4 seperate minute values
        //the values will be part of a comma delimited string
        int     cRetryMin[4];
        DWORD   i = 0;
        char    *szTemp;
        char    *Ptr = NULL;
        szTemp = m_szProgressiveRetryMinutes;

        //Parse out the 4 integers
        for (;i<4;) {
            Ptr = strchr(szTemp,',');
            if (Ptr)
                *Ptr = '\0';

            cRetryMin[i] = 0;
            cRetryMin[i] = atoi(szTemp);
            if (cRetryMin[i] < 1)
                break;
            i++;
            if (Ptr) {
                *Ptr = ',';
                szTemp = ++Ptr;
                Ptr = NULL;
            } else
                break;
        }

        //check if could parse nothing
        if (i==0) {
            //dwRetryMin[i] = 60;  //defualt retry is 60 minutes
            //NK** for now look at the old value - this way we can set something
            //using MMC
            cRetryMin[i] = m_cRemoteRetryMinutes;

            i++;
        }

        //If not all four retry intervals were specified
        //Make the use the last specifed interval in place of unspecified intervals
        while (i<4) {
            cRetryMin[i] = cRetryMin[i - 1];
            i++;
        }

        AQConfig.dwFirstRetrySeconds = cRetryMin[0] * 60;
        AQConfig.dwSecondRetrySeconds = cRetryMin[1] * 60;
        AQConfig.dwThirdRetrySeconds = cRetryMin[2] * 60;
        AQConfig.dwFourthRetrySeconds = cRetryMin[3] * 60;

        AQConfig.dwConnectionRetryMilliseconds = (m_cRemoteRetryMinutes*60*1000);
        AQConfig.dwRetryThreshold = ReadMetabaseDword(mb,MD_SMTP_REMOTE_RETRY_THRESHOLD,3);
        if (!AQConfig.dwRetryThreshold)
            AQConfig.dwRetryThreshold = 3;
        StateTrace((LPARAM)this, "RetryThreshold = %u", AQConfig.dwRetryThreshold);

        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_CON_RETRY;

        //
        // If DSN intervals are not set, then derive them from the retry intervals
        //      10/6/98 - MikeSwa
        //

        AQConfig.dwDelayExpireMinutes = ReadMetabaseDword(mb,
                                                          MD_SMTP_EXPIRE_REMOTE_DELAY_MIN, m_cRemoteRetryMinutes);
        AQConfig.dwNDRExpireMinutes = ReadMetabaseDword(mb,
                                                        MD_SMTP_EXPIRE_REMOTE_NDR_MIN,
                                                        m_cRemoteRetryMinutes * m_cRemoteRetryAttempts);
        AQConfig.dwAQConfigInfoFlags |=
        (AQ_CONFIG_INFO_EXPIRE_DELAY |
         AQ_CONFIG_INFO_EXPIRE_NDR);

        AQConfig.dwLocalDelayExpireMinutes = ReadMetabaseDword(mb,
                                                               MD_SMTP_EXPIRE_LOCAL_DELAY_MIN, m_cRetryMinutes);
        AQConfig.dwLocalNDRExpireMinutes = ReadMetabaseDword(mb,
                                                             MD_SMTP_EXPIRE_LOCAL_NDR_MIN,
                                                             m_cRetryMinutes * m_cRetryAttempts);
        AQConfig.dwAQConfigInfoFlags |=
        (AQ_CONFIG_INFO_LOCAL_EXPIRE_DELAY |
         AQ_CONFIG_INFO_LOCAL_EXPIRE_NDR);

    }

    if (IsFieldSet(fc, FC_SMTP_INFO_PIPELINE)) {
        dwTempVar = !!ReadMetabaseDword(mb, MD_SHOULD_PIPELINE_OUT, TRUE);
        if (fShowEvents && ((dwTempVar && !m_fShouldPipelineOut) || (!dwTempVar && m_fShouldPipelineOut))) {
            apszSubStrings[0] = pchAddr1;
            if (dwTempVar)
                SmtpLogEvent(SMTP_EVENT_SET_PIPELINE_OUT_ENABLED, 1, apszSubStrings, 0);
            else
                SmtpLogEvent(SMTP_EVENT_SET_PIPELINE_OUT_DISABLED, 1, apszSubStrings, 0);
        }

        m_fShouldPipelineOut = dwTempVar;
        StateTrace((LPARAM)this, "m_fShouldPipelineOut = %u", m_fShouldPipelineOut);

        dwTempVar = !!ReadMetabaseDword(mb, MD_SHOULD_PIPELINE_IN, TRUE);
        if (fShowEvents && ((dwTempVar && !m_fShouldPipelineIn)|| (!dwTempVar && m_fShouldPipelineIn))) {
            apszSubStrings[0] = pchAddr1;
            if (dwTempVar)
                SmtpLogEvent(SMTP_EVENT_SET_PIPELINE_IN_ENABLED, 1, apszSubStrings, 0);
            else
                SmtpLogEvent(SMTP_EVENT_SET_PIPELINE_IN_DISABLED, 1, apszSubStrings, 0);

        }

        m_fShouldPipelineIn = dwTempVar;
        StateTrace((LPARAM)this, "m_fShouldPipelineIn = %u", m_fShouldPipelineIn);
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_SMART_HOST)) {
        dwTempVar = ReadMetabaseDword(mb, MD_SMARTHOST_TYPE, 0);
        StateTrace((LPARAM)this, "m_fSmartHostType = %u", dwTempVar);
        if (dwTempVar != smarthostNone) {
            TempString.Reset();

            if (! mb.GetStr("", MD_SMARTHOST_NAME, IIS_MD_UT_SERVER, &TempString) ||
                TempString.IsEmpty()) {
                // Don't have a smart host, so turn off smart host and start.
                // Log it though, because the settings conflicted and so somebody
                // probably messed up...
                dwTempVar = m_fSmartHostType = smarthostNone;
                m_szSmartHostName[0] = '\0';
                ErrorTrace((LPARAM)this, "Unable to read smart host name, error %u", dwErr);
                apszSubStrings[0] = pchAddr1;
                SmtpLogEvent(SMTP_EVENT_INVALID_SMART_HOST, 1, apszSubStrings, 0);
            } else {
                if (fShowEvents && lstrcmpi(m_szSmartHostName,TempString.QueryStr())) {
                    apszSubStrings[0] = pchAddr1;
                    apszSubStrings[1] = TempString.QueryStr();
                    SmtpLogEvent(SMTP_EVENT_SET_SMART_HOST_NAME, 2, apszSubStrings, 0);
                }

                lstrcpyn (m_szSmartHostName,TempString.QueryStr(), MAX_PATH);
            }

            StateTrace((LPARAM)this, "m_szSmartHost = %s", m_szSmartHostName);
        }

        // If the value is changing, generate an information NT event...
        if (fShowEvents && (dwTempVar != m_fSmartHostType)) {
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = m_szSmartHostName;

            switch (dwTempVar) {
            case smarthostNone:
                {
                    SmtpLogEvent(SMTP_EVENT_SET_SMART_HOST_TYPE_NONE, 1, apszSubStrings, 0);
                    break;
                }
            case smarthostAfterFail:
                {
                    SmtpLogEvent(SMTP_EVENT_SET_SMART_HOST_TYPE_AFTER_FAIL,
                                 2, apszSubStrings, 0);
                    break;
                }
            case smarthostAlways:
                {
                    SmtpLogEvent(SMTP_EVENT_SET_SMART_HOST_TYPE_ALWAYS,
                                 2, apszSubStrings, 0);
                    break;
                }
            }//end switch

        }//endf if

        m_fSmartHostType = dwTempVar;
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_MASQUERADE)) {
        m_fMasquerade = !!ReadMetabaseDword(mb, MD_DO_MASQUERADE, FALSE);
        StateTrace((LPARAM)this, "m_fSmartHostType = %u", m_fMasquerade);
        if (m_fMasquerade) {
            TempString.Reset();

            if (! mb.GetStr("", MD_MASQUERADE_NAME, IIS_MD_UT_SERVER, &TempString) ||
                TempString.IsEmpty()) {
                // Don't have a masquerade, so turn off masquerading and start.
                // Log it though, because the settings conflicted and so somebody
                // probably messed up...
                m_fMasquerade = 0;
                m_szMasqueradeName[0] = '\0';
                ErrorTrace((LPARAM)this, "Unable to read masquerade name, error %u", dwErr);
                apszSubStrings[0] = pchAddr1;
                SmtpLogEvent(SMTP_EVENT_INVALID_MASQUERADE, 1, apszSubStrings, 0);
            } else {
                if (fShowEvents && lstrcmpi(m_szMasqueradeName,TempString.QueryStr())) {
                    apszSubStrings[0] = pchAddr1;
                    apszSubStrings[1] = TempString.QueryStr();
                    SmtpLogEvent(SMTP_EVENT_SET_MASQUERADE_NAME, 2, apszSubStrings, 0);
                }

                lstrcpyn (m_szMasqueradeName,TempString.QueryStr(), AB_MAX_DOMAIN);
            }

            StateTrace((LPARAM)this, "m_szMasqueradeName = %s", m_szMasqueradeName);
        }
    }


    if (IsFieldSet(fc, FC_SMTP_INFO_DEFAULT_DOMAIN)) {

        m_fDefaultDomainExists = TRUE;

        TempString.Reset();
        if (! mb.GetStr("", MD_DEFAULT_DOMAIN_VALUE, IIS_MD_UT_SERVER, &TempString)) {
            //
            // we set this value on system start up this is a problem... it should be set.
            //
            lstrcpyn(m_szDefaultDomain, ((SMTP_IIS_SERVICE *) g_pInetSvc)->QueryTcpipName() , MAX_PATH);
            ErrorTrace((LPARAM) this, "Error reading Default Domain from Metabase.  Using TcpipValue Name: %s", m_szDefaultDomain);
        }

        else if (TempString.IsEmpty()) {
            //
            // blow away the value, this will invoke the routine again, and it will be updated
            // with the higher level default.  Just in case, put the Instance value in there as a
            // placeholder... just in case.
            //

            lstrcpyn(m_szDefaultDomain, ((SMTP_IIS_SERVICE *) g_pInetSvc)->QueryTcpipName() , MAX_PATH);
            ErrorTrace((LPARAM) this, "Default Domain was blank string, removing Instance value.");

            if (! mb.DeleteData("", MD_DEFAULT_DOMAIN_VALUE, IIS_MD_UT_SERVER, STRING_METADATA)) {
                ErrorTrace((LPARAM) this, "Error deleting Default Domain from Metabase.  Using TcpipValue Name: %s", m_szDefaultDomain);
            }
        }

        else {
            lstrcpyn(m_szDefaultDomain,TempString.QueryStr(), sizeof(m_szDefaultDomain));

            if (fShowEvents) {
                apszSubStrings[0] = pchAddr1;
                apszSubStrings[1] = m_szDefaultDomain;

                // If the value is changing, generate an information NT event...
                SmtpLogEvent(SMTP_EVENT_SET_DEFAULT_DOMAIN, 2, apszSubStrings, 0);
            }
        }

        //
        // Inform aqueue of the default domain
        //
        AQConfig.szDefaultLocalDomain = m_szDefaultDomain;
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_DEFAULT_DOMAIN;
        ErrorTrace((LPARAM)this , "Default domain is %s", m_szDefaultDomain);
    }


    if (IsFieldSet(fc, FC_SMTP_INFO_FQDN)) {

        TempString.Reset();
        if (! mb.GetStr("", MD_FQDN_VALUE, IIS_MD_UT_SERVER, &TempString)) {
            //
            // We set this value on system start up - see main.cxx,
            // InitializeService
            // This is a problem... it should be set.
            //
            lstrcpyn(m_szFQDomainName, ((SMTP_IIS_SERVICE *) g_pInetSvc)->QueryTcpipName(), MAX_PATH);
            ErrorTrace((LPARAM) this, "Error reading FQDN value from Metabase.  Using TcpipValue Name: %s", m_szFQDomainName);
        } else if (TempString.IsEmpty()) {
            //
            // blow away the value, this will invoke the routine again, and it will be updated
            // with the higher level default.  Just in case, put the Instance value in there as a
            // placeholder... just in case.
            //

            lstrcpyn(m_szFQDomainName, ((SMTP_IIS_SERVICE *) g_pInetSvc)->QueryTcpipName() , MAX_PATH);
            ErrorTrace((LPARAM) this, "FQDN Value was blank string, removing Instance value.");

            if (! mb.DeleteData("", MD_FQDN_VALUE, IIS_MD_UT_SERVER, STRING_METADATA)) {
                ErrorTrace((LPARAM) this, "Error reading FQDN value from Metabase.  Using TcpipValue Name: %s", m_szFQDomainName);
            }
        }

        else {

            lstrcpyn(m_szFQDomainName,TempString.QueryStr(),
                sizeof(m_szFQDomainName));

            //
            // Register the SPNs for this virtual server. Currently, we ignore
            // errors here.
            //

            if (!RegisterServicePrincipalNames(FALSE)) {

                ErrorTrace((LPARAM) this, "Unable to register Kerberos SPNs %d, will try later",
                           GetLastError());

            }
        }

        //VerifyFQDNWithBindings();

        AQConfig.szServerFQDN = m_szFQDomainName;
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_SERVER_FQDN;

        ErrorTrace((LPARAM)this , "Fully qualified domain name is %s", m_szFQDomainName);
    }



    if (IsFieldSet(fc, FC_SMTP_INFO_SEND_TO_ADMIN)) {
        char * DomainOffset = NULL;
        DWORD NameSize = 0;

        TempString.Reset();

        if (! mb.GetStr("", MD_SEND_NDR_TO, IIS_MD_UT_SERVER, &TempString) ||
            TempString.IsEmpty()) {
            m_fSendNDRToAdmin = FALSE;
            m_AdminName[0] = '\0';
            ErrorTrace((LPARAM)this, "Unable to read admin name, error %u", dwErr);
        } else {
            lstrcpyn (m_AdminName,TempString.QueryStr(), MAX_INTERNET_NAME);
            DomainOffset = strchr(m_AdminName, '@');
            if (CAddr::ValidateCleanEmailName(m_AdminName, DomainOffset)) {
                m_fSendNDRToAdmin = TRUE;
                if (DomainOffset == NULL) {
                    lstrcat(m_AdminName, "@");
                    lstrcat(m_AdminName, m_szDefaultDomain);
                }
            } else {
                ErrorTrace((LPARAM)this, "Unable to read admin name, error %u", dwErr);
                m_AdminName[0] = '\0';
                m_fSendNDRToAdmin = FALSE;
            }

        }

        StateTrace((LPARAM)this, "m_AdminName = %s", m_AdminName);

        if (fShowEvents && m_fSendNDRToAdmin) {
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = m_AdminName;
            SmtpLogEvent(SMTP_EVENT_SET_SEND_NDR_TO_ADMIN_ENABLED, 2, apszSubStrings, 0);
        } else if (fShowEvents && !m_fSendNDRToAdmin) {
            apszSubStrings[0] = pchAddr1;
            SmtpLogEvent(SMTP_EVENT_SET_SEND_NDR_TO_ADMIN_DISABLED, 1, apszSubStrings, 0);
        }

        DomainOffset = NULL;
        NameSize = 0;

        TempString.Reset();

        if (! mb.GetStr("", MD_SEND_BAD_TO, IIS_MD_UT_SERVER, &TempString) ||
            TempString.IsEmpty()) {
            m_fSendBadToAdmin = FALSE;
            m_BadMailName[0] = '\0';
            ErrorTrace((LPARAM)this, "Unable to read badmail email name, error %u", dwErr);
        } else {
            lstrcpyn(m_BadMailName,TempString.QueryStr(), MAX_INTERNET_NAME);
            DomainOffset = strchr(m_BadMailName, '@');

            if (CAddr::ValidateCleanEmailName(m_BadMailName, DomainOffset)) {
                m_fSendBadToAdmin = TRUE;
                if (DomainOffset == NULL) {
                    lstrcat(m_BadMailName, "@");
                    lstrcat(m_BadMailName, m_szDefaultDomain);
                }
            } else {
                m_fSendBadToAdmin = FALSE;
                m_BadMailName[0] = '\0';
                ErrorTrace((LPARAM)this, "Unable to read badmail email name, error %u", dwErr);
            }
        }

        StateTrace((LPARAM)this, "m_BadMailName = %s", m_BadMailName);

        if (fShowEvents && m_fSendBadToAdmin) {
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = m_BadMailName;
            SmtpLogEvent(SMTP_EVENT_SET_SEND_BAD_TO_ADMIN_ENABLED, 2, apszSubStrings, 0);
        } else if (fShowEvents && !m_fSendBadToAdmin) {
            apszSubStrings[0] = pchAddr1;
            SmtpLogEvent(SMTP_EVENT_SET_SEND_BAD_TO_ADMIN_DISABLED, 1, apszSubStrings, 0);
        }

    }

    if (IsFieldSet(fc, FC_SMTP_INFO_DEFAULT_DROP_DIR)) {
        TempString.Reset();

        if (! mb.GetStr("", MD_MAIL_DROP_DIR, IIS_MD_UT_SERVER, &TempString, 0) ||
            TempString.IsEmpty()) {
            // We had a problem reading the metabase.
            // This is a very bad thing.
            m_szMailDropDir[0] = '\0';
            m_cchMailDropDir = 0;
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = szMailDropDir;
            SmtpLogEvent(SMTP_EVENT_INVALID_MAIL_DROP_DIR, 2, apszSubStrings, 0);
        } else {
            lstrcpyn(m_szMailDropDir, TempString.QueryStr(), MAX_PATH);

            if (fShowEvents) {
                apszSubStrings[0] = pchAddr1;
                apszSubStrings[1] = m_szMailDropDir;
                SmtpLogEvent(SMTP_EVENT_SET_MAIL_DROP_DIR, 2, apszSubStrings, dwErr);
            }

            // We found a path in the reg, so see if we can use it...
            dwAttr = GetFileAttributes(m_szMailDropDir);
            if (dwAttr == 0xFFFFFFFF) {
                // The path doesn't exist yet, so we'll try to create it.
                if (!CreateLayerDirectory(m_szMailDropDir) && (dwErr = GetLastError()) != ERROR_ALREADY_EXISTS) {
                    ErrorTrace((LPARAM)this, "Unable to create mail drop directory (%s)", m_szMailQueueDir);
                    apszSubStrings[0] = pchAddr1;
                    apszSubStrings[1] = m_szMailDropDir;
                    SmtpLogEvent(SMTP_EVENT_INVALID_MAIL_DROP_DIR, 2, apszSubStrings, dwErr);
                    m_szMailDropDir[0] = '\0';
                    m_cchMailDropDir = 0;
                }
            }

            else {
                if (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY)) {
                    // The registry points to a file, so we're outta luck.
                    // The directory doesn't exist, and we can't create it.
                    // Because this is the queue directory, we're not going
                    // to be able to start.  Log it so it can be fixed, but
                    // set fRet to FALSE so that we shut back down.
                    ErrorTrace((LPARAM)this, "Mail drop directory (%s) already exists as a file", m_szMailDropDir);
                    apszSubStrings[0] = pchAddr1;
                    apszSubStrings[1] = m_szMailDropDir;
                    SmtpLogEvent(SMTP_EVENT_INVALID_MAIL_DROP_DIR, 2, apszSubStrings, ERROR_ALREADY_EXISTS);
                    m_szMailDropDir[0] = '\0';
                }
            }

            if (m_szMailDropDir[0] != '\0') {
                // Looks like everything is going to be OK, so we add a backslash (if
                // necessary) because it makes things easier later.
                m_cchMailDropDir = lstrlen(m_szMailDropDir);
                if (m_cchMailDropDir > 0 && m_szMailDropDir[m_cchMailDropDir - 1] != '\\') {
                    lstrcat(m_szMailDropDir, "\\");
                    m_cchMailDropDir++;
                }
            }
        }
    }

    //
    // Added by keithlau on 7/8/96
    //
    if (IsFieldSet(fc, FC_SMTP_INFO_BAD_MAIL_DIR)) {
        TempString.Reset();

        if (! mb.GetStr("", MD_BAD_MAIL_DIR, IIS_MD_UT_SERVER, &TempString, 0) ||
            TempString.IsEmpty()) {
            // We had a problem reading the registry, so
            // set the flags back to not save bad mail and
            // log it and hop out.
            // This is NOT fatal.  We'll still start up and run,
            // but we're not going to save bad mail, and we wanted
            // to, so at least we'll log the event.
            m_szBadMailDir[0] = '\0';
            ErrorTrace((LPARAM)this, "Unable to read bad mail dir value, error = %u", dwErr);
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = szBadMailDir;
            SmtpLogEvent(SMTP_EVENT_CANNOT_READ_SVC_REGKEY, 2, apszSubStrings, 0);
        } else {
            lstrcpyn (m_szBadMailDir,TempString.QueryStr(), MAX_PATH);
        }

        if (m_szBadMailDir[0] != '\0') {
            // We found a path in the registry, so see if it already exists.
            dwAttr = GetFileAttributes(m_szBadMailDir);
            if (dwAttr == 0xFFFFFFFF) {
                // It doesn't exist at all, so try to create it.
                if (!CreateLayerDirectory(m_szBadMailDir) && (dwErr = GetLastError()) != ERROR_ALREADY_EXISTS) {
                    // We couldn't create it, so we can't save bad mail.
                    // Log it because somebody messed up the registry.
                    // This is NOT fatal.  We'll still start up and run,
                    // but we're not going to save bad mail, and we wanted
                    // to, so at least we'll log the event.
                    ErrorTrace((LPARAM)this, "Unable to create bad mail directory (%s)", m_szBadMailDir);
                    apszSubStrings[0] = pchAddr1;
                    apszSubStrings[1] = m_szBadMailDir;
                    SmtpLogEvent(SMTP_EVENT_INVALID_BAD_MAIL_DIR, 2, apszSubStrings, 0);
                    m_szBadMailDir[0] = '\0';
                }
            } else {
                if (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY)) {
                    // The registry points to a file, so we're outta luck.
                    // The directory doesn't exist, and we can't create it.
                    // This is NOT fatal.  We'll still start up and run,
                    // but we're not going to save bad mail, and we wanted
                    // to, so at least we'll log the event.
                    ErrorTrace((LPARAM)this, "Bad mail directory (%s) already exists", m_szBadMailDir);
                    apszSubStrings[0] = pchAddr1;
                    apszSubStrings[1] = m_szBadMailDir;
                    SmtpLogEvent(SMTP_EVENT_INVALID_BAD_MAIL_DIR, 2, apszSubStrings, 0);
                    m_szBadMailDir[0] = '\0';
                }
            }

            StateTrace((LPARAM)this, "Save bad mail is enabled and m_szBadMailDir = %s", m_szBadMailDir);
        } else {
            // We at least leave a trace saying that save bad mail is disabled
            StateTrace((LPARAM)this, "Save bad mail is disabled");
        }

        if (m_szBadMailDir[0] != '\0') {
            // Finally, if everything has gone OK, then add a trailing backslash so
            // that things are easier later.
            dwLen = lstrlen(m_szBadMailDir);
            if (dwLen > 0 && m_szBadMailDir[dwLen-1] != '\\')
                lstrcat(m_szBadMailDir, "\\");
        }
    }

    if (IsFieldSet(fc, FC_SMTP_INFO_DOMAIN_ROUTING)) {
        m_DefaultRouteAction = ReadMetabaseDword(mb, MD_ROUTE_ACTION, 0);

        TempString.Reset();

        if (!mb.GetStr("", MD_ROUTE_USER_NAME, IIS_MD_UT_SERVER, &TempString, 0) ||
            TempString.IsEmpty()) {
            m_DefaultRemoteUserName[0] = '\0';
            m_DefaultRemotePassword[0] = '\0';
            m_DefaultRouteAction &= ~SMTP_AUTH_NTLM;
            m_DefaultRouteAction &= ~SMTP_AUTH_CLEARTEXT;
            m_DefaultRouteAction &= ~SMTP_AUTH_KERBEROS;
            m_DefaultRouteAction &= ~SMTP_SASL;
        } else {
            lstrcpyn (m_DefaultRemoteUserName,TempString.QueryStr(), MAX_INTERNET_NAME);
        }

        TempString.Reset();

        if (!mb.GetStr("", MD_ROUTE_PASSWORD, IIS_MD_UT_SERVER, &TempString, METADATA_SECURE) ||
            TempString.IsEmpty()) {
            m_DefaultRemotePassword[0] = '\0';
        } else {
            lstrcpyn (m_DefaultRemotePassword,TempString.QueryStr(), MAX_PATH);
        }

        // Get change domain name.
        if (m_pChangeObject)
        {
            char *psz = strstr((const char *) m_pChangeObject->pszMDPath, "/Domain/");

            if (!psz)
            {
                // Changing default config or even more, rebuild
                fRebuild = TRUE;
            }
            else
            {
                // Found a normal domain change, copy the name
                strncpy(szDomainName, psz+8, strlen(psz)-8);
                szDomainName[strlen(psz)-8-1]='\0';
            }

            if (!strcmp(szDomainName, "*"))
            {
                // Changing '*' domain, rebuild
                fRebuild = TRUE;
            }
        }

        fRet = GetRouteDomains(mb, szDomainName, fRebuild);
    }

    AQConfig.cbVersion = sizeof(AQConfigInfo);

    //Send badmail information
    AQConfig.szBadMailDir = m_szBadMailDir;
    AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_BADMAIL_DIR;

    //Get DSN Options
    AQConfig.dwDSNOptions = ReadMetabaseDword(mb, MD_SMTP_DSN_OPTIONS, DSN_OPTIONS_DEFAULT);
    AQConfig.dwDSNLanguageID = ReadMetabaseDword(mb, MD_SMTP_DSN_LANGUAGE_ID, 0);

    AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_USE_DSN_OPTIONS |
                                    AQ_CONFIG_INFO_USE_DSN_LANGUAGE;

    if (m_fSendNDRToAdmin)
        AQConfig.szSendCopyOfNDRToAddress = m_AdminName;
    else
        AQConfig.szSendCopyOfNDRToAddress = NULL;
    AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_SEND_DSN_TO;

    m_pIAdvQueueConfig->SetConfigInfo(&AQConfig);

    //
    // jstamerj 1998/11/17 16:34:48:
    //   Set the well known proeprties of ISession
    //
    hr = HrSetWellKnownIServerProps();
    if(FAILED(hr)) {
        //
        // Just like everything else in this fucntion, don't treat
        // this as fatal; just log it
        //
        ErrorTrace((LPARAM)this, "HrSetWellKnownIServerProps failed hr %08lx", hr);
    }

    m_GenLock.ExclusiveUnlock();

    if (!fRet && (GetLastError() == NO_ERROR))
        SetLastError(ERROR_PATH_NOT_FOUND);

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

//+---------------------------------------------------------------
//
//  Function:   DeleteDomainEntry
//
//  Synopsis:   Delete a domain from cached tables.
//
//  Arguments:  DomainName: name of the domain to delete.
//
//  Returns:    BOOL - TRUE on SUCCESS, FALSE on FAIL
//
//----------------------------------------------------------------

BOOL SMTP_SERVER_INSTANCE::DeleteDomainEntry(const char *DomainName)
{
    TraceFunctEnterEx((LPARAM)this, "DeleteDomainEntry");

    DebugTrace((LPARAM)this , "Delete Domain [%s] ", DomainName);

    // Remove this domain from our SMTPSVC tables
    m_TurnAccessList.RemoveFromTable((const char *) DomainName);

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

//+---------------------------------------------------------------
//
//  Function:   RemoveRegParams
//
//  Synopsis:   Remove metabase info from cached tables.
//              We only handle domain removal at this moment.
//
//  Arguments:  DomainName: name of the domain to delete.
//              If DomainName is NULL, we get it from
//              m_pChangeObject.
//
//  Returns:    BOOL - TRUE on SUCCESS, FALSE on FAIL
//
//----------------------------------------------------------------
BOOL SMTP_SERVER_INSTANCE::RemoveRegParams(const char *DomainName)
{
    TraceFunctEnterEx((LPARAM)this, "RemoveRegParams");

    char szDomainName    [AB_MAX_DOMAIN + 1]    = {0};
    BOOL fRet                                   = TRUE;

    m_GenLock.ExclusiveLock();

    if (!m_pChangeObject)
        goto Exit;

    if (DomainName)
    {
        strcpy(szDomainName, DomainName);
    }
    else
    {
        // At this stage, we only handle Domain removale.
        char *psz = strstr((const char *) m_pChangeObject->pszMDPath, "/Domain/");

        if (psz)
        {
            // We find it.
            strncpy(szDomainName, psz+8, strlen(psz)-8);
            szDomainName[strlen(psz)-8-1]='\0';
        }
    }

    if (szDomainName[0] == '\0')
        goto Exit;

    {
        HRESULT     hr              = S_OK;
        char        szRoutePath     [MAX_PATH + 1];
        char        szActionType    [MAX_PATH + 1];
        char        szUserName      [MAX_INTERNET_NAME + 1];
        char        szEtrnDomain    [AB_MAX_DOMAIN + 1];
        char        szPassword      [MAX_PATH + 1];
        char        szTargetName    [MAX_PATH + 1];
        DomainInfo  DefaultDomainInfo;
        DomainInfo  StarDomainInfo;
        MB          mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );

        if( !mb.Open( QueryMDPath(), METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE) )
        {
            fRet = FALSE;
            goto Exit;
        }

        if (!strcmp(szDomainName, "*"))
        {
            // Deleting the '*' domain, must rebuild
            fRet = GetRouteDomains(mb, szDomainName, TRUE);
            goto Exit;
        }

        // Delete the domain from the table in SMTPSVC
        DeleteDomainEntry((const char *) szDomainName);

        // Since we have no way to tell AQ to delete this domain apart from
        // doing a full rebuild, we are going to push the defaults to AQ
        // to overwrite the custom settings this domain had before

        // Load up the "default config" : We get this by loading the server
        // default config and then trying to overwrite it with the '*'
        // domain config (if present)

        // REVIEW : Ideally this code would be in DeleteDomainEntry but putting it
        // there hurts us now because we have to call DeleteDomainEntry from
        // SetRouteDomainParameters to clean the tables in SMTPSVC.  If we can get
        // rid of those tables, the layout of these functions shoule be reconsidered.

        wsprintf(szRoutePath, "");
        SetRouteDomainParameters(mb,
                        szDomainName,
                        szRoutePath,
                        szActionType,
                        szUserName,
                        szEtrnDomain,
                        szPassword,
                        szTargetName,
                        &DefaultDomainInfo);

        if (AlwaysUseSmartHost() && m_szSmartHostName[0]) {
            DefaultDomainInfo.dwDomainInfoFlags |= DOMAIN_INFO_REMOTE_SMARTHOST;
            DefaultDomainInfo.szSmartHostDomainName = m_szSmartHostName;
            DefaultDomainInfo.cbSmartHostDomainNameLength = lstrlen(m_szSmartHostName);
        }

        //check if we should always use SSL
        if (GetDefaultRouteAction() & SMTP_SSL) {
            DefaultDomainInfo.dwDomainInfoFlags |= DOMAIN_INFO_USE_SSL;
        }

        // Try to overwrite this with the "*" domain if it exists
        wsprintf(szRoutePath, "/Domain/*");
        SetRouteDomainParameters(mb,
                        szDomainName,
                        szRoutePath,
                        szActionType,
                        szUserName,
                        szEtrnDomain,
                        szPassword,
                        szTargetName,
                        &StarDomainInfo);

        // If we found the star domain - dwDomainInfoFlags is zero if
        // the domain does not exist in the metabase
        if (StarDomainInfo.dwDomainInfoFlags) {
            hr = m_pIAdvQueueConfig->SetDomainInfo(&StarDomainInfo);
        }
        // else push the default domain info
        else {
            hr = m_pIAdvQueueConfig->SetDomainInfo(&DefaultDomainInfo);
        }
    }

Exit:
    m_GenLock.ExclusiveUnlock();

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

BOOL SMTP_SERVER_INSTANCE::GetCatInfo(MB& mb, AQConfigInfo& AQConfig)
{
    STR         TempString;
    char        Password[MAX_PATH];
    char        BindType[MAX_PATH];
    char        SchemaType[MAX_PATH];
    char        Domain[MAX_PATH];
    char        UserName[MAX_PATH];
    char        Host[MAX_PATH];
    char        NamingContext[MAX_PATH];
    char        DsType[MAX_PATH];

    Password[0] = '\0';
    BindType[0] = '\0';
    SchemaType[0] = '\0';
    Domain[0] = '\0';
    UserName[0] = '\0';
    Host[0] = '\0';
    NamingContext[0] = '\0';
    DsType [0] = '\0';

    if( mb.GetDword("RoutingSources", MD_SMTP_DS_USE_CAT, IIS_MD_UT_SERVER, &AQConfig.dwMsgCatEnable))
    {
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_ENABLE;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutDWORD(
                PE_ISERVID_DW_CATENABLE,
                AQConfig.dwMsgCatEnable)));
    }

    if( mb.GetDword("RoutingSources", MD_SMTP_DS_FLAGS, IIS_MD_UT_SERVER, &AQConfig.dwMsgCatFlags))
    {
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_FLAGS;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutDWORD(
                PE_ISERVID_DW_CATFLAGS,
                AQConfig.dwMsgCatFlags)));
    }

    if( mb.GetDword("RoutingSources", MD_SMTP_DS_PORT, IIS_MD_UT_SERVER, &AQConfig.dwMsgCatPort))
    {
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_PORT;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutDWORD(
                PE_ISERVID_DW_CATPORT,
                AQConfig.dwMsgCatPort)));
    }

    TempString.Reset();

    if (mb.GetStr("RoutingSources", MD_SMTP_DS_ACCOUNT, IIS_MD_UT_SERVER, &TempString) &&
        !TempString.IsEmpty()) {
        lstrcpyn(UserName, TempString.QueryStr(), MAX_PATH);
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_USER;
        AQConfig.szMsgCatUser = UserName;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutStringA(
                PE_ISERVID_SZ_CATUSER,
                TempString.QueryStr())));
    }

    TempString.Reset();

    if (mb.GetStr("RoutingSources", MD_SMTP_DS_SCHEMA_TYPE, IIS_MD_UT_SERVER, &TempString) &&
        !TempString.IsEmpty()) {
        lstrcpyn(SchemaType, TempString.QueryStr(), MAX_PATH);
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_SCHEMATYPE;
        AQConfig.szMsgCatSchemaType = SchemaType;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutStringA(
                PE_ISERVID_SZ_CATSCHEMA,
                TempString.QueryStr())));
    }

    TempString.Reset();

    if (mb.GetStr("RoutingSources", MD_SMTP_DS_BIND_TYPE, IIS_MD_UT_SERVER, &TempString) &&
        !TempString.IsEmpty()) {
        lstrcpyn(BindType, TempString.QueryStr(), MAX_PATH);
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_BINDTYPE;
        AQConfig.szMsgCatBindType = BindType;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutStringA(
                PE_ISERVID_SZ_CATBINDTYPE,
                TempString.QueryStr())));
    }

    TempString.Reset();

    if (mb.GetStr("RoutingSources", MD_SMTP_DS_PASSWORD, IIS_MD_UT_SERVER, &TempString, METADATA_INHERIT | METADATA_SECURE )) {
        lstrcpyn(Password, TempString.QueryStr(), MAX_PATH);
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_PASSWORD;
        AQConfig.szMsgCatPassword = Password;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutStringA(
                PE_ISERVID_SZ_CATPASSWORD,
                TempString.QueryStr())));
    }

    TempString.Reset();

    if (mb.GetStr("RoutingSources", MD_SMTP_DS_DOMAIN, IIS_MD_UT_SERVER, &TempString) &&
        !TempString.IsEmpty()) {
        lstrcpyn(Domain, TempString.QueryStr(), MAX_PATH);
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_DOMAIN;
        AQConfig.szMsgCatDomain = Domain;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutStringA(
                PE_ISERVID_SZ_CATDOMAIN,
                TempString.QueryStr())));
    }

    TempString.Reset();

    if (mb.GetStr("RoutingSources", MD_SMTP_DS_NAMING_CONTEXT, IIS_MD_UT_SERVER, &TempString) &&
        !TempString.IsEmpty()) {
        lstrcpyn(NamingContext, TempString.QueryStr(), MAX_PATH);
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_NAMING_CONTEXT;
        AQConfig.szMsgCatNamingContext = NamingContext;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutStringA(
                PE_ISERVID_SZ_CATNAMINGCONTEXT,
                TempString.QueryStr())));
    }

    TempString.Reset();

    if (mb.GetStr("RoutingSources", MD_SMTP_DS_TYPE, IIS_MD_UT_SERVER, &TempString) &&
        !TempString.IsEmpty()) {
        lstrcpyn(DsType, TempString.QueryStr(), MAX_PATH);
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_TYPE;
        AQConfig.szMsgCatType = DsType;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutStringA(
                PE_ISERVID_SZ_CATDSTYPE,
                TempString.QueryStr())));
    }

    AQConfig.cbVersion = sizeof(AQConfigInfo);

    TempString.Reset();

    if(mb.GetStr("RoutingSources", MD_SMTP_DS_HOST, IIS_MD_UT_SERVER, &TempString) &&
       !TempString.IsEmpty())
    {
        lstrcpyn(Host, TempString.QueryStr(), MAX_PATH);
        AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_HOST;
        AQConfig.szMsgCatHost = Host;
        _VERIFY(SUCCEEDED(
            m_InstancePropertyBag.PutStringA(
                PE_ISERVID_SZ_CATDSHOST,
                TempString.QueryStr())));
    }

    //
    // Indicate that all the official "msgcat" keys that exist are set
    //
    AQConfig.dwAQConfigInfoFlags |= AQ_CONFIG_INFO_MSGCAT_DEFAULT;

    AQConfig.cbVersion = sizeof(AQConfigInfo);

    m_pIAdvQueueConfig->SetConfigInfo(&AQConfig);

    return TRUE;
}


BOOL SMTP_SERVER_INSTANCE::ReadRouteDomainIpSecList(MB& mb)
{
    IMDCOM*             pMBCom;
    HRESULT             hRes;
    METADATA_RECORD     mdRecord;
    DWORD               dwRequiredLen;
    DWORD               dwErr;
    BOOL                fSuccess = TRUE;
    char                *szValueName = "";

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::ReadRouteDomainIpSecList");

    ResetRelayIpSecList();

    pMBCom = (IMDCOM*)m_Service->QueryMDObject();

    mdRecord.dwMDIdentifier  = MD_SMTP_IP_RELAY_ADDRESSES;
    mdRecord.dwMDAttributes  = METADATA_INHERIT;
    mdRecord.dwMDUserType    = IIS_MD_UT_FILE;
    mdRecord.dwMDDataType    = BINARY_METADATA;
    mdRecord.dwMDDataLen     = 5000;
    mdRecord.pbMDData        = (PBYTE) new char [5000];

    if (mdRecord.pbMDData == NULL) {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    hRes = pMBCom->ComMDGetMetaData( mb.QueryHandle(),
                                     (LPBYTE)szValueName,
                                     &mdRecord,
                                     &dwRequiredLen );
    if ( SUCCEEDED( hRes ) ) {

        SetRelayIpSecList(mdRecord.pbMDData,
                          mdRecord.dwMDDataLen,
                          mdRecord.dwMDDataTag );
    } else {
        if (mdRecord.pbMDData)
            delete mdRecord.pbMDData;
        fSuccess = FALSE;
        dwErr = HRESULTTOWIN32( hRes );
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fSuccess;
}

void SMTP_SERVER_INSTANCE::BuildTurnTable(MULTISZ&  msz, char * szDomainName)
{
    const char * StartPtr = NULL;
    CTurnData * pTurnData = NULL;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::BuildTurnTable");

    for (StartPtr = msz.First(); StartPtr != NULL; StartPtr = msz.Next( StartPtr )) {
        ((PSMTP_IIS_SERVICE) g_pInetSvc)->StartHintFunction();

        DebugTrace((LPARAM)this , "%s is allowed to issue TURN", StartPtr);

        pTurnData = new CTurnData(StartPtr, szDomainName);
        if (pTurnData != NULL) {
            if (!m_TurnAccessList.InsertIntoTable((CHASH_ENTRY *) pTurnData)) {
                delete pTurnData;
            }
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
}

//+---------------------------------------------------------------
//
//  Function:   SetRouteDomainParameters
//
//  Synopsis:   Does the actual work of adding a domain from the metabase
//
//----------------------------------------------------------------
void SMTP_SERVER_INSTANCE::SetRouteDomainParameters(MB &mb,
                                                    char *szDomainName,
                                                    char *szRoutePath,
                                                    char  szActionType [MAX_PATH + 1],
                                                    char  szUserName [MAX_INTERNET_NAME + 1],
                                                    char  szEtrnDomain [MAX_INTERNET_NAME + 1],
                                                    char  szPassword [MAX_PATH + 1],
                                                    char  szTargetName [MAX_PATH + 1],
                                                    DomainInfo *pLocalDomainInfo)
{
    TraceFunctEnter("SMTP_SERVER_INSTANCE::SetRouteDomainParameters");

    char *      DomainPtr       = NULL;
    char *      UserNamePtr     = NULL;
    char *      PasswordPtr     = NULL;
    char *      TargetNamePtr   = NULL;
    DWORD       dwAction        = 0;
    STR         TempString;
    DWORD       dwErr           = NO_ERROR;
    DWORD       dwLen           = 0;
    BOOL        RelayForAuth    = TRUE;
    DWORD       dwEtrnWaitTime  = 0;
    BOOL        WildCard        = FALSE;
    CHAR        pchAddr1[32]    = "";
    MULTISZ     msz;

    if (szDomainName[0]) {
        ZeroMemory(pLocalDomainInfo, sizeof(DomainInfo));
        pLocalDomainInfo->cbVersion = sizeof(DomainInfo);
        pLocalDomainInfo->cbDomainNameLength = lstrlen(szDomainName);
        pLocalDomainInfo->szDomainName = szDomainName;

        szActionType [0] = '\0';
        szUserName [0] = '\0';
        szPassword [0] = '\0';
        szEtrnDomain[0] = '\0';
        szTargetName[0] = '\0';

        UserNamePtr = szUserName;
        PasswordPtr = szPassword;
        TargetNamePtr = szTargetName;
        dwAction = 0;

        DomainPtr = szDomainName;

        if (!mb.GetDword(szRoutePath, MD_ROUTE_ACTION, IIS_MD_UT_SERVER, &dwAction)) {
            dwAction = 0;
        }

        // If we don't recognize the actions we bail now - SMTP_DEFAULT
        // shound never be set on any RouteAction in the metabase
        if ((dwAction & ~SMTP_ALL_ROUTE_FLAGS) || (dwAction & SMTP_DEFAULT)) {
            TraceFunctLeave();
            return;
        }

        TempString.Reset();
        if (mb.GetStr(szRoutePath, MD_ROUTE_ACTION_TYPE, IIS_MD_UT_SERVER, &TempString, 0) &&
            !TempString.IsEmpty()) {
            lstrcpyn(szActionType, TempString.QueryStr(), MAX_PATH);
        }

        TempString.Reset();

        if (((dwAction & SMTP_SMARTHOST) || (dwAction & SMTP_SASL)) && mb.GetStr(szRoutePath, MD_ROUTE_USER_NAME, IIS_MD_UT_SERVER, &TempString) &&
            !TempString.IsEmpty()) {
            lstrcpyn(szUserName, TempString.QueryStr(), MAX_INTERNET_NAME);
        } else {
            UserNamePtr = NULL;
        }

        TempString.Reset();

        if (UserNamePtr != NULL) {
            if (mb.GetStr(szRoutePath, MD_ROUTE_PASSWORD, IIS_MD_UT_SERVER, &TempString, METADATA_SECURE | METADATA_INHERIT) &&
                !TempString.IsEmpty()) {
                lstrcpyn(szPassword, TempString.QueryStr(), MAX_PATH);
            }
        } else {
            PasswordPtr = "";
        }

        TempString.Reset();

        if (TargetNamePtr != NULL) {
            if (mb.GetStr(szRoutePath, MD_ROUTE_AUTHTARGET, IIS_MD_UT_SERVER, &TempString, METADATA_SECURE | METADATA_INHERIT) &&
                !TempString.IsEmpty()) {
                lstrcpyn(szTargetName, TempString.QueryStr(), MAX_PATH);
            }
        } else {
            TargetNamePtr = "";
        }

        TempString.Reset();
        if (mb.GetStr(szRoutePath, MD_SMTP_CSIDE_ETRN_DOMAIN, IIS_MD_UT_SERVER, &TempString, 0) &&
            !TempString.IsEmpty()) {
            lstrcpyn(szEtrnDomain, TempString.QueryStr(), AB_MAX_DOMAIN);
        }

        dwEtrnWaitTime = ReadMetabaseDword(mb, MD_SMTP_CSIDE_ETRN_DELAY, 0);

        //
        //  If the domain is set to explicitly allow relay for authenticated users..
        //  use that value.  Otherwise, use the value set on the VSI (to maintain 
        //  backwards compatibility with W2K users).
        //
        if (dwAction & SMTP_AUTH_RELAY)
           RelayForAuth = TRUE;
        else
           RelayForAuth = m_fRelayForAuthUsers;

        if (dwAction & SMTP_SMARTHOST) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_REMOTE_SMARTHOST;

            if (dwAction & SMTP_SSL)
                pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_USE_SSL;

            if (szActionType[0] != '\0') {
                pLocalDomainInfo->szSmartHostDomainName = szActionType;
                pLocalDomainInfo->cbSmartHostDomainNameLength = lstrlen(szActionType);
            } else if (*szDomainName == '*') {
                //The domain names could be specified as "*" - an explicit smart
                //host must be used.
                pLocalDomainInfo->dwDomainInfoFlags &= ~DOMAIN_INFO_REMOTE_SMARTHOST;
            } else { //use the domain name as our smarthost
                pLocalDomainInfo->szSmartHostDomainName = szDomainName;
                pLocalDomainInfo->cbSmartHostDomainNameLength = lstrlen(pLocalDomainInfo->szSmartHostDomainName);
            }
        }

        //if we are doing SASL, make sure we have a username and password
        //and a correct authentication bits
        if (dwAction & SMTP_SASL) {

            // One of these must be set or else the SMTP_SASL flag doesn't
            // make sense
            if (!(dwAction & SMTP_AUTH_NTLM) &&
                !(dwAction & SMTP_AUTH_CLEARTEXT) &&
                !(dwAction & SMTP_AUTH_KERBEROS)) {

                // dbraun : we can be cleaner about handling this - bailing
                // leaves us with an incompletely configured domain

                TraceFunctLeave();
                return;
            }

            if (UserNamePtr) {
                pLocalDomainInfo->szUserName = UserNamePtr;
                pLocalDomainInfo->cbUserNameLength = lstrlen (UserNamePtr);
            }

            if (PasswordPtr) {
                pLocalDomainInfo->szPassword = PasswordPtr;
                pLocalDomainInfo->cbPasswordLength = lstrlen(PasswordPtr);
            }

            if (dwAction & SMTP_AUTH_NTLM) {
                pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_USE_NTLM;
            }

            if (dwAction & SMTP_AUTH_CLEARTEXT) {
                pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_USE_PLAINTEXT;
            }
            if (dwAction & SMTP_AUTH_KERBEROS) {
                pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_USE_KERBEROS;
                if (TargetNamePtr) {
                    pLocalDomainInfo->szAuthType = TargetNamePtr;
                    pLocalDomainInfo->cbAuthTypeLength = lstrlen(TargetNamePtr);
                }
            }

        }


        char * szTmpDomain;
        //Check for the wildcard entries
        if (*DomainPtr == '*' && *(DomainPtr+1) == '.') {
            WildCard = TRUE;
            szTmpDomain = DomainPtr + 2;
        } else {
            szTmpDomain = DomainPtr;
        }


        if (szTmpDomain[0] != '*' || szTmpDomain[1] != 0) {
            if (!CAddr::ValidateDomainName(szTmpDomain)) {
                ErrorTrace((LPARAM)this , "%s is an invalid domain", DomainPtr);

                //bad domain name
                TraceFunctLeave();
                return;
            }
        }

        if (dwAction & SMTP_DROP) {
            if (!CreateLayerDirectory(szActionType) && (dwErr = GetLastError()) != ERROR_ALREADY_EXISTS) {
                // Reflect the changes
                const CHAR *aszStrings[3];
                CHAR szTemp1[MAX_PATH + 1];
                CHAR szTemp2[MAX_PATH + 1];

                aszStrings[0] = pchAddr1;
                aszStrings[1] = szTemp1;
                aszStrings[2] = szTemp2;

                lstrcpyn(szTemp1, szActionType, MAX_PATH);
                lstrcpyn(szTemp2, DomainPtr, MAX_PATH);
                SmtpLogEvent(SMTP_EVENT_NO_DROP_DIRECTORY, 3, aszStrings, dwErr);
            }

            dwLen = lstrlen(szActionType);
            if (dwLen > 0 && szActionType[dwLen-1] != '\\')
                lstrcat(szActionType, "\\");

            pLocalDomainInfo->szDropDirectory = szActionType;
            pLocalDomainInfo->cbDropDirectoryLength = lstrlen (szActionType);
            pLocalDomainInfo->dwDomainInfoFlags = DOMAIN_INFO_LOCAL_DROP;
        }

        // Remove original one if it is there
        DeleteDomainEntry((const char *) DomainPtr);

        //
        // Insert local domains into the routing table.
        //
        if ((dwAction & SMTP_DELIVER) && (szActionType[0] == '\0')) {
            DebugTrace((LPARAM)this , "adding %s as a DELIVER domain", szDomainName);

            pLocalDomainInfo->dwDomainInfoFlags = DOMAIN_INFO_LOCAL_MAILBOX;

        } else if (dwAction & SMTP_ALIAS) {
            DebugTrace((LPARAM)this , "adding %s as a ALIAS domain", szDomainName);

            if (IsDefaultInRt()) {
                pLocalDomainInfo->dwDomainInfoFlags = DOMAIN_INFO_LOCAL_MAILBOX | DOMAIN_INFO_ALIAS;
            } else {
                pLocalDomainInfo->szDropDirectory = m_szMailDropDir;
                pLocalDomainInfo->cbDropDirectoryLength = lstrlen (m_szMailDropDir);
                pLocalDomainInfo->dwDomainInfoFlags = DOMAIN_INFO_LOCAL_DROP | DOMAIN_INFO_ALIAS;
            }
        }

        if (RelayForAuth) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_AUTH_RELAY;
        }

        if (dwAction & SMTP_DOMAIN_RELAY) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_DOMAIN_RELAY;
        }

        msz.Reset();

        if ((dwAction & SMTP_ETRN_CMD) && mb.GetMultisz(szRoutePath, MD_SMTP_AUTHORIZED_TURN_LIST, IIS_MD_UT_SERVER, &msz) &&
            !msz.IsEmpty()) {
            BuildTurnTable(msz, szTmpDomain);
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_TURN_ONLY;
        }
        if (dwAction & SMTP_ETRN_CMD && !(dwAction & SMTP_DISABLE_ETRN) ) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_ETRN_ONLY;
        }//if(dwAction & SMTP_ETRN_CMD)

        if (dwAction & SMTP_USE_HELO ) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_USE_HELO;
        }//if(dwAction & SMTP_USE_HELO)

        if (dwAction & SMTP_CSIDE_ETRN) {

            TempString.Reset();
            if (mb.GetStr(szRoutePath, MD_SMTP_CSIDE_ETRN_DOMAIN, IIS_MD_UT_SERVER, &TempString, 0) &&
                !TempString.IsEmpty()) {
                pLocalDomainInfo->szETRNDomainName = szEtrnDomain;
                lstrcpyn(pLocalDomainInfo->szETRNDomainName, TempString.QueryStr(), AB_MAX_DOMAIN);
                pLocalDomainInfo->cbETRNDomainNameLength = strlen(szEtrnDomain);
                pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_SEND_ETRN;
            }

        }//if(dwAction & SMTP_CSIDE_ETRN)

        if (dwAction & SMTP_CSIDE_TURN) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_SEND_TURN;
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_TURN_ON_EMPTY;

        }//if(dwAction & SMTP_CSIDE_TURN)


        if (dwAction & SMTP_DISABLE_BMIME) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_DISABLE_BMIME;

        }//if(dwAction & SMTP_DISABLE_BMIME)

        if (dwAction & SMTP_CHUNKING) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_USE_CHUNKING;

        }//if(dwAction & SMTP_CHUNKING)
        else if (dwAction & SMTP_DISABLE_CHUNK) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_DISABLE_CHUNKING;
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_DISABLE_BMIME;
        }

        if (dwAction & SMTP_DISABLE_DSN) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_DISABLE_DSN;

        }//if(dwAction & SMTP_DISBALE_DSN)

        if (dwAction & SMTP_DISABLE_PIPELINE) {
            pLocalDomainInfo->dwDomainInfoFlags |= DOMAIN_INFO_DISABLE_PIPELINE;

        }//if(dwAction & SMTP_DISABLE_PIPELINE)

    }//if (szDomainName[0])
    TraceFunctLeave();
}

//+---------------------------------------------------------------
//
//  Function:   AddDomainEntry
//
//  Synopsis:   Add a domain into cached tables.
//
//  Arguments:  MB:         already opened metabase.
//              DomainName: name of the domain to add.
//
//  Returns:    BOOL - TRUE on SUCCESS, FALSE on FAIL
//
//----------------------------------------------------------------
BOOL SMTP_SERVER_INSTANCE::AddDomainEntry (MB &mb, char * DomainName)
{
    HRESULT hr              = S_OK;
    BOOL    fReturn         = TRUE;
    char    szDomainName    [AB_MAX_DOMAIN + 1];
    char    szRoutePath     [MAX_PATH + 1];
    char    szActionType    [MAX_PATH + 1];
    char    szUserName      [MAX_INTERNET_NAME + 1];
    char    szEtrnDomain    [AB_MAX_DOMAIN + 1];
    char    szPassword      [MAX_PATH + 1];
    char    szTargetName    [MAX_PATH + 1];
    DomainInfo  LocalDomainInfo;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::AddNewEntry");

    strcpy(szDomainName, DomainName);

    if (szDomainName[0])
    {
        szRoutePath[0] = '\0';
        wsprintf(szRoutePath, "/Domain/%s", szDomainName);

        SetRouteDomainParameters(mb,
                                 szDomainName,
                                 szRoutePath,
                                 szActionType,
                                 szUserName,
                                 szEtrnDomain,
                                 szPassword,
                                 szTargetName,
                                 &LocalDomainInfo);
        hr = m_pIAdvQueueConfig->SetDomainInfo(&LocalDomainInfo);
        if (FAILED(hr))
        {
            fReturn = FALSE;
        }
    }//if (szDomainName[0])

    TraceFunctLeaveEx((LPARAM)this);
    return fReturn;
}


//+---------------------------------------------------------------
//
//  Function:   GetRouteDomains
//
//  Synopsis:   Get Routing domains from the metabase
//
//  Arguments:  MB:         already opened metabase.
//              DomainName: name of the domain to add.
//              fRebuild:   bool indicating if we need to rebuild
//                           the whole table
//
//  Returns:    BOOL - TRUE on SUCCESS, FALSE on FAIL
//
//----------------------------------------------------------------
BOOL SMTP_SERVER_INSTANCE::GetRouteDomains(MB &mb, char * DomainName, BOOL fRebuild)
{
    HRESULT         hr              = S_OK;
    DWORD           ThreadId;
    DWORD           error;
    BOOL            fReturn         = TRUE;
    DomainInfo      LocalDomainInfo;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::GetRouteDomains");

    ((PSMTP_IIS_SERVICE) g_pInetSvc)->StartHintFunction();

    m_TurnAccessList.SetDupesAllowed();

    // Only rebuild when fRebuild is TRUE.
    if (fRebuild)
    {
        // We need to clean m_hEnumDomainThreadHandle here
        // to avoid handle leak.
        if (m_hEnumDomainThreadHandle)
        {
            if (!m_fEnumThreadStarted) {
                // the thread has been created, but it has not been
                // able to grab the gencrit lock yet.  This means
                // that it will be doing a full rebuild already, so
                // we can just bail
                goto cleanup;
            }

            // Set up signal and wait
            WaitForSingleObject(m_hEnumDomainThreadHandle, INFINITE);
            ErrorTrace((LPARAM)this, "EnumDomain Thread is dead");
            CloseHandle(m_hEnumDomainThreadHandle);
            m_hEnumDomainThreadHandle = NULL;
        }

        m_fEnumThreadStarted = FALSE;
        m_hEnumDomainThreadHandle = CreateThread (NULL, 0,
                    EnumAllDomains, this, 0, &ThreadId);
        if(m_hEnumDomainThreadHandle == NULL)
        {
            error = GetLastError();
            ErrorTrace((LPARAM)this, "CreateThread failed for EnumAllDomains. err: %u", error);
            fReturn = FALSE;
        }
        else
        {
            DebugTrace((LPARAM)this , "EnumDomainThread is created, threadId [%ld]", ThreadId);
        }
    }
    else
    {
        if (!AddDomainEntry(mb, DomainName))
            fReturn = FALSE;
    }

cleanup:
    TraceFunctLeaveEx((LPARAM)this);
    return fReturn;
}


//+---------------------------------------------------------------
//
//  Function:   EnumAllDomains
//
//  Synopsis:   Enumerate all domains in this SMTP instance.
//
//  Arguments:  ptr: pointer to the SMTP server instance.
//
//  Returns:    BOOL - TRUE on SUCCESS, FALSE on FAIL
//
//----------------------------------------------------------------
DWORD EnumAllDomains(VOID *ptr)
{
    HRESULT     hr              = S_OK;
    char        szDomainName    [AB_MAX_DOMAIN + 1];
    char        szRoutePath     [MAX_PATH + 1];
    char        szActionType    [MAX_PATH + 1];
    char        szUserName      [MAX_INTERNET_NAME + 1];
    char        szEtrnDomain    [AB_MAX_DOMAIN + 1];
    char        szPassword      [MAX_PATH + 1];
    char        szTargetName    [MAX_PATH + 1];
    char        szStarDomain[]  = "*";
    DWORD       dwTotal         = 0;
    DomainInfo  LocalDomainInfo;
    MB          mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );
    SMTP_SERVER_INSTANCE *pInstance = (SMTP_SERVER_INSTANCE *) ptr;

    TraceFunctEnterEx((LPARAM)pInstance, "EnumAllDomains");

    pInstance->ExclusiveLockGenCrit();

    pInstance->m_fEnumThreadStarted = TRUE;

    pInstance->m_TurnAccessList.SetDupesAllowed();
    pInstance->m_TurnAccessList.RemoveAllEntries();

    //Signal AQ that we are starting over
    pInstance->m_pIAdvQueueConfig->StartConfigUpdate();

    if (pInstance->m_szMailDropDir[0] == '\0')
    {
        ZeroMemory(&LocalDomainInfo, sizeof(DomainInfo));
        LocalDomainInfo.cbVersion = sizeof(DomainInfo);
        LocalDomainInfo.cbDomainNameLength = lstrlen(pInstance->m_szDefaultDomain);
        LocalDomainInfo.szDomainName = pInstance->m_szDefaultDomain;
        LocalDomainInfo.dwDomainInfoFlags = DOMAIN_INFO_LOCAL_MAILBOX;

        HRESULT hr;
        hr = pInstance->m_pIAdvQueueConfig->SetDomainInfo(&LocalDomainInfo);

        DebugTrace((LPARAM)pInstance , "default domain %s was added to the routing table", pInstance->m_szDefaultDomain);

        //signals default domain was added to routing table
        pInstance->m_fDefaultInRt = TRUE;
    }
    else
    {
        ZeroMemory(&LocalDomainInfo, sizeof(DomainInfo));
        LocalDomainInfo.cbVersion = sizeof(DomainInfo);
        LocalDomainInfo.cbDomainNameLength = lstrlen(pInstance->m_szDefaultDomain);
        LocalDomainInfo.szDomainName = pInstance->m_szDefaultDomain;
        LocalDomainInfo.szDropDirectory = pInstance->m_szMailDropDir;
        LocalDomainInfo.cbDropDirectoryLength = lstrlen (pInstance->m_szMailDropDir);
        LocalDomainInfo.dwDomainInfoFlags = DOMAIN_INFO_LOCAL_DROP;

        hr = pInstance->m_pIAdvQueueConfig->SetDomainInfo(&LocalDomainInfo);
    }

    if( !mb.Open( pInstance->QueryMDPath(), METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE) )
    {
        pInstance->ExclusiveUnLockGenCrit();
        return FALSE;
    }

    while (!pInstance->IsShuttingDown() && mb.EnumObjects("/Domain", szDomainName, dwTotal++)) {

        if (szDomainName[0]) {
            szRoutePath[0] = '\0';
            wsprintf(szRoutePath, "/Domain/%s", szDomainName);

            pInstance->SetRouteDomainParameters(mb,
                                     szDomainName,
                                     szRoutePath,
                                     szActionType,
                                     szUserName,
                                     szEtrnDomain,
                                     szPassword,
                                     szTargetName,
                                     &LocalDomainInfo);
            hr = pInstance->m_pIAdvQueueConfig->SetDomainInfo(&LocalDomainInfo);
            if (FAILED(hr)) {
            }
        }//if (szDomainName[0])
    }//while (mb.EnumObjects("/RouteDomains", szDomainName, dw++))


    pInstance->SetRouteDomainParameters(mb,
                                szStarDomain, "",
                                szActionType,
                                szUserName,
                                szEtrnDomain,
                                szPassword,
                                szTargetName,
                                &LocalDomainInfo);

    if (pInstance->AlwaysUseSmartHost() && pInstance->m_szSmartHostName[0]) {
        LocalDomainInfo.dwDomainInfoFlags |= DOMAIN_INFO_REMOTE_SMARTHOST;
        LocalDomainInfo.szSmartHostDomainName = pInstance->m_szSmartHostName;
        LocalDomainInfo.cbSmartHostDomainNameLength = lstrlen(pInstance->m_szSmartHostName);
    }

    //check if we should always use SSL
    if (pInstance->GetDefaultRouteAction() & SMTP_SSL) {
        LocalDomainInfo.dwDomainInfoFlags |= DOMAIN_INFO_USE_SSL;
    }

    hr = pInstance->m_pIAdvQueueConfig->SetDomainInfo(&LocalDomainInfo);

    // jstamerj 1998/07/24 11:18:39:
    //   For M2, AQueue requires a local domain entry " " in its
    //   configuration to handle recipients without SMTP addresses
    //   (such as an remote X400 address).  This will be removed when
    //   code is added to encapsualte non-SMTP addresses into SMTP.
    //   Add this local domain here.
    //
    ZeroMemory(&LocalDomainInfo, sizeof(DomainInfo));

    LocalDomainInfo.cbVersion = sizeof(DomainInfo);
    LocalDomainInfo.cbDomainNameLength = 1;
    LocalDomainInfo.szDomainName = " ";
    LocalDomainInfo.dwDomainInfoFlags = DOMAIN_INFO_LOCAL_MAILBOX;

    hr = pInstance->m_pIAdvQueueConfig->SetDomainInfo(&LocalDomainInfo);

    //Signal AQ that we are finished updating domain config
    pInstance->m_pIAdvQueueConfig->FinishConfigUpdate();

    pInstance->ExclusiveUnLockGenCrit();

    TraceFunctLeaveEx((LPARAM)pInstance);
    return TRUE;
}

BOOL SMTP_SERVER_INSTANCE::ReadIpSecList(void)
{
    IMDCOM*             pMBCom;
    METADATA_HANDLE     hMB;
    HRESULT             hRes;
    METADATA_RECORD     mdRecord;
    DWORD               dwRequiredLen;
    DWORD               dwErr;
    BOOL                fSuccess;

    m_GenLock.ExclusiveLock();

    m_rfAccessCheck.Reset( (IMDCOM*)m_Service->QueryMDObject() );

    pMBCom = (IMDCOM*)m_Service->QueryMDObject();
    hRes = pMBCom->ComMDOpenMetaObject( METADATA_MASTER_ROOT_HANDLE,
                                        (BYTE *) QueryMDPath(),
                                        METADATA_PERMISSION_READ,
                                        5000,
                                        &hMB );
    if ( SUCCEEDED( hRes ) ) {
        mdRecord.dwMDIdentifier  = MD_IP_SEC;
        mdRecord.dwMDAttributes  = METADATA_INHERIT | METADATA_REFERENCE;
        mdRecord.dwMDUserType    = IIS_MD_UT_FILE;
        mdRecord.dwMDDataType    = BINARY_METADATA;
        mdRecord.dwMDDataLen     = 0;
        mdRecord.pbMDData        = (PBYTE)NULL;

        hRes = pMBCom->ComMDGetMetaData( hMB,
                                         (LPBYTE)"",
                                         &mdRecord,
                                         &dwRequiredLen );
        if ( SUCCEEDED( hRes ) && mdRecord.dwMDDataTag ) {
            m_rfAccessCheck.Set( mdRecord.pbMDData,
                                 mdRecord.dwMDDataLen,
                                 mdRecord.dwMDDataTag );
        }

        DBG_REQUIRE( SUCCEEDED(pMBCom->ComMDCloseMetaObject( hMB )) );
    } else {
        fSuccess = FALSE;
        dwErr = HRESULTTOWIN32( hRes );
    }

    m_GenLock.ExclusiveUnlock();
    return TRUE;

}

BOOL IsNTFS(IN  LPCSTR  pszRealPath)

/*++
    Gets file system specific information for a given path.
    It uses GetVolumeInfomration() to query the file system type
       and file system flags.
    On success the flags and file system type are returned in
       passed in pointers.

--*/
{
#define MAX_FILE_SYSTEM_NAME_SIZE    ( MAX_PATH)
    CHAR rgchBuf[MAX_FILE_SYSTEM_NAME_SIZE];
    CHAR rgchRoot[MAX_FILE_SYSTEM_NAME_SIZE];
    int   i;
    DWORD dwReturn = ERROR_PATH_NOT_FOUND;

    if ( pszRealPath   == NULL) {
        return FALSE;
    }

    if ( pszRealPath[0] == ('\\') &&
         pszRealPath[1] == ('\\')) {

        return FALSE;

    } // else

    ZeroMemory( (void *) rgchRoot, sizeof(rgchRoot) );

    //
    // This is non UNC name.
    // Copy just the root directory to rgchRoot for querying
    //

    for ( i = 0; i < 9 && pszRealPath[i] != '\0'; i++) {

        if ( (rgchRoot[i] = pszRealPath[i]) == ':') {

            break;
        }
    } // for


    if ( rgchRoot[i] != ':') {

        //
        // we could not find the root directory.
        //  return with error value
        //
        return ( FALSE);
    }

    rgchRoot[i+1] = '\\';     // terminate the drive spec with a slash
    rgchRoot[i+2] = '\0';     // terminate the drive spec with null char

    // The rgchRoot should end with a "\" (slash)
    // otherwise, the call will fail.
    if (  GetVolumeInformation( rgchRoot,        // lpRootPathName
                                NULL,            // lpVolumeNameBuffer
                                0,               // len of volume name buffer
                                NULL,            // lpdwVolSerialNumber
                                NULL,            // lpdwMaxComponentLength
                                NULL,            // lpdwSystemFlags
                                rgchBuf,         // lpFileSystemNameBuff
                                sizeof(rgchBuf)/sizeof(WCHAR)
                              )) {



        if ( lstrcmp( rgchBuf, "NTFS") == 0) {
            return TRUE;
        }

    }

    return ( FALSE);

}


//+---------------------------------------------------------------
//
//  Function:   SMTPCONFIG::ReadStartupRegParams
//
//  Synopsis:   Reads fixed (i.e. not modifiable on-the-fly) parameters
//              from the registry into the config class member variables.
//
//  Arguments:  None
//
//  Returns:    BOOL - TRUE on SUCCESS, FALSE on FAIL
//
//  Note:       Created by KeithLau on 7/15/96
//
//----------------------------------------------------------------
BOOL SMTP_SERVER_INSTANCE::ReadStartupRegParams(VOID)
{
    BOOL        fRet = TRUE;
    DWORD       dwErr = NO_ERROR;
    DWORD       dwAttr;
    char        szValueName[MAX_PATH + 1];
    MB          mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    STR         TempString;
    const CHAR * apszSubStrings[2];
    CHAR pchAddr1[32] = "";


    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::ReadStartupRegParams");

    GetServerBindings();

    m_GenLock.ExclusiveLock();

    //
    //  Read metabase data.
    //

    lstrcpy(szValueName, QueryMDPath());

    _itoa(QueryInstanceId(), pchAddr1, 10);

    if ( !mb.Open( szValueName, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE) ) {
        //UnLockConfig();
        m_GenLock.ExclusiveUnlock();
        return FALSE;
    }

    m_CmdLogFlags = ReadMetabaseDword(mb, MD_COMMAND_LOG_MASK, DEFAULT_CMD_LOG_FLAGS);

    m_fFlushMailFiles = !!ReadMetabaseDword(mb, MD_FLUSH_MAIL_FILE, TRUE);

    m_cMaxRoutingThreads = ReadMetabaseDword(mb, MD_ROUTING_THREADS, 8);
    StateTrace((LPARAM)this, "m_cMaxRoutingThreads = %u", m_cMaxRoutingThreads);

    m_fDisablePickupDotStuff = !!ReadMetabaseDword(mb, MD_SMTP_DISABLE_PICKUP_DOT_STUFF, FALSE);
    StateTrace((LPARAM)this, "m_fDisablePickupDotStuff = %u", m_fDisablePickupDotStuff);

    m_cMaxRemoteQThreads = ReadMetabaseDword(mb, MD_SMTP_MAX_REMOTEQ_THREADS, 1);
    StateTrace((LPARAM)this, "m_cMaxRoutingThreads = %u",m_cMaxRemoteQThreads);
    m_cMaxLocalQThreads = ReadMetabaseDword(mb, MD_SMTP_MAX_LOCALQ_THREADS, 1);
    StateTrace((LPARAM)this, "m_cMaxRoutingThreads = %u", m_cMaxLocalQThreads);

    TempString.Reset();
    if (!mb.GetStr("", MD_MAIL_QUEUE_DIR, IIS_MD_UT_SERVER, &TempString, 0) ||
        TempString.IsEmpty()) {
        // We had a problem reading the registry.
        // This is a very bad thing.  We obviously cannot run without
        // a queue directory, so set fRet to FALSE so that we shut
        // back down (and log it so that an admin can fix it).
        m_szMailQueueDir[0] = '\0';
        fRet = FALSE;
        apszSubStrings[0] = pchAddr1;
        apszSubStrings[1] = szMailQueueDir;

        SmtpLogEvent(SMTP_EVENT_CANNOT_READ_SVC_REGKEY, 2, apszSubStrings, 0);
    } else {
        lstrcpyn(m_szMailQueueDir, TempString.QueryStr(), MAX_PATH);

        if (!IsNTFS(m_szMailQueueDir)) {
            m_IsFileSystemNtfs = FALSE;

            DebugTrace((LPARAM)this, "Queue dir (%s) is not NTFS", m_szMailQueueDir);
        }

        // We found a path in the reg, so see if we can use it...
        dwAttr = GetFileAttributes(m_szMailQueueDir);
        if (dwAttr == 0xFFFFFFFF) {
            // The path doesn't exist yet, so we'll try to create it.
            if (!CreateLayerDirectory(m_szMailQueueDir) && (dwErr = GetLastError()) != ERROR_ALREADY_EXISTS) {
                // It doesn't exist and we couldn't create it, so
                // log it and bail with fRet = FALSE so that we shut
                // back down.
                ErrorTrace((LPARAM)this, "Unable to create mail queue directory (%s)", m_szMailQueueDir);
                apszSubStrings[0] = pchAddr1;
                apszSubStrings[1] = m_szMailQueueDir;
                SmtpLogEvent(SMTP_EVENT_INVALID_MAIL_QUEUE_DIR, 2, apszSubStrings, dwErr);
                m_szMailQueueDir[0] = '\0';
                fRet = FALSE;
            }
        } else {
            if (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY)) {
                // The registry points to a file, so we're outta luck.
                // The directory doesn't exist, and we can't create it.
                // Because this is the queue directory, we're not going
                // to be able to start.  Log it so it can be fixed, but
                // set fRet to FALSE so that we shut back down.

                ErrorTrace((LPARAM)this, "Mail queue directory (%s) already exists as a file", m_szMailQueueDir);
                apszSubStrings[0] = pchAddr1;
                apszSubStrings[1] = m_szMailQueueDir;
                SmtpLogEvent(SMTP_EVENT_INVALID_MAIL_QUEUE_DIR, 2, apszSubStrings, dwErr);
                m_szMailQueueDir[0] = '\0';
                fRet = FALSE;
            }
        }
    }

    TempString.Reset();

    if (! mb.GetStr("", MD_MAIL_DROP_DIR, IIS_MD_UT_SERVER, &TempString, 0) ||
        TempString.IsEmpty()) {
        // We had a problem reading the metabase.
        // This is a very bad thing.  We obviously cannot run without
        // a drop directory if we are in drop mode, so set fRet to
        // FALSE so that we shut back down (and log it so that an
        // admin can fix it).
        m_szMailDropDir[0] = '\0';
        m_cchMailDropDir = 0;

        //don't start if we are disabled, since drop directory is  not
        //configurable.
        if (!m_fIsRoutingTable) {
            fRet = FALSE;
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = szMailDropDir;
            SmtpLogEvent(SMTP_EVENT_CANNOT_READ_SVC_REGKEY, 2, apszSubStrings, 0);
        }
    } else {
        lstrcpyn(m_szMailDropDir, TempString.QueryStr(), MAX_PATH);

        apszSubStrings[0] = pchAddr1;
        apszSubStrings[1] = m_szMailDropDir;

        // We found a path in the reg, so see if we can use it...
        dwAttr = GetFileAttributes(m_szMailDropDir);
        if (dwAttr == 0xFFFFFFFF) {
            // The path doesn't exist yet, so we'll try to create it.
            if (!CreateLayerDirectory(m_szMailDropDir) && (dwErr = GetLastError()) != ERROR_ALREADY_EXISTS) {
                // It doesn't exist and we couldn't create it, so
                // log it and bail with fRet = FALSE so that we shut
                // back down.
                ErrorTrace((LPARAM)this, "Unable to create mail drop directory (%s)", m_szMailQueueDir);
                apszSubStrings[0] = pchAddr1;
                apszSubStrings[1] = m_szMailDropDir;
                SmtpLogEvent(SMTP_EVENT_INVALID_MAIL_DROP_DIR, 2, apszSubStrings, dwErr);
                m_szMailDropDir[0] = '\0';
                m_cchMailDropDir = 0;

                //don't start if we are disabled, since drop directory is  not
                //configurable.
                if (!m_fIsRoutingTable)
                    fRet = FALSE;
            }
        } else {
            if (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY)) {
                // The registry points to a file, so we're outta luck.
                // The directory doesn't exist, and we can't create it.
                // Because this is the queue directory, we're not going
                // to be able to start.  Log it so it can be fixed, but
                // set fRet to FALSE so that we shut back down.
                ErrorTrace((LPARAM)this, "Mail drop directory (%s) already exists as a file", m_szMailDropDir);
                apszSubStrings[0] = pchAddr1;
                apszSubStrings[1] = m_szMailDropDir;
                SmtpLogEvent(SMTP_EVENT_INVALID_MAIL_DROP_DIR, 2, apszSubStrings, dwErr);
                m_szMailDropDir[0] = '\0';

                //don't start if we are disabled, since drop directory is  not
                //configurable.
                if (!m_fIsRoutingTable)
                    fRet = FALSE;
            }
        }

        // Looks like everything is going to be OK, so we add a backslash (if
        // necessary) because it makes things easier later.
        m_cchMailDropDir = lstrlen(m_szMailDropDir);
        if (m_cchMailDropDir > 0 && m_szMailDropDir[m_cchMailDropDir - 1] != '\\') {
            lstrcat(m_szMailDropDir, "\\");
            m_cchMailDropDir++;
        }
    }

    // Looks like everything is going to be OK, so we add a backslash (if
    // necessary) because it makes things easier later.
    m_cchMailQueueDir = lstrlen(m_szMailQueueDir);
    if (m_cchMailQueueDir > 0 && m_szMailQueueDir[m_cchMailQueueDir - 1] != '\\') {
        lstrcat(m_szMailQueueDir, "\\");
        m_cchMailQueueDir++;
    }

    m_fShouldPickupMail = !!ReadMetabaseDword(mb, MD_SHOULD_PICKUP_MAIL, TRUE);
    if (m_fShouldPickupMail) {
        m_cMaxDirBuffers = ReadMetabaseDword(mb, MD_MAX_DIR_BUFFERS, 2000);
        m_cMaxDirChangeIoSize = ReadMetabaseDword(mb, MD_MAX_DIR_CHANGE_IO_SIZE, 1000);
        m_cMaxDirPendingIos = ReadMetabaseDword(mb, MD_MAX_DIR_PENDING_IOS, 1);

        TempString.Reset();

        if (!mb.GetStr("", MD_MAIL_PICKUP_DIR, IIS_MD_UT_SERVER, &TempString, 0) ||
            TempString.IsEmpty()) {
            // We had a problem reading the registry.
            // This is a very bad thing.
            m_szMailPickupDir[0] = '\0';
            m_fShouldPickupMail = 0;
            apszSubStrings[0] = pchAddr1;
            apszSubStrings[1] = szMailPickupDir;
            SmtpLogEvent(SMTP_EVENT_CANNOT_READ_SVC_REGKEY, 2, apszSubStrings, 0);

        } else {
            lstrcpyn(m_szMailPickupDir, TempString.QueryStr(), MAX_PATH);

            // We found a path in the reg, so see if we can use it...
            dwAttr = GetFileAttributes(m_szMailPickupDir);
            if (dwAttr == 0xFFFFFFFF) {
                // The path doesn't exist yet, so we'll try to create it.
                if (!CreateLayerDirectory(m_szMailPickupDir) && (dwErr = GetLastError()) != ERROR_ALREADY_EXISTS) {
                    // It doesn't exist and we couldn't create it, so
                    // log it and bail with fRet = FALSE so that we shut
                    // back down.
                    ErrorTrace((LPARAM)this, "Unable to create mail pickup queue directory (%s)", m_szMailPickupDir);
                    apszSubStrings[0] = pchAddr1;
                    apszSubStrings[1] = m_szMailPickupDir;
                    SmtpLogEvent(SMTP_EVENT_INVALID_MAIL_DROP_DIR, 2, apszSubStrings, dwErr);
                    m_szMailPickupDir[0] = '\0';
                    m_fShouldPickupMail = 0;
                }
            } else {
                if (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY)) {
                    // The registry points to a file, so we're outta luck.
                    // The directory doesn't exist, and we can't create it.
                    ErrorTrace((LPARAM)this, "Mail pickup queue directory (%s) already exists as a file", m_szMailPickupDir);
                    apszSubStrings[0] = pchAddr1;
                    apszSubStrings[1] = m_szMailPickupDir;
                    SmtpLogEvent(SMTP_EVENT_INVALID_MAIL_DROP_DIR, 2, apszSubStrings, dwErr);
                    m_szMailPickupDir[0] = '\0';
                    m_fShouldPickupMail = 0;
                }
            }
        }

        // Looks like everything is going to be OK, so we add a backslash (if
        // necessary) because it makes things easier later.
        m_cchMailPickupDir = lstrlen(m_szMailPickupDir);
        if (m_cchMailPickupDir > 0 && m_szMailPickupDir[m_cchMailPickupDir - 1] != '\\') {
            lstrcat(m_szMailPickupDir, "\\");
            m_cchMailPickupDir++;
        }
    }

    if (!mb.GetStr("", MD_CONNECT_RESPONSE, IIS_MD_UT_SERVER, &TempString) ||
        TempString.IsEmpty()) {
        // We had a problem reading the metabase
        // This is a very bad thing.
        lstrcpy (m_szConnectResponse, "Microsoft ESMTP MAIL Service, ");
        lstrcat (m_szConnectResponse, g_VersionString);
        lstrcat (m_szConnectResponse, " ready at ");
//      SmtpLogEvent(SMTP_EVENT_CANNOT_READ_SVC_REGKEY, 2, apszSubStrings, 0);
    } else {
        lstrcpyn(m_szConnectResponse, TempString.QueryStr(), MAX_PATH);
    }
    m_cchConnectResponse = lstrlenA(m_szConnectResponse);

    mb.Close();

    m_GenLock.ExclusiveUnlock();

    ReadIpSecList();

    if (!fRet)
        SetLastError(ERROR_PATH_NOT_FOUND);

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

void SMTP_SERVER_INSTANCE::GetServerBindings(void)
{
    DWORD       dwErr = NO_ERROR;

    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::GetServerBindings");

    m_GenLock.ExclusiveLock();

    //
    //  open metabase data.
    //

    if ( !mb.Open( QueryMDPath(), METADATA_PERMISSION_READ ) ) {
        m_GenLock.ExclusiveUnlock();
        TraceFunctLeaveEx((LPARAM)this);
        return ;
    }

    m_ServerBindings.Reset();

    if (!mb.GetMultisz("", MD_SERVER_BINDINGS, IIS_MD_UT_SERVER, &m_ServerBindings) ||
        m_ServerBindings.IsEmpty()) {
        dwErr = GetLastError();
        ErrorTrace((LPARAM)this, "Unable to read server bindings, error = %u", dwErr);
    }

    m_GenLock.ExclusiveUnlock();
    TraceFunctLeaveEx((LPARAM)this);
}


VOID
SMTP_SERVER_INSTANCE::MDChangeNotify(
                                    MD_CHANGE_OBJECT * pco
                                    )
/*++

  This method handles the metabase change notification for this instance

  Arguments:

    hMDHandle - Metabase handle generating the change notification
    pcoChangeList - path and id that has changed

--*/
{
    FIELD_CONTROL   control      = 0;
    BOOL            fSslModified = FALSE;
    DWORD           i;
    DWORD           err;
    DWORD           id;
    DWORD           MdState;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::MDChangeNotify");

    //
    //  Tell our parent about the change notification first
    //

    LockThisForWrite();

    IIS_SERVER_INSTANCE::MDChangeNotify( pco );

    // Save change object
    m_pChangeObject = pco;

    for ( i = 0; i < pco->dwMDNumDataIDs; i++ ) {
        id = pco->pdwMDDataIDs[i];

        switch ( id ) {
        case MD_REVERSE_NAME_LOOKUP:
            control |= FC_SMTP_INFO_REVERSE_LOOKUP;
            break;

        case MD_NTAUTHENTICATION_PROVIDERS:
            control |= FC_SMTP_INFO_NTAUTHENTICATION_PROVIDERS;
            break;

        case MD_MD_SERVER_SS_AUTH_MAPPING:
        case MD_SMTP_CLEARTEXT_AUTH_PROVIDER:
            control |= FC_SMTP_CLEARTEXT_AUTH_PROVIDER;
            break;

        case MD_AUTHORIZATION:
            control |= FC_SMTP_INFO_AUTHORIZATION;
            break;

        case MD_HOP_COUNT:
            control |= FC_SMTP_INFO_MAX_HOP_COUNT;
            break;

        case MD_MAX_SMTP_ERRORS:
        case MD_MAX_SMTP_AUTHLOGON_ERRORS:
            control |= FC_SMTP_INFO_MAX_ERRORS;
            break;

        case MD_MAX_MSG_SIZE:
        case MD_MAX_MSG_SIZE_B4_CLOSE:
            control |= FC_SMTP_INFO_MAX_SIZE;
            break;

        case MD_REMOTE_TIMEOUT:
            control |= FC_SMTP_INFO_REMOTE_TIMEOUT;
            break;

        case MD_MAX_OUTBOUND_CONNECTION:
            control |= FC_SMTP_INFO_MAX_OUTBOUND_CONN;
            break;

        case MD_MAX_RECIPIENTS:
            control |= FC_SMTP_INFO_MAX_RECIPS;
            break;

        case MD_ETRN_SUBDOMAINS:
            control |= FC_SMTP_INFO_ETRN_SUBDOMAINS;
            break;

        case MD_MAIL_DROP_DIR:
            control |= FC_SMTP_INFO_DEFAULT_DROP_DIR;
            control |= FC_SMTP_INFO_DOMAIN_ROUTING;
            break;

        case MD_LOCAL_RETRY_ATTEMPTS:
        case MD_LOCAL_RETRY_MINUTES:
        case MD_REMOTE_RETRY_ATTEMPTS:
        case MD_REMOTE_RETRY_MINUTES:
//        case MD_SHARE_RETRY_MINUTES:
        case MD_SMTP_REMOTE_RETRY_THRESHOLD:
        case MD_SMTP_REMOTE_PROGRESSIVE_RETRY_MINUTES:
        case MD_SMTP_EXPIRE_REMOTE_NDR_MIN:
        case MD_SMTP_EXPIRE_REMOTE_DELAY_MIN:
        case MD_SMTP_EXPIRE_LOCAL_NDR_MIN:
        case MD_SMTP_EXPIRE_LOCAL_DELAY_MIN:
            control |= FC_SMTP_INFO_RETRY;
            break;

        case MD_SHOULD_PIPELINE_OUT:
        case MD_SHOULD_PIPELINE_IN:
            control |= FC_SMTP_INFO_PIPELINE;
            break;

        case MD_SMTP_DS_TYPE:
        case MD_SMTP_DS_DATA_DIRECTORY:
        case MD_SMTP_DS_DEFAULT_MAIL_ROOT:
        case MD_SMTP_DS_BIND_TYPE:
        case MD_SMTP_DS_SCHEMA_TYPE:
        case MD_SMTP_DS_HOST:
        case MD_SMTP_DS_NAMING_CONTEXT:
        case MD_SMTP_DS_ACCOUNT:
        case MD_SMTP_DS_PASSWORD:
        case MD_SMTP_DS_DOMAIN:
        case MD_SMTP_DS_USE_CAT:
        case MD_SMTP_DS_PORT:
        case MD_SMTP_DS_FLAGS:
            control |= FC_SMTP_INFO_ROUTING;
            break;

        case MD_SEND_BAD_TO:
        case MD_SEND_NDR_TO:
            control |= FC_SMTP_INFO_SEND_TO_ADMIN;
            break;

        case MD_SMARTHOST_TYPE:
        case MD_SMARTHOST_NAME:
            control |= FC_SMTP_INFO_SMART_HOST;
            control |= FC_SMTP_INFO_DOMAIN_ROUTING;
            break;

        case MD_NAME_RESOLUTION_TYPE:
        case MD_BATCH_MSG_LIMIT:
        case MD_SMTP_IP_RELAY_ADDRESSES:
        case MD_SMTP_DISABLE_RELAY:
        case MD_SMTP_MAIL_NO_HELO:
        case MD_SMTP_HELO_NODOMAIN:
        case MD_SMTP_DISABLE_PICKUP_DOT_STUFF:
        case MD_SMTP_EVENTLOG_LEVEL:
            control |= FC_SMTP_INFO_COMMON_PARAMS;
            break;

        case MD_DEFAULT_DOMAIN_VALUE:
            control |= FC_SMTP_INFO_DEFAULT_DOMAIN;
            control |= FC_SMTP_INFO_DOMAIN_ROUTING;
            break;

        case MD_FQDN_VALUE:
            control |= FC_SMTP_INFO_FQDN;
            control |= FC_SMTP_INFO_DOMAIN_ROUTING;
            break;

        case MD_BAD_MAIL_DIR:
            control |= FC_SMTP_INFO_BAD_MAIL_DIR;
            break;

        case MD_DO_MASQUERADE:
        case MD_MASQUERADE_NAME:
            control |= FC_SMTP_INFO_MASQUERADE;
            break;

        case MD_REMOTE_SMTP_PORT:
            control |= FC_SMTP_INFO_REMOTE_PORT;
            break;

        case MD_LOCAL_DOMAINS:
            control |= FC_SMTP_INFO_LOCAL_DOMAINS;
            break;

        case MD_DOMAIN_ROUTING:
            control |= FC_SMTP_INFO_DOMAIN_ROUTING;
            break;

        case MD_POSTMASTER_EMAIL:
        case MD_POSTMASTER_NAME:
            control |= FC_SMTP_INFO_ADMIN_EMAIL_NAME;
            break;

        case MD_SMTP_SSL_REQUIRE_TRUSTED_CA:
        case MD_SMTP_SSL_CERT_HOSTNAME_VALIDATION:
        case MD_SSL_ACCESS_PERM:
            control |= FC_SMTP_INFO_SSL_PERM;
            break;

        case MD_SASL_LOGON_DOMAIN:
            control |= FC_SMTP_INFO_SASL_LOGON_DOMAIN;
            break;

        case MD_MAX_OUT_CONN_PER_DOMAIN:
            control |= FC_SMTP_INFO_MAX_OUT_CONN_PER_DOMAIN;
            break;

        case MD_INBOUND_COMMAND_SUPPORT_OPTIONS:
        case MD_OUTBOUND_COMMAND_SUPPORT_OPTIONS:
        case MD_ADD_NOHEADERS :
            control |= FC_SMTP_INFO_INBOUND_SUPPORT_OPTIONS;
            break;

        case MD_SERVER_BINDINGS:
            GetServerBindings();
            break;

        case MD_IP_SEC:
            control |= FC_SMTP_INFO_DOMAIN_ROUTING;
            ReadIpSecList();
            break;

        case MD_SMTP_RELAY_FOR_AUTH_USERS:
            control |= FC_SMTP_INFO_DOMAIN_ROUTING;
            control |= FC_SMTP_INFO_COMMON_PARAMS;
            break;

        case MD_DOMAIN_VALIDATION_FLAGS:
            control |= FC_SMTP_INFO_COMMON_PARAMS;
            break;

        case MD_ROUTE_ACTION:
        case MD_ROUTE_ACTION_TYPE:
        case MD_ROUTE_USER_NAME:
        case MD_ROUTE_PASSWORD:
        case MD_ROUTE_AUTHTARGET:
        case MD_SMTP_CSIDE_ETRN_DELAY:
        case MD_SMTP_CSIDE_ETRN_DOMAIN:
        case MD_SMTP_AUTHORIZED_TURN_LIST:
            control |= FC_SMTP_INFO_DOMAIN_ROUTING;
            break;

        case MD_SSL_CERT_HASH:
        case MD_SSL_CERT_CONTAINER:
        case MD_SSL_CERT_PROVIDER:
        case MD_SSL_CERT_OPEN_FLAGS:
        case MD_SSL_CERT_STORE_NAME:
        case MD_SSL_CTL_IDENTIFIER:
        case MD_SSL_CTL_CONTAINER:
        case MD_SSL_CTL_PROVIDER:
        case MD_SSL_CTL_PROVIDER_TYPE:
        case MD_SSL_CTL_OPEN_FLAGS:
        case MD_SSL_CTL_STORE_NAME:
            fSslModified = TRUE;
            break;

        default:
            break;
        }
    }

    //We need to react to domains being deleted
    //      9/29/98 - MikeSwa
    if (MD_CHANGE_TYPE_DELETE_OBJECT == pco->dwMDChangeType) {
        control |= FC_SMTP_INFO_DOMAIN_ROUTING;
    }

    //
    // If anything related to SSL has changed, call the function used to flush
    // the SSL/Schannel credential cache and reset the server certificate
    //
    if ( fSslModified && g_pSslKeysNotify ) {
        (g_pSslKeysNotify) ( SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED, this );

        ResetSSLInfo(this);
    }

    MdState = QueryServerState( );

    if ( (MdState == MD_SERVER_STATE_STOPPING) || (MdState == MD_SERVER_STATE_STOPPED)) {
        goto Done;
    }

    if ( control != 0 ) {
        if (!ReadRegParams(control, FALSE)) {
            err = GetLastError();
            DBGPRINTF((
                      DBG_CONTEXT,
                      "SMTP_SERVER_INSTANCE::MDChangeNotify() cannot read config, error %lx\n",
                      err
                      ));

        }
    }

    // Handle deleting domains
    if (control & FC_SMTP_INFO_DOMAIN_ROUTING)
    {
        // We are deleting objects
        if (pco->dwMDChangeType == MD_CHANGE_TYPE_DELETE_OBJECT) {
            if (!RemoveRegParams(NULL)) {
            err = GetLastError();
            DBGPRINTF((
              DBG_CONTEXT,
              "SMTP_SERVER_INSTANCE::MDChangeNotify() cannot remove config, error %lx\n",
              err
              ));
            }
        }
    }

Done:
    m_pChangeObject = NULL;
    UnlockThis();
    TraceFunctLeaveEx((LPARAM)this);
}


IIS_SSL_INFO*
SMTP_SERVER_INSTANCE::QueryAndReferenceSSLInfoObj( VOID )
/*++

   Description

       Returns SSL info for this instance; calls Reference() before returning
       We actually call GetCertificate( ) here, so the name is really incorrect,
       but changing it will involve asking IIS to change IISTYPES to add the
       new method as a vitual function.

   Arguments:

       None

   Returns:

       Ptr to SSL info object on success, NULL if failure

--*/
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::QueryAndReferenceSSLInfoObj");
    IIS_SSL_INFO *pPtr = NULL;

    LockThisForRead();

    //
    // If it's null, we may have to create it - unlock, lock for write and make sure it's
    // still NULL before creating it
    //
    if ( !m_pSSLInfo ) {
        UnlockThis();

        LockThisForWrite();

        //
        // Still null, so create it now
        //
        if ( !m_pSSLInfo ) {
            m_pSSLInfo = new IIS_SSL_INFO( (LPTSTR) QueryMDPath(),
                                           (IMDCOM *) g_pInetSvc->QueryMDObject() );

            if ( m_pSSLInfo == NULL ) {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                UnlockThis();
                return NULL;
            }

            //
            // Acquire an internal reference
            //
            m_pSSLInfo->Reference();

            //
            // Register for changes
            //
            IIS_SERVER_CERT *pCert = m_pSSLInfo->GetCertificate();
            if ( pCert ) {
                // Do logging if we fail to get the certificate
                LogCertStatus();
            }

            //NIMISHK**** Do I need CTL - maybe I can get rid of this call
            IIS_CTL *pCTL = m_pSSLInfo->GetCTL();
            if ( pCTL ) {
                //Do logging if we fail to get the CTL
                LogCTLStatus();
            }

            if ( g_pCAPIStoreChangeNotifier ) {
                if ( pCert && pCert->IsValid() ) {
                    if (!g_pCAPIStoreChangeNotifier->RegisterStoreForChange( pCert->QueryStoreName(),
                                                                             pCert->QueryStoreHandle(),
                                                                             ResetSSLInfo,
                                                                             (PVOID) this ) ) {
                        DebugTrace((LPARAM)this,
                                   "Failed to register for change event on store %s",
                                   pCert->QueryStoreName());
                    }
                }

                if ( pCTL && pCTL->IsValid() ) {
                    if (!g_pCAPIStoreChangeNotifier->RegisterStoreForChange( pCTL->QueryStoreName(),
                                                                             pCTL->QueryOriginalStore(),
                                                                             ResetSSLInfo,
                                                                             (PVOID) this ) ) {
                        DebugTrace((LPARAM)this,
                                   "Failed to register for change event on store %s",
                                   pCTL->QueryStoreName());
                    }
                }

                if ( ( pCert && pCert->IsValid()) ||
                     ( pCTL && pCTL->IsValid() ) ) {
                    HCERTSTORE hRootStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                                           0,
                                                           NULL,
                                                           CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                                           "ROOT" );

                    if ( hRootStore ) {
                        //
                        // Watch for changes to the ROOT store
                        //
                        if ( !g_pCAPIStoreChangeNotifier->RegisterStoreForChange( "ROOT",
                                                                                  hRootStore,
                                                                                  ResetSSLInfo,
                                                                                  (PVOID) this ) ) {
                            DebugTrace((LPARAM)this,
                                       "Failed to register for change event on root store");
                        }

                        CertCloseStore( hRootStore,
                                        0 );
                    } else {
                        DebugTrace((LPARAM)this,
                                   "Failed to open ROOT store, error 0x%d",
                                   GetLastError());

                    }
                } // if ( pCert || pCTL )

            } // if (g_pCAPIStoreChangeNotifier)

        } // if ( !m_pSSLInfo )

    } //if ( !m_pSSLInfo )

//
// At this point, m_pSSLInfo should not be NULL anymore, so add the external reference
//
    m_pSSLInfo->Reference();

    pPtr = m_pSSLInfo;

    UnlockThis();

    TraceFunctLeaveEx((LPARAM)this);

    return pPtr;
}

VOID SMTP_SERVER_INSTANCE::ResetSSLInfo( LPVOID pvParam )
/*++
    Description:

        Wrapper function for function to call to notify of SSL changes

    Arguments:

        pvParam - pointer to instance for which SSL keys have changed

    Returns:

        Nothing

--*/
{
    TraceFunctEnterEx((LPARAM)NULL, "SMTP_SERVER_INSTANCE::ResetSSLInfo");
    //
    // Call function to flush credential cache etc
    //
    if ( g_pSslKeysNotify ) {
        g_pSslKeysNotify( SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED,
                          pvParam );
    }

    SMTP_SERVER_INSTANCE *pInst = (SMTP_SERVER_INSTANCE *) pvParam;

    pInst->LockThisForRead();

    if ( pInst->m_pSSLInfo ) {
        pInst->UnlockThis();

        pInst->LockThisForWrite();

        if ( pInst->m_pSSLInfo ) {
            //
            // Stop watching for change notifications
            //
            IIS_SERVER_CERT *pCert = pInst->m_pSSLInfo->QueryCertificate();
            IIS_CTL *pCTL = pInst->m_pSSLInfo->QueryCTL();

            if ( g_pCAPIStoreChangeNotifier ) {
                //
                // Stop watching the store the cert came out of
                //
                if ( pCert && pCert->IsValid() ) {
                    g_pCAPIStoreChangeNotifier->UnregisterStore( pCert->QueryStoreName(),
                                                                 ResetSSLInfo,
                                                                 (PVOID) pvParam );
                }

                //
                // Stop watching the store the CTL came out of
                //
                if ( pCTL && pCTL->IsValid() ) {
                    g_pCAPIStoreChangeNotifier->UnregisterStore( pCTL->QueryStoreName(),
                                                                 ResetSSLInfo,
                                                                 (PVOID) pvParam );
                }

                //
                // Stop watching the ROOT store
                //
                g_pCAPIStoreChangeNotifier->UnregisterStore( "ROOT",
                                                             ResetSSLInfo,
                                                             (PVOID) pvParam );
            }

            //
            // Release internal reference
            //
            IIS_SSL_INFO::Release( pInst->m_pSSLInfo );

            //
            // Next call to QueryAndReferenceSSLObj() will create it again
            //
            pInst->m_pSSLInfo = NULL;
        }
    }

    pInst->UnlockThis();
    TraceFunctLeaveEx((LPARAM)NULL);
}

VOID SMTP_SERVER_INSTANCE::LogCertStatus()
/*++
    Description:

       Writes system log event about status of server certificate if the cert is in some
       way not quite kosher eg expired, revoked, not signature-valid

    Arguments:

       None

    Returns:

       Nothing
--*/
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::LogCertStatus");

    _ASSERT( m_pSSLInfo );

    DWORD dwCertValidity = 0;

    //
    // If we didn't construct the cert fully, log an error
    //
    if ( !m_pSSLInfo->QueryCertificate()->IsValid() ) {
        CONST CHAR *apszMsgs[2];
        CHAR achInstance[20];
        CHAR achErrorNumber[20];
        wsprintf( achInstance,
                  "%lu",
                  QueryInstanceId() );
        wsprintf( achErrorNumber,
                  "0x%x",
                  GetLastError() );

        apszMsgs[0] = achInstance;
        apszMsgs[1] = achErrorNumber;

        DWORD dwStatus = m_pSSLInfo->QueryCertificate()->Status();
        DWORD dwStringID = 0;

        DebugTrace((LPARAM)this,
                   "Couldn't retrieve server cert; status : %d",
                   dwStatus);

        switch ( dwStatus ) {
        case CERT_ERR_MB:
            dwStringID = SSL_MSG_CERT_MB_ERROR;
            break;

        case CERT_ERR_CAPI:
            dwStringID = SSL_MSG_CERT_CAPI_ERROR;
            break;

        case CERT_ERR_CERT_NOT_FOUND:
            dwStringID = SSL_MSG_CERT_NOT_FOUND;
            break;

        default:
            dwStringID = SSL_MSG_CERT_INTERNAL_ERROR;
            break;
        }

        SmtpLogEvent(dwStringID,
                     2,
                     apszMsgs,
                     0 );

        TraceFunctLeaveEx((LPARAM)this);
        return;
    }


    //
    // If cert is invalid in some other way , write the appropriate log message
    //
    if ( m_pSSLInfo->QueryCertValidity( &dwCertValidity ) ) {
        const CHAR *apszMsgs[1];
        CHAR achInstance[20];
        wsprintfA( achInstance,
                   "%lu",
                   QueryInstanceId() );
        apszMsgs[0] = achInstance;
        DWORD dwMsgID = 0;

        if ( ( dwCertValidity & CERT_TRUST_IS_NOT_TIME_VALID ) ||
             ( dwCertValidity & CERT_TRUST_IS_NOT_TIME_NESTED ) ||
             ( dwCertValidity & CERT_TRUST_CTL_IS_NOT_TIME_VALID ) ) {
            DebugTrace((LPARAM)this,
                       "Server cert/CTL is not time-valid or time-nested");

            dwMsgID = SSL_MSG_TIME_INVALID_SERVER_CERT;
        }


        if ( dwCertValidity & CERT_TRUST_IS_REVOKED ) {
            DebugTrace((LPARAM)this,
                       "Server Cert is revoked");

            dwMsgID = SSL_MSG_REVOKED_SERVER_CERT;
        }

        if ( ( dwCertValidity & CERT_TRUST_IS_UNTRUSTED_ROOT ) ||
             ( dwCertValidity & CERT_TRUST_IS_PARTIAL_CHAIN ) ) {
            DebugTrace((LPARAM)this,
                       "Server Cert doesn't chain up to a trusted root");

            dwMsgID = SSL_MSG_UNTRUSTED_SERVER_CERT;
        }

        if ( ( dwCertValidity & CERT_TRUST_IS_NOT_SIGNATURE_VALID ) ||
             ( dwCertValidity & CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID ) ) {
            DebugTrace((LPARAM)this,
                       "Server Cert/CTL is not signature valid");

            dwMsgID = SSL_MSG_SIGNATURE_INVALID_SERVER_CERT;
        }

        if ( dwMsgID ) {
            SmtpLogEvent( dwMsgID,
                          1,
                          apszMsgs,
                          0 );
        }
    }

    TraceFunctLeaveEx((LPARAM)this);

}


VOID SMTP_SERVER_INSTANCE::LogCTLStatus()
/*++
    Description:

       Writes system log event about status of server CTL if CTL isn't valid

    Arguments:

      None

    Returns:

       Nothing
--*/
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::LogCTLStatus");

    _ASSERT( m_pSSLInfo );

    //
    // If we didn't construct the CTL fully, log an error
    //
    if ( !m_pSSLInfo->QueryCTL()->IsValid() ) {
        CONST CHAR *apszMsgs[2];
        CHAR achInstance[20];
        CHAR achErrorNumber[20];
        wsprintf( achInstance,
                  "%lu",
                  QueryInstanceId() );
        wsprintf( achErrorNumber,
                  "0x%x",
                  GetLastError() );

        apszMsgs[0] = achInstance;
        apszMsgs[1] = achErrorNumber;

        DWORD dwStatus = m_pSSLInfo->QueryCTL()->QueryStatus();
        DWORD dwStringID = 0;

        DebugTrace((LPARAM)this,
                   "Couldn't retrieve server CTL; status : %d\n",
                   dwStatus);

        switch ( dwStatus ) {
        case CERT_ERR_MB:
            dwStringID = SSL_MSG_CTL_MB_ERROR;
            break;

        case CERT_ERR_CAPI:
            dwStringID = SSL_MSG_CTL_CAPI_ERROR;
            break;

        case CERT_ERR_CERT_NOT_FOUND:
            dwStringID = SSL_MSG_CTL_NOT_FOUND;
            break;

        default:
            dwStringID = SSL_MSG_CTL_INTERNAL_ERROR;
            break;
        }

        SmtpLogEvent( dwStringID,
                      2,
                      apszMsgs,
                      0 );
        TraceFunctLeaveEx((LPARAM)this);
        return;
    }
    TraceFunctLeaveEx((LPARAM)this);
}


BOOL
SmtpMappingSupportFunction(
                          PVOID pvInstance,
                          PVOID pData,
                          DWORD dwPropId)
{
    if (dwPropId == SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED) {
        return (SetSslKeysNotify( (PFN_SF_NOTIFY) pData));
    } else if (dwPropId == SIMSSL_NOTIFY_MAPPER_CERT11_CHANGED ||
               dwPropId == SIMSSL_NOTIFY_MAPPER_CERTW_CHANGED) {
        return ( TRUE );
    } else {
        return ( FALSE );
    }
}

BOOL
SetSslKeysNotify(
                PFN_SF_NOTIFY pFn
                )
/*++

   Description

       Set the function called to notify SSL keys have changed
       Can be called only once

   Arguments:

       pFn - function to call to notify SSL keys change

   Returns:

       TRUE if function reference stored, FALSE otherwise

--*/
{
    if ( g_pSslKeysNotify == NULL || pFn == NULL ) {
        g_pSslKeysNotify = pFn;
        return TRUE;
    }

    return FALSE;
}


CAddr * SMTP_SERVER_INSTANCE::AppendLocalDomain (CAddr * OldAddress)
{
    char ReWriteAddr [MAX_INTERNET_NAME + 1];
    CAddr * NewAddress = NULL;
    DWORD TotalSize  = 0;

    //If there is no domain on this address,
    //then append the current domain to this
    //address

    m_GenLock.ShareLock();

    TotalSize = lstrlen(OldAddress->GetAddress()) + lstrlen(GetDefaultDomain()) + 1; //+1 for the @
    if ( TotalSize  >= MAX_INTERNET_NAME) {
        m_GenLock.ShareUnlock();
        SetLastError(ERROR_INVALID_DATA);
        return NULL;
    }

    lstrcpy(ReWriteAddr, OldAddress->GetAddress());
    lstrcat(ReWriteAddr, "@");

    lstrcat(ReWriteAddr, GetDefaultDomain());
    m_GenLock.ShareUnlock();

    //create a new CAddr
    NewAddress = CAddr::CreateKnownAddress (ReWriteAddr);

    return NewAddress;
}

BOOL SMTP_SERVER_INSTANCE::AppendLocalDomain(char * Address)
{

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::AppendLocalDomain");

    m_GenLock.ShareLock();

    if ((lstrlen(Address) + lstrlen(GetDefaultDomain()) + 1) > MAX_INTERNET_NAME) {
        //Our concatanated name will be larger than allowed name
        ErrorTrace((LPARAM)this, "Generated address longer than allowed max");
        m_GenLock.ShareUnlock();
        return FALSE;
    }
    lstrcat(Address, "@");
    lstrcat(Address, GetDefaultDomain());

    m_GenLock.ShareUnlock();

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

CAddr * SMTP_SERVER_INSTANCE::MasqueradeDomain (CAddr * OldAddress)
{
    char ReWriteAddr [MAX_INTERNET_NAME + 1];
    CAddr * NewAddress = NULL;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::MasqueradeDomain");

    m_GenLock.ShareLock();

    if (m_fMasquerade) {
        //if there is a domain in the name, get rid of it
        //we are going to replace it with the masquerade
        if (OldAddress->GetDomainOffset()) {
            *(OldAddress->GetDomainOffset()) = '\0';
        }

        lstrcpy(ReWriteAddr, OldAddress->GetAddress());
        lstrcat(ReWriteAddr, "@");

        lstrcat(ReWriteAddr, m_szMasqueradeName);

        //create a new CAddr
        NewAddress = CAddr::CreateKnownAddress (ReWriteAddr);
    }

    m_GenLock.ShareUnlock();
    TraceFunctLeaveEx((LPARAM)this);
    return NewAddress;
}

BOOL SMTP_SERVER_INSTANCE::MasqueradeDomain(char * Address, char * DomainPtr)
{

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::MasqueradeDomain");

    m_GenLock.ShareLock();

    if (m_fMasquerade) {
        //if there is a domain in the name, get rid of it
        //we are going to replace it with the masquerade
        if (DomainPtr) {

            if ((DomainPtr - Address + lstrlen(m_szMasqueradeName)) > MAX_INTERNET_NAME) {
                //Our concatanated name will be larger than allowed name
                ErrorTrace((LPARAM)this, "Generated address longer than allowed max");
                m_GenLock.ShareUnlock();
                return FALSE;
            }
            lstrcpy(DomainPtr, m_szMasqueradeName);
        } else {
            if ((lstrlen(Address) + lstrlen(m_szMasqueradeName) + 1) > MAX_INTERNET_NAME) {
                //Our concatanated name will be larger than allowed name
                ErrorTrace((LPARAM)this, "Generated address longer than allowed max");
                m_GenLock.ShareUnlock();
                return FALSE;
            }
            lstrcat(Address, "@");
            lstrcat(Address, m_szMasqueradeName);
        }

    }

    m_GenLock.ShareUnlock();
    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

extern BOOL IsIpInGlobalList(DWORD IpAddress);

BOOL SMTP_SERVER_INSTANCE::CompareIpAddress(DWORD IpAddress)
{
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::CompareIpAddress");

    if (IpAddress != g_LoopBackAddr) {
        fRet = IsIpInGlobalList(IpAddress);
    } else {
        FatalTrace((LPARAM) this, "IpAddress %d is loopback - Failing connection", IpAddress);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

//Note : When connected port is passed in 0, it only does IP address comparison
//
BOOL SMTP_SERVER_INSTANCE::IsAddressMine(DWORD IpAddress, DWORD ConnectedPort)
{
    char * Ptr = NULL;
    const char *  StartPtr = NULL;
    const CHAR * ipAddressString = NULL;
    const CHAR * ipPortString = NULL;
    const CHAR * hostNameString = NULL;
    const CHAR * end = NULL;
    DWORD InetAddr = 0;
    DWORD CharIpSize = 0;
    CHAR temp[sizeof("123.123.123.123")];
    INT length;
    LONG tempPort;
    BOOL BindingMatchFound = FALSE;
    BOOL IpSame = FALSE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::IsAddressMine");

    //grab the sharing lock

    m_GenLock.ShareLock();

    if (m_ServerBindings.IsEmpty()) {
        DebugTrace((LPARAM) this, "Server bindings is emtpy - checking all addresses");

        m_GenLock.ShareUnlock();

        IpSame = CompareIpAddress(IpAddress);
        TraceFunctLeaveEx((LPARAM)this);
        return IpSame;
    } else {
        for (StartPtr = m_ServerBindings.First(); StartPtr != NULL; StartPtr = m_ServerBindings.Next( StartPtr )) {
            ipAddressString = StartPtr;

            ipPortString = strchr(StartPtr, ':');

            if (ipPortString == NULL) {
                goto out;
            }

            ipPortString++;

            hostNameString = strchr( ipPortString, ':' );

            if ( hostNameString == NULL ) {
                goto out;
            }

            hostNameString++;

            //
            // Validate and parse the IP address portion.
            //

            if ( *ipAddressString == ':' ) {
                InetAddr = INADDR_ANY;

            } else {
                length = DIFF(ipPortString - ipAddressString) - 1;

                if ( length > sizeof(temp) ) {
                    goto out;
                }

                CopyMemory( temp, ipAddressString, length);

                temp[length] = '\0';

                InetAddr = (DWORD)inet_addr( temp );

                if ( InetAddr == INADDR_NONE ) {
                    goto out;
                }

            }//end else of if( *ipAddressString == ':' )

            //
            // Validate and parse the port.
            //

            if ( *ipPortString == ':' ) {
                goto out;
            }

            length = (INT)(hostNameString - ipPortString);

            if ( length > sizeof(temp) ) {
                goto out;
            }

            CopyMemory(temp,ipPortString, length);

            temp[length] = '\0';

            tempPort = strtol( temp, (CHAR **)&end, 0 );

            if ( tempPort <= 0 || tempPort > 0xFFFF ) {
                goto out;
            }

            if ( *end != ':' ) {
                goto out;
            }

            if (InetAddr == INADDR_ANY) {
                IpSame = CompareIpAddress(IpAddress);

                if (IpSame && ((DWORD) tempPort == ConnectedPort) && (ConnectedPort > 0)) {
                    BindingMatchFound = TRUE;
                    goto out;
                } else if (IpSame && (ConnectedPort == 0)) {
                    BindingMatchFound = TRUE;
                    goto out;
                }
            } else if ( (IpAddress == InetAddr) && ((DWORD) tempPort == ConnectedPort) && (ConnectedPort > 0)) {
                FatalTrace((LPARAM) this, "IpAddress %d is one of mine - Failing connection", IpAddress);
                BindingMatchFound = TRUE;
                goto out;
            } else if ( (IpAddress == InetAddr) && (ConnectedPort == 0)) {
                BindingMatchFound = TRUE;
                goto out;
            }

        }//end for
    }//end else

    out:

    m_GenLock.ShareUnlock();

    if (!BindingMatchFound)
        DebugTrace((LPARAM) this, "IpAddress %d is not one of mine", IpAddress);

    TraceFunctLeaveEx((LPARAM)this);
    return BindingMatchFound;
}

BOOL SMTP_SERVER_INSTANCE::MoveToBadMail ( IMailMsgProperties *pIMsg, BOOL fUseIMsg, char * MailFile, char * FilePath)
{
    TCHAR BadMailDir[MAX_PATH + 1];
    TCHAR MailPath [MAX_PATH + 1];
    TCHAR StreamPath[MAX_PATH + 1];
    char * pszSearch = NULL;
    BOOL  f = TRUE;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::MoveToBadMail");

    //concatenate the name of the stream to the file
    lstrcpy(MailPath, FilePath);
    lstrcat(MailPath, MailFile);

    m_GenLock.ShareLock();
    f = SUCCEEDED(m_IAQ->HandleFailedMessage(pIMsg, fUseIMsg, MailPath, MESSAGE_FAILURE_BAD_PICKUP_DIR_FILE, E_FAIL));
    m_GenLock.ShareUnlock();

    TraceFunctLeaveEx((LPARAM)this);
    return f;
}

#define NTFS_STORE_DIRECTORY_REG_PATH   _T("Software\\Microsoft\\Exchange\\StoreDriver\\Ntfs\\%u")
#define NTFS_STORE_DIRECTORY_REG_NAME   _T("StoreDir")
#define NTFS_STORE_BACKSLASH            _T("\\")
#define NTFS_QUEUE_DIRECTORY_SUFFIX     _T("\\Queue")
#define NTFS_DROP_DIRECTORY_SUFFIX      _T("\\Drop")

/*++
    Description:
      Initializes server configuration data from registry for SMTP Service.
      Some values are also initialized with constants.
      If invalid registry key or load data from registry fails,
        then use default values.

    Arguments:  None

    Returns:

       TRUE  if there are no errors.

    Limitations:

        No validity check is performed on the data present in registry.
--*/
BOOL SMTP_SERVER_INSTANCE::InitFromRegistry(void)
{
    LONG    err = 0;
    DWORD   dwErr = 0;
    DWORD   SizeOfBuffer = 0;
    HKEY    hkeyTcpipParam = NULL;
    BOOL    fRet = FALSE;

    //char    szHostName[MAX_PATH + 1];
    // const   CHAR * apszSubStrings[2];

    CHAR pchAddr1[32] = "";

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::InitFromRegistry");

    _itoa(QueryInstanceId(), pchAddr1, 10);

    //
    // This is added by KeithLau on 7/15/96
    // This method loads the registry values that cannot be accessed
    // through the RPC's
    //
    if (!ReadStartupRegParams()) {
        ErrorTrace((LPARAM) this, "Read startup params failed.");
        goto Exit;
    }

    if (!StartAdvancedQueueing()) {
        DebugTrace((LPARAM)this, "Unable to load Advanced Queueing module\n");
        goto Exit;
    }

    fInitializedAQ = TRUE;

    //
    // Metabase Structures... can change at runtime
    // Turn off FC_SMTP_INFO_DEFAULT_DROP_DIR since
    // we already read it in ReadStartupRegParams()

    if (!ReadRegParams(FC_SMTP_INFO_ALL & ~FC_SMTP_INFO_DEFAULT_DROP_DIR, TRUE, FALSE))
    {
        ErrorTrace((LPARAM) this, "Read params failed.");
        goto Exit;
    }

    if (!InitQueues()) {
        err= GetLastError();
        ErrorTrace((LPARAM) this, "can't init queue err  = %d", err);
        if (err == NO_ERROR)
            err = ERROR_INVALID_PARAMETER;

        SetLastError(err);

        goto Exit;
    }

    fRet = TRUE;

    Exit:

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

/*++

     Adds the new client connection to the list
      of client connections and increments the count of
      clients currently connected to server.
     If the count of max connections is exceeded, then the
      new connection is rejected.

    Arguments:

       pcc       pointer to client connection to be added

    Returns:
      TRUE on success and
      FALSE if there is max Connections exceeded.
--*/
CLIENT_CONNECTION * SMTP_SERVER_INSTANCE::CreateNewConnection( IN OUT PCLIENT_CONN_PARAMS  ClientParam)
{

    SMTP_CONNECTION * NewConnection = NULL;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::InsertNewConnection");

    // We will not accept new connections until the intial queue is built
    if (!m_fShouldStartAcceptingConnections || IsShuttingDown()) {
        return (NULL);
    }

    NewConnection = SMTP_CONNECTION::CreateSmtpConnection (ClientParam, this);
    if (NewConnection != NULL) {

        BUMP_COUNTER(this, NumConnInOpen);

        LockConfig();

        //  Increment the count of connected users
        m_cCurrentConnections++;

        // Update the current maximum connections
        if ( m_cCurrentConnections > m_cMaxCurrentConnections) {
            m_cMaxCurrentConnections = m_cCurrentConnections;
        }

        //set the client unique ID
        NewConnection->SetClientId(m_dwNextInboundClientId);

        m_dwNextInboundClientId++;

        //
        // Insert into the list of connected users.
        //
        InsertTailList( &m_ConnectionsList, &NewConnection->QueryListEntry());

        DebugTrace((LPARAM) this, "SMTP_SERVER_INSTANCE:InsertNewConnection succeeded");

        UnLockConfig();
    }


    TraceFunctLeaveEx((LPARAM)this);
    return ( NewConnection);

}


void SMTP_SERVER_INSTANCE::StopHint()
{
    if ( g_pInetSvc && g_pInetSvc->QueryCurrentServiceState() ==  SERVICE_STOP_PENDING) {

        //      10/28/98 - MikeSwa
        //Use stop hint 30 seconds to avoid problems with commiting many
        //messages on shutdown. (the previous limit of 10 seconds seemed
        //to cause problems with the service control manager).
        g_pInetSvc->UpdateServiceStatus(SERVICE_STOP_PENDING, NO_ERROR, m_dwStopHint,
                                         30000 ) ;

        m_dwStopHint++ ;
    }
}

/*++

   Disconnects all user connections.

--*/
VOID SMTP_SERVER_INSTANCE::DisconnectAllConnections( VOID)
{
    int iteration = 0;
    int i = 0;
    int Count = 0;
    LONG    cLastThreadCount = 0;
    DWORD   dwLastAllocCount = 0;
    DWORD   dwAllocCount;
    int AfterSleepCount = 0;
    DWORD   dwStopHint = 2;
    DWORD   dwTickCount;
    DWORD   dwError = 0;
    PLIST_ENTRY  pEntry = NULL;
    SMTP_CONNECTION  * pConn = NULL;

    TraceFunctEnter("SMTP_SERVER_INSTANCE::DisconnectAllConnections( VOID)");

    if (m_fShutdownCalled) {
        DebugTrace((LPARAM)this, "m_fShutdownCalled already -- leaving");
        TraceFunctLeaveEx((LPARAM) this);
    }

    //set the global termination flag
    m_IsShuttingDown = TRUE;

    LockConfig();

    TriggerStoreServerEvent(SMTP_STOREDRV_PREPSHUTDOWN_EVENT);
    m_fStoreDrvPrepShutDownEventCalled = TRUE;

    //close down all the active sockets.
    for ( pEntry = m_ConnectionsList.Flink; pEntry != &m_ConnectionsList; pEntry = pEntry->Flink) {

        //get the next connection object
        pConn = (SMTP_CONNECTION *) CONTAINING_RECORD( pEntry, CLIENT_CONNECTION, m_listEntry);
        _ASSERT( pConn != NULL);

        //call the disconnect routine. DisconnectClient() just closes the socket.
        //This will cause all pending I/Os to fail, and have the connections
        //bubble up to the completion routine where they will be removed from
        //the connection list and then distroyed
        pConn->DisconnectClient( ERROR_SERVER_DISABLED);
    }

    UnLockConfig();

    DebugTrace((LPARAM)this, "Cancelling all outstanding SQL queries");


    //
    //  Wait for the users to die.
    //  The connection objects should be automatically freed because the
    //   socket has been closed. Subsequent requests will fail
    //   and cause a blowaway of the connection objects.
    // looping is used to get out as early as possible when m_cCurrentConn == 0
    //

    //
    // need to check Pool.GetAllocCount instead of InUseList.Empty
    // because alloc goes to zero during the delete operator
    // instead of during the destructor
    //
    //  We sleep at most 120 seconds for a fixed user count.
    //

    dwTickCount = GetTickCount();
    cLastThreadCount = GetProcessClientThreads();
    for (i = 0; i < 180; i++) {
        DebugTrace((LPARAM)this, "Waiting for connections to die, i = %u", i);
        //  dwAllocCount = SMTP_CONNECTION::Pool.GetAllocCount();
        dwAllocCount = (DWORD) GetConnInAllocCount();
        if (dwAllocCount == 0 && GetProcessClientThreads() == 0) {
            DebugTrace((LPARAM)this, "All SMTP_CONNECTIONs connections are gone!");
            break;
        }

        Sleep(1000);

        // Update the stop hint checkpoint when we get within 1 second (1000 ms), of the timeout...
        if ((SERVICE_STOP_WAIT_HINT - 1000) < (GetTickCount() - dwTickCount) && g_pInetSvc &&
            g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) {
            DebugTrace((LPARAM)this, "Updating stop hint, checkpoint = %u", dwStopHint);

            g_pInetSvc->UpdateServiceStatus(SERVICE_STOP_PENDING, NO_ERROR, dwStopHint,
                                            SERVICE_STOP_WAIT_HINT ) ;

            dwStopHint++ ;
            dwTickCount = GetTickCount();
        }

        DebugTrace((LPARAM)this, "Alloc counts: current = %u, last = %u; Thread counts: current = %d, last = %d",
                   dwAllocCount, dwLastAllocCount, GetProcessClientThreads(), cLastThreadCount);
        if (dwAllocCount < dwLastAllocCount || GetProcessClientThreads() < cLastThreadCount) {
            DebugTrace((LPARAM)this, "SMTP_CONNECTION Connections are going away, reseting i");
            i = 0;
        }

        dwLastAllocCount = dwAllocCount;
        cLastThreadCount = GetProcessClientThreads();
    }

    if (i == 180) {
        ErrorTrace((LPARAM) this, "%d users won't die", m_cCurrentConnections);
        //
        // once we're thru do it again to find any stray clients
        //
        LockConfig();

        for (pEntry = m_ConnectionsList.Flink;
            pEntry != &m_ConnectionsList;
            pEntry = pEntry->Flink ) {
            //
            // get the next connection object
            //
            pConn = (SMTP_CONNECTION *)CONTAINING_RECORD(pEntry, CLIENT_CONNECTION, m_listEntry);
            _ASSERT(pConn != NULL);

            ErrorTrace( (LPARAM)pConn, "Stray client" );
        }
        UnLockConfig();
    }


    DebugTrace( (LPARAM)this, "SMTP_CONNECTION Count at end is: %d", SMTP_CONNECTION::Pool.GetAllocCount() );

    TraceFunctLeaveEx((LPARAM) this);

}


/*++

    Removes the current connection from the list of conenctions
     and decrements count of connected users

    Arguments:

       pcc       pointer to client connection to be removed

--*/
VOID SMTP_SERVER_INSTANCE::RemoveConnection( IN OUT CLIENT_CONNECTION * pConn)
{

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::RemoveConnection");

    _ASSERT( pConn != NULL);

    LockConfig();

    // Remove from list of connections
    RemoveEntryList( &pConn->QueryListEntry());

    // Decrement count of current users
    m_cCurrentConnections--;

    BUMP_COUNTER(this, NumConnInClose);

    UnLockConfig();

    TraceFunctLeaveEx((LPARAM)this);

} // SMTP_SERVER_INSTANCE::RemoveConnection()




/*++

     Adds the new client connection to the list
      of outbound client connections and increments the count of
      outbound clients currently connected to server.

    Arguments:

       pcc       pointer to client connection to be added

    Returns:
      TRUE on success and
      FALSE if there is max Connections exceeded.
--*/
BOOL SMTP_SERVER_INSTANCE::InsertNewOutboundConnection( IN OUT CLIENT_CONNECTION * pcc, BOOL ByPassLimitCheck)
{

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::InsertNewOutboundConnection");

    _ASSERT( pcc != NULL);

    m_OutLock.ExclusiveLock();

    // Increment the count of connected users
    m_cCurrentOutConnections++;

    //set the client unique ID
    pcc->SetClientId(m_dwNextOutboundClientId);

    m_dwNextInboundClientId++;

    // Insert into the list of connected outbound users.
    InsertTailList( &m_OutConnectionsList, &pcc->QueryListEntry());

    m_OutLock.ExclusiveUnlock();

    BUMP_COUNTER(this, NumConnOutOpen);

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

BOOL SMTP_SERVER_INSTANCE::InsertAsyncDnsObject( IN OUT CAsyncSmtpDns *pcc)
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::InsertAsyncDnsObj");

    _ASSERT( pcc != NULL);

    EnterCriticalSection( &m_csAsyncDns ) ;

    IncAsyncDnsObjs();

    BUMP_COUNTER(this, RoutingTableLookups);

    // Insert into the list of connected outbound users.
    InsertTailList( &m_AsyncDnsList, &pcc->QueryListEntry());

    LeaveCriticalSection( &m_csAsyncDns ) ;

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

VOID SMTP_SERVER_INSTANCE::RemoveAsyncDnsObject( IN OUT CAsyncSmtpDns * pConn)
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::RemoveAsyncDnsObject");

    _ASSERT( pConn != NULL);

    EnterCriticalSection( &m_csAsyncDns ) ;

    // Remove from list of connections
    RemoveEntryList( &pConn->QueryListEntry());

    DecAsyncDnsObjs();

    DROP_COUNTER(this, RoutingTableLookups);

    LeaveCriticalSection( &m_csAsyncDns ) ;

    TraceFunctLeaveEx((LPARAM)this);

} // SMTP_SERVER_INSTANCE::RemoveAsyncObject()


VOID SMTP_SERVER_INSTANCE::DisconnectAllAsyncDnsConnections( VOID)
{

    int iteration = 0;
    int i = 0;
    int Count = 0;
    DWORD   dwLastAllocCount = 0;
    DWORD   dwAllocCount;
    int AfterSleepCount = 0;
    DWORD   dwStopHint = 2;
    DWORD   dwTickCount;
    DWORD   dwError = 0;
    PLIST_ENTRY  pEntry = NULL;
    CAsyncSmtpDns  * pConn = NULL;

    TraceFunctEnter("SMTP_SERVER_INSTANCE::DisconnectAllAsyncDnsConnections( VOID)");

    if (m_fShutdownCalled) {
        DebugTrace((LPARAM)this, "m_fShutdownCalled already -- leaving");
        TraceFunctLeaveEx((LPARAM) this);
    }

    EnterCriticalSection( &m_csAsyncDns ) ;

    //close down all the active sockets.
    for ( pEntry = m_AsyncDnsList.Flink; pEntry != &m_AsyncDnsList; pEntry = pEntry->Flink) {

        //get the next connection object
        pConn = (CAsyncSmtpDns *) CONTAINING_RECORD( pEntry, CAsyncSmtpDns, m_ListEntry);
        _ASSERT( pConn != NULL);

        //call the disconnect routine. DisconnectClient() just closes the socket.
        //This will cause all pending I/Os to fail, and have the connections
        //"bubble up to the completion routine where they will be removed from
        //the connection list and then distroyed
        pConn->DisconnectClient();
    }

    LeaveCriticalSection( &m_csAsyncDns ) ;


    //
    //  Wait for the users to die.
    //  The connection objects should be automatically freed because the
    //   socket has been closed. Subsequent requests will fail
    //   and cause a blowaway of the connection objects.
    // looping is used to get out as early as possible when m_cCurrentConn == 0
    //

    //
    // need to check Pool.GetAllocCount instead of InUseList.Empty
    // because alloc goes to zero during the delete operator
    // instead of during the destructor
    //
    //  We sleep at most 120 seconds for a fixed user count.
    //

    dwTickCount = GetTickCount();
    for (i = 0; i < 500; i++) {
        DebugTrace((LPARAM)this, "Waiting for connections to die, i = %u", i);
        dwAllocCount = (DWORD) GetAsyncDnsAllocCount ();
        if (dwAllocCount == 0) {
            DebugTrace((LPARAM)this, "All SMTP DNS connections are gone!");
            break;
        }

        Sleep(1000);

        // Update the stop hint checkpoint when we get within 1 second (1000 ms), of the timeout...
        if ((SERVICE_STOP_WAIT_HINT - 1000) < (GetTickCount() - dwTickCount) && g_pInetSvc &&
            g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) {
            DebugTrace((LPARAM)this, "Updating stop hint, checkpoint = %u", dwStopHint);

            g_pInetSvc->UpdateServiceStatus(SERVICE_STOP_PENDING, NO_ERROR, dwStopHint,
                                            SERVICE_STOP_WAIT_HINT ) ;

            dwStopHint++ ;
            dwTickCount = GetTickCount();
        }

        DebugTrace((LPARAM)this, "Alloc counts: current = %u, last = %u",
                   dwAllocCount, dwLastAllocCount);
        if (dwAllocCount < dwLastAllocCount) {
            DebugTrace((LPARAM)this, "SMTP DNS Connections are going away, reseting i");
            i = 0;
        }

        dwLastAllocCount = dwAllocCount;
    }

    if (i == 500) {
        ErrorTrace((LPARAM) this, "%d users won't die", m_cCurrentConnections);
        //
        // once we're thru do it again to find any stray clients
        //
        EnterCriticalSection( &m_csAsyncDns ) ;

        for (pEntry = m_AsyncDnsList.Flink;
            pEntry != &m_AsyncDnsList;
            pEntry = pEntry->Flink ) {
            //
            // get the next connection object
            //
            pConn = (CAsyncSmtpDns *)CONTAINING_RECORD(pEntry, CAsyncSmtpDns, m_ListEntry);
            _ASSERT(pConn != NULL);

            ErrorTrace( (LPARAM)pConn, "Stray client" );
        }
        LeaveCriticalSection( &m_csAsyncDns ) ;

    }


    DebugTrace( (LPARAM)this, "SMTP DNS Count at end is: %d", CAsyncSmtpDns::Pool.GetAllocCount() );
    TraceFunctLeaveEx((LPARAM) this);
}

BOOL SMTP_SERVER_INSTANCE::InsertAsyncObject( IN OUT CAsyncMx *pcc)
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::InsertNewAsyncConnection");

    _ASSERT( pcc != NULL);

    m_OutLock.ExclusiveLock();

    IncAsyncMxOutObjs();

    // Insert into the list of connected outbound users.
    InsertTailList( &m_AsynConnectList, &pcc->QueryListEntry());

    m_OutLock.ExclusiveUnlock();

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

VOID SMTP_SERVER_INSTANCE::RemoveAsyncObject( IN OUT CAsyncMx * pConn)
{
    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::RemoveAsyncObject");

    _ASSERT( pConn != NULL);

    m_OutLock.ExclusiveLock();

    // Remove from list of connections
    RemoveEntryList( &pConn->QueryListEntry());

    DecAsyncMxOutObjs();

    m_OutLock.ExclusiveUnlock();

    TraceFunctLeaveEx((LPARAM)this);

} // SMTP_SERVER_INSTANCE::RemoveAsyncObject()

VOID SMTP_SERVER_INSTANCE::DisconnectAllAsyncConnections( VOID)
{
    PLIST_ENTRY  pEntry = NULL;
    CAsyncMx  * pConn = NULL;
    int iteration = 0;
    int i = 0;
    int Count = 0;
    LONG    cLastThreadCount = 0;
    DWORD   dwLastAllocCount = 0;
    DWORD   dwAllocCount;
    int AfterSleepCount = 0;
    DWORD   dwStopHint = 2;
    DWORD   dwTickCount;
    DWORD   dwError = 0;

    TraceFunctEnter("SMTP_SERVER_INSTANCE::DisconnectAllAsynConnections( VOID)");

#if 0

    //close down all the active sockets.
    for ( pEntry = m_AsynConnectList.Flink; pEntry != &m_AsynConnectList; pEntry = pEntry->Flink) {
        //get the next connection object
        pConn = (CAsyncMx *) CONTAINING_RECORD( pEntry, CAsyncMx, m_ListEntry);
        _ASSERT( pConn != NULL);

        pConn->SignalObject( );
    }
#endif

    //
    //  Wait for the users to die.
    //  The connection objects should be automatically freed because the
    //   socket has been closed. Subsequent requests will fail
    //   and cause a blowaway of the connection objects.
    // looping is used to get out as early as possible when m_cCurrentConn == 0
    //

    //
    // need to check Pool.GetAllocCount instead of InUseList.Empty
    // because alloc goes to zero during the delete operator
    // instead of during the destructor
    //
    //  We sleep at most 120 seconds for a fixed user count.
    //

    dwTickCount = GetTickCount();
    for (i = 0; i < 500; i++) {
        DebugTrace((LPARAM)this, "Waiting for async connections to die, i = %u", i);
        dwAllocCount = (DWORD) GetAsyncMxOutAllocCount();
        if (dwAllocCount == 0) {
            DebugTrace((LPARAM)this, "All CASYNCMXs connections are gone!");
            break;
        }

        Sleep(1000);

        // Update the stop hint checkpoint when we get within 1 second (1000 ms), of the timeout...
        if ((SERVICE_STOP_WAIT_HINT - 1000) < (GetTickCount() - dwTickCount) && g_pInetSvc &&
            g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) {
            DebugTrace((LPARAM)this, "Updating stop hint, checkpoint = %u", dwStopHint);

            g_pInetSvc->UpdateServiceStatus(SERVICE_STOP_PENDING, NO_ERROR, dwStopHint,
                                            SERVICE_STOP_WAIT_HINT ) ;

            dwStopHint++ ;
            dwTickCount = GetTickCount();
        }

        DebugTrace((LPARAM)this, "Alloc counts: current = %u, last = %u; Thread counts: current = %d, last = %d",
                   dwAllocCount, dwLastAllocCount, GetProcessClientThreads(), cLastThreadCount);
        if (dwAllocCount < dwLastAllocCount) {
            DebugTrace((LPARAM)this, "CASYNCMX Connections are going away, resetting i");
            i = 0;
        }

        dwLastAllocCount = dwAllocCount;
    }

    if (i == 500) {
        ErrorTrace((LPARAM) this, "%d users won't die", m_cNumAsyncObjsAlloced);
        //
        // once we're thru do it again to find any stray clients
        //
        m_OutLock.ExclusiveLock();

        for (pEntry = m_ConnectionsList.Flink;
            pEntry != &m_ConnectionsList;
            pEntry = pEntry->Flink ) {
            //
            // get the next connection object
            //
            pConn = (CAsyncMx *)CONTAINING_RECORD(pEntry, CAsyncMx, m_ListEntry);
            _ASSERT(pConn != NULL);

            ErrorTrace( (LPARAM)pConn, "Stray client" );
        }

        m_OutLock.ExclusiveUnlock();
    }


    DebugTrace( (LPARAM)this, "CASYNCMX Count at end is: %d", m_cNumAsyncObjsAlloced);
    TraceFunctLeaveEx((LPARAM) this);
}




/*++

   Disconnects all user connections.

--*/
VOID SMTP_SERVER_INSTANCE::DisconnectAllOutboundConnections( VOID)
{
    int iteration = 0;
    int i = 0;
    int Count = 0;
    DWORD   dwLastAllocCount = 0;
    DWORD   dwAllocCount;
    int AfterSleepCount = 0;
    DWORD   dwStopHint = 2;
    DWORD   dwTickCount;
    PLIST_ENTRY  pEntry = NULL;
    CLIENT_CONNECTION  * pConn = NULL;

    TraceFunctEnterEx((LPARAM)this, "SMTP_SERVER_INSTANCE::DisconnectAllOutboundConnections( VOID)");

    if (m_fShutdownCalled) {
        DebugTrace((LPARAM)this, "m_fShutdownCalled already -- leaving");
        TraceFunctLeaveEx((LPARAM) this);
    }

    m_OutLock.ExclusiveLock();


    //close down all the active sockets.
    for ( pEntry = m_OutConnectionsList.Flink; pEntry != &m_OutConnectionsList; pEntry = pEntry->Flink) {

        //get the next connection object
        pConn = CONTAINING_RECORD( pEntry, CLIENT_CONNECTION, m_listEntry);
        _ASSERT( pConn != NULL);

        //call the disconnect routine. DisconnectClient() just closes the socket.
        //This will cause all pending I/Os to fail, and have the connections
        //"bubble up to the completion routine where they will be removed from
        //the connection list and then distroyed
        pConn->DisconnectClient( ERROR_SERVER_DISABLED);
    }

    m_OutLock.ExclusiveUnlock();

    //
    //  Wait for the users to die.
    //  The connection objects should be automatically freed because the
    //   socket has been closed. Subsequent requests will fail
    //   and cause a blowaway of the connection objects.
    // looping is used to get out as early as possible when m_cCurrentConn == 0
    //


    //
    //  Wait for the users to die.
    //  The connection objects should be automatically freed because the
    //   socket has been closed. Subsequent requests will fail
    //   and cause a blowaway of the connection objects.
    // looping is used to get out as early as possible when m_cCurrentConn == 0
    //

    //
    // need to check Pool.GetAllocCount instead of InUseList.Empty
    // because alloc goes to zero during the delete operator
    // instead of during the destructor
    //
    //  We sleep at most 180 seconds for a fixed user count.
    //
    dwTickCount = GetTickCount();
    for (i = 0; i < 180; i++) {
        DebugTrace((LPARAM)this, "Waiting for connections to die, i = %u", i);
        dwAllocCount = (DWORD) GetConnOutAllocCount();
        if (dwAllocCount == 0) {
            DebugTrace((LPARAM)this, "All SMTP_CONNOUTs connections are gone!");
            break;
        }

        Sleep(1000);

        // Update the stop hint checkpoint when we get within 1 second (1000 ms), of the timeout...
        if ((SERVICE_STOP_WAIT_HINT - 1000) < (GetTickCount() - dwTickCount) && g_pInetSvc &&
            g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) {
            DebugTrace((LPARAM)this, "Updating stop hint, checkpoint = %u", dwStopHint);

            g_pInetSvc->UpdateServiceStatus(SERVICE_STOP_PENDING, NO_ERROR, dwStopHint,
                                            SERVICE_STOP_WAIT_HINT ) ;

            dwStopHint++ ;
            dwTickCount = GetTickCount();
        }

        DebugTrace((LPARAM)this, "Alloc counts: current = %u, last = %u", dwAllocCount, dwLastAllocCount);
        if (dwAllocCount < dwLastAllocCount) {
            DebugTrace((LPARAM)this, "SMTP_CONNECTION Connections are going away, resetting i");
            i = 0;
        }

        dwLastAllocCount = dwAllocCount;
    }


    DebugTrace( (LPARAM)this, "SMTP_CONNOUT Count at end is: %d", SMTP_CONNECTION::Pool.GetAllocCount() );
    TraceFunctLeaveEx((LPARAM)this);
}


/*++

    Removes the current connection from the list of conenctions
     and decrements count of connected users

    Arguments:

       pcc       pointer to client connection to be removed

--*/
VOID SMTP_SERVER_INSTANCE::RemoveOutboundConnection( IN OUT CLIENT_CONNECTION * pConn)
{
    _ASSERT( pConn != NULL);

    m_OutLock.ExclusiveLock();

    // Remove from list of connections
    RemoveEntryList( &pConn->QueryListEntry());

    // Decrement count of current users
    m_cCurrentOutConnections--;

    BUMP_COUNTER(this, NumConnOutClose);

    m_OutLock.ExclusiveUnlock();


} // SMTP_SERVER_INSTANCE::RemoveConnection()

BOOL SMTP_SERVER_INSTANCE::InitDirectoryNotification(void)
{
    char MailPickUp[MAX_PATH + 1];

    TraceFunctEnterEx((LPARAM)this, "InitDirectoryNotification");

    lstrcpy(MailPickUp, GetMailPickupDir());

    //get rid of the \\ at the end of the name
    if (MailPickUp [GetMailPickupDirLength() - 1] == '\\')
        MailPickUp [GetMailPickupDirLength() - 1] = '\0';

    //create an outbound connectiong_SmtpConfig->GetMailPickupDir()
    SmtpDir = SMTP_DIRNOT::CreateSmtpDirNotification(MailPickUp, SMTP_DIRNOT::ReadDirectoryCompletion, this);
    if (SmtpDir == NULL) {
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
    }

    //now that both queues are initialized, create the
    //thread that goes off and finds any mail files
    //that were not sent and builds up both queues
    DWORD ThreadId;
    DWORD error;
    DirPickupThreadHandle = CreateThread (NULL, 0, SMTP_DIRNOT::PickupInitialFiles, SmtpDir, 0, &ThreadId);
    if (DirPickupThreadHandle == NULL) {
        error = GetLastError();
        ErrorTrace((LPARAM)this, "CreateThread failed for SMTP_DIRNOT::PickupInitialFiles. err: %u", error);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

void SMTP_SERVER_INSTANCE::DestroyDirectoryNotification(void)
{
    TraceFunctEnterEx((LPARAM)this, "DestroyDirectoryNotification(void)");

    //wait for the initial pickup thread
    //to die
    if (DirPickupThreadHandle != NULL) {
        if (SmtpDir)
            SmtpDir->SetPickupRetryQueueEvent();

        WaitForSingleObject(DirPickupThreadHandle, INFINITE);
        ErrorTrace((LPARAM)this, "Initial pickup thread is dead");
        CloseHandle(DirPickupThreadHandle);
        DirPickupThreadHandle = NULL;
    }

    //Just close the handle to the
    //directory. This will cause
    //the notification to come back
    //with an error, and it will be
    //deleted.
    if (SmtpDir) {
        SmtpDir->CloseDirHandle();
    }

    if (SmtpDir) {
        delete SmtpDir;
        SmtpDir = NULL;
        CloseHandle(StopHandle);
        StopHandle = NULL;
    }

    TraceFunctLeaveEx((LPARAM)this);
}

extern char g_UserName[];
extern char g_DomainName[];
extern char g_Password[];


void SMTP_SERVER_INSTANCE::SinkSmtpServerStartHintFunc(void)
{
    if (g_pInetSvc) {
        ((PSMTP_IIS_SERVICE) g_pInetSvc)->StartHintFunction();
    }
}

void SMTP_SERVER_INSTANCE::SinkSmtpServerStopHintFunc(void)
{
    StopHint();
}

void SmtpServerStartHintFunc(PVOID ThisPtr)
{
    ((PSMTP_IIS_SERVICE) g_pInetSvc)->StartHintFunction();
}

void SmtpServerStopHintFunc(PVOID ThisPtr)
{
    ((SMTP_SERVER_INSTANCE *) ThisPtr)->StopHint();
}

BOOL SMTP_SERVER_INSTANCE::StartAdvancedQueueing(void)
{
    TraceFunctEnterEx((LPARAM) this, "LoadAdvancedQueueing");

    HRESULT hr = S_OK;

    ((PSMTP_IIS_SERVICE) g_pInetSvc)->StartHintFunction();

    hr = (g_pfnInitializeAQ)(m_ComSmtpServer, QueryInstanceId(),
                             g_UserName, g_DomainName, g_Password, SmtpServerStartHintFunc,
                             (PVOID) this, &m_IAQ, &m_ICM,
                             &m_pIAdvQueueConfig, &m_pvAQInstanceContext);

    ErrorTrace((LPARAM)this, "Advanced Queuing returned status code  %x", hr);

    TraceFunctLeaveEx((LPARAM) this);
    return !FAILED(hr);

}

BOOL SMTP_SERVER_INSTANCE::StopQDrivers(void)
{
    TraceFunctEnterEx((LPARAM) this, "StopQDrivers");

    if (m_pIAdvQueueConfig) {
        m_pIAdvQueueConfig->Release();
        m_pIAdvQueueConfig = NULL;
    }

    if (m_IAQ != NULL) {
        m_IAQ->Release();
        m_IAQ = NULL;
    }

    if (m_ICM != NULL) {
        m_ICM->Release();
        m_ICM = NULL;
    }

    if (fInitializedAQ && g_pfnDeinitializeAQ && m_pvAQInstanceContext) {
        (g_pfnDeinitializeAQ)(m_pvAQInstanceContext, SmtpServerStopHintFunc, (PVOID) this);
        m_pvAQInstanceContext = NULL;
        fInitializedAQ = FALSE;
    }

    TraceFunctLeaveEx((LPARAM) this);
    return TRUE;
}

extern void VerifyFQDNWithGlobalIp(DWORD InstanceId,char * szFQDomainName);
void SMTP_SERVER_INSTANCE::VerifyFQDNWithBindings(void)
{

    CONST CHAR *apszMsgs[2];
    CHAR achInstance[20];
    CHAR achIPAddr[20];

    char * FQDNValue = NULL;
    char * IpAddress = NULL;
    in_addr UNALIGNED * P_Addr = NULL;

    PHOSTENT pH = NULL;

    char * Ptr = NULL;
    const char *  StartPtr = NULL;
    const CHAR * ipAddressString = NULL;
    const CHAR * ipPortString = NULL;
    const CHAR * end = NULL;
    DWORD InetAddr = 0;
    DWORD CharIpSize = 0;
    CHAR temp[sizeof("123.123.123.123")];
    INT length;

    BOOL fGlobalListChecked = FALSE;

    //Get the current instnace id
    wsprintf( achInstance,
              "%lu",
              QueryInstanceId() );
    apszMsgs[1] = achInstance;

    //grab the sharing lock

    if (m_ServerBindings.IsEmpty()) {
        if (!fGlobalListChecked) {
            VerifyFQDNWithGlobalIp(QueryInstanceId(), m_szFQDomainName);
            fGlobalListChecked = TRUE;
        }
    } else {
        for (StartPtr = m_ServerBindings.First(); StartPtr != NULL; StartPtr = m_ServerBindings.Next( StartPtr )) {
            ipAddressString = StartPtr;
            ipPortString = strchr(StartPtr, ':');
            if (ipPortString == NULL) {
                wsprintf( achIPAddr,"%s","0.0.0.0");
                apszMsgs[0] = achIPAddr;
                SmtpLogEvent( SMTP_EVENT_UNRESOLVED_FQDN,2,apszMsgs,0 );
            }

            // Validate and parse the IP address portion.
            //
            if ( *ipAddressString == ':' ) {
                if (!fGlobalListChecked) {
                    VerifyFQDNWithGlobalIp(QueryInstanceId(),m_szFQDomainName);
                    fGlobalListChecked = TRUE;
                }
            } else {
                length = DIFF(ipPortString - ipAddressString) - 1;
                if ( length > sizeof(temp) ) {
                    wsprintf( achIPAddr,"%s", temp);
                    apszMsgs[0] = achIPAddr;
                    SmtpLogEvent( SMTP_EVENT_UNRESOLVED_FQDN,1,apszMsgs,0 );
                }
                CopyMemory( temp, ipAddressString, length);
                temp[length] = '\0';
                InetAddr = inet_addr( temp );
                if ( InetAddr != INADDR_NONE ) {
                    //For IP address find the host name
                    ((PSMTP_IIS_SERVICE) g_pInetSvc)->StartHintFunction();
                    pH = gethostbyaddr((char*)(&InetAddr), 4, PF_INET );
                    if (pH && pH->h_name) {
                        if (_strcmpi(pH->h_name,m_szFQDomainName)) {
                            wsprintf( achIPAddr,"%s",temp);
                            apszMsgs[0] = achIPAddr;
                            SmtpLogEvent( SMTP_EVENT_UNRESOLVED_FQDN,2,apszMsgs,0 );
                        }
                    } else {
                        wsprintf( achIPAddr,"%s",temp);
                        apszMsgs[0] = achIPAddr;
                        SmtpLogEvent( SMTP_EVENT_UNRESOLVED_FQDN,2,apszMsgs,0 );
                    }

                } else {
                    wsprintf( achIPAddr,"%s", temp);
                    apszMsgs[0] = achIPAddr;
                    SmtpLogEvent( SMTP_EVENT_UNRESOLVED_FQDN,2,apszMsgs,0 );
                }
            }//end else of if( *ipAddressString == ':' )
        }//end for
    }//end else

    return;
}

BOOL SMTP_SERVER_INSTANCE::RegisterServicePrincipalNames(BOOL fLock)
{
    if (fLock)
        m_GenLock.ExclusiveLock();

    if (!m_fHaveRegisteredPrincipalNames) {

        PSMTP_IIS_SERVICE     pService = (PSMTP_IIS_SERVICE) g_pInetSvc;

        if (pService->ResetServicePrincipalNames()) {

            m_fHaveRegisteredPrincipalNames =
                CSecurityCtx::RegisterServicePrincipalNames(
                    SMTP_SERVICE_NAME, m_szFQDomainName);
        }
    }

    if (fLock)
        m_GenLock.ExclusiveUnlock();

    return( m_fHaveRegisteredPrincipalNames );
}


//+------------------------------------------------------------
//
// Function: SMTP_SERVER_INSTANCE::HrSetWellKnownIServerProps
//
// Synopsis: Take info from member variables and set them in the
//           IServer property bag
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  error from CMailMsgLoggingPropertyBag
//
// History:
// jstamerj 1998/11/17 16:41:08: Created.
//
//-------------------------------------------------------------
HRESULT SMTP_SERVER_INSTANCE::HrSetWellKnownIServerProps()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this,
                      "SMTP_SERVER_INSTANCE::HrSetWellKnownIServerProps");

    _ASSERT(m_pSmtpInfo);

    hr = m_InstancePropertyBag.PutDWORD(
        PE_ISERVID_DW_INSTANCE,
        m_pSmtpInfo->dwInstanceId);

    if(FAILED(hr))
        goto CLEANUP;

    hr = m_InstancePropertyBag.PutStringA(
        PE_ISERVID_SZ_DEFAULTDOMAIN,
        m_szDefaultDomain);

    if(FAILED(hr))
        goto CLEANUP;

 CLEANUP:
    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);

    return hr;
}

//---[ SMTP_SERVER_INSTANCE::IsDropDirQuotaExceeded ]--------------------------
//
//
//  Description:
//      Checks to see if we are past our drop dir quota (if enforced).  The
//      quota is defined to be 11 times the max messages size (or 22 MB if
//      there is no max message size).  If we are within 1 max message size
//      of the quota (2MB is no max message size), we will assume that this
//      message will push us over the quota.
//  Parameters:
//      -
//  Returns:
//      TRUE        We are past our quota (or this message will do it)
//      FALSE       We are still under drop dir quota.
//  History:
//      10/28/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL SMTP_SERVER_INSTANCE::IsDropDirQuotaExceeded()
{
    TraceFunctEnterEx((LPARAM) this, "SMTP_SERVER_INSTANCE::IsDropDirQuotaExceeded");
    DWORD   cbMaxMsgSize = GetMaxMsgSize();
    BOOL    fQuotaExceeded = FALSE;
    HANDLE  hDropDirFind = INVALID_HANDLE_VALUE;
    LARGE_INTEGER LIntDropDirSize;
    LARGE_INTEGER LIntDropQuota;
    LARGE_INTEGER LIntCurrentFile;
    WIN32_FIND_DATA   FileInfo;
    CHAR    szDropDirSearch[sizeof(m_szMailDropDir) + sizeof("*")];

    ZeroMemory(&FileInfo, sizeof(FileInfo));
    LIntDropDirSize.QuadPart = 0;
    LIntDropQuota.QuadPart = 0;

    if (!IsDropDirQuotaCheckingEnabled() || !GetMailDropDir(szDropDirSearch))
    {
        fQuotaExceeded = FALSE;
        goto Exit;
    }

    if (!cbMaxMsgSize)
        cbMaxMsgSize = 2*1024*1024;  //Default to 2 MB

    //Set drop dir quota to be 10 times the max message size, if we
    //exceed this, then we are within 1 max message size of the "true" quota
    LIntDropQuota.QuadPart = 10*cbMaxMsgSize;

    //Build up a search so we can loop over the file names
    lstrcat(szDropDirSearch, "*");
    hDropDirFind = FindFirstFileEx(szDropDirSearch,
                                   FindExInfoStandard,
                                   &FileInfo,
                                   FindExSearchNameMatch,
                                   NULL,
                                   0);

    if (INVALID_HANDLE_VALUE == hDropDirFind)
    {
        ErrorTrace((LPARAM) this,
            "Unable to open drop dir for quota checking - 0x%X", GetLastError());

        //If we cannot open the directory assume we are over quota
        fQuotaExceeded  = TRUE;
        goto Exit;
    }

    //Loop over all the files we have found
    do
    {
        LIntCurrentFile.LowPart = FileInfo.nFileSizeLow;
        LIntCurrentFile.HighPart = FileInfo.nFileSizeHigh;

        LIntDropDirSize.QuadPart += LIntCurrentFile.QuadPart;

        if (LIntDropQuota.QuadPart <= LIntDropDirSize.QuadPart)
        {
            fQuotaExceeded = TRUE;
            goto Exit;
        }
    } while (FindNextFile(hDropDirFind, &FileInfo));

    if (LIntDropQuota.QuadPart <= LIntDropDirSize.QuadPart)
        fQuotaExceeded = TRUE;
    else
        fQuotaExceeded = FALSE;

  Exit:
    if (INVALID_HANDLE_VALUE != hDropDirFind)
        FindClose(hDropDirFind);

    TraceFunctLeave();
    return fQuotaExceeded;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\spinlock.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: spinlock.cpp
//
// Contents: Simple Spinlock package used by CLdapConnection
//
// Classes:
//
// Functions:
//   AcquireSpinLockSingleProc
//   AcquireSpinLockMultiProc
//   InitializeSpinLock
//   ReleaseSpinLock
//
// History:
// jstamerj 980511 17:26:26: Created.
//
//-------------------------------------------------------------
#include "smtpinc.h"
#include "spinlock.h"

PFN_ACQUIRESPINLOCK g_AcquireSpinLock;

//+----------------------------------------------------------------------------
//
//  Function:   InitializeSpinLock
//
//  Synopsis:   Initializes a SPIN_LOCK
//
//  Arguments:  [psl] -- Pointer to SPIN_LOCK to initialize
//
//  Returns:    Nothing. *psl is in released state when this functionr returns
//
//-----------------------------------------------------------------------------

VOID InitializeSpinLock(
    PSPIN_LOCK psl)
{
    *psl = 0;

    if(g_AcquireSpinLock == NULL) {
        // Determine multi or single proc
        SYSTEM_INFO si;
        GetSystemInfo(&si);
    
        if(si.dwNumberOfProcessors > 1) {
            g_AcquireSpinLock = AcquireSpinLockMultipleProc;
        } else {
            g_AcquireSpinLock = AcquireSpinLockSingleProc;
        }
    }

}

//+----------------------------------------------------------------------------
//
//  Function:   AcquireSpinLockMultiProc
//
//  Synopsis:   Acquire a lock, spinning while it is unavailable.
//              Optimized for multi proc machines
//
//  Arguments:  [psl] -- Pointer to SPIN_LOCK to acquire
//
//  Returns:    Nothing. *psl is in acquired state when this function returns
//
//-----------------------------------------------------------------------------

VOID AcquireSpinLockMultipleProc(
    volatile PSPIN_LOCK psl)
{
    do {

        //
        // Spin while the lock is unavailable
        //

        while (*psl > 0) {
            ;
        }

        //
        // Lock just became available, try to grab it
        //

    } while ( InterlockedIncrement(psl) != 1 );

}

//+----------------------------------------------------------------------------
//
//  Function:   AcquireSpinLockSingleProc
//
//  Synopsis:   Acquire a lock, spinning while it is unavailable.
//              Optimized for single proc machines
//
//  Arguments:  [psl] -- Pointer to SPIN_LOCK to acquire
//
//  Returns:    Nothing. *psl is in acquired state when this function returns
//
//-----------------------------------------------------------------------------

VOID AcquireSpinLockSingleProc(
    volatile PSPIN_LOCK psl)
{
    do {

        //
        // Spin while the lock is unavailable
        //

        while (*psl > 0) {
            Sleep(0);
        }

        //
        // Lock just became available, try to grab it
        //

    } while ( InterlockedIncrement(psl) != 1 );

}

//+----------------------------------------------------------------------------
//
//  Function:   ReleaseSpinLock
//
//  Synopsis:   Releases an acquired spin lock
//
//  Arguments:  [psl] -- Pointer to SPIN_LOCK to release.
//
//  Returns:    Nothing. *psl is in released state when this function returns
//
//-----------------------------------------------------------------------------

VOID ReleaseSpinLock(
    PSPIN_LOCK psl)
{
    _ASSERT( *psl > 0 );

    InterlockedExchange( psl, 0 );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\sockutil.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    sockutil.c

    This module contains utility routines for managing & manipulating
    sockets.


    FILE HISTORY:
		VladimV		30-May-1995		Created	

*/


#define INCL_INETSRV_INCS
#include "smtpinc.h"

extern HINSTANCE		g_WSockMsgDll;


//
//  Public functions.
//

/*******************************************************************

    NAME:       InitializeSockets

    SYNOPSIS:   Initializes socket access.  Among other things, this
                routine is responsible for connecting to WinSock,
                and creating the connection thread.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    NOTES:      This routine may only be called by a single thread
                of execution; it is not necessarily multi-thread safe.

    HISTORY:

********************************************************************/
APIERR InitializeSockets( VOID )
{
    WSADATA   wsadata;
    SOCKERR   serr;

    TraceFunctEnter( "InitializeSockets" );

    //
    //  Connect to WinSock.
    //

    serr = WSAStartup( MAKEWORD( 1, 1 ), &wsadata );

    if( serr != 0 ) {

       // g_pInetSvc->LogEvent( SMTP_EVENT_CANNOT_INITIALIZE_WINSOCK,
       //                        0, (const CHAR **) NULL, serr);

        FatalTrace( 0, "cannot initialize WinSock, socket error %d", serr); _ASSERT( FALSE);
    } else {
		DebugTrace( 0, "Sockets initialized");
	}
    TraceFunctLeave();
    return serr;
}   // InitializeSockets

/*******************************************************************

    NAME:       TerminateSockets

    SYNOPSIS:   Terminate socket access.  This routine is responsible
                for closing the connection socket(s) and detaching
                from WinSock.

    NOTES:      This routine may only be called by a single thread
                of execution; it is not necessarily multi-thread safe.

    HISTORY:

********************************************************************/
VOID TerminateSockets( VOID )
{
    SOCKERR serr;

    TraceFunctEnter( "TerminateSockets" );

    //
    //  Disconnect from WinSock.
    //

    serr = WSACleanup();

    if( serr != 0 ) {
		FatalTrace( 0, "cannot terminate WinSock, error=%d", serr); _ASSERT( FALSE);
    } else {
		DebugTrace( 0, "Sockets terminated");
	}
    TraceFunctLeave();
}   // TerminateSockets

/*******************************************************************

    NAME:       GetSockErrorMessage

    SYNOPSIS:   This routine is responsible for getting winsock
                error messages stored in smtpsvc.dll

    HISTORY:

********************************************************************/
DWORD GetSockErrorMessage(DWORD dwErrno, char * ErrorBuf, DWORD ErrorBufSize)
{
    DWORD msglen;
    DWORD usMsgNum;

    switch (dwErrno) 
	{
        case WSAENAMETOOLONG:
            usMsgNum = SMTP_WSAENAMETOOLONG;
            break;
        case WSASYSNOTREADY:
            usMsgNum = SMTP_WSASYSNOTREADY;
            break;
        case WSAVERNOTSUPPORTED:
            usMsgNum = SMTP_WSAVERNOTSUPPORTED;
            break;
        case WSAESHUTDOWN:
            usMsgNum = SMTP_WSAESHUTDOWN;
            break;
        case WSAEINTR:
            usMsgNum = SMTP_WSAEINTR;
            break;
        case WSAHOST_NOT_FOUND:
            usMsgNum = SMTP_WSAHOST_NOT_FOUND;
            break;
        case WSATRY_AGAIN:
            usMsgNum = SMTP_WSATRY_AGAIN;
            break;
        case WSANO_RECOVERY:
            usMsgNum = SMTP_WSANO_RECOVERY;
            break;
        case WSANO_DATA:
            usMsgNum = SMTP_WSANO_DATA;
            break;
        case WSAEBADF:
            usMsgNum = SMTP_WSAEBADF;
            break;
        case WSAEWOULDBLOCK:
            usMsgNum = SMTP_WSAEWOULDBLOCK;
            break;
        case WSAEINPROGRESS:
            usMsgNum = SMTP_WSAEINPROGRESS;
            break;
        case WSAEALREADY:
            usMsgNum = SMTP_WSAEALREADY;
            break;
        case WSAEFAULT:
            usMsgNum = SMTP_WSAEFAULT;
            break;
        case WSAEDESTADDRREQ:
            usMsgNum = SMTP_WSAEDESTADDRREQ;
            break;
        case WSAEMSGSIZE:
            usMsgNum = SMTP_WSAEMSGSIZE;
            break;
        case WSAEPFNOSUPPORT:
            usMsgNum = SMTP_WSAEPFNOSUPPORT;
            break;
        case WSAENOTEMPTY:
            usMsgNum = SMTP_WSAENOTEMPTY;
            break;
        case WSAEPROCLIM:
            usMsgNum = SMTP_WSAEPROCLIM;
            break;
        case WSAEUSERS:
            usMsgNum = SMTP_WSAEUSERS;
            break;
        case WSAEDQUOT:
            usMsgNum = SMTP_WSAEDQUOT;
            break;
        case WSAESTALE:
            usMsgNum = SMTP_WSAESTALE;
            break;
        case WSAEINVAL:
            usMsgNum = SMTP_WSAEINVAL;
            break;
        case WSAEMFILE:
            usMsgNum = SMTP_WSAEMFILE;
            break;
        case WSAELOOP:
            usMsgNum = SMTP_WSAELOOP;
            break;
        case WSAEREMOTE:
            usMsgNum = SMTP_WSAEREMOTE;
            break;
        case WSAENOTSOCK:
            usMsgNum = SMTP_WSAENOTSOCK;
            break;
        case WSAEADDRNOTAVAIL:
            usMsgNum = SMTP_WSAEADDRNOTAVAIL;
            break;
        case WSAEADDRINUSE:
            usMsgNum = SMTP_WSAEADDRINUSE;
            break;
        case WSAEAFNOSUPPORT:
            usMsgNum = SMTP_WSAEAFNOSUPPORT;
            break;
        case WSAESOCKTNOSUPPORT:
            usMsgNum = SMTP_WSAESOCKTNOSUPPORT;
            break;
        case WSAEPROTONOSUPPORT:
            usMsgNum = SMTP_WSAEPROTONOSUPPORT;
            break;
        case WSAENOBUFS:
            usMsgNum = SMTP_WSAENOBUFS;
            break;
        case WSAETIMEDOUT:
            usMsgNum = SMTP_WSAETIMEDOUT;
            break;
        case WSAEISCONN:
            usMsgNum = SMTP_WSAEISCONN;
            break;
        case WSAENOTCONN:
            usMsgNum = SMTP_WSAENOTCONN;
            break;
        case WSAENOPROTOOPT:
            usMsgNum = SMTP_WSAENOPROTOOPT;
            break;
        case WSAECONNRESET:
            usMsgNum = SMTP_WSAECONNRESET;
            break;
        case WSAECONNABORTED:
            usMsgNum = SMTP_WSAECONNABORTED;
            break;
        case WSAENETDOWN:
            usMsgNum = SMTP_WSAENETDOWN;
            break;
        case WSAENETRESET:
            usMsgNum = SMTP_WSAENETRESET;
            break;
        case WSAECONNREFUSED:
            usMsgNum = SMTP_WSAECONNREFUSED;
            break;
        case WSAEHOSTDOWN:
            usMsgNum = SMTP_WSAEHOSTDOWN;
            break;
        case WSAEHOSTUNREACH:
            usMsgNum = SMTP_WSAEHOSTUNREACH;
            break;
        case WSAEPROTOTYPE:
            usMsgNum = SMTP_WSAEPROTOTYPE;
            break;
        case WSAEOPNOTSUPP:
            usMsgNum = SMTP_WSAEOPNOTSUPP;
            break;
        case WSAENETUNREACH:
            usMsgNum = SMTP_WSAENETUNREACH;
            break;
        case WSAETOOMANYREFS:
            usMsgNum = SMTP_WSAETOOMANYREFS;
            break;
        default:
            usMsgNum = dwErrno;
			break;
    }

								// call the OS using US/ASCII
	msglen = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, g_WSockMsgDll, usMsgNum,
						   MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
						   ErrorBuf, ErrorBufSize, NULL);
	return(msglen);
}


/*++

	Name :
		MyStrChr

    Description:
	   Works just like strchr(), but takes the size
	   of the buffer

    Arguments:
		Line - Buffer to search
		Val  - Value to look for in the buffer
		LineSize - Size of Line

    Returns:
		If Val is found, a pointer to Val is
		returned, els NULL


--*/
char * MyStrChr(char *Line, unsigned char Val, DWORD LineSize)
{
   register DWORD Loop = 0;
   unsigned char * Match = NULL;
   register unsigned char * SearchPtr;

   ASSERT( Line != NULL);

   if(LineSize == 0)
    return NULL;

   SearchPtr = (unsigned char *) Line;

   // Scan the entire buffer looking for Val
   for(Loop = 0; Loop < LineSize; Loop++)
   {
     if (SearchPtr[Loop] == Val)
     {
		Match  = &SearchPtr[Loop];
        break;
     }

   } // for

  return (char *) Match;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\stats.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module Name :
    
       stats.cxx

   Abstract:
    
       Defines functions required for server statistics

   Author:

       Murali R. Krishnan    ( MuraliK )     04-Nov-1994
   
   Project:

       Web Server DLL

   Functions Exported:

               SMTP_SERVER_STATISTICS::SERVER_STATISTICS( VOID) 
       VOID    SMTP_SERVER_STATISTICS::ClearStatistics( VOID)
       DWORD   CopyToStatsBuffer( LPSMTP_STATISTICS_1 lpStat)

   Revision History:

       Sophia Chung ( SophiaC )     20-Nov-1996

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#define INCL_INETSRV_INCS
#include "smtpinc.h"


/************************************************************
 *    Functions 
 ************************************************************/

 /*++
     Initializes statistics information for server.
--*/

SMTP_SERVER_STATISTICS::SMTP_SERVER_STATISTICS(SMTP_SERVER_INSTANCE * pInstance) 
{
    InitializeCriticalSection( & m_csStatsLock);

	m_pInstance = pInstance;

    ClearStatistics();

} // SMTP_SERVER_STATISTICS::SMTP_SERVER_STATISTICS();

/*++

    Clears the counters used for statistics information

--*/ 
VOID
SMTP_SERVER_STATISTICS::ClearStatistics( VOID)
{
    LockStatistics();

    ZeroMemory( &m_SmtpStats, sizeof(SMTP_STATISTICS_0) );
    m_SmtpStats.TimeOfLastClear       = GetCurrentTime();
    UnlockStatistics();

} // SMTP_SERVER_STATISTICS::ClearStatistics()



DWORD
SMTP_SERVER_STATISTICS::CopyToStatsBuffer( LPSMTP_STATISTICS_0 lpStat)
/*++
    Description:
        copies the statistics data from the server statistcs structure
        to the SMTP_STATISTICS_1 structure for RPC access.

    Arugments:
        lpStat  pointer to SMTP_STATISTICS_1 object which contains the 
                data on successful return

    Returns:
        Win32 error codes. NO_ERROR on success. 

--*/
{
	AQPerfCounters AqPerf;
	HRESULT hr = S_FALSE;
	IAdvQueueConfig *pIAdvQueueConfig = NULL;

    _ASSERT( lpStat != NULL);

    LockStatistics();

	pIAdvQueueConfig = m_pInstance->QueryAqConfigPtr();
	if(pIAdvQueueConfig != NULL)
	{
        AqPerf.cbVersion = sizeof(AQPerfCounters);
		hr = pIAdvQueueConfig->GetPerfCounters(
            &AqPerf,
            &(m_SmtpStats.CatPerfBlock));

		if(!FAILED(hr))
		{
			m_SmtpStats.RemoteQueueLength = AqPerf.cCurrentQueueMsgInstances;
			m_SmtpStats.NumMsgsDelivered = AqPerf.cMsgsDeliveredLocal;
			m_SmtpStats.LocalQueueLength = AqPerf.cCurrentMsgsPendingLocalDelivery;
			m_SmtpStats.RemoteRetryQueueLength = AqPerf.cCurrentMsgsPendingRemoteRetry;
            m_SmtpStats.NumSendRetries = AqPerf.cTotalMsgRemoteSendRetries;
            m_SmtpStats.NumNDRGenerated = AqPerf.cNDRsGenerated;
            m_SmtpStats.RetryQueueLength = AqPerf.cCurrentMsgsPendingLocalRetry;
            m_SmtpStats.NumDeliveryRetries = AqPerf.cTotalMsgLocalRetries;
            m_SmtpStats.ETRNMessages = AqPerf.cTotalMsgsTURNETRN;
			m_SmtpStats.CatQueueLength = AqPerf.cCurrentMsgsPendingCat;
            m_SmtpStats.MsgsBadmailNoRecipients = AqPerf.cTotalMsgsBadmailNoRecipients;
            m_SmtpStats.MsgsBadmailHopCountExceeded = AqPerf.cTotalMsgsBadmailHopCountExceeded;
            m_SmtpStats.MsgsBadmailFailureGeneral = AqPerf.cTotalMsgsBadmailFailureGeneral;
            m_SmtpStats.MsgsBadmailBadPickupFile = AqPerf.cTotalMsgsBadmailBadPickupFile;
            m_SmtpStats.MsgsBadmailEvent = AqPerf.cTotalMsgsBadmailEvent;
            m_SmtpStats.MsgsBadmailNdrOfDsn = AqPerf.cTotalMsgsBadmailNdrOfDsn;
            m_SmtpStats.MsgsPendingRouting = AqPerf.cCurrentMsgsPendingRouting;
            m_SmtpStats.MsgsPendingUnreachableLink = AqPerf.cCurrentMsgsPendingUnreachableLink;
            m_SmtpStats.SubmittedMessages = AqPerf.cTotalMsgsSubmitted;
            m_SmtpStats.DSNFailures = AqPerf.cTotalDSNFailures;
            m_SmtpStats.MsgsInLocalDelivery = AqPerf.cCurrentMsgsInLocalDelivery;
		}
	}

    CopyMemory( lpStat, &m_SmtpStats, sizeof(SMTP_STATISTICS_0) );

    UnlockStatistics();

    return ( NO_ERROR);

} // CopyToStatsBuffer()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\smtpsvr.cpp ===
// SMTPServer.cpp : Implementation of CSMTPServer

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "stdafx.h"
#include "dbgtrace.h"

#include "filehc.h"
#include "mailmsg.h"
#include "mailmsgi.h"

#include "smtpsvr.h"

//DECLARE_DEBUG_PRINTS_OBJECT();

#define MAILMSG_PROGID          L"Exchange.MailMsg"

/////////////////////////////////////////////////////////////////////////////
// CSMTPServer

STDMETHODIMP CSMTPServer::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] =
	{
		&IID_ISMTPServer,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

BOOL InitExchangeSmtpServer(PVOID Ptr, PVOID Ptr2)
{

	CSMTPServer * ThisPtr = (CSMTPServer *) Ptr;
	ThisPtr->Init((SMTP_SERVER_INSTANCE *) Ptr2);
	return TRUE;
}


//
// Add all your initialization needs here ...
//
HRESULT CSMTPServer::Init(SMTP_SERVER_INSTANCE * pInstance)
{
	_ASSERT (pInstance != NULL);

	m_pInstance = pInstance;
	return(S_OK);
}

STDMETHODIMP CSMTPServer::QueryInterface(
                        REFIID          iid,
                        void            **ppvObject
                        )
{

	if (iid == IID_IUnknown)
    {
		// Return our identity
		*ppvObject = (IUnknown *)(ISMTPServerInternal *)this;
		AddRef();
    }
	else if(iid == IID_ISMTPServer)
	{
		// Return our identity
		*ppvObject = (ISMTPServerInternal *)this;
		AddRef();
	}
    else if(iid == IID_ISMTPServerInternal)
    {
        // Return our identity
        *ppvObject = (ISMTPServerInternal *)this;
        AddRef();
    }
    else if(iid == IID_IMailTransportRouterReset)
    {
        // Return our identity
        *ppvObject = (IMailTransportRouterReset *)this;
        AddRef();
    }
    else if(iid == IID_IMailTransportSetRouterReset)
    {
        // Return our identity
        *ppvObject = (IMailTransportSetRouterReset *)this;
        AddRef();
    }
    else if(iid == IID_IMailTransportRouterSetLinkState)
    {
        // Return our identity
        *ppvObject = (IMailTransportRouterSetLinkState *)this;
        AddRef();
    }
    else if(iid == IID_ISMTPServerEx)
    {
        // Return our identity
        *ppvObject = (ISMTPServerEx *)this;
        AddRef();
    }
    else if(iid == IID_ISMTPServerGetAuxDomainInfoFlags)
    {
        // Return our identity
        *ppvObject = (ISMTPServerGetAuxDomainInfoFlags *)this;
        AddRef();
    }
    else if(iid == IID_ISMTPServerAsync)
    {
        // Return our identity
        *ppvObject = (ISMTPServerAsync *)this;
        AddRef();
    }
    else
    {
		return(E_NOINTERFACE);
    }

    return(S_OK);
}

STDMETHODIMP CSMTPServer::AllocMessage(
			IMailMsgProperties **ppMsg
			)
{
	HRESULT hr = S_OK;
	// Create a new MailMsg
	hr = CoCreateInstance(
                    CLSID_MsgImp,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_IMailMsgProperties,
                    (LPVOID *)ppMsg);

	return(hr);
}

STDMETHODIMP CSMTPServer::SubmitMessage(
			IMailMsgProperties *pMsg
			)
{
	HRESULT hr = S_FALSE;

	if(m_pInstance)
	{
		hr = m_pInstance->InsertIntoAdvQueue(pMsg);
	}

	return(hr);
}


STDMETHODIMP CSMTPServer::TriggerLocalDelivery(
			IMailMsgProperties *pMsg, DWORD dwRecipientCount, DWORD * pdwRecipIndexes
			)
{
	HRESULT hr = S_FALSE;

	if(m_pInstance)
	{
		hr = m_pInstance->TriggerLocalDelivery(pMsg, dwRecipientCount, pdwRecipIndexes, NULL);
	}

	return(hr);
}

STDMETHODIMP CSMTPServer::TriggerLocalDeliveryAsync(
			IMailMsgProperties *pMsg, DWORD dwRecipientCount, DWORD * pdwRecipIndexes, IMailMsgNotify *pNotify
			)
{
	HRESULT hr = S_FALSE;

	if(m_pInstance)
	{
		hr = m_pInstance->TriggerLocalDelivery(pMsg, dwRecipientCount, pdwRecipIndexes, pNotify);
	}

	return(hr);
}

STDMETHODIMP CSMTPServer::TriggerServerEvent(
    DWORD dwEventID,
    PVOID pvContext)
{
	HRESULT hr = S_FALSE;

	if(m_pInstance)
	{
		hr = m_pInstance->TriggerServerEvent(dwEventID, pvContext);
	}

	return(hr);
}

STDMETHODIMP CSMTPServer::ReadMetabaseString(DWORD MetabaseId, LPBYTE Buffer, DWORD * BufferSize, BOOL fSecure)
{
	HRESULT hr = S_FALSE;

	if(m_pInstance)
	{
		hr = m_pInstance->SinkReadMetabaseString(MetabaseId, (char *) Buffer, BufferSize, (BOOL) fSecure);
	}

	return hr;
}

STDMETHODIMP CSMTPServer::ReadMetabaseDword(DWORD MetabaseId, DWORD * dwValue)
{
	HRESULT hr = S_FALSE;

	if(m_pInstance)
	{
		hr = m_pInstance->SinkReadMetabaseDword(MetabaseId, dwValue);
	}

	return hr;
}

STDMETHODIMP CSMTPServer::ServerStartHintFunction()
{
	HRESULT hr = S_OK;

	if(m_pInstance)
	{
		m_pInstance->SinkSmtpServerStartHintFunc();
	}

	return hr;
}

STDMETHODIMP CSMTPServer::ServerStopHintFunction()
{
	HRESULT hr = S_OK;

	if(m_pInstance)
	{
		m_pInstance->SinkSmtpServerStopHintFunc();
	}

	return hr;
}

STDMETHODIMP CSMTPServer::ReadMetabaseData(DWORD MetabaseId, BYTE *Buffer, DWORD *BufferSize)
{
	HRESULT hr = S_FALSE;

	if(m_pInstance)
	{
		hr = m_pInstance->SinkReadMetabaseData(MetabaseId, Buffer, BufferSize);
	}

	return hr;
}

//---[ CSMTPServer::AllocBoundMessage ]----------------------------------------
//
//
//  Description:
//      Creates a message and binds it to an ATQ Context
//  Parameters:
//      ppMsg       Message to allocate
//      phContent   Content handle for message
//  Returns:
//      HRESULT from alloc message event
//      E_POINTER if ppMsg or phContent is NULL
//      E_FAIL if m_pIstance is NULL
//  History:
//      7/11/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPServer::AllocBoundMessage(
              OUT IMailMsgProperties **ppMsg,
              OUT PFIO_CONTEXT *phContent)
{
    TraceFunctEnterEx((LPARAM) this, "CSMTPServer::AllocBoundMessage");
    HRESULT hr = S_OK;
	SMTP_ALLOC_PARAMS AllocParams;
    IMailMsgBind *pBindInterface = NULL;

    if (!phContent || !ppMsg)
    {
        hr = E_POINTER;
        goto Exit;
    }

    //we cannot bind the message without m_pInstance
    if (!m_pInstance)
    {
        hr = E_FAIL;
        goto Exit;
    }

    //CoCreate unbound message object
    hr = CoCreateInstance(
                    CLSID_MsgImp,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_IMailMsgProperties,
                    (LPVOID *)ppMsg);

    if (FAILED(hr))
        goto Exit;

    hr = (*ppMsg)->QueryInterface(IID_IMailMsgBind, (void **) &pBindInterface);
    if (FAILED(hr))
        goto Exit;

    AllocParams.BindInterfacePtr = (PVOID) pBindInterface;
    AllocParams.IMsgPtr = (PVOID) (*ppMsg);
    AllocParams.hContent = NULL;
    AllocParams.hr = S_OK;
    AllocParams.m_pNotify = NULL;

    //For client context pass in something that will stay around the lifetime of the
    //atqcontext -
    AllocParams.pAtqClientContext = m_pInstance;

    if(m_pInstance->AllocNewMessage(&AllocParams))
	{
		hr = AllocParams.hr;

		if (SUCCEEDED(hr) && (AllocParams.hContent != NULL))
			*phContent = AllocParams.hContent;
		else
			hr = E_FAIL;
	}
	else
	{
		hr = E_FAIL;
	}

  Exit:

    if (FAILED(hr) && ppMsg && (*ppMsg))
    {
        (*ppMsg)->Release();
        *ppMsg = NULL;

    }

    if (pBindInterface)
        pBindInterface->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CSMTPSvr::ResetRoutes ]-------------------------------------------------
//
//
//  Description:
//      Implements IMailTransportRouterReset::ResetRoutes.  Acts as a buffer
//      between AQ and the routers.  On shutdown... AQ can safely destroy
//      it's heap by telling ISMTPServer to release its pointer to AQ's
//      IMailTransportRouterReset interface
//  Parameters:
//      dwResetType     The type of route reset to perform.
//  Returns:
//      S_OK on success (or if no m_pIRouterReset)
//      Error code from AQUEUE if error occurs.
//  History:
//      11/8/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPServer::ResetRoutes(IN DWORD dwResetType)
{
    HRESULT hr = S_OK;
    m_slRouterReset.ShareLock();

    if (m_pIRouterReset)
        hr = m_pIRouterReset->ResetRoutes(dwResetType);

    m_slRouterReset.ShareUnlock();
    return hr;
}


//---[ CSMTPSvr::RegisterResetInterface ]---------------------------------------
//
//
//  Description:
//      Implements IMailTransportSetRouterReset::RegisterResetInterface.  Used
//      by AQ to set its IMailTransportRouterReset ptr.  Also used at shutdown
//      to set its pointer to NULL.
//  Parameters:
//      IN dwVirtualServerID        Virtual server ID
//      IN pIRouterReset            AQ's IMailTransportRouterReset
//  Returns:
//      S_OK on success
//  History:
//      11/8/98 - MikeSwa Created
//      1/9/99 - MikeSwa Modified to include IMailTransportRouterSetLinkState
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPServer::RegisterResetInterface(
                            IN DWORD dwVirtualServerID,
                            IN IMailTransportRouterReset *pIRouterReset)
{
    HRESULT hr = S_OK;

    _ASSERT(!m_pInstance || (m_pInstance->QueryInstanceId() == dwVirtualServerID));

    if (m_pInstance && (m_pInstance->QueryInstanceId() != dwVirtualServerID))
        return E_INVALIDARG;

    //Grab exclsuive lock so we don't release out from under anyone
    m_slRouterReset.ExclusiveLock();

    if (m_pIRouterReset)
        m_pIRouterReset->Release();

    if (m_pIRouterSetLinkState)
    {
        m_pIRouterSetLinkState->Release();
        m_pIRouterSetLinkState = NULL;
    }

    m_pIRouterReset = pIRouterReset;
    if (m_pIRouterReset)
    {
        m_pIRouterReset->AddRef();

        //Get new SetLinkState interface
        m_pIRouterReset->QueryInterface(IID_IMailTransportRouterSetLinkState,
                                            (VOID **) &m_pIRouterSetLinkState);
    }

    m_slRouterReset.ExclusiveUnlock();
    return S_OK;
}

STDMETHODIMP CSMTPServer::WriteLog( LPMSG_TRACK_INFO pMsgTrackInfo,
                                    IMailMsgProperties *pMsgProps,
                                    LPEVENT_LOG_INFO pEventLogInfo ,
                                    LPSTR pszProtocolLog )
{
    HRESULT hr = S_OK;

    if(m_pInstance)
    {
        m_pInstance->WriteLog( pMsgTrackInfo, pMsgProps, pEventLogInfo, pszProtocolLog );
    }

    return hr;
}

//---[ CSMTPServer::SetLinkState ]----------------------------------------------
//
//
//  Description:
//      Acts as a buffer between AQ and the routers.  On shutdown... AQ can
//      safely destroy it's heap by telling ISMTPServer to release its pointer
//      to AQ's IMailTransportRouterSetLinkState interface
//  Parameters:
//      IN  szLinkDomainName        The Domain Name of the link (next hop)
//      IN  guidRouterGUID          The GUID ID of the router
//      IN  dwScheduleID            The schedule ID link
//      IN  szConnectorName         The connector name given by the router
//      IN  dwSetLinkState          The link state to set
//      IN  dwUnsetLinkState        The link state to unset
//  Returns:
//      S_OK always
//  History:
//      1/9/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPServer::SetLinkState(
        IN LPSTR                   szLinkDomainName,
        IN GUID                    guidRouterGUID,
        IN DWORD                   dwScheduleID,
        IN LPSTR                   szConnectorName,
        IN DWORD                   dwSetLinkState,
        IN DWORD                   dwUnsetLinkState,
        IN FILETIME               *pftNextScheduled,
        IN IMessageRouter         *pMessageRouter)
{
    HRESULT hr = S_OK;
    m_slRouterReset.ShareLock();

    if (m_pIRouterSetLinkState)
        hr = m_pIRouterSetLinkState->SetLinkState(szLinkDomainName,
                                                  guidRouterGUID,
                                                  dwScheduleID,
                                                  szConnectorName,
                                                  dwSetLinkState,
                                                  dwUnsetLinkState,
                                                  pftNextScheduled,
                                                  pMessageRouter);

    m_slRouterReset.ShareUnlock();

    return hr;
}

STDMETHODIMP CSMTPServer::TriggerLogEvent(
        IN DWORD                    idMessage,
        IN WORD                     idCategory,
        IN WORD                     cSubstrings,
        IN LPCSTR                   *rgszSubstrings,
        IN WORD                     wType,
        IN DWORD                    errCode,
        IN WORD                     iDebugLevel,
        IN LPCSTR                   szKey,
        IN DWORD                    dwOptions,
        IN DWORD                    iMessageString,
        IN HMODULE                  hModule)
{
    HRESULT hr = S_OK;

    if(m_pInstance)
    {
        m_pInstance->TriggerLogEvent(
                        idMessage,
                        idCategory,
                        cSubstrings,
                        rgszSubstrings,
                        wType,
                        errCode,
                        iDebugLevel,
                        szKey,
                        dwOptions,
                        iMessageString,
                        hModule);
    }

    return hr;
}


//---[ CSMTPServer::ResetLogEvent ]------------------------------------------
//
//
//  Description:
//      Reset any history about events using this message and key,
//      so that the next TriggerLogEvent with one-time or periodic logging
//      will cause the event to be logged.
//  Parameters:
//      idMessage   :
//      szKey       :
//  Returns:
//      S_OK on success
//  History:
//      7/20/2000 - created, dbraun
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPServer::ResetLogEvent(
        IN DWORD                    idMessage,
        IN LPCSTR                   szKey)
{
    HRESULT hr = S_OK;

    if(m_pInstance)
    {
        m_pInstance->ResetLogEvent(
                        idMessage,
                        szKey);
    }

    return hr;
}


//---[ CSMTPServer::HrTriggerGetAuxDomainInfoFlagsEvent ]----------------------
//
//
//  Description:
//      Triggers the Get Aux Domain Info Flags event - this is to be used by aqueue to
//      query for additional domain info config stored outside the metabase
//  Parameters:
//      pszDomainName       : Name of domain to query flags for
//      pdwDomainInfoFlags  : DWORD to return domain flags
//  Returns:
//      S_OK on success
//      S_FALSE if no domain found
//  History:
//      10/6/2000 - created, dbraun
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPServer::HrTriggerGetAuxDomainInfoFlagsEvent(
        IN  LPCSTR  pszDomainName,
        OUT DWORD  *pdwDomainInfoFlags )
{
    HRESULT hr = S_OK;

    if(m_pInstance)
    {
        hr = m_pInstance->HrTriggerGetAuxDomainInfoFlagsEvent(
                        pszDomainName,
                        pdwDomainInfoFlags);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\smtpsvr.h ===
// SMTPServer.h : Declaration of the CSMTPServer

#ifndef __SMTPSERVER_H_
#define __SMTPSERVER_H_

#include "resource.h"       // main symbols
#include <smtpevent.h>

/////////////////////////////////////////////////////////////////////////////
// CSMTPServer
//class ATL_NO_VTABLE CSMTPServer :
class CSMTPServer :
	public ISupportErrorInfo,
    public ISMTPServerInternal,
    public IMailTransportRouterReset,
    public IMailTransportSetRouterReset,
    public IMailTransportRouterSetLinkState,
    public ISMTPServerEx,
    public ISMTPServerGetAuxDomainInfoFlags,
    public ISMTPServerAsync
{
public:
	CSMTPServer()
	{
		m_pInstance = NULL;
        m_pIRouterReset = NULL;
        m_pIRouterSetLinkState = NULL;
		m_ulRefCount = 0;
	}

	HRESULT Init(SMTP_SERVER_INSTANCE * pInstance);


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ISMTPServer
public:

	STDMETHOD(QueryInterface)(REFIID iid, void  **ppvObject);

	STDMETHOD_(ULONG, AddRef)(void) {return(InterlockedIncrement(&m_ulRefCount));};

	STDMETHOD_(ULONG, Release) (void)
	{
		LONG    lRefCount = InterlockedDecrement(&m_ulRefCount);
		if (lRefCount == 0)
		{
            delete this;
		}

		return(lRefCount);
	};

	STDMETHOD (AllocMessage)(
				IMailMsgProperties **ppMsg
				);

	STDMETHOD (SubmitMessage)(
				IMailMsgProperties *pMsg
				);

	STDMETHOD (TriggerLocalDelivery)(IMailMsgProperties *pMsg, DWORD dwRecipientCount, DWORD * pdwRecipIndexes);
    STDMETHOD (TriggerServerEvent)(DWORD dwEventID, PVOID pvContext);

	STDMETHOD (ReadMetabaseString)(DWORD MetabaseId, LPBYTE Buffer, DWORD * BufferSize, BOOL fSecure);

	STDMETHOD (ReadMetabaseDword)(DWORD MetabaseId, DWORD * dwValue);
	STDMETHOD (ServerStartHintFunction)();
	STDMETHOD (ServerStopHintFunction)();

    STDMETHOD (AllocBoundMessage)(OUT IMailMsgProperties **ppMsg, OUT PFIO_CONTEXT *phContent);
    STDMETHOD (WriteLog)(IN LPMSG_TRACK_INFO pMsgTrackInfo,
                         IN IMailMsgProperties *pMsg,
                         IN LPEVENT_LOG_INFO pEventLogInfo,
                         IN LPSTR pszProtocolLog );

    STDMETHOD (ReadMetabaseData)(IN DWORD MetabaseId,
                                 IN OUT BYTE * Buffer,
                                 IN OUT DWORD * BufferSize);


public: //IMailTransportRouterReset
    STDMETHOD (ResetRoutes)(IN DWORD dwResetType);

public: //IMailTransportSetRouterReset
    STDMETHOD (RegisterResetInterface)(IN DWORD dwVirtualServerID,
                                      IN IMailTransportRouterReset *pIRouterReset);
public: //IMailTransportRouterSetLinkState
    STDMETHOD(SetLinkState)(
        IN LPSTR                   szLinkDomainName,
        IN GUID                    guidRouterGUID,
        IN DWORD                   dwScheduleID,
        IN LPSTR                   szConnectorName,
        IN DWORD                   dwSetLinkState,
        IN DWORD                   dwUnsetLinkState,
        IN FILETIME                *pftNextScheduled,
        IN IMessageRouter          *pMessageRouter);

public: //ISMTPServerEx
    STDMETHOD(TriggerLogEvent)(
        IN DWORD                    idMessage,
        IN WORD                     idCategory,
        IN WORD                     cSubstrings,
        IN LPCSTR                   *rgszSubstrings,
        IN WORD                     wType,
        IN DWORD                    errCode,
        IN WORD                     iDebugLevel,
        IN LPCSTR                   szKey,
        IN DWORD                    dwOptions,
        IN DWORD                    iMessageString,
        IN HMODULE                  hModule);

    STDMETHOD(ResetLogEvent)(
        IN DWORD                    idMessage,
        IN LPCSTR                   szKey);

public: //ISMTPServerGetAuxDomainInfoFlags
    STDMETHOD(HrTriggerGetAuxDomainInfoFlagsEvent)(
        IN  LPCSTR  pszDomainName,
        OUT DWORD  *pdwDomainInfoFlags );

public: //ISMTPServerAsync
	STDMETHOD(TriggerLocalDeliveryAsync)(IMailMsgProperties *pMsg, 
                                         DWORD dwRecipientCount, 
                                         DWORD * pdwRecipIndexes,
                                         IMailMsgNotify *pNotify);

private:
	LONG m_ulRefCount;
	SMTP_SERVER_INSTANCE               *m_pInstance;
    IMailTransportRouterReset          *m_pIRouterReset;
    IMailTransportRouterSetLinkState   *m_pIRouterSetLinkState;
    CShareLockNH                        m_slRouterReset;

};

#endif //__SMTPSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "smtpinc.h"
#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__6D1C7805_EAEC_11D1_AA65_00C04FA35B82__INCLUDED_)
#define AFX_STDAFX_H__6D1C7805_EAEC_11D1_AA65_00C04FA35B82__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_APARTMENT_THREADED

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#define INCL_INETSRV_INCS
#include "atq.h"
#include "dbgtrace.h"

#define _ATL_NO_DEBUG_CRT
#define _ATL_STATIC_REGISTRY 1
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__6D1C7805_EAEC_11D1_AA65_00C04FA35B82__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\strcscmp.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    strcscmp.cxx

Abstract:

    This module implements case insensitive string comparison routines.

Author:

    Mike Massa (mikemas)           Sept 20, 1991

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     9-20-91     created

Notes:

    Exports:
        None

--*/

#include "smtpinc.h"

#ident "@(#)strcasecmp.c        5.3     3/8/91"

/******************************************************************
 *
 *  SpiderTCP BIND
 *
 *  Copyright 1990  Spider Systems Limited
 *
 *  STRCASECMP.C
 *
 ******************************************************************/

/*
 *       /usr/projects/tcp/SCCS.rel3/rel/src/lib/net/0/s.strcasecmp.c
 *      @(#)strcasecmp.c        5.3
 *
 *      Last delta created      14:12:01 3/4/91
 *      This file extracted     11:20:35 3/8/91
 *
 *      Modifications:
 *
 *              GSS     24 Jul 90       New File
 */
/*
 * Copyright (c) 1987 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "@(#)strcasecmp.c        5.7 (Berkeley) 2/7/89";
#endif /* LIBC_SCCS and not lint */
/**************************************************************************/

#include <winsock.h>
//#include "winsockp.h"

/*
 * This array is designed for mapping upper and lower case letter
 * together for a case independent comparison.  The mappings are
 * based upon ascii character sequences.
 */
static char charmap[] = {
        '\000', '\001', '\002', '\003', '\004', '\005', '\006', '\007',
        '\010', '\011', '\012', '\013', '\014', '\015', '\016', '\017',
        '\020', '\021', '\022', '\023', '\024', '\025', '\026', '\027',
        '\030', '\031', '\032', '\033', '\034', '\035', '\036', '\037',
        '\040', '\041', '\042', '\043', '\044', '\045', '\046', '\047',
        '\050', '\051', '\052', '\053', '\054', '\055', '\056', '\057',
        '\060', '\061', '\062', '\063', '\064', '\065', '\066', '\067',
        '\070', '\071', '\072', '\073', '\074', '\075', '\076', '\077',
        '\100', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
        '\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
        '\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
        '\170', '\171', '\172', '\133', '\134', '\135', '\136', '\137',
        '\140', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
        '\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
        '\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
        '\170', '\171', '\172', '\173', '\174', '\175', '\176', '\177',
        '\200', '\201', '\202', '\203', '\204', '\205', '\206', '\207',
        '\210', '\211', '\212', '\213', '\214', '\215', '\216', '\217',
        '\220', '\221', '\222', '\223', '\224', '\225', '\226', '\227',
        '\230', '\231', '\232', '\233', '\234', '\235', '\236', '\237',
        '\240', '\241', '\242', '\243', '\244', '\245', '\246', '\247',
        '\250', '\251', '\252', '\253', '\254', '\255', '\256', '\257',
        '\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267',
        '\270', '\271', '\272', '\273', '\274', '\275', '\276', '\277',
        '\300', '\301', '\302', '\303', '\304', '\305', '\306', '\307',
        '\310', '\311', '\312', '\313', '\314', '\315', '\316', '\317',
        '\320', '\321', '\322', '\323', '\324', '\325', '\326', '\327',
        '\330', '\331', '\332', '\333', '\334', '\335', '\336', '\337',
        '\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
        '\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
        '\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
        '\370', '\371', '\372', '\373', '\374', '\375', '\376', '\377',
};

int
strcasecmp(
    char *s1,
    char *s2
    )
{
        register char *cm = charmap,
                        *us1 = (char *)s1,
                        *us2 = (char *)s2;

        while (cm[*us1] == cm[*us2++])
                if (*us1++ == '\0')
                        return(0);
        return(cm[*us1] - cm[*--us2]);
}

int
strncasecmp(
    char *s1,
    char *s2,
    int   n
    )
{
        register char *cm = charmap,
                        *us1 = (char *)s1,
                        *us2 = (char *)s2;

        while (--n >= 0 && cm[*us1] == cm[*us2++])
                if (*us1++ == '\0')
                        return(0);
        return(n < 0 ? 0 : cm[*us1] - cm[*--us2]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\timeconv.h ===
/*-------------------------------------------------------------------------
  timeconv.h
  	Function prototypes for time conversion functions.
  

  Copyright (C) 1994  Microsoft Corporation.

  Author
  	Lindsay Harris	- lindsayh

  History
	14:08 on Wed 20 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	First version, now that there are 2 time functions!

  --------------------------------------------------------------------------*/

#if  !defined( _TIMECONV_H )

#define	_TIMECONV_H


const DWORD cMaxArpaDate = 28;
/*
 *  Generate an ARPA/Internet time format string for current time.
 *  You must pass in a buffer of type char [cMaxArpaDate]
 */

char  *
GetArpaDate( char rgBuf[ cMaxArpaDate ] );

//
// 12/21/98 -- pgopi
// Get System time & file time in string format.
//

void GetSysAndFileTimeAsString( char *achReturn );


#endif		// _TIMECONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpapi\smtpbind.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    srvbind.c

Abstract:

    Contains the RPC bind and un-bind routines for the Server
    Service.

Author:

    Dan Lafferty (danl)     01-Mar-1991

Environment:

    User Mode -Win32

Revision History


 Madan Appiah (madana) 10-Oct-1995 Created.
 Murali R. Krishnan (MuraliK)   15-Nov-1995   Remove Netp routines
 Murali R. Krishnan (MuraliK)   21-Nov-1995   Support TCP/IP binding
 Rohan Phillips   (rohanp)      26-Feb-1997   Moved from K2 tree for smtp

--*/

//
// INCLUDES
//

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <smtpinet.h>

#include <smtpsvc.h>
#include <inetinfo.h>
#include "apiutil.h"

handle_t
NNTP_IMPERSONATE_HANDLE_bind(
    SMTP_IMPERSONATE_HANDLE ServerName
    )

/*++

Routine Description:

    This routine is called from the inet info admin client stubs when
    it is necessary create an RPC binding to the server end with
    impersonation level of security

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindHandle;
    RPC_STATUS RpcStatus;

    RpcStatus = RpcBindHandleForServer(&BindHandle,
                                       ServerName,
                                       SMTP_INTERFACE_NAME,
                                       PROT_SEQ_NP_OPTIONS_W
                                       );


    return BindHandle;
} // SMTP_IMPERSONATE_HANDLE_bind()


handle_t
SMTP_HANDLE_bind (
    SMTP_HANDLE   ServerName)

/*++

Routine Description:
    This routine calls a common bind routine that is shared by all services.
    This routine is called from the server service client stubs when
    it is necessary to bind to a server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    handle_t    BindingHandle;
    RPC_STATUS  status;

    status = RpcBindHandleForServer(&BindingHandle,
                                   ServerName,
                                   SMTP_INTERFACE_NAME,
                                   PROT_SEQ_NP_OPTIONS_W
                                   );

    return( BindingHandle);
}


void
NNTP_IMPERSONATE_HANDLE_unbind(
    SMTP_IMPERSONATE_HANDLE ServerName,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by all services
    This routine is called from the inet admin client stubs when it is
    necessary to unbind from the server end.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);

    (VOID ) RpcBindHandleFree(&BindHandle);

    return;
} // SMTP_IMPERSONATE_HANDLE_unbind()


void
SMTP_HANDLE_unbind (
    SMTP_HANDLE   ServerName,
    handle_t        BindingHandle)

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.
    This routine is called from the server service client stubs when
    it is necessary to unbind to a server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
	UNREFERENCED_PARAMETER(ServerName);


	(VOID ) RpcBindHandleFree(&BindingHandle);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\svcstat.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    svcstat.cpp

Abstract:

    This module contains code for doing statistics rpcs

Author:

    Johnson Apacible (JohnsonA)     12-Nov-1995

Revision History:

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "smtpsvc.h"
#include "findiis.hxx"

extern PSMTP_STATISTICS_BLOCK_ARRAY GetServerPerfCounters(PSMTP_IIS_SERVICE pService);

VOID
ClearStatistics(
        VOID
        );

NET_API_STATUS
NET_API_FUNCTION
SmtprQueryStatistics(
    IN SMTP_HANDLE	pszServer,
    IN DWORD		Level,
    OUT LPSTAT_INFO	pBuffer
    )
{
    APIERR							err = 0;	
	PSMTP_IIS_SERVICE				pService = NULL;
	PLIST_ENTRY						pInfoList = NULL;
	PLIST_ENTRY						pEntry = NULL;
	DWORD							dwEntries = 0;
	DWORD							dwAlloc = 0;
	PSMTP_INSTANCE_LIST_ENTRY		pSmtpInfo = NULL;
	PSMTP_STATISTICS_BLOCK_ARRAY	pSmtpStatsBlockArray = NULL;
	PSMTP_STATISTICS_BLOCK			pStatsBlock = NULL;

    _ASSERT( pBuffer != NULL );
    UNREFERENCED_PARAMETER(pszServer);

	pService = (PSMTP_IIS_SERVICE) g_pInetSvc;
    //
    //  Check for proper access.
    //

    err = TsApiAccessCheck( TCP_QUERY_STATISTICS );

    if( err != NO_ERROR ) {
        return (NET_API_STATUS)err;
    }

	pService->AcquireServiceShareLock();
	
	if(g_IsShuttingDown)
	{
		pService->ReleaseServiceShareLock();
		return (NET_API_STATUS)ERROR_REQUEST_ABORTED;
	}

	//
	// get the information list.  Determine the # instances
	//

	if(pService->QueryCurrentServiceState() != SERVICE_RUNNING)
	{
		err = ERROR_REQUEST_ABORTED;
		goto error_exit;
	}


    pInfoList = pService->GetInfoList();
    if (IsListEmpty(pInfoList))
    {
       err = ERROR_INVALID_PARAMETER;
       goto error_exit;
    }
 //
    //  Return the proper statistics based on the infolevel.
    //

    switch( Level ) {

    case 0 : 
		dwEntries = 0;
		for (pEntry = pInfoList->Flink; pEntry != pInfoList; pEntry = pEntry->Flink)
		{
			dwEntries++;
		}

		if (dwEntries == 0)
		{
			err = ERROR_INVALID_PARAMETER;
			goto error_exit;
		}


		dwAlloc = sizeof(SMTP_STATISTICS_BLOCK_ARRAY) + dwEntries * sizeof(SMTP_STATISTICS_BLOCK);
		pSmtpStatsBlockArray = (PSMTP_STATISTICS_BLOCK_ARRAY)MIDL_user_allocate(dwAlloc);
		if (!pSmtpStatsBlockArray)
		{
			err = ERROR_NOT_ENOUGH_MEMORY;
			goto error_exit;
		}

		pSmtpStatsBlockArray->cEntries = dwEntries;
		pStatsBlock = pSmtpStatsBlockArray->aStatsBlock;
		for (pEntry = pInfoList->Flink; pEntry != pInfoList; pEntry = pEntry->Flink)
		{
			pSmtpInfo = (PSMTP_INSTANCE_LIST_ENTRY)
								CONTAINING_RECORD(pEntry,SMTP_INSTANCE_LIST_ENTRY,ListEntry);

			pStatsBlock->dwInstance = pSmtpInfo->dwInstanceId;

			pSmtpInfo->pSmtpServerStatsObj->CopyToStatsBuffer(&(pStatsBlock->Stats_0));
		
			pStatsBlock++;
		}

		pBuffer->StatInfo0 = pSmtpStatsBlockArray;
        
		break;

    default :
        err = ERROR_INVALID_LEVEL;
        break;
    }

error_exit:

	pBuffer->StatInfo0 = pSmtpStatsBlockArray;

	pService->ReleaseServiceShareLock();
    return (NET_API_STATUS)err;

}   // SmtprQueryStatistics

/*

NET_API_STATUS
NET_API_FUNCTION
SmtprQueryStatistics(
    IN SMTP_HANDLE pszServer,
    IN DWORD Level,
    IN LPSTAT_INFO pBuffer,
	IN DWORD dwInstance
    )
{
    APIERR err;
	PSMTP_IIS_SERVICE		pService;
	PSMTP_SERVER_INSTANCE pInstance;

    _ASSERT( pBuffer != NULL );
    UNREFERENCED_PARAMETER(pszServer);

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheck( TCP_QUERY_STATISTICS );

    if( err != NO_ERROR ) {
        return (NET_API_STATUS)err;
    }


	//
	// get a pointer to the global service
	//

	pService = (


	pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
	if(pInstance == NULL)
	{
		return((NET_API_STATUS) ERROR_INVALID_PARAMETER);
	}

    //
    //  Return the proper statistics based on the infolevel.
    //

    switch( Level ) {

    case 0 : 
		
		LPSMTP_STATISTICS_0 pstats0;

		if (!pInstance->GetStatistics(Level, (PCHAR*) &pstats0))
  		{
			err = GetLastError();	
		}
		else
		{			
			pBuffer->StatInfo0 = pstats0;
		}
        break;

    default :
        err = ERROR_INVALID_LEVEL;
        break;
    }

	pInstance->Dereference();
    return (NET_API_STATUS)err;

}   // SmtprQueryStatistics  */



NET_API_STATUS
NET_API_FUNCTION
SmtprClearStatistics(
    SMTP_HANDLE pszServer,
	IN DWORD dwInstance
    )
{
    APIERR err;
	PSMTP_SERVER_INSTANCE pInstance;

    UNREFERENCED_PARAMETER(pszServer);

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheck( TCP_CLEAR_STATISTICS );
    if( err != NO_ERROR ) {
        return (NET_API_STATUS)err;
    }

	pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
	if(pInstance == NULL)
	{
		return((NET_API_STATUS) ERROR_INVALID_PARAMETER);
	}

    //
    //  Clear the statistics.
    //

    pInstance->ClearStatistics();

	pInstance->Dereference();
    return (NET_API_STATUS)err;

}   // SmtprClearStatistics

VOID
ClearStatistics(
        VOID
        )
{

    return;

} // ClearStatistics
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\server\timeconv.cxx ===
/* --------------------------------------------------------------------------
	timeconv.cpp
		Functions to perform various time conversion operations.
	
	Copyright (C) 1994, Microsoft Corporation.
	All rights reserved.

	Author:
		Lindsay Harris - lindsayh

   -------------------------------------------------------------------------- */

#include "smtpinc.h"
#include <time.h>
#include <string.h>
#include <dbgtrace.h>
#include "timeconv.h"

/*
 *   A handcrafted time zone string to GMT offsets table.  This is not
 *  a very good way to handle this.
 */

static  struct
{
	int		iTZOffset;		// Arithmetic offset from GMT, in seconds.
	char    rgchTZName[ 4 ];	// String representation of time zone.
} _TZ_NAME[] =
{
	{ 0, 		{ 'G', 'M', 'T', '\0' } },
	{ 0, 		{ 'U', 'T', 'C', '\0' } },
	{ 0, 		{ 'U', 'T', '\0', '\0' } },
	{ -14400,	{ 'E', 'D', 'T', '\0' } },
	{ -18000,	{ 'E', 'S', 'T', '\0' } },
	{ -18000,	{ 'C', 'D', 'T', '\0' } },
	{ -21600,	{ 'C', 'S', 'T', '\0' } },
	{ -21600,	{ 'M', 'D', 'T', '\0' } },
	{ -25200,	{ 'M', 'S', 'T', '\0' } },
	{ -25200,	{ 'P', 'D', 'T', '\0' } },
	{ -28800,	{ 'P', 'S', 'T', '\0' } },
	{  43200,	{ 'N', 'Z', 'S', '\0' } },	// NZ standard time.
	{  46800,	{ 'N', 'Z', 'D', '\0' } },
};

#define	NUM_TZ	(sizeof( _TZ_NAME ) / sizeof( _TZ_NAME[ 0 ] ))

// The date Jan 1, 1970 00:00:00 in type FILETIME
#define	ft1970high 27111902
#define	ft1970low 3577643008

static FILETIME ft1970 = {ft1970low, ft1970high};


// The number of FILETIME units (100's of nanoseconds) in a time_t unit (seconds)
#define dFiletimePerDTime_t 10000000

/*
 *   English language month table.
 */

static  char  *rgchMonth[ 12 ] =
{
	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
};

/* -----------------------------------------------------------------------
  GetSysAndFileTimeAsString --s tring should be atleast 64 bytes

   ----------------------------------------------------------------------- */

void GetSysAndFileTimeAsString( char *achReturn )
{

	SYSTEMTIME	stUTC;						// The current time in UTC/GMT

	GetSystemTime( &stUTC );

    FILETIME ft;

	// Convert from SYSTEMTIME to FILETIME
	SystemTimeToFileTime(&stUTC, &ft);

	/*
	 *    No major trickery here.  We have all the data, so simply
	 *  format it according to the rules on how to do this.
	 */

	wsprintf( achReturn, "%02d %s %04d %02d:%02d:%02d.%04d (UTC) FILETIME=[%08X:%08X]",
			  stUTC.wDay,
			  rgchMonth[ stUTC.wMonth - 1 ],
			  stUTC.wYear,
			  stUTC.wHour,
			  stUTC.wMinute,
			  stUTC.wSecond,
			  stUTC.wMilliseconds,
              ft.dwLowDateTime,
              ft.dwHighDateTime);
}

/* -----------------------------------------------------------------------
  GetArpaDate
  	Returns a pointer to static memory containing the current date in
  	Internet/ARPA standard format.

  Author
 	Lindsay Harris	- lindasyh

  History
	13:49 on Wed 20 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	First version.
	Imported to Tigris. Added passed-in buffer, changed year to 4-digit format

   ----------------------------------------------------------------------- */


char  *
GetArpaDate( char achReturn[ cMaxArpaDate ] )
{

	char    chSign;							// Sign to print.

	DWORD   dwResult;

	int		iBias;							// Offset relative to GMT.

	TIME_ZONE_INFORMATION	tzi;			// Local time zone data.

	SYSTEMTIME	stUTC;						// The current time in UTC/GMT



	dwResult = GetTimeZoneInformation( &tzi );
	GetLocalTime( &stUTC );

	//  Calculate the time zone offset.
	iBias = tzi.Bias;
	if( dwResult == TIME_ZONE_ID_DAYLIGHT )
		iBias += tzi.DaylightBias;
	
	/*
	 *   We always want to print the sign for the time zone offset, so
	 *  we decide what it is now and remember that when converting.
	 *  The convention is that west of the 0 degree meridian has a
	 *  negative offset - i.e. add the offset to GMT to get local time.
	 */

	if( iBias > 0 )
	{
		chSign = '-';		// Yes, I do mean negative.
	}
	else
	{
		iBias = -iBias;
		chSign = '+';
	}

	/*
	 *    No major trickery here.  We have all the data, so simply
	 *  format it according to the rules on how to do this.
	 */

	_snprintf( achReturn, cMaxArpaDate , "%d %s %04d %02d:%02d:%02d %c%02d%02d",
			stUTC.wDay, rgchMonth[ stUTC.wMonth - 1 ],
			stUTC.wYear,
			stUTC.wHour, stUTC.wMinute, stUTC.wSecond, chSign,
			(iBias / 60) % 100, iBias % 60 );

	return achReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpapi\rpcutil.c ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      rpcutil.c

   Abstract:

      This module defines functions that may help to replace the rpc util
        functions from rpcutil.lib

   Author:

       Murali R. Krishnan    ( MuraliK )     15-Sept-1995

   Environment:
       Win32 User Mode

   Project:

       Common Code for Internet Services

   Functions Exported:

        MIDL_user_allocate()
        MIDL_user_free()
        RpcBindHandleForServer()
        RpcBindHandleFree()

   Revision History:

        Murali R. Krishnan (MuraliK) 21-Dec-1995  Support TcpIp binding & free.
        Murali R. Krishnan (MuraliK) 20-Feb-1996  Support Lpc binding & free.

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>
# include <rpc.h>

# include "apiutil.h"

# if DBG

# include <stdio.h>
# include <stdlib.h>

# define DBGPRINTF(s)       { CHAR rgchBuff[1024]; \
                              sprintf s ; \
                              OutputDebugStringA( rgchBuff); \
                            }
# define DBG_CONTEXT        ( rgchBuff)


# else // DBG


# define DBGPRINTF(s)     /* nothing */
# define DBG_CONTEXT      /* nothing */

# endif // DBG

#define ISRPC_CLIENT_OVER_TCPIP          0x00000001
#define ISRPC_CLIENT_OVER_NP             0x00000002
#define ISRPC_CLIENT_OVER_SPX            0x00000004
#define ISRPC_CLIENT_OVER_LPC            0x00000008

// # define MAX_COMPUTERNAME_LENGTH    (255)


/************************************************************
 *    Functions
 ************************************************************/


PVOID
MIDL_user_allocate(IN size_t size)
/*++

Routine Description:

    MIDL memory allocation.

Arguments:

    size : Memory size requested.

Return Value:

    Pointer to the allocated memory block.

--*/
{
    PVOID pvBlob;

    pvBlob = LocalAlloc( LPTR, size);

    return( pvBlob );

} // MIDL_user_allocate()




VOID
MIDL_user_free(IN PVOID pvBlob)
/*++

Routine Description:

    MIDL memory free .

Arguments:

    pvBlob : Pointer to a memory block that is freed.


Return Value:

    None.

--*/
{
    LocalFree( pvBlob);

    return;
}  // MIDL_user_free()




RPC_STATUS
RpcBindHandleOverNamedPipe( OUT handle_t * pBindingHandle,
                           IN LPWSTR      pwszServerName,
                           IN LPWSTR      pwszEndpoint,
                           IN LPWSTR      pwszOptions
                          )
/*++
  This function uses the parameters supplied and generates a named pipe
   binding handle for RPC.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszEndpoint     pointer to string containing the Named Pipe Endpoint
   pwszOptions      pointer to string containing any additional options for
                       binding.


  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPWSTR     pwszBinding = NULL;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingComposeW(0,            // ObjUuid
                                         L"ncacn_np",  // prot seq: named pipe
                                         pwszServerName, // NetworkAddr
                                         pwszEndpoint, // Endpoint
                                         pwszOptions,  // Options
                                         &pwszBinding);    // StringBinding

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBindingW(pwszBinding,
                                                 pBindingHandle );
    }


    //
    // Cleanup and return back.
    //

    if ( pwszBinding != NULL) {
        RpcStringFreeW(&pwszBinding);
    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            RpcBindingFree(*pBindingHandle);
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverNamedPipe()

RPC_STATUS
RpcBindHandleOverLpc( OUT handle_t * pBindingHandle,
                      IN LPWSTR      pwszEndpoint,
                      IN LPWSTR      pwszOptions
                     )
/*++
  This function uses the parameters supplied and generates a lpc
   binding handle for RPC.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszEndpoint     pointer to string containing the lpc Endpoint
   pwszOptions      pointer to string containing any additional options for
                       binding.


  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPWSTR     pwszBinding = NULL;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingComposeW(0,            // ObjUuid
                                         L"ncalrpc",   // prot seq: lpc
                                         NULL,         // NetworkAddr
                                         pwszEndpoint, // Endpoint
                                         pwszOptions,  // Options
                                         &pwszBinding);    // StringBinding

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBindingW(pwszBinding,
                                                 pBindingHandle );
    }


    //
    // Cleanup and return back.
    //

    if ( pwszBinding != NULL) {
        RpcStringFreeW(&pwszBinding);
    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            RpcBindingFree(*pBindingHandle);
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverLpc()




#ifndef CHICAGO

//
// If changes are made to the NT version, check out the windows 95
// version located right after this routine and see if the change
// needs to be propagated there too.
//

RPC_STATUS
RpcBindHandleOverTcpIp( OUT handle_t * pBindingHandle,
                       IN LPWSTR       pwszServerName,
                       IN LPWSTR       pwszInterfaceName
                       )
/*++

    NT Version

  This function uses the parameters supplied and generates a dynamic end point
     binding handle for RPC over TCP/IP.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszInterfaceName pointer to string containing the interface name

  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPWSTR     pwszBinding = NULL;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingComposeW(0,               // ObjUuid
                                         L"ncacn_ip_tcp", // tcpip seq
                                         pwszServerName,  // NetworkAddr
                                         NULL,            // Endpoint
                                         L"",             // Options
                                         &pwszBinding);   // StringBinding

    DBGPRINTF( (DBG_CONTEXT, "\nRpcStringBindingComposeW(%S, %S) return %S."
                " Error = %ld\n",
                L"ncacn_ip_tcp",
                pwszServerName,
                pwszBinding,
                rpcStatus)
              );

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBindingW(pwszBinding,
                                                 pBindingHandle );

        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingFromStringBindingW(%S) return %d."
                    "Binding=%p\n",
                    pwszBinding,
                    rpcStatus,
                    *pBindingHandle)
                  );
    }

    if ( rpcStatus == RPC_S_OK) {

        //
        // set up the security information
        //

        rpcStatus =
          RpcBindingSetAuthInfoW(*pBindingHandle,
                                 pwszInterfaceName,   // pszPrincipalName
                                 RPC_C_AUTHN_LEVEL_CONNECT,
                                 RPC_C_AUTHN_WINNT,
                                 NULL,                // AuthnIdentity
                                 0                    // AuthzSvc
                                 );
        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingSetAuthInfo(%S(Interface=%S), %p)"
                    " return %d.\n",
                    pwszBinding,
                    pwszInterfaceName,
                    *pBindingHandle,
                    rpcStatus
                    )
                  );

    }

    //
    // Cleanup and return back.
    //

    if ( pwszBinding != NULL) {

        DWORD rpcStatus1 = RpcStringFreeW(&pwszBinding);
        DBGPRINTF( (DBG_CONTEXT, "RpcStringFreeW() returns %d.",
                    rpcStatus1)
                  );

    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            DWORD rpcStatus1 = RpcBindingFree(*pBindingHandle);
            DBGPRINTF( (DBG_CONTEXT, "RpcBindingFree() returns %d.\n",
                        rpcStatus1)
                      );
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverTcpIp()

#else // CHICAGO



RPC_STATUS
RpcBindHandleOverTcpIp( OUT handle_t * pBindingHandle,
                       IN LPWSTR       pwszServerName,
                       IN LPWSTR       pwszInterfaceName
                       )
/*++

    Windows 95 version

  This function uses the parameters supplied and generates a dynamic end point
     binding handle for RPC over TCP/IP.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszInterfaceName pointer to string containing the interface name

  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPSTR     pszBindingA = NULL;
    CHAR    szServerA[MAX_PATH];
    CHAR    szInterfaceA[MAX_PATH];
    int        cch;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    *szServerA = '0';

    if (pwszServerName)
    cch = WideCharToMultiByte(CP_ACP,
                              0,
                              pwszServerName,
                              -1,
                              szServerA,
                              sizeof(szServerA)/sizeof(CHAR),
                              NULL,NULL
                              );

    *szInterfaceA = '0';

    if(pwszInterfaceName)
    cch = WideCharToMultiByte(CP_ACP,
                              0,
                              pwszInterfaceName,
                              -1,
                              szInterfaceA,
                              sizeof(szInterfaceA)/sizeof(CHAR),
                              NULL,NULL
                              );


    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingCompose(0,            // ObjUuid
                                         "ncacn_ip_tcp", // tcpip seq
                                         szServerA, // NetworkAddr
                                         NULL, // Endpoint
                                         NULL, //L"",  // Options
                                         &pszBindingA);    // StringBinding

    DBGPRINTF( (DBG_CONTEXT, "\nRpcStringBindingCompose(%s, %s) return %s."
                " Error = %ld\n",
                "ncacn_ip_tcp",
                szServerA,
                pszBindingA,
                rpcStatus)
              );

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBinding(pszBindingA,
                                                 pBindingHandle );

        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingFromStringBinding(%s) return %d."
                    "Binding=%08x\n",
                    pszBindingA,
                    rpcStatus,
                    *pBindingHandle)
                  );
    }

    if ( rpcStatus == RPC_S_OK) {

        //
        // set up the security information
        //

        rpcStatus =
          RpcBindingSetAuthInfo(*pBindingHandle,
                                 szInterfaceA,   // pszPrincipalName
                                 RPC_C_AUTHN_LEVEL_CONNECT,
                                 RPC_C_AUTHN_WINNT,
                                 NULL,  // AuthnIdentity
                                 0      // AuthzSvc
                                 );
        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingSetAuthInfo(%s(Interface=%s), %08x)"
                    " return %d.\n",
                    pszBindingA,
                    szInterfaceA,
                    *pBindingHandle,
                    rpcStatus
                    )
                  );

    }

    //
    // Cleanup and return back.
    //

    if ( pszBindingA != NULL) {

        DWORD rpcStatus1 = RpcStringFree(&pszBindingA);
        DBGPRINTF( (DBG_CONTEXT, "RpcStringFreeW() returns %d.",
                    rpcStatus1)
                  );

    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            DWORD rpcStatus1 = RpcBindingFree(*pBindingHandle);
            DBGPRINTF( (DBG_CONTEXT, "RpcBindingFree() returns %d.\n",
                        rpcStatus1)
                      );
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverTcpIp()
#endif



#ifndef CHICAGO
DWORD
RpcuFindProtocolToUse( IN LPCWSTR pwszServerName)
/*++
  Given the server name this funciton determines the protocol
  to use for RPC binding.

  The transport used is determined dynamically based on following rules.

  If server name is NULL or 127.0.0.1 or same as local computer name
      then use the LPC.

  If server name starts with a leading "\\" (double slash),
      then attempt RPC binding over NamedPipe.

  If server name does not start with leading "\\",
      then attempt RPC binding over TCPIP.

  If TCPIP binding fails, then this function tries binding over NamedPipe.


  Argument:
    pwszServerName - pointer to string containing the name of the server


  Returns:
    DWORD containing the type of protocol to use.

--*/
{
    static WCHAR g_wchLocalMachineName[ MAX_COMPUTERNAME_LENGTH + 1];
    BOOL   fLeadingSlashes;
    DWORD  dwBindProtocol = ISRPC_CLIENT_OVER_NP;
    BOOL   fLocalMachine;

    if ( pwszServerName == NULL ||
         _wcsicmp( L"127.0.0.1", pwszServerName) == 0) {


        return (ISRPC_CLIENT_OVER_LPC);
    }

    if ( g_wchLocalMachineName[0] == L'\0') {

        DWORD cchComputerNameLen = MAX_COMPUTERNAME_LENGTH;

        //
        // Obtain the local computer name
        //

        if (!GetComputerNameW( g_wchLocalMachineName,
                              &cchComputerNameLen)
            ) {

            *g_wchLocalMachineName = L'\0';
        }
    }

    fLeadingSlashes = ((*pwszServerName == L'\\') &&
                       (*(pwszServerName+1) == L'\\')
                       );


    //
    // Check to see if machine name matches local computer name
    //  if so, use LPC
    //

    fLocalMachine = !_wcsicmp( g_wchLocalMachineName,
                              ((fLeadingSlashes) ?
                               (pwszServerName + 2) : pwszServerName)
                              );

    if ( fLocalMachine) {

        return (ISRPC_CLIENT_OVER_LPC);
    }

    if ( !fLeadingSlashes) {

        DWORD  nDots;
        LPCWSTR pszName;

        //
        // Check if the name has dotted decimal name.
        // If so then suggest TCP binding.
        //

        for( nDots = 0, pszName = pwszServerName;
            ((pszName = wcschr( pszName, L'.' )) != NULL);
            nDots++, pszName++)
          ;

        if ( nDots == 3) {

            //
            // if the string has 3 DOTs exactly then this string must represent
            // an IpAddress.
            //

            return(ISRPC_CLIENT_OVER_TCPIP);
        }
    }


    return ( ISRPC_CLIENT_OVER_NP);
} // RpcuFindProtocolToUse()
#endif



RPC_STATUS
RpcBindHandleForServer( OUT handle_t * pBindingHandle,
                       IN LPWSTR      pwszServerName,
                       IN LPWSTR      pwszInterfaceName,
                       IN LPWSTR      pwszOptions
                       )
/*++
  This function uses the parameters supplied and generates a binding
    handle for RPC.


  It is assumed that binding over named pipe uses static end point
      with the interface name and options as provided.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszInterfaceName pointer to string containing the interface name
   pwszOptions      pointer to string containing any additional options for
                       binding.

  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus = RPC_S_SERVER_UNAVAILABLE;
    LPWSTR     pwszBinding = NULL;
    DWORD      dwBindProtocol = 0;


    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

#ifndef CHICAGO
    dwBindProtocol = RpcuFindProtocolToUse( pwszServerName);
#else
    dwBindProtocol = ISRPC_CLIENT_OVER_TCPIP;
#endif

    switch ( dwBindProtocol) {

      case ISRPC_CLIENT_OVER_LPC:
        {

            WCHAR  rgchLpc[1024];

            //
            // generate a LPC end point name from the interface name.
            //  the End point =   <InterfaceName>_LPC
            //

            if ( lstrlenW( pwszInterfaceName) >=
                ( sizeof(rgchLpc)/sizeof(WCHAR) - 6)) {

                SetLastError( ERROR_INVALID_PARAMETER);
                return ( ERROR_INVALID_PARAMETER);
            }

            lstrcpyW( rgchLpc, pwszInterfaceName);
            lstrcatW( rgchLpc, L"_LPC");

            //
            // Attempt binding over static LPC.
            //

            rpcStatus = RpcBindHandleOverLpc( pBindingHandle,
                                             rgchLpc,
                                             pwszOptions
                                             );

            DBGPRINTF(( DBG_CONTEXT,
                       " RpcBindingOverLpc(%S) returns %d."
                       " Handle = %p\n",
                       pwszServerName, rpcStatus, *pBindingHandle));

            break;
        }

      case ISRPC_CLIENT_OVER_TCPIP:

// # ifdef RPC_BIND_OVER_TCP

        //
        // Attempt binding over TCPIP using Dynamic Endpoint.
        //

        rpcStatus = RpcBindHandleOverTcpIp( pBindingHandle,
                                           pwszServerName,
                                           pwszInterfaceName);

        DBGPRINTF(( DBG_CONTEXT,
                   " RpcBindingOverTcpIp(%S) returns %d. Handle = %p\n",
                   pwszServerName, rpcStatus, *pBindingHandle));

        if ( rpcStatus == RPC_S_OK) {

            break;  // done with RPC binding over TCP
        }

        // Fall Through

// # endif // RPC_BIND_OVER_TCP

      case ISRPC_CLIENT_OVER_NP:
        {
            WCHAR  rgchNp[1024];

            //
            // generate a NamedPipe end point name from the interface name.
            //  the End point =   \PIPE\<InterfaceName>
            //

            lstrcpyW( rgchNp, L"\\PIPE\\");
            if ( lstrlenW( pwszInterfaceName) >=
                ( sizeof(rgchNp)/sizeof(WCHAR) - 10)) {

                SetLastError( ERROR_INVALID_PARAMETER);
                return ( ERROR_INVALID_PARAMETER);
            }

            lstrcatW( rgchNp, pwszInterfaceName);

            //
            // Attempt binding over static NamedPipe.
            //

            rpcStatus = RpcBindHandleOverNamedPipe( pBindingHandle,
                                                   pwszServerName,
                                                   rgchNp,
                                                   pwszOptions
                                                   );

            DBGPRINTF(( DBG_CONTEXT,
                       " RpcBindingOverNamedPipe(%S) returns %d."
                       " Handle = %p\n",
                       pwszServerName, rpcStatus, *pBindingHandle));
            break;
        }

      default:
        break;

    } // switch()

    return ( rpcStatus);

} // RpcBindHandleForServer()





RPC_STATUS
RpcBindHandleFree(IN OUT handle_t * pBindingHandle)
/*++

  Description:

    This function frees up the binding handle allocated using
      RpcBindHandleForServer(). It uses RPC Binding Free routing to do this.
    This function acts just as a thunk so that the alloc/free of RPC contexts
      are consolidated within this module.

  Arguments:
    pBindingHandle  pointer to RPC binding handle that needs to be freed.


  Returns:
    RPC_STATUS - containig the RPC status. RPC_S_OK for success.

--*/
{

    return ( RpcBindingFree( pBindingHandle));

} // RpcBindHandleFree()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpapi\smtpstub.c ===
/*++

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    SmtpStub.C

Abstract:

    These are the smtp service API RPC client stubs.

Author:

    Johnson Apacible (johnsona)     17-Oct-1995
        template used srvstub.c (Dan Lafferty)

Environment:

    User Mode - Win32

Revision History:

--*/

//
// INCLUDES
//

#include <windows.h>
#include <apiutil.h>
#include <lmcons.h>     // NET_API_STATUS
#include <inetinfo.h>
#include <smtpapi.h>
#include <smtpsvc.h>


NET_API_STATUS
NET_API_FUNCTION
SmtpQueryStatistics(
    IN  LPWSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr
    )
/*++

Routine Description:

    This is the DLL entrypoint for SmtpGetStatistics

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    level --Level of information required. 100, 101 and 102 are valid
        for all platforms. 302, 402, 403, 502 are valid for the
        appropriate platform.

    bufptr --On return a pointer to the return information structure
        is returned in the address pointed to by bufptr.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    *bufptr = NULL;     // Must be NULL so RPC knows to fill it in.

    RpcTryExcept

       apiStatus = SmtprQueryStatistics(
                servername,
                level,
                (LPSTAT_INFO) bufptr);

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // SmtpQueryStatistics

NET_API_STATUS
NET_API_FUNCTION
SmtpClearStatistics(
    IN LPWSTR Server OPTIONAL,  IN DWORD dwInstance)
{
    NET_API_STATUS status;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        status = SmtpClearStatistics(
                     Server, dwInstance
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);

} // SmtpClearStatistics

NET_API_STATUS
NET_API_FUNCTION
SmtpGetAdminInformation(
    IN  LPWSTR                  pszServer OPTIONAL,
    OUT LPSMTP_CONFIG_INFO *    ppConfig,
    IN DWORD            dwInstance

    )
/*++

Routine Description:

    This is the DLL entrypoint for SmtpGetAdminInformation

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    ppConfig --Configuration information returned from the server.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    *ppConfig = NULL;     // Must be NULL so RPC knows to fill it in.

    RpcTryExcept

       apiStatus = SmtprGetAdminInformation(
                pszServer,
                (LPSMTP_CONFIG_INFO *) ppConfig,
                dwInstance);

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // SmtpGetAdminInformation


NET_API_STATUS
NET_API_FUNCTION
SmtpSetAdminInformation(
    IN  LPWSTR                  pszServer OPTIONAL,
    IN  LPSMTP_CONFIG_INFO      pConfig,
    IN DWORD            dwInstance

    )
/*++

Routine Description:

    This is the DLL entrypoint for SmtpSetAdminInformation

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    pConfig --Configuration information to be set on the server.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    RpcTryExcept

       apiStatus = SmtprSetAdminInformation(
                pszServer,
                (LPSMTP_CONFIG_INFO) pConfig,
                dwInstance);

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // SmtpSetAdminInformation



/*++

Routine Description:

    SmtpGetConnectedUserList

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpGetConnectedUserList(
    IN  LPWSTR wszServerName,
    OUT LPSMTP_CONN_USER_LIST *ppConnUserList,
    IN DWORD            dwInstance

    )
{
    NET_API_STATUS apiStatus;

    *ppConnUserList = NULL;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprGetConnectedUserList(
                     wszServerName,
                     ppConnUserList,
                     dwInstance
                     );
    }
    RpcExcept (1) {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}



/*++

Routine Description:

    SmtpDisconnectUser

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpDisconnectUser(
    IN LPWSTR wszServerName,
    IN DWORD dwUserId,
    IN DWORD dwInstance

    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprDisconnectUser(
                     wszServerName,
                     dwUserId,
                     dwInstance
                     );
    }
    RpcExcept (1) {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}



/*++

Routine Description:

    SmtpCreateUser

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpCreateUser(
    IN LPWSTR   wszServerName,
    IN LPWSTR   wszEmail,
    IN LPWSTR   wszForwardEmail,
    IN DWORD    dwLocal,
    IN DWORD    dwMailboxSize,
    IN DWORD    dwMailboxMessageSize,
    IN LPWSTR   wszVRoot,
    IN DWORD    dwInstance

    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprCreateUser(
                     wszServerName,
                     wszEmail,
                     wszForwardEmail,
                     dwLocal,
                     dwMailboxSize,
                     dwMailboxMessageSize,
                     wszVRoot,
                     dwInstance
                     );
    }
    RpcExcept (1) {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}

/*++

Routine Description:

    SmtpDeleteUser

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpDeleteUser(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    IN  DWORD dwInstance

    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprDeleteUser(
                     wszServerName,
                     wszEmail,
                     dwInstance
                     );
    }
    RpcExcept (1) {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}

/*++

Routine Description:

    SmtpGetUserProps

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpGetUserProps(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    OUT LPSMTP_USER_PROPS *ppUserProps,
    IN  DWORD dwInstance

    )
{
    NET_API_STATUS apiStatus;

    *ppUserProps = NULL;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprGetUserProps(
                     wszServerName,
                     wszEmail,
                     ppUserProps,
                     dwInstance
                     );
    }
    RpcExcept (1) {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}

/*++

Routine Description:

    SmtpSetUserProps

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpSetUserProps(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    IN LPSMTP_USER_PROPS pUserProps,
    IN DWORD    dwInstance

    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprSetUserProps(
                     wszServerName,
                     wszEmail,
                     pUserProps,
                     dwInstance
                     );
    }
    RpcExcept (1) {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}


/*++

Routine Description:

    SmtpCreateDistList

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpCreateDistList(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    IN DWORD dwType,
    IN DWORD dwInstance

    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprCreateDistList(
                     wszServerName,
                     wszEmail,
                     dwType,
                     dwInstance
                     );
    }
    RpcExcept (1) {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}

/*++

Routine Description:

    SmtpDeleteDistList

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpDeleteDistList(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    IN DWORD dwInstance
    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprDeleteDistList(
                     wszServerName,
                     wszEmail,
                     dwInstance
                     );
    }
    RpcExcept (1) {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}


/*++

Routine Description:

    SmtpCreateDistListMember

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpCreateDistListMember(
    IN LPWSTR   wszServerName,
    IN LPWSTR   wszEmail,
    IN LPWSTR   wszEmailMember,
    IN DWORD    dwInstance

    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprCreateDistListMember(
                     wszServerName,
                     wszEmail,
                     wszEmailMember,
                     dwInstance
                     );
    }
    RpcExcept (1) {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}

/*++

Routine Description:

    SmtpDeleteDistListMember

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpDeleteDistListMember(
    IN LPWSTR   wszServerName,
    IN LPWSTR   wszEmail,
    IN LPWSTR   wszEmailMember,
    IN  DWORD   dwInstance

    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprDeleteDistListMember(
                     wszServerName,
                     wszEmail,
                     wszEmailMember,
                     dwInstance
                     );
    }
    RpcExcept (1) {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}


/*++

Routine Description:

    SmtpGetNameList

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpGetNameList(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    IN DWORD dwType,
    IN DWORD dwRowsRequested,
    IN BOOL fForward,
    OUT LPSMTP_NAME_LIST *ppNameList,
    IN  DWORD   dwInstance

    )
{
    NET_API_STATUS apiStatus;

    // Make sure RPC knows we want them to fill it in
    *ppNameList = NULL;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprGetNameList(
                     wszServerName,
                     wszEmail,
                     dwType,
                     dwRowsRequested,
                     fForward,
                     ppNameList,
                     dwInstance
                     );
    }
    RpcExcept (1) {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}



/*++

Routine Description:

    SmtpGetNameListFromList

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpGetNameListFromList(
    IN  LPWSTR              wszServerName,
    IN  LPWSTR              wszEmailList,
    IN  LPWSTR              wszEmail,
    IN  DWORD               dwType,
    IN  DWORD               dwRowsRequested,
    IN  BOOL                fForward,
    OUT LPSMTP_NAME_LIST    *ppNameList,
    IN  DWORD               dwInstance

    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprGetNameListFromList(
                     wszServerName,
                     wszEmailList,
                     wszEmail,
                     dwType,
                     dwRowsRequested,
                     fForward,
                     ppNameList,
                     dwInstance
                     );
    }
    RpcExcept (1) {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}

/*++

Routine Description:

    SmtpGetVRootSize

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpGetVRootSize(
    IN  LPWSTR      wszServerName,
    IN  LPWSTR      wszVRoot,
    IN  LPDWORD     pdwBytes,
    IN  DWORD       dwInstance

    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprGetVRootSize(
                     wszServerName,
                     wszVRoot,
                     pdwBytes,
                     dwInstance
                     );
    }
    RpcExcept (1) {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}

/*++

Routine Description:

    SmtpBackupRoutingTable

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpBackupRoutingTable(
    IN  LPWSTR      wszServerName,
    IN  LPWSTR      wszPath,
    IN  DWORD       dwInstance

    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprBackupRoutingTable(
                     wszServerName,
                     wszPath,
                     dwInstance
                     );
    }
    RpcExcept (1) {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpapi\smtpsubs.c ===
/*++

Copyright (c) 1990-1992  Microsoft Corporation

Module Name:

    smtpsubs.c

Abstract:

    Subroutines for LAN Manager APIs.

Author:

    Dan Hinsley (DanHi) 23-Mar-93

Revision History:

--*/

// These must be included first:
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define NOMINMAX                // Avoid stdlib.h vs. windows.h warnings.
#include <windows.h>
#include <apiutil.h>


BOOLEAN
SmtpInitialize (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN LPVOID lpReserved OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(DllHandle);          // avoid compiler warnings


    //
    // Handle attaching smtpsvc.dll to a new process.
    //

    if (Reason == DLL_PROCESS_ATTACH) {

#if 0
        //
        // Initialize RPC Bind Cache
        //

        NetpInitRpcBindCache();
#endif


    //
    // When DLL_PROCESS_DETACH and lpReserved is NULL, then a FreeLibrary
    // call is being made.  If lpReserved is Non-NULL, then ExitProcess is
    // in progress.  These cleanup routines will only be called when
    // a FreeLibrary is being called.  ExitProcess will automatically
    // clean up all process resources, handles, and pending io.
    //
    } else if ((Reason == DLL_PROCESS_DETACH) &&
               (lpReserved == NULL)) {

#if 0
        NetpCloseRpcBindCache();
#endif

    }

    return TRUE;

} // SmtpInitialize
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpctrs\perfutil.h ===
//#---------------------------------------------------------------
//  File:		perfutil.h
//
//  Synopsis:	This file supports routines used to parse and
//				create Performance Monitor Data Structures.
//				It actually supports Performance Object types with
//				multiple instances
//
//	Copyright (C) 1995 Microsoft Corporation
//	All rights reserved.
//
//  Authors:	rkamicar - based on msn sources by Russ Blake
//----------------------------------------------------------------

#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

// enable this define to log process heap data to the event log
#ifdef PROBE_HEAP_USAGE
#undef PROBE_HEAP_USAGE
#endif
//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

//	(assumes dword is 4 bytes long and pointer is a dword in size)
#define ALIGN_ON_DWORD(x) ((VOID *)(((DWORD) x & 0x00000003) ? (((DWORD) x & 0xFFFFFFFC) + 4) : ((DWORD) x)))

extern WCHAR  GLOBAL_STRING[];	// Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];		// get data from foreign computers
extern WCHAR  COSTLY_STRING[];
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL	1
#define QUERY_ITEMS	2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY	4

//
// The definition of the only routine of perfutil.c, It builds part of a
// performance data instance (PERF_INSTANCE_DEFINITION) as described in
// winperf.h
//

HANDLE MonOpenEventLog ();
VOID MonCloseEventLog ();
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

typedef struct _LOCAL_HEAP_INFO_BLOCK {
	DWORD   AllocatedEntries;
	DWORD   AllocatedBytes;
	DWORD   FreeEntries;
	DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;


//
//  Memory Probe macro
//
#ifdef PROBE_HEAP_USAGE

#define HEAP_PROBE()	{ \
	DWORD   dwHeapStatus[5]; \
	NTSTATUS CallStatus; \
	dwHeapStatus[4] = __LINE__; \
	if (!(CallStatus = memprobe (dwHeapStatus, 16L, NULL))) { \
		REPORT_INFORMATION_DATA (TCP_HEAP_STATUS, LOG_DEBUG,	\
			&dwHeapStatus, sizeof(dwHeapStatus));  \
	} else {  \
		REPORT_ERROR_DATA (TCP_HEAP_STATUS_ERROR, LOG_DEBUG, \
			&CallStatus, sizeof (DWORD)); \
	} \
}

#else

#define HEAP_PROBE()	;

#endif

#endif  //_PERFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpctrs\smtpctrs.h ===
//#---------------------------------------------------------------
//  File:		smtpctrs.h
//
//  Synopsis:	Offset definitions for the MSN Server's
//				counter objects & counters.
//
//				These offsets *must* start at 0 and be
//				multiples of 2.  In the MsnOpenPerformanceData
//				procecedure, they will be added to the MSN
//				Server's "First Counter" and "First Help"
//				values in order to determine the absolute
//				location of the counter & object names
//				and corresponding help text in the registry.
//
//				This file is used by the MSNCTRS.DLL DLL
//				code as well as the MSNCTRS.INI definition
//				file.  MSNCTRS.INI is parsed by the LODCTR
//				utility to load the object & counter names
//				into the registry.
//
//	Copyright (C) 1995 Microsoft Corporation
//	All rights reserved.
//
//  Authors:	toddch - based on msn sources by rkamicar, keithmo
//----------------------------------------------------------------

#ifndef _SMTPCTRS_H_
#define _SMTPCTRS_H_


//
// disabled tracing by default for the perfmon client code
//
#ifndef	NOTRACE
#define	NOTRACE
#endif

//
//  The SMTP Server counter object.
//

#define SMTP_COUNTER_OBJECT					0


//
//  The individual counters.
//

#define SMTP_BYTES_SENT_TTL_COUNTER						2
#define SMTP_BYTES_SENT_PER_SEC_COUNTER					4
#define SMTP_BYTES_RCVD_TTL_COUNTER						6
#define	SMTP_BYTES_RCVD_PER_SEC_COUNTER					8
#define SMTP_BYTES_TTL_COUNTER							10
#define SMTP_BYTES_TTL_PER_SEC_COUNTER					12

#define SMTP_BYTES_SENT_MSG_COUNTER						14
#define SMTP_BYTES_SENT_MSG_PER_SEC_COUNTER				16
#define SMTP_BYTES_RCVD_MSG_COUNTER						18
#define	SMTP_BYTES_RCVD_MSG_PER_SEC_COUNTER				20
#define SMTP_BYTES_MSG_COUNTER							22
#define SMTP_BYTES_MSG_PER_SEC_COUNTER					24

#define SMTP_MSG_RCVD_TTL_COUNTER						26
#define SMTP_MSG_RCVD_PER_SEC_COUNTER					28
#define SMTP_AVG_RCPTS_PER_MSG_RCVD_COUNTER				30
#define SMTP_BASE_AVG_RCPTS_PER_MSG_RCVD_COUNTER		32
#define SMTP_PCT_LCL_RCPTS_PER_MSG_RCVD_COUNTER			34
#define SMTP_BASE_PCT_LCL_RCPTS_PER_MSG_RCVD_COUNTER	36
#define SMTP_PCT_RMT_RCPTS_PER_MSG_RCVD_COUNTER			38
#define SMTP_BASE_PCT_RMT_RCPTS_PER_MSG_RCVD_COUNTER	40
#define SMTP_MSG_RCVD_REFUSED_SIZE_COUNTER				42
#define SMTP_MSG_RCVD_REFUSED_CADDR_COUNTER				44
#define SMTP_MSG_RCVD_REFUSED_MAIL_COUNTER				46


#define SMTP_MSG_DLVR_TTL_COUNTER						48
#define SMTP_MSG_DLVR_PER_SEC_COUNTER					50
#define SMTP_MSG_DLVR_RETRIES_TTL_COUNTER				52
#define SMTP_AVG_RETRIES_PER_MSG_DLVR_COUNTER			54
#define SMTP_BASE_AVG_RETRIES_PER_MSG_DLVR_COUNTER		56
#define SMTP_MSG_FWD_TTL_COUNTER						58
#define SMTP_MSG_FWD_PER_SEC_COUNTER					60
#define SMTP_NDR_GENERATED_COUNTER						62
#define SMTP_LOCALQ_LENGTH_COUNTER						64
#define SMTP_RETRYQ_LENGTH_COUNTER						66
#define SMTP_NUM_MAILFILE_HANDLES_COUNTER				68
#define SMTP_NUM_QUEUEFILE_HANDLES_COUNTER				70
#define SMTP_CATQ_LENGTH_COUNTER						72

#define SMTP_MSG_SENT_TTL_COUNTER						74
#define SMTP_MSG_SENT_PER_SEC_COUNTER					76
#define SMTP_MSG_SEND_RETRIES_TTL_COUNTER				78
#define SMTP_AVG_RETRIES_PER_MSG_SEND_COUNTER			80
#define SMTP_BASE_AVG_RETRIES_PER_MSG_SEND_COUNTER		82
#define SMTP_AVG_RCPTS_PER_MSG_SENT_COUNTER				84
#define SMTP_BASE_AVG_RCPTS_PER_MSG_SENT_COUNTER		86
#define SMTP_REMOTEQ_LENGTH_COUNTER						88

#define SMTP_DNS_QUERIES_TTL_COUNTER					90
#define SMTP_DNS_QUERIES_PER_SEC_COUNTER				92
#define SMTP_REMOTE_RETRY_QUEUE_LENGTH_COUNTER			94
#define SMTP_PICKUP_QUEUE_LENGTH_COUNTER				96

#define SMTP_CONN_IN_TTL_COUNTER						98
#define SMTP_CONN_IN_CURR_COUNTER						100
#define SMTP_CONN_OUT_TTL_COUNTER						102
#define SMTP_CONN_OUT_CURR_COUNTER						104
#define SMTP_CONN_OUT_REFUSED_COUNTER					106

#define SMTP_ERR_TTL_COUNTER							108
#define SMTP_ERR_PER_SEC_COUNTER						110

#define SMTP_DIR_DROPS_TTL_COUNTER						112
#define SMTP_DIR_DROPS_PER_SEC_COUNTER					114
#define SMTP_RT_LOOKUPS_TTL_COUNTER						116
#define SMTP_RT_LOOKUPS_PER_SEC_COUNTER					118
#define SMTP_ETRN_MSGS_TTL_COUNTER						120
#define SMTP_ETRN_MSGS_PER_SEC_COUNTER					122

#define SMTP_MSG_BADMAIL_NO_RECIPIENTS_COUNTER          124
#define SMTP_MSG_BADMAIL_HOP_COUNT_EXCEEDED_COUNTER     126
#define SMTP_MSG_BADMAIL_FAILURE_GENERAL_COUNTER        128
#define SMTP_MSG_BADMAIL_BAD_PICKUP_FILE_COUNTER        130
#define SMTP_MSG_BADMAIL_EVENT_COUNTER                  132
#define SMTP_MSG_BADMAIL_NDR_OF_DSN_COUNTER             134
#define SMTP_MSG_PENDING_ROUTING_COUNTER                136
#define SMTP_MSG_PENDING_UNREACHABLE_LINK_COUNTER       138
#define SMTP_SUBMITTED_MESSAGES_COUNTER                 140
#define SMTP_DSN_FAILURES_COUNTER                       142
#define SMTP_MSG_IN_LOCAL_DELIVERY_COUNTER              144

#define SMTP_CAT_SUBMISSIONS_COUNTER                    146
#define SMTP_CAT_SUBMISSIONS_PER_SEC_COUNTER            148
#define SMTP_CAT_COMPLETIONS_COUNTER                    150
#define SMTP_CAT_COMPLETIONS_PER_SEC_COUNTER            152
#define SMTP_CAT_CURRENT_CATEGORIZATIONS_COUNTER        154
#define SMTP_CAT_SUCCEEDED_CATEGORIZATIONS_COUNTER      156
#define SMTP_CAT_HARD_FAILURES_COUNTER                  158
#define SMTP_CAT_RETRY_FAILURES_COUNTER                 160
#define SMTP_CAT_RETRY_OUTOFMEMORY_COUNTER              162
#define SMTP_CAT_RETRY_DSLOGON_COUNTER                  164
#define SMTP_CAT_RETRY_DSCONNECTION_COUNTER             166
#define SMTP_CAT_RETRY_GENERIC_COUNTER                  168
#define SMTP_CAT_MSGS_OUT_COUNTER                       170
#define SMTP_CAT_MSGS_CREATED_COUNTER                   172
#define SMTP_CAT_MSGS_ABORTED_COUNTER                   174
#define SMTP_CAT_RECIPS_PRECAT_COUNTER                  176
#define SMTP_CAT_RECIPS_POSTCAT_COUNTER                 178
#define SMTP_CAT_RECIPS_NDRD_COUNTER                    180
#define SMTP_CAT_RECIPS_UNRESOLVED_COUNTER              182
#define SMTP_CAT_RECIPS_AMBIGUOUS_COUNTER               184
#define SMTP_CAT_RECIPS_ILLEGAL_COUNTER                 186
#define SMTP_CAT_RECIPS_LOOP_COUNTER                    188
#define SMTP_CAT_RECIPS_GENERICFAILURE_COUNTER          190
#define SMTP_CAT_RECIPS_INMEMORY_COUNTER                192
#define SMTP_CAT_SENDERS_UNRESOLVED_COUNTER             194
#define SMTP_CAT_SENDERS_AMBIGUOUS_COUNTER              196
#define SMTP_CAT_ADDRESS_LOOKUPS_COUNTER                198
#define SMTP_CAT_ADDRESS_LOOKUPS_PER_SEC_COUNTER        200
#define SMTP_CAT_ADDRESS_LOOKUP_COMPLETIONS_COUNTER     202
#define SMTP_CAT_ADDRESS_LOOKUP_COMPLETIONS_PER_SEC_COUNTER 204
#define SMTP_CAT_ADDRESS_LOOKUPS_NOT_FOUND_COUNTER      206
#define SMTP_CAT_MAILMSG_DUPLICATE_COLLISIONS_COUNTER   208
#define SMTP_CAT_LDAP_CONNECTIONS_COUNTER               210
#define SMTP_CAT_LDAP_CONNECTION_FAILURES_COUNTER       212
#define SMTP_CAT_LDAP_OPEN_CONNECTIONS_COUNTER          214
#define SMTP_CAT_LDAP_BINDS_COUNTER                     216
#define SMTP_CAT_LDAP_BIND_FAILURES_COUNTER             218
#define SMTP_CAT_LDAP_SEARCHES_COUNTER                  220
#define SMTP_CAT_LDAP_SEARCHES_PER_SEC_COUNTER          222
#define SMTP_CAT_LDAP_PAGED_SEARCHES_COUNTER            224
#define SMTP_CAT_LDAP_SEARCH_FAILURES_COUNTER           226
#define SMTP_CAT_LDAP_PAGED_SEARCH_FAILURES_COUNTER     228
#define SMTP_CAT_LDAP_SEARCHES_COMPLETED_COUNTER        230
#define SMTP_CAT_LDAP_SEARCHES_COMPLETED_PER_SEC_COUNTER 232
#define SMTP_CAT_LDAP_PAGED_SEARCHES_COMPLETED_COUNTER  234
#define SMTP_CAT_LDAP_SEARCHES_COMPLETED_FAILURE_COUNTER 236
#define SMTP_CAT_LDAP_PAGED_SEARCHES_COMPLETED_FAILURE_COUNTER 238
#define SMTP_CAT_LDAP_GENERAL_COMPLETION_FAILURES_COUNTER 240
#define SMTP_CAT_LDAP_ABANDONED_SEARCHES_COUNTER        242
#define SMTP_CAT_LDAP_PENDING_SEARCHES_COUNTER          244

// SERVICE_START
// CONNECTION_START
// LAST_CLEAR

#endif  // _SMTPCTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpctrs\perfmsg.h ===
//#---------------------------------------------------------------
//  File:		perfmsg.h
//
//  Synopsis:	This file provides the macros and definitions
//				used by the extensible counters for reporting
//				events to the event logging facility.

//
//	Copyright (C) 1995 Microsoft Corporation
//	All rights reserved.
//
//  Authors:	toddch - based on msn sources by rkamicar, a-robw
//----------------------------------------------------------------

#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME  "smtpctrs"

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//	Levels:  LOG_NONE = No event log messages ever
//			LOG_USER = User event log messages (e.g. errors)
//			LOG_DEBUG = Minimum Debugging
//			LOG_VERBOSE = Maximum Debugging
//

#define  LOG_NONE	0
#define  LOG_USER	1
#define  LOG_DEBUG	2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//	REPORT_xxx (message_value, message_level)
//	where:
//		xxx is the severity to be displayed in the event log
//		message_value is the numeric ID from above
//		message_level is the "filtering" level of error reporting
//			using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the
//
//	REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpctrs\perfsmtp.c ===
//---------------------------------------------------------------
//  File:       perfsmtp.c
//
//  Synopsis:   This file implements the Extensible Performance
//              Objects for the SMTP service.
//
//  Copyright (C) 1996 Microsoft Corporation
//  All rights reserved.
//
//  Authors:    toddch - based on rkamicar, keithmo source
//----------------------------------------------------------------
#ifdef  THIS_FILE
#undef  THIS_FILE
#endif
static  char    __szTraceSourceFile[] = __FILE__;
#define THIS_FILE   __szTraceSourceFile

#define NOTRACE

#define  INITGUID

#include <nt.h>         // For ntrtl.h
#include <ntrtl.h>      // RtlLargeInteger*()
#include <nturtl.h>     // For windows.h
#include <windows.h>
#include <winperf.h>
#include <lm.h>
#include <string.h>
#include <stdio.h>
#include "smtpdata.h"   // The counter descriptions
#include "smtpctrs.h"   // more counter descriptions
#include "perfutil.h"   // Perfmon support
#include "smtps.h"      // Registry Key strings.
#include "smtpapi.h"        // RPC interface wrappers


#include "dbgtrace.h"



//
//  Private globals.
//

DWORD   cOpens  = 0;                // Active "opens" reference count.
BOOL    fInitOK   = FALSE;          // TRUE if DLL initialized OK.

//
//  Public prototypes.
//

PM_OPEN_PROC    OpenSmtpPerformanceData;
PM_COLLECT_PROC CollectSmtpPerformanceData;
PM_CLOSE_PROC   CloseSmtpPerformanceData;



//
//  Public functions.
//

/*******************************************************************

    NAME:   OpenSmtpPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate
                performance counters with the registry.

    ENTRY:      lpDeviceNames - Pointer to object ID of each device
                    to be opened.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo 07-Jun-1993 Created.

********************************************************************/
DWORD APIENTRY
OpenSmtpPerformanceData(LPWSTR lpDeviceNames)
{
    PERF_COUNTER_DEFINITION *pctr;
    DWORD   i;
    DWORD   dwFirstCounter = 0;
    DWORD   dwFirstHelp = 0;
    DWORD   err  = NO_ERROR;
    HKEY    hkey = NULL;
    DWORD   size;
    DWORD   type;
    BOOL    fOpenRegKey = FALSE;

#ifndef NOTRACE
    //
    // make sure that tracing is enabled
    //
    InitAsyncTrace();
#endif

    //
    // we need to have another level of scoping here for TraceFunctEnter()
    // to work
    //
    {
    TraceFunctEnter("OpenSmtpPerformanceData");

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). The registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem.
    //
    if(!fInitOK)
    {
        //
        // This is the *first* open - update the indicies in
        // our table with the offset of our counters within the
        // perfmon key.
        //
        DebugTrace(0, "Initializing.");

        //
        //  Open the service's Performance key and get the
        // offsets of our counters within the PerfLib MULTI_SZ.
        //
        err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           SMTP_PERFORMANCE_KEY,
                           0,
                           KEY_READ,
                           &hkey);
        if(err == NO_ERROR) {
            fOpenRegKey = TRUE;
            size = sizeof(DWORD);

            err = RegQueryValueEx(hkey,
                                  "First Counter",
                                  NULL,
                                  &type,
                                  (LPBYTE)&dwFirstCounter,
                                  &size);
        } else {
            DebugTrace(0, "No 'First Counter' key (err = %d) in '%s'",
                    err, SMTP_PERFORMANCE_KEY);
        }
        if(err == NO_ERROR) {
            size = sizeof(DWORD);

            err = RegQueryValueEx(hkey,
                                  "First Help",
                                  NULL,
                                  &type,
                                  (LPBYTE)&dwFirstHelp,
                                  &size);
        } else {
            DebugTrace(0, "No 'First Help' key (err = %d) in '%s'",
                    err, SMTP_PERFORMANCE_KEY);
        }

        if (NO_ERROR == err)
        {
            //
            //  Update the object & counter name & help indicies.
            //
            SmtpDataDefinition.SmtpObjectType.ObjectNameTitleIndex += dwFirstCounter;
            SmtpDataDefinition.SmtpObjectType.ObjectHelpTitleIndex += dwFirstHelp;
    
            pctr = &SmtpDataDefinition.SmtpBytesSentTtl;
    
            for(i = 0; i < NUMBER_OF_SMTP_COUNTERS; i++) {
                pctr->CounterNameTitleIndex += dwFirstCounter;
                pctr->CounterHelpTitleIndex += dwFirstHelp;
                pctr++;
            }
            //
            //  Remember that we initialized OK.
            //
            fInitOK = TRUE;
        } else {
            DebugTrace(0, "No 'First Help' key (err = %d) in '%s'",
                    err, SMTP_PERFORMANCE_KEY);
        }

        if (fOpenRegKey)
        {
            err = RegCloseKey(hkey);
            // This should never fail!
            _ASSERT(err == ERROR_SUCCESS);
        }
    }
    //
    //  Bump open counter.
    //
    cOpens++;

    TraceFunctLeave();
    } // end of TraceFunctEnter() scoping

    return NO_ERROR;

}   // OpenSmtpPerformanceData

/*******************************************************************

    NAME:   CollectSmtpPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate

    ENTRY:  lpValueName - The name of the value to retrieve.

                lppData - On entry contains a pointer to the buffer to
                    receive the completed PerfDataBlock & subordinate
                    structures.  On exit, points to the first bytes
                    *after* the data structures added by this routine.

                lpcbTotalBytes - On entry contains a pointer to the
                    size (in BYTEs) of the buffer referenced by lppData.
                    On exit, contains the number of BYTEs added by this
                    routine.

                lpNumObjectTypes - Receives the number of objects added
                    by this routine.

    RETURNS:    DWORD - Win32 status code.  MUST be either NO_ERROR
                    or ERROR_MORE_DATA.

    HISTORY:
        KeithMo 07-Jun-1993 Created.

********************************************************************/
DWORD APIENTRY
CollectSmtpPerformanceData(LPWSTR    lpValueName,
                          LPVOID  * lppData,
                          LPDWORD   lpcbTotalBytes,
                          LPDWORD   lpNumObjectTypes)
{
    DWORD                       dwQueryType;
    ULONG                       cbRequired;
    DWORD                       * pdwCounter;
    DWORD                       * pdwEndCounter;
    unsigned __int64            * pliCounter;
    SMTP_COUNTER_BLOCK          * pCounterBlock;
    SMTP_DATA_DEFINITION        * pSmtpDataDefinition;
    SMTP_INSTANCE_DEFINITION    * pSmtpInstanceDefinition;
    SMTP_INSTANCE_DEFINITION    * pInstanceTotalDefinition;
    PSMTP_STATISTICS_BLOCK_ARRAY    pSmtpStatsBlockArray;
    PSMTP_STATISTICS_BLOCK      pSmtpStatsBlock;
    LPSMTP_STATISTICS_0         pSmtpStats;
    NET_API_STATUS              neterr;
    DWORD                       dwInstance;
    DWORD                       dwInstanceIndex;
    DWORD                       dwInstanceCount;
    CHAR                        temp[INSTANCE_NAME_SIZE];
    DWORD                       ii;


    TraceFunctEnter("CollectSmtpPerformanceData");

//    DebugTrace(0, " lpValueName     = %08lX (%ls)", lpValueName, lpValueName);
    DebugTrace(0, " lppData         = %08lX (%08lX)",   lppData, *lppData);
    DebugTrace(0, " lpcbTotalBytes  = %08lX (%08lX)",
                                        lpcbTotalBytes, *lpcbTotalBytes);
    DebugTrace(0, " lpNumObjectTypes= %08lX (%08lX)",
                                        lpNumObjectTypes, *lpNumObjectTypes);

    //
    //  No need to even try if we failed to open...
    //

    if(!fInitOK)
    {
        ErrorTrace(0, "Initialization failed, aborting.");

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        //
        //  According to the Performance Counter design, this
        //  is a successful exit.  Go figure.
        //

        TraceFunctLeave();
        return NO_ERROR;
    }

    //
    //  Determine the query type.
    //

    dwQueryType = GetQueryType(lpValueName);

    if(dwQueryType == QUERY_FOREIGN)
    {
        ErrorTrace(0, "Foreign queries not supported.");

        //
        //  We don't do foreign queries.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        TraceFunctLeave();
        return NO_ERROR;
    }

    if(dwQueryType == QUERY_ITEMS)
    {
        //
        //  The registry is asking for a specific object.  Let's
        //  see if we're one of the chosen.
        //

        if(!IsNumberInUnicodeList(
                        SmtpDataDefinition.SmtpObjectType.ObjectNameTitleIndex,
                        lpValueName))
        {
            ErrorTrace(0, "%ls not a supported object type.", lpValueName);

            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

            TraceFunctLeave();
            return NO_ERROR;
        }
    }

    //
    //  Query the statistics and see if there has been enough space allocated.
    //  The number of instances will be returned in dwInstanceCount
    //

    neterr = SmtpQueryStatistics( NULL, 0, (LPBYTE *) &pSmtpStatsBlockArray);

    if( neterr != NERR_Success )
    {
        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        TraceFunctLeave();
        return NO_ERROR;
    }


    //
    // Check the space requirement add one to the number of instances for the totals.
    //

    dwInstanceCount = pSmtpStatsBlockArray->cEntries;
    if(*lpcbTotalBytes < (sizeof(SMTP_DATA_DEFINITION) +
            (dwInstanceCount + 1) * (sizeof(SMTP_INSTANCE_DEFINITION) + SIZE_OF_SMTP_PERFORMANCE_DATA)))
     {
        ErrorTrace(0, "%lu bytes of buffer insufficient, need %lu.",
                                            *lpcbTotalBytes, cbRequired);

        //
        //  Nope.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        //
        // Free the returned buffer
        //

        NetApiBufferFree((LPBYTE)pSmtpStatsBlockArray);


        TraceFunctLeave();
        return ERROR_MORE_DATA;
    }


    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    pSmtpDataDefinition = (SMTP_DATA_DEFINITION *)*lppData;
    CopyMemory(pSmtpDataDefinition, &SmtpDataDefinition,
                                            sizeof(SMTP_DATA_DEFINITION));

    //
    // Initialize the Total Instance
    //
    pSmtpInstanceDefinition = (SMTP_INSTANCE_DEFINITION *)(pSmtpDataDefinition + 1);

    pInstanceTotalDefinition = pSmtpInstanceDefinition;
    CopyMemory(pInstanceTotalDefinition, &SmtpInstanceDefinition, sizeof(SMTP_INSTANCE_DEFINITION));

    //
    // For the Total Instance update the namelength, insert the name, add 1 for null.
    //
    sprintf(temp,"_Total");

    pInstanceTotalDefinition->PerfInstanceDef.NameLength =
            2 * (MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,temp,-1,
            (pInstanceTotalDefinition->InstanceName),INSTANCE_NAME_SIZE)) + 1;

    ZeroMemory((PVOID)(pInstanceTotalDefinition + 1),SIZE_OF_SMTP_PERFORMANCE_DATA);


    //
    // Begin looping through Instances.
    //

    pSmtpStatsBlock = pSmtpStatsBlockArray->aStatsBlock;

    for (ii = 0; ii < dwInstanceCount; ii++)

    {
        dwInstance = pSmtpStatsBlock->dwInstance;
        pSmtpStats = &(pSmtpStatsBlock->Stats_0);


        //
        // Copy the (constant, initialized) Instance Definition to the block for the instance.
        //

        pSmtpInstanceDefinition = (SMTP_INSTANCE_DEFINITION *)((DWORD_PTR)pSmtpInstanceDefinition +
                    sizeof(SMTP_INSTANCE_DEFINITION) + SIZE_OF_SMTP_PERFORMANCE_DATA);

        CopyMemory(pSmtpInstanceDefinition, &SmtpInstanceDefinition, sizeof(SMTP_INSTANCE_DEFINITION));

        //
        // update the namelength, insert the name, add 1 for null.
        //
        sprintf(temp,"SMTP %u", dwInstance);
        pSmtpInstanceDefinition->PerfInstanceDef.NameLength =
                2 * (MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,temp,-1,
                (pSmtpInstanceDefinition->InstanceName),INSTANCE_NAME_SIZE)) + 1;


        //
        //  Fill in the counter block.
        //

        pCounterBlock = (SMTP_COUNTER_BLOCK *)(pSmtpInstanceDefinition + 1);

        pCounterBlock->PerfCounterBlock.ByteLength = SIZE_OF_SMTP_PERFORMANCE_DATA;

        //
        //  Get the pointer to the first (unsigned __int64) counter.  This
        //  pointer *must* be quadword aligned.
        //

        pliCounter = (unsigned __int64 *)(pCounterBlock + 1);

        DebugTrace(0, "pSmtpDataDefinition = %08lX", pSmtpDataDefinition);
        DebugTrace(0, "pCounterBlock    = %08lX", pCounterBlock);
        DebugTrace(0, "ByteLength       = %08lX",
                            pCounterBlock->PerfCounterBlock.ByteLength);
        DebugTrace(0, "pliCounter       = %08lX", pliCounter);

        //
        //  Move the 'unsigned __int64's into the buffer.
        //

        *pliCounter++ = pSmtpStats->BytesSentTotal;
        *pliCounter++ = pSmtpStats->BytesSentTotal;
        *pliCounter++ = pSmtpStats->BytesRcvdTotal;
        *pliCounter++ = pSmtpStats->BytesRcvdTotal;
        *pliCounter++ = pSmtpStats->BytesSentTotal + pSmtpStats->BytesRcvdTotal;
        *pliCounter++ = pSmtpStats->BytesSentTotal + pSmtpStats->BytesRcvdTotal;

        *pliCounter++ = pSmtpStats->BytesSentMsg;
        *pliCounter++ = pSmtpStats->BytesSentMsg;
        *pliCounter++ = pSmtpStats->BytesRcvdMsg;
        *pliCounter++ = pSmtpStats->BytesRcvdMsg;
        *pliCounter++ = pSmtpStats->BytesSentMsg + pSmtpStats->BytesRcvdMsg;
        *pliCounter++ = pSmtpStats->BytesSentMsg + pSmtpStats->BytesRcvdMsg;

        //
        //  Now move the DWORDs into the buffer.
        //

        pdwCounter = (DWORD *)pliCounter;

        DebugTrace(0, "pdwCounter       = %08lX", pdwCounter);

        // Messages Received
        *pdwCounter++ = pSmtpStats->NumMsgRecvd;
        *pdwCounter++ = pSmtpStats->NumMsgRecvd;
        *pdwCounter++ = pSmtpStats->NumRcptsRecvd;
        *pdwCounter++ = pSmtpStats->NumMsgRecvd * 100;
        *pdwCounter++ = pSmtpStats->NumRcptsRecvdLocal;
        *pdwCounter++ = pSmtpStats->NumRcptsRecvd;
        *pdwCounter++ = pSmtpStats->NumRcptsRecvdRemote;
        *pdwCounter++ = pSmtpStats->NumRcptsRecvd;
        *pdwCounter++ = pSmtpStats->MsgsRefusedDueToSize;
        *pdwCounter++ = pSmtpStats->MsgsRefusedDueToNoCAddrObjects;
        *pdwCounter++ = pSmtpStats->MsgsRefusedDueToNoMailObjects;

        // MTA Deliveries
        *pdwCounter++ = pSmtpStats->NumMsgsDelivered;
        *pdwCounter++ = pSmtpStats->NumMsgsDelivered;
        *pdwCounter++ = pSmtpStats->NumDeliveryRetries;
        *pdwCounter++ = pSmtpStats->NumDeliveryRetries;
        *pdwCounter++ = pSmtpStats->NumMsgsDelivered * 100;
        *pdwCounter++ = pSmtpStats->NumMsgsForwarded;
        *pdwCounter++ = pSmtpStats->NumMsgsForwarded;
        *pdwCounter++ = pSmtpStats->NumNDRGenerated;
        *pdwCounter++ = pSmtpStats->LocalQueueLength;
        *pdwCounter++ = pSmtpStats->RetryQueueLength;
        *pdwCounter++ = pSmtpStats->NumMailFileHandles;
        *pdwCounter++ = pSmtpStats->NumQueueFileHandles;
        *pdwCounter++ = pSmtpStats->CatQueueLength;

        // Messages Sent
        *pdwCounter++ = pSmtpStats->NumMsgsSent;
        *pdwCounter++ = pSmtpStats->NumMsgsSent;
        *pdwCounter++ = pSmtpStats->NumSendRetries;
        *pdwCounter++ = pSmtpStats->NumSendRetries;
        *pdwCounter++ = pSmtpStats->NumMsgsSent * 100;
        *pdwCounter++ = pSmtpStats->NumRcptsSent;
        *pdwCounter++ = pSmtpStats->NumMsgsSent * 100;
        *pdwCounter++ = pSmtpStats->RemoteQueueLength;

        // DNS lookups
        *pdwCounter++ = pSmtpStats->NumDnsQueries;
        *pdwCounter++ = pSmtpStats->NumDnsQueries;
        *pdwCounter++ = pSmtpStats->RemoteRetryQueueLength;

        // Connections
        *pdwCounter++ = pSmtpStats->NumConnInOpen;
        *pdwCounter++ = pSmtpStats->NumConnInOpen - pSmtpStats->NumConnInClose;
        *pdwCounter++ = pSmtpStats->NumConnOutOpen;
        *pdwCounter++ = pSmtpStats->NumConnOutOpen - pSmtpStats->NumConnOutClose;
        *pdwCounter++ = pSmtpStats->NumConnOutRefused;

        *pdwCounter++ = pSmtpStats->NumProtocolErrs;
        *pdwCounter++ = pSmtpStats->NumProtocolErrs;

        *pdwCounter++ = pSmtpStats->DirectoryDrops;
        *pdwCounter++ = pSmtpStats->DirectoryDrops;
        *pdwCounter++ = pSmtpStats->RoutingTableLookups;
        *pdwCounter++ = pSmtpStats->RoutingTableLookups;
        *pdwCounter++ = pSmtpStats->ETRNMessages;
        *pdwCounter++ = pSmtpStats->ETRNMessages;

        // new AQueue counters
        *pdwCounter++ = pSmtpStats->MsgsBadmailNoRecipients;
        *pdwCounter++ = pSmtpStats->MsgsBadmailHopCountExceeded;
        *pdwCounter++ = pSmtpStats->MsgsBadmailFailureGeneral;
        *pdwCounter++ = pSmtpStats->MsgsBadmailBadPickupFile;
        *pdwCounter++ = pSmtpStats->MsgsBadmailEvent;
        *pdwCounter++ = pSmtpStats->MsgsBadmailNdrOfDsn;
        *pdwCounter++ = pSmtpStats->MsgsPendingRouting;
        *pdwCounter++ = pSmtpStats->MsgsPendingUnreachableLink;
        *pdwCounter++ = pSmtpStats->SubmittedMessages;
        *pdwCounter++ = pSmtpStats->DSNFailures;
        *pdwCounter++ = pSmtpStats->MsgsInLocalDelivery;

        // Cat counters
        *pdwCounter++ = pSmtpStats->CatPerfBlock.CatSubmissions;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.CatCompletions;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.CurrentCategorizations;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.SucceededCategorizations;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.HardFailureCategorizations;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.RetryFailureCategorizations;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.RetryOutOfMemory;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.RetryDSLogon;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.RetryDSConnection;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.RetryGeneric;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.MessagesSubmittedToQueueing;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.MessagesCreated;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.MessagesAborted;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.PreCatRecipients;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.PostCatRecipients;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.NDRdRecipients;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.UnresolvedRecipients;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.AmbiguousRecipients;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.IllegalRecipients;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LoopRecipients;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.GenericFailureRecipients;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.RecipsInMemory;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.UnresolvedSenders;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.AmbiguousSenders;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.AddressLookups;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.AddressLookupCompletions;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.AddressLookupsNotFound;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.MailmsgDuplicateCollisions;

        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.Connections;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.ConnectFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.OpenConnections;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.Binds;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.BindFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.Searches;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.PagedSearches;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.SearchFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.PagedSearchFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.SearchesCompleted;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.PagedSearchesCompleted;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.SearchCompletionFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.PagedSearchCompletionFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.GeneralCompletionFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.AbandonedSearches;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.PendingSearches;
        *pdwCounter++ = 0; // padding

        _ASSERT((BYTE *)pdwCounter - (BYTE *)pCounterBlock ==
                                    SIZE_OF_SMTP_PERFORMANCE_DATA);


        pdwEndCounter = pdwCounter;

        //
        // Increment the Total Block.
        //

        pCounterBlock = (SMTP_COUNTER_BLOCK *)(pInstanceTotalDefinition + 1);

        pCounterBlock->PerfCounterBlock.ByteLength = SIZE_OF_SMTP_PERFORMANCE_DATA;

        //
        //  Get the pointer to the first (unsigned __int64) counter.  This
        //  pointer *must* be quadword aligned.
        //

        pliCounter = (unsigned __int64 *)(pCounterBlock + 1);

        //
        //  Increment the 'unsigned __int64's in the buffer.
        //

        *pliCounter++ = *pliCounter + pSmtpStats->BytesSentTotal;
        *pliCounter++ = *pliCounter + pSmtpStats->BytesSentTotal;
        *pliCounter++ = *pliCounter + pSmtpStats->BytesRcvdTotal;
        *pliCounter++ = *pliCounter + pSmtpStats->BytesRcvdTotal;
        *pliCounter++ = *pliCounter + pSmtpStats->BytesSentTotal + pSmtpStats->BytesRcvdTotal;
        *pliCounter++ = *pliCounter + pSmtpStats->BytesSentTotal + pSmtpStats->BytesRcvdTotal;

        *pliCounter++ = *pliCounter + pSmtpStats->BytesSentMsg;
        *pliCounter++ = *pliCounter + pSmtpStats->BytesSentMsg;
        *pliCounter++ = *pliCounter + pSmtpStats->BytesRcvdMsg;
        *pliCounter++ = *pliCounter + pSmtpStats->BytesRcvdMsg;
        *pliCounter++ = *pliCounter + pSmtpStats->BytesSentMsg + pSmtpStats->BytesRcvdMsg;
        *pliCounter++ = *pliCounter + pSmtpStats->BytesSentMsg + pSmtpStats->BytesRcvdMsg;

        //
        //  Increment the DWORDs in the buffer.
        //

        pdwCounter = (DWORD *)pliCounter;

        // Increment the Messages Received
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgRecvd;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgRecvd;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumRcptsRecvd;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgRecvd * 100;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumRcptsRecvdLocal;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumRcptsRecvd;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumRcptsRecvdRemote;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumRcptsRecvd;
        *pdwCounter++ = *pdwCounter + pSmtpStats->MsgsRefusedDueToSize;
        *pdwCounter++ = *pdwCounter + pSmtpStats->MsgsRefusedDueToNoCAddrObjects;
        *pdwCounter++ = *pdwCounter + pSmtpStats->MsgsRefusedDueToNoMailObjects;

        // Increment the MTA Deliveries
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgsDelivered;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgsDelivered;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumDeliveryRetries;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumDeliveryRetries;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgsDelivered * 100;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgsForwarded;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgsForwarded;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumNDRGenerated;
        *pdwCounter++ = *pdwCounter + pSmtpStats->LocalQueueLength;
        *pdwCounter++ = *pdwCounter + pSmtpStats->RetryQueueLength;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMailFileHandles;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumQueueFileHandles;
        *pdwCounter++ = *pdwCounter + pSmtpStats->CatQueueLength;

        // Increment the Messages Sent
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgsSent;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgsSent;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumSendRetries;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumSendRetries;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgsSent * 100;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumRcptsSent;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgsSent * 100;
        *pdwCounter++ = *pdwCounter + pSmtpStats->RemoteQueueLength;

        // Increment the DNS lookups
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumDnsQueries;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumDnsQueries;
        *pdwCounter++ = *pdwCounter + pSmtpStats->RemoteRetryQueueLength;

        // Increment the Connections
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumConnInOpen;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumConnInOpen - pSmtpStats->NumConnInClose;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumConnOutOpen;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumConnOutOpen - pSmtpStats->NumConnOutClose;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumConnOutRefused;

        *pdwCounter++ = *pdwCounter + pSmtpStats->NumProtocolErrs;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumProtocolErrs;

        *pdwCounter++ = *pdwCounter +pSmtpStats->DirectoryDrops;
        *pdwCounter++ = *pdwCounter +pSmtpStats->DirectoryDrops;
        *pdwCounter++ = *pdwCounter +pSmtpStats->RoutingTableLookups;
        *pdwCounter++ = *pdwCounter +pSmtpStats->RoutingTableLookups;
        *pdwCounter++ = *pdwCounter +pSmtpStats->ETRNMessages;
        *pdwCounter++ = *pdwCounter +pSmtpStats->ETRNMessages;

        *pdwCounter++ = *pdwCounter +pSmtpStats->MsgsBadmailNoRecipients;
        *pdwCounter++ = *pdwCounter +pSmtpStats->MsgsBadmailHopCountExceeded;
        *pdwCounter++ = *pdwCounter +pSmtpStats->MsgsBadmailFailureGeneral;
        *pdwCounter++ = *pdwCounter +pSmtpStats->MsgsBadmailBadPickupFile;
        *pdwCounter++ = *pdwCounter +pSmtpStats->MsgsBadmailEvent;
        *pdwCounter++ = *pdwCounter +pSmtpStats->MsgsBadmailNdrOfDsn;
        *pdwCounter++ = *pdwCounter +pSmtpStats->MsgsPendingRouting;
        *pdwCounter++ = *pdwCounter +pSmtpStats->MsgsPendingUnreachableLink;
        *pdwCounter++ = *pdwCounter +pSmtpStats->SubmittedMessages;
        *pdwCounter++ = *pdwCounter +pSmtpStats->DSNFailures;
        *pdwCounter++ = *pdwCounter +pSmtpStats->MsgsInLocalDelivery;


        // Cat counters
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.CatSubmissions;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.CatCompletions;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.CurrentCategorizations;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.SucceededCategorizations;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.HardFailureCategorizations;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.RetryFailureCategorizations;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.RetryOutOfMemory;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.RetryDSLogon;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.RetryDSConnection;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.RetryGeneric;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.MessagesSubmittedToQueueing;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.MessagesCreated;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.MessagesAborted;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.PreCatRecipients;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.PostCatRecipients;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.NDRdRecipients;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.UnresolvedRecipients;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.AmbiguousRecipients;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.IllegalRecipients;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.LoopRecipients;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.GenericFailureRecipients;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.RecipsInMemory;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.UnresolvedSenders;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.AmbiguousSenders;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.AddressLookups;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.AddressLookupCompletions;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.AddressLookupsNotFound;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.MailmsgDuplicateCollisions;
        //
        // LDAP counters are already global
        //
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.Connections;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.ConnectFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.OpenConnections;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.Binds;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.BindFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.Searches;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.PagedSearches;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.SearchFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.PagedSearchFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.SearchesCompleted;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.PagedSearchesCompleted;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.SearchCompletionFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.PagedSearchCompletionFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.GeneralCompletionFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.AbandonedSearches;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.PendingSearches;
        *pdwCounter++ = 0; // padding


        _ASSERT((BYTE *)pdwCounter - (BYTE *)pCounterBlock ==
                                    SIZE_OF_SMTP_PERFORMANCE_DATA);

        //
        // Increment in the returned statistics block
        //

        pSmtpStatsBlock++;
    }


    //
    //  Free the API buffer.
    //
    //MIDL_user_free((LPBYTE)pSmtpStats);

    NetApiBufferFree((LPBYTE)pSmtpStatsBlockArray);



    dwInstanceCount++;  // for the _Totals instance.

    pSmtpDataDefinition->SmtpObjectType.TotalByteLength = sizeof(SMTP_DATA_DEFINITION) +
            dwInstanceCount * (sizeof(SMTP_INSTANCE_DEFINITION) + SIZE_OF_SMTP_PERFORMANCE_DATA);
    pSmtpDataDefinition->SmtpObjectType.NumInstances = dwInstanceCount;


    //
    //  Update arguments for return.
    //

    *lppData        = (PVOID) pdwEndCounter;
    *lpNumObjectTypes = 1;
    *lpcbTotalBytes   = (DWORD)((BYTE *)pdwEndCounter - (BYTE *)pSmtpDataDefinition);


    DebugTrace(0, "pData            = %08lX", *lppData);
    DebugTrace(0, "NumObjectTypes   = %08lX", *lpNumObjectTypes);
    DebugTrace(0, "cbTotalBytes     = %08lX", *lpcbTotalBytes);
    DebugTrace(0, "sizeof *pSmtpStat = %08lX", sizeof *pSmtpStats);

    //
    //  Success!  Honest!!
    //
    TraceFunctLeave();
    return NO_ERROR;


}   // CollectSmtpPerformanceData

/*******************************************************************

    NAME:   CloseSmtpPerformanceData

    SYNOPSIS:   Terminates the performance counters.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo 07-Jun-1993 Created.

********************************************************************/
DWORD APIENTRY
CloseSmtpPerformanceData(VOID)
{
    TraceFunctEnter("CloseSmtpPerformanceData");
    //
    //  No real cleanup to do here.
    //
    cOpens--;

    TraceFunctLeave();
    //
    // shuts down and flushes all trace statements
    //
#ifndef NOTRACE
    TermAsyncTrace();
#endif

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpctrs\smtpdata.c ===
//#---------------------------------------------------------------
//  File:       smtpdata.h
//
//  Synopsis:   Constant data structures for the SMTP
//              Server's counter objects & counters.
//
//  Copyright (C) 1995 Microsoft Corporation
//  All rights reserved.
//
//  Authors:    toddch - based on msn sources by rkamicar, keithmo
//----------------------------------------------------------------
#ifdef  THISFILE
#undef  THISFILE
#endif
static  const char  __szTraceSourceFile[] = __FILE__;
#define THISFILE    __szTraceSourceFile

#define NOTRACE

#include <windows.h>
#include <winperf.h>
#include "smtpctrs.h"
#include "smtpdata.h"

//
//  Initialize the constant portitions of these data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//

SMTP_DATA_DEFINITION SmtpDataDefinition =
{
    {
        sizeof(SMTP_DATA_DEFINITION) +      // Total Length of at least one instance
            sizeof(SMTP_INSTANCE_DEFINITION) +
            SIZE_OF_SMTP_PERFORMANCE_DATA,
        sizeof(SMTP_DATA_DEFINITION),       // Definition Length
        sizeof(PERF_OBJECT_TYPE),           // Header Length
        SMTP_COUNTER_OBJECT,                // Name Index into Title DB
        0,                               // String
        SMTP_COUNTER_OBJECT,                // Help Index into Title DB
        0,                               // String
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_SMTP_COUNTERS,
        0,                                  // Default
        PERF_NO_INSTANCES,
        0,                                  // UNICODE instance strings
                                            // These two aren't needed since
                                            // we're not a High Perf. Timer
        { 0, 0 },                           // Sample Time in "Object" units
        { 0, 0 }                            // Freq. of "Object" units in hz.
    },

    {   // SmtpBytesSentTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_SENT_TTL_COUNTER,            // Name Index into Title DB
        0,                                   // String
        SMTP_BYTES_SENT_TTL_COUNTER,            // Help Index into Title DB
        0,
        -6,                                     // Scale (1/10000)
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_SENT_TTL_OFFSET
    },

    {   // SmtpBytesSentPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_SENT_PER_SEC_COUNTER,
        0,
        SMTP_BYTES_SENT_PER_SEC_COUNTER,
        0,
        -3,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_SENT_PER_SEC_OFFSET
    },

    {   // SmtpBytesRcvdTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_RCVD_TTL_COUNTER,
        0,
        SMTP_BYTES_RCVD_TTL_COUNTER,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_RCVD_TTL_OFFSET
    },

    {   // SmtpBytesRcvdPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_RCVD_PER_SEC_COUNTER,
        0,
        SMTP_BYTES_RCVD_PER_SEC_COUNTER,
        0,
        -3,                                     // Scale (1/1)
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_RCVD_PER_SEC_OFFSET
    },

    {   // SmtpBytesTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_TTL_COUNTER,
        0,
        SMTP_BYTES_TTL_COUNTER,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_TTL_OFFSET
    },

    {   // SmtpBytesTtlPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_TTL_PER_SEC_COUNTER,
        0,
        SMTP_BYTES_TTL_PER_SEC_COUNTER,
        0,
        -3,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_TTL_PER_SEC_OFFSET
    },

    {   // SmtpBytesSentMsg
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_SENT_MSG_COUNTER,            // Name Index into Title DB
        0,                                   // String
        SMTP_BYTES_SENT_MSG_COUNTER,            // Help Index into Title DB
        0,
        -6,                                     // Scale (1/10000)
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_SENT_MSG_OFFSET
    },

    {   // SmtpBytesSentMsgPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_SENT_MSG_PER_SEC_COUNTER,
        0,
        SMTP_BYTES_SENT_MSG_PER_SEC_COUNTER,
        0,
        -3,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_SENT_MSG_PER_SEC_OFFSET
    },

    {   // SmtpBytesRcvdMsg
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_RCVD_MSG_COUNTER,
        0,
        SMTP_BYTES_RCVD_MSG_COUNTER,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_RCVD_MSG_OFFSET
    },

    {   // SmtpBytesRcvdMsgPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_RCVD_MSG_PER_SEC_COUNTER,
        0,
        SMTP_BYTES_RCVD_MSG_PER_SEC_COUNTER,
        0,
        -3,                                     // Scale (1/1)
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_RCVD_MSG_PER_SEC_OFFSET
    },

    {   // SmtpBytesMsg
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_MSG_COUNTER,
        0,
        SMTP_BYTES_MSG_COUNTER,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_MSG_OFFSET
    },

    {   // SmtpBytesMsgPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_MSG_PER_SEC_COUNTER,
        0,
        SMTP_BYTES_MSG_PER_SEC_COUNTER,
        0,
        -3,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_MSG_PER_SEC_OFFSET
    },

    {   // SmtpMsgRcvdTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_RCVD_TTL_COUNTER,
        0,
        SMTP_MSG_RCVD_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_RCVD_TTL_OFFSET
    },

    {   // SmtpMsgRcvdPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_RCVD_PER_SEC_COUNTER,
        0,
        SMTP_MSG_RCVD_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_MSG_RCVD_PER_SEC_OFFSET
    },

    {   // SmtpAvgRcptsPerMsgRcvd
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_AVG_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        SMTP_AVG_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        SMTP_AVG_RCPTS_PER_MSG_RCVD_OFFSET
    },

    {   // SmtpBaseAvgRcptsPerMsgRcvd
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BASE_AVG_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        SMTP_BASE_AVG_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(DWORD),
        SMTP_BASE_AVG_RCPTS_PER_MSG_RCVD_OFFSET
    },

    {   // SmtpPctLclRcptsPerMsgRcvd
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_PCT_LCL_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        SMTP_PCT_LCL_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        SMTP_PCT_LCL_RCPTS_PER_MSG_RCVD_OFFSET
    },

    {   // SmtpBasePctLclRcptsPerMsgRcvd
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BASE_PCT_LCL_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        SMTP_BASE_PCT_LCL_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(DWORD),
        SMTP_BASE_PCT_LCL_RCPTS_PER_MSG_RCVD_OFFSET
    },

    {   // SmtpPctRmtRcptsPerMsgRcvd
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_PCT_RMT_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        SMTP_PCT_RMT_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        SMTP_PCT_RMT_RCPTS_PER_MSG_RCVD_OFFSET
    },

    {   // SmtpBasePctRmtRcptsPerMsgRcvd
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BASE_PCT_RMT_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        SMTP_BASE_PCT_RMT_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(DWORD),
        SMTP_BASE_PCT_RMT_RCPTS_PER_MSG_RCVD_OFFSET
    },

    {   // SmtpMsgRcvdRefusedSize
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_RCVD_REFUSED_SIZE_COUNTER,
        0,
        SMTP_MSG_RCVD_REFUSED_SIZE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_RCVD_REFUSED_SIZE_OFFSET
    },

    {   // SmtpMsgRcvdRefusedCAddr
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_RCVD_REFUSED_CADDR_COUNTER,
        0,
        SMTP_MSG_RCVD_REFUSED_CADDR_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_RCVD_REFUSED_CADDR_OFFSET
    },
    
    {   // SmtpMsgRcvdRefusedMail
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_RCVD_REFUSED_MAIL_COUNTER,
        0,
        SMTP_MSG_RCVD_REFUSED_MAIL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_RCVD_REFUSED_MAIL_OFFSET
    },

    {   // SmtpMsgDlvrTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_DLVR_TTL_COUNTER,
        0,
        SMTP_MSG_DLVR_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_DLVR_TTL_OFFSET
    },

    {   // SmtpMsgDlvrPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_DLVR_PER_SEC_COUNTER,
        0,
        SMTP_MSG_DLVR_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_MSG_DLVR_PER_SEC_OFFSET
    },

    {   // SmtpMsgDlvrRetriesTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_DLVR_RETRIES_TTL_COUNTER,
        0,
        SMTP_MSG_DLVR_RETRIES_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_DLVR_RETRIES_TTL_OFFSET
    },

    {   // SmtpAvgRetriesPerMsgDlvr
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_AVG_RETRIES_PER_MSG_DLVR_COUNTER,
        0,
        SMTP_AVG_RETRIES_PER_MSG_DLVR_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        SMTP_AVG_RETRIES_PER_MSG_DLVR_OFFSET
    },

    {   // SmtpBaseAvgRetriesPerMsgDlvr
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BASE_AVG_RETRIES_PER_MSG_DLVR_COUNTER,
        0,
        SMTP_BASE_AVG_RETRIES_PER_MSG_DLVR_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(DWORD),
        SMTP_BASE_AVG_RETRIES_PER_MSG_DLVR_OFFSET
    },

    {   // SmtpMsgFwdTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_FWD_TTL_COUNTER,
        0,
        SMTP_MSG_FWD_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_FWD_TTL_OFFSET
    },

    {   // SmtpMsgFwdPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_FWD_PER_SEC_COUNTER,
        0,
        SMTP_MSG_FWD_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_MSG_FWD_PER_SEC_OFFSET
    },

    {   // SmtpNdrGenerated
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_NDR_GENERATED_COUNTER,
        0,
        SMTP_NDR_GENERATED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_NDR_GENERATED_OFFSET
    },

    {   // SmtpLocalQLength
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_LOCALQ_LENGTH_COUNTER,
        0,
        SMTP_LOCALQ_LENGTH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_LOCALQ_LENGTH_OFFSET
    },

    {   // SmtpRetryQLength
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_RETRYQ_LENGTH_COUNTER,
        0,
        SMTP_RETRYQ_LENGTH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_RETRYQ_LENGTH_OFFSET
    },

    {   // SmtpNumMailFileHandles
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_NUM_MAILFILE_HANDLES_COUNTER,
        0,
        SMTP_NUM_MAILFILE_HANDLES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_NUM_MAILFILE_HANDLES_OFFSET
    },

    {   // SmtpNumQueueFileHandles
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_NUM_QUEUEFILE_HANDLES_COUNTER,
        0,
        SMTP_NUM_QUEUEFILE_HANDLES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_NUM_QUEUEFILE_HANDLES_OFFSET
    },

    {   // SmtpCatQLength
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CATQ_LENGTH_COUNTER,
        0,
        SMTP_CATQ_LENGTH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CATQ_LENGTH_OFFSET
    },

    {   // SmtpMsgSentTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_SENT_TTL_COUNTER,
        0,
        SMTP_MSG_SENT_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_SENT_TTL_OFFSET
    },

    {   // SmtpMsgSentPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_SENT_PER_SEC_COUNTER,
        0,
        SMTP_MSG_SENT_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_MSG_SENT_PER_SEC_OFFSET
    },

    {   // SmtpMsgSendRetriesTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_SEND_RETRIES_TTL_COUNTER,
        0,
        SMTP_MSG_SEND_RETRIES_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_SEND_RETRIES_TTL_OFFSET
    },

    {   // SmtpAvgRetriesPerMsgSend
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_AVG_RETRIES_PER_MSG_SEND_COUNTER,
        0,
        SMTP_AVG_RETRIES_PER_MSG_SEND_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        SMTP_AVG_RETRIES_PER_MSG_SEND_OFFSET
    },

    {   // SmtpBaseAvgRetriesPerMsgSend
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BASE_AVG_RETRIES_PER_MSG_SEND_COUNTER,
        0,
        SMTP_BASE_AVG_RETRIES_PER_MSG_SEND_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(DWORD),
        SMTP_BASE_AVG_RETRIES_PER_MSG_SEND_OFFSET
    },

    {   // SmtpAvgRcptsPerMsgSent
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_AVG_RCPTS_PER_MSG_SENT_COUNTER,
        0,
        SMTP_AVG_RCPTS_PER_MSG_SENT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        SMTP_AVG_RCPTS_PER_MSG_SENT_OFFSET
    },

    {   // SmtpBaseAvgRcptsPerMsgSent
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BASE_AVG_RCPTS_PER_MSG_SENT_COUNTER,
        0,
        SMTP_BASE_AVG_RCPTS_PER_MSG_SENT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(DWORD),
        SMTP_BASE_AVG_RCPTS_PER_MSG_SENT_OFFSET
    },

    {   // SmtpRemoteQLength
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_REMOTEQ_LENGTH_COUNTER,
        0,
        SMTP_REMOTEQ_LENGTH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_REMOTEQ_LENGTH_OFFSET
    },

    {   // SmtpDnsQueriesTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_DNS_QUERIES_TTL_COUNTER,
        0,
        SMTP_DNS_QUERIES_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_DNS_QUERIES_TTL_OFFSET
    },

    {   // SmtpDnsQueriesPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_DNS_QUERIES_PER_SEC_COUNTER,
        0,
        SMTP_DNS_QUERIES_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_DNS_QUERIES_PER_SEC_OFFSET
    },

    {   // SmtpRemoteRetryQueueLemgth
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_REMOTE_RETRY_QUEUE_LENGTH_COUNTER,
        0,
        SMTP_REMOTE_RETRY_QUEUE_LENGTH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_REMOTE_RETRY_QUEUE_LENGTH_OFFSET
    },

    {   // SmtpConnInTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CONN_IN_TTL_COUNTER,
        0,
        SMTP_CONN_IN_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CONN_IN_TTL_OFFSET
    },

    {   // SmtpConnInCurr
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CONN_IN_CURR_COUNTER,
        0,
        SMTP_CONN_IN_CURR_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CONN_IN_CURR_OFFSET
    },

    {   // SmtpConnOutTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CONN_OUT_TTL_COUNTER,
        0,
        SMTP_CONN_OUT_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CONN_OUT_TTL_OFFSET
    },

    {   // SmtpConnOutCurr
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CONN_OUT_CURR_COUNTER,
        0,
        SMTP_CONN_OUT_CURR_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CONN_OUT_CURR_OFFSET
    },

    {   // SmtpConnOutRefused
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CONN_OUT_REFUSED_COUNTER,
        0,
        SMTP_CONN_OUT_REFUSED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CONN_OUT_REFUSED_OFFSET
    },

    {   // SmtpErrTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_ERR_TTL_COUNTER,
        0,
        SMTP_ERR_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_ERR_TTL_OFFSET
    },

    {   // SmtpErrPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_ERR_PER_SEC_COUNTER,
        0,
        SMTP_ERR_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_ERR_PER_SEC_OFFSET
    },

    {   // SmtpDirectoryDropsTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_DIR_DROPS_TTL_COUNTER,
        0,
        SMTP_DIR_DROPS_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_DIR_DROPS_OFFSET
    },

    {   // SmtpDirectoryDropsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_DIR_DROPS_PER_SEC_COUNTER,
        0,
        SMTP_DIR_DROPS_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_DIR_DROPS_PER_SEC_OFFSET
    },

    {   // SmtpRoutingTblLookupsTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_RT_LOOKUPS_TTL_COUNTER,
        0,
        SMTP_RT_LOOKUPS_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_RT_LOOKUPS_OFFSET
    },

    {   // SmtpRoutingTblLookupsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_RT_LOOKUPS_PER_SEC_COUNTER,
        0,
        SMTP_RT_LOOKUPS_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_RT_LOOKUPS_PER_SEC_OFFSET
    },

    {   // SmtpETRNMsgsTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_ETRN_MSGS_TTL_COUNTER,
        0,
        SMTP_ETRN_MSGS_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_ETRN_MSGS_OFFSET
    },

    {   // SmtpETRNMsgsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_ETRN_MSGS_PER_SEC_COUNTER,
        0,
        SMTP_ETRN_MSGS_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_ETRN_MSGS_PER_SEC_OFFSET
    },

    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_BADMAIL_NO_RECIPIENTS_COUNTER,
        0,
        SMTP_MSG_BADMAIL_NO_RECIPIENTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_BADMAIL_NO_RECIPIENTS_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_BADMAIL_HOP_COUNT_EXCEEDED_COUNTER,
        0,
        SMTP_MSG_BADMAIL_HOP_COUNT_EXCEEDED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_BADMAIL_HOP_COUNT_EXCEEDED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_BADMAIL_FAILURE_GENERAL_COUNTER,
        0,
        SMTP_MSG_BADMAIL_FAILURE_GENERAL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_BADMAIL_FAILURE_GENERAL_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_BADMAIL_BAD_PICKUP_FILE_COUNTER,   
        0,
        SMTP_MSG_BADMAIL_BAD_PICKUP_FILE_COUNTER,   
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_BADMAIL_BAD_PICKUP_FILE_OFFSET     
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_BADMAIL_EVENT_COUNTER,            
        0,
        SMTP_MSG_BADMAIL_EVENT_COUNTER,              
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_BADMAIL_EVENT_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_BADMAIL_NDR_OF_DSN_COUNTER,
        0,
        SMTP_MSG_BADMAIL_NDR_OF_DSN_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_BADMAIL_NDR_OF_DSN_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_PENDING_ROUTING_COUNTER,   
        0,
        SMTP_MSG_PENDING_ROUTING_COUNTER,   
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_PENDING_ROUTING_OFFSET         
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_PENDING_UNREACHABLE_LINK_COUNTER,
        0,
        SMTP_MSG_PENDING_UNREACHABLE_LINK_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_PENDING_UNREACHABLE_LINK_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_SUBMITTED_MESSAGES_COUNTER,
        0,
        SMTP_SUBMITTED_MESSAGES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_SUBMITTED_MESSAGES_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_DSN_FAILURES_COUNTER,
        0,
        SMTP_DSN_FAILURES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_DSN_FAILURES_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_IN_LOCAL_DELIVERY_COUNTER,   
        0,
        SMTP_MSG_IN_LOCAL_DELIVERY_COUNTER,   
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_IN_LOCAL_DELIVERY_OFFSET   
    },
    {   // CatSubmissions
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_SUBMISSIONS_COUNTER,
        0,
        SMTP_CAT_SUBMISSIONS_COUNTER,
        
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CATSUBMISSIONS_OFFSET
    },
    {   // CatSubmissionsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_SUBMISSIONS_PER_SEC_COUNTER,
        0,
        SMTP_CAT_SUBMISSIONS_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_CATSUBMISSIONS_OFFSET
    },
    {   // CatCompletions
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_COMPLETIONS_COUNTER,
        0,
        SMTP_CAT_COMPLETIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CATCOMPLETIONS_OFFSET
    },
    {   // CatCompletionsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_COMPLETIONS_PER_SEC_COUNTER,
        0,
        SMTP_CAT_COMPLETIONS_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_CATCOMPLETIONS_OFFSET
    },
    {   // CatCurrentCategorizations
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_CURRENT_CATEGORIZATIONS_COUNTER,
        0,
        SMTP_CAT_CURRENT_CATEGORIZATIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CURRENTCATEGORIZATIONS_OFFSET
    },
    {   // CatSucceededCategorizations
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_SUCCEEDED_CATEGORIZATIONS_COUNTER,
        0,
        SMTP_CAT_SUCCEEDED_CATEGORIZATIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_SUCCEEDEDCATEGORIZATIONS_OFFSET
    },
    {   // CatHardFailures
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_HARD_FAILURES_COUNTER,
        0,
        SMTP_CAT_HARD_FAILURES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_HARDFAILURECATEGORIZATIONS_OFFSET
    },
    {   // CatRetryFailures
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RETRY_FAILURES_COUNTER,
        0,
        SMTP_CAT_RETRY_FAILURES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_RETRYFAILURECATEGORIZATIONS_OFFSET
    },
    {   // CatOutOfMemoryFailures
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RETRY_OUTOFMEMORY_COUNTER,
        0,
        SMTP_CAT_RETRY_OUTOFMEMORY_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_RETRYOUTOFMEMORY_OFFSET
    },
    {   // CatDsLogonFailures
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RETRY_DSLOGON_COUNTER,
        0,
        SMTP_CAT_RETRY_DSLOGON_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_RETRYDSLOGON_OFFSET
    },
    {   // CatDsConnectionFailures
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RETRY_DSCONNECTION_COUNTER,
        0,
        SMTP_CAT_RETRY_DSCONNECTION_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_RETRYDSCONNECTION_OFFSET
    },
    {   // CatGenericRetryFailures
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RETRY_GENERIC_COUNTER,
        0,
        SMTP_CAT_RETRY_GENERIC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_RETRYDSLOGON_OFFSET
    },
    {   // CatMsgsOut
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_MSGS_OUT_COUNTER,
        0,
        SMTP_CAT_MSGS_OUT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MESSAGESSUBMITTEDTOQUEUEING_OFFSET
    },
    {   // CatMsgsCreated
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_MSGS_CREATED_COUNTER,
        0,
        SMTP_CAT_MSGS_CREATED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MESSAGESCREATED_OFFSET
    },
    {   // CatMsgsAborted
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_MSGS_ABORTED_COUNTER,
        0,
        SMTP_CAT_MSGS_ABORTED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MESSAGESABORTED_OFFSET
    },
    {   // CatRecipsPreCat
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RECIPS_PRECAT_COUNTER,
        0,
        SMTP_CAT_RECIPS_PRECAT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_PRECATRECIPIENTS_OFFSET
    },
    {   // CatRecipsPostCat
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RECIPS_POSTCAT_COUNTER,
        0,
        SMTP_CAT_RECIPS_POSTCAT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_POSTCATRECIPIENTS_OFFSET
    },
    {   // CatRecipsNDRd
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RECIPS_NDRD_COUNTER,
        0,
        SMTP_CAT_RECIPS_NDRD_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_NDRDRECIPIENTS_OFFSET
    },
    {   // CatRecipsUnresolved
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RECIPS_UNRESOLVED_COUNTER,
        0,
        SMTP_CAT_RECIPS_UNRESOLVED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_UNRESOLVEDRECIPIENTS_OFFSET
    },
    {   // CatRecipsAmbiguous
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RECIPS_AMBIGUOUS_COUNTER,
        0,
        SMTP_CAT_RECIPS_AMBIGUOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_AMBIGUOUSRECIPIENTS_OFFSET
    },
    {   // CatRecipsIllegal
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RECIPS_ILLEGAL_COUNTER,
        0,
        SMTP_CAT_RECIPS_ILLEGAL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_ILLEGALRECIPIENTS_OFFSET
    },
    {   // CatRecipsLoop
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RECIPS_LOOP_COUNTER,
        0,
        SMTP_CAT_RECIPS_LOOP_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_LOOPRECIPIENTS_OFFSET
    },
    {   // CatRecipsGenericFailure
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RECIPS_GENERICFAILURE_COUNTER,
        0,
        SMTP_CAT_RECIPS_GENERICFAILURE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_GENERICFAILURERECIPIENTS_OFFSET
    },
    {   // CatRecipsInMemory
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RECIPS_INMEMORY_COUNTER,
        0,
        SMTP_CAT_RECIPS_INMEMORY_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_RECIPSINMEMORY_OFFSET
    },
    {   // CatSendersUnresolved
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_SENDERS_UNRESOLVED_COUNTER,
        0,
        SMTP_CAT_SENDERS_UNRESOLVED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_UNRESOLVEDSENDERS_OFFSET
    },
    {   // CatSendersAmbiguous
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_SENDERS_AMBIGUOUS_COUNTER,
        0,
        SMTP_CAT_SENDERS_AMBIGUOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_AMBIGUOUSSENDERS_OFFSET
    },
    {   // CatAddressLookups
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_ADDRESS_LOOKUPS_COUNTER,
        0,
        SMTP_CAT_ADDRESS_LOOKUPS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_ADDRESSLOOKUPS_OFFSET
    },
    {   // CatAddressLookupsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_ADDRESS_LOOKUPS_PER_SEC_COUNTER,
        0,
        SMTP_CAT_ADDRESS_LOOKUPS_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_ADDRESSLOOKUPS_OFFSET
    },
    {   // CatAddressCompletions
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_ADDRESS_LOOKUP_COMPLETIONS_COUNTER,
        0,
        SMTP_CAT_ADDRESS_LOOKUP_COMPLETIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_ADDRESSLOOKUPCOMPLETIONS_OFFSET
    },
    {   // CatAddressCompletionsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_ADDRESS_LOOKUP_COMPLETIONS_PER_SEC_COUNTER,
        0,
        SMTP_CAT_ADDRESS_LOOKUP_COMPLETIONS_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_ADDRESSLOOKUPCOMPLETIONS_OFFSET
    },
    {   // CatAddressLookupsNotFound
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_ADDRESS_LOOKUPS_NOT_FOUND_COUNTER,
        0,
        SMTP_CAT_ADDRESS_LOOKUPS_NOT_FOUND_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_ADDRESSLOOKUPSNOTFOUND_OFFSET
    },
    {   // CatMailMsgDuplicateCollisions
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_MAILMSG_DUPLICATE_COLLISIONS_COUNTER,
        0,
        SMTP_CAT_MAILMSG_DUPLICATE_COLLISIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MAILMSGDUPLICATECOLLISIONS_OFFSET
    },
    {   // CatLDAPConnections
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_CONNECTIONS_COUNTER,
        0,
        SMTP_CAT_LDAP_CONNECTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CONNECTIONS_OFFSET
    },
    {   // CatLDAPConnectionFailures
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_CONNECTION_FAILURES_COUNTER,
        0,
        SMTP_CAT_LDAP_CONNECTION_FAILURES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CONNECTFAILURES_OFFSET
    },
    {   // CatLDAPOpenConnections
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_OPEN_CONNECTIONS_COUNTER,
        0,
        SMTP_CAT_LDAP_OPEN_CONNECTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_OPENCONNECTIONS_OFFSET
    },
    {   // CatLDAPBinds
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_BINDS_COUNTER,
        0,
        SMTP_CAT_LDAP_BINDS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_BINDS_OFFSET
    },
    {   // CatLDAPBindFailures
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_BIND_FAILURES_COUNTER,
        0,
        SMTP_CAT_LDAP_BIND_FAILURES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_BINDFAILURES_OFFSET
    },
    {   // CatLDAPSearches
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_SEARCHES_COUNTER,
        0,
        SMTP_CAT_LDAP_SEARCHES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_SEARCHES_OFFSET
    },
    {   // CatLDAPSearchesPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_SEARCHES_PER_SEC_COUNTER,
        0,
        SMTP_CAT_LDAP_SEARCHES_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_SEARCHES_OFFSET
    },
    {   // CatLDAPPagedSearches
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_PAGED_SEARCHES_COUNTER,
        0,
        SMTP_CAT_LDAP_PAGED_SEARCHES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_PAGEDSEARCHES_OFFSET
    },
    {   // CatLDAPSearchFailures
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_SEARCH_FAILURES_COUNTER,
        0,
        SMTP_CAT_LDAP_SEARCH_FAILURES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_SEARCHFAILURES_OFFSET
    },
    {   // CatLDAPPagedSearchFailures
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_PAGED_SEARCH_FAILURES_COUNTER,
        0,
        SMTP_CAT_LDAP_PAGED_SEARCH_FAILURES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_PAGEDSEARCHFAILURES_OFFSET
    },
    {   // CatLDAPSearchesCompleted
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_SEARCHES_COMPLETED_COUNTER,
        0,
        SMTP_CAT_LDAP_SEARCHES_COMPLETED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_SEARCHESCOMPLETED_OFFSET
    },
    {   // CatLDAPSearchesCompletedPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_SEARCHES_COMPLETED_PER_SEC_COUNTER,
        0,
        SMTP_CAT_LDAP_SEARCHES_COMPLETED_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_SEARCHESCOMPLETED_OFFSET
    },
    {   // CatLDAPPagedSearchesCompleted
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_PAGED_SEARCHES_COMPLETED_COUNTER,
        0,
        SMTP_CAT_LDAP_PAGED_SEARCHES_COMPLETED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_PAGEDSEARCHESCOMPLETED_OFFSET
    },
    {   // CatLDAPSearchesCompeltedFailure
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_SEARCHES_COMPLETED_FAILURE_COUNTER,
        0,
        SMTP_CAT_LDAP_SEARCHES_COMPLETED_FAILURE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_SEARCHCOMPLETIONFAILURES_OFFSET
    },
    {   // CatLDAPPagedSearchesCompletedFailure
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_PAGED_SEARCHES_COMPLETED_FAILURE_COUNTER,
        0,
        SMTP_CAT_LDAP_PAGED_SEARCHES_COMPLETED_FAILURE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_PAGEDSEARCHCOMPLETIONFAILURES_OFFSET
    },
    {   // CatLDAPGeneralCompletionFailure
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_GENERAL_COMPLETION_FAILURES_COUNTER,
        0,
        SMTP_CAT_LDAP_GENERAL_COMPLETION_FAILURES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_GENERALCOMPLETIONFAILURES_OFFSET
    },
    {   // CatLDAPAbandonedSearches
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_ABANDONED_SEARCHES_COUNTER,
        0,
        SMTP_CAT_LDAP_ABANDONED_SEARCHES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_ABANDONEDSEARCHES_OFFSET
    },
    {   // CatLDAPPendingSearches
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_PENDING_SEARCHES_COUNTER,
        0,
        SMTP_CAT_LDAP_PENDING_SEARCHES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_PENDINGSEARCHES_OFFSET
    }
};


// Initialize the Instance Data Structure.  Parts will be updated at collection time.

SMTP_INSTANCE_DEFINITION         SmtpInstanceDefinition =
{
    {
        sizeof(SMTP_INSTANCE_DEFINITION),   // ByteLength
        0,                                  // ParentObjectTitleIndex
        0,                                  // ParentObjectInstance
        PERF_NO_UNIQUE_ID,                  // UniqueID
        sizeof(PERF_INSTANCE_DEFINITION),   // OffsetToName
        0                                   // NameLength (will be updated)
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpctrs\perfutil.c ===
//#---------------------------------------------------------------
//  File:		perfutil.c
//
//  Synopsis:	This file implements the utility routines used
//				to construct the common parts of a
//				PERF_INSTANCE_DEFINITION (see winperf.h) and
//				perform event logging functions.
//
//	Copyright (C) 1995 Microsoft Corporation
//	All rights reserved.
//
//  Authors:	toddch - based on msn sources by rkamicar, Russ Blake
//----------------------------------------------------------------
#ifdef	THISFILE
#undef	THISFILE
#endif
static	const char	__szTraceSourceFile[] = __FILE__;
#define	THISFILE	__szTraceSourceFile

#define NOTRACE
//
//  include files
//
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "smtpctrs.h"	// error message definition
#include "perfmsg.h"
#include "perfutil.h"

//
// Global data definitions.
//

DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";	// pointer to null string

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT	1
#define DELIMITER   2
#define INVALID	3

#define EvalThisChar(c,d) (\
	(c == d) ? DELIMITER : \
	(c == 0) ? DELIMITER : \
	(c < (WCHAR)'0') ? INVALID : \
	(c > (WCHAR)'9') ? INVALID : \
	DIGIT)

DWORD
GetQueryType (
	IN LPWSTR lpValue
)
/*++

GetQueryType

	returns the type of query described in the lpValue string so that
	the appropriate processing method may be used

Arguments

	IN lpValue
		string passed to PerfRegQuery Value for processing

Return Value

	QUERY_GLOBAL
		if lpValue == 0 (null pointer)
		lpValue == pointer to Null string
		lpValue == pointer to "Global" string

	QUERY_FOREIGN
		if lpValue == pointer to "Foriegn" string

	QUERY_COSTLY
		if lpValue == pointer to "Costly" string

	otherwise:

	QUERY_ITEMS

--*/
{
	WCHAR   *pwcArgChar, *pwcTypeChar;
	BOOL	bFound;

	if (lpValue == 0) {
		return QUERY_GLOBAL;
	} else if (*lpValue == 0) {
		return QUERY_GLOBAL;
	}

	// check for "Global" request

	pwcArgChar = lpValue;
	pwcTypeChar = GLOBAL_STRING;
	bFound = TRUE;  // assume found until contradicted

	// check to the length of the shortest string

	while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
		if (*pwcArgChar++ != *pwcTypeChar++) {
			bFound = FALSE; // no match
			break;		// bail out now
		}
	}

	if (bFound) return QUERY_GLOBAL;

	// check for "Foreign" request

	pwcArgChar = lpValue;
	pwcTypeChar = FOREIGN_STRING;
	bFound = TRUE;  // assume found until contradicted

	// check to the length of the shortest string

	while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
		if (*pwcArgChar++ != *pwcTypeChar++) {
			bFound = FALSE; // no match
			break;		// bail out now
		}
	}

	if (bFound) return QUERY_FOREIGN;

	// check for "Costly" request

	pwcArgChar = lpValue;
	pwcTypeChar = COSTLY_STRING;
	bFound = TRUE;  // assume found until contradicted

	// check to the length of the shortest string

	while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
		if (*pwcArgChar++ != *pwcTypeChar++) {
			bFound = FALSE; // no match
			break;		// bail out now
		}
	}

	if (bFound) return QUERY_COSTLY;

	// if not Global and not Foreign and not Costly,
	// then it must be an item list

	return QUERY_ITEMS;

}


BOOL
IsNumberInUnicodeList (
	IN DWORD   dwNumber,
	IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

	IN dwNumber
		DWORD number to find in list

	IN lpwszUnicodeList
		Null terminated, Space delimited list of decimal numbers

Return Value:

	TRUE:
			dwNumber was found in the list of unicode number strings

	FALSE:
			dwNumber was not found in the list.

--*/
{
	DWORD   dwThisNumber;
	WCHAR   *pwcThisChar;
	BOOL	bValidNumber;
	BOOL	bNewItem;
	WCHAR   wcDelimiter;	// could be an argument to be more flexible

	if (lpwszUnicodeList == 0) return FALSE;	// null pointer, # not founde

	pwcThisChar = lpwszUnicodeList;
	dwThisNumber = 0;
	wcDelimiter = (WCHAR)' ';
	bValidNumber = FALSE;
	bNewItem = TRUE;

	while (TRUE) {
		switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
			case DIGIT:
				// if this is the first digit after a delimiter, then
				// set flags to start computing the new number
				if (bNewItem) {
					bNewItem = FALSE;
					bValidNumber = TRUE;
				}
				if (bValidNumber) {
					dwThisNumber *= 10;
					dwThisNumber += (*pwcThisChar - (WCHAR)'0');
				}
				break;

			case DELIMITER:
				// a delimter is either the delimiter character or the
				// end of the string ('\0') if when the delimiter has been
				// reached a valid number was found, then compare it to the
				// number from the argument list. if this is the end of the
				// string and no match was found, then return.
				//
				if (bValidNumber) {
					if (dwThisNumber == dwNumber) return TRUE;
					bValidNumber = FALSE;
				}
				if (*pwcThisChar == 0) {
					return FALSE;
				} else {
					bNewItem = TRUE;
					dwThisNumber = 0;
				}
				break;

			case INVALID:
				// if an invalid character was encountered, ignore all
				// characters up to the next delimiter and then start fresh.
				// the invalid number is not compared.
				bValidNumber = FALSE;
				break;

			default:
				break;

		}
		pwcThisChar++;
	}

}   // IsNumberInUnicodeList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpdbg\makefile.inc ===
$(O)\seo.h $(O)\seo_i.c : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(O)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqueue.h $(O)\aqueue_i.c : $(STAXINC)\export\aqueue.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqueue_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqueue_i.c \
    -header $@ \
    -tlb $(O)\aqueue.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpdisp.h $(O)\smtpdisp_i.c : $(STAXINC)\export\smtpdisp.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpdisp_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpdisp_i.c \
    -header $@ \
    -tlb $(O)\smtpdisp.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\imsg.h $(O)\imsg_i.c : $(STAXINC)\export\imsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\imsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\imsg_i.c \
    -header $@ \
    -tlb $(O)\imsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpevent.h $(O)\smtpevent_i.c : $(STAXINC)\export\smtpevent.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpevent_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpevent_i.c \
    -header $@ \
    -tlb $(O)\smtpevent.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\cdo.h $(O)\cdo_i.c : $(STAXINC)\cdo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\cdo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\cdo_i.c \
    -header $@ \
    -tlb $(O)\cdo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\wstgado.h $(O)\wstgado_i.c : $(STAXINC)\export\wstgado.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\wstgado_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\wstgado_i.c \
    -header $@ \
    -tlb $(O)\wstagado.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\pe_disp.h $(O)\pe_disp_i.c : $(STAXINC)\export\pe_disp.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\pe_disp_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\pe_disp_i.c \
    -header $@ \
    -tlb $(O)\pe_disp.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpsvc.h $(O)\smtpsvc_s.c : ..\smtpsvc.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -oldnames \
    -client none \
    -sstub $(O)\smtpsvc_s.c \
    -header $@ \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

!ifndef INETAMSG_MC_PATH
INETAMSG_MC_PATH=..\..\..\inc
!endif
$(O)\smtpmsg.h $(O)\smtpmsg.rc $(O)\msg00001.bin: $(SERVER)\smtpmsg.mc $(INETAMSG_MC_PATH)\inetamsg.mc $(STAXINC)\export\aqerr.mc
    copy /a $(INETAMSG_MC_PATH)\inetamsg.mc + /a $(SERVER)\smtpmsg.mc + /a $(STAXINC)\export\aqerr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\smtpmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\smtpmsg.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpdbg\smtpdbg.h ===
//-----------------------------------------------------------------------------
//
//
//  File: smtpdbg.h
//
//  Description:  Header file for SMTP debug extension
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/4/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __SMTPDBG_H__
#define __SMTPDBG_H__

#define BUILDING_SMTP_DEBUG_EXTENTIONS
#define _ANSI_UNICODE_STRINGS_DEFINED_
#define INCL_INETSRV_INCS

#include <smtpinc.h>

//
// ATL includes
//
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"

extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL

//
// SEO includes
//
#include <seo.h>
#include <seolib.h>
#include <memory.h>
#include <smtpdbg.h>
#include <smtpcli.hxx>
#include <smtpinst.hxx>
#include <stats.hxx>
#include <dropdir.hxx>
#include <smtpout.hxx>

#include <dbgdumpx.h>

#endif //__SMTPDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpdbg\smtpflds.h ===
//-----------------------------------------------------------------------------
//
//
//  File: smtpdlfs.h
//
//  Description:  Header file that defines structures to be dumped by the SMTP
//      debugger extension.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      2/22/99 - GPulla created
//      7/4/99 - MikeSwa Updated and checked in 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include <_dbgdump.h>

BEGIN_ENUM_DESCRIPTOR(STATE_ENUM)
    ENUM_VALUE2(EHLO, "EHLO")
    ENUM_VALUE2(HELO, "HELO")	
    ENUM_VALUE2(RCPT, "RCPT")
    ENUM_VALUE2(MAIL, "MAIL")
    ENUM_VALUE2(AUTH, "AUTH")
    ENUM_VALUE2(DATA, "DATA")
    ENUM_VALUE2(STARTTLS, "STARTTLS")
    ENUM_VALUE2(TLS,  "TLS")
    ENUM_VALUE2(QUIT, "QUIT")
    ENUM_VALUE2(RSET, "RSET")
    ENUM_VALUE2(NOOP, "NOOP")
    ENUM_VALUE2(VRFY, "VRFY")
    ENUM_VALUE2(ETRN, "ETRN")
    ENUM_VALUE2(TURN, "TURN")
    ENUM_VALUE2(BDAT, "BDAT")
    ENUM_VALUE2(HELP, "HELP")
    ENUM_VALUE2(LAST_SMTP_STATE, "LAST_SMTP_STATE")
END_ENUM_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(OutboundConnectionFlags)
    BIT_MASK_VALUE2(SIZE_OPTION, "SIZE_OPTION")
    BIT_MASK_VALUE2(PIPELINE_OPTION, "PIPELINE_OPTION")
    BIT_MASK_VALUE2(EBITMIME_OPTION, "EBITMIME_OPTION")
    BIT_MASK_VALUE2(SMARTHOST_OPTION, "SMARTHOST_OPTION")
    BIT_MASK_VALUE2(DSN_OPTION, "DSN_OPTION")
    BIT_MASK_VALUE2(TLS_OPTION, "TLS_OPTION")
    BIT_MASK_VALUE2(AUTH_NTLM, "AUTH_NTLM")
    BIT_MASK_VALUE2(AUTH_CLEARTEXT, "AUTH_CLEARTEXT")
    BIT_MASK_VALUE2(ETRN_SENT, "ETRN_SENT")
    BIT_MASK_VALUE2(ETRN_OPTION, "ETRN_OPTION")
    BIT_MASK_VALUE2(SASL_OPTION, "SASL_OPTION")
    BIT_MASK_VALUE2(CHUNKING_OPTION, "CHUNKING_OPTION")
    BIT_MASK_VALUE2(BINMIME_OPTION, "BINMIME_OPTION")
    BIT_MASK_VALUE2(ENHANCEDSTATUSCODE_OPTION, "ENHANCEDSTATUSCODE_OPTION")
    BIT_MASK_VALUE2(AUTH_GSSAPI, "AUTH_GSSAPI")
    BIT_MASK_VALUE2(AUTH_DIGEST, "AUTH_DIGEST")
    BIT_MASK_VALUE2(ETRN_ONLY_OPTION, "ETRN_ONLY_OPTION")
    BIT_MASK_VALUE2(STARTTLS_OPTION, "STARTTLS_OPTION")
END_BIT_MASK_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(Connection_Object)
    FIELD3(FieldTypeClassSignature, SMTP_CONNECTION, m_signature)
    FIELD4(FieldTypeEnum, SMTP_CONNECTION, m_State, GET_ENUM_DESCRIPTOR(STATE_ENUM))
    FIELD3(FieldTypeBoolean, SMTP_CONNECTION, m_HelloSent)
    FIELD3(FieldTypeBoolean, SMTP_CONNECTION, m_RecvdMailCmd)
    FIELD3(FieldTypeBoolean, SMTP_CONNECTION, m_RecvdRcptCmd)
    FIELD3(FieldTypeBoolean, SMTP_CONNECTION, m_RecvdAuthCmd)
    FIELD3(FieldTypePointer, SMTP_CONNECTION, m_precvBuffer)
    FIELD3(FieldTypeDword,  SMTP_CONNECTION, m_cbParsable)
    FIELD3(FieldTypeDword,  SMTP_CONNECTION, m_cbReceived)
    FIELD3(FieldTypeDword,  SMTP_CONNECTION, m_cbCurrentWriteBuffer)
    FIELD3(FieldTypeDword,  SMTP_CONNECTION, m_cbRecvBufferOffset)
    FIELD3(FieldTypePointer, SMTP_CONNECTION, m_pFileWriteBuffer)
    FIELD3(FieldTypePointer, SMTP_CONNECTION, m_pOutputBuffer)
    FIELD3(FieldTypeBool, SMTP_CONNECTION, m_fNegotiatingSSL)
    FIELD3(FieldTypeBool, SMTP_CONNECTION, m_SecurePort)
    FIELD3(FieldTypeBool, SMTP_CONNECTION, m_fIsChunkComplete)
    FIELD3(FieldTypeBool, SMTP_CONNECTION, m_InHeader)
    FIELD3(FieldTypeBool, SMTP_CONNECTION, m_TimeToRewriteHeader)
    FIELD3(FieldTypeDword, SMTP_CONNECTION, m_SessionSize)
    FIELD3(FieldTypeDword, SMTP_CONNECTION, m_TotalMsgSize)
    FIELD3(FieldTypeDword, SMTP_CONNECTION, m_cbMaxRecvBuffer)
    FIELD3(FieldTypePointer, SMTP_CONNECTION, m_pInstance)
    FIELD3(FieldTypeDword, SMTP_CONNECTION, m_MailBodyError)
    FIELD3(FieldTypeDword, SMTP_CONNECTION, m_nBytesRemainingInChunk)
    FIELD3(FieldTypeDword, SMTP_CONNECTION, m_cbTempBDATLen)
    //FIELD3(FieldTypeDword,  SMTP_CONNECTION, m_WritesPendingCount)
    //FIELD3(FieldTypeDword,  SMTP_CONNECTION, m_SuspectedWriteError)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(Smtp_Server_Stats)
//	FIELD3(FieldTypeDword, SMTP_SERVER_STATISTICS, m_signature)
    FIELD3(FieldTypePointer, SMTP_SERVER_STATISTICS, m_pInstance)
END_FIELD_DESCRIPTOR


BEGIN_FIELD_DESCRIPTOR(Smtp_Server_Inst)
    FIELD3(FieldTypeClassSignature, SMTP_SERVER_INSTANCE, m_signature)
    FIELD3(FieldTypePStr, SMTP_SERVER_INSTANCE, m_szMailQueueDir)
    FIELD3(FieldTypePStr, SMTP_SERVER_INSTANCE, m_szMailPickupDir)
    FIELD3(FieldTypePStr, SMTP_SERVER_INSTANCE, m_szMailDropDir)
    FIELD3(FieldTypeStruct, SMTP_SERVER_INSTANCE, m_ConnectionsList)
    FIELD3(FieldTypeDword, SMTP_SERVER_INSTANCE, m_cCurrentConnections)
    FIELD3(FieldTypeDword, SMTP_SERVER_INSTANCE, m_cCurrentOutConnections)
    FIELD3(FieldTypeDword, SMTP_SERVER_INSTANCE, m_cMaxCurrentConnections)
    FIELD3(FieldTypeDword, SMTP_SERVER_INSTANCE, m_cMaxOutConnections)
    FIELD3(FieldTypeDword, SMTP_SERVER_INSTANCE, m_cMaxOutConnectionsPerDomain)
    FIELD3(FieldTypeDword, SMTP_SERVER_INSTANCE, m_cbMaxMsgSize)
    FIELD3(FieldTypeDword, SMTP_SERVER_INSTANCE, m_cbMaxMsgSizeBeforeClose)
END_FIELD_DESCRIPTOR


BEGIN_FIELD_DESCRIPTOR(Smtp_Iis_Inst)
    FIELD3(FieldTypeDword, SMTP_IIS_SERVICE, m_OldMaxPoolThreadValue)
    FIELD3(FieldTypeLong, SMTP_IIS_SERVICE, m_cCurrentSystemRoutingThreads)
    FIELD3(FieldTypeDword, SMTP_IIS_SERVICE, m_cMaxSystemRoutingThreads)
    FIELD3(FieldTypeDword, SMTP_IIS_SERVICE, m_dwStartHint)
//  FIELD3(FieldTypeDword, SMTP_IIS_SERVICE, m_nInstance)
//  FIELD3(FieldTypeLong, SMTP_IIS_SERVICE, m_nStartedInstances)
//  FIELD3(FieldTypeStruct, SMTP_IIS_SERVICE, m_InstanceListHead)
END_FIELD_DESCRIPTOR


BEGIN_FIELD_DESCRIPTOR(Smtp_Outbound_Connection)
    FIELD3(FieldTypeClassSignature, SMTP_CONNECTION, m_signature)
    FIELD3(FieldTypeSymbol, SMTP_CONNOUT, m_NextState)             //pointer to a function
    FIELD3(FieldTypeDword, SMTP_CONNOUT, m_cbParsable)
    FIELD3(FieldTypeStruct, SMTP_CONNOUT, m_OutputBuffer)
    FIELD3(FieldTypePointer, SMTP_CONNOUT, m_pOutputBuffer)
    FIELD3(FieldTypeStruct, SMTP_CONNOUT, m_NativeCommandBuffer)
    FIELD3(FieldTypePointer, SMTP_CONNOUT, m_pIMsg)                 //pointer to imsg object
    FIELD3(FieldTypePointer, SMTP_CONNOUT, m_pISMTPConnection)      //pointer to smtp_conn object
    FIELD3(FieldTypePointer, SMTP_CONNOUT, m_precvBuffer)
    FIELD4(FieldTypeDWordBitMask, SMTP_CONNOUT, m_Flags, GET_BIT_MASK_DESCRIPTOR(OutboundConnectionFlags))
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(Drop_Directory)
    FIELD3(FieldTypeClassSignature, CDropDir, m_dwSig)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(Class_Buffer)
    FIELD3(FieldTypeClassSignature, CBuffer, m_dwSignature)
    FIELD3(FieldTypePointer, CBuffer, m_pIoBuffer)
    FIELD3(FieldTypeDword, CBuffer, m_cCount)
END_FIELD_DESCRIPTOR

BEGIN_STRUCT_DESCRIPTOR 
	STRUCT(SMTP_CONNECTION, Connection_Object)
    STRUCT(SMTP_SERVER_STATISTICS, Smtp_Server_Stats)
    STRUCT(SMTP_SERVER_INSTANCE, Smtp_Server_Inst)
    STRUCT(SMTP_IIS_SERVICE, Smtp_Iis_Inst)
    STRUCT(SMTP_CONNOUT, Smtp_Outbound_Connection)
    STRUCT(CDropDir, Drop_Directory)
    STRUCT(CBuffer, Class_Buffer)
END_STRUCT_DESCRIPTOR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpdbg\smtpdbg.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: smtpdbg.cpp
//
//  Description: Debugger extentions for SMTPSVC.  Any SMTP-specific 
//      extensions should go in this file.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      2/22/99 - GPulla created
//      7/4/99 - MikeSwa Updated and checked in 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "smtpdbg.h"

DEFINE_EXPORTED_FUNCTIONS

DECLARE_DEBUG_PRINTS_OBJECT()

// Displayed at top of help command
LPSTR ExtensionNames[] = 
{
	"Debugger Extension for : smtpsvc\n",
	0
};

//Displayed at bottom of help command... after exported functions are explained
LPSTR Extensions[] = 
{
	"\n",
	0
};

//Because of the way the we redefine private/protected, the Do*Command protocol
//command functions must be redefined here or else there will be linker errors.  
//If new protocol commands are added, they MUST be added here as well.
BOOL SMTP_CONNECTION::DoEHLOCommand(const char * InputLine, DWORD parameterSize){ return 1; }
BOOL SMTP_CONNECTION::DoHELOCommand(const char * InputLine, DWORD parameterSize){ return 1; }
BOOL SMTP_CONNECTION::DoRSETCommand(const char * InputLine, DWORD parameterSize){ return 1; }
BOOL SMTP_CONNECTION::DoNOOPCommand(const char * InputLine, DWORD parameterSize){ return 1; }

BOOL SMTP_CONNECTION::DoQUITCommand(const char * InputLine, DWORD parameterSize){ return 1; }
BOOL SMTP_CONNECTION::DoHELPCommand(const char * InputLine, DWORD parameterSize){ return 1; }
BOOL SMTP_CONNECTION::DoMAILCommand(const char * InputLine, DWORD parameterSize){ return 1; }
BOOL SMTP_CONNECTION::DoRCPTCommand(const char * InputLine, DWORD parameterSize){ return 1; }

BOOL SMTP_CONNECTION::DoDATACommand(const char * InputLine, DWORD parameterSize){ return 1; }
BOOL SMTP_CONNECTION::DoVRFYCommand(const char * InputLine, DWORD parameterSize){ return 1; }
BOOL SMTP_CONNECTION::DoAUTHCommand(const char * InputLine, DWORD parameterSize){ return 1; }
BOOL SMTP_CONNECTION::DoLASTCommand(const char * InputLine, DWORD parameterSize){ return 1; }

BOOL SMTP_CONNECTION::DoETRNCommand(const char * InputLine, DWORD parameterSize){ return 1; }
BOOL SMTP_CONNECTION::DoTURNCommand(const char * InputLine, DWORD parameterSize){ return 1; }
BOOL SMTP_CONNECTION::DoSTARTTLSCommand(const char * InputLine, DWORD parameterSize){ return 1; }

BOOL SMTP_CONNECTION::DoTLSCommand(const char * InputLine, DWORD parameterSize){ return 1; }
BOOL SMTP_CONNECTION::DoBDATCommand(const char * InputLine, DWORD parameterSize){ return 1; }
BOOL SMTP_CONNECTION::Do_EODCommand(const char * InputLine, DWORD parameterSize){ return 1; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpmd\jd_misc.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    jd_misc.cpp

Abstract:
	variety of assisting functions
	  - command line parameters parsing
	  - displaying the error messages
	  - creating the random file
          - creating the unique identifier based on thread and process
Author:

    jaroslad  

Revision History:
     06-01-96      ( Jaroslad ) Original.

--*/

#include <tchar.h>
#include "jd_misc.h"

#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>

int random (int low, int high)
{
	return ( low+((long)rand()*(long)high)/RAND_MAX );
}


/* Sample structure demonstating how to use comand line definition structure

  TParamDef CmdLineParam[]=
{
 {"c" ,1, &FtpServerIpAddr,TYPE_TCHAR,OPT, "ftp server computer name", "computer"},
 {"b", 0, &fStop,       TYPE_INT,  OPT, "binary flag"},
 {"start", 0, &fStart,     TYPE_INT,  OPT, "start service"},
 {"pause", 0, &fPause,     TYPE_INT,  OPT, "pause service"},
 {"s" ,1, &ServiceName,    TYPE_TCHAR, MAND,"service name","svc"},

 { {NULL,0, NULL ,         TYPE_TCHAR, OPT, "Place the description of the program here" };

*/

void DisplayUsage( _TCHAR **argv, TParamDef *tt)
{
	_tprintf(_T("Usage:\n\t%s "), argv[0]);
	for(int i=0; tt[i].sw!=0;i++)
	{
		if(tt[i].sw[0]==0) //default (do not need switch) parameters
		{
			_tprintf(_T("%s "),(tt[i].text_param!=NULL)?tt[i].text_param:_T("parm"));
		}
		else
		{
			_tprintf(_T("-%s "),tt[i].sw);
			if(tt[i].param_number==1)
				_tprintf(_T("[%s] "),(tt[i].text_param!=NULL)?tt[i].text_param:_T("parm"));
			else if(tt[i].param_number>1)
				_tprintf(_T("[[%s]...] "),(tt[i].text_param!=NULL)?tt[i].text_param:_T("parm"));
		}
	}

	_tprintf(_T("\n\n"));
	for(i=0; tt[i].sw!=0; i++)
	{
		if(tt[i].sw[0]==0) //default parameters
		{
			_tprintf(_T("\"no switch\"  %s\n"),tt[i].text_desc);
		}
		else if(tt[i].text_desc!=NULL)
		{
			_tprintf(_T("-%-6s %s\n"),tt[i].sw,tt[i].text_desc);
		}
	}
	//print description
	if( tt[i].text_desc!=NULL && tt[i].text_desc[0]!=0)
	{
		_tprintf(_T("\nDescription:\n"));
		_tprintf(_T("%s \n"), tt[i].text_desc);
	}
}

void DisplayUsageAndExit( _TCHAR **argv, TParamDef *tt)
{
	DisplayUsage( argv, tt);
	
	exit(1);
}

//structure that makes easy lexical parsing of the command line arguments

struct sParamLex
{
	int argc;
	TCHAR **argv;
	_TCHAR ParamBuffer[400];
	int iCurrentParamChar;  //character index within the current parameter being processed
	int iCurrentParam;      //index to the current parameter that is processed 
public:
	sParamLex(int argc,_TCHAR **argv):argc(argc),argv(argv){iCurrentParamChar=0; iCurrentParam=1;};
	BOOL IsNextSwitch();
	BOOL IsEnd();
	LPTSTR ReadNext();
};

BOOL sParamLex::IsNextSwitch()
{
	if(IsEnd())
		return FALSE;
	if (argv[iCurrentParam][iCurrentParamChar]==_T('-'))
		return TRUE;
	else
		return FALSE;
}

BOOL sParamLex::IsEnd()
{
	if(iCurrentParam>=argc)
		return TRUE;
	else
		return FALSE;
}

LPTSTR sParamLex::ReadNext()
{
	LPTSTR lpszRetval;
	if (IsEnd())
		return NULL;
	if(IsNextSwitch())
	{	int i=0;
		iCurrentParamChar++; //skip '/' or '-'
		while (argv[iCurrentParam][iCurrentParamChar]!=0 && argv[iCurrentParam][iCurrentParamChar]!=_T(':'))
			ParamBuffer[i++]=argv[iCurrentParam][iCurrentParamChar++];
		if(argv[iCurrentParam][iCurrentParamChar]==_T(':'))
			iCurrentParamChar++;
		if(argv[iCurrentParam][iCurrentParamChar]==0)
		{
			iCurrentParam++; iCurrentParamChar=0;
		}
		ParamBuffer[i]=0;
		lpszRetval=ParamBuffer;
	}
	else
	{
		lpszRetval=&argv[iCurrentParam][iCurrentParamChar];
		iCurrentParam++; iCurrentParamChar=0;
	}
	return lpszRetval;
}


void ParseParam(int argc, _TCHAR ** argv, TParamDef * tt)
{
	
	for(int i=0; tt[i].sw!=NULL ; i++)
	{
		tt[i].curr_param_read=0; //initialize 
	}
	
	sParamLex paramLex(argc,argv);
	
	BOOL fParseBegin=TRUE;
	while(!paramLex.IsEnd())
	{
		int k;
		if(paramLex.IsNextSwitch())
		{
			_TCHAR * sw = paramLex.ReadNext();
			/*find the switch in switch table*/ 
			for( k=0; tt[k].sw!=NULL ;k++)
			{ 
				if(tt[k].sw[0]==0) continue; //skip the default parameters
				if(_tcscmp(tt[k].sw, sw)==0 /*equal*/ )
					break;	
			}
			if(tt[k].sw == NULL) //switch not found
			{	_tprintf(_T("invalid switch \"%s\"\n"),sw);/*error*/
				DisplayUsageAndExit(argv,tt);
			}
		}
		else if( fParseBegin==TRUE && (_tcscmp(tt[0].sw, _T(""))==0 /*equal*/ ) )
		{ //default parameters (has to be the first record in arg description)
			k=0; 
		}
		else
		{
			_tprintf(_T("default arguments not expected\n"));/*error*/
			DisplayUsageAndExit(argv,tt);
		}
			
		
		if(tt[k].param_number==0) //switch without parameters
		{
			if(paramLex.IsEnd()==FALSE && paramLex.IsNextSwitch()==FALSE)
			{
				_tprintf(_T("switch \"%s\" takes no parameters \n"),tt[k].sw);
				DisplayUsageAndExit(argv,tt);
			}
			tt[k].curr_param_read++;
			*((int *)tt[k].ptr)=1;
		}
		else if(tt[k].param_number>0) //swith with more then 0ne parameter
		{
			if(paramLex.IsEnd()==TRUE || paramLex.IsNextSwitch()==TRUE)
			{  _tprintf(_T(" switch \"%s\" expects parameter\n"),tt[k].sw);//error
				DisplayUsageAndExit(argv,tt);
			}
			else
			{
				_TCHAR * prm;
			
				do
				{	
					prm=paramLex.ReadNext();
				
					if(tt[k].param_number <= tt[k].curr_param_read)
					{
						_tprintf(_T("number of parameters for switch -%s exceeds maximum allowed (%d)\n"),tt[k].sw,tt[k].param_number); 
						DisplayUsageAndExit(argv,tt);
					}		
					

					if(tt[k].ptr_type==TYPE_TCHAR || tt[k].ptr_type==TYPE_LPCTSTR)
						*(((_TCHAR **)tt[k].ptr) + tt[k].curr_param_read++)=prm;
					else if(tt[k].ptr_type==TYPE_INT ||tt[k].ptr_type==TYPE_WORD)
						*(((int *)tt[k].ptr) + tt[k].curr_param_read++)=_ttoi(prm);
					else if(tt[k].ptr_type==TYPE_LONG || tt[k].ptr_type==TYPE_DWORD)
						*(((long *)tt[k].ptr) + tt[k].curr_param_read++)=_ttol(prm);
					
				}while (paramLex.IsEnd()==FALSE && paramLex.IsNextSwitch()==FALSE);
		
			}
		}//end tt[k].param_number
		
	} // end while
	for(i=0; tt[i].sw!=0;i++) //check for mandatory switches
	{
		if (tt[i].opt_mand==MAND && tt[i].curr_param_read==0)
		{
			_tprintf(_T("mandatory switch -%s missing\n"),tt[i].sw);
			DisplayUsageAndExit(argv,tt);
		}

		if(tt[i].param_read!=NULL) // set number of params for switch
			*tt[i].param_read=tt[i].curr_param_read;

	}
}




/******************************************
  time_printf
*******************************************/


int time_printf(_TCHAR *format, ...)
{
   static CRITICAL_SECTION cs;
   static BOOL fInit=0;
   va_list marker;

   if(fInit==0)
   {
	   fInit=1;
	   InitializeCriticalSection(&cs);
   }

   _TCHAR buf[80]; 	
   
   EnterCriticalSection(&cs);
   va_start( marker, format );     /* Initialize variable arguments. */
   _tprintf(_TEXT("%s - "),_tstrtime(buf));
   _vtprintf(format,marker);
   LeaveCriticalSection(&cs);
   va_end( marker );              /* Reset variable arguments.      */
 //  printf("%s%s",bufa,bufb); //for multithreaded will be printed as one line
   return 1;
}

void error_printf(_TCHAR *format, ...)
{
   va_list marker;

   va_start( marker, format );     /* Initialize variable arguments. */
   _tprintf(_TEXT("Error: "));
   int x=_vftprintf(stderr,format,marker);
   va_end( marker );              /* Reset variable arguments.      */
   
}

void fatal_error_printf(_TCHAR *format, ...)
{
   va_list marker;
 
   va_start( marker, format );     /* Initialize variable arguments. */
   _tprintf(_TEXT("Error: "));
   int x=_vftprintf(stderr,format,marker);
   va_end( marker );              /* Reset variable arguments.      */
   exit(EXIT_FAILURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpmd\ansimeta.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       ansimeta.h

   Abstract:

        WRAPPER functions for ANSI calls of UNICODE ADMCOM interface

   Environment:

      Win32 User Mode

   Author:

      jaroslad  (jan 1997)

--*/

#ifndef _ANSIMETA__H
#define _ANSIMETA__H

#include <tchar.h>
#include <afx.h>

#include <iadmw.h>




class ANSI_smallIMSAdminBase
    {

        
    public:
		IMSAdminBase * m_pcAdmCom;   //interface pointer to Metabase Admin

		ANSI_smallIMSAdminBase (){m_pcAdmCom=0;};

	  void SetInterfacePointer(IMSAdminBase * a_pcAdmCom) {a_pcAdmCom = m_pcAdmCom;}
          virtual HRESULT STDMETHODCALLTYPE AddKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath) ;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath) ;
        
        
        virtual HRESULT STDMETHODCALLTYPE EnumKeys( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [size_is][out] */ unsigned char __RPC_FAR *pszMDName,
            /* [in] */ DWORD dwMDEnumObjectIndex) ;
        
        virtual HRESULT STDMETHODCALLTYPE CopyKey( 
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
            /* [in] */ BOOL bMDOverwriteFlag,
            /* [in] */ BOOL bMDCopyFlag) ;
        
        virtual HRESULT STDMETHODCALLTYPE RenameKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDNewName) ;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ PMETADATA_RECORD pmdrMDData) ;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) ;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType) ;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE EnumData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [in] */ DWORD dwMDEnumDataIndex,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) ;
        
        
        virtual HRESULT STDMETHODCALLTYPE CopyData( 
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ BOOL bMDCopyFlag) ;
        
        virtual HRESULT STDMETHODCALLTYPE OpenKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDAccessRequested,
            /* [in] */ DWORD dwMDTimeOut,
            /* [out] */ PMETADATA_HANDLE phMDNewHandle) ;
        
        virtual HRESULT STDMETHODCALLTYPE CloseKey( 
            /* [in] */ METADATA_HANDLE hMDHandle) ;
        
        
        virtual HRESULT STDMETHODCALLTYPE SaveData( void) ;
        
     };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpmd\admutil.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       admutil.cpp

   Abstract:

        IMSAdminBase interface WRAPPER functions definition

   Environment:

      Win32 User Mode

   Author:

          jaroslad  (jan 1997)

--*/


#if !defined (ADMUTIL_H)
#define ADMUTIL_H

#include <afx.h>
#ifdef UNICODE
	#include <iadmw.h>
#else
	#include "ansimeta.h"
#endif
#include <iwamreg.h>

class CAdmUtil;

//************************************************************************
//CAdmNode DEFINITION
//- store all the complex information about accessing MetaObject or MetaData


class CAdmNode
{
        CString strComputer; //computer to access
        CString strService;
        CString strInstance;
        CString strIPath; //path relative to instance
                                          //(/LM/{strService}/{strInstance}/{strIPath} gives the full path to MEtaObject
        CString strProperty; // name of the MetaData within given Path


        static INT              GetSlashIndex(const CString& strPath, INT iSeqNumber);
        static INT              GetCountOfSlashes(const CString& strPath);
        static CString  GetPartOfPath(const CString& strPath, INT iStart, INT iEnd=-1);

public:
        CAdmNode(const CString& a_strPath=CString("")) {SetPath(a_strPath);};
        void SetPath(CString a_strPath);

        //magic functions to provide various kinds of paths within metabase
        CString GetLMRootPath(void);
        CString GetLMServicePath(void);
        CString GetLMInstancePath(void);
        CString GetLMNodePath(void);
        CString GetServicePath(void);
        CString GetInstancePath(void);
        CString GetNodePath(void);
        CString GetRelPathFromService(void);
        CString GetRelPathFromInstance(void);

        CString GetParentNodePath(void);
        CString GetCurrentNodeName(void);

        //access to METADATA_RECORD items
        CString GetComputer(void)  {return strComputer;};
        CString GetService(void)  {return strService;};
        CString GetInstance(void)  {return strInstance;};
        CString GetIPath(void)  {return strIPath;};
        CString GetProperty(void)  {return strProperty;};

        //setting the METADATA_RECORD items
        void SetComputer(const CString& a_strComputer)  {strComputer=a_strComputer;};
        void SetService(const CString& a_strService)    {strService=a_strService;};
        void SetInstance(const CString& a_strInstance)  {strInstance=a_strInstance;};
        void SetIPath(const CString& a_strIPath)        {strIPath=a_strIPath;};
        void SetProperty(const CString& a_strProperty)  {strProperty=a_strProperty;};


        friend CAdmUtil;
};


//************************************************************************
//CAdmProp DEFINITION
//
// -convenience wrapper for METADATA_RECORD


class CAdmProp
{
        enum {USERTYPESET=0x01,DATATYPESET=0x02,ATTRIBSET=0x04}; //value indicates that the variable was not set
                                                           //0 cannot be used, because that is valid value
        METADATA_RECORD mdr;
        DWORD dwFlags;

public:
        CAdmProp(){dwFlags=0;mdr.dwMDIdentifier=0; mdr.dwMDAttributes=0; mdr.dwMDUserType=0;
                                        mdr.dwMDDataType=0;mdr.pbMDData=0; mdr.dwMDDataLen=0;};
        CAdmProp(METADATA_RECORD &a_mdr);
	CAdmProp(const CString &a_strProperty);
        void SetIdentifier(DWORD a_dwIdentif) {mdr.dwMDIdentifier=a_dwIdentif;};
        void SetAttrib(DWORD a_dwAttrib) {mdr.dwMDAttributes=a_dwAttrib;dwFlags|=ATTRIBSET;};
        void SetUserType(DWORD a_dwUserType) {mdr.dwMDUserType=a_dwUserType;dwFlags|=USERTYPESET;};
        void SetDataType(DWORD a_dwDataType) {mdr.dwMDDataType=a_dwDataType;dwFlags|=DATATYPESET;};

        BOOL IsSetAttrib(void)
                { return (((dwFlags&ATTRIBSET)!=0)?TRUE:FALSE); };
        BOOL IsSetUserType(void)
                {return (((dwFlags&USERTYPESET)!=0)?TRUE:FALSE); };
        BOOL IsSetDataType(void)
                {return (((dwFlags&DATATYPESET)!=0)?TRUE:FALSE); };


        DWORD GetAttrib(void) {return mdr.dwMDAttributes;};
        DWORD GetDataType(void) {return mdr.dwMDDataType;};
        DWORD GetUserType(void) {return mdr.dwMDUserType;};
        DWORD GetIdentifier(void) {return mdr.dwMDIdentifier;};
        PBYTE GetMDData(void) {return mdr.pbMDData;};
        DWORD GetMDDataLen(void) {return mdr.dwMDDataLen;};

        void SetValue(DWORD a_dwValue);
        void SetValue(CString a_strValue);
        void SetValue(LPCTSTR *a_lplpszValue, DWORD a_dwValueCount); //for multisz
        void SetValue(LPBYTE pbValue, DWORD dwValueLength ); //for binary
        BOOL SetValueByDataType(LPCTSTR *a_lplpszPropValue,DWORD* a_lpdwPropValueLength,WORD a_wPropValueCount);

        void PrintProperty(void);


        virtual void Print(const _TCHAR *format,...);


        friend CAdmUtil;
};

//************************************************************************
//CAdmUtil DEFINITION
//
//-convenience wrapper for calling IMSAdminBase interface functions

//defined in admutil.cpp
extern DWORD g_dwTIMEOUT_VALUE;
extern DWORD g_dwDELAY_AFTER_OPEN_VALUE;


class CAdmUtil
{
        static enum {
                DEFAULTBufferSize=4
        };

#ifdef UNICODE
        IMSAdminBase * pcAdmCom;   //interface pointer to Metabase Admin
#else
		ANSI_smallIMSAdminBase * pcAdmCom;   //interface pointer to Metabase Admin Ansi Wrapper
#endif
		IWamAdmin*	pIWamAdm; //interface pointer to Wam Admin

		METADATA_HANDLE m_hmd;    //metabase handle that micht be reused for sequence of commands
		CString m_strNodePath;    //related to m_hmd - if h_hmd!=NULL it points to m_strNodePath
		DWORD m_dwPermissionOfhmd; //related to m_hmd  

        PBYTE pbDataBuffer;   //buffer to get data from METABASE (used for METADATA_RECORD)
        WORD wDataBufferSize; //size of the above buffer
protected:
        BOOL fPrint ; //print Error messages
        HRESULT hresError;    //store the last HRESULT of calling interface IMSAdminBase interface function
                                                  // this is used to store some other error as is OUT_OF_MEMORY or INVALID_PARAMETER



        //with wIndex it is possible to open more than one METADATA object, opening multiple object is not available outside the class
        void OpenObject(WORD wIndex, LPCSTR lpszService,WORD wInstance, LPCSTR lpszPath, DWORD dwPermission=METADATA_PERMISSION_WRITE+METADATA_PERMISSION_READ, BOOL fCreate=TRUE);
        void CloseObject(WORD wIndex);

        METADATA_HANDLE OpenObjectTo_hmd(CAdmNode & a_AdmNode,
                        DWORD dwPermission=METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE,
                        BOOL fCreate=FALSE);
		void CloseObject_hmd(void);
      
public:
        CAdmUtil(const CString & strComputer=CString(""));
        ~CAdmUtil();
#ifdef UNICODE
		IMSAdminBase * GetpcAdmCom(void) {return pcAdmCom;}; 
#else
		IMSAdminBase * GetpcAdmCom(void) {return (pcAdmCom==0)?0:pcAdmCom->m_pcAdmCom;}; 
#endif

        //connect to computer, call class factory for IMSAdminBase
        void Open(const CString & strComputer);
        //close connection to computer, throw away IMSAdminBase
        void Close(void);


        //OPEN , CLOSE, CREATE, DELETE, COPY METAOBJECT
        METADATA_HANDLE OpenObject(CAdmNode & a_AdmNode,
                                                DWORD dwPermission=METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE,
                                                BOOL fCreate=FALSE);
        void CloseObject(METADATA_HANDLE hmd);
        void CreateObject(CAdmNode & a_AdmNode);
        void DeleteObject(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp);
        void DeleteObject(METADATA_HANDLE a_hmd, CString& a_strNodeNameToDelete);
        void CopyObject(CAdmNode&       a_AdmNode,  CAdmNode&   a_AdmNodeDst);
        void RenameObject(CAdmNode&     a_AdmNode,  CAdmNode&   a_AdmNodeDst);

        void GetProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp);

        void SetProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp);
        void SetProperty(PMETADATA_RECORD a_pmdrData, METADATA_HANDLE a_hmd);

        void DeleteProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp);
        void DeleteProperty(PMETADATA_RECORD a_pmdrData, METADATA_HANDLE a_hmd);

        //ENUMERATE
        void EnumPropertiesAndPrint(CAdmNode& a_AdmNode,
                                                                          CAdmProp a_AdmProp,
                                                                          BYTE bRecurLevel=0,
                                                                          METADATA_HANDLE a_hmd=0,
                                                                          CString & a_strRelPath=CString(""));
        void EnumAndPrint(CAdmNode&     a_AdmNode,
                                                        CAdmProp&       a_AdmProp,
                                                        BOOL            a_fRecursive=FALSE,
                                                        BYTE            a_bRecurLevel=0,
                                                        METADATA_HANDLE a_hmd=0,
                                                        CString&        a_strRelPath=CString(""));
        //SAVE METABASE DATA
        void SaveData(void);

        //FUNCTION TO RUN CHOSEN METABASE COMMAND WITH GIVEN PARAMATERS
        void Run(CString& strCommand,  //command to run
                         CAdmNode& a_AdmNode,        //PATH TO METABASE OBJECT
                         CAdmProp& a_AdmProp,        //METADATA object
                         CAdmNode& a_AdmDstNode=CAdmNode(""), //DESTINATION PATH (as used for COPY)
                         LPCTSTR *a_lplpszPropValue=0,   //VALUES TO BE STORED (for SET command)
                         DWORD *a_lpdwPropValueLength=0,        //LENGTH OF VALUES TO BE STORED (for SET command)
                         WORD wPropValueCount=0);       //NUMBER OF VALUES TO BE STORED

        //virtual functions for Error and regular messages to be printed.
        // these can be redefined in order to fit custom needs
        virtual void Error(const _TCHAR * format,...);
        virtual void Print(const _TCHAR * format,...);

        //Disable and enable to print error or regular messages
        void EnablePrint(void) {fPrint=TRUE;};
        void DisablePrint(void) {fPrint=FALSE;};

        HRESULT QueryLastHresError(void) {return hresError;};
        void SetLastHresError(HRESULT hr) {hresError=hr;};

	//defined in vptool
	void OpenWamAdm(const CString & strComputer);
	void CloseWamAdm(void);
	void AppCreateInProc(const _TCHAR* szPath,const CString & strComputer);
	void AppCreateOutProc(const _TCHAR* szPath,const CString & strComputer);
	void AppDelete(const _TCHAR* szPath,const CString & strComputer);
        void AppRename(CAdmNode& a_AdmNode, CAdmNode& a_AdmDstNode, const CString & strComputer);
	void AppUnLoad(const _TCHAR* szPath,const CString & strComputer);
	void AppGetStatus(const _TCHAR* szPath,const CString & strComputer);

};


//runs administration command based on given parameters



LPTSTR ConvertHresToString(HRESULT hRes);
DWORD ConvertHresToDword(HRESULT hRes);
LPTSTR ConvertReturnCodeToString(DWORD ReturnCode);

CString FindCommonPath(CString a_strPath1,CString a_strPath2);

#define M_LOCAL_MACHINE "/LM/"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpdbg\smtpdump.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: smtpdump.cpp
//
//  Description: C file that build the extenstions defined in smtpflds.h
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      2/22/99 - GPulla created
//      7/4/99 - MikeSwa Updated and checked in 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#define _ANSI_UNICODE_STRINGS_DEFINED_

#include "smtpdbg.h"

PEXTLIB_INIT_ROUTINE g_pExtensionInitRoutine = NULL;
#include "smtpflds.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpmd\admutil.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       admutil.cpp

   Abstract:

        IADMCOM interface WRAPPER functions implemetation

   Environment:

      Win32 User Mode

   Author:

      jaroslad  (jan 1997)

--*/



#define INITGUID

#include <tchar.h>
#include <afx.h>

#ifdef UNICODE
    #include <iadmw.h>
    #define IADM_PBYTE
#else
    #include "ansimeta.h"
    //convert when using ANSI interface
    #define IADM_PBYTE   (PBYTE)
#endif

#include <iiscnfg.h>

#include <ole2.h>

#include <ctype.h>  //import toupper
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>

#include "admutil.h"
#include "tables.h"
#include <jd_misc.h>


//////////////////////////////
//global variable definition
DWORD g_dwTIMEOUT_VALUE =30000;

DWORD g_dwDELAY_AFTER_OPEN_VALUE=0;
//////////////////////////////

//*********************

CString FindCommonPath(CString a_strPath1, CString a_strPath2)
{
    CString strCommonPath=_TEXT("");
    int MinLength=a_strPath1.GetLength();
    int i;
    //find shorter from strings
    if(a_strPath2.GetLength() < MinLength)
            MinLength=a_strPath2.GetLength();
    for(i=0; i<MinLength; i++)
    {
        if(a_strPath1.GetAt(i)!=a_strPath2.GetAt(i) )
            // common path cannot be any longer;
            break;
    }
    //  now find the previous '/' and all before '/' is the common path
    for(i=i-1; i>=0;i--)
    {
        if(a_strPath1.GetAt(i)==_T('/'))
        {
            strCommonPath=a_strPath1.Left(i+1);//take the trailing '/' with you
            //strRelSrcPath=strPath1.Mid(i+1);
            //strRelDstPath=strPath2.Mid(i+1);
            break;
        }
    }
    return strCommonPath;
}


//**********************************************************************
//IMPLEMENTATION  of CAdmNode
//**********************************************************************



//return the position of '/' that is iSeqNumber in the order
//e.g: GetSlashIndex("aaa/bbb/ccc/ddd",2) returns position of 2nd index that equals 7)
INT CAdmNode::GetSlashIndex(const CString& strPath, INT iSeqNumber)
{
    INT count=0;
    if (iSeqNumber==0)
        return 0;
    for(INT i=0; i<strPath.GetLength();i++)
    {
        if(strPath[i]==_T('/'))
            if((++count)==iSeqNumber)
                return i;
    }
    return -1;

}

//return the count of '/' in strPath

INT CAdmNode::GetCountOfSlashes(const CString& strPath)
{
    INT count=0;
    for(INT i=0; i<strPath.GetLength();i++)
    {
        if(strPath[i]==_T('/'))
            count++;
    }
    return count;
}

//return selement within the given string with sequence number wIndex
//e.g.: GetPartOfPath("aaa/bbb/ccc",1,1) will return "bbb"
//e.g.: GetPartOfPath("aaa/bbb/ccc",1) will return "bbb/ccc"
//e.g.: GetPartOfPath("aaa/bbb/ccc",0,1) will return "aaa/bbb"

//iStart- sequence number of first slash
//iEnd- sequence number of last slash
CString CAdmNode::GetPartOfPath(const CString& strPath, INT iStart, INT iEnd)
{
    if(iEnd!=-1 && iEnd <= iStart)
        return _TEXT("");
    INT i=0;
    INT iPosBegin = GetSlashIndex(strPath,iStart);
    if(iPosBegin==-1) //not found (exceeds number of slashes available in strPath
    {
        return _TEXT("");
    }
    iPosBegin+=((iStart==0)?0:1); //adjust iPosBegin

    INT iPosEnd = GetSlashIndex(strPath,iEnd);
    CString strToReturn;
    if(iEnd==-1 || iPosEnd==-1)
        strToReturn = strPath.Mid(iPosBegin);
    else
        strToReturn = strPath.Mid(iPosBegin,iPosEnd-iPosBegin);
    if(iStart==0 && strToReturn==_TEXT("") && strPath!=_TEXT(""))
        return _TEXT("/"); //this had to be root
    else
        return strToReturn;
}


//within path can be given computer name, service, instance number
// function will split the path to Computer, Service, Instance, Path relative to instance
//

void CAdmNode::SetPath(CString a_strPath)
{
    if(a_strPath.IsEmpty())
        return;

    // change backslashes
    for(int i=0; i<a_strPath.GetLength(); i++)
    {
        // skip DBCS
        if(IsDBCSLeadByte(a_strPath[i]))
        {
            i++;
            continue;
        }
        if(a_strPath[i]==_T('\\'))
            a_strPath.SetAt(i,_T('/'));
    }

    //trim  leading '/'
    while (a_strPath.GetLength()!=0 && a_strPath[0]==_T('/'))
        a_strPath=a_strPath.Mid(1);


    int iSvc=-1;

    if( IsServiceName(GetPartOfPath(a_strPath,1,2))) //get the second name within path
    { //if second is service then first has to be computer name
        strComputer = GetPartOfPath(a_strPath,0,1);
        strService  = GetPartOfPath(a_strPath,1,2);
        if( IsNumber(GetPartOfPath(a_strPath,2,3))) {
            strInstance = GetPartOfPath(a_strPath,2,3);
            strIPath = GetPartOfPath(a_strPath,3); //store the rest
        }
        else {
            strIPath = GetPartOfPath(a_strPath,2); //store the rest

        }
    }
    else if( IsServiceName(GetPartOfPath(a_strPath,0,1))) //get the second name within path
    { //if second is service then first has to be computer name
        strComputer = _TEXT("");
        strService  = GetPartOfPath(a_strPath,0,1);
        if( IsNumber(GetPartOfPath(a_strPath,1,2))) {
            strInstance = GetPartOfPath(a_strPath,1,2);
            strIPath = GetPartOfPath(a_strPath,2); //store the rest
        }
        else {
            strIPath = GetPartOfPath(a_strPath,1); //store the rest
        }
    }
    else
    {
        strIPath = a_strPath;
    }

    //in IPath there can be Property name at the end
    INT iCount= GetCountOfSlashes(strIPath);
    CString LastName= GetPartOfPath(strIPath,iCount); //get last name within path;

     if(MapPropertyNameToCode(LastName)!=NAME_NOT_FOUND)
     {  //the Last name in the path is valid Property name
        strProperty = LastName;
        strIPath = GetPartOfPath(strIPath,0,iCount); //Strip Last name from IPath
     }
}

CString CAdmNode::GetLMRootPath(void)
{
    return _T("/")+CString(IIS_MD_LOCAL_MACHINE_PATH);
}



CString CAdmNode::GetLMServicePath(void)
{
    if(strService.IsEmpty())
        return GetLMRootPath();
    else
        return GetLMRootPath()+_T("/")+strService;
}

CString CAdmNode::GetLMInstancePath(void)
{
    if(strInstance.IsEmpty())
        return GetLMServicePath();
    else
        return GetLMServicePath()+_T("/")+strInstance;
}

CString CAdmNode::GetLMNodePath(void)
{
    if(strIPath.IsEmpty())
        return GetLMInstancePath();
    else
        return GetLMInstancePath()+_T("/")+strIPath;
}

CString CAdmNode::GetServicePath(void)
{
    if(strService.IsEmpty())
        return _TEXT("");
    else
        return _T("/")+strService;
}

CString CAdmNode::GetInstancePath(void)
{
    if(!strInstance.IsEmpty())
        return GetServicePath() + _T("/")+ strInstance;
    else
        return GetServicePath();
}

CString CAdmNode::GetNodePath(void)
{

    if(!strIPath.IsEmpty())
        return GetInstancePath() + _T("/")+ strIPath;
    else
        return GetInstancePath();
}



CString CAdmNode::GetParentNodePath(void)
{
    CString strNodePath;
    strNodePath = GetNodePath();

    if(strNodePath.IsEmpty())
        return strNodePath;
    else
    {
        int i= strNodePath.GetLength()-1; //point to the end of strNodePath
        if (strNodePath.Right(1)==_T("/"))
            i--;
        for(; i>=0; i--)
        {
            if(strNodePath.GetAt(i)==_T('/'))
                return strNodePath.Left(i+1);
        }
        return _TEXT("");
    }
}
//can return _TEXT("") for nonamed
CString CAdmNode::GetCurrentNodeName(void)
{
    CString strNodePath;
    strNodePath = GetNodePath();

    if(strNodePath.IsEmpty())
        return strNodePath;
    else
    {
        int i= strNodePath.GetLength()-1; //point to the end of strNodePath
        if (strNodePath.Right(1)==_T("/"))
            i--;
        for(int count=0; i>=0; i--, count++) //search backward for '/'
        {
            if(strNodePath.GetAt(i)==_T('/'))
                return strNodePath.Mid(i+1,count);
        }
        return strNodePath;
    }
}


CString CAdmNode::GetRelPathFromService(void)
{
    CString str=strService;
    if (!strInstance.IsEmpty())
        str=str+_T("/")+strInstance;
    if (!strIPath.IsEmpty())
        str=str+_T("/")+strIPath;
    return str;
}

CString CAdmNode::GetRelPathFromInstance(void)
{
    if(strInstance.IsEmpty())
        return strIPath;
    else
        return  strInstance+_T("/")+strIPath;
}

//**********************************************************************
//**********************************************************************
//IMPLEMENTATION  of CAdmProp object
//**********************************************************************
//**********************************************************************

CAdmProp::CAdmProp(METADATA_RECORD &a_mdr)
{
    memcpy (&mdr,&a_mdr,sizeof(METADATA_RECORD));
}

void CAdmProp::SetValue(DWORD a_dwValue)
{
    if(mdr.pbMDData!=0)
        delete mdr.pbMDData;
    mdr.dwMDDataLen= sizeof(DWORD);
    mdr.pbMDData = (PBYTE) new char[mdr.dwMDDataLen];
    memcpy(mdr.pbMDData,&a_dwValue,mdr.dwMDDataLen);


}


void CAdmProp::SetValue(CString a_strValue)
{
    if(mdr.pbMDData!=0)
        delete mdr.pbMDData;
    mdr.dwMDDataLen = (a_strValue.GetLength()+1)*sizeof(_TCHAR);
    mdr.pbMDData = (PBYTE) new _TCHAR [mdr.dwMDDataLen/sizeof(_TCHAR)];
    memcpy(mdr.pbMDData,LPCTSTR(a_strValue),(mdr.dwMDDataLen-1)*sizeof(_TCHAR));
    ((_TCHAR *)mdr.pbMDData)[mdr.dwMDDataLen/sizeof(_TCHAR)-1]=0; //terminate with zero
}

void CAdmProp::SetValue(LPCTSTR *a_lplpszValue, DWORD a_dwValueCount)
{
    if(mdr.pbMDData!=NULL)
    {
        delete mdr.pbMDData;
        mdr.pbMDData=0;
    }
    mdr.dwMDDataLen=0;
    for(DWORD i=0; i< a_dwValueCount; i++)
    {
        if(a_lplpszValue[i]==NULL)
            break;

        mdr.dwMDDataLen += (_tcslen(a_lplpszValue[i])+1)*sizeof(_TCHAR);
    }
    mdr.dwMDDataLen+=sizeof(_TCHAR); // two 0 at the end
    mdr.pbMDData = (PBYTE) new char[mdr.dwMDDataLen];
    //merge strings in one area of memory
    DWORD j=0; //index to destination where stings will be merged
    for( i=0; i< a_dwValueCount; i++) //index to aray of strings
    {
        if(a_lplpszValue[i]==NULL)
            break;
        DWORD k=0; //index within string
        while(a_lplpszValue[i][k]!=0)
            ((_TCHAR *)mdr.pbMDData)[j++]=a_lplpszValue[i][k++];
        ((_TCHAR *)mdr.pbMDData)[j++]=0;
    }
    ((_TCHAR *)mdr.pbMDData)[j++]=0;
}

void
CAdmProp::SetValue(
    LPBYTE pbValue,
    DWORD dwValueLength
    )
{
    if( mdr.pbMDData != NULL )
    {
        delete mdr.pbMDData;
    }
    mdr.dwMDDataLen = dwValueLength;
    mdr.pbMDData = (PBYTE) new BYTE[mdr.dwMDDataLen];
    memcpy( mdr.pbMDData, pbValue, mdr.dwMDDataLen );
}


//sets the value depending on GetDataType()

BOOL CAdmProp::SetValueByDataType(LPCTSTR *a_lplpszPropValue, DWORD* a_lpdwPropValueLength, WORD a_wPropValueCount)
{
//process the value
    WORD i;
    if(a_wPropValueCount!=0)
    {   DWORD dwValue=0;
        switch(GetDataType())
        {
        case DWORD_METADATA:
            {
                for (i=0;i<a_wPropValueCount;i++)
                {
                    if( _tcslen(a_lplpszPropValue[i]) > 2 && a_lplpszPropValue[i][0]==_T('0') && _toupper(a_lplpszPropValue[i][1])==_T('X'))
                    {   _TCHAR * lpszX;
                        dwValue += _tcstoul(a_lplpszPropValue[i]+2, &lpszX, 16);
                    }
                    else if(IsNumber(a_lplpszPropValue[i]))
                        dwValue += _ttol(a_lplpszPropValue[i]);
                    else
                    {
                        DWORD dwMapped=MapValueNameToCode(a_lplpszPropValue[i],GetIdentifier());

                        if(dwMapped==NAME_NOT_FOUND)
                        {
                            Print(_TEXT("value not resolved: %s\n"),a_lplpszPropValue[i]);
                            return FALSE;
                        }
                        else
                        // it has to be checked if adding can be performed
                            dwValue |= dwMapped;
                    }
                }
                SetValue(dwValue);
            }
            break;
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
            {
                CString strValue=_TEXT("");
                for (i=0;i<a_wPropValueCount;i++)
                {
                    strValue += a_lplpszPropValue[i];
                }
                SetValue(strValue);
            }
            break;
        case MULTISZ_METADATA:
            {
                SetValue(a_lplpszPropValue, a_wPropValueCount);
            }
            break;
        case BINARY_METADATA:
            SetValue( (LPBYTE)a_lplpszPropValue[0], a_lpdwPropValueLength[0] );
            break;
        default:
            return FALSE;
        }
    }
    return TRUE;
}

void CAdmProp::Print(const _TCHAR * format,...)
{
   _TCHAR buffer[2000];
   va_list marker;
   va_start( marker, format );     /* Initialize variable arguments. */
   _vstprintf(buffer,format, marker);
   _tprintf(_TEXT("%s"),buffer);

   va_end( marker );              /* Reset variable arguments.      */

}


void CAdmProp::PrintProperty(void)
{
    CString strPropName=tPropertyNameTable::MapCodeToName(mdr.dwMDIdentifier);
    BOOL    fSecure =(mdr.dwMDAttributes&METADATA_SECURE);

    //print code or name of property
    if(strPropName.IsEmpty())
        Print(_TEXT("%-30ld: "), mdr.dwMDIdentifier);
    else
    {
	if(getenv("MDUTIL_PRINT_ID")!=NULL) //let's print out Identifier numeric values when environment variable is set
        	Print(_TEXT("%ld %-25s: "), mdr.dwMDIdentifier,LPCTSTR(strPropName));
	else
	        Print(_TEXT("%-30s: "), LPCTSTR(strPropName));
    }
    CString strFlagsToPrint=_TEXT("");

    strFlagsToPrint+=_TEXT("[");
    if(mdr.dwMDAttributes&METADATA_INHERIT)
        strFlagsToPrint+=_TEXT("I");
    if(mdr.dwMDAttributes&METADATA_SECURE)
        strFlagsToPrint+=_TEXT("P");
    if(mdr.dwMDAttributes&METADATA_REFERENCE)
        strFlagsToPrint+=_TEXT("R");
    if(mdr.dwMDUserType==IIS_MD_UT_SERVER)
        strFlagsToPrint+=_TEXT("S");
    if(mdr.dwMDUserType==IIS_MD_UT_FILE)
        strFlagsToPrint+=_TEXT("F");
    if(mdr.dwMDUserType==IIS_MD_UT_WAM)
        strFlagsToPrint+=_TEXT("W");
    if(mdr.dwMDUserType==ASP_MD_UT_APP)
        strFlagsToPrint+=_TEXT("A");
    strFlagsToPrint+=_TEXT("]");
    Print(_TEXT("%-8s"),LPCTSTR(strFlagsToPrint));

    //print property value
    DWORD i;
    switch (mdr.dwMDDataType) {
    case DWORD_METADATA:
#ifndef SHOW_SECURE
        if ( fSecure )
        {
            Print(_TEXT("(DWORD)  ********"), *(DWORD *)(mdr.pbMDData));
        }
        else
#endif
        {
            Print(_TEXT("(DWORD)  0x%x"), *(DWORD *)(mdr.pbMDData));
            // try to convert to readable info
            CString strNiceContent;
            strNiceContent=tValueTable::MapValueContentToString(*(DWORD *)(mdr.pbMDData), mdr.dwMDIdentifier);
            if(!strNiceContent.IsEmpty())
                Print(_TEXT("={%s}"),LPCTSTR(strNiceContent));
            else //at least decimal value can be useful
                Print(_TEXT("={%ld}"),*(DWORD *)(mdr.pbMDData));
        }
        break;
    case BINARY_METADATA:

        Print(_TEXT("(BINARY) 0x"));
        for (i = 0; i < mdr.dwMDDataLen; i++) {
#ifndef SHOW_SECURE
            if ( fSecure )
            {
                Print(_TEXT(" * " ));
            }
            else
#endif
            {
                Print(_TEXT("%02x "), ((PBYTE)(mdr.pbMDData))[i]);
            }
        }
        break;

    case STRING_METADATA:
    case EXPANDSZ_METADATA:
        if(mdr.dwMDDataType==STRING_METADATA)
                Print(_TEXT("(STRING) "));
        else
                Print(_TEXT("(EXPANDSZ) "));
#ifndef SHOW_SECURE
        if( fSecure )
        { //do not expose the length of secure data
           Print( _TEXT("\"********************\"" ));
        }
        else
#endif
        {
          Print(_TEXT("\""));
          for (i = 0; i < mdr.dwMDDataLen/sizeof(_TCHAR); i++) {
            if(((_TCHAR *)(mdr.pbMDData))[i]==0)
            {
                if( i+1 == mdr.dwMDDataLen/sizeof(_TCHAR))
                { //we are at the end print only terminating "
                    Print(_TEXT("\""));
                }
                else
                {
                    Print(_TEXT("\" \""));
                }
            }
            if(((_TCHAR *)(mdr.pbMDData))[i]=='\r')
                Print(_TEXT("\t"));
            else
            {
               // if(mdr.dwMDAttributes&METADATA_SECURE)
               // {
               //     Print( _TEXT("*" ));
               // }
               // else
               // {
                    Print( _TEXT("%c"), ((_TCHAR *)(mdr.pbMDData))[i]);
               // }
            }
          }
        }
        break;
    case MULTISZ_METADATA:
        Print(_TEXT("(MULTISZ) ")); //0 should be separator of mulisz strings

#ifndef SHOW_SECURE
        if( fSecure )
        { //do not expose the length of secure data
           Print( _TEXT("\"********************\"" ));
            }
        else
#endif
        {
            Print(_TEXT("\""));
            for (i = 0; i < mdr.dwMDDataLen/sizeof(_TCHAR); i++) {
                if(((_TCHAR *)(mdr.pbMDData))[i]==0)
                {
                    if( i+1 == mdr.dwMDDataLen/sizeof(_TCHAR) || (mdr.dwMDDataLen/sizeof(_TCHAR)-i==2 && ((_TCHAR *)(mdr.pbMDData))[i]==0 && ((_TCHAR *)(mdr.pbMDData))[i+1]==0))
                    { //we are at the end print only terminating "
                        Print(_TEXT("\"")); break;
                    }
                    else
                    {
                        Print(_TEXT("\" \""));
                    }
                }
                else
                    Print(_TEXT("%c"),((_TCHAR *)(mdr.pbMDData))[i]);
            }
        }
        break;
    default:
        Print(_TEXT("(UNKNOWN) "));
        break;
    }
    Print(_TEXT("\n"));
}

//**********************************************************************
//**********************************************************************
//IMPLEMENTATION  of CAdmUtil object
//**********************************************************************
//**********************************************************************


//nesting for recursive enumeration
static void nest_print(BYTE bLevel)
{
    for(int i=0; i<=bLevel;i++)
        _tprintf(_T(" "));
}

CAdmUtil::CAdmUtil (const CString & strComputer)
{
    EnablePrint(); // by default print error messages


    pcAdmCom=0;
    m_hmd=0;
    pbDataBuffer=new BYTE [DEFAULTBufferSize];
    wDataBufferSize=DEFAULTBufferSize;

#if UNICODE
    pcAdmCom=0;
#else
    pcAdmCom=new ANSI_smallIMSAdminBase;  //we will access metabase through wrapper class
#endif

    //Open (strComputer);
}

void CAdmUtil::Open (const CString & strComputer)
{
    IClassFactory * pcsfFactory = NULL;
    COSERVERINFO csiMachineName;
    COSERVERINFO *pcsiParam = NULL;
    OLECHAR rgchMachineName[MAX_PATH];


#if UNICODE
   //release previous interface if needed
    if(pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->Release();
        pcAdmCom=0;
    }
    //convert to OLECHAR[];
    if (!strComputer.IsEmpty())
    {
           wsprintf( rgchMachineName, L"%s", LPCTSTR(strComputer));

#else
   //release previous interface if needed
    if(pcAdmCom!=0 &&pcAdmCom->m_pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->m_pcAdmCom->Release();
        pcAdmCom->m_pcAdmCom=0;
    }
    //convert to OLECHAR[];
    if (!strComputer.IsEmpty())
    {
            wsprintfW( rgchMachineName, L"%S", LPCTSTR(strComputer));
#endif
    }
    //fill the structure for CoGetClassObject
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;
    pcsiParam = &csiMachineName;
    csiMachineName.pwszName =  (strComputer.IsEmpty())?NULL:rgchMachineName;

    hresError = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);

    if (FAILED(hresError))
    {
     Error(_TEXT("CoGetClassObject"));
    }
    else {
        hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase,
#if UNICODE
                         (void **) &pcAdmCom);
#else
                         (void **) &pcAdmCom->m_pcAdmCom);
#endif
        if (FAILED(hresError)) Error(_TEXT("CreateInstance"));
        pcsfFactory->Release();
    }
}



void CAdmUtil::Close (void)
{
    //release the interface
#if UNICODE
    if(pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->Release();
        pcAdmCom=0;
    }

#else
    if(pcAdmCom!=0 &&pcAdmCom->m_pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->m_pcAdmCom->Release();
        pcAdmCom->m_pcAdmCom=0;
    }
#endif
}



CAdmUtil::~CAdmUtil (void)
{
    //release the interface
    if(pbDataBuffer!=NULL)
        delete [] pbDataBuffer;
    //the following may fail if class is static
#if UNICODE
    if(pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->Release();
        pcAdmCom=0;
    }

#else
    if(pcAdmCom!=0 &&pcAdmCom->m_pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->m_pcAdmCom->Release();
        pcAdmCom->m_pcAdmCom=0;
    }
#endif
}

//*******************************************************************************
//with fCreate set to TRUE the node will be created if it doesn't exist

METADATA_HANDLE CAdmUtil::OpenObject(CAdmNode & a_AdmNode, DWORD dwPermission, BOOL fCreate)
{
    METADATA_HANDLE hmdToReturn = 0;

    //try to open the full path
    CString strPathToOpen=a_AdmNode.GetLMNodePath();

    hresError = pcAdmCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
        IADM_PBYTE LPCTSTR(strPathToOpen), dwPermission, g_dwTIMEOUT_VALUE, &hmdToReturn);

    if (FAILED(hresError)) {
        if ( ((dwPermission==(dwPermission|METADATA_PERMISSION_READ)) || fCreate==FALSE) ||(hresError != RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND))) {
            CString strErrMsg=_TEXT("OpenKey");
            strErrMsg += _TEXT("(\"")+a_AdmNode.GetNodePath()+_TEXT("\")");
            Error(LPCTSTR(strErrMsg));
        }
        else {
            //!!!!!!!!!!!!!Place the dialog to ask to create the path
            // open the service object for write
            METADATA_HANDLE hmdServicePathHandle;
            hresError = pcAdmCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                IADM_PBYTE LPCTSTR(a_AdmNode.GetLMServicePath()), METADATA_PERMISSION_WRITE, g_dwTIMEOUT_VALUE, &hmdServicePathHandle);

            if (FAILED(hresError))
            {
                CString strErrMsg=_TEXT("OpenKey");
                strErrMsg += _TEXT("(\"")+a_AdmNode.GetServicePath()+_TEXT(",WRITE")+_TEXT("\")");
                Error(LPCTSTR(strErrMsg));
            }
            else {
                // create the node
                hresError = pcAdmCom->AddKey(hmdServicePathHandle,
                                    IADM_PBYTE LPCTSTR(a_AdmNode.GetRelPathFromInstance()));
                if (FAILED(hresError)) {
                    CString strErrMsg=_TEXT("AddKey");
                    strErrMsg += _TEXT("(\"")+a_AdmNode.GetRelPathFromInstance()+_TEXT("\")");
                    Error(LPCTSTR(strErrMsg));
                }

                //close the service object
                pcAdmCom->CloseKey(hmdServicePathHandle);
                if (FAILED(hresError))  Error(_TEXT("CloseKey"));
                else {
                    // now finally we can open the full path
                    hresError = pcAdmCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                        IADM_PBYTE LPCTSTR(strPathToOpen), dwPermission, g_dwTIMEOUT_VALUE, &hmdToReturn);
                    if (FAILED(hresError))
                    {
                        CString strErrMsg=_TEXT("OpenKey");
                        strErrMsg += _TEXT("(\"")+a_AdmNode.GetServicePath()+_TEXT(",WRITE")+_TEXT("\")");
                        Error(LPCTSTR(strErrMsg));
                    }
                }
            }
        }
    }
    Sleep(g_dwDELAY_AFTER_OPEN_VALUE);
    return hmdToReturn;
}

//*******************************************************************************
void CAdmUtil::CloseObject(METADATA_HANDLE hmd)
{
    HRESULT hresStore=hresError;
    hresError=pcAdmCom->CloseKey(hmd);
    if (FAILED(hresError)) Error(_TEXT("CloseData"));
    else    hresError=hresStore; //restore the previous hresError


}
//*******************************************************************************

void CAdmUtil::CreateObject(CAdmNode & a_AdmNode)
{
        OpenObjectTo_hmd(a_AdmNode, METADATA_PERMISSION_WRITE, TRUE/* fCreate*/);
}

#if 0
    METADATA_HANDLE hmdToReturn = 0;

    //try to open the full path
    CString strPathToOpen=a_AdmNode.GetLMNodePath();

    METADATA_HANDLE hmdServicePathHandle;
    hresError = pcAdmCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
            IADM_PBYTE LPCTSTR(a_AdmNode.GetLMServicePath()), METADATA_PERMISSION_WRITE, g_dwTIMEOUT_VALUE, &hmdServicePathHandle);
    if (FAILED(hresError))
    {
        CString strErrMsg=_TEXT("OpenKey");
        strErrMsg += _TEXT("(\"")+a_AdmNode.GetServicePath()+_TEXT(",WRITE")+_TEXT("\")");
        Error(LPCTSTR(strErrMsg));
    }
    else
    {
        // create the node
        hresError = pcAdmCom->AddKey(hmdServicePathHandle,
                            IADM_PBYTE LPCTSTR(a_AdmNode.GetRelPathFromInstance()));
        if (FAILED(hresError)) {
            CString strErrMsg=_TEXT("AddKey");
            strErrMsg += _TEXT("(\"")+a_AdmNode.GetRelPathFromInstance()+_TEXT("\")");
            Error(LPCTSTR(strErrMsg));
        }
        //close the service object
        CloseObject(hmdServicePathHandle);
    }
#endif


// This function enables to reuse open handles in order to improve performance
// !!it supports only one acticve handle (otherwise the processing may fail)

METADATA_HANDLE CAdmUtil::OpenObjectTo_hmd(CAdmNode & a_AdmNode, DWORD dwPermission, BOOL fCreate)
{
        CString strPathToOpen=a_AdmNode.GetLMNodePath();
        if(m_hmd!=0 && strPathToOpen.CompareNoCase(m_strNodePath)==0 && m_dwPermissionOfhmd == dwPermission )
        {  //we can reuse already opened node

        }
        else
        {
                if(m_hmd != 0)
                {
                        CloseObject(m_hmd);
                        m_hmd=0;
                }
                m_hmd = OpenObject(a_AdmNode, dwPermission, fCreate);
                m_dwPermissionOfhmd = dwPermission;
                m_strNodePath = strPathToOpen;
        }
    return m_hmd;
}

void CAdmUtil::CloseObject_hmd(void)
{
	if(m_hmd != 0)
	{
		CloseObject(m_hmd);
		m_hmd=0;
	}
}
//*******************************************************************************

void CAdmUtil::GetProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp)
{
    DWORD dwRequiredDataLen=0;
    WORD wDataBufferSize=0;
    PBYTE DataBuffer=0;

    DWORD dwPropertyCode=a_AdmProp.GetIdentifier();

    if(dwPropertyCode==0)   Error(_TEXT("Property name not found"));
    else
    {
        //MD_SET_DATA_RECORD(&a_AdmProp.mdr,
        //                 0,
        //                 METADATA_INHERIT | METADATA_PARTIAL_PATH,
        //                 0,
        //                 0,
        //                 wDataBufferSize,
        //                 pbDataBuffer);

        //a_AdmProp.SetIdentifier(dwPropertyCode); //has to be set beforehand
        a_AdmProp.SetDataType(0);
        a_AdmProp.SetUserType(0);
        a_AdmProp.SetAttrib(0);

        METADATA_HANDLE hmd = OpenObjectTo_hmd(a_AdmNode,
                                         METADATA_PERMISSION_READ);
        if (SUCCEEDED(hresError))
        {
            hresError = pcAdmCom->GetData(hmd,
                IADM_PBYTE  _TEXT(""),
        &a_AdmProp.mdr, &dwRequiredDataLen);
            if (FAILED(hresError)) {
                if (hresError == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {
    ///////////             delete []pbDataBuffer;
                    pbDataBuffer=new BYTE[dwRequiredDataLen];
                    if (pbDataBuffer==0) {
                        hresError = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                        Error(_TEXT("Buffer resize failed"));
                    }
                    else {
                        a_AdmProp.mdr.dwMDDataLen = dwRequiredDataLen;
                        a_AdmProp.mdr.pbMDData = pbDataBuffer;
                        hresError = pcAdmCom->GetData(hmd,
                        IADM_PBYTE _TEXT(""), &a_AdmProp.mdr, &dwRequiredDataLen);
                        if (FAILED(hresError)) Error(_TEXT("GetData"));
                    }
                }
                else
                     Error(_TEXT("GetData"));;

            }
            //CloseObject (hmd);  we might reuse it
        }

    }
}

//if lplpszPropertyValue[1]==NULL it means there is only one value (it is not a multistring)


void CAdmUtil::SetProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp)
{
    METADATA_HANDLE hmd = OpenObjectTo_hmd(a_AdmNode,
                                         METADATA_PERMISSION_WRITE,TRUE/*create node if doesn't exist*/);
    if (SUCCEEDED(hresError))
    {
        SetProperty(&a_AdmProp.mdr,hmd);
        //CloseObject(hmd); we will reuse it
    }
}


void CAdmUtil::SetProperty(PMETADATA_RECORD a_pmdrData,METADATA_HANDLE a_hmd)
{
    hresError = pcAdmCom->SetData(a_hmd,
                            IADM_PBYTE _TEXT(""), a_pmdrData);
    if (FAILED(hresError))  Error(_TEXT("SetData"));

}

void CAdmUtil::SaveData(void)
{
        if (m_hmd!=0)
        {  //we have to close reusable handle in order to save successfully
                CloseObject(m_hmd);
                m_hmd=0;
        }
    hresError = pcAdmCom->SaveData();
        if (FAILED(hresError)) Error(_TEXT("SaveData"));
}

//****************************************************************************
//DELETE PROPERTY

void CAdmUtil::DeleteProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp)
{
    METADATA_HANDLE hmd = OpenObjectTo_hmd(a_AdmNode,
                                         METADATA_PERMISSION_WRITE,TRUE/*create node if doesn't exist*/);
    if (SUCCEEDED(hresError))
    {
        DeleteProperty(&a_AdmProp.mdr,hmd);
        // CloseObject(hmd); we will reuse it
    }
}


void CAdmUtil::DeleteProperty(PMETADATA_RECORD a_pmdrData,METADATA_HANDLE a_hmd)
{
    hresError = pcAdmCom->DeleteData(a_hmd,
                IADM_PBYTE  _TEXT(""), a_pmdrData->dwMDIdentifier,ALL_METADATA);
    if (FAILED(hresError))  Error(_TEXT("DeleteData"));

}

//****************************************************************************
//DELETE OBJECT

void CAdmUtil::DeleteObject(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp)
{
    CAdmNode NodeToOpen = a_AdmNode.GetParentNodePath();
    METADATA_HANDLE hmd = OpenObjectTo_hmd(NodeToOpen,
                                         METADATA_PERMISSION_WRITE,FALSE/*create node if doesn't exist*/);
    if (SUCCEEDED(hresError))
    {
        CString strToDelete=a_AdmNode.GetCurrentNodeName();
        if(strToDelete==_TEXT(""))
            strToDelete=_TEXT("//"); //empty name has to be wrapped with '/'
        DeleteObject(hmd,strToDelete);
        //CloseObject(hmd); we will reuse it
    }
}

void CAdmUtil::DeleteObject(METADATA_HANDLE a_hmd, CString& a_strObjectName)
{
    hresError = pcAdmCom->DeleteKey(a_hmd, IADM_PBYTE LPCTSTR(a_strObjectName));
    if (FAILED(hresError))  Error(_TEXT("DeleteKey"));

}






void CAdmUtil::EnumPropertiesAndPrint(CAdmNode& a_AdmNode,
                                      CAdmProp a_AdmProp, //cannot be passed by reference
                                      BYTE bRecurLevel,
                                      METADATA_HANDLE a_hmd,
                                      CString & a_strRelPath)
{
    CAdmProp mdrData=a_AdmProp;
    DWORD dwRequiredDataLen=0;
    PBYTE DataBuffer=0;
    METADATA_HANDLE hmdMain;

    if(a_hmd==0) //if handle was not passed then open one
    {
        hmdMain = OpenObjectTo_hmd(a_AdmNode, METADATA_PERMISSION_READ);
        if (FAILED(hresError))
                return;
    }
    else
        hmdMain = a_hmd;

    for (int j=0;;j++) { //cycle for properties
        MD_SET_DATA_RECORD(&mdrData.mdr,
                       0,
                       a_AdmProp.mdr.dwMDAttributes,
                       a_AdmProp.mdr.dwMDUserType,
                       a_AdmProp.mdr.dwMDDataType,
                       dwRequiredDataLen,
                       pbDataBuffer);

        hresError = pcAdmCom->EnumData(hmdMain,
            IADM_PBYTE LPCTSTR(a_strRelPath), &mdrData.mdr,j, &dwRequiredDataLen);
        if (FAILED(hresError))
        {
            if(hresError == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS))
            {
                hresError=0; //NO MORE ITEMS IS NOT ERROR FOR US
                break; //end of items
            }
            else if (hresError == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER))
            {
                delete pbDataBuffer;
                pbDataBuffer=new BYTE[dwRequiredDataLen];
                if (pbDataBuffer==0)
                {
                    hresError = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    Error(_TEXT("Buffer resize failed"));
                }
                else
                {
                    mdrData.mdr.dwMDDataLen = dwRequiredDataLen;
                    mdrData.mdr.pbMDData = pbDataBuffer;
                    hresError = pcAdmCom->EnumData(hmdMain,
                            IADM_PBYTE LPCTSTR(a_strRelPath), &mdrData.mdr,j, &dwRequiredDataLen);
                    if (FAILED(hresError)) Error(_TEXT("GetData"));
                }
            }
            else
                Error(_TEXT("EnumData"));
        }
        //else
          //  Error(_TEXT("EnumData"));

        if(SUCCEEDED(hresError)) //we  enumerated successfully, let's print
        {
            nest_print(bRecurLevel+1);

            mdrData.PrintProperty();
        }
        else
        {
            break;
        }
    }  //end for j   - cycle for properties
    //if(a_hmd==0)
    //    CloseObject(hmdMain); we will reuse it //close only if we opened at the beginning
}


void CAdmUtil::EnumAndPrint(CAdmNode&   a_AdmNode,
                            CAdmProp&   a_AdmProp,
                            BOOL        a_fRecursive,
                            BYTE        a_bRecurLevel,
                            METADATA_HANDLE a_hmd,
                            CString&    a_strRelPath)
{
    _TCHAR NameBuf[METADATA_MAX_NAME_LEN];

    METADATA_HANDLE hmdMain;

    if(a_hmd==0) //if handle was not passed then open one
    {
        hmdMain = OpenObjectTo_hmd(a_AdmNode, METADATA_PERMISSION_READ);
        if (FAILED(hresError))
                return;
    }
    else
        hmdMain = a_hmd;


    //printf("[RELATIVE PATH : \"%s\"]\n",LPCTSTR(a_strRelPath));
    //print the properties of the node
    EnumPropertiesAndPrint(a_AdmNode,a_AdmProp,a_bRecurLevel,hmdMain,a_strRelPath);


    for (int i=0; ;i++) {  //cycle for subnodes
        hresError = pcAdmCom->EnumKeys(hmdMain,
            IADM_PBYTE LPCTSTR(a_strRelPath), IADM_PBYTE NameBuf, i);
        if(FAILED(hresError)) {
            if(hresError == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS)) {
                hresError=0; //NO MORE ITEMS IS NOT ERROR FOR US
                break; //end of cycle
            }
            else
            {
                Error(_TEXT("EnumKeys"));
                break;
            }

        }
        else {

          //process and print node info

            CString strNewRelPath( a_strRelPath );
            if(NameBuf[0]==0) //empty name
                strNewRelPath+=_TEXT("//"); //add two slashes -> this is required by metabase
            else
            {
                UINT  nLen;
                //if(strNewRelPath.GetLength()>=1 && strNewRelPath.Right(1)==_TEXT("/")) {
                if( (nLen=strNewRelPath.GetLength())>=1 && (strNewRelPath.GetAt(nLen-1)=='/') ) {
                }
                else {
                    strNewRelPath+=_TEXT("/"); //add only if it is not at the end of string.
                }
                strNewRelPath+=NameBuf;
            }
            CString strStringToPrint( a_AdmNode.GetNodePath() );
            UINT  nLen = strStringToPrint.GetLength();

            //if (strStringToPrint.Right(2)==_TEXT("//"))
            if ((nLen > 2) && strStringToPrint.GetAt(nLen-1)=='/'
                           && strStringToPrint.GetAt(nLen-2)=='/' )
            {
                strStringToPrint += strNewRelPath.Mid(1); //strip first '/'
            }
            else
            {
                strStringToPrint += strNewRelPath;
            }
            LPCTSTR lpszStr=LPCTSTR(strStringToPrint);
            this->Print(_TEXT("[%s]\n"),lpszStr );

            if(a_fRecursive)
            {
                EnumAndPrint(a_AdmNode,a_AdmProp ,a_fRecursive, a_bRecurLevel+1, hmdMain,strNewRelPath);
            }
            else
            {  //no recursion

            }
        }
    } //end for i  - cycle for nodes
    //if(a_hmd==0)
    //    CloseObject(hmdMain); //we will reuse it //close only if we opened at the beginning
}


//****************************************************************
//  the following function is somehow complicated because
//  metadata copy function doesn't support copying of one object to another place with different name
//  e.g. ComAdmCopyKey will copy /W3SVC/1//scripts/oldscripts1 /W3SVC/1//oldscripts2
//                          will create /W3SVC/1//oldscripts2/oldscripts1
//

void CAdmUtil::CopyObject(CAdmNode& a_AdmNode,
                          CAdmNode& a_AdmNodeDst)
{
    CString strSrcPath=a_AdmNode.GetNodePath();
    CString strDstPath=a_AdmNodeDst.GetNodePath();


    CString strCommonPath; //=_TEXT("");
    CString strRelSrcPath=strSrcPath; //relative to common path
    CString strRelDstPath=strDstPath; //relative to common path


    //we cannot open Source Path for reading because if will diable wrining to all parent nodes
    //e.g. copy /W3SVC/1//scripts/oldscripts /W3SVC/1//oldscripts would fail
    //It is necessary to find common partial path and open metabase object for that common partial path for READ/WRITE

    //!!!!!!!!!!!!!!!!! assume that paths are not case sensitive

    int MinLength=strSrcPath.GetLength();
    int i;
    //find shorter from strings
    if(strDstPath.GetLength() < MinLength)
            MinLength=strDstPath.GetLength();
    for(i=0; i<MinLength; i++)
    {
        if(strSrcPath.GetAt(i)!=strDstPath.GetAt(i) )
            // common path cannot be any longer;
            break;
    }
    //  now find the previous '/' and all before '/' is the common path
    for(i=i-1; i>=0;i--)
    {
        if(strSrcPath.GetAt(i)==_T('/'))
        {
            strCommonPath=strSrcPath.Left(i+1);//take the trailing '/' with you
            strRelSrcPath=strSrcPath.Mid(i+1);
            strRelDstPath=strDstPath.Mid(i+1);
            break;
        }
    }




    _TCHAR NameBuf[METADATA_MAX_NAME_LEN];

    METADATA_HANDLE hmdCommon=0;

    CAdmNode CommonNode;
    CommonNode.SetPath(strCommonPath);


    hmdCommon = OpenObjectTo_hmd(CommonNode, METADATA_PERMISSION_READ+METADATA_PERMISSION_WRITE);
    if (FAILED(hresError))
            return;

// Altered by Adam Stone on 30-Jan-97  The following code was changed to comply with
// the changes to the metabase ComMDCopyKey function.
    // Copy the metadata to the destination
    hresError = pcAdmCom->CopyKey (hmdCommon,
                                    IADM_PBYTE LPCTSTR(strRelSrcPath),
                                    hmdCommon,
                                    IADM_PBYTE LPCTSTR(strRelDstPath),
                                    FALSE, // Do NOT overwrite
                                    TRUE); // Copy do NOT move

    if (FAILED(hresError)) // if the node already exists, it is error
    {
        CString strErrMsg=_TEXT("CopyKey");
        strErrMsg += _TEXT("(\"")+a_AdmNodeDst.GetRelPathFromInstance()+_TEXT("\")");
        Error(LPCTSTR(strErrMsg));
    }

// All of the commented out code has become unneccessary as of 30-Jan-97  because of a change
// in the metabase.  ComMDCopyKey now copies to the destination, overwriting if
// requested.  It used to copy to a child of the destination object.
/*  // create the node
*   hresError = pcAdmCom->AddKey(hmdCommon,
*                       IADM_PBYTE LPCTSTR(strRelDstPath));
*   if (FAILED(hresError)) { //if the node exists, it is error)
*       CString strErrMsg=_TEXT("AddKey");
*       strErrMsg += _TEXT("(\"")+a_AdmNodeDst.GetRelPathFromInstance()+_TEXT("\")");
*       Error(LPCTSTR(strErrMsg));
*   }
*   else //no error when creating new node
*   {
*       for (i=0; ;i++) {  //cycle for subnodes
*           hresError = pcAdmCom->EnumKeys(hmdCommon,
*               IADM_PBYTE LPCTSTR(strRelSrcPath), (PBYTE)NameBuf, i);
*           if(FAILED(hresError)) {
*               if(hresError == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS)) {
*                   hresError=0; //this is not an error
*                   break; //end of cycle
*               }
*               else
*               {
*                   Error(_TEXT("EnumKeys"));
*                   break;
*               }
*
*           }
*           else {
*
*             //process and copy node child node
*
*               CString strNewRelSrcPath=strRelSrcPath;
*               if(NameBuf[0]==0) //empty name
*                   strNewRelSrcPath+=_TEXT("//"); //add two slashes -> this is required by metabase
*               else
*               {   if(strNewRelSrcPath.GetLength()>=1 && strNewRelSrcPath.Right(1)==_TEXT("/")) {
*                   }
*                   else {
*                       strNewRelSrcPath+=_TEXT("/"); //add only if it is not at the end of string.
*                   }
*                   strNewRelSrcPath+=NameBuf;
*               }
*               hresError = pcAdmCom->CopyKey(
*                   hmdCommon, (PBYTE) LPCTSTR(strNewRelSrcPath),
*                   hmdCommon, (PBYTE) LPCTSTR(strRelDstPath),TRUE,TRUE);
*               if(FAILED(hresError)) {
*                   Error(_TEXT("CopyKey"));
*               }
*
*
*           }
*       } //end for i  - cycle for nodes
*
*
*       //WE COPIED ALL NODES, COPY PARAMETERS NOW
*       CAdmProp mdrData;
*       DWORD dwRequiredDataLen=0;
*       PBYTE DataBuffer=0;
*
*
*
*       for (int j=0;;j++) { //cycle for properties
*           MD_SET_DATA_RECORD(&mdrData.mdr,
*                          0,
*                          0,
*                          0,
*                          0,
*                          dwRequiredDataLen,
*                          pbDataBuffer);
*
*           hresError = pcAdmCom->EnumData(hmdCommon,
*                           (PBYTE) LPCTSTR(strRelSrcPath)
*                           , &mdrData.mdr,j, &dwRequiredDataLen);
*           if (FAILED(hresError))
*           {
*               if(hresError == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS))
*               {
*                   hresError=0; //NO MORE ITEMS IS NOT ERROR FOR US
*                   break; //end of items
*               }
*               else if (hresError == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER))
*               {
///////////                 delete pbDataBuffer;
*                   pbDataBuffer=new BYTE[dwRequiredDataLen];
*                   if (pbDataBuffer==0)
*                   {
*                       hresError = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
*                       Error(_TEXT("Buffer resize failed"));
*                   }
*                   else
*                   {
*                       mdrData.mdr.dwMDDataLen = dwRequiredDataLen;
*                       mdrData.mdr.pbMDData = pbDataBuffer;
*                       hresError = pcAdmCom->EnumData(hmdCommon,
*                           (PBYTE) LPCTSTR(strRelSrcPath)
*                           , &mdrData.mdr,j, &dwRequiredDataLen);
*                       if (FAILED(hresError)) Error(_TEXT("GetData"));
*                   }
*               }
*               else
*                   Error(_TEXT("EnumData"));
*           }
*           else
*               Error(_TEXT("EnumData"));
*
*           if(SUCCEEDED(hresError)) //we  enumerated successfully, let's print
*           {
*               hresError = pcAdmCom->SetData(hmdCommon, (PBYTE) LPCTSTR(strRelDstPath),&mdrData.mdr);
*               if (FAILED(hresError))  Error(_TEXT("SetData"));
*           }
*           else
*           {
*               break;
*           }
*       }  //end for j   - cycle for properties
*   }
*/


    //CloseObject(hmdCommon); //we will reuse handle //close only if we opened at the beginning

}

void CAdmUtil::RenameObject(CAdmNode& a_AdmNode,
                          CAdmNode& a_AdmNodeDst)
{
    CString strSrcPath=a_AdmNode.GetNodePath();
    CString strDstPath=a_AdmNodeDst.GetNodePath();


    CString strCommonPath=_TEXT("");
    CString strRelSrcPath=strSrcPath; //relative to common path
    CString strRelDstPath=strDstPath; //relative to common path


    //we cannot open Source Path for reading because if will diable wrining to all parent nodes
    //e.g. copy /W3SVC/1//scripts/oldscripts /W3SVC/1//oldscripts would fail
    //It is necessary to find common partial path and open metabase object for that common partial path for READ/WRITE

    //!!!!!!!!!!!!!!!!! assume that paths are not case sensitive

    int MinLength=strSrcPath.GetLength();
    int i;
    //find shorter from strings
    if(strDstPath.GetLength() < MinLength)
            MinLength=strDstPath.GetLength();
    for(i=0; i<MinLength; i++)
    {
        if(strSrcPath.GetAt(i)!=strDstPath.GetAt(i) )
            // common path cannot be any longer;
            break;
    }
    //  now find the previous '/' and all before '/' is the common path
    for(i=i-1; i>=0;i--)
    {
        if(strSrcPath.GetAt(i)==_T('/'))
        {
            strCommonPath=strSrcPath.Left(i+1);//take the trailing '/' with you
            strRelSrcPath=strSrcPath.Mid(i); // keep the trailing '/' in case it's "//"
            strRelDstPath=strDstPath.Mid(i+1);
            break;
        }
    }




    _TCHAR NameBuf[METADATA_MAX_NAME_LEN];

    METADATA_HANDLE hmdCommon=0;

    CAdmNode CommonNode;
    CommonNode.SetPath(strCommonPath);


    hmdCommon = OpenObjectTo_hmd(CommonNode, METADATA_PERMISSION_READ+METADATA_PERMISSION_WRITE);
    if (FAILED(hresError))
            return;

    hresError = pcAdmCom->RenameKey (hmdCommon,
                                    IADM_PBYTE LPCTSTR(strRelSrcPath),
                                    IADM_PBYTE LPCTSTR(strRelDstPath)
                                   );


    if (FAILED(hresError)) // if the node already exists, it is error
    {
        CString strErrMsg=_TEXT("RenameKey");
        strErrMsg += _TEXT("(\"")+a_AdmNodeDst.GetRelPathFromInstance()+_TEXT("\")");
        Error(LPCTSTR(strErrMsg));
    }

    //CloseObject(hmdCommon); //we will reuse it//close only if we opened at the beginning

}



//**********************************************************************
//IMPLEMENTATION  of AdmUtil
//**********************************************************************


void CAdmUtil::Run(CString& strCommand, CAdmNode& a_AdmNode, CAdmProp& a_AdmProp, CAdmNode& a_AdmDstNode,
                LPCTSTR *a_lplpszPropValue,
                DWORD *a_lpdwPropValueLength,
                WORD wPropValueCount)

{

    DWORD dwCommandCode=0;

    dwCommandCode = tCommandNameTable::MapNameToCode(strCommand);

    switch(dwCommandCode)
    {

    case CMD_SAVE:
    SaveData();
    if (FAILED(hresError)) {}
    else{
        Print(_TEXT("saved\n"));
    }
    break;

    case CMD_CREATE:
    {
        if (a_AdmNode.GetProperty()!=_TEXT("")) //property name cannot be used
            Error(_TEXT("property name for CREATE not supported"));
    //    else if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
    //        Error(_TEXT("service name for CREATE is missing"));
        else
        {
            CreateObject(a_AdmNode);
            if( SUCCEEDED(QueryLastHresError()))
            {
              //  SaveData(); //end of transaction
                if( SUCCEEDED(QueryLastHresError()))
                {
                    Print(_TEXT("created \"%s\"\n"), LPCTSTR(a_AdmNode.GetNodePath()));
                }
            }
        }
    }
    break;
    case CMD_SET:
    {
        CAdmProp AdmPropToGet;
        AdmPropToGet = a_AdmProp;
        AdmPropToGet.SetAttrib(0);
        AdmPropToGet.SetUserType(0);
        AdmPropToGet.SetDataType(0);

        DisablePrint(); //do not print any error message
        GetProperty(a_AdmNode, AdmPropToGet);
        EnablePrint(); //continue printing error messages

        //*************************SETTING ATTRIB, DATATYPE, USERTYPE
        // if the parameter exists in the metabase, then existing ATTRIB, DATATYPE, USERTYPE
        //              will be used , but this can be overwritten from a_AdmProp
        // if the parameter doesn't exists in the metabase, then default ATTRIB, DATATYPE, USERTYPE
        //              (see tables.cpp) will be used , but this can be overwritten from a_AdmProp

        if(FAILED(QueryLastHresError()))
        {  //store the value to be set into a_AdmProp
                //FIND DEFAULT SETTINGS
                DWORD dwPropCode=a_AdmProp.GetIdentifier();
                tPropertyNameTable * PropNameTableRecord = tPropertyNameTable::FindRecord(dwPropCode);
                if (PropNameTableRecord!=NULL)
                {
                        AdmPropToGet.SetIdentifier(PropNameTableRecord->dwCode);
                        AdmPropToGet.SetAttrib(PropNameTableRecord->dwDefAttributes) ;
                        AdmPropToGet.SetUserType(PropNameTableRecord->dwDefUserType);
                        AdmPropToGet.SetDataType(PropNameTableRecord->dwDefDataType);
                }
        }
        else
        {  //reuse the existing settings
                if( a_AdmProp.GetDataType()!=0 &&(a_AdmProp.GetDataType()!= AdmPropToGet.GetDataType()))
                {
                        Error(_TEXT("Cannot redefine data type from %s to %s"),
                                tDataTypeNameTable::MapCodeToName(AdmPropToGet.GetDataType()),
                                tDataTypeNameTable::MapCodeToName(a_AdmProp.GetDataType()));
                        break;
                }
        }
        // use settings passed to the function if set
        if(!a_AdmProp.IsSetDataType())
                a_AdmProp.SetDataType(AdmPropToGet.GetDataType()); //reuse existing data type
        if(!a_AdmProp.IsSetUserType())
                a_AdmProp.SetUserType(AdmPropToGet.GetUserType()); //reuse existing user type
        if(!a_AdmProp.IsSetAttrib())
                a_AdmProp.SetAttrib(AdmPropToGet.GetAttrib()); //reuse exixting attrib




        if(a_AdmProp.SetValueByDataType( (LPCTSTR *)a_lplpszPropValue, a_lpdwPropValueLength, wPropValueCount)==0)
             Error(_TEXT("SetValueByDataType failed"));
        else
        {
           // if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
           //     Error(_TEXT("service name for SET is missing"));
           // else
            if (a_AdmNode.GetProperty()!=_TEXT(""))
            {
                SetProperty(a_AdmNode, a_AdmProp);
                if( SUCCEEDED(QueryLastHresError()))
                {
                    //SaveData(); //end of transaction
                    if( SUCCEEDED(QueryLastHresError()))
                    {
                        GetProperty(a_AdmNode, a_AdmProp);
                        if(SUCCEEDED(QueryLastHresError()))
                            a_AdmProp.PrintProperty();
                    }
                }
            }else
                Error(_TEXT("property name missing for SET command"));
        }
        break;
    }
    case CMD_DELETE:

        //if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
        //    Error(_TEXT("service name for DELETE is missing"));
        if (IsServiceName(a_AdmNode.GetService()) && a_AdmNode.GetInstance()==_TEXT("") && a_AdmNode.GetIPath()==_TEXT("") && a_AdmNode.GetProperty()==_TEXT(""))
            Error(_TEXT("cannot delete service"));
        else if (a_AdmNode.GetInstance()==_TEXT("1") && a_AdmNode.GetIPath()==_TEXT("") && a_AdmNode.GetProperty()==_TEXT("")) //property name cannot be used
            Error(_TEXT("cannot delete 1. instance"));
        else if (a_AdmNode.GetProperty()!=_TEXT(""))
        {
            DeleteProperty(a_AdmNode, a_AdmProp);
        }
        else
        {
            DeleteObject(a_AdmNode, a_AdmProp);
        }
            //if( SUCCEEDED(QueryLastHresError()))
            //{
            //  GetProperty(a_AdmNode, a_AdmProp);
            //  if(SUCCEEDED(QueryLastHresError()))
            //      a_AdmProp.PrintProperty();
            //}
        if(SUCCEEDED(QueryLastHresError()))
        {
            //SaveData(); //end of transaction
            if( SUCCEEDED(QueryLastHresError()))
            {
                Print(_TEXT("deleted \"%s"), LPCTSTR(a_AdmNode.GetNodePath()));
                if(a_AdmNode.GetProperty()!=_TEXT(""))
                    Print(_TEXT("%s"),LPCTSTR(((a_AdmNode.GetNodePath().Right(1)==_TEXT("/"))?_TEXT(""):_TEXT("/"))+
                                    a_AdmNode.GetProperty()));
                Print(_TEXT("\"\n"));
            }

        }
        break;

    case CMD_GET:
        //    if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
        //        Error(_TEXT("service name for GET is missing"));

        //    else
            if (a_AdmNode.GetProperty()!=_TEXT(""))
            {
                GetProperty(a_AdmNode, a_AdmProp);
                if(SUCCEEDED(QueryLastHresError()))
                    a_AdmProp.PrintProperty();
            }
            else
            {
                EnumPropertiesAndPrint(a_AdmNode, a_AdmProp);
            }
        break;
    case CMD_COPY:

            if(a_AdmDstNode.GetNodePath()==_TEXT(""))
                Error(_TEXT("destination path is missing"));
            else if(a_AdmNode.GetProperty()!=_TEXT("") || a_AdmDstNode.GetProperty()!=_TEXT(""))
                Error(_TEXT("copying of properties (parameters) not supported\n"));
            //else if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
            //    Error(_TEXT("service name in source path for COPY is missing"));
            //else if (a_AdmDstNode.GetService()==_TEXT("")) //property name cannot be used
            //    Error(_TEXT("service name for destination path COPY is missing"));
            //else if (a_AdmNode.GetInstance()==_TEXT("")) //property name cannot be used
            //    Error(_TEXT("instance number in source path for COPY is missing"));
            //else if (a_AdmDstNode.GetInstance()==_TEXT("")) //property name cannot be used
            //    Error(_TEXT("instance number in destination path for COPY is missing"));

            else
            {
                CopyObject(a_AdmNode,a_AdmDstNode);
                if(SUCCEEDED(QueryLastHresError()))
                {
                    //SaveData(); //end of transaction
                    if( SUCCEEDED(QueryLastHresError()))
                    {

                        Print(_TEXT("copied from %s to %s\n"), LPCTSTR(a_AdmNode.GetNodePath()),LPCTSTR(a_AdmDstNode.GetNodePath()));
                    }
                }
                break;
            }
        break;
    case CMD_RENAME:
            if(a_AdmDstNode.GetNodePath()==_TEXT(""))
                Error(_TEXT("destination path is missing"));
            else if(a_AdmNode.GetProperty()!=_TEXT("") || a_AdmDstNode.GetProperty()!=_TEXT(""))
                Error(_TEXT("renaming of properties (parameters) not supported"));
            //else if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
            //    Error(_TEXT("service name in source path for RENAME is missing"));
            //else if (a_AdmDstNode.GetService()==_TEXT(""))
            //    Error(_TEXT("service name for destination path RENAME is missing"));
            //else if (a_AdmNode.GetInstance()==_TEXT(""))
            //    Error(_TEXT("instance number in source path for RENAME is missing"));
            //else if (a_AdmDstNode.GetInstance()==_TEXT(""))
            //   Error(_TEXT("instance number in destination path for RENAME is missing"));
            else if (a_AdmNode.GetInstance()==_TEXT("1") && a_AdmNode.GetIPath()==_TEXT(""))
                Error(_TEXT("cannot rename 1. instance"));
            else if (a_AdmNode.GetRelPathFromService().CompareNoCase(a_AdmDstNode.GetRelPathFromService())==0)
                Error(_TEXT("cannot rename to itself"));
            else
            {  //check if one of the paths is not the child of the other one
                CString str1=a_AdmNode.GetRelPathFromService();
                CString str2=a_AdmDstNode.GetRelPathFromService();

                CString strCommonPath=FindCommonPath(str1,str2);

                if(strCommonPath.CompareNoCase(str1)==0 ||
                        strCommonPath.CompareNoCase(str1)==0)
                    Error(_TEXT("cannot rename - one path is the child of the other"));
                else
                { //O.K.
                    //CopyObject(a_AdmNode,a_AdmDstNode);
                    //if(SUCCEEDED(QueryLastHresError()))
                    //{
                    //    DeleteObject(a_AdmNode,a_AdmProp);
                    //    if(SUCCEEDED(QueryLastHresError()))
                    //    {
                    //       // SaveData(); //end of transaction
                    //        if( SUCCEEDED(QueryLastHresError()))
                    //        {
                    //            Print("renamed from %s to %s\n", LPCTSTR(a_AdmNode.GetNodePath()),LPCTSTR(a_AdmDstNode.GetNodePath()));
                    //        }
                    //    }
                    // }
                    RenameObject(a_AdmNode,a_AdmDstNode);
                    if(SUCCEEDED(QueryLastHresError()))
                    {
                      // SaveData(); //end of transaction
                       if( SUCCEEDED(QueryLastHresError()))
                       {

                           Print(_TEXT("renamed from %s to %s\n"), LPCTSTR(a_AdmNode.GetNodePath()),LPCTSTR(a_AdmDstNode.GetNodePath()));
                       }
                    }
                }
            }

            break;

    case CMD_ENUM:
            EnumAndPrint(a_AdmNode, a_AdmProp, FALSE/*no recursion*/);
            break;
    case CMD_ENUM_ALL:
            EnumAndPrint(a_AdmNode, a_AdmProp,TRUE/*no recursion*/);
            break;
    case CMD_APPCREATEINPROC:
            AppCreateInProc(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;

    case CMD_APPDELETE:
            AppDelete(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;

    case CMD_APPRENAME:
            AppRename(a_AdmNode,a_AdmDstNode,a_AdmNode.GetComputer());
            break;

    case CMD_APPCREATEOUTPROC:
            AppCreateOutProc(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;

    case CMD_APPGETSTATUS:
            AppGetStatus(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;

    case CMD_APPUNLOAD:
            AppUnLoad(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;


    default:
        Print(_TEXT("Command not recognized: %s\n"),strCommand);
        hresError=RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        return ;

    }
    return;
}


//if hresError is 0, we will set it to invalid parameter

void CAdmUtil::Error(const _TCHAR * format,...)
{
   _TCHAR buffer[2000];
   va_list marker;
   va_start( marker, format );     /* Initialize variable arguments. */

   int x=_vstprintf(buffer, format, marker);

   va_end( marker );              /* Reset variable arguments.      */
    if(hresError==0)
    {
        if(fPrint)
    {
            _ftprintf(stderr,_TEXT("Error: %s\n"),buffer);
    }

        hresError=RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER); //little trick
    }
    else
    {


        if(fPrint)
        {
            _ftprintf(stderr,_TEXT("Error: %s - HRES(0x%x)   %s\n"), buffer, hresError/*, ConvertHresToDword(hresError),ConvertHresToDword(hresError)*/,ConvertReturnCodeToString(ConvertHresToDword(hresError)));
	    if(getenv("MDUTIL_ASCENT_LOG")!=NULL)
	    {
		//we got to do some ascent logging

		FILE *fpAscent;
		fpAscent=fopen("Ascent.log","a");
		if (fpAscent)
		{
			//new variation description
			fprintf(fpAscent,"Variation1: METADATA ACCESS (by mdutil.exe)\n");
			fprintf(fpAscent,"Explain: READ OR WRITE OPERATION TO METADATA \n");

			//variation summary
			fprintf(fpAscent,"Attempted: 1 \n");
			fprintf(fpAscent,"Passed: 0 \n");
			fprintf(fpAscent,"Failed: 1 \n");


			_ftprintf(fpAscent,_TEXT("Error: Operation failed with HRES(0x%x)\n"), hresError);

			fclose(fpAscent);
		}
	    }
	}
    }

    if(fPrint)
    {
	  if(getenv("MDUTIL_BLOCK_ON_ERROR")!=NULL && hresError!=0x80070003)  //path not found
	  {
		_ftprintf(stdout,_TEXT("\nHit SPACE to continue or Ctrl-C to abort.\n"));
		while(1)
		{
			while(!_kbhit())
			{
				;
			}

			if(_getch()==' ')
			{
				_ftprintf(stdout,_TEXT("Continuing...\n"));
				break;
			}
		}
	  }
     }

}

void CAdmUtil::Print(const _TCHAR * format,...)
{

   va_list marker;
   va_start( marker, format );     /* Initialize variable arguments. */
   if(fPrint)
    _vtprintf(format, marker);
   va_end( marker );              /* Reset variable arguments.      */
}


LPTSTR ConvertReturnCodeToString(DWORD ReturnCode)
{
    LPTSTR RetCode = NULL;
    switch (ReturnCode) {
    case ERROR_SUCCESS:
        RetCode = _TEXT("ERROR_SUCCESS");
        break;
    case ERROR_PATH_NOT_FOUND:
        RetCode = _TEXT("ERROR_PATH_NOT_FOUND");
        break;
    case ERROR_INVALID_HANDLE:
        RetCode = _TEXT("ERROR_INVALID_HANDLE");
        break;
    case ERROR_INVALID_DATA:
        RetCode =_TEXT("ERROR_INVALID_DATA");
        break;
    case ERROR_INVALID_PARAMETER:
        RetCode =_TEXT("ERROR_INVALID_PARAMETER");
        break;
    case ERROR_NOT_SUPPORTED:
        RetCode =_TEXT("ERROR_NOT_SUPPORTED");
        break;
    case ERROR_ACCESS_DENIED:
        RetCode =_TEXT("ERROR_ACCESS_DENIED");
        break;
    case ERROR_NOT_ENOUGH_MEMORY:
        RetCode =_TEXT("ERROR_NOT_ENOUGH_MEMORY");
        break;
    case ERROR_FILE_NOT_FOUND:
        RetCode =_TEXT("ERROR_FILE_NOT_FOUND");
        break;
    case ERROR_DUP_NAME:
        RetCode =_TEXT("ERROR_DUP_NAME");
        break;
    case ERROR_PATH_BUSY:
        RetCode =_TEXT("ERROR_PATH_BUSY");
        break;
    case ERROR_NO_MORE_ITEMS:
        RetCode =_TEXT("ERROR_NO_MORE_ITEMS");
        break;
    case ERROR_INSUFFICIENT_BUFFER:
        RetCode =_TEXT("ERROR_INSUFFICIENT_BUFFER");
        break;
    case ERROR_PROC_NOT_FOUND:
        RetCode =_TEXT("ERROR_PROC_NOT_FOUND");
        break;
    case ERROR_INTERNAL_ERROR:
        RetCode =_TEXT("ERROR_INTERNAL_ERROR");
        break;
    case MD_ERROR_NOT_INITIALIZED:
        RetCode =_TEXT("MD_ERROR_NOT_INITIALIZED");
        break;
    case MD_ERROR_DATA_NOT_FOUND:
        RetCode =_TEXT("MD_ERROR_DATA_NOT_FOUND");
        break;
    case ERROR_ALREADY_EXISTS:
        RetCode =_TEXT("ERROR_ALREADY_EXISTS");
        break;
    case MD_WARNING_PATH_NOT_FOUND:
        RetCode =_TEXT("MD_WARNING_PATH_NOT_FOUND");
        break;
    case MD_WARNING_DUP_NAME:
        RetCode =_TEXT("MD_WARNING_DUP_NAME");
        break;
    case MD_WARNING_INVALID_DATA:
        RetCode =_TEXT("MD_WARNING_INVALID_DATA");
        break;
    case ERROR_INVALID_NAME:
        RetCode =_TEXT("ERROR_INVALID_NAME");
        break;
    default:
        RetCode= _TEXT("");//RetCode = "Unrecognized Error Code");
        break;
    }
    return (RetCode);
}

DWORD ConvertHresToDword(HRESULT hRes)
{
    return HRESULTTOWIN32(hRes);
}

LPTSTR ConvertHresToString(HRESULT hRes)
{
    LPTSTR strReturn = NULL;

    if ((HRESULT_FACILITY(hRes) == FACILITY_WIN32) ||
        (HRESULT_FACILITY(hRes) == FACILITY_ITF) ||
        (hRes == 0)) {
        strReturn = ConvertReturnCodeToString(ConvertHresToDword(hRes));
    }
    else {
        switch (hRes) {
        case CO_E_SERVER_EXEC_FAILURE:
            strReturn =_TEXT("CO_E_SERVER_EXEC_FAILURE");
            break;
        default:
            strReturn =_TEXT("Unrecognized hRes facility");
        }
    }
    return(strReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpmd\jd_misc.h ===
#if !defined (JD_MISC_H)
#define JD_MISC_H 

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    jd_misc.h

Abstract:
	header file for jd_misc.cpp


Author:

    jaroslad  

Revision History:
    06-01-96      ( Jaroslad ) Original.

--*/

#include <windows.h>

int random(int low, int high);


enum Tptr_type {TYPE_TCHAR,TYPE_INT,TYPE_LONG, TYPE_WORD,TYPE_DWORD,TYPE_LPCTSTR};
enum Topt_mand {OPT,MAND}; // switches can be optional or mandatory


struct SParamDef
{
	_TCHAR *sw;     // letter for switch
	int  param_number; //number of parameters (0-zero,1 means exactly one,
					   // >1 means not more param than
	void * ptr;  // pointer to assign value of switch (depends on sw_type)
    
	enum Tptr_type  ptr_type;
	enum Topt_mand  opt_mand;

	_TCHAR * text_desc;  //description for usage print
	_TCHAR * text_param; //what param the switch requires 
					   //(if in usage is '...-c [file]' text_param is "file" )
	WORD * param_read; //same as curr_param_read, but used to export value to caller
	WORD  curr_param_read; // current nuber of params already assigned to ptr;
						// applies only with param_number >1
};
typedef struct SParamDef TParamDef;


void DisplayUsageAndExit( _TCHAR **argv, TParamDef *tt);
void DisplayUsage( _TCHAR **argv, TParamDef *tt);

void ParseParam(int argc, _TCHAR ** argv, TParamDef * tt);

int time_printf(_TCHAR *format, ...);

void fatal_error_printf(_TCHAR *format, ...);
void error_printf(_TCHAR *format, ...);




#define YES			TRUE
#define NO			FALSE

#define SUCCESS     TRUE
#define FAILURE     FALSE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpmd\ansimeta.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       ansimeta.cpp

   Abstract:

        WRAPPER functions for ANSI calls of UNICODE ADMCOM interface

   Environment:

      Win32 User Mode

   Author:

      jaroslad  (jan 1997)

--*/


#include "ansimeta.h"
#include <mbstring.h>


WCHAR * ConvertToUnicode(unsigned char * pszString);


WCHAR * ConvertToUnicode(CHAR * pszString)
{
	return ConvertToUnicode((unsigned char *) pszString);
}

WCHAR * ConvertToUnicode(unsigned char * pszString)
{ 
	if (pszString==NULL)
		return NULL;
	int Size_wszString = (_mbslen((const unsigned char *) pszString)+1)*sizeof(WCHAR);
	WCHAR * pwszString = new WCHAR[Size_wszString];
	if (pwszString== NULL)
	{
		return NULL;
	}
	MultiByteToWideChar(0, 0, (char *) pszString, -1, pwszString, Size_wszString);
	return pwszString;
}


CHAR * ConvertToMultiByte(WCHAR * pwszString)
{
	if(pwszString==NULL)
		return NULL;
	int Size_szString = (wcslen(pwszString)*sizeof(WCHAR)+1);
	CHAR * pszString = new CHAR[Size_szString];
	if (pszString== NULL)
	{
		return NULL;
	}
	WideCharToMultiByte(0, 0, pwszString, -1, pszString,Size_szString, NULL,NULL );
	return pszString;
}


HRESULT ConvertMetadataToAnsi(PMETADATA_RECORD pmdrMDData)
{		 
		HRESULT hRes=ERROR_SUCCESS;
     
		//convert data if STRING, EXPAND STRING or MULTISZ
		switch(pmdrMDData->dwMDDataType )
		{
		case STRING_METADATA:
	        case EXPANDSZ_METADATA:
		{
			CHAR * pszData= ConvertToMultiByte((WCHAR *) pmdrMDData->pbMDData);
			if (pszData==0)  {hRes=E_OUTOFMEMORY; goto Exit;}
			strcpy((char *)pmdrMDData->pbMDData,pszData);
			pmdrMDData->dwMDDataLen=strlen((char *)pmdrMDData->pbMDData)+1;
			delete [] pszData;
			break;
		}
		case MULTISZ_METADATA:
		{
			WCHAR *pwszMultiString = (WCHAR *) pmdrMDData->pbMDData;
			DWORD dwAnsiDataLen=0;
			do
			{
				CHAR * pszData= ConvertToMultiByte(pwszMultiString);
				if (pszData==0)  {hRes=E_OUTOFMEMORY; goto Exit;}
				strcpy((char *)(pmdrMDData->pbMDData)+dwAnsiDataLen,pszData);
				dwAnsiDataLen+=strlen(pszData)+1;
				pwszMultiString+=_mbslen((const unsigned char *)pszData)+1; //move pointer to the next string in MULTISZ
				delete [] pszData;
			}while((void *) pwszMultiString < (void *) (pmdrMDData->pbMDData+pmdrMDData->dwMDDataLen));
			pmdrMDData->dwMDDataLen=dwAnsiDataLen;
			break;
		}
		}
Exit:
	return hRes;
}

HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::AddKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath) 
{
	HRESULT hRes=0;
	WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);
	if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	hRes= this->m_pcAdmCom->AddKey(hMDHandle, pwszMDPath);
	
Exit:
	//release memory
	if( pwszMDPath!=0) delete [] pwszMDPath;
	return hRes;
}

        
HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::DeleteKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath) 
{
	HRESULT hRes=0;
	WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

	if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	hRes= this->m_pcAdmCom->DeleteKey(hMDHandle, pwszMDPath);
	
Exit:
	//release memory
	if( pwszMDPath!=0) delete [] pwszMDPath;
	return hRes;

}
        
        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::EnumKeys( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [size_is][out] */ unsigned char __RPC_FAR *pszMDName,
            /* [in] */ DWORD dwMDEnumObjectIndex) 
{
	HRESULT hRes=0;
	CHAR * pszMDName1=0;

	WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);
	WCHAR pwszMDName[METADATA_MAX_NAME_LEN];


	if ((pwszMDPath==0) || (pwszMDName==0)) { hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	hRes= this->m_pcAdmCom->EnumKeys(hMDHandle, pwszMDPath,pwszMDName,dwMDEnumObjectIndex);

	//convert pszMDName to ANSI
	pszMDName1=ConvertToMultiByte(pwszMDName);
	strcpy((char *)pszMDName,pszMDName1); 
Exit:
	//release memory
	if( pwszMDPath!=0) delete [] pwszMDPath;
	if( pszMDName1!=0) delete [] pszMDName1;
	return hRes;
}


        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::CopyKey( 
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
            /* [in] */ BOOL bMDOverwriteFlag,
            /* [in] */ BOOL bMDCopyFlag) 

{
	HRESULT hRes=0;

	WCHAR * pwszMDSourcePath=ConvertToUnicode(pszMDSourcePath);
	WCHAR * pwszMDDestPath=ConvertToUnicode(pszMDDestPath);

	if ((pwszMDSourcePath==0) || (pwszMDDestPath==0) ){ hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	hRes= this->m_pcAdmCom->CopyKey(hMDSourceHandle, pwszMDSourcePath, 
					hMDDestHandle, pwszMDDestPath, bMDOverwriteFlag, bMDCopyFlag);
Exit:
	//release memory
	if( pwszMDSourcePath!=0) delete [] pwszMDSourcePath;
	if( pwszMDDestPath!=0) delete [] pwszMDDestPath;
	return hRes;
}



        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::RenameKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDNewName) 
{
	HRESULT hRes=0;

	WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);
	WCHAR * pwszMDNewName=ConvertToUnicode(pszMDNewName);

	if ((pwszMDPath==0) || (pwszMDNewName==0)) { hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	hRes= this->m_pcAdmCom->RenameKey(hMDHandle, pwszMDPath,pwszMDNewName);
Exit:
	//release memory
	if( pwszMDPath!=0) delete [] pwszMDPath;
	if( pwszMDNewName!=0) delete [] pwszMDNewName;
	return hRes;
}




        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::SetData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ PMETADATA_RECORD pmdrMDData) 
{
	HRESULT hRes=0;
	WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

	if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	
     
	//convert data if STRING, EXPAND STRING or MULTISZ
	switch(pmdrMDData->dwMDDataType )
	{
	case STRING_METADATA:
	case EXPANDSZ_METADATA:
	{
		WCHAR * pwszData= ConvertToUnicode((CHAR *) pmdrMDData->pbMDData);
		if (pwszData==0)  {hRes=E_OUTOFMEMORY; goto Exit;}
		PBYTE  pbMDStoreData=pmdrMDData->pbMDData;
		DWORD dwMDStoreDataLen=pmdrMDData->dwMDDataLen;
		pmdrMDData->pbMDData= (PBYTE) pwszData;
		pmdrMDData->dwMDDataLen=(wcslen((WCHAR *)pmdrMDData->pbMDData)+1)*sizeof(WCHAR);

		hRes= this->m_pcAdmCom->SetData(hMDHandle, pwszMDPath,pmdrMDData);

		pmdrMDData->dwMDDataLen = dwMDStoreDataLen;
		pmdrMDData->pbMDData = pbMDStoreData;
		delete [] pwszData;
		break;
	}
	case MULTISZ_METADATA:
	{
		CHAR *pszMultiString = (CHAR *) pmdrMDData->pbMDData;
		WCHAR *pwszMDData=new WCHAR[(pmdrMDData->dwMDDataLen)];
		if (pwszMDData==0)  {hRes=E_OUTOFMEMORY; goto Exit;}
		DWORD dwUniDataLen=0;
		do
		{
			WCHAR * pwszData= ConvertToUnicode(pszMultiString);
			if (pwszData==0)  {hRes=E_OUTOFMEMORY; goto Exit;}
			wcscpy(pwszMDData+dwUniDataLen,pwszData);
			dwUniDataLen+=wcslen(pwszData)+1;
			delete [] pwszData;

			while(*(pszMultiString++)!=0); //move pointer to the next string in MULTISZ
		}while(*pszMultiString!=0);
		pwszMDData[dwUniDataLen++]=0;

		//store original values
		PBYTE pbMDStoreData=pmdrMDData->pbMDData;
		DWORD dwMDStoreDataLen=pmdrMDData->dwMDDataLen;
		
		pmdrMDData->dwMDDataLen=dwUniDataLen*sizeof(WCHAR);
		pmdrMDData->pbMDData= (PBYTE) pwszMDData;

		hRes= this->m_pcAdmCom->SetData(hMDHandle, pwszMDPath,pmdrMDData);

		delete [] pwszMDData;
		//restore original values
		pmdrMDData->dwMDDataLen = dwMDStoreDataLen;
		pmdrMDData->pbMDData = pbMDStoreData;
		break;
	}
	default:
	{
		hRes= this->m_pcAdmCom->SetData(hMDHandle, pwszMDPath,pmdrMDData);
	}
	} //end of switch

Exit:
	//release memory
	if( pwszMDPath!=0) delete [] pwszMDPath;
	return hRes;
}


        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::GetData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) 
{
	HRESULT hRes=0;
	WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

	if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	hRes= this->m_pcAdmCom->GetData(hMDHandle, pwszMDPath,pmdrMDData,pdwMDRequiredDataLen);
	if(SUCCEEDED(hRes))
	{
		ConvertMetadataToAnsi(pmdrMDData);
	}
	
Exit:
	//release memory
	if( pwszMDPath!=0) delete [] pwszMDPath;
	return hRes;
}


        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::DeleteData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType) 
{
	HRESULT hRes=0;
	WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

	if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	hRes= this->m_pcAdmCom->DeleteData(hMDHandle, pwszMDPath,dwMDIdentifier,dwMDDataType);
	
Exit:
	//release memory
	if( pwszMDPath!=0) delete [] pwszMDPath;
	return hRes;
}

        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::EnumData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [in] */ DWORD dwMDEnumDataIndex,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) 
        
{
	HRESULT hRes=0;
	WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

	if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	hRes= this->m_pcAdmCom->EnumData(hMDHandle, pwszMDPath,pmdrMDData,dwMDEnumDataIndex,pdwMDRequiredDataLen);
	if(SUCCEEDED(hRes))
	{
		ConvertMetadataToAnsi(pmdrMDData);
	}
	
Exit:
	//release memory
	if( pwszMDPath!=0) delete [] pwszMDPath;
	return hRes;
}        
        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::CopyData( 
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ BOOL bMDCopyFlag) 
{
	HRESULT hRes=0;

	WCHAR * pwszMDSourcePath=ConvertToUnicode(pszMDSourcePath);
	WCHAR * pwszMDDestPath=ConvertToUnicode(pszMDDestPath);


	if ((pwszMDSourcePath==0) || (pwszMDDestPath==0) ) { hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	hRes= this->m_pcAdmCom->CopyData(hMDSourceHandle, pwszMDSourcePath, 
					hMDDestHandle, pwszMDDestPath, dwMDAttributes,
					dwMDUserType,dwMDDataType,bMDCopyFlag);
Exit:
	//release memory
	if( pwszMDSourcePath!=0) delete [] pwszMDSourcePath;
	if( pwszMDDestPath!=0) delete [] pwszMDDestPath;

	return hRes;
}
        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::OpenKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDAccessRequested,
            /* [in] */ DWORD dwMDTimeOut,
            /* [out] */ PMETADATA_HANDLE phMDNewHandle) 
{
	HRESULT hRes=0;
	WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

	if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	hRes= this->m_pcAdmCom->OpenKey(hMDHandle, pwszMDPath, dwMDAccessRequested, dwMDTimeOut, phMDNewHandle);
	
Exit:
	//release memory
	if( pwszMDPath!=0) delete [] pwszMDPath;
	return hRes;
}
        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::CloseKey( 
            /* [in] */ METADATA_HANDLE hMDHandle) 
{
	if(this->m_pcAdmCom==0) { return CO_E_NOTINITIALIZED;}
	return this->m_pcAdmCom->CloseKey(hMDHandle);
	
}        
        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::SaveData( void) 
{
	if(this->m_pcAdmCom==0) {return CO_E_NOTINITIALIZED;}
	return this->m_pcAdmCom->SaveData();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpmib\mib.h ===
/*++  BUILD Version: 001   // Increment this if a change has global effects

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      mib.h

   Abstract:

     Generic Macros and Functions for SNMP Extension Agent for
       gathering statistics information for Internet Services on NT.

   Author:

       Murali R. Krishnan    ( MuraliK )    22-Feb-1995

   Environment:

      User Mode -- Win32

   Project:

      SMTP Server SNMP MIB DLL

   Revision History:

--*/

# ifndef _MIB_H_
# define _MIB_H_

#include <windows.h>
#include <snmp.h>
#include <lm.h>
#include <inetinfo.h>

//
//  MIB function actions.
//

#define MIB_GET         ( ASN_RFC1157_GETREQUEST)
#define MIB_SET         ( ASN_RFC1157_SETREQUEST)
#define MIB_GETNEXT     ( ASN_RFC1157_GETNEXTREQUEST)
#define MIB_GETFIRST    ( ASN_PRIVATE | ASN_CONSTRUCTOR | 0x0 )


//
//  MIB Variable access privileges.
//

#define MIB_ACCESS_READ        0
#define MIB_ACCESS_WRITE       1
#define MIB_ACCESS_READWRITE   2
#define MIB_NOACCESS           3


typedef UINT ( * LPMIBFUNC)(
                            RFC1157VarBind    *  pRfcVarBind,
                            UINT                 Action,
                            struct _MIB_ENTRY *  pMibeCurrent,
                            struct _MIB_ENTRIES* pMibEntries,
                            LPVOID               pStatistics
                            );


typedef struct _MIB_ENTRY  {

    AsnObjectIdentifier   asnOid;       // OID for mib variable
    LONG                  lFieldOffset; // filed offset
    UINT                  uiAccess;     // type of accesss( R, W, R/W, None)
    LPMIBFUNC             pMibFunc;     // ptr to function managing this var.
    BYTE                  bType;        // Type( integer, counter, gauage).

} MIB_ENTRY, FAR * LPMIB_ENTRY;


typedef struct  _MIB_ENTRIES {

    AsnObjectIdentifier  *  pOidPrefix;  // Oid with prefix for MIB ENTRIES
    int                     cMibEntries; // count of MIB_ENTRIES in the array
    LPMIB_ENTRY             prgMibEntry; // ptr to array of MIB_ENTRIES

} MIB_ENTRIES, FAR * LPMIB_ENTRIES;

//
// GET_OID_LENGTH( oid)  gets the length of the oid.
//

# define  GET_OID_LENGTH( oid)           ((oid).idLength)

//
//  Macro to determine number of sub-oid's in an array of UINTs.
//

#define OID_SIZEOF( uiArray )      ( sizeof( uiArray) / sizeof(UINT) )

//
// OID_FROM_UINT_ARRAY():  Macro to define OID from an Array of UINTs
//
# define OID_FROM_UINT_ARRAY( uiArray)   { OID_SIZEOF( uiArray), uiArray }


//
// Macros for creating MIB Entries ( as specified in struct _MIB_ENTRY above)
//  MIB_ENTRY_HEADER:  creates a generic MIB_ENTRY for a MIB group header.
//  MIB_ENTRY_ITEM:    creates a generic MIB_ENTRY for a MIB variable.
//  MIB_COUNTER:       creates a counter type MIB_ENTRY
//  MIB_INTEGER:       creates an integer type MIB_ENTRY
//

# define MIB_ENTRY_HEADER( oid)             \
           {   oid,                         \
               -1,                          \
               MIB_NOACCESS,                \
               NULL,                        \
               ASN_RFC1155_OPAQUE,          \
           }

# define MIB_ENTRY_ITEM( oid, offset, access, type, func)  \
           {   oid,            \
               offset,         \
               access,         \
               ( func),        \
               ( type),        \
           }

# define MIB_COUNTER( oid, field, func)    \
     MIB_ENTRY_ITEM( oid, field, MIB_ACCESS_READ, ASN_RFC1155_COUNTER, func)

# define MIB_INTEGER( oid, field, func)    \
           MIB_ENTRY_ITEM( oid, field, MIB_ACCESS_READ, ASN_INTEGER, func)

UINT
ResolveVarBinding(
   IN OUT RFC1157VarBind * pRfcVarBinding,
   IN BYTE                 pduAction,
   IN LPVOID               pStatistics,
   IN LPMIB_ENTRIES        pMibEntries
  );


UINT
MibStatisticsWorker(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
   );



# endif // _MIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\snmp\dummy.c ===
/**
    This is just a dummy C file for the compiler to have
**/

void dummy_main(void)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpmib\main.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    main.c

Abstract:

    SNMP Extension Agent for SMTP Service on Windows NT.

Created:

  MuraliK   22-Feb-1995

Revision History:

--*/

#include "mib.h"
#include <excpt.h>
#include "smtptype.h"
#include "smtpapi.h"
#include <apiutil.h>
#include <dbgutil.h>

#define LowDword( x )   ( *((LPDWORD)&(x))  )
#define HighDword( x )  ( *((LPDWORD)&(x)+1) )

/************************************************************
 *   Variable Definitions
 ************************************************************/

//
// Definition of the MIB objects
//

//
//  The InternetServer section of the OID tree is organized as follows:
//
//      iso(1)
//          org(3)
//              dod(6)
//                  internet(1)
//                      private(4)
//                          enterprises(1)
//                              microsoft(311)
//                                  software(1)
//                                      InternetServer(7)
//                                          InetSrvCommon(1)
//                                              InetSrvStatistics(1)
//                                          FtpServer(2)
//                                              FtpStatistics(1)
//                                          HttpServer(3)
//                                              HttpStatistics(1)
//                                          GopherServer(4)
//                                              GopherStatistics(1)
//                                          MnsServer(5)
//                                              MsnStatistics(1)
//                                          NntpServer(6)
//                                              NntpStatistics(1)
//                                          SmtpServer(7)
//                                              SmtpStatistics(1)
//

static UINT   sg_rguiPrefix[] =  { 1, 3, 6, 1, 4, 1, 311, 1, 7, 7};
static AsnObjectIdentifier sg_MibOidPrefix =
                      OID_FROM_UINT_ARRAY( sg_rguiPrefix);

# define SMTP_PREFIX_OID_LENGTH    ( GET_OID_LENGTH( sg_MibOidPrefix))
# define SMTP_STATISTICS_OID_SUFFIX            ( 1)


//
// Following is the global description of all MIB Entries ( Mibe s) for
//   Smtp Service.
// Definition appears as:
//  Mibe( MIB Entry Name, Index in MIB Block, SmtpStatisticsField)
//
//   Incidentally, MIB Entry suffix coincides with the entry name in OID Tree
//
//  Any New MIB should be added here. and dont change use of after this defn.
//
// HighWord need to be treated special to account for int64 to 32 bit quantities
//

# define ALL_MIB_ENTRIES()    \
MibH( BytesSentTotal_HighWord,     1,    BytesSentTotal)          \
Mibe( BytesSentTotal_LowWord,      2,    BytesSentTotal)          \
MibH( BytesRcvdTotal_HighWord,     3,    BytesRcvdTotal)          \
Mibe( BytesRcvdTotal_LowWord,      4,    BytesRcvdTotal)          \
MibH( BytesSentMsg_HighWord,       5,    BytesSentMsg)            \
Mibe( BytesSentMsg_LowWord,        6,    BytesSentMsg)            \
MibH( BytesRcvdMsg_HighWord,       7,    BytesRcvdMsg)            \
Mibe( BytesRcvdMsg_LowWord,        8,    BytesRcvdMsg)            \
Mibe( NumMsgRecvd,                 9,    NumMsgRecvd)             \
Mibe( NumRcptsRecvd,               10,   NumRcptsRecvd)           \
Mibe( NumRcptsRecvdLocal,          11,   NumRcptsRecvdLocal)      \
Mibe( NumRcptsRecvdRemote,         12,   NumRcptsRecvdRemote)     \
Mibe( MsgsRefusedDueToSize,        13,   MsgsRefusedDueToSize)    \
Mibe( MsgsRefusedDueToNoCAddrObjects,        14,   MsgsRefusedDueToNoCAddrObjects)    \
Mibe( MsgsRefusedDueToNoMailObjects,        15,   MsgsRefusedDueToNoMailObjects)    \
Mibe( NumMsgsDelivered,            16,   NumMsgsDelivered)        \
Mibe( NumDeliveryRetries,          17,   NumDeliveryRetries)      \
Mibe( NumMsgsPickedUp,             18,   NumMsgsForwarded)        \
Mibe( NumNDRGenerated,             19,   NumNDRGenerated)         \
Mibe( LocalQueueLength,            20,   LocalQueueLength)         \
Mibe( LocalRetryQueueLength,       21,   RetryQueueLength)         \
Mibe( NumMailFileHandles,          22,   NumMailFileHandles)         \
Mibe( NumQueueFileHandles,         23,   NumQueueFileHandles)         \
Mibe( NumMsgsSent,                 24,   NumMsgsSent)             \
Mibe( NumRcptsSent,                25,   NumRcptsSent)            \
Mibe( NumSendRetries,              26,   NumSendRetries)          \
Mibe( RemoteQueueLength,           27,   RemoteQueueLength)        \
Mibe( NumDnsQueries,               28,   NumDnsQueries)           \
Mibe( RemoteRetryQueueLength,      29,   RemoteRetryQueueLength)  \
Mibe( NumConnInOpen,               30,   NumConnInOpen)           \
Mibe( NumConnInClose,              31,   NumConnInClose)          \
Mibe( NumConnOutOpen,              32,   NumConnOutOpen)          \
Mibe( NumConnOutClose,             33,   NumConnOutClose)         \
Mibe( NumConnOutRefused,           34,   NumConnOutRefused)       \
Mibe( NumProtocolErrs,             35,   NumProtocolErrs)         \
Mibe( DirectoryDrops,              36,   DirectoryDrops)          \
Mibe( RoutingTableLookups,         37,   RoutingTableLookups)     \
Mibe( ETRNMessages,                38,   ETRNMessages)

//
// Individual OID Definitions.
//   All Leaf variables should have a zero appended to their OID to indicate
//   that it is the only instance of this variable and that it exists.
//  Declare just the id's starting from next to the prefix given above.
//


//
// Few Convenience Macros for MIB entries addition.
//

# define MIB_VAR_NAME( NameSuffix)       MIB_ ## NameSuffix

# define DEFINE_MIBOID( NameSuffix, uiArray)   \
           UINT MIB_VAR_NAME( NameSuffix)[] = uiArray

# define DEFINE_MIBOID_LEAF( NameSuffix, NodeNumber) \
           UINT MIB_VAR_NAME( NameSuffix)[] = \
                          { SMTP_STATISTICS_OID_SUFFIX, ( NodeNumber), 0 }

//
// Define all the OIDs. First define the higher level node and then leaves.
//
DEFINE_MIBOID( Statistics,     { SMTP_STATISTICS_OID_SUFFIX} );

//
//  Define the Leaf OIDs.
//
# define Mibe( NameSuffix, Index, FieldName)  \
     DEFINE_MIBOID_LEAF( NameSuffix, Index);

#define MibH( NameSuffix, Index, FieldName)   \
     Mibe( NameSuffix, Index, FieldName)

//
// Expand the macro ALL_MIB_ENTRIES to obtain definitions of MIB Leafs.
//

ALL_MIB_ENTRIES()

# undef Mibe
# undef MibH


//
//  MIB Variable definition
//

//
// Define Mibe()  to be for variable definitions of counters.
//  Note that the comma is appearing before a new counter name. It is used
//   for structure initialization.
//

# define OFFSET_IN_SMTP_STATISTICS( Field)    \
     FIELD_OFFSET( SMTP_STATISTICS_0,   Field)

# define Mibe( NameSuffix, Index, Field)        \
     , MIB_COUNTER( OID_FROM_UINT_ARRAY( MIB_VAR_NAME( NameSuffix)),  \
                    OFFSET_IN_SMTP_STATISTICS(Field),                 \
                    MibStatisticsWorker)

# define MibH( NameSuffix, Index, Field)        \
     , MIB_COUNTER( OID_FROM_UINT_ARRAY( MIB_VAR_NAME( NameSuffix)),  \
                    OFFSET_IN_SMTP_STATISTICS(Field) + sizeof(DWORD), \
                    MibStatisticsWorker)

static MIB_ENTRY  sg_rgSmtpMib[] = {

    //
    // Statistics
    //

    MIB_ENTRY_HEADER( OID_FROM_UINT_ARRAY( MIB_VAR_NAME( Statistics)))
    ALL_MIB_ENTRIES()
};

# undef Mibe
# undef MibH

static MIB_ENTRIES  sg_SmtpMibs =
  {
    &sg_MibOidPrefix,
    ( sizeof( sg_rgSmtpMib) / sizeof( MIB_ENTRY)),
    sg_rgSmtpMib
  };


/************************************************************
 *    Functions
 ************************************************************/


BOOL  WINAPI
DllLibMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL)
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    Smtp MIB DLL. It initialises local variables and prepares the
    interface for the process to use SNMP Extension Agents for SMTP service.

 Messages            Actions

    ProcessAttach        Initializes winsock and data structures.
                          It fails if winsock has not already been started.

    ProcessDetach        Cleans up local data structures and disconnects from
                         winsock.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
  BOOL    fReturn = TRUE;

  switch (fdwReason ) {

    case DLL_PROCESS_ATTACH: {

        //
        // Initialize various modules
        //

        break;
    } /* case DLL_PROCESS_ATTACH */

    case DLL_PROCESS_DETACH: {

       //
       // Only cleanup when we are called because of a FreeLibrary().
       //  i.e., when lpvContext == NULL
       // If we are called because of a process termination, dont free anything
       //   the system will free resources and memory for us.
       //

       if ( lpvContext == NULL) {

           //
           // Code to be executed on successful termination
           //

       }

       break;
   } /* case DLL_PROCESS_DETACH */

   default:
       break;
  }    /* switch */

  return ( fReturn);
}  /* DllLibMain() */


/************************************************************
 *  Entry Points of SNMP Extension DLL For Smtp Service
 ************************************************************/

//
//  Extension Agent DLLs need access to elapsed time agent has been active.
//  This is implemented by initializing the Extension Agent with a time zero
//  reference, and allowing the agent to compute elapsed time by subtracting
//  the time zero reference from the current system time.  This example
//  Extension Agent implements this reference with dwTimeZero.
//

DWORD dwTimeZero = 0;


BOOL
SnmpExtensionInit(
    IN  DWORD                 dwTimeZeroReference,
    OUT HANDLE              * phPollForTrapEvent,
    OUT AsnObjectIdentifier * pAsnOidSupportedView
    )
/*++
  Description:
     The Extension Agent DLLs provide this entry point SnmpExtensionInit()
     to co-ordinate the initializations of the extension agent and the
     extendible  agent.
     The Extendible agent provides extension agent with a time zero reference.
     The Extension Agent provides Extendible agent with an Event Handle
         for communicating occurences of traps.
     The Extension Agent also provides Extendible agent with an ObjectId
         representing the root of the MIB structure
         that it (extension) supports.

  Arguments:
     dwTimeZeroReference    DWORD containing the Time Zero Reference for sync.
     phPollForTrapEvent     pointer to handle which on successful return
                             may contain an event handle to be polled for
                             traps.
     pAsnOidSupportedView   pointer to ASN ( Abstract Syntax Notation OID)
                             that contains the oid representing root of the
                             MIB structure.

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{


    //
    //  Record the time reference provided by the Extendible Agent.
    //

    dwTimeZero = dwTimeZeroReference;

    //
    //  Indicate the MIB view supported by this Extension Agent, an object
    //  identifier representing the sub root of the MIB that is supported.
    //

    *pAsnOidSupportedView = sg_MibOidPrefix; // NOTE!  structure copy

    //
    // Though the following is a handle, dont use INVALID_HANDLE_VALUE ( -1)
    //  because that constant is only for few people ( Win32). But all through
    //  NT invalid handle value is NULL ( 0).
    //

    *phPollForTrapEvent = NULL;

    //
    //  Indicate that Extension Agent initialization was sucessfull.
    //

    return ( TRUE);

}   // SnmpExtensionInit()

BOOL
SnmpExtensionTrap(
    OUT AsnObjectIdentifier * pAsnOidEnterprise,
    OUT AsnInteger          * pAsniGenericTrap,
    OUT AsnInteger          * pAsniSpecificTrap,
    OUT AsnTimeticks        * pAsnTimeStamp,
    OUT RFC1157VarBindList  * pRfcVariableBindings
    )
/*++
  Description:
     This function is used to communicate traps to the Extendible Agent.
     The Extendible Agent will invoke this entry point when the trap event
      ( supplied at the initialization time) is asserted, which indicates
      that zero or more traps had occured.
     The Extendible agent will repeatedly query this function till this
      function returns FALSE.

  Arguments:
    pAsnOidEnterprise      pointer to ASN OID for Enterprise, indicating
                             original enterprise generating trap.
    pAsniGenericTrap       pointer to ASN Integer which on return will
                             contain the indication of the generic trap.
    pAsniSpecificTrap      pointer to ASN Integer which on return will
                             contain the specific trap generated.
    pAsnTimeStamp          pointer to ASN containing the received Time-Stamp.
    pRfcVariableBindings   pointer to RFC 1157 compliant variable bindings.


  Returns:
    TRUE if success and there are more traps to be queried.
    FALSE if all traps are answered and work done.

--*/
{

    //
    //  We don't support traps (yet).
    //

    return ( FALSE);

}   // SnmpExtensionTrap()

BOOL
SnmpExtensionQuery(
    IN BYTE                     bRequestType,
    IN OUT RFC1157VarBindList * pRfcVariableBindings,
    OUT AsnInteger         *    pAsniErrorStatus,
    OUT AsnInteger         *    pAsniErrorIndex
    )
/*++
  Description:
    This function is called by Extendible Agent to resolve the SNMP requests
    for queries on MIB Variables in the Extension Agent's supported MIB view.
    ( which was supplied at initialization time).
    The Request Type is GET, GETNEXT, and SET.

  Arguments:
    bRequestType    byte containing the type of request.
                    It can be one of
                     ASN_RFC1157_GETREQUEST
                     ASN_RFC1157_GETNEXTREQUEST
                     ASN_RFC1157_SETREQUEST

    pRfcVariableBindings
                   pointer to RFC 1157 compliant variable bindings.

    pAsniErrorStatus
                   pointer to ASN Integer for Error Status

    pAsniErrorIndex
                  pointer to ASN INteger giving the index for error.

  Returns:
    TRUE on success and FALSE on failure.
--*/

{
    LPSMTP_STATISTICS_0             pSmtpStatistics = NULL;
    NET_API_STATUS                  Status;
    PSMTP_STATISTICS_BLOCK_ARRAY    aStatsBlockArray = NULL;

    //
    //  Try to query the statistics now so we'll have a consitent
    //  view across all variable bindings.
    //


    Status = SmtpQueryStatistics(
                            NULL,                    // pszServer
                            0,
                            (LPBYTE *) &aStatsBlockArray
                            );

    if (aStatsBlockArray != NULL)
    {
        //
        // **** RETURN STATISTICS FOR THE FIRST INSTANCE ONLY !! ****
        //

        pSmtpStatistics = &(aStatsBlockArray->aStatsBlock->Stats_0);
    }
    else {
        // if SmtpQueryStatistics fails, we should bail out here
        return ( SNMPAPI_ERROR);
    }


    //
    //  Status Errors not checked for  here!
    //  Reason:
    //    If the verb is GET_NEXT beyond the block we support,
    //           then there is no need to worry about the error at all.
    //    If the verb is GET within the block, it will get NULL value
    //           ( due the memset() done above).
    //

    __try {

        //
        //  Iterate through the variable bindings list to resolve individual
        //  variable bindings.
        //

        RFC1157VarBind * pVarBinding;

        for( pVarBinding = pRfcVariableBindings->list;
            pVarBinding < ( pRfcVariableBindings->list +
                            pRfcVariableBindings->len);
            pVarBinding++ ) {

            *pAsniErrorStatus = ResolveVarBinding( pVarBinding,
                                                  bRequestType,
                                                  pSmtpStatistics,
                                                  &sg_SmtpMibs);

            //
            //  Test and handle case where Get Next past end of MIB view
            //  supported by this Extension Agent occurs.  Special
            //  processing is required to communicate this situation to
            //  the Extendible Agent so it can take appropriate action,
            //  possibly querying other Extension Agents.
            //

            if(( *pAsniErrorStatus == SNMP_ERRORSTATUS_NOSUCHNAME ) &&
               ( bRequestType == MIB_GETNEXT ) ) {

                *pAsniErrorStatus = SNMP_ERRORSTATUS_NOERROR;

                //
                //  Modify variable binding of such variables so the OID
                //  points just outside the MIB view supported by this
                //  Extension Agent.  The Extendible Agent tests for this,
                //  and takes appropriate action.
                //

                SNMP_oidfree( &pVarBinding->name );
                SNMP_oidcpy( &pVarBinding->name, &sg_MibOidPrefix);
                pVarBinding->name.ids[ SMTP_PREFIX_OID_LENGTH - 1]++;
            }

            //
            //  If an error was indicated, communicate error status and error
            //  index to the Extendible Agent.  The Extendible Agent will
            //  ensure that the origional variable bindings are returned in
            //  the response packet.

            *pAsniErrorIndex =
              (( *pAsniErrorStatus != SNMP_ERRORSTATUS_NOERROR ) ?
               ((size_t)( pVarBinding - pRfcVariableBindings->list) + 1) : 0);

        } // for

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  For now do nothing.
        //

    }

    if ( aStatsBlockArray )
    {
        NetApiBufferFree( aStatsBlockArray );
    }

    return ( SNMPAPI_NOERROR);

}   // SnmpExtensionQuery()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpmd\tables.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       tables.h

   Abstract:

        mapping tables to convert various info between text and binary

   Environment:

      Win32 User Mode

   Author: 
     
	  jaroslad  (jan 1997)

--*/

#if !defined (__JD_TABLES_H)
#define __JD_TABLES_H 


#include <afx.h>
#ifdef UNICODE
	#include <iadmw.h>
#else
	#include "ansimeta.h"
#endif

//constanst to be returned by functions that map name to code
//
#define NAME_NOT_FOUND 0xFFFFFFFE

BOOL IsNumber(const CString& name);



BOOL IsServiceName(const CString& name);


//**********************************************************************
// PROPERTY NAME TABLE DEFINITION
//**********************************************************************
struct tPropertyNameTable;
 
tPropertyNameTable gPropertyNameTable[];

struct tPropertyNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwDefAttributes; //default attributes (metadata compatible)
	DWORD dwDefUserType;   //default user type (metadata compatible)
	DWORD dwDefDataType;   //default data type (metadata compatible)
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static tPropertyNameTable * FindRecord(DWORD dwCode, tPropertyNameTable * PropertyNameTable=::gPropertyNameTable);
	static tPropertyNameTable * FindRecord(const CString strName, tPropertyNameTable * PropertyNameTable=::gPropertyNameTable);
	
	static DWORD MapNameToCode(const CString& strName, tPropertyNameTable * PropertyNameTable=::gPropertyNameTable);
	static CString MapCodeToName(DWORD dwCode, tPropertyNameTable * PropertyNameTable=::gPropertyNameTable);
};

DWORD MapPropertyNameToCode(const CString & strName);



//**********************************************************************
// VALUE TABLE DEFINITION
//**********************************************************************

struct tValueTable ;
tValueTable gValueTable[];

struct tValueTable 
{
	enum {TYPE_EXCLUSIVE=1};
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwRelatedPropertyCode; // code of the Property this value can be used for
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static DWORD  MapNameToCode(const CString& strName, DWORD dwRelatedPropertyCode, tValueTable * ValueTable=::gValueTable);
	static CString MapValueContentToString(DWORD dwValueContent, DWORD dwRelatedPropertyCode, tValueTable * ValueTable=::gValueTable);

};

DWORD  MapValueNameToCode(const CString & strName, DWORD dwRelatedPropertyCode);



//**********************************************************************
// COMMAND NAME TABLE DEFINITION 
//**********************************************************************

struct tCommandNameTable ;
tCommandNameTable gCommandNameTable[];

struct tCommandNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static DWORD  MapNameToCode(const CString& strName, tCommandNameTable * CommandNameTable=::gCommandNameTable);
};

DWORD MapCommandNameToCode(const CString & strName);

enum
{	CMD_SET=1,
	CMD_GET,
	CMD_COPY,
	CMD_DELETE,
	CMD_ENUM,
	CMD_ENUM_ALL,
	CMD_CREATE,
	CMD_RENAME,
	CMD_SCRIPT,
	CMD_SAVE,
	CMD_APPCREATEINPROC,
	CMD_APPCREATEOUTPROC,
	CMD_APPDELETE,
        CMD_APPRENAME,
	CMD_APPUNLOAD,
	CMD_APPGETSTATUS,
};

//**********************************************************************
// PROPERTY ATTRIB NAME TABLE DEFINITION
//**********************************************************************
struct tAttribNameTable ;
tAttribNameTable gAttribNameTable[];


struct tAttribNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static DWORD MapNameToCode(const CString& strName, tAttribNameTable * AttribNameTable=::gAttribNameTable);
};

DWORD MapAttribNameToCode(const CString & strName);


//**********************************************************************
// PROPERTY DATA TYPE NAME TABLE DEFINITION 
//**********************************************************************

struct tDataTypeNameTable ;
tDataTypeNameTable gDataTypeNameTable[];

struct tDataTypeNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static DWORD  MapNameToCode(const CString& strName, tDataTypeNameTable * DataTypeNameTable=::gDataTypeNameTable);
	static CString MapCodeToName(DWORD a_dwCode, tDataTypeNameTable * DataTypeNameTable=::gDataTypeNameTable);

};

DWORD MapDataTypeNameToCode(const CString & strName);

//**********************************************************************
// PROPERTY USER TYPE NAME TABLE DEFINITION AND IMPLEMENTATION
//**********************************************************************

struct tUserTypeNameTable ;
tUserTypeNameTable gUserTypeNameTable[];


struct tUserTypeNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static DWORD  MapNameToCode(const CString& strName, tUserTypeNameTable * UserTypeNameTable=::gUserTypeNameTable);
};

DWORD MapUserTypeNameToCode(const CString & strName);



void PrintTablesInfo(void);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpmd\tables.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       tables.cpp

   Abstract:

        mapping tables to convert various info between text and binary

   Environment:

      Win32 User Mode

   Author:

      jaroslad  (jan 1997)

--*/


#include "tables.h"

#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#include <iiscnfgp.h>  //get MD_* constants
#include "smtpinet.h"
//#include "pop3s.h"
//#include "imaps.h"


BOOL IsNumber(const CString & name)
{
    for(INT i=0;i<name.GetLength();i++)
    {
        if (name[i]<_T('0') || name[i]>_T('9'))
            return FALSE;
    }
    return TRUE;
}



BOOL IsServiceName(const CString& name)
{
    BOOL fRetval=FALSE;

    if(name.CompareNoCase(_T("W3SVC"))==0 || name.CompareNoCase(_T("MSFTPSVC"))==0 ||
    name.CompareNoCase(_T("NNTPSVC"))==0 || name.CompareNoCase(_T("SMTPSVC"))==0)
    {
        fRetval=TRUE;
    }
    return fRetval;
}





//**********************************************************************
// COMMAND NAME TABLE IMPLEMENTATION
//**********************************************************************


//constants defined in tables.h
struct tCommandNameTable gCommandNameTable[]=
{
    {CMD_SET, _T("SET")},
    {CMD_GET, _T("GET")},
    {CMD_GET, _T("G")},
    {CMD_COPY, _T("COPY")},
    {CMD_DELETE, _T("DELETE")},
    {CMD_DELETE, _T("DEL")},
    {CMD_ENUM, _T("ENUM")},
    {CMD_ENUM, _T("E")},
    {CMD_ENUM_ALL,_T("ENUM_ALL")},
    {CMD_CREATE, _T("CREATE")},
    {CMD_RENAME, _T("RENAME")},
    {CMD_SCRIPT, _T("SCRIPT")},
    {CMD_SAVE, _T("SAVE")},
    {CMD_APPCREATEINPROC, _T("APPCREATEINPROC")},
    {CMD_APPCREATEOUTPROC, _T("APPCREATEOUTPROC")},
    {CMD_APPDELETE, _T("APPDELETE")},
    {CMD_APPUNLOAD, _T("APPUNLOAD")},
    {CMD_APPGETSTATUS, _T("APPGETSTATUS")},

    //the end
    {0,0}

};

DWORD MapCommandNameToCode(const CString & strName)
{
    return tCommandNameTable::MapNameToCode(strName);
}


DWORD tCommandNameTable::MapNameToCode(const CString & strName, tCommandNameTable * CommandNameTable)
{
    for(int i=0; CommandNameTable[i].lpszName!=0;i++)
    {
        if(strName.CompareNoCase(CommandNameTable[i].lpszName)==0)
            return CommandNameTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}

#if 0
CString tCommandNameTable::MapCodeToName(DWORD dwCode, tCommandNameTable * CommandNameTable)
{
    for(int i=0; CommandNameTable[i].lpszName!=0;i++)
    {
        if(dwCode==CommandNameTable[i].dwCode)
            return CommandNameTable[i].dwName;
    }
    return 0;
}
#endif



//**********************************************************************
// PROPERTY NAME TABLE IMPLEMENTATION
//**********************************************************************


tPropertyNameTable  gPropertyNameTable[]=
{
//  These are global to all services and should only be set at
//  the IIS root
    {MD_MAX_BANDWIDTH                ,_T("MaxBandwidth"),           METADATA_NO_ATTRIBUTES, /*SHOULD BE GLOBAL*/IIS_MD_UT_SERVER,       DWORD_METADATA},
    {MD_KEY_TYPE                     ,_T("KeyType"),        METADATA_NO_ATTRIBUTES, /*SHOULD BE GLOBAL*/IIS_MD_UT_SERVER,       STRING_METADATA},
//  These properties are applicable to both HTTP and FTP virtual
//  servers
    {MD_CONNECTION_TIMEOUT           ,_T("ConnectionTimeout"),      METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_MAX_CONNECTIONS              ,_T("MaxConnections"),         METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SERVER_COMMENT               ,_T("ServerComment"),          METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   STRING_METADATA},
    {MD_SERVER_STATE                 ,_T("ServerState"),            METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SERVER_COMMAND               ,_T("ServerCommand"),          METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SERVER_AUTOSTART             ,_T("ServerAutostart"),        METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_CLUSTER_SERVER_COMMAND       ,_T("ClusterServerCommand"),   METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_CLUSTER_ENABLED              ,_T("ClusterEnabled"),         METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SERVER_SIZE                  ,_T("ServerSize"),             METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SERVER_LISTEN_BACKLOG        ,_T("ServerListenBacklog"),    METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SERVER_LISTEN_TIMEOUT        ,_T("ServerListenTimeout"),    METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_DOWNLEVEL_ADMIN_INSTANCE     ,_T("DownlevelAdminInstance"), METADATA_INHERIT      , IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SERVER_BINDINGS              ,_T("ServerBindings"),         METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   MULTISZ_METADATA},
    { MD_SERVER_CONFIGURATION_INFO    ,   _T("ServerConfigurationInfo"),METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},

    //internals
    {MD_SERVER_PLATFORM              ,_T("ServerPlatform"),         METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SERVER_VERSION_MAJOR         ,_T("MajorVersion"),           METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SERVER_VERSION_MINOR         ,_T("MinorVersion"),           METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SERVER_CAPABILITIES          ,_T("Capabilities"),           METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},

//  These properties are specific to HTTP and belong to the virtual
//  server
//    {MD_SECURE_PORT                  ,_T("SecurePort"),             METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SECURE_BINDINGS              ,_T("SecureBindings"),         METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   MULTISZ_METADATA},
    {MD_NTAUTHENTICATION_PROVIDERS   ,_T("NTAuthenticationProviders"),  METADATA_INHERIT,       IIS_MD_UT_SERVER,/*??*/STRING_METADATA},
    {MD_SCRIPT_TIMEOUT               ,_T("ScriptTimeout"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_CACHE_EXTENSIONS             ,_T("CacheExtensions"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,/*??*/DWORD_METADATA},
    {MD_CREATE_PROCESS_AS_USER       ,_T("CreateProcessAsUser"),        METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_CREATE_PROC_NEW_CONSOLE      ,_T("CreateProcNewConsole"),   METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_POOL_IDC_TIMEOUT             ,_T("PoolIDCTimeout"),         METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_ALLOW_KEEPALIVES             ,_T("AllowKeepAlives"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_FILTER_LOAD_ORDER            ,_T("FilterLoadOrder"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,/*??*/STRING_METADATA},
    {MD_FILTER_IMAGE_PATH            ,_T("FilterImagePath"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_FILTER_STATE                 ,_T("FilterState"),                METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_FILTER_ENABLED                   ,_T("FilterEnabled"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_FILTER_FLAGS                     ,_T("FilterFlags"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_FILTER_DESCRIPTION               ,_T("FilterDescription"),        METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},

    { MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS, _T("AllowPathInfoForScriptMappings"), METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA },
    { MD_AUTH_CHANGE_URL                 ,_T("AuthChangeUrl"),  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_AUTH_EXPIRED_URL, _T("AuthExpiredUrl"),     METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_AUTH_NOTIFY_PWD_EXP_URL, _T("NotifyPwdExpUrl"), METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_AUTH_EXPIRED_UNSECUREURL, _T("AuthExpiredUnsecureUrl"),     METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_AUTH_NOTIFY_PWD_EXP_UNSECUREURL, _T("NotifyPwdExpUnsecureUrl"), METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_ADV_NOTIFY_PWD_EXP_IN_DAYS, _T("NotifyPwdExpInDays"),   METADATA_INHERIT,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_AUTH_CHANGE_FLAGS, _T("AuthChangeFlags"),   METADATA_INHERIT,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_ADV_CACHE_TTL, _T("AdvCacheTTL"),   METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_NET_LOGON_WKS, _T("NetLogonWks"),METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_USE_HOST_NAME, _T("UseHostName"),METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
#if defined(CAL_ENABLED)
    {MD_CAL_VC_PER_CONNECT, "CalVcPerConnect",METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_CAL_AUTH_RESERVE_TIMEOUT, "CalAuthReserveTimeout",METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_CAL_SSL_RESERVE_TIMEOUT, "CalSslReserveTimeout",METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_CAL_W3_ERROR, "CalW3Error",METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
#endif
    { MD_IN_PROCESS_ISAPI_APPS        , _T("InProcessIsapiApps") ,METADATA_INHERIT, IIS_MD_UT_SERVER, MULTISZ_METADATA},
    { MD_CUSTOM_ERROR_DESC            , _T("CustomErrorDesc")    ,METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, MULTISZ_METADATA},

    {MD_MAPCERT                      ,_T("MapCert"),                    METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {MD_MAPNTACCT                    ,_T("MaPNTAccT"),                  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {MD_MAPNAME                      ,_T("MapName"),                    METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {MD_MAPENABLED                   ,_T("MapEnabled"),                 METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {MD_MAPREALM                     ,_T("MapRealm"),                   METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {MD_MAPPWD                       ,_T("MapPwd"),                     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {MD_ITACCT                       ,_T("ITACCT"),                     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {MD_CPP_CERT11                   ,_T("CppCert11"),                  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {MD_SERIAL_CERT11                ,_T("SerialCert11"),               METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {MD_CPP_CERTW                    ,_T("CppCertw"),                   METADATA_SECURE,IIS_MD_UT_SERVER, BINARY_METADATA},
    {MD_SERIAL_CERTW                 ,_T("SerialCertw"),                METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {MD_CPP_DIGEST                   ,_T("CppDigest"),                  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {MD_SERIAL_DIGEST                ,_T("SerialDigest"),               METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {MD_CPP_ITA                      ,_T("CppIta"),                 METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {MD_SERIAL_ITA                   ,_T("SerialIta"),                  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
// Virtual root properties - note MD_ACCESS_PERM is also generally set at
// the virtual directory.  These are used for both HTTP and FTP
    {MD_VR_PATH                   ,_T("VrPath"),                    METADATA_INHERIT,IIS_MD_UT_FILE,STRING_METADATA},
    {MD_VR_USERNAME               ,_T("VrUsername"),                METADATA_INHERIT,IIS_MD_UT_FILE,STRING_METADATA},
    {MD_VR_PASSWORD               ,_T("VrPassword") ,           METADATA_INHERIT|METADATA_SECURE,IIS_MD_UT_FILE,     STRING_METADATA},
    {MD_VR_ACL                    ,_T("VrAcl"),                 METADATA_INHERIT,IIS_MD_UT_FILE,BINARY_METADATA},
// This is used to flag down updated vr entries - Used for migrating vroots
    {MD_VR_UPDATE                    ,_T("VrUpdate"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_FILE,DWORD_METADATA},
//  Logging related attributes
    {MD_LOG_TYPE                      ,_T("LogType"),                   METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGFILE_DIRECTORY            ,_T("LogFileDirectory"),           METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGFILE_PERIOD               ,_T("LogFilePeriod"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGFILE_TRUNCATE_SIZE        ,_T("LogFileTruncateSize"),        METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGSQL_DATA_SOURCES          ,_T("LogSqlDataSources"),          METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGSQL_TABLE_NAME            ,_T("LogSqlTableName"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGSQL_USER_NAME             ,_T("LogSqlUserName"),             METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGSQL_PASSWORD              ,_T("LogSqlPassword"),             METADATA_SECURE,IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_LOGEXT_FIELD_MASK               ,_T("ExtLogFieldMask"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGEXT_FIELD_MASK2              ,_T("ExtLogFieldMask2"),           METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOG_PLUGIN_ORDER                ,_T("LogPluginOrder"),             METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
//  These are FTP specific properties
    {MD_EXIT_MESSAGE                 ,_T("ExitMessage"),                METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_GREETING_MESSAGE             ,_T("GreetingMessage"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,/*!!*/MULTISZ_METADATA},
    {MD_MAX_CLIENTS_MESSAGE          ,_T("MaxClientsMessage"),      METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_MSDOS_DIR_OUTPUT             ,_T("MSDOSDirOutput"),         METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_ALLOW_ANONYMOUS              ,_T("AllowAnonymous"),         METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_ANONYMOUS_ONLY               ,_T("AnonymousOnly"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOG_ANONYMOUS                ,_T("LogAnonymous"),               METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOG_NONANONYMOUS             ,_T("LogNonAnonymous"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
//  These are SSL specific properties
    {MD_SSL_PUBLIC_KEY               ,_T("SslPublicKey"),               METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,BINARY_METADATA},
    {MD_SSL_PRIVATE_KEY              ,_T("SslPrivateKey"),          METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,BINARY_METADATA},
    {MD_SSL_KEY_PASSWORD             ,_T("SslKeyPassword"),         METADATA_SECURE,IIS_MD_UT_SERVER,BINARY_METADATA},
//  File and Directory related properties - these should be added in the
//  metabase with a user type of IIS_MD_UT_FILE
    {MD_AUTHORIZATION                ,_T("Authorization"),              METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_AUTHORIZATION_PERSISTENCE    ,_T("AuthorizationPersistence"),   METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_REALM                        ,_T("Realm"),                      METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {MD_HTTP_EXPIRES                 ,_T("HttpExpires"),                METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {MD_HTTP_PICS                    ,_T("HtpPics"),                    METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {MD_HTTP_CUSTOM                  ,_T("HttpCustom"),             METADATA_INHERIT,   IIS_MD_UT_FILE,MULTISZ_METADATA},
    {MD_DIRECTORY_BROWSING           ,_T("DirectoryBrowsing"),          METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_DEFAULT_LOAD_FILE            ,_T("DefaultLoadFile"),            METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {MD_CONTENT_NEGOTIATION          ,    _T("ContentNegotiation"),     METADATA_INHERIT    ,IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_CUSTOM_ERROR                 ,_T("CustomError"),                METADATA_INHERIT,   IIS_MD_UT_FILE,MULTISZ_METADATA},
    {MD_FOOTER_DOCUMENT              ,_T("FooterDocument"),         METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {MD_FOOTER_ENABLED               ,_T("FooterEnabled"),              METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_HTTP_REDIRECT                    ,_T("HttpRedirect"),               METADATA_NO_ATTRIBUTES,IIS_MD_UT_FILE,STRING_METADATA},
    {MD_DEFAULT_LOGON_DOMAIN         ,_T("DefaultLogonDomain"), METADATA_INHERIT,      IIS_MD_UT_FILE,STRING_METADATA},
    {MD_LOGON_METHOD                 ,_T("LogonMethod"),            METADATA_INHERIT,      IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_SCRIPT_MAPS                     ,_T("ScriptMaps"),              METADATA_INHERIT,IIS_MD_UT_FILE,MULTISZ_METADATA},
    {MD_SCRIPT_TIMEOUT                     ,_T("ScriptTimeout"),        METADATA_INHERIT,IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_MIME_MAP                     ,_T("MimeMap"),                    METADATA_INHERIT,IIS_MD_UT_FILE,MULTISZ_METADATA},
    {MD_ACCESS_PERM                  ,_T("AccessPerm"),             METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_SSL_ACCESS_PERM          ,_T("SslAccessPerm"),             METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_IP_SEC                       ,_T("IpSec")   ,                   METADATA_INHERIT,IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_ANONYMOUS_USER_NAME          ,_T("AnonymousUserName"),      METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {MD_ANONYMOUS_PWD                ,_T("AnonymousPwd"),               METADATA_INHERIT|METADATA_SECURE,IIS_MD_UT_FILE,STRING_METADATA},
    {MD_ANONYMOUS_USE_SUBAUTH        ,_T("AnonymousUseSubAuth"),        METADATA_INHERIT,IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_DONT_LOG                     ,_T("DontLOG"),                    METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_ADMIN_ACL                    ,_T("AdminAcl"),                   METADATA_INHERIT,   IIS_MD_UT_FILE,BINARY_METADATA},
    {MD_SSI_EXEC_DISABLED                ,_T("SSIExecDisabled"),            METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_DO_REVERSE_DNS                   ,_T("DoReverseDns"),               METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_WIN32_ERROR                  ,_T("Win32Error"),            0,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_ALLOW_REPLACE_ON_RENAME          ,_T("AllowReplaceOnRename"),       METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA},
    {MD_CC_NO_CACHE                  ,_T("CacheControlNoCache"),             METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_CC_MAX_AGE                  ,_T("CacheControlMaxAge"),             METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_CC_OTHER                  ,_T("CacheControlOther"),             METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
// ASP and WAM params
    {MD_ASP_BUFFERINGON                  ,_T("CacheControlOther"),  METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    { MD_ASP_BUFFERINGON                  , _T("AspBufferingOn"),       METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_LOGERRORREQUESTS             , _T("AspLogErrorRequests"),  METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
    { MD_ASP_SCRIPTERRORSSENTTOBROWSER    , _T("AspScriptErrorSentToBrowser"),METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_SCRIPTERRORMESSAGE           , _T("AspScriptErrorMessage"),METADATA_INHERIT, ASP_MD_UT_APP, STRING_METADATA},
    { MD_ASP_SCRIPTFILECACHESIZE          , _T("AspScriptFileCacheSize"),METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
    { MD_ASP_SCRIPTENGINECACHEMAX         , _T("AspScriptEngineCacheMax"),METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
    { MD_ASP_SCRIPTTIMEOUT                , _T("AspScriptTimeout"),     METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_SESSIONTIMEOUT               , _T("AspSessionTimeout"),    METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_ENABLEPARENTPATHS            , _T("AspEnableParentPaths"), METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_MEMFREEFACTOR                , _T("AspMemFreeFactor"),     METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
    { MD_ASP_MINUSEDBLOCKS                , _T("AspMinUseDblocks"),     METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
    { MD_ASP_ALLOWSESSIONSTATE            , _T("AspAllowSessionState"), METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_SCRIPTLANGUAGE               , _T("AspScriptLanguage")     ,METADATA_INHERIT, ASP_MD_UT_APP, STRING_METADATA},
    { MD_ASP_ALLOWOUTOFPROCCMPNTS         , _T("AspAllowOutOfProcCmpnts"),METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_EXCEPTIONCATCHENABLE         , _T("AspExceptionCatchEnable"),METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_CODEPAGE                     , _T("AspCodepage")           ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_SCRIPTLANGUAGELIST           , _T("AspScriptLanguages")    ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_ENABLESERVERDEBUG            , _T("AspEnableServerDebug")  ,METADATA_INHERIT,ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_ENABLECLIENTDEBUG            , _T("AspEnableClientDebug")  ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_TRACKTHREADINGMODEL          , _T("AspTrackThreadingModel") ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
// WAM params
    { MD_APP_ROOT                     , _T("AppRoot"),      METADATA_INHERIT, IIS_MD_UT_WAM, STRING_METADATA},
    { MD_APP_ISOLATED                 , _T("AppIsolated"),  METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
    { MD_APP_WAM_CLSID                , _T("AppWamClsid"),  METADATA_INHERIT, IIS_MD_UT_WAM, STRING_METADATA},
    { MD_APP_PACKAGE_ID               , _T("AppPackageId"), METADATA_INHERIT, IIS_MD_UT_WAM, STRING_METADATA},
    { MD_APP_PACKAGE_NAME             , _T("ApPackageName"),METADATA_INHERIT, IIS_MD_UT_WAM, STRING_METADATA},
    { MD_APP_LAST_OUTPROC_PID         , _T("AppLastOutprocId"), METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
// SMTP parameters
    {MD_COMMAND_LOG_MASK,   _T("CmdLogMask"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_FLUSH_MAIL_FILE,    _T("FlushMailFiles"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_BATCH_MSG_LIMIT,    _T("BatchMsgLimit"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_MAIL_OBJECTS,   _T("MaxMailObjects"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_ROUTING_THREADS,    _T("RoutingThreads"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAIL_QUEUE_DIR, _T("MailQueueDir"),     METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SHOULD_PICKUP_MAIL, _T("ShouldPickUpMail"),     METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_DIR_BUFFERS,    _T("MaxDirectoryBuffers"),  METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_DIR_CHANGE_IO_SIZE,_T("DirectoryBuffSize"), METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_DIR_PENDING_IOS,_T("NumDirPendingIos"),     METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAIL_PICKUP_DIR,    _T("MailPickupDir"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SHOULD_DELIVER, _T("ShouldDeliver"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAIL_DROP_DIR,  _T("MailDropDir"),      METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_ROUTING_DLL,    _T("RoutingDll"),       METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_REVERSE_NAME_LOOKUP,_T("EnableReverseLookup"),  METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_NAME_RESOLUTION_TYPE,_T("NameResolution"),      METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_HOP_COUNT,      _T("MaxHopCount"),      METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_SMTP_ERRORS,    _T("MaxErrors"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_MSG_SIZE,   _T("MaxMsgSize"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_MSG_SIZE_B4_CLOSE,_T("MaxMsgSizeBeforeClose"),  METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_OUTBOUND_TIMEOUT,   _T("MaxOutTimeout"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_OUTBOUND_CONNECTION,_T("MaxOutConnections"),    METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_RECIPIENTS, _T("MaxRcpts"),         METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_LOCAL_RETRY_ATTEMPTS,_T("MaxRetryAttempts"),    METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_LOCAL_RETRY_MINUTES ,_T("MaxRetryMinutes"),     METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_REMOTE_RETRY_ATTEMPTS,_T("MaxRemoteRetryAttempts"), METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_REMOTE_RETRY_MINUTES,_T("MaxRemoteRetryMinutes"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_SHARE_RETRY_MINUTES,_T("MaxShareRetryMinutes"), METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SHOULD_PIPELINE_OUT,_T("PipelineInput"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SHOULD_PIPELINE_IN, _T("PipelineOutput"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMARTHOST_TYPE, _T("SmartHostUseType"),     METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMARTHOST_NAME, _T("SmartHost"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_CONNECT_RESPONSE,   _T("ConnectResponse"),      METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_DEFAULT_DOMAIN_VALUE,_T("DefaultDomain"),       METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_BAD_MAIL_DIR,   _T("BadMailDir"),       METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_ROUTING_SOURCES,    _T("OldRoutingSources"),       METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA},
    {MD_SMTP_DS_HOST,       _T("Host"),     METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_DS_NAMING_CONTEXT,     _T("NamingContext"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_DS_ACCOUNT,        _T("Account"),      METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_DS_PASSWORD,       _T("Password"),     METADATA_SECURE, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_DS_DATA_DIRECTORY,     _T("DataDirectory"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_DS_DEFAULT_MAIL_ROOT,      _T("DefaultMailRoot"),      METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_DS_BIND_TYPE,      _T("BindType"),     METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_DS_SCHEMA_TYPE,        _T("SchemaType"),       METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_DS_TYPE,        _T("DSType"),       METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
//    {MD_REMOTE_HANG_TIME,   _T("RemoteHangTime"),       METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA},
    {MD_MASQUERADE_NAME,    _T("MasqueradeName"),       METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_DO_MASQUERADE,  _T("ShouldMasquerade"),     METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_REMOTE_SMTP_PORT,   _T("RemoteSMTPPort"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_SSLPORT,        _T("SSLPort"),          METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_POSTMASTER_EMAIL,   _T("AdminEmail"),       METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_POSTMASTER_NAME,    _T("AdminName"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_ETRN_DAYS,      _T("ETRNDays"),         METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_LOCAL_DOMAINS,  _T("LocalDomains"),     METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA},
    {MD_DOMAIN_ROUTING, _T("DomainRouting"),        METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA},
    {MD_REMOTE_TIMEOUT, _T("RemoteTimeout"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SEND_NDR_TO,    _T("SendNDRTo"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SEND_BAD_TO,    _T("SendBADTo"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_ALWAYS_USE_SSL, _T("AlwaysUseSSL"),     METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_REMOTE_SECURE_PORT, _T("RemoteSecurePort"),     METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_OUT_CONN_PER_DOMAIN,_T("MaxOutConPerDomain"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_LIMIT_REMOTE_CONNECTIONS,_T("LimitRemoteConnections"),METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_REMOTE_SECURE_PORT, _T("RemoteSecurePort"),     METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_SORT_TEMP_DIR,  _T("MailSortTmpDir"),       METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_SERVICE_VERSION,_T("ServiceVersion"),      METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_SMTP_EXTENSION_DLLS,_T("ExtensionDlls"),        METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA},
//    {MD_SMTP_NUM_RESOLVER_SOCKETS,_T("NumResolverSockets"), METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_SMTP_USE_MX_RESOLVER,_T("UseMxResolver"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_FQDN_VALUE,     _T("FQDNValue"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_UPDATED_FQDN,   _T("UpdatedFQDN"),      METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_UPDATED_DEFAULT_DOMAIN,_T("UpdatedDefDomain"),  METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_ETRN_SUBDOMAINS,    _T("ETRNSubdomains"),       METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA},
//    {MD_MAX_POOL_THREADS,   _T("MaxPoolThreads"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SASL_LOGON_DOMAIN,  _T("SASLLogonDom"),     METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
//    {MD_SERVER_SS_AUTH_MAPPING, _T("SSAuthMapping"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_CLEARTEXT_AUTH_PROVIDER,   _T("CTAProvider"),      METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
//    {MD_ALWAYS_USE_SASL,    _T("AlwaysUseSASL"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_SMTP_AUTHORIZATION, _T("SMTPAuth"),     METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_SMTP_AUTHLOGON_ERRORS,  _T("AuthLogonErrors"),      METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_ROUTE_ACTION,   _T("RouteAction"),      METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_ROUTE_ACTION_TYPE,  _T("RouteActionType"),      METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_ROUTE_USER_NAME,    _T("RouteUserName"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_ROUTE_PASSWORD, _T("RoutePassword"),        METADATA_SECURE, IIS_MD_UT_FILE, STRING_METADATA},
//    {MD_SMTP_PREFERRED_AUTH,    _T("PreferredAuth"),        METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA},
    {MD_SMTP_MAX_REMOTEQ_THREADS,    _T("MaxRemQThreads"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_MAX_LOCALQ_THREADS,    _T("MaxLocQThreads"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_AUTHORIZED_TURN_LIST,    _T("AuthTURNList"),        METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA},
    {MD_SMTP_CSIDE_ETRN_DELAY,    _T("CSideEtrnDelay"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_CSIDE_ETRN_DOMAIN,    _T("CSideEtrnDomain"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
//    {MD_SMTP_VALIDATE_HELO_ARG,    _T("ValidateHelo"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_IP_RELAY_ADDRESSES                   ,_T("IpRelayAddresses"),                  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},  
    {MD_SMTP_RELAY_FOR_AUTH_USERS, _T("RelayForAuth"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_SYSTEM_ROUTING_THREADS, _T("SysRoutingThreads"),    METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_SHOW_BINARY_MIME, _T("AdvertiseBMIME"), METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_SHOW_CHUNKING, _T("AdvertiseCHUNK"),    METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_CONNECT_TIMEOUT, _T("CONNECTTimeOut"), METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_MAILFROM_TIMEOUT, _T("MAILFROMTimeOut"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_RCPTTO_TIMEOUT, _T("RCPTTOTimeOut"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_DATA_TIMEOUT, _T("DATATimeOut"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_BDAT_TIMEOUT, _T("BDATTimeOut"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_AUTH_TIMEOUT, _T("AUTHTimeOut"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_SASL_TIMEOUT, _T("SASLTimeOut"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_HELO_TIMEOUT, _T("HELOTimeOut"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_TURN_TIMEOUT, _T("TURNTimeOut"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_RSET_TIMEOUT, _T("RSETTimeOut"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_SMTP_QUIT_TIMEOUT, _T("QUITTimeOut"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_HELO_NODOMAIN, _T("HeloNoDomain"), METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_MAIL_NO_HELO, _T("MailNoHelo"),    METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_AQUEUE_DLL,  _T("AQDll"),   METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
//    {MD_MAPIDRV_DLL,  _T("MAPIDRVDll"), METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
//    {MD_CAT_DLL,  _T("CATDll"), METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_DOMAIN_VALIDATION_FLAGS,  _T("DomainValidationFlags"),  METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_DS_DOMAIN,  _T("DSDomain"),    METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_DS_USE_CAT, _T("DSUseCAT"),    METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_DS_FLAGS, _T("DSFlags"), METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_DS_PORT, _T("DSPort"), METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_REMOTE_RETRY_THRESHOLD, _T("RetryThreshold"),  METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_REMOTE_PROGRESSIVE_RETRY_MINUTES, _T("RemoteRetryMinString"),  METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    
    {MD_SMTP_EXPIRE_LOCAL_DELAY_MIN, _T("LocalDelayDSNMinutes"),    METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_EXPIRE_LOCAL_NDR_MIN, _T("LocalNDRMinutes"),   METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_EXPIRE_REMOTE_DELAY_MIN, _T("RemoteDelayDSNMinutes"),  METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_EXPIRE_REMOTE_NDR_MIN, _T("RemoteNDRMinutes"),     METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_USE_TCP_DNS,_T("UseTcpDns"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_DSN_OPTIONS,_T("DSNOptions"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_DSN_LANGUAGE_ID,_T("DSNLangID"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_SSL_REQUIRE_TRUSTED_CA, _T("VerifySSLCertIssuer"), METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA},
    {MD_SMTP_SSL_CERT_HOSTNAME_VALIDATION, _T("VerifySSLCertSubject"), METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA},
    {MD_SMTP_DISABLE_PICKUP_DOT_STUFF, _T("DisablePickupDotStuff"), METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA},
    {0,0}
};


DWORD MapPropertyNameToCode(const CString & strName)
{
    return tPropertyNameTable::MapNameToCode(strName);
}

// function finds the record within given property name table,
// with the name equal to parameter lpszName
tPropertyNameTable * tPropertyNameTable::FindRecord(const CString strName, tPropertyNameTable * PropertyNameTable)
{
    for(int i=0; PropertyNameTable[i].lpszName!=0;i++)
    {
        if( strName.CompareNoCase(PropertyNameTable[i].lpszName)==0)
            return PropertyNameTable+i;
    }
    return 0;
}

tPropertyNameTable * tPropertyNameTable::FindRecord(DWORD dwCode, tPropertyNameTable * PropertyNameTable)
{
    if(dwCode==0)
            return NULL;
    for(int i=0; PropertyNameTable[i].lpszName!=0;i++)
    {
        if( dwCode==PropertyNameTable[i].dwCode)
            return PropertyNameTable+i;
    }
    return 0;
}

DWORD tPropertyNameTable::MapNameToCode(const CString & strName, tPropertyNameTable * PropertyNameTable)
{
    for(int i=0; PropertyNameTable[i].lpszName!=0;i++)
    {
        if(strName.CompareNoCase(PropertyNameTable[i].lpszName)==0)
            return PropertyNameTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}

CString tPropertyNameTable::MapCodeToName(DWORD dwCode, tPropertyNameTable * PropertyNameTable)
{
    for(int i=0; PropertyNameTable[i].lpszName!=0;i++)
    {
        if(dwCode == PropertyNameTable[i].dwCode)
            return PropertyNameTable[i].lpszName;
    }
    return _T("");
}


//**********************************************************************
// PROPERTY ATTRIB NAME TABLE  IMPLEMENTATION
//**********************************************************************


//constants defined in imd.h
struct tAttribNameTable gAttribNameTable[]=
{
    {METADATA_NO_ATTRIBUTES, _T("NO_ATTRIBUTES")},
    {METADATA_INHERIT, _T("INHERIT")},
    {METADATA_PARTIAL_PATH, _T("PARTIAL_PATH")},
    {METADATA_SECURE,_T("SECURE")},
    {METADATA_INSERT_PATH,_T("INSERT_PATH")},
//  {METADATA_REFERENCE,_T("REFERENCE")},
//  {METADATA_MASTER_ROOT_HANDLE, _T("MASTER_ROOT_HANDLE")},
//the end
    {0,0}
};

DWORD MapAttribNameToCode(const CString & strName)
{
    return tAttribNameTable::MapNameToCode(strName);
}


DWORD tAttribNameTable::MapNameToCode(const CString& strName, tAttribNameTable * AttribNameTable)
{
    for(int i=0; AttribNameTable[i].lpszName!=0;i++)
    {
        if(strName.CompareNoCase(AttribNameTable[i].lpszName)==0)
            return AttribNameTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}


//**********************************************************************
// PROPERTY DATA TYPE NAME TABLE MPLEMENTATION
//**********************************************************************

//constants defined in imd.h
tDataTypeNameTable  gDataTypeNameTable[]=
{
    {DWORD_METADATA,    _T("DWORD")},
    {STRING_METADATA,   _T("STRING")},
    {BINARY_METADATA,   _T("BINARY")},
    {EXPANDSZ_METADATA, _T("EXPANDSZ")},
    {MULTISZ_METADATA,  _T("MULTISZ")},
//the end
    {0,0}
};

DWORD MapDataTypeNameToCode(const CString & strName)
{
    return tDataTypeNameTable::MapNameToCode(strName);
}


DWORD tDataTypeNameTable::MapNameToCode(const CString& strName, tDataTypeNameTable * DataTypeNameTable)
{
    for(int i=0; DataTypeNameTable[i].lpszName!=0;i++)
    {
        if(strName.CompareNoCase(DataTypeNameTable[i].lpszName)==0)
            return DataTypeNameTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}

CString tDataTypeNameTable::MapCodeToName(DWORD a_dwCode, tDataTypeNameTable * DataTypeNameTable)
{
    for(int i=0; DataTypeNameTable[i].lpszName!=0;i++)
    {
        if(a_dwCode==DataTypeNameTable[i].dwCode)
            return DataTypeNameTable[i].lpszName;
    }
    return _T("");
}


//**********************************************************************
// PROPERTY USER TYPE NAME TABLE  IMPLEMENTATION
//**********************************************************************

//constants defined in iiscnfg.h
struct tUserTypeNameTable gUserTypeNameTable[]=
{
    {IIS_MD_UT_SERVER, _T("UT_SERVER")},
    {IIS_MD_UT_FILE, _T("UT_FILE")},
    {IIS_MD_UT_WAM,  _T("UT_WAM")},
    {ASP_MD_UT_APP,  _T("UT_APP")},
//the end
    {0,0}

};

DWORD MapUserTypeNameToCode(const CString & strName)
{
    return tUserTypeNameTable::MapNameToCode(strName);
}


DWORD tUserTypeNameTable::MapNameToCode(const CString& strName, tUserTypeNameTable * UserTypeNameTable)
{
    for(int i=0; UserTypeNameTable[i].lpszName!=0;i++)
    {
        if(strName.CompareNoCase(UserTypeNameTable[i].lpszName)==0)
            return UserTypeNameTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}



//**********************************************************************
// PROPERTY PREDEFINED VALUES TABLE IMPLEMENTATION
//**********************************************************************

//constants defined in iiscnfg.h

//Predefined values table
struct tValueTable gValueTable[]=
{
//  Valid values for MD_AUTHORIZATION
    {MD_AUTH_ANONYMOUS               ,_T("Anonymous"),  MD_AUTHORIZATION},
    {MD_AUTH_BASIC                   ,_T("Basic"),      MD_AUTHORIZATION},
    {MD_AUTH_NT                      ,_T("NT"),     MD_AUTHORIZATION},
    {MD_AUTH_MD5                     ,_T("MD5"),        MD_AUTHORIZATION},
    {MD_AUTH_MAPBASIC                ,_T("MapBasic"),   MD_AUTHORIZATION},
//  Valid values for MD_ACCESS_PERM
    {MD_ACCESS_READ                  ,_T("Read"),   MD_ACCESS_PERM},
    {MD_ACCESS_WRITE                 ,_T("Write"),  MD_ACCESS_PERM},
    {MD_ACCESS_EXECUTE               ,_T("Execute"),    MD_ACCESS_PERM},
    {MD_ACCESS_SSL                   ,_T("SSL"),        MD_ACCESS_PERM},// Require SSL
    {MD_ACCESS_NEGO_CERT             ,_T("NegoCert"),   MD_ACCESS_PERM},// Allow client SSL certs
    {MD_ACCESS_REQUIRE_CERT          ,_T("RequireCert"),MD_ACCESS_PERM},// Require client SSL certs
    {MD_ACCESS_MAP_CERT              ,_T("MapCert"),MD_ACCESS_PERM},// Map SSL cert to NT account
    {MD_ACCESS_SSL128                ,_T("SSL128"), MD_ACCESS_PERM},// Require 128 bit SSL
    {MD_ACCESS_SCRIPT                ,_T("Script"), MD_ACCESS_PERM},// Script
    {MD_ACCESS_NO_REMOTE_READ        ,_T("NoRemoteRead"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_WRITE       ,_T("NoRemoteWrite"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_EXECUTE     ,_T("NoRemoteExecute"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_SCRIPT      ,_T("NoRemoteScript"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_MASK                  ,_T("MaskAll"),    MD_ACCESS_PERM},
//  Valid values for MD_SSL_ACCESS_PERM
    {MD_ACCESS_READ                  ,_T("Read"),   MD_SSL_ACCESS_PERM},
    {MD_ACCESS_WRITE                 ,_T("Write"),  MD_SSL_ACCESS_PERM},
    {MD_ACCESS_EXECUTE               ,_T("Execute"),    MD_SSL_ACCESS_PERM},
    {MD_ACCESS_SSL                   ,_T("SSL"),        MD_SSL_ACCESS_PERM},// Require SSL
    {MD_ACCESS_NEGO_CERT             ,_T("NegoCert"),   MD_SSL_ACCESS_PERM},// Allow client SSL certs
    {MD_ACCESS_REQUIRE_CERT          ,_T("RequireCert"),MD_SSL_ACCESS_PERM},// Require client SSL certs
    {MD_ACCESS_MAP_CERT              ,_T("MapCert"),MD_SSL_ACCESS_PERM},// Map SSL cert to NT account
    {MD_ACCESS_SSL128                ,_T("SSL128"), MD_SSL_ACCESS_PERM},// Require 128 bit SSL
    {MD_ACCESS_SCRIPT                ,_T("Script"), MD_SSL_ACCESS_PERM},// Script
    {MD_ACCESS_NO_REMOTE_READ        ,_T("NoRemoteRead"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_WRITE       ,_T("NoRemoteWrite"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_EXECUTE     ,_T("NoRemoteExecute"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_SCRIPT      ,_T("NoRemoteScript"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_MASK                  ,_T("MaskAll"),    MD_SSL_ACCESS_PERM},
//  Valid values for MD_DIRECTORY_BROWSING
    {MD_DIRBROW_SHOW_DATE            ,_T("Date"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_SHOW_TIME            ,_T("Time"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_SHOW_SIZE            ,_T("Size"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_SHOW_EXTENSION       ,_T("Extension"), MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_LONG_DATE            ,_T("LongDate"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_ENABLED              ,_T("Enabled"),   MD_DIRECTORY_BROWSING},// Allow directory browsing
    {MD_DIRBROW_LOADDEFAULT          ,_T("LoadDefault"),MD_DIRECTORY_BROWSING},// Load default doc if exists
    {MD_DIRBROW_MASK                 ,_T("MaskAll"),        MD_DIRECTORY_BROWSING},
//  Valid values for MD_LOGON_METHOD
    {MD_LOGON_INTERACTIVE    ,_T("Interactive"),    MD_LOGON_METHOD, tValueTable::TYPE_EXCLUSIVE},
    {MD_LOGON_BATCH          ,_T("Batch"),      MD_LOGON_METHOD, tValueTable::TYPE_EXCLUSIVE},
    {MD_LOGON_NETWORK        ,_T("Network"),        MD_LOGON_METHOD, tValueTable::TYPE_EXCLUSIVE},
//  Valid values for MD_FILTER_STATE
    {MD_FILTER_STATE_LOADED          ,_T("Loaded"), MD_FILTER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_FILTER_STATE_UNLOADED        ,_T("Unloaded"),   MD_FILTER_STATE,    tValueTable::TYPE_EXCLUSIVE },
//  Valid values for MD_FILTER_FLAGS
    {/*SF_NOTIFY_SECURE_PORT*/0x00000001         ,_T("SecurePort"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_NONSECURE_PORT*/0x00000002      ,_T("NonSecurePort"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_READ_RAW_DATA*/0x000008000      ,_T("ReadRawData"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_PREPROC_HEADERS*/0x00004000     ,_T("PreprocHeaders"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_AUTHENTICATION*/0x00002000      ,_T("Authentication"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_URL_MAP*/0x00001000         ,_T("UrlMap"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_ACCESS_DENIED*/0x00000800       ,_T("AccessDenied"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_SEND_RESPONSE*/0x00000040       ,_T("SendResponse"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_SEND_RAW_DATA*/0x00000400       ,_T("SendRawData"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_LOG*/0x00000200         ,_T("NotifyLog"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_END_OF_REQUEST*/0x00000080  ,_T("EndOfRequest"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_END_OF_NET_SESSION*/0x00000100  ,_T("EndOfNetSession"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_AUTHENTICATIONEX*/  0x20000000  ,_T("AuthenticationX"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_REQUEST_SECURITY_CONTEXT_CLOSE*/0x10000000,_T("RequestSecurityContextClose"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_RENEGOTIATE_CERT*/0x08000000,   _T("RenegotiateCert"), MD_FILTER_FLAGS},

    {/*SF_NOTIFY_ORDER_HIGH*/0x00080000   ,_T("OrderHigh"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_ORDER_MEDIUM*/0x00040000   ,_T("OrderMedium"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_ORDER_LOW*/0x00020000   ,_T("OrderLow"), MD_FILTER_FLAGS},

//  Valid values for MD_SERVER_STATE
    {MD_SERVER_STATE_STARTING        ,_T("Starting"),   MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_STARTED         ,_T("Started"),    MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_STOPPING        ,_T("Stopping"),   MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_STOPPED         ,_T("Stopped"),    MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_PAUSING         ,_T("Pausing"),    MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_PAUSED          ,_T("Paused"),     MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_CONTINUING      ,_T("Continuing"), MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
//  Valid values for MD_SERVER_COMMAND
    {MD_SERVER_COMMAND_START         ,_T("Start"),      MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_COMMAND_STOP          ,_T("Stop"),       MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_COMMAND_PAUSE         ,_T("Pause"),      MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_COMMAND_CONTINUE      ,_T("Continue"),   MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
//  Valid values for MD_SERVER_SIZE
    {MD_SERVER_SIZE_SMALL            ,_T("Small"),  MD_SERVER_SIZE, tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_SIZE_MEDIUM           ,_T("Medium"), MD_SERVER_SIZE, tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_SIZE_LARGE            ,_T("Large"),  MD_SERVER_SIZE, tValueTable::TYPE_EXCLUSIVE},

    //{APPCMD_NONE, _T("None"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_VERIFY, _T("Verify"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_GETSTATUS, _T("GetStatus"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CREATE, _T("Create"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CREATEINPROC, _T("CreateInProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CREATEOUTPROC, _T("CreateOutProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CHANGETOINPROC, _T("ChangeToInProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CHANGETOOUTPROC, _T("ChangeToOutProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_DELETE, _T("Delete"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_UNLOAD, _T("Unload"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},

    //{APPSTATUS_Error, _T("Error"),        MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Created, _T("Created"),    MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Deleted, _T("Deleted"),    MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_UnLoaded, _T("Unloaded"),  MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Killed, _T("Killed"),  MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Running, _T("Running"),    MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Stopped, _T("Stopped"),    MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_NoApplication, _T("NoApplication"),    MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_AppSubNode, _T("AppSubNode"),  MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},


// NEED LOGGING Updates
#if 0
    {MD_LOGTYPE_NONE     ,_T("LOGTYPE_NONE")},
    {MD_LOGTYPE_FILE     ,_T("LOGTYPE_FILE")},
    {MD_LOGTYPE_ODBC     ,_T("LOGTYPE_ODBC")},
    {MD_LOGFILE_PERIOD_MAXSIZE   ,_T("LOGFILE_PERIOD_MAXSIZE")},
    {MD_LOGFILE_PERIOD_DAILY     ,_T("LOGFILE_PERIOD_DAILY")},
    {MD_LOGFILE_PERIOD_WEEKLY    ,_T("LOGFILE_PERIOD_WEEKLY")},
    {MD_LOGFILE_PERIOD_MONTHLY   ,_T("LOGFILE_PERIOD_MONTHLY")},
#endif
//the end
    {0,0}
};

DWORD  MapValueNameToCode(const CString & strName,DWORD dwRelatedPropertyCode)
{
    return tValueTable::MapNameToCode(strName, dwRelatedPropertyCode);
}


DWORD  tValueTable::MapNameToCode(const CString& strName, DWORD dwRelatedPropertyCode, tValueTable * ValueTable)
{
    for(int i=0; ValueTable[i].lpszName!=0;i++)
    {
        if((strName.CompareNoCase(ValueTable[i].lpszName)==0) && ValueTable[i].dwRelatedPropertyCode==dwRelatedPropertyCode)
            return ValueTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}

CString  tValueTable::MapValueContentToString(DWORD dwValueContent, DWORD dwRelatedPropertyCode, tValueTable * ValueTable)
{
    CString strResult=_T("");
    for(int i=0; ValueTable[i].lpszName!=0;i++)
    {
        if(ValueTable[i].dwRelatedPropertyCode==dwRelatedPropertyCode)
        {
            if(ValueTable[i].dwFlags==tValueTable::TYPE_EXCLUSIVE)
            {
                if (ValueTable[i].dwCode == dwValueContent)
                    return ValueTable[i].lpszName;
            }
            else if ((ValueTable[i].dwCode & dwValueContent) == ValueTable[i].dwCode)
            {
                strResult = strResult + ValueTable[i].lpszName + _T(" ");
            }

        }
    }
    strResult.TrimRight();
    return strResult;
}


//prints info about what is stored in tables so that user can see the predefined names and values

void PrintTablesInfo(void)
{
    //Print supported property names
    _tprintf(_T("***The following list of property names (IIS parameters) is supported:\n"));
    _tprintf(_T("------------------------------------------------------------------------------\n"));
    _tprintf(_T("%-25s: \t%-10s %s\n"),_T("Property Name"), _T("Data type"), _T("Attributes and User Type"));
    _tprintf(_T("\t\t--Predefined Values\n"));
    _tprintf(_T("------------------------------------------------------------------------------\n"));
    for(int i=0; gPropertyNameTable[i].lpszName!=NULL; i++)
    {
       _tprintf(_T("%-25s: \t%-10s "),gPropertyNameTable[i].lpszName,
            LPCTSTR(_T("(")+tDataTypeNameTable::MapCodeToName(gPropertyNameTable[i].dwDefDataType)+_T(")")));
        if( (METADATA_INHERIT & gPropertyNameTable[i].dwDefAttributes) == METADATA_INHERIT)
        {   _tprintf(_T("INHERIT\t"));
        }
        if( (IIS_MD_UT_SERVER & gPropertyNameTable[i].dwDefUserType) == IIS_MD_UT_SERVER)
        {   _tprintf(_T("UT_SERVER\t"));
        }

        if( (IIS_MD_UT_FILE & gPropertyNameTable[i].dwDefUserType) == IIS_MD_UT_FILE)
        {   _tprintf(_T("UT_FILE "));
        }

        _tprintf(_T("\n"));

        //print list of applicable values

        for(int j=0; gValueTable[j].lpszName!=NULL;j++)
        {
            if( gValueTable[j].dwRelatedPropertyCode==gPropertyNameTable[i].dwCode)
            {
                _tprintf(_T("\t\t %-15s (=0x%x)\n"),gValueTable[j].lpszName,gValueTable[j].dwCode);

            }
        }
    }
    _tprintf(_T("\n***The following list of user types (for IIS parameters) is supported:\n"));
    for(i=0; gUserTypeNameTable[i].lpszName!=NULL; i++)
    {
        _tprintf(_T("%s "),gUserTypeNameTable[i].lpszName);
    }

    _tprintf(_T("\n\n***The following list of data types (for IIS parameters) is supported:\n"));
    for(i=0; gDataTypeNameTable[i].lpszName!=NULL; i++)
    {
        _tprintf(_T("%s  "),gDataTypeNameTable[i].lpszName);
    }
    _tprintf(_T("\n\n***The following list of attributes (for IIS parameters) is supported:\n"));
    for( i=0; gAttribNameTable[i].lpszName!=NULL; i++)
    {
        _tprintf(_T("%s  "),gAttribNameTable[i].lpszName);
    }
    _tprintf(_T("\n"));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpmd\main.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       main.cpp

   Abstract:

       command line admin tool main function

   Environment:

      Win32 User Mode

   Author: 
     
      jaroslad  (jan 1997)

--*/

#include <tchar.h>

#include <afx.h>

#include <string.h>
#include <stdlib.h>
#include <stdio.h>   


#include "admutil.h"
#include "tables.h"
#include "jd_misc.h"    



CAdmUtil oAdmin;  //admin object

#define MAX_NUMBER_OF_SMALL_VALUES  100
#define MAX_NUMBER_OF_VALUES  10100
#define MAX_NUMBER_OF_DEFAULT_ARGS  10110


//structure stores the command line arguments

struct tAdmutilParams
{
    WORD fHelp; //print help - flag
    WORD fFullHelp; //print help - flag
    WORD fNoSave; //do not save metabase
    LPCTSTR lpszCommand;
    LPCTSTR lpszComputer;
    WORD  wInstance;
    LPCTSTR lpszService;
    LPCTSTR lpszPath;
    LPCTSTR lpszComputerDst; //for COPY destination
    WORD  wInstanceDst;     //for COPY destination
    LPCTSTR lpszServiceDst; //for COPY destination
    LPCTSTR lpszPathDst;        //for COPY destination

    LPCTSTR lplpszDefaultArg[MAX_NUMBER_OF_DEFAULT_ARGS];
    WORD wDefaultArgCount;

    LPCTSTR lpszPropName;

    LPCTSTR lplpszPropAttrib[MAX_NUMBER_OF_SMALL_VALUES];
    WORD  wPropAttribCount;
    LPCTSTR lplpszPropDataType[MAX_NUMBER_OF_SMALL_VALUES];
    WORD wPropDataTypeCount;
    LPCTSTR lplpszPropUserType[MAX_NUMBER_OF_SMALL_VALUES];
    WORD wPropUserTypeCount;
    LPCTSTR lplpszPropValue[MAX_NUMBER_OF_VALUES]; //pointer to array of values (e.g multisz type allows the multiple values for one property
    DWORD lpdwPropValueLength[MAX_NUMBER_OF_VALUES];
    WORD  wPropValueCount;
    WORD  wPropFileValueCount;
};

tAdmutilParams Params;
_TCHAR **g_argv;
int g_argc;

static BOOL CompareOutput(_TCHAR *FileToCompare,_TCHAR* FileTemplate);

// definition of command line syntax with some help text -this is the input for ParseParam()

TParamDef CmdLineArgDesc[]=
{
 {_TEXT(""),MAX_NUMBER_OF_DEFAULT_ARGS, (void *) Params.lplpszDefaultArg,TYPE_LPCTSTR,OPT, _TEXT("Command [param ...]"),_TEXT("CMD [param param]"),&Params.wDefaultArgCount},
 {_TEXT("svc") ,1, (void *) &Params.lpszService,TYPE_LPCTSTR,OPT,_TEXT("service (MSFTPSVC, W3SVC)")},
 {_TEXT("s"), 1, (void *) &Params.lpszComputer,TYPE_LPCTSTR,OPT, _TEXT("name of computer to administer"),_TEXT("comp"),},          
 {_TEXT("i") ,1, &Params.wInstance, TYPE_WORD, OPT,_TEXT("instance number"),_TEXT("inst")},
 {_TEXT("path"),1, (void *) &Params.lpszPath,   TYPE_LPCTSTR,OPT, _TEXT("path "),_TEXT("path")},
 {_TEXT("pathdst"),1, (void *) &Params.lpszPathDst, TYPE_LPCTSTR,OPT, _TEXT("destination path (use for COPY only)"),_TEXT("path")},
 {_TEXT("prop"),1, (void *) &Params.lpszPropName, TYPE_LPCTSTR,OPT, _T("property (IIS parameter) name")},
 {_TEXT("attrib"),MAX_NUMBER_OF_SMALL_VALUES, (void *) Params.lplpszPropAttrib,TYPE_LPCTSTR,OPT, _T("property attributes"),_T(""),&Params.wPropAttribCount},
 {_TEXT("utype"),MAX_NUMBER_OF_SMALL_VALUES, (void *) Params.lplpszPropUserType,TYPE_LPCTSTR,OPT, _T("property user type"),_T(""),&Params.wPropUserTypeCount},
 {_TEXT("dtype"),MAX_NUMBER_OF_SMALL_VALUES, (void *) Params.lplpszPropDataType,TYPE_LPCTSTR,OPT, _T("property data type"),_T(""),&Params.wPropDataTypeCount},
 {_TEXT("value"),MAX_NUMBER_OF_VALUES, (void *) Params.lplpszPropValue,TYPE_LPCTSTR,OPT, _T("property values"),_T(""),&Params.wPropValueCount},
 {_TEXT("fvalue"),MAX_NUMBER_OF_VALUES, (void *) Params.lplpszPropValue,TYPE_LPCTSTR,OPT, _T("property values as files"),_T(""),&Params.wPropFileValueCount},
 {_TEXT("nosave"),0, &Params.fNoSave,TYPE_WORD,OPT, _T("do not save metabase"),_T("")},
 {_TEXT("timeout"),1, &g_dwTIMEOUT_VALUE,TYPE_DWORD,OPT, _T("timeout for metabase access in ms (default is 30000 sec"),_T("")},
 {_TEXT("delayafteropen"),1, &g_dwDELAY_AFTER_OPEN_VALUE,TYPE_DWORD,OPT, _T("delay after opening node (default is 0 sec)"),_T("")},
 {_TEXT("help"),0, &Params.fFullHelp,TYPE_WORD,OPT, _T("print full help"),_T("")},
 {_TEXT("?"),0, &Params.fHelp,TYPE_WORD,OPT, _T("print help"),_T("")},  
  {NULL,0, NULL ,         TYPE_TCHAR, OPT, 
   _T("IIS K2 administration utility that enables the manipulation with metabase parameters\n")
   _T("\n")
   _T("Notes:\n")
   _T(" Simpified usage of mdutil doesn't require any switches.\n")
   _T(" \n")
   _T(" mdutil GET      path             - display chosen parameter\n")
   _T(" mdutil SET      path value ...   - assign the new value\n")
   _T(" mdutil ENUM     path             - enumerate all parameters for given path\n")
   _T(" mdutil ENUM_ALL path             - recursively enumerate all parameters\n")
   _T(" mdutil DELETE   path             - delete given path or parameter\n")
   _T(" mdutil CREATE   path             - create given path\n")
   _T(" mdutil COPY     pathsrc pathdst  - copy all from pathsrc to pathdst (will create pathdst)\n")
   _T(" mdutil RENAME   pathsrc pathdst  - rename chosen path\n")
   _T(" mdutil SCRIPT   scriptname       - runs the script\n")
   _T(" mdutil APPCREATEINPROC  w3svc/1/root - Create an in-proc application \n")
   _T(" mdutil APPCREATEOUTPROC w3svc/1/root - Create an out-proc application\n")
   _T(" mdutil APPDELETE        w3svc/1/root - Delete the application if there is one\n")
   _T(" mdutil APPRENAME        w3svc/1/root/dira w3svc/1/root/dirb - Rename the application \n")
   _T(" mdutil APPUNLOAD        w3svc/1/root - Unload an application from w3svc runtime lookup table.\n")
   _T(" mdutil APPGETSTATUS     w3svc/1/root - Get status of the application\n")
   _T("\n")
   _T("  -path has format: {computer}/{service}/{instance}/{URL}/{Parameter}\n")
   _T("\n")
   _T("Samples:\n")
   _T("  mdutil GET W3SVC/1/ServerBindings     \n")
   _T("  mdutil SET JAROSLAD2/W3SVC/1/ServerBindings \":81:\"\n")
   _T("  mdutil COPY W3SVC/1/ROOT/iisadmin W3SVC/2/ROOT/adm\n")
   _T("  mdutil ENUM_ALL W3SVC\n")
   _T("  mdutil ENUM W3SVC/1\n")
   _T("\n")
   _T("Additional features\n")
   _T("  set MDUTIL_BLOCK_ON_ERROR environment variable to block mdutil.exe after error (except ERROR_PATH_NOT_FOUND)\n")
   _T("  set MDUTIL_ASCENT_LOG environment variable to force mdutil.exe to append errors to ascent log\n")
   _T("  set MDUTIL_PRINT_ID environment variable to force mdutil.exe to print metadata numeric identifiers along with friendly names\n")
 }
};


BOOL
ReadFromFiles( 
    LPTSTR*  lplpszPropValue,
    DWORD*  lpdwPropValueLength,
    DWORD   dwPropFileValueCount 
    )
{
    DWORD dwL;

    while ( dwPropFileValueCount-- )
    {
        FILE* fIn = _tfopen( lplpszPropValue[dwPropFileValueCount], _T("rb") );
        if ( fIn == NULL )
        {
            return FALSE;
        }
        if ( fseek( fIn, 0, SEEK_END ) == 0 )
        {
            dwL = ftell( fIn );
            fseek( fIn, 0, SEEK_SET );
        }
        else
        {
            fclose( fIn );
            return FALSE;
        }
        if ( (lplpszPropValue[dwPropFileValueCount] = (LPTSTR)malloc( dwL )) == NULL )
        {
            fclose( fIn );
            return FALSE;
        }
        if ( fread( lplpszPropValue[dwPropFileValueCount], 1, dwL, fIn ) != dwL )
        {
            fclose( fIn );
            return FALSE;
        }
        fclose( fIn );
        lpdwPropValueLength[dwPropFileValueCount] = dwL;
    }

    return TRUE;
}

///////////////////////////////

class CScript
{
    FILE * m_fpScript;
    void GetNextToken(/*OUT*/ LPTSTR * lplpszToken);
    DWORD CleanWhiteSpaces(void);
public:
    CScript(void) {m_fpScript=0;};
    DWORD Open(LPCTSTR lpszFile);
    DWORD Close(void);
    DWORD GetNextLineTokens(int *argc, /*OUT*/ _TCHAR *** argv);
};



DWORD CScript::CleanWhiteSpaces()
{

    if(m_fpScript!=NULL)
    {
        int LastChar=0;
        _TINT c=0;
        while(1)
        {   
            LastChar=c;
            c=_fgettc(m_fpScript);
            if(c==_T('\t') || c==_T(' ') || c==_T('\r'))
            {   continue;
            }
            if(c==_T('\\'))
            {
                int cc=_fgettc(m_fpScript);
                if (cc==_T('\r')) //continue with the next line of the file
                {
                    if(_fgettc(m_fpScript)!=_T('\n'))
                    {
                        fseek( m_fpScript, -1, SEEK_CUR );
                    }
                    continue;
                }
                else if (cc==_T('\n')) //continue with the next line of the file
                {   
                    continue;
                }   
                else
                {
                    fseek( m_fpScript, -2, SEEK_CUR );
                    break;
                }
            }
            if(c==WEOF)
            {   break;
            }
            else
            {   fseek( m_fpScript, -1, SEEK_CUR ); //return back one position
                break;
            }
        }
    }
    return 0;
}

void CScript::GetNextToken(LPTSTR * lplpszToken)
{
    enum {TERMINATE_QUOTE, TERMINATE_WHITESPACE};
    long flag=TERMINATE_WHITESPACE;

    //clean white spaces
    CleanWhiteSpaces();
    //store the beginning offset of token
    long Offset = ftell(m_fpScript);
    _TINT c=_fgettc(m_fpScript);
    long CurrentOffset=0;
    
    if(c==WEOF)
    {
        *lplpszToken=NULL;
        return ;
    }
    if (c==_T('\n')){
        *lplpszToken=_T("\n");
        return ;
    }
    else
    {
        if (c==_T('\"')) { //token ends with " or the end of the line
            flag=TERMINATE_QUOTE;
            Offset = ftell(m_fpScript);
        }
        else {
            flag=TERMINATE_WHITESPACE;
        }
        
        // find the end of the token
        while(1) {
            CurrentOffset=ftell(m_fpScript);
            c=_fgettc(m_fpScript);
            
            if(c==_T('\n')){
                break;
            }

            if(c==WEOF)
            {
                break;
            }

            
            if( (flag==TERMINATE_QUOTE && c==_T('\"')) || (
                    flag==TERMINATE_WHITESPACE && (c==_T(' ') || c==_T('\t') || c==_T('\r')) ) ){
                break;
            }
        }
        

        //get the token size
        long TokenSize = CurrentOffset - Offset;
        
        if(TokenSize!=0)
        {
            // allocate mamory for the token
            *lplpszToken = new _TCHAR[ TokenSize+1 ];
            //read the token
            fseek( m_fpScript, Offset, SEEK_SET);
            for(int i=0;i<TokenSize;i++)
                (*lplpszToken)[i]=(TCHAR)_fgettc(m_fpScript);
            //terminate the token
            (*lplpszToken)[i]=0; 
        }
        else
        { //empty string
            *lplpszToken=new _TCHAR[1 ];
            (*lplpszToken)[0]=0;
        }
        //discard double quote if it was at the end of the token
        c=_fgettc(m_fpScript);
        if(c!=_T('\"'))
            fseek( m_fpScript, ((c==WEOF)?0:-1), SEEK_CUR );
    }
}
    


DWORD CScript::Open(LPCTSTR lpszFile)
{
    m_fpScript = _tfopen(  lpszFile, _T("rt") );
    if(m_fpScript==NULL)
        return GetLastError();
    else
        return ERROR_SUCCESS;
}

DWORD CScript::Close()
{
    if( m_fpScript!=NULL)
        fclose( m_fpScript);
    return GetLastError();
}


DWORD CScript::GetNextLineTokens(int *argc, /*OUT*/ _TCHAR *** argv)
{
    for(int i=1;i<*argc;i++) {
        delete  (*argv)[i];
        (*argv)[i]=0;
    }
    *argc=0;
    if(*argv==NULL)
        (*argv)=new LPTSTR [ MAX_NUMBER_OF_VALUES ];

    (*argv)[(*argc)++]=_T("mdutil"); //set zero parameter
    
    LPTSTR lpszNextToken=NULL;
    while((*argc)<MAX_NUMBER_OF_VALUES) {
        GetNextToken(&lpszNextToken);
        if(lpszNextToken==NULL )  //end of file
            break;
    
        if(_tcscmp(lpszNextToken,_T("\n"))==0)  //new line
            break;
        (*argv)[(*argc)++]=lpszNextToken;
        
    }
    return GetLastError();
}


int  MainFunc(int argc, _TCHAR **argv); //declaration



//MAIN FUNCTION
int __cdecl main(int argc, CHAR **_argv)
{


    //  convert parameters from SBCS to UNICODE;
    _TCHAR **argv= new LPTSTR [argc];
    for (int i=0;i<argc;i++)
    {
        argv[i]=new _TCHAR[strlen(_argv[i])+1];
        #ifdef UNICODE
            MultiByteToWideChar(0, 0, _argv[i], -1, argv[i],strlen(_argv[i])+1 );
        #else
            strcpy(argv[i],_argv[i]);
        #endif  
    }
    

    DWORD dwCommandCode=0;

    DWORD retval=0;
    HRESULT hRes;
    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (FAILED(hRes)) {
        fatal_error_printf(_T("CoInitializeEx\n"));
    }

    //extract command line parameters
    ParseParam(argc,argv,CmdLineArgDesc); 
    //**************************
    //PRINT HELP ON REQUEST
    if(Params.fFullHelp)
    {
        //print help
        DisplayUsage(argv,CmdLineArgDesc);
        PrintTablesInfo();
    }
    else if(Params.wDefaultArgCount==0 || Params.fHelp)
    {
        //print help
        DisplayUsage(argv,CmdLineArgDesc);
    }
    else
    {
            if (Params.wDefaultArgCount>0)
    { 
        //first default has to be command
        Params.lpszCommand=Params.lplpszDefaultArg[0];
        dwCommandCode = tCommandNameTable::MapNameToCode(Params.lplpszDefaultArg[0]);
        if( Params.wDefaultArgCount>1)
        {   //second default 
                Params.lpszPath=Params.lplpszDefaultArg[1];
        }
            if(dwCommandCode==CMD_SCRIPT)  //process script
            { 
                tAdmutilParams StoredParams=Params;

                CScript Script;
                DWORD dwRes;
                if((dwRes=Script.Open(Params.lpszPath))!=ERROR_SUCCESS)
                    fatal_error_printf(_T("cannot open script file %s (error %d)\n"),Params.lpszPath,dwRes);

                int l_argc=0;
                _TCHAR ** l_argv=NULL;
                while(1)
                {
                    Script.GetNextLineTokens(&l_argc,&l_argv);
                    if(l_argc==1) //end of script file
                        break;
                    Params=StoredParams; 
                    _tprintf(_T(">"));
                    for(int i=1;i<l_argc;i++)
                        _tprintf(_T("%s "),l_argv[i]);
                    _tprintf(_T("\n"));
                    DWORD retval1=MainFunc(l_argc,l_argv);
                    retval = ((retval==0) ? retval1:retval);
                }
                if (oAdmin.GetpcAdmCom()!=NULL)
                {
                    if(Params.fNoSave)
                    {}
                    else
                        oAdmin.SaveData();
                }

            }
            else
            {
                retval=MainFunc(argc,argv); //run only one command typed on the command line
                if (oAdmin.GetpcAdmCom()!=NULL)
                {
                    if(Params.fNoSave)
                    {}
                    else
                        oAdmin.SaveData();
                }
            }
        }   
    
        
    }

    //close admin object
    oAdmin.Close(); 
    //close wam adm object
    oAdmin.CloseWamAdm();

    CoUninitialize();
    //Cleanup of parameters
    if(argv!=0)
    {
        for (int i=0;i<argc;i++)
        {
            delete [] argv[i];
        }
        delete argv;
    }

    return retval;

}

int  MainFunc(int argc, _TCHAR **argv)
{   
    g_argc=argc;
    g_argv=argv;
    DWORD retval;
    
    LPCTSTR lpszCommand=0;

    CAdmNode AdmNode;
    CAdmProp AdmProp;
    CAdmNode AdmDstNode;

    int i;
    
    DWORD dwCommandCode=0;

    //extract command line parameters
    ParseParam(argc,argv,CmdLineArgDesc); 
    

    //PROCESS THE DEFAULT PARAMETERS
    // trick: place the default arguments into variables that apply for non default one (see Params structure)
    
    if (Params.wDefaultArgCount>0)
    { //first default has to be command
        Params.lpszCommand=Params.lplpszDefaultArg[0];
        dwCommandCode = tCommandNameTable::MapNameToCode(Params.lplpszDefaultArg[0]);
        if( Params.wDefaultArgCount>1)
        {//second deault has to be path
                Params.lpszPath=Params.lplpszDefaultArg[1];
        }
        if( Params.wDefaultArgCount>2)
        {
            switch(dwCommandCode)
            { 

            case CMD_SET:
                //the rest of default args are values
                Params.wPropValueCount=0;
                for(i=2;i<Params.wDefaultArgCount;i++)
                {
                    Params.lplpszPropValue[i-2] = Params.lplpszDefaultArg[i];
                    Params.wPropValueCount++;
                }
                break;
             case CMD_DELETE:
             case CMD_CREATE:
             case CMD_GET:
             case CMD_ENUM:
             case CMD_ENUM_ALL:
                 if( Params.wDefaultArgCount>2)
                 {
                    error_printf(_T("maximum default arguments number exceeds expected (2)\n"));
                    return 1;
                 }
                 
                        break;
             case CMD_COPY:
             case CMD_RENAME: 
             case CMD_APPRENAME: 
                 if( Params.wDefaultArgCount>3)
                 {
                    error_printf(_T("maximum default arguments number exceeds expected (3)\n"));
                    return 1;
                 }

                 else
                    Params.lpszPathDst=Params.lplpszDefaultArg[2];
                 break;

             default:
                error_printf(_T("command not recognized: %s or number of parameters doesn't match\n"),Params.lpszCommand);
                return 1;

            }
        }
    } //end of default argument handling

        
    //extract computer,service,instance, if stored in Path
    AdmNode.SetPath(Params.lpszPath);

    //valid only for copy function
    AdmDstNode.SetPath(Params.lpszPathDst);

    //process computer, service, instance, property name arguments
    if(Params.lpszComputer!=NULL) {
        if(!AdmNode.GetComputer().IsEmpty()) {
            error_printf(_T("computer name entered more than once\n"));
            return 1;
        }
        else
            AdmNode.SetComputer(Params.lpszComputer);
    }

    if(Params.lpszService!=NULL) {
        if(!AdmNode.GetService().IsEmpty()) {
            error_printf(_T("service name entered more than once\n"));
            return 1;
        }
        else {
            if(IsServiceName(Params.lpszService))
                AdmNode.SetService(Params.lpszService);
            else {
                error_printf(_T("service name not recognized: %s\n"), Params.lpszService);
                return 1;
            }
        }
    }

    if(Params.wInstance!=0) 
    {
        if(!AdmNode.GetInstance().IsEmpty()) {
            error_printf(_T("instance entered more than once\n"));
            return 1;
        }
        else {
            _TCHAR buf[30];
            //!!! maybe ltoa should be used
            AdmNode.SetInstance(_itot(Params.wInstance,buf,10));
        }
    }

    //******************************************        
    //process attrib, utype, dtype, value

    //property name first
    CString strProp=AdmNode.GetProperty();
    if(Params.lpszPropName!=NULL && !strProp.IsEmpty())
    {
        error_printf(_T("property name entered more than once\n"));
        return 1;
    }
    else if (Params.lpszPropName!=NULL)
    {
        AdmNode.SetProperty(Params.lpszPropName);

    }
    if(IsNumber(AdmNode.GetProperty()))
    {
        AdmProp.SetIdentifier(_ttol(AdmNode.GetProperty()));
    }
    else
    {
        DWORD dwIdentifier=MapPropertyNameToCode(AdmNode.GetProperty());
        if(dwIdentifier==NAME_NOT_FOUND)
        {}
        else
            AdmProp.SetIdentifier(dwIdentifier) ;
    }
    
    //process the attrib entered on command line
    if(Params.wPropAttribCount!=0)
    {   DWORD dwAttrib=0;
        for (i=0;i<Params.wPropAttribCount;i++)
        {
            if(IsNumber(Params.lplpszPropAttrib[i]))
                dwAttrib += _ttol(Params.lplpszPropAttrib[i]);
            else
            {
                DWORD dwMapped=MapAttribNameToCode(Params.lplpszPropAttrib[i]);
                if(dwMapped==NAME_NOT_FOUND)
                {
                    error_printf(_T("attribute name not resolved: %s\n"), Params.lplpszPropAttrib[i]);
                    return 1;
                }
                else
                    dwAttrib |= dwMapped;
            }
        }
        //overwrite the default attrib
        AdmProp.SetAttrib(dwAttrib) ;
    }

    //process the usertype entered on command line
    if(Params.wPropUserTypeCount!=0)
    {   DWORD dwUserType=0;
        for (i=0;i<Params.wPropUserTypeCount;i++)
        {
            if(IsNumber(Params.lplpszPropUserType[i]))
                dwUserType += _ttol(Params.lplpszPropUserType[i]);
            else
            {
                DWORD dwMapped=MapUserTypeNameToCode(Params.lplpszPropUserType[i]);
                if(dwMapped==NAME_NOT_FOUND)
                {
                    error_printf(_T("user type not resolved: %s\n"), Params.lplpszPropUserType[i]);
                    return 1;
                }
                else
                    dwUserType |= dwMapped;
            }
        }
        //overwrite the default UserType
        AdmProp.SetUserType(dwUserType) ;
    }


    //process the datatype entered on command line
    if(Params.wPropDataTypeCount!=0)
    {   DWORD dwDataType=0;
        for (i=0;i<Params.wPropDataTypeCount;i++)
        {
            if(IsNumber(Params.lplpszPropDataType[i]))
                dwDataType += _ttol(Params.lplpszPropDataType[i]);
            else
            {
                DWORD dwMapped=MapDataTypeNameToCode(Params.lplpszPropDataType[i]);
                if(dwMapped==NAME_NOT_FOUND)
                {
                    error_printf(_T("DataType type not resolved: %s\n"), Params.lplpszPropDataType[i]);
                    return 1;

                }
                else
                    dwDataType |= dwMapped;
            }
        }
        //overwrite the default DataTypeType
        AdmProp.SetDataType(dwDataType) ;
    }
//LPCTSTR lplpszPropValue[MAX_NUMBER_OF_PROPERTY_VALUES]; //pointer to array of values (e.g multisz type allows the multiple values for one property
//WORD  wPropValueCount;

    
    //create admin object
    if(oAdmin.GetpcAdmCom()==NULL)
    {
        oAdmin.Open(AdmNode.GetComputer());
        if( FAILED(oAdmin.QueryLastHresError()))
        {
            retval= ConvertHresToDword(oAdmin.QueryLastHresError());
        }
    }
    
    
    if(oAdmin.GetpcAdmCom()!=NULL)
    {
        //
        // read from files if Params.wPropFileValueCount != 0
        //

        if ( Params.wPropFileValueCount )
        {
            if ( !ReadFromFiles( (LPTSTR*)Params.lplpszPropValue, Params.lpdwPropValueLength, Params.wPropFileValueCount ) )
            {
                error_printf(_T("Can't read value from file %s"), Params.lplpszPropValue[0] );
                return 1;
            }
            Params.wPropValueCount = Params.wPropFileValueCount;
        }

        oAdmin.Run(CString(Params.lpszCommand), 
            AdmNode, 
            AdmProp, 
            AdmDstNode,
            Params.lplpszPropValue,
            Params.lpdwPropValueLength,
            Params.wPropValueCount);
            retval=ConvertHresToDword(oAdmin.QueryLastHresError());
        
    }
    return ((retval==0)?0:1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpmib\mib.c ===
/*++  BUILD Version: 0001   // Increment this if a change has global effects.

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      mib.c

   Abstract:

      This defines Auxiliary functions for defining an SNMP Extension Agent
         for collecting and querying Statistical information.

   Author:

       Murali R. Krishnan    ( MuraliK )     23-Feb-1995

   Environment:

       User Mode -- Win32

   Project:

       SNMP Extension DLL for SMTP Service DLL

   Functions Exported:

     UINT  ResolveVarBinding();
     UINT  MibStatisticsWorker();

   Revision History:

--*/

# include "mib.h"

static UINT
MibLeafFunction(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
  );

static UINT
MibGetNextVar(
   IN OUT RFC1157VarBind    *  pRfcVarBinding,
   IN MIB_ENTRY             *  pMibeCurrent,
   IN MIB_ENTRIES           *  pMibEntries,
   IN LPVOID                   pStatistics
  );


static VOID
PrintAsnObjectIdentifier( IN char * pszOidDescription,
                          IN AsnObjectIdentifier * pAsno)
{

    return;
} // PrintAsnObjectIdentifier()


UINT
ResolveVarBinding(
   IN OUT RFC1157VarBind   * pRfcVarBinding,
   IN BYTE                   pduAction,
   IN LPVOID                 pStatistics,
   IN LPMIB_ENTRIES          pMibEntries
  )
/*++
  Description:
    This function resolves a single variable binding. Modifies the variable
       on a GET or a GET-NEXT.

  Arguments:
     pRfcVarBinding    pointer to RFC Variable Bindings
     pduAction      Protocol Data Unit Action specified.
     pStatistics    pointer to statisitcs data structure containing
                      values of counter data.
     pMibEntries    pointer to MIB_ENTRIES context information
                      which contains prefix, array of MIB_ENTRIES and
                      count of the entries.
  Returns:
    Standard PDU error codes.

  Note:
--*/
{
    AsnObjectIdentifier  AsnTempOid;
    LPMIB_ENTRY  pMibScan;
    UINT         pduResult = SNMP_ERRORSTATUS_NOERROR;
    LPMIB_ENTRY pMibUpperBound =
      pMibEntries->prgMibEntry + pMibEntries->cMibEntries;

    //
    // Search for the variable binding name in the mib.
    //

    for( pMibScan = pMibEntries->prgMibEntry;
        pMibScan < pMibUpperBound;
        pMibScan++) {

        int iCmpResult;

        //
        // Create a fully qualified OID for the current item in the MIB.
        //  and use it for comparing against variable to be resolved.
        //

        SNMP_oidcpy( &AsnTempOid, pMibEntries->pOidPrefix);
        SNMP_oidappend( &AsnTempOid, &pMibScan->asnOid);

        iCmpResult = SNMP_oidcmp( &pRfcVarBinding->name, &AsnTempOid);
        SNMP_oidfree( &AsnTempOid);

        if ( iCmpResult == 0) {

            //
            // Found a match. Stop the search and process.
            //

            break;

        } else
          if ( iCmpResult < 0) {

              //
              // This could be the OID of a leaf ( withoug a trailing 0) or
              //  it could contain an invalid OID ( between valid OIDs).
              //

              if ( pduAction == MIB_GETNEXT) {

                  //
                  // Advance the variable binding to next entry
                  //
                  SNMP_oidfree( &pRfcVarBinding->name);
                  SNMP_oidcpy( &pRfcVarBinding->name,
                                pMibEntries->pOidPrefix);
                  SNMP_oidappend( &pRfcVarBinding->name, &pMibScan->asnOid);

                  if ( ( pMibScan->bType != ASN_RFC1155_OPAQUE) &&
                       ( pMibScan->bType != ASN_SEQUENCE)) {

                      pduAction = MIB_GET;
                  }

              } else {

                  pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;
              }

              //
              // Stop and process the appropriate entry.
              //

              break;
          } // ( iCmpResult < 0)

    } // for


    if ( pMibScan >= pMibUpperBound) {

        pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;
    }

    if ( pduResult == SNMP_ERRORSTATUS_NOERROR) {

        //
        // A match is found or further processing is required.
        //

        if ( pMibScan->pMibFunc == NULL) {

            //
            // This happens only if the match is for Group OID
            //

            pduResult = ( ( pduAction != MIB_GETNEXT) ?
                       SNMP_ERRORSTATUS_NOSUCHNAME:
                         MibGetNextVar( pRfcVarBinding,
                                       pMibScan,
                                       pMibEntries,
                                       pStatistics));
        } else {

            pduResult = ( pMibScan->pMibFunc) ( pRfcVarBinding,
                                               pduAction,
                                               pMibScan,
                                               pMibEntries,
                                               pStatistics);
        }
    }


    return ( pduResult);

} // ResolveVarBinding()

UINT
MibStatisticsWorker(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
   )
/*++
  This function resolves the variables assuming that there is statistical
    information ( sequence of counters) in the data passed in pStatistics.

  Arguments:
     pRfcVarBind   pointer to RFC variable binding to be resolved.
     pduAction     protocol data unit action to be taken.
     pMibeCurrent  pointer to MIB_ENTRY which is o be used for resolution.
     pMibEntries   pointer to MIB_ENTRIES structure to be used
                     as context for resolving and performing the action.
     pStatistics   pointer to sequence of counters used for data resolution.


  Returns:
    Standard PDU error codes.

--*/
{
    UINT   pduResult = SNMP_ERRORSTATUS_NOERROR;
                 // default indicating action to be done at end of switch

    switch( pduAction) {

      case MIB_SET:
      case MIB_GETNEXT:

        // action is performed at the end of switch statement.
        break;


      case MIB_GETFIRST:
      case MIB_GET:

        //
        //  If no statistics do no action.
        //  If this is the header field ( non-leaf) do no action
        //   Otherwise, perform action as if this is the leaf node.
        //

        if ( pStatistics == NULL || pMibeCurrent->lFieldOffset == -1) {

            pduResult = SNMP_ERRORSTATUS_GENERR;
        }

        // Action on this node is performed at the end of the switch statement.
        break;

      default:
        pduResult = SNMP_ERRORSTATUS_GENERR;
        break;
    } // switch()


    if ( pduResult == SNMP_ERRORSTATUS_NOERROR) {

        //
        // Use the generic leaf function to perform the action specified.
        //
        pduResult = MibLeafFunction( pRfcVarBinding, pduAction, pMibeCurrent,
                                    pMibEntries, pStatistics);
    }

    return ( pduResult);

} // MibStatisticsWorker()




static UINT
MibLeafFunction(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
  )
/*++
  This function resolves the variables assuming that there is statistical
    information ( sequence of counters) in the data passed in pStatistics
    and that this is a leaf node of the MIB tree.
  This is a generic function for leaf nodes.

  Arguments:
     pRfcVarBind   pointer to RFC variable binding to be resolved.
     pduAction     protocol data unit action to be taken.
     pMibeCurrent  pointer to MIB_ENTRY which is o be used for resolution.
     pMibEntries   pointer to MIB_ENTRIES structure to be used
                     as context for resolving and performing the action.
     pStatistics   pointer to sequence of counters used for data resolution.


  Returns:
    Standard PDU error codes.

--*/
{
    UINT  pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;  // default is error value.

    switch( pduAction ) {

      case MIB_GETNEXT:

        //
        //  Determine if we're within the range and not at the end.
        //  If not within the range the above default pduResult == NOSUCHNAME
        //         is the required error message.
        //

        if ( ( pMibeCurrent >= pMibEntries->prgMibEntry) &&
             ( pMibeCurrent <
              ( pMibEntries->prgMibEntry + pMibEntries->cMibEntries))) {

            pduResult = MibGetNextVar( pRfcVarBinding,
                                      pMibeCurrent,
                                      pMibEntries,
                                      pStatistics);
        }

        break;

      case MIB_GETFIRST:
      case MIB_GET:

        //
        //  Make sure that this variable's ACCESS is GET'able.
        //  If the access prohibits from GETting it, report error as
        //    NOSUCHNAME ( default value of pduResult in initialization above)
        //

        if(( pMibeCurrent->uiAccess == MIB_ACCESS_READ ) ||
           ( pMibeCurrent->uiAccess == MIB_ACCESS_READWRITE ) ) {

            DWORD  dwValue;

            //
            //  Setup pRfcVarBinding's return value.
            //

            pRfcVarBinding->value.asnType = pMibeCurrent->bType;
            dwValue = *( (LPDWORD )((LPBYTE )pStatistics +
                                    pMibeCurrent->lFieldOffset));

            pduResult = SNMP_ERRORSTATUS_NOERROR;  // we found a value.

            switch( pMibeCurrent->bType)  {

              case ASN_RFC1155_GAUGE:
                pRfcVarBinding->value.asnValue.gauge = (AsnGauge ) dwValue;
                break;

              case ASN_RFC1155_COUNTER:
                pRfcVarBinding->value.asnValue.counter = (AsnCounter ) dwValue;
                break;

              case ASN_INTEGER:
                pRfcVarBinding->value.asnValue.number = (AsnInteger ) dwValue;
                break;

              case ASN_RFC1155_IPADDRESS:
              case ASN_OCTETSTRING:
                //
                //  Not supported for this MIB (yet).
                //  Fall through to indicate generic error.
                //

              default:

                //
                // Sorry! Type in Mibe does not suit our purpose.
                //   Indicate generic error.
                //
                pduResult = SNMP_ERRORSTATUS_GENERR;
                break;
            } // innner switch

        } // if ( valid read access)

        break;

      case MIB_SET:

        //
        //  We don't support settable variables (yet).
        //   Fall through for error.
        //

      default:
        pduResult = SNMP_ERRORSTATUS_GENERR;
        break;
    } // switch ( pduAction)


    return ( pduResult);

} // MibLeafFunction()





static UINT
MibGetNextVar(
   IN OUT RFC1157VarBind    *  pRfcVarBinding,
   IN MIB_ENTRY             *  pMibeCurrent,
   IN MIB_ENTRIES           *  pMibEntries,
   IN LPVOID                   pStatistics)
/*++
  Description:
     This function sets the binding variable to iterate to the next variable.

  Arguments:
     pRfcVarBind   pointer to RFC variable binding to be resolved.
     pMibeCurrent  pointer to MIB_ENTRY which is o be used for resolution.
     pMibEntries   pointer to MIB_ENTRIES structure to be used
                     as context for resolving and performing the action.
     pStatistics   pointer to sequence of counters used for data resolution.

  Returns:
     PDU Error Codes.
--*/
{
    UINT  pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;
    LPMIB_ENTRY pMibUpperBound =
      pMibEntries->prgMibEntry + pMibEntries->cMibEntries;

    //
    // If within the range of MIB ENTRIES process.
    //

    if ( pMibeCurrent >= pMibEntries->prgMibEntry) {

        //
        //  Scan through the remaining MIB Entries
        //

        LPMIB_ENTRY  pMibeScan;

        for( pMibeScan = pMibeCurrent+1;
             pMibeScan < pMibUpperBound;
             pMibeScan++ ) {

            //
            // Setup variable bindings for the next MIB variable
            //

            SNMP_oidfree( &pRfcVarBinding->name);
            SNMP_oidcpy( &pRfcVarBinding->name, pMibEntries->pOidPrefix);
            SNMP_oidappend( &pRfcVarBinding->name, &pMibeScan->asnOid);

            //
            //  If the function pointer is not NULL and the type of the MIB
            //  variable is anything but OPAQUE, then call the function to
            //  process the MIB variable.
            //

            if(( pMibeScan->pMibFunc != NULL ) &&
               ( pMibeScan->bType    != ASN_RFC1155_OPAQUE ) ) {

                pduResult = ( pMibeScan->pMibFunc)( pRfcVarBinding,
                                                   MIB_GETFIRST,
                                                   pMibeScan,
                                                   pMibEntries,
                                                   pStatistics);
                break;
            }

            //
            // On failure in the scan, pduResult will have default value
            //    as initialized above in declaration.
            //

        } // for
    }

    return ( pduResult);

} // MibGetNextVar()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\storedrv\ntff.cpp ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\smtpmd\vptool.cpp ===
/*===================================================================
Microsoft ASP

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Package Management Tool

File: main.cpp

Owner: leijin

Note:
===================================================================*/


#include <tchar.h>

#include "admutil.h"
#include <stdio.h>
#include <objbase.h>
#include <initguid.h>

//#ifdef _WAMREG_LINK_DIRECT
//#include "..\wmrgexp.h"
//#endif

#include <iwamreg.h>

#define SIZE_STRING_BUFFER  1024


void CAdmUtil::OpenWamAdm (const CString & strComputer)
{
    IClassFactory * pcsfFactory = NULL;
    COSERVERINFO csiMachineName;
    COSERVERINFO *pcsiParam = NULL;
    OLECHAR rgchMachineName[MAX_PATH];

    //release previous interface if needed
    if(pIWamAdm!=0)
    {
	//reuse the interface
	return;
        //pIWamAdm->Release();
        //pIWamAdm=0;
    }
    //convert to OLECHAR[];
    #if UNICODE
        wsprintfW( rgchMachineName, L"%s", LPCTSTR(strComputer));
    #else
            wsprintfW( rgchMachineName, L"%S", LPCTSTR(strComputer));
    #endif
            
    //fill the structure for CoGetClassObject
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;
    pcsiParam = &csiMachineName;
    csiMachineName.pwszName =  (strComputer.IsEmpty())?NULL:rgchMachineName;

    hresError = CoGetClassObject(CLSID_WamAdmin, CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);

    if (FAILED(hresError))
    {
     Error(_T("Failed to CoGetClassObject of WamAdm object"));
    }
    else {
        hresError = pcsfFactory->CreateInstance(NULL, IID_IWamAdmin, (void **) &pIWamAdm);
        if (FAILED(hresError)) Error(_T("Failed to CreateInstance of WamAdm object"));
        pcsfFactory->Release();
    }
}

void CAdmUtil::CloseWamAdm (void)
{
	if(pIWamAdm!=0)
    {
        pIWamAdm->Release();
        pIWamAdm=0;
    }
}

void CAdmUtil::AppCreateInProc(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT     hr = NOERROR;
    //  
    INT         cSize = 0;
    INT         cch = 0;
#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    
    OpenWamAdm(strComputer);

    if (SUCCEEDED(hresError) && pIWamAdm!=0)
    {
		CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm->AppCreate(wszMetabasePath, TRUE);
        if (FAILED(hresError))
            {
            Error(_T("create failed"));
            }
        else
            {
            Print(_T("application created\n"));
            }
    }

    //CloseWamAdm();

    return;
}

void CAdmUtil::AppCreateOutProc(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];
    
    
    INT         cSize = 0;
    INT         cch = 0;

#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    OpenWamAdm(strComputer);
    if (SUCCEEDED(hresError)&& pIWamAdm!=0)
    {
		CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm->AppCreate(wszMetabasePath, FALSE);
        if (FAILED(hresError))
        {
            Error(_T("create failed"));
        }
        else
        {
            Print(_T("application created\n"));
        }
    }
    //CloseWamAdm();
    return;
}

void CAdmUtil::AppDelete(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];


    INT         cSize = 0;
    INT         cch = 0;

#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    OpenWamAdm(strComputer);
    if (SUCCEEDED(hresError)&& pIWamAdm!=0)
        {
		CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm->AppDelete(wszMetabasePath,FALSE);
        if (FAILED(hresError))
            {
            Error(_T("delete failed"));
            }   
        else
            {
            Print(_T("application deleted\n"));
            }
        }
    //CloseWamAdm();
    return;
}

void CAdmUtil::AppRename(CAdmNode& a_AdmNode, CAdmNode& a_AdmDstNode, const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];

    WCHAR       wszMetabaseDstPath[SIZE_STRING_BUFFER];

    INT         cSize = 0;
    INT         cch = 0;

#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, LPCTSTR(a_AdmNode.GetLMNodePath()), -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }

    wcscat(wszMetabaseDstPath,L"/");
    cSize = MultiByteToWideChar(0, 0, LPCTSTR(a_AdmDstNode.GetLMNodePath()), -1, wszMetabaseDstPath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
    wcscat(wszMetabaseDstPath,L"/");

#else
    wcscpy(wszMetabasePath,LPCTSTR(a_AdmNode.GetLMNodePath()));
    wcscpy(wszMetabaseDstPath,LPCTSTR(a_AdmDstNode.GetLMNodePath()));
#endif


    OpenWamAdm(strComputer);
    if (SUCCEEDED(hresError)&& pIWamAdm!=0)
        {
	    CloseObject_hmd(); //close reusable handle; it may conflict with WAM
            hresError = pIWamAdm->AppDeleteRecoverable(wszMetabasePath,TRUE /*Recursive*/);
            if (FAILED(hresError))
            {
                Error(_T("AppDeleteRecoverable() failed"));
            }   
            else
            {
                RenameObject(a_AdmNode,a_AdmDstNode);
                if(FAILED(QueryLastHresError()))
                {
                   Error(_T("node failed to be renamed"));
                }
                else
                {  
	          CloseObject_hmd(); //close reusable handle; it may conflict with WAM
                  hresError = pIWamAdm->AppRecover(wszMetabaseDstPath,TRUE /*Recursive*/);
 	          if (FAILED(hresError))
                  {
                     Error(_T("AppRecover() failed"));
                  }
		  else
                  {
                     Print(_T("application renamed\n"));
                  }
                }
             }
        }
    //CloseWamAdm();
    return;
}


void CAdmUtil::AppUnLoad(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];


    INT         cSize = 0;
    INT         cch = 0;

#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    OpenWamAdm(strComputer);
    if (SUCCEEDED(hresError)&& pIWamAdm!=0)
        {
		CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm->AppUnLoad(wszMetabasePath,FALSE);
        if (FAILED(hresError))
            {
            Error(_T("Unload application failed"));
            }
        else
            {
            Print(_T("application unloaded\n"));
            }

        }
    //CloseWamAdm();
    return;
}

void CAdmUtil::AppGetStatus(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];
    

    INT         cSize = 0;
    INT         cch = 0;

#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("The Metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    OpenWamAdm(strComputer);
    if (SUCCEEDED(hresError)&& pIWamAdm!=0)
        {
        DWORD dwStatus;
		CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm->AppGetStatus(wszMetabasePath, &dwStatus);
        if (FAILED(hresError))
            {
            Error(_T("GetStatus of application  %s failed"));
            }
        else
            {
            if (dwStatus == APPSTATUS_NOTDEFINED)
                {
                Print(_T("Application is not defined\n"));
                }
            else if (dwStatus == APPSTATUS_STOPPED)
                {
                Print(_T("Application is stopped\n"));
                }
            else if (dwStatus == APPSTATUS_RUNNING)
                {
                Print(_T("Application is running\n"));
                }
            else
                {
                Print(_T("Application is in unknown state\n"));
                }
            }                   
        }
    //CloseWamAdm();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\snmp\makefile.inc ===
copyfiles:
!if "$(_NTTREE) != ""
	xcopy /verifd smtp.mib $(_NTTREE)\staxpt\
!endif
!if "$(_NTTREE_NO_SPLIT) != ""
	xcopy /verifd smtp.mib $(_NTTREE_NO_SPLIT)\staxpt\
!endif

$(O)\smtpmib.bin: ..\..\mibs\smi.mib ..\..\mibs\inetsrv.mib smtp.mib
    mibcc -o$(O)\smtpmib.bin ..\..\mibs\smi.mib ..\..\mibs\inetsrv.mib smtp.mib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\storedrv\ntfsdrct.h ===
/*==========================================================================*\

    Module:        ipcctrs.h

    Copyright Microsoft Corporation 1998, All Rights Reserved.

    Author:        WayneC, MinYang

    Descriptions:  Object and Counter definitions for ExIPC.

\*==========================================================================*/

//
//  Object and Counter definitions
//

#define OBJECT_NTFSDRV                          0

#define NTFSDRV_QUEUE_LENGTH                    2
#define NTFSDRV_NUM_ALLOCS                      4
#define NTFSDRV_NUM_DELETES                     6
#define NTFSDRV_NUM_ENUMERATED                  8
#define NTFSDRV_MSG_BODIES_OPEN                 10
#define NTFSDRV_MSG_STREAMS_OPEN                12
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\storedrv\ntfs.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1998,1999 Microsoft Corporation
//
//  File:       ntfs.h
//
//  Contents:   Header file for NTFS-base message class
//
//-----------------------------------------------------------------------------
#ifndef __NTFS_H_
#define __NTFS_H_

#include "resource.h"       // main symbols
#include "listmacr.h"
#include "evntwrap.h"
#include "perf.h"


//
// Class IDs
//
EXTERN_C const CLSID CLSID_NtfsStoreDriver;
EXTERN_C const CLSID CLSID_NtfsEnumMessages;
EXTERN_C const CLSID CLSID_NtfsPropertyStream;

/////////////////////////////////////////////////////////////////////////////
// CDriverUtils

class CDriverUtils
{
public:
	CDriverUtils();
	~CDriverUtils();

	static HRESULT LoadStoreDirectory(
				DWORD	dwInstanceId,
				LPTSTR	szStoreDirectory,
				DWORD	*pdwLength
				);

	static HRESULT GetStoreFileName(
				LPTSTR	szStoreDirectory,
				LPTSTR	szStoreFilename,
				DWORD	*pdwLength
				);

	static HRESULT GetStoreFileFromPath(
				LPTSTR					szStoreFilename,
				IMailMsgPropertyStream	**ppStream,
				PFIO_CONTEXT			*phContentFile,
				BOOL					fCreate,
				BOOL					fIsFAT,
                IMailMsgProperties      *pMsg,
				GUID					guidInstance = GUID_NULL
				);

	static HRESULT SetMessageContext(
				IMailMsgProperties		*pMsg,
				LPBYTE					pbContext,
				DWORD					dwLength
				);

	static HRESULT GetMessageContext(
				IMailMsgProperties		*pMsg,
				LPBYTE					pbContext,
				DWORD					*pdwLength
				);

	static HRESULT IsStoreDirectoryFat(
				LPTSTR	szStoreDirectory,
				BOOL	*pfIsFAT
				);

#if 0
	static HANDLE CreateFileCallback(
				LPSTR	szFilename,
				LPVOID	lpvData,
				DWORD	*pdwSize,
				DWORD	*pdwSizeHigh
				);
#endif

private:
	static DWORD			s_dwCounter;
};

typedef struct {
	DWORD		dwSignature;
	DWORD		dwVersion;
	GUID		guidInstance;
} NTFS_STREAM_HEADER;

#define STREAM_OFFSET				sizeof(NTFS_STREAM_HEADER)
#define STREAM_SIGNATURE			'rvDN'
#define STREAM_SIGNATURE_INVALID	'rvD!'
#define STREAM_SIGNATURE_PRECOMMIT	'rvDp'
#define STREAM_SIGNATURE_NOOFFSET	'MMCv'

//
// These are internal status codes used by CNtfsStoreDriver::SetHandle
// to report on the status of the current stream
//
// They aren't errors because SetHandle does actually load the stream.
// they are hints to the caller telling them that mailmsg won't be
// able to parse the stream.
//
#define FACILITY_NTFSDRV        0x6b1
#define NTFSDRV_S_HRESULT(_x_) \
    MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_NTFSDRV, (_x_))
#define S_NO_FIRST_COMMIT       NTFSDRV_S_HRESULT(1)
#define S_INVALIDSTREAM         NTFSDRV_S_HRESULT(2)

/////////////////////////////////////////////////////////////////////////////
// CNtfsStoreDriver

class ATL_NO_VTABLE CNtfsStoreDriver :
	public IMailMsgStoreDriver,
	public ISMTPStoreDriver,
	public IEventIsCacheable,
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public CComCoClass<CNtfsStoreDriver, &CLSID_NtfsStoreDriver>,
    public IMailMsgStoreDriverValidateContext
{
public:
    CNtfsStoreDriver();
    ~CNtfsStoreDriver();

	LONG AddUsage()
		{ return(InterlockedIncrement(&m_lRefCount)); }

	LONG ReleaseUsage()
		{ return(InterlockedDecrement(&m_lRefCount)); }

	DWORD GetInstance()
		{ return(m_dwInstance); }

	BOOL IsShuttingDown()
		{ return(m_fIsShuttingDown); }

	/***************************************************************************/
	//
	// Implementation of IUnknown
	//

	HRESULT STDMETHODCALLTYPE QueryInterface(
				REFIID		iid,
				void		**ppvObject
				);

	ULONG STDMETHODCALLTYPE AddRef();

	ULONG STDMETHODCALLTYPE Release();

	/***************************************************************************/
	//
	// IMailMsgStoreDriver
	//
	HRESULT STDMETHODCALLTYPE AllocMessage(
				IMailMsgProperties		*pMsg,
				DWORD					dwFlags,
				IMailMsgPropertyStream	**ppStream,
				PFIO_CONTEXT			*phContentFile,
				IMailMsgNotify			*pNotify
				);

	HRESULT STDMETHODCALLTYPE EnumMessages(
				IMailMsgEnumMessages	**ppEnum
				);

	HRESULT STDMETHODCALLTYPE ReOpen(
				IMailMsgProperties		*pMsg,
				IMailMsgPropertyStream	**ppStream,
				PFIO_CONTEXT			*phContentFile,
				IMailMsgNotify			*pNotify
				);

	HRESULT STDMETHODCALLTYPE Delete(
				IMailMsgProperties		*pMsg,
				IMailMsgNotify			*pNotify
				);

	HRESULT STDMETHODCALLTYPE CloseContentFile(
				IMailMsgProperties		*pMsg,
				PFIO_CONTEXT			hContentFile
				);

	HRESULT STDMETHODCALLTYPE ReAllocMessage(
				IMailMsgProperties		*pOriginalMsg,
				IMailMsgProperties		*pNewMsg,
				IMailMsgPropertyStream	**ppStream,
				PFIO_CONTEXT		*phContentFile,
				IMailMsgNotify			*pNotify
				);

	HRESULT STDMETHODCALLTYPE SupportWriteContent() { return S_OK; }

	/***************************************************************************/
	//
	// ISMTPStoreDriver
	//
	HRESULT STDMETHODCALLTYPE Init(
				DWORD dwInstance,
				IUnknown *pBinding,
				IUnknown *pServer,
				DWORD dwReason,
				IUnknown **ppStoreDriver
				);

	HRESULT STDMETHODCALLTYPE PrepareForShutdown(
				DWORD dwReason
				);

	HRESULT STDMETHODCALLTYPE Shutdown(
				DWORD dwReason
				);

	HRESULT STDMETHODCALLTYPE LocalDelivery(
				IMailMsgProperties *pMsg,
				DWORD dwRecipCount,
				DWORD *pdwRecipIndexes,
				IMailMsgNotify *pNotify
				);

	HRESULT STDMETHODCALLTYPE EnumerateAndSubmitMessages(
				IMailMsgNotify *pNotify
				);

	//
	// IEventIsCahceable
	//
	HRESULT STDMETHODCALLTYPE IsCacheable();

    //
    //  IMailMsgStoreDriverValidateContext
    //
    HRESULT STDMETHODCALLTYPE ValidateMessageContext(
                                        BYTE *pbContext,
                                        DWORD cbContext);

DECLARE_REGISTRY_RESOURCEID(IDR_NTFSDRV)

BEGIN_COM_MAP(CNtfsStoreDriver)
    COM_INTERFACE_ENTRY(IMailMsgStoreDriver)
    COM_INTERFACE_ENTRY(ISMTPStoreDriver)
    COM_INTERFACE_ENTRY(IEventIsCacheable)
    COM_INTERFACE_ENTRY(IMailMsgStoreDriverValidateContext)
END_COM_MAP()

	GUID GetInstanceGuid() { return m_guidInstance; }

    BOOL IsFAT() { return m_fIsFAT; }

private:

	LONG				m_lRefCount;

	DWORD				m_dwInstance;

	TCHAR				m_szQueueDirectory[MAX_PATH * 2];
	TCHAR				m_szDropDirectory[MAX_PATH * 2];
	BOOL				m_fInitialized;
	BOOL				m_fIsShuttingDown;
	ISMTPServer			*m_pSMTPServer;

	// Reference count
	LONG				m_ulRefCount;

	BOOL				m_fIsFAT;

	// our instance guid
	GUID			    m_guidInstance;

public:

    //Use list entry to maintain the list to keep track of current
    //instances of sink of this type
    LIST_ENTRY  m_InstLEntry;

public:
    //Global array of instances
    static DWORD                sm_cCurrentInstances;
    static CRITICAL_SECTION     sm_csLockInstList;
    static LIST_ENTRY           sm_ListHead;

    //for controlling the retry queue
    static void LockList () {EnterCriticalSection (&CNtfsStoreDriver::sm_csLockInstList);}
    static void UnLockList() {LeaveCriticalSection (&CNtfsStoreDriver::sm_csLockInstList);}

    //Lookup and insert into array
    static IUnknown * LookupSinkInstance(DWORD dwVirtualServerId, REFIID iidBinding)
    {
        PLIST_ENTRY  pCurrentListEntry;
        CNtfsStoreDriver * pStoreInstance = NULL;

        //Initialize
        pCurrentListEntry = &sm_ListHead;

        //Look at the next entry to see if we are not at the end of the queue
        while(pCurrentListEntry->Flink != &sm_ListHead)
        {
            //Get the object pointed by the next entry
            pStoreInstance = CONTAINING_RECORD( pCurrentListEntry->Flink, CNtfsStoreDriver, m_InstLEntry);

            //If the entry has same virtual server id we are done
            //NK** : check binding too in MM3 timeframe
            if(dwVirtualServerId == pStoreInstance->m_dwInstance)
            {
                    return (IUnknown *)(ISMTPStoreDriver *)pStoreInstance;
            }

            pCurrentListEntry = pCurrentListEntry->Flink;
        }
        return NULL;
    }

    static HRESULT InsertSinkInstance(PLIST_ENTRY  pListEntry)
    {
        CNtfsStoreDriver::sm_cCurrentInstances++;
        //insert at the start of the list
        InsertHeadList(&sm_ListHead, pListEntry);
        return S_OK;
    }

    static HRESULT RemoveSinkInstance(IUnknown * pISinkInstance)
    {
        PLIST_ENTRY  pCurrentListEntry;
        CNtfsStoreDriver * pStoreInstance = NULL;

        //Initialize
        pCurrentListEntry = &sm_ListHead;

        //Look at the next entry to see if we are not at the end of the queue
        while(pCurrentListEntry->Flink != &sm_ListHead)
        {
            //Get the object pointed by the next entry
            pStoreInstance = CONTAINING_RECORD( pCurrentListEntry->Flink, CNtfsStoreDriver, m_InstLEntry);

            //If the entry has same instance pointer we are done
            //check binding too in MM3 timeframe
            if(pISinkInstance == (IUnknown *)(ISMTPStoreDriver *)pStoreInstance)
            {
                RemoveEntryList(pCurrentListEntry->Flink);
                CNtfsStoreDriver::sm_cCurrentInstances--;
                pStoreInstance->m_InstLEntry.Flink = NULL;
                pStoreInstance->m_InstLEntry.Blink = NULL;
                return S_OK;
            }

            pCurrentListEntry = pCurrentListEntry->Flink;
        }

        return(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    }

public:
    PerfObjectInstance *m_ppoi;
    static CEventLogWrapper    *g_pEventLog;

};

/////////////////////////////////////////////////////////////////////////////
// CNtfsStoreDriver

class ATL_NO_VTABLE CNtfsEnumMessages :
	public IMailMsgEnumMessages,
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public CComCoClass<CNtfsEnumMessages, &CLSID_NtfsEnumMessages>
{
public:
    CNtfsEnumMessages();
    ~CNtfsEnumMessages();

	HRESULT SetStoreDirectory(
				LPTSTR	szStoreDirectory,
				BOOL	fIsFAT
				);

	HRESULT SetInfo(
				CNtfsStoreDriver	*pDriver
				)
	{
		_ASSERT(pDriver);
		m_pDriver = pDriver;
		pDriver->AddUsage();
		return(S_OK);
	}

	/***************************************************************************/
	//
	// Implementation of IUnknown
	//

	HRESULT STDMETHODCALLTYPE QueryInterface(
				REFIID		iid,
				void		**ppvObject
				);

	ULONG STDMETHODCALLTYPE AddRef();

	ULONG STDMETHODCALLTYPE Release();

	//
	// IMailMsgEnumMessages
	//
	HRESULT STDMETHODCALLTYPE Next(
				IMailMsgProperties		*pMsg,
				IMailMsgPropertyStream	**ppStream,
				PFIO_CONTEXT			*phContentFile,
				IMailMsgNotify			*pNotify
				);

DECLARE_REGISTRY_RESOURCEID(IDR_NTFSENUM)

BEGIN_COM_MAP(CNtfsEnumMessages)
    COM_INTERFACE_ENTRY(IMailMsgEnumMessages)
END_COM_MAP()

private:
	CNtfsStoreDriver	*m_pDriver;
	BOOL				m_fIsFAT;

	TCHAR			m_szEnumPath[MAX_PATH * 2];
	TCHAR			m_szStorePath[MAX_PATH * 2];
	HANDLE			m_hEnum;
	WIN32_FIND_DATA	m_Data;

	// Reference count
	LONG			m_ulRefCount;

};

/////////////////////////////////////////////////////////////////////////////
// CNtfsPropertyStream

class ATL_NO_VTABLE CNtfsPropertyStream :
	public IMailMsgPropertyStream,
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public CComCoClass<CNtfsPropertyStream, &CLSID_NtfsPropertyStream>
{
public:

    CNtfsPropertyStream();
    ~CNtfsPropertyStream();

	//
	// guidInstance should be GUID_NULL when we are loading an existing
	// stream from disk, or an instance guid for the driver when we are
	// creating a new stream;
	//
	HRESULT SetHandle(
				HANDLE			    hStream,
				GUID			    guidInstance,
                BOOL                fLiveStream,
                IMailMsgProperties  *pMsg);

	HRESULT SetInfo(
				CNtfsStoreDriver	*pDriver
				)
	{
		_ASSERT(pDriver);
		m_pDriver = pDriver;
		pDriver->AddUsage();
        IncCtr((pDriver->m_ppoi), NTFSDRV_MSG_STREAMS_OPEN);
		return(S_OK);
	}

	/***************************************************************************/
	//
	// Implementation of IUnknown
	//

	HRESULT STDMETHODCALLTYPE QueryInterface(
				REFIID		iid,
				void		**ppvObject
				);

	ULONG STDMETHODCALLTYPE AddRef();

	ULONG STDMETHODCALLTYPE Release();

	//
	// IMailMsgPropertyStream
	//
	HRESULT STDMETHODCALLTYPE GetSize(
				IMailMsgProperties	*pMsg,
				DWORD			*pdwSize,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE ReadBlocks(
				IMailMsgProperties	*pMsg,
				DWORD				dwCount,
				DWORD				*pdwOffset,
				DWORD				*pdwLength,
				BYTE				**ppbBlock,
				IMailMsgNotify		*pNotify
				);

	HRESULT STDMETHODCALLTYPE StartWriteBlocks(
				IMailMsgProperties	*pMsg,
				DWORD 			cBlocks,
				DWORD			cBytes);

	HRESULT STDMETHODCALLTYPE EndWriteBlocks(
				IMailMsgProperties	*pMsg);

	HRESULT STDMETHODCALLTYPE CancelWriteBlocks(
				IMailMsgProperties	*pMsg);

	HRESULT STDMETHODCALLTYPE WriteBlocks(
				IMailMsgProperties	*pMsg,
				DWORD				dwCount,
				DWORD				*pdwOffset,
				DWORD				*pdwLength,
				BYTE				**ppbBlock,
				IMailMsgNotify		*pNotify
				);

DECLARE_REGISTRY_RESOURCEID(IDR_NTFSSTM)

BEGIN_COM_MAP(CNtfsPropertyStream)
    COM_INTERFACE_ENTRY(IMailMsgPropertyStream)
END_COM_MAP()

	GUID GetInstanceGuid() { return m_guidInstance; }

private:
	HANDLE				m_hStream;
	CNtfsStoreDriver	*m_pDriver;

    // how many times have we seen EndWriteBlocks? (and thus a full commit)
    BOOL                m_cCommits;

	// Reference count
	LONG				m_ulRefCount;

	// do we have header information?
	BOOL				m_fStreamHasHeader;

    // is the stream being used for validation?
    BOOL                m_fValidation;

	// the instance GUID under which this was created
	GUID				m_guidInstance;

    // the hresult that we returned from StartWriteBlocks.  if we failed
    // then we also fail writeblocks
    HRESULT             m_hrStartWriteBlocks;
};


#define DECLARE_STD_IUNKNOWN_METHODS(ClassRoot, Interface)	\
HRESULT STDMETHODCALLTYPE C##ClassRoot::QueryInterface(		\
			REFIID		iid,								\
			void		**ppvObject							\
			)												\
{															\
	if (iid == IID_IUnknown)								\
		*ppvObject = (IUnknown *)(##Interface *)this;		\
	else if (iid == IID_##Interface)						\
		*ppvObject = (##Interface *)this;					\
	else													\
		return(E_NOINTERFACE);								\
	AddRef();												\
	return(S_OK);											\
}															\
ULONG STDMETHODCALLTYPE C##ClassRoot::AddRef()				\
{															\
	return(InterlockedIncrement(&m_ulRefCount));			\
}															\
ULONG STDMETHODCALLTYPE C##ClassRoot::Release()				\
{															\
	LONG	lRefCount = InterlockedDecrement(&m_ulRefCount);\
	if (lRefCount == 0)										\
		delete this;										\
	return(lRefCount);										\
}

#endif //__NTFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\storedrv\atl.cpp ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  File:       atl.cpp
//
//  Contents:   Includes atlimpl.cpp, so that we don't rely on atl.dll
//
//  Classes:    All ATL classes.
//
//  Functions:  All ATL functions.
//
//  History:    October 23, 1997 - Milans, Created.
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "statreg.h"
#include "statreg.cpp"
#include "atlimpl.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\storedrv\ntfs.cpp ===
//+----------------------------------------------------------------------------
//
//  Ntfs.cpp : Implementation of NTFS Store driver classes
//
//  Copyright (C) 1998, Microsoft Corporation
//
//  File:       ntfs.cpp
//
//  Contents:   Implementation of NTFS Store driver classes.
//
//  Classes:    CNtfsStoreDriver, CNtfsPropertyStream
//
//  Functions:
//
//  History:    3/31/98     KeithLau        Created
//
//-----------------------------------------------------------------------------

#include "stdafx.h"

#include "filehc.h"
#include "mailmsg.h"
#include "mailmsgi.h"

#include "mailmsgprops.h"

#include "seo.h"
#include "seo_i.c"

#include "Ntfs.h"

#include "smtpmsg.h"

HANDLE g_hTransHeap = NULL;

//
// Instantiate the CLSIDs
//
#ifdef __cplusplus
extern "C"{
#endif

const CLSID CLSID_NtfsStoreDriver       = {0x609b7e3a,0xc918,0x11d1,{0xaa,0x5e,0x00,0xc0,0x4f,0xa3,0x5b,0x82}};
const CLSID CLSID_NtfsEnumMessages      = {0xbbddbdec,0xc947,0x11d1,{0xaa,0x5e,0x00,0xc0,0x4f,0xa3,0x5b,0x82}};
const CLSID CLSID_NtfsPropertyStream    = {0x6d7572ac,0xc939,0x11d1,{0xaa,0x5e,0x00,0xc0,0x4f,0xa3,0x5b,0x82}};

#ifdef __cplusplus
}
#endif

//
// Define the store file prefix and extension
//
#define NTFS_STORE_FILE_PREFIX                  _T("\\NTFS_")
#define NTFS_STORE_FILE_WILDCARD                _T("*")
#define NTFS_STORE_FILE_EXTENSION               _T(".EML")
#define NTFS_FAT_STREAM_FILE_EXTENSION_1ST      _T(".STM")
#define NTFS_FAT_STREAM_FILE_EXTENSION_LIVE     _T(".STL")
#define NTFS_STORE_FILE_PROPERTY_STREAM_1ST     _T(":PROPERTIES")
#define NTFS_STORE_FILE_PROPERTY_STREAM_LIVE    _T(":PROPERTIES-LIVE")
#define NTFS_STORE_BACKSLASH                    _T("\\")
#define NTFS_QUEUE_DIRECTORY_SUFFIX             _T("\\Queue")
#define NTFS_DROP_DIRECTORY_SUFFIX              _T("\\Drop")

#define SMTP_MD_ID_BEGIN_RESERVED   0x00009000
#define MD_MAIL_QUEUE_DIR               (SMTP_MD_ID_BEGIN_RESERVED+11 )
#define MD_MAIL_DROP_DIR                (SMTP_MD_ID_BEGIN_RESERVED+18 )

/////////////////////////////////////////////////////////////////////////////
// CDriverUtils

//
// Define the registry path location in the registry
//
#define NTFS_STORE_DIRECTORY_REG_PATH   _T("Software\\Microsoft\\Exchange\\StoreDriver\\Ntfs\\%u")
#define NTFS_STORE_DIRECTORY_REG_NAME   _T("StoreDir")

//
// Instantiate static
//
DWORD CDriverUtils::s_dwCounter = 0;
CEventLogWrapper *CNtfsStoreDriver::g_pEventLog = NULL;

CDriverUtils::CDriverUtils()
{
}

CDriverUtils::~CDriverUtils()
{
}

HRESULT CDriverUtils::LoadStoreDirectory(
            DWORD   dwInstanceId,
            LPTSTR  szStoreDirectory,
            DWORD   *pdwLength
            )
{
    HKEY    hKey = NULL;
    DWORD   dwRes;
    DWORD   dwType;
    TCHAR   szStoreDirPath[MAX_PATH];
    HRESULT hrRes = S_OK;

    _ASSERT(szStoreDirectory);
    _ASSERT(pdwLength);

    TraceFunctEnter("CDriverUtils::LoadStoreDirectory");

    // Build up the registry path given instance ID
    wsprintf(szStoreDirPath, NTFS_STORE_DIRECTORY_REG_PATH, dwInstanceId);

    // Open the registry key
    dwRes = (DWORD)RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                szStoreDirPath,
                0,
                KEY_ALL_ACCESS,
                &hKey);
    if (dwRes != ERROR_SUCCESS)
    {
        hrRes = HRESULT_FROM_WIN32(dwRes);
        goto Cleanup;
    }

    // Adjust the buffer size for character type ...
    (*pdwLength) *= sizeof(TCHAR);
    dwRes = (DWORD)RegQueryValueEx(
                hKey,
                NTFS_STORE_DIRECTORY_REG_NAME,
                NULL,
                &dwType,
                (LPBYTE)szStoreDirectory,
                pdwLength);
    if (dwRes != ERROR_SUCCESS)
    {
        hrRes = HRESULT_FROM_WIN32(dwRes);
        ErrorTrace((LPARAM)0, "Failed to load store driver directory %u", dwRes);
    }
    else
    {
        hrRes = S_OK;
        DebugTrace((LPARAM)0, "Store directory is %s", szStoreDirectory);
    }

Cleanup:

    if (hKey)
        RegCloseKey(hKey);

    TraceFunctLeave();
    return(hrRes);
}

HRESULT CDriverUtils::GetStoreFileName(
            LPTSTR  szStoreDirectory,
            LPTSTR  szStoreFilename,
            DWORD   *pdwLength
            )
{
    _ASSERT(szStoreDirectory);
    _ASSERT(szStoreFilename);
    _ASSERT(pdwLength);

    DWORD       dwLength = *pdwLength;
    DWORD       dwStrLen;
    FILETIME    ftTime;

    dwStrLen = lstrlen(szStoreDirectory);
    if (dwLength <= dwStrLen)
        return(HRESULT_FROM_WIN32(ERROR_MORE_DATA));

    lstrcpy(szStoreFilename, szStoreDirectory);
    dwLength -= dwStrLen;
    szStoreFilename += dwStrLen;
    *pdwLength = dwStrLen;

    GetSystemTimeAsFileTime(&ftTime);

    dwStrLen = lstrlen(NTFS_STORE_FILE_PREFIX) +
                lstrlen(NTFS_STORE_FILE_EXTENSION) +
                26;
    if (dwLength <= dwStrLen)
        return(HRESULT_FROM_WIN32(ERROR_MORE_DATA));
    wsprintf(szStoreFilename,
            "%s%08x%08x%08x%s",
            NTFS_STORE_FILE_PREFIX,
            ftTime.dwLowDateTime,
            ftTime.dwHighDateTime,
            InterlockedIncrement((PLONG)&s_dwCounter),
            NTFS_STORE_FILE_EXTENSION);

    *pdwLength += (dwStrLen + 1);

    return(S_OK);
}

HRESULT CDriverUtils::GetStoreFileFromPath(
            LPTSTR                  szStoreFilename,
            IMailMsgPropertyStream  **ppStream,
            PFIO_CONTEXT            *ppFIOContentFile,
            BOOL                    fCreate,
            BOOL                    fIsFAT,
            IMailMsgProperties      *pMsg,
            GUID                    guidInstance
            )
{
    // OK, got a file, get the content handle and property stream
    HRESULT hrRes = S_OK;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    HANDLE  hStream = INVALID_HANDLE_VALUE;
    TCHAR   szPropertyStream[MAX_PATH << 1];
    BOOL    fDeleteOnCleanup = FALSE;

    _ASSERT(fCreate || (guidInstance == GUID_NULL));

    IMailMsgPropertyStream  *pIStream = NULL;

    TraceFunctEnter("CDriverUtils::GetStoreFileFromPath");

    if (ppFIOContentFile)
    {
        // Open the content ...
        hFile = CreateFile(
                    szStoreFilename,
                    GENERIC_READ | GENERIC_WRITE,   // Read / Write
                    FILE_SHARE_READ,                // Shared read
                    NULL,                           // Default security
                    (fCreate)?CREATE_NEW:OPEN_EXISTING, // Create new or open existing file
                    FILE_FLAG_OVERLAPPED |          // Overlapped access
                    FILE_FLAG_SEQUENTIAL_SCAN,      // Seq scan
                    //FILE_FLAG_WRITE_THROUGH,      // Write through cache
                    NULL);                          // No template
        if (hFile == INVALID_HANDLE_VALUE)
            goto Cleanup;
    }

    DebugTrace(0, "--- start ---");
    if (ppStream)
    {
        DebugTrace((LPARAM)0, "Handling stream in %s", fIsFAT?"FAT":"NTFS");

        BOOL fTryLiveStream = !fCreate;
        BOOL fNoLiveStream = FALSE;
        BOOL fLiveWasCorrupt = FALSE;

        do {
            // Open the alternate file stream
            lstrcpy(szPropertyStream, szStoreFilename);

            if (fTryLiveStream) {
                DebugTrace((LPARAM) 0, "TryingLive");
                lstrcat(szPropertyStream,
                    fIsFAT?NTFS_FAT_STREAM_FILE_EXTENSION_LIVE:
                           NTFS_STORE_FILE_PROPERTY_STREAM_LIVE);
            } else {
                DebugTrace((LPARAM) 0, "Trying1st");
                lstrcat(szPropertyStream,
                    fIsFAT?NTFS_FAT_STREAM_FILE_EXTENSION_1ST:
                           NTFS_STORE_FILE_PROPERTY_STREAM_1ST);
            }

            DebugTrace((LPARAM) 0, "File: %s", szPropertyStream);

            hStream = CreateFile(
                        szPropertyStream,
                        GENERIC_READ | GENERIC_WRITE,   // Read / Write
                        FILE_SHARE_READ,                                // No sharing
                        NULL,                           // Default security
                        (fCreate)?
                        CREATE_NEW:                     // Create new or
                        OPEN_EXISTING,                  // Open existing file
                        FILE_FLAG_SEQUENTIAL_SCAN,      // Seq scan
                        //FILE_FLAG_WRITE_THROUGH,      // Write through cache
                        NULL);                          // No template
            if (hStream == INVALID_HANDLE_VALUE) {
                DebugTrace((LPARAM) 0, "Got INVALID_HANDLE_VALUE\n");
                if (fTryLiveStream && GetLastError() == ERROR_FILE_NOT_FOUND) {
                    DebugTrace((LPARAM) 0, "livestream and FILE_NOT_FOUND\n");
                    hrRes = S_INVALIDSTREAM;
                    fNoLiveStream = TRUE;
                } else if (GetLastError() == ERROR_FILE_NOT_FOUND) {
                    DebugTrace((LPARAM) 0, "no primary stream either\n");
                    hrRes = S_NO_FIRST_COMMIT;
                } else {
                    DebugTrace((LPARAM) 0, 
                        "Returning CreateFile error %lu\n", GetLastError());
                    hrRes = HRESULT_FROM_WIN32(GetLastError());
                    goto Cleanup;
                }
            } else {
                hrRes = CoCreateInstance(
                            CLSID_NtfsPropertyStream,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IMailMsgPropertyStream,
                            (LPVOID *)&pIStream);
                if (FAILED(hrRes))
                    goto Cleanup;

                hrRes = ((CNtfsPropertyStream *)pIStream)->SetHandle(hStream,
                                                                     guidInstance,
                                                                     fTryLiveStream,
                                                                     pMsg);
                if (FAILED(hrRes)) {
                    if (fCreate) fDeleteOnCleanup = TRUE;
                    goto Cleanup;
                }
            }

            if (hrRes == S_INVALIDSTREAM || hrRes == S_NO_FIRST_COMMIT) {
                if (hrRes == S_INVALIDSTREAM) {
                    DebugTrace((LPARAM) 0, 
                        "SetHandle returned S_INVALIDSTREAM\n");
                } else {
                    DebugTrace((LPARAM) 0, 
                        "SetHandle returned S_NO_FIRST_COMMIT\n");
                }
                if (fTryLiveStream) {
                    // if we were working with the live stream then retry with
                    // the 1st commited stream
                    fTryLiveStream = FALSE;
                    fLiveWasCorrupt = !fNoLiveStream;
                    DebugTrace((LPARAM) 0, "Trying regular stream\n");
                    if (pIStream) {
                        pIStream->Release();
                        pIStream = NULL;
                    }
                    if (hrRes == S_NO_FIRST_COMMIT) hrRes = S_INVALIDSTREAM;
                } else {
                    // the 1st committed stream was invalid.  this can
                    // only occur when the message was not acked.
                    //
                    // if the live stream existed and this one is invalid
                    // then something is weird, so we go down the eventlog
                    // path (returning S_OK).  S_OK works because currently
                    // pStream->m_fStreamHasHeader is set to 0.  Either
                    // the mailmsg signature check will fail or mailmsg
                    // won't be able to read the entire master header.
                    // either way will cause the message to be ignored and
                    // eventlog'd
                    //
                    // CEnumNtfsMessages::Next will delete the message
                    // for us
                    if (hrRes == S_INVALIDSTREAM) {
                        if (fLiveWasCorrupt && !fNoLiveStream) {
                            hrRes = S_OK;
                            DebugTrace((LPARAM) 0, "Returning S_OK because there was no live stream\n");
                        } else {
                            hrRes = S_NO_FIRST_COMMIT;
                            DebugTrace((LPARAM) 0, "Returning S_NO_FIRST_COMMIT\n");
                        }
                    } else {
                        DebugTrace((LPARAM) 0, "Returning S_NO_FIRST_COMMIT\n");
                    }
                }
            } else {
                DebugTrace((LPARAM) 0, "SetHandle returned other error %x\n", hrRes);
            }
            _ASSERT(SUCCEEDED(hrRes));
            if (FAILED(hrRes)) goto Cleanup;
        } while (hrRes == S_INVALIDSTREAM);
    }

    // Fill in the return values
    if (ppStream) {
        *ppStream = pIStream;
    }
    if (ppFIOContentFile) {
        *ppFIOContentFile = AssociateFile(hFile);
        if (*ppFIOContentFile == NULL) {
            goto Cleanup;
        }
    }

    TraceFunctLeave();
    return(hrRes);

Cleanup:
    if (hrRes == S_OK) hrRes = HRESULT_FROM_WIN32(GetLastError());
    if (SUCCEEDED(hrRes)) hrRes = E_FAIL;

    if (hStream != INVALID_HANDLE_VALUE) {
        CloseHandle(hStream);
    }
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }
    if (fDeleteOnCleanup) {
        // this only happens at file creation time.  There is no 
        // live file to worry about.  The below code is too simplistic
        // if we do have to delete a live stream.
        _ASSERT(fCreate);
        DeleteFile(szStoreFilename);
        DeleteFile(szPropertyStream);
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT CDriverUtils::SetMessageContext(
            IMailMsgProperties      *pMsg,
            LPBYTE                  pbContext,
            DWORD                   dwLength
            )
{
    HRESULT hrRes   = S_OK;
    BYTE    pbData[(MAX_PATH * 2) + sizeof(CLSID)];

    _ASSERT(pMsg);

    if (dwLength > (MAX_PATH * 2))
        return(E_INVALIDARG);

    MoveMemory(pbData, &CLSID_NtfsStoreDriver, sizeof(CLSID));
    MoveMemory(pbData + sizeof(CLSID), pbContext, dwLength);
    dwLength += sizeof(CLSID);
    hrRes = pMsg->PutProperty(
                IMMPID_MPV_STORE_DRIVER_HANDLE,
                dwLength,
                pbData);

    // make S_FALSE return S_OK
    if (SUCCEEDED(hrRes)) hrRes = S_OK;

    return(hrRes);
}

HRESULT CDriverUtils::GetMessageContext(
            IMailMsgProperties      *pMsg,
            LPBYTE                  pbContext,
            DWORD                   *pdwLength
            )
{
    HRESULT hrRes   = S_OK;
    DWORD   dwLength;

    _ASSERT(pMsg);
    _ASSERT(pbContext);
    _ASSERT(pdwLength);

    dwLength = *pdwLength;

    hrRes = pMsg->GetProperty(
                IMMPID_MPV_STORE_DRIVER_HANDLE,
                dwLength,
                pdwLength,
                pbContext);

    if (SUCCEEDED(hrRes))
    {
        dwLength = *pdwLength;

        // Verify length and CLSID
        if ((dwLength < sizeof(CLSID)) ||
            (*(CLSID *)pbContext != CLSID_NtfsStoreDriver))
            hrRes = NTE_BAD_SIGNATURE;
        else
        {
            // Copy the context info
            dwLength -= sizeof(CLSID);
            MoveMemory(pbContext, pbContext + sizeof(CLSID), dwLength);
            *pdwLength = dwLength;
        }
    }

    return(hrRes);
}

HRESULT CDriverUtils::IsStoreDirectoryFat(
            LPTSTR  szStoreDirectory,
            BOOL    *pfIsFAT
            )
{
    HRESULT hrRes = S_OK;
    TCHAR   szDisk[MAX_PATH];
    TCHAR   szFileSystem[MAX_PATH];
    DWORD   lSerial, lMaxLen, lFlags;
    DWORD   dwLength;
    UINT    uiErrorMode;

    _ASSERT(szStoreDirectory);
    _ASSERT(pfIsFAT);

    TraceFunctEnter("CDriverUtils::IsStoreDirectoryFat");

    // OK, find the root drive, make sure we handle UNC names
    dwLength = lstrlen(szStoreDirectory);
    if (dwLength < 2)
        return(E_INVALIDARG);

    szDisk[0] = szStoreDirectory[0];
    szDisk[1] = szStoreDirectory[1];
    if ((szDisk[0] == _T('\\')) && (szDisk[1] == _T('\\')))
    {
        DWORD   dwCount = 0;
        LPTSTR  pTemp = szDisk + 2;

        DebugTrace((LPARAM)0, "UNC Name: %s", szStoreDirectory);

        // Handle UNC
        szStoreDirectory += 2;
        while (*szStoreDirectory)
            if (*pTemp = *szStoreDirectory++)
                if (*pTemp++ == _T('\\'))
                {
                    dwCount++;
                    if (dwCount == 2)
                        break;
                }
        if (dwCount == 2)
            *pTemp = _T('\0');
        else if (dwCount == 1)
        {
            *pTemp++ = _T('\\');
            *pTemp = _T('\0');
        }
        else
            return(E_INVALIDARG);
    }
    else
    {
        DebugTrace((LPARAM)0, "Local drive: %s", szStoreDirectory);

        // Local path
        if (!_istalpha(szDisk[0]) || (szDisk[1] != _T(':')))
            return(E_INVALIDARG);
        szDisk[2] = _T('\\');
        szDisk[3] = _T('\0');
    }

    // Call the system to determine what file system we have here,
    // we set the error mode here to avoid unsightly pop-ups.
    uiErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    if (GetVolumeInformation(
                szDisk,
                NULL, 0,
                &lSerial, &lMaxLen, &lFlags,
                szFileSystem, MAX_PATH))
    {
        DebugTrace((LPARAM)0, "File system is: %s", szFileSystem);

        if (!lstrcmpi(szFileSystem, _T("NTFS")))
            *pfIsFAT = FALSE;
        else if (!lstrcmpi(szFileSystem, _T("FAT")))
            *pfIsFAT = TRUE;
        else if (!lstrcmpi(szFileSystem, _T("FAT32")))
            *pfIsFAT = TRUE;
        else
            hrRes = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
    }
    else
        hrRes = HRESULT_FROM_WIN32(GetLastError());
    SetErrorMode(uiErrorMode);

    TraceFunctLeave();
    return(hrRes);
}


/////////////////////////////////////////////////////////////////////////////
// CNtfsStoreDriver
//

//
// Instantiate static
//
DWORD                CNtfsStoreDriver::sm_cCurrentInstances = 0;
CRITICAL_SECTION     CNtfsStoreDriver::sm_csLockInstList;
LIST_ENTRY           CNtfsStoreDriver::sm_ListHead;

CNtfsStoreDriver::CNtfsStoreDriver()
{
    m_fInitialized = FALSE;
    m_fIsShuttingDown = FALSE;
    *m_szQueueDirectory = _T('\0');
    *m_szDropDirectory = _T('\0');
    m_pSMTPServer = NULL;
    m_lRefCount = 0;
    m_fIsFAT = TRUE; // Assume we ARE on a fat partition until we discover otherwise
    UuidCreate(&m_guidInstance);
    m_ppoi = NULL;
    m_InstLEntry.Flink = NULL;
    m_InstLEntry.Blink = NULL;
}

CNtfsStoreDriver::~CNtfsStoreDriver() {
    CNtfsStoreDriver::LockList();
    if (m_InstLEntry.Flink != NULL) {
        _ASSERT(m_InstLEntry.Blink != NULL);
        HRESULT hr = CNtfsStoreDriver::RemoveSinkInstance(
                        (IUnknown *)(ISMTPStoreDriver *)this);
        _ASSERT(SUCCEEDED(hr));
    }
    _ASSERT(m_InstLEntry.Flink == NULL);
    _ASSERT(m_InstLEntry.Blink == NULL);
    CNtfsStoreDriver::UnLockList();
}

DECLARE_STD_IUNKNOWN_METHODS(NtfsStoreDriver, IMailMsgStoreDriver)

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::AllocMessage(
            IMailMsgProperties      *pMsg,
            DWORD                   dwFlags,
            IMailMsgPropertyStream  **ppStream,
            PFIO_CONTEXT            *phContentFile,
            IMailMsgNotify          *pNotify
            )
{
    HRESULT hrRes = S_OK;
    TCHAR   szStoreFileName[MAX_PATH << 1];
    DWORD   dwLength;

    _ASSERT(pMsg);
    _ASSERT(ppStream);
    _ASSERT(phContentFile);

    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::AllocMessage");

    if (!m_fInitialized)
        return(E_FAIL);

    if (m_fIsShuttingDown)
    {
        DebugTrace((LPARAM)this, "Failing because shutting down");
        return(HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS));
    }

    if (!pMsg || !ppStream || !phContentFile)
        return(E_POINTER);

    do {

        // Get a file name
        dwLength = sizeof(szStoreFileName);
        hrRes = CDriverUtils::GetStoreFileName(
                    m_szQueueDirectory,
                    szStoreFileName,
                    &dwLength);
        if (FAILED(hrRes))
            return(hrRes);

        // Create the file
        hrRes = CDriverUtils::GetStoreFileFromPath(
                    szStoreFileName,
                    ppStream,
                    phContentFile,
                    TRUE,
                    m_fIsFAT,
                    pMsg,
                    m_guidInstance
                    );

    } while (hrRes == HRESULT_FROM_WIN32(ERROR_FILE_EXISTS));

    if (FAILED(hrRes))
        return(hrRes);

    ((CNtfsPropertyStream *)*ppStream)->SetInfo(this);

    // OK, save the file name as a store driver context
    hrRes = CDriverUtils::SetMessageContext(
                pMsg,
                (LPBYTE)szStoreFileName,
                dwLength * sizeof(TCHAR));
    if (FAILED(hrRes))
    {
        // Release all file resources
        ReleaseContext(*phContentFile);
        DecCtr(m_ppoi, NTFSDRV_MSG_BODIES_OPEN);
        _VERIFY((*ppStream)->Release() == 0);
    } else {
        // Update counters
        IncCtr(m_ppoi, NTFSDRV_QUEUE_LENGTH);
        IncCtr(m_ppoi, NTFSDRV_NUM_ALLOCS);
        IncCtr(m_ppoi, NTFSDRV_MSG_BODIES_OPEN);
    }


    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::EnumMessages(
            IMailMsgEnumMessages    **ppEnum
            )
{
    HRESULT             hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::EnumMessages");

    if (!m_fInitialized)
        return(E_FAIL);

    if (m_fIsShuttingDown)
    {
        DebugTrace((LPARAM)this, "Failing because shutting down");
        return(HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS));
    }

    if (!ppEnum)
        return E_POINTER;

    hrRes = CoCreateInstance(
                CLSID_NtfsEnumMessages,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IMailMsgEnumMessages,
                (LPVOID *)ppEnum);
    if (SUCCEEDED(hrRes))
    {
        ((CNtfsEnumMessages *)(*ppEnum))->SetInfo(this);
        hrRes = ((CNtfsEnumMessages *)(*ppEnum))->SetStoreDirectory(
                    m_szQueueDirectory,
                    m_fIsFAT);
    }
    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::ReOpen(
            IMailMsgProperties      *pMsg,
            IMailMsgPropertyStream  **ppStream,
            PFIO_CONTEXT            *phContentFile,
            IMailMsgNotify          *pNotify
            )
{
    HRESULT hrRes = S_OK;
    TCHAR   szStoreFileName[MAX_PATH * 2];
    DWORD   dwLength = MAX_PATH * 2;

    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::ReOpen");

    if (!m_fInitialized)
        return(E_FAIL);

    if (!pMsg)
        return E_POINTER;

    if (m_fIsShuttingDown)
    {
        // We allow reopen to occur when we are pending shutdown.
        // This gives a chance to reopen the streams and commit any
        // unchanged data
        DebugTrace((LPARAM)this, "ReOpening while shutting down ...");
    }

    // Now we have to load the file name from the context
    dwLength *= sizeof(TCHAR);
    hrRes = CDriverUtils::GetMessageContext(
                pMsg,
                (LPBYTE)szStoreFileName,
                &dwLength);
    if (FAILED(hrRes))
        return(hrRes);

    // Got the file name, just open the files
    hrRes = CDriverUtils::GetStoreFileFromPath(
                szStoreFileName,
                ppStream,
                phContentFile,
                FALSE,
                m_fIsFAT,
                pMsg);
    if (SUCCEEDED(hrRes) && ppStream) {
        ((CNtfsPropertyStream *)*ppStream)->SetInfo(this);
    }

    if (SUCCEEDED(hrRes)) {
        if (phContentFile) IncCtr(m_ppoi, NTFSDRV_MSG_BODIES_OPEN);
    }


    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::ReAllocMessage(
            IMailMsgProperties      *pOriginalMsg,
            IMailMsgProperties      *pNewMsg,
            IMailMsgPropertyStream  **ppStream,
            PFIO_CONTEXT            *phContentFile,
            IMailMsgNotify          *pNotify
            )
{
    HRESULT hrRes = S_OK;
    TCHAR   szStoreFileName[MAX_PATH * 2];
    DWORD   dwLength = MAX_PATH * 2;

    IMailMsgPropertyStream  *pStream;
    PFIO_CONTEXT            hContentFile;

    _ASSERT(pOriginalMsg);
    _ASSERT(pNewMsg);
    _ASSERT(ppStream);
    _ASSERT(phContentFile);

    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::ReAllocMessage");

    if (!m_fInitialized)
        return(E_FAIL);

    if (m_fIsShuttingDown)
    {
        DebugTrace((LPARAM)this, "Failing because shutting down");
        return(HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS));
    }

    // Now we have to load the file name from the context
    dwLength *= sizeof(TCHAR);
    hrRes = CDriverUtils::GetMessageContext(
                pOriginalMsg,
                (LPBYTE)szStoreFileName,
                &dwLength);
    if (FAILED(hrRes))
        return(hrRes);

    // Allocate a new message
    hrRes = AllocMessage(
                pNewMsg,
                0,
                &pStream,
                &hContentFile,
                NULL);
    if (FAILED(hrRes))
        return(hrRes);

    // Copy the content from original message to new message
    hrRes = pOriginalMsg->CopyContentToFile(
                hContentFile,
                NULL);
    if (SUCCEEDED(hrRes))
    {
        *ppStream = pStream;
        *phContentFile = hContentFile;
    }
    else
    {
        HRESULT myRes;

        // Delete on failure
        pStream->Release();
        ReleaseContext(hContentFile);
        DecCtr(m_ppoi, NTFSDRV_MSG_BODIES_OPEN);
        myRes = Delete(pNewMsg, NULL);
        _ASSERT(myRes);
    }
    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::Delete(
            IMailMsgProperties      *pMsg,
            IMailMsgNotify          *pNotify
            )
{
    HRESULT hrRes = S_OK;
    TCHAR   szStoreFileName[MAX_PATH * 2];
    TCHAR   szStoreFileNameStl[MAX_PATH * 2];
    DWORD   dwLength = MAX_PATH * 2;

    _ASSERT(pMsg);

    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::Delete");

    if (!m_fInitialized)
        return(E_FAIL);

    if (!pMsg)
        return E_POINTER;

    if (m_fIsShuttingDown)
    {
        // We would allow deletes during shutdown
        DebugTrace((LPARAM)this, "Deleteing while shutting down ...");
    }

    // Now we have to load the file name from the context
    dwLength *= sizeof(TCHAR);
    hrRes = CDriverUtils::GetMessageContext(
                pMsg,
                (LPBYTE)szStoreFileName,
                &dwLength);
    if (FAILED(hrRes))
        return(hrRes);

    // Got the file name, delete the file
    // For FAT, we know we can force delete the stream, but we are not
    // so sure about the content file. So we always try to delete the
    // content file first, if it succeeds, we delete the stream file.
    // If it fails, we will keep the stream intact so we can at least
    // use the stream to debug what's going on.
    if (!DeleteFile(szStoreFileName)) {
        DWORD cRetries = 0;
        hrRes = HRESULT_FROM_WIN32(GetLastError());
        // in hotmail we've found that delete sometimes fails with
        // a sharing violation even though we've closed all handles.
        // in this case we try again
        for (cRetries = 0; 
             hrRes == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) && cRetries < 5; 
             cRetries++)
        {
            Sleep(0);
            if (DeleteFile(szStoreFileName)) {
                hrRes = S_OK;
            } else {
                hrRes = HRESULT_FROM_WIN32(GetLastError());
            } 
        }
        _ASSERT(SUCCEEDED(hrRes));
        ErrorTrace((LPARAM) this, 
                   "DeleteFile(%s) failed with %lu, cRetries=%lu, hrRes=%x", 
                   szStoreFileName, GetLastError(), cRetries, hrRes);
    } else if (m_fIsFAT) {
        // Wiped the content, now wipe the stream
        DWORD cRetries = 0;
        lstrcpy(szStoreFileNameStl, szStoreFileName);
        lstrcat(szStoreFileName, NTFS_FAT_STREAM_FILE_EXTENSION_1ST);
        if (!DeleteFile(szStoreFileName)) {
            hrRes = HRESULT_FROM_WIN32(GetLastError());
            for (cRetries = 0; 
                 hrRes == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) && cRetries < 5; 
                 cRetries++)
            {
                Sleep(0);
                if (DeleteFile(szStoreFileName)) {
                    hrRes = S_OK;
                } else {
                    hrRes = HRESULT_FROM_WIN32(GetLastError());
                } 
            }
            _ASSERT(SUCCEEDED(hrRes));
            ErrorTrace((LPARAM) this, 
                       "DeleteFile(%s) failed with %lu, cRetries=%lu, hrRes=%x", 
                       szStoreFileName, GetLastError(), cRetries, hrRes);
        }
        lstrcat(szStoreFileNameStl, NTFS_FAT_STREAM_FILE_EXTENSION_LIVE);
        // this can fail, since we don't always have a live stream
        DeleteFile(szStoreFileNameStl);
    }

    if (SUCCEEDED(hrRes)) {
        DecCtr(m_ppoi, NTFSDRV_QUEUE_LENGTH);
        IncCtr(m_ppoi, NTFSDRV_NUM_DELETES);
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::CloseContentFile(
            IMailMsgProperties      *pMsg,
            PFIO_CONTEXT            hContentFile
            )
{
    HRESULT hrRes = S_OK;

    _ASSERT(pMsg);
    _ASSERT(hContentFile!=NULL);

    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::CloseContentFile");

    if (!m_fInitialized)
        return (E_FAIL);

    if (m_fIsShuttingDown)
    {
        // We would allow content files to be closed during shutdown
        DebugTrace((LPARAM)this, "Closing content file while shutting down ...");
    }

#ifdef DEBUG
    TCHAR szStoreFileName[MAX_PATH * 2];
    DWORD dwLength = MAX_PATH * 2;
    dwLength *= sizeof(TCHAR);
    _ASSERT(SUCCEEDED(CDriverUtils::GetMessageContext(pMsg,(LPBYTE)szStoreFileName,&dwLength)));
#endif

    ReleaseContext(hContentFile);
    DecCtr(m_ppoi, NTFSDRV_MSG_BODIES_OPEN);

    TraceFunctLeave();
    return (hrRes);
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::Init(
            DWORD dwInstance,
            IUnknown *pBinding,
            IUnknown *pServer,
            DWORD dwReason,
            IUnknown **ppStoreDriver
            )
{
    HRESULT hrRes = S_OK;
    DWORD   dwLength = sizeof(m_szQueueDirectory);
    REFIID  iidStoreDriverBinding = GUID_NULL;
    IUnknown * pTempStoreDriver = NULL;

    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::Init");

    // We will treat all dwReasons as equal ...
    //NK** : We need to treat binding change differently in order to set the correct
    //enumeration status - we do it before returning from here

    if (m_fInitialized)
        return(HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED));

    if (m_fIsShuttingDown)
        return(HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS));

    // Try to load the store directory
    DebugTrace((LPARAM)this, "Initializing instance %u", dwInstance);

    //Grab a lock for the duration of this function
    //
    CNtfsStoreDriver::LockList();
    pTempStoreDriver = CNtfsStoreDriver::LookupSinkInstance(dwInstance, iidStoreDriverBinding);

    if(pTempStoreDriver)
    {
        //Found a valid store driver
        pTempStoreDriver->AddRef();
        *ppStoreDriver = (IUnknown *)(ISMTPStoreDriver *)pTempStoreDriver;
        CNtfsStoreDriver::UnLockList();
        return S_OK;
    }

    //hrRes = CDriverUtils::LoadStoreDirectory(
        //  dwInstance,
        //  m_szQueueDirectory,
        //  &dwLength);
    //if (SUCCEEDED(hrRes))
    if (1)
    {
    //  m_fInitialized = TRUE;
        //m_fIsShuttingDown = FALSE;
        //m_dwInstance = dwInstance;
        //m_lRefCount = 0;

        DWORD BuffSize = sizeof(m_szQueueDirectory);

        // Get the SMTP server interface
        m_pSMTPServer = NULL;
        if (pServer &&
            !SUCCEEDED(pServer->QueryInterface(IID_ISMTPServer, (LPVOID *)&m_pSMTPServer)))
            m_pSMTPServer = NULL;

        // Read the metabase if we have a server, otherwise read from the registry
        if(m_pSMTPServer)
        {
            HRESULT hr1, hr2;

            hr1 = m_pSMTPServer->ReadMetabaseString(MD_MAIL_QUEUE_DIR, (unsigned char *) m_szQueueDirectory, &BuffSize, FALSE);

            BuffSize = sizeof(m_szDropDirectory);
            hr2 = m_pSMTPServer->ReadMetabaseString(MD_MAIL_DROP_DIR, (unsigned char *) m_szDropDirectory, &BuffSize, FALSE);
        }
        else
        {
            DebugTrace((LPARAM)this, "NTFSDRV Getting config from registry");
            hrRes = CDriverUtils::LoadStoreDirectory(
                                      dwInstance,
                                      m_szQueueDirectory,
                                      &dwLength);
            if (SUCCEEDED(hrRes))
            {
                // Deduce the queue and drop directories
                lstrcpy(m_szDropDirectory, m_szQueueDirectory);
                lstrcat(m_szDropDirectory, NTFS_DROP_DIRECTORY_SUFFIX);
                lstrcat(m_szQueueDirectory, NTFS_QUEUE_DIRECTORY_SUFFIX);
            }
        }

        // Detect the file system
        hrRes = CDriverUtils::IsStoreDirectoryFat(
                    m_szQueueDirectory,
                    &m_fIsFAT);

        m_fInitialized = TRUE;

        m_fIsShuttingDown = FALSE;
        m_dwInstance = dwInstance;
        m_lRefCount = 0;

        //NK** MAke binding GUID a member and start storing it

        DebugTrace((LPARAM)this, "Queue directory: %s", m_szQueueDirectory);
        DebugTrace((LPARAM)this, "Drop directory: %s", m_szDropDirectory);

        // Return a store driver only if we succeeded initialization
        if (ppStoreDriver)
        {
            *ppStoreDriver = (IUnknown *)(ISMTPStoreDriver *)this;
            AddRef();

            // if we are the first instance then initialize perfmon
            if (IsListEmpty(&sm_ListHead)) {
                InitializePerformanceStatistics();
            }

            CNtfsStoreDriver::InsertSinkInstance(&m_InstLEntry);
        }
    }

    WCHAR wszPerfInstanceName[MAX_INSTANCE_NAME];
    _snwprintf(wszPerfInstanceName, MAX_INSTANCE_NAME, L"SMTP #%u", dwInstance);
    m_ppoi = CreatePerfObjInstance(wszPerfInstanceName);

    TraceFunctLeaveEx((LPARAM)this);

    // Always return S_OK
    CNtfsStoreDriver::UnLockList();
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::PrepareForShutdown(
            DWORD dwReason
            )
{
    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::PrepareForShutdown");

    m_fIsShuttingDown = TRUE;

    TraceFunctLeaveEx((LPARAM)this);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::Shutdown(
            DWORD dwReason
            )
{
    DWORD   dwWaitTime = 0;
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::Shutdown");

    m_fIsShuttingDown = TRUE;

    _ASSERT(m_lRefCount == 0);

#if 0
    // BUG - 80960
    // Now wait for all our references to come back
    while (m_lRefCount)
    {
        _ASSERT(m_lRefCount >= 0);
        Sleep(100);
        dwWaitTime += 100;
        DebugTrace((LPARAM)this,
                "[%u ms] Waiting for objects to be released (%u outstanding)",
                dwWaitTime, m_lRefCount);
    }
#endif

    if(m_pSMTPServer)
    {
        m_pSMTPServer->Release();
        m_pSMTPServer = NULL;
    }

    if (m_ppoi) {
        delete m_ppoi;
        m_ppoi = NULL;
    }

    CNtfsStoreDriver::LockList();
    hr = CNtfsStoreDriver::RemoveSinkInstance((IUnknown *)(ISMTPStoreDriver *)this);
    // if we are the last instance then shutdown perfmon
    if (IsListEmpty(&sm_ListHead)) {
        ShutdownPerformanceStatistics();
    }
    CNtfsStoreDriver::UnLockList();
    if(FAILED(hr))
    {
        //We failed to remove this sink from the global list
        _ASSERT(0);
    }

    m_fInitialized = FALSE;
    m_fIsShuttingDown = FALSE;

    TraceFunctLeaveEx((LPARAM)this);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::LocalDelivery(
            IMailMsgProperties *pMsg,
            DWORD dwRecipCount,
            DWORD *pdwRecipIndexes,
            IMailMsgNotify *pNotify
            )
{
    HRESULT hrRes = S_OK;
    TCHAR   szStoreFileName[MAX_PATH * 2];
    TCHAR   szCopyFileName[MAX_PATH * 2];
    LPTSTR  pszFileName;
    DWORD   dwLength = MAX_PATH * 2;

    _ASSERT(pMsg);

    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::LocalDelivery");

#ifdef ENABLE_LOCAL_DELIVERY



#else

#ifdef DEBUG

    // We will not drop unless we have a non-empty drop dir specification
    if (m_szDropDirectory[0] == '\0')
        return(S_OK);

    // If it's not initialized, just return S_OK so another store driver
    // can attempt delivery
    if (!m_fInitialized)
        return (S_OK);

    if (m_fIsShuttingDown)
        return(HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS));

    // Get the file name
    dwLength *= sizeof(TCHAR);
    hrRes = CDriverUtils::GetMessageContext(pMsg,(LPBYTE)szStoreFileName,&dwLength);
    if (SUCCEEDED(hrRes))
    {
        // Scan backwards for a backslash
        pszFileName = szStoreFileName + dwLength;
        while (dwLength--)
            if (*--pszFileName == _T('\\'))
            {
                wsprintf(szCopyFileName, _T("%s%s"), m_szDropDirectory, pszFileName);

                DebugTrace((LPARAM)this,
                        "Copying file %s to %s", szStoreFileName, szCopyFileName);
                if (!CopyFile(szStoreFileName, szCopyFileName, TRUE))
                {
                    ErrorTrace((LPARAM)this, "CopyFile failed %u", GetLastError());
                    hrRes = HRESULT_FROM_WIN32(GetLastError());
                }
                else
                    hrRes = S_OK;
            }
        if (!dwLength)
        {
            _ASSERT(FALSE);
            hrRes = HRESULT_FROM_WIN32(ERROR_INVALID_BLOCK);
        }
    }

#endif

#endif

    TraceFunctLeaveEx((LPARAM)this);
    return (hrRes);
}

static void LogEventCorruptMessage(CEventLogWrapper *pEventLog,
                                   IMailMsgProperties *pMsg,
                                   char *pszQueueDirectory,
                                   HRESULT hrLog)
{
    HRESULT hr;
    char szMessageFile[MAX_PATH];
    DWORD dwLength = sizeof(szMessageFile);
    const char *rgszSubstrings[] = { szMessageFile, pszQueueDirectory };

    hr = CDriverUtils::GetMessageContext(pMsg, (LPBYTE) szMessageFile, &dwLength);
    if (FAILED(hr)) {
        strcpy(szMessageFile, "<unknown>");
    }

    pEventLog->LogEvent(NTFSDRV_INVALID_FILE_IN_QUEUE,
                        2,
                        rgszSubstrings,
                        EVENTLOG_WARNING_TYPE,
                        hrLog,
                        LOGEVENT_DEBUGLEVEL_MEDIUM,
                        szMessageFile,
                        LOGEVENT_FLAG_ALWAYS);
}

static void DeleteNeverAckdMessage(CEventLogWrapper *pEventLog,
                                   IMailMsgProperties *pMsg,
                                   char *pszQueueDirectory,
                                   HRESULT hrLog,
                                   BOOL fIsFAT)
{
    HRESULT hr;
    char szMessageFile[MAX_PATH+50];
    char szMessageFileSTL[MAX_PATH+50];
    DWORD dwLength = MAX_PATH;
    TraceFunctEnter("DeleteNeverAckdMessage");

    hr = CDriverUtils::GetMessageContext(pMsg, (LPBYTE) szMessageFile, &dwLength);
    if (FAILED(hr)) {
        _ASSERT(FALSE && "GetMessageContext failed");
        return;
    }

    DebugTrace((LPARAM) 0, "Deleting: %s\n", szMessageFile);
    DeleteFile(szMessageFile);
    if (fIsFAT) {
        // Wiped the content, now wipe the stream
        lstrcpy(szMessageFileSTL, szMessageFile);
        lstrcat(szMessageFile, NTFS_FAT_STREAM_FILE_EXTENSION_1ST);
        DeleteFile(szMessageFile);
        lstrcat(szMessageFileSTL, NTFS_FAT_STREAM_FILE_EXTENSION_LIVE);
        // this can fail, since we don't always have a live stream
        DeleteFile(szMessageFileSTL);
    }
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::EnumerateAndSubmitMessages(
            IMailMsgNotify *pNotify
            )
{
    HRESULT hrRes = S_OK;

    IMailMsgEnumMessages    *pEnum = NULL;

    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::EnumerateAndSubmitMessages");

    if (!m_fInitialized)
        return (E_FAIL);

    if (m_fIsShuttingDown)
        goto Shutdown;

    // Assert we got all the pieces ...
    if (!m_pSMTPServer) return S_FALSE;

    // Now, get an enumerator from our peer IMailMsgStoreDriver and
    // start enumerating away ...
    hrRes = EnumMessages(&pEnum);
    if (SUCCEEDED(hrRes))
    {
        IMailMsgProperties      *pMsg = NULL;
        IMailMsgPropertyStream  *pStream = NULL;
        PFIO_CONTEXT            hContentFile = NULL;

        do
        {
            // Check for shut down
            if (m_fIsShuttingDown)
                goto Shutdown;

            // Create an instance of the message object, note
            // we reuse messages from a failed attempt
            if (!pMsg)
            {
                hrRes = CoCreateInstance(
                            CLSID_MsgImp,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IMailMsgProperties,
                            (LPVOID *)&pMsg);

                // Next, check if we are over the inbound cutoff limit. If so, we will release the message
                // and not proceed.
                if (SUCCEEDED(hrRes))
                {
                    DWORD   dwCreationFlags;
                    hrRes = pMsg->GetDWORD(
                                IMMPID_MPV_MESSAGE_CREATION_FLAGS,
                                &dwCreationFlags);
                    if (FAILED(hrRes) ||
                        (dwCreationFlags & MPV_INBOUND_CUTOFF_EXCEEDED))
                    {
                        // If we fail to get this property of if the inbound cutoff
                        // exceeded flag is set, discard the message and return failure
                        if (SUCCEEDED(hrRes))
                        {
                            DebugTrace((LPARAM)this, "Failing because inbound cutoff reached");
                            hrRes = E_OUTOFMEMORY;
                        }
                        pMsg->Release();
                        pMsg = NULL;
                    }
                }

                // Now if we are out of memory, we would probably
                // keep failing, so lets just return and get on with
                // delivery
                if (!SUCCEEDED(hrRes))
                {
                    break;
                }
            }

            // Get the next message
            hrRes = pEnum->Next(
                        pMsg,
                        &pStream,
                        &hContentFile,
                        NULL);
            // Next() cleans up its own mess if it fails
            if (SUCCEEDED(hrRes))
            {
                DWORD   dwStreamSize = 0;

                IncCtr(m_ppoi, NTFSDRV_MSG_BODIES_OPEN);
                DebugTrace((LPARAM) this, "Next returned success\n");

                // We delete streams which are too short to contain
                // a master header
                hrRes = pStream->GetSize(pMsg, &dwStreamSize, NULL);
                DebugTrace((LPARAM) this, "GetSize returned %x, %x\n", dwStreamSize, hrRes);
                if (!SUCCEEDED(hrRes) || dwStreamSize < 1024)
                {
                    pStream->Release();
                    ReleaseContext(hContentFile);
                    DeleteNeverAckdMessage(g_pEventLog,
                                           pMsg,
                                           m_szQueueDirectory,
                                           hrRes,
                                           m_fIsFAT);
                    DecCtr(m_ppoi, NTFSDRV_MSG_BODIES_OPEN);
                    continue;
                }

                DebugTrace((LPARAM) this, "Submitting to mailmsg\n");
                // Submit the message, this call will actually do the
                // bind to the store driver
                if (m_fIsShuttingDown)
                    hrRes = E_FAIL;
                else
                {
                    IMailMsgBind    *pBind = NULL;

                    // Bind and submit
                    hrRes = pMsg->QueryInterface(
                                IID_IMailMsgBind,
                                (LPVOID *)&pBind);
                    if (SUCCEEDED(hrRes))
                    {
                        hrRes = pBind->BindToStore(
                                    pStream,
                                    (IMailMsgStoreDriver *)this,
                                    hContentFile);
                        pBind->Release();
                        if (SUCCEEDED(hrRes))
                        {
                            // Relinquish the extra refcount added by bind(2 -> 1)
                            pStream->Release();

                            hrRes = m_pSMTPServer->SubmitMessage(
                                        pMsg);
                            if (!SUCCEEDED(hrRes))
                            {

                                // Relinquish the usage count added by bind (1 -> 0)
                                IMailMsgQueueMgmt   *pMgmt = NULL;

                                hrRes = pMsg->QueryInterface(
                                            IID_IMailMsgQueueMgmt,
                                            (LPVOID *)&pMgmt);
                                if (SUCCEEDED(hrRes))
                                {
                                    pMgmt->ReleaseUsage();
                                    pMgmt->Release();
                                }
                                else
                                {
                                    _ASSERT(hrRes == S_OK);
                                }
                            } else {
                                // update counter
                                IncCtr(m_ppoi, NTFSDRV_QUEUE_LENGTH);
                                IncCtr(m_ppoi, NTFSDRV_NUM_ENUMERATED);
                            }
                            // Whether or not the message is submitted, release our
                            // refcount
                            pMsg->Release();
                            pMsg = NULL;
                        }
                    }
                    else
                    {
                        _ASSERT(hrRes == S_OK);
                    }
                }
                if (!SUCCEEDED(hrRes))
                {
                    // Clean up the mess ...
                    pStream->Release();
                    ReleaseContext(hContentFile);
                    DecCtr(m_ppoi, NTFSDRV_MSG_BODIES_OPEN);

                    if (m_fIsShuttingDown)
                        goto Shutdown;

                    //
                    // log an event about the message being corrupt
                    //
                    LogEventCorruptMessage(g_pEventLog,
                                           pMsg,
                                           m_szQueueDirectory,
                                           hrRes);

                    // We might want to discard this message and go on
                    // with other messages. We will re-use this message
                    // object upstream.
                    hrRes = S_OK;
                }
                else
                {
                    // Make sure we will not accidentally delete or
                    // reuse the message
                    pMsg = NULL;
                }
            }

        } while (SUCCEEDED(hrRes));

        // We distinguish the successful end of enumeration
        if (hrRes == HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES))
            hrRes = S_OK;

        // Release the enumerator, of course ...
        pEnum->Release();

        // Release any residual messages
        if (pMsg)
            pMsg->Release();
    }

    TraceFunctLeaveEx((LPARAM)this);
    return (S_OK);

Shutdown:

    // Release the enumerator, of course ...
    if(pEnum)
        pEnum->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return (HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS));
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::IsCacheable()
{
    // signal that only one instance of the sink should be created
    return (S_OK);
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::ValidateMessageContext(
                                        	BYTE *pbContext,
                                        	DWORD cbContext)
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CMailMsgEnumMessages
//

CNtfsEnumMessages::CNtfsEnumMessages()
{
    *m_szEnumPath = _T('\0');
    m_hEnum = INVALID_HANDLE_VALUE;
    m_pDriver = NULL;
    m_fIsFAT = TRUE; // Assume we are FAT until we discover otherwise
}

CNtfsEnumMessages::~CNtfsEnumMessages()
{
    *m_szEnumPath = _T('\0');
    if (m_hEnum != INVALID_HANDLE_VALUE)
    {
        if (!FindClose(m_hEnum))
        {
            _ASSERT(FALSE);
        }
        m_hEnum = INVALID_HANDLE_VALUE;
    }
    if (m_pDriver)
        m_pDriver->ReleaseUsage();
}


HRESULT CNtfsEnumMessages::SetStoreDirectory(
            LPTSTR  szStoreDirectory,
            BOOL    fIsFAT
            )
{
    if (!szStoreDirectory)
        return(E_FAIL);

    // Mark the file system
    m_fIsFAT = fIsFAT;

    if (lstrlen(szStoreDirectory) >= MAX_PATH)
    {
        _ASSERT(FALSE);
        return(E_FAIL);
    }

    lstrcpy(m_szEnumPath, szStoreDirectory);
    lstrcat(m_szEnumPath, NTFS_STORE_FILE_PREFIX);
    lstrcat(m_szEnumPath, NTFS_STORE_FILE_WILDCARD);
    lstrcat(m_szEnumPath, NTFS_STORE_FILE_EXTENSION);
    lstrcpy(m_szStorePath, szStoreDirectory);
    lstrcat(m_szStorePath, NTFS_STORE_BACKSLASH);
    return(S_OK);
}

DECLARE_STD_IUNKNOWN_METHODS(NtfsEnumMessages, IMailMsgEnumMessages)

HRESULT STDMETHODCALLTYPE CNtfsEnumMessages::Next(
            IMailMsgProperties      *pMsg,
            IMailMsgPropertyStream  **ppStream,
            PFIO_CONTEXT            *phContentFile,
            IMailMsgNotify          *pNotify
            )
{
    HRESULT hrRes = S_OK;
    TCHAR   szFQPN[MAX_PATH * 2];

    if (!pMsg || !ppStream || !phContentFile) return E_POINTER;

    BOOL fFoundFile = FALSE;
    TraceFunctEnter("CNtfsEnumMessages::Next");

    while (!fFoundFile) {
        _ASSERT(m_pDriver);
        if (m_pDriver->IsShuttingDown())
            return(HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS));

        if (m_hEnum == INVALID_HANDLE_VALUE)
        {
            m_hEnum = FindFirstFile(m_szEnumPath, &m_Data);
            if (m_hEnum == INVALID_HANDLE_VALUE)
            {
                return(HRESULT_FROM_WIN32(GetLastError()));
            }
        }
        else
        {
            if (!FindNextFile(m_hEnum, &m_Data))
            {
                return(HRESULT_FROM_WIN32(GetLastError()));
            }
        }

        // Digest the data ...
        while (m_Data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            // Make sure it's not a directory
            if (!FindNextFile(m_hEnum, &m_Data))
            {
                return(HRESULT_FROM_WIN32(GetLastError()));
            }
        }

        // OK, got a file, get the content handle and property stream
        lstrcpy(szFQPN, m_szStorePath);
        lstrcat(szFQPN, m_Data.cFileName);
        hrRes = CDriverUtils::GetStoreFileFromPath(
                    szFQPN,
                    ppStream,
                    phContentFile,
                    FALSE,
                    m_fIsFAT,
                    pMsg);
        if (hrRes == S_NO_FIRST_COMMIT) {
            DebugTrace((LPARAM) this, "Got no first commit, doing a delete\n");
            // this means that we never ACK'd the message.  silently delete it
            if (*ppStream) (*ppStream)->Release();
            ReleaseContext(*phContentFile);
            DeleteFile(szFQPN);
            if (m_fIsFAT) {
                TCHAR szFileName[MAX_PATH * 2];
                lstrcpy(szFileName, szFQPN);
                lstrcat(szFileName, NTFS_FAT_STREAM_FILE_EXTENSION_1ST);
                DeleteFile(szFileName);
                lstrcpy(szFileName, szFQPN);
                lstrcat(szFileName, NTFS_FAT_STREAM_FILE_EXTENSION_LIVE);
                DeleteFile(szFileName);
            }
        } else if (FAILED(hrRes)) {
            // couldn't open the file.  try the next one
            DebugTrace((LPARAM) this, "GetStoreFileFromPath returned %x\n", hrRes);
        } else {
            CNtfsPropertyStream *pNtfsStream =
                (CNtfsPropertyStream *) (*ppStream);

            // skip over items made with this instance of the ntfs store driver
            if (pNtfsStream->GetInstanceGuid() ==
                m_pDriver->GetInstanceGuid())
            {
                (*ppStream)->Release();
                ReleaseContext(*phContentFile);
            } else {
                fFoundFile = TRUE;
            }
        }
    }

    // We got the handles successfully opened, now write the filename
    // as the store driver context
    hrRes = CDriverUtils::SetMessageContext(
                pMsg,
                (LPBYTE)szFQPN,
                (lstrlen(szFQPN) + 1) * sizeof(TCHAR));
    if (FAILED(hrRes))
    {
        // Release all file resources
        ReleaseContext(*phContentFile);
        _VERIFY((*ppStream)->Release() == 0);
    }
    else
    {
        ((CNtfsPropertyStream *)(*ppStream))->SetInfo(m_pDriver);
    }

    return(hrRes);
}


/////////////////////////////////////////////////////////////////////////////
// CNtfsPropertyStream
//

CNtfsPropertyStream::CNtfsPropertyStream()
{
    m_hStream = INVALID_HANDLE_VALUE;
    m_pDriver = NULL;
    m_fValidation = FALSE;
    // this will make us fail writeblocks if they don't call startwriteblocks
    // first
    m_hrStartWriteBlocks = E_FAIL;
}

CNtfsPropertyStream::~CNtfsPropertyStream()
{
    if (m_hStream != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hStream);
        m_hStream = INVALID_HANDLE_VALUE;
    }
    if (m_pDriver) {
        DecCtr((m_pDriver->m_ppoi), NTFSDRV_MSG_STREAMS_OPEN);
        m_pDriver->ReleaseUsage();
    }
}

DECLARE_STD_IUNKNOWN_METHODS(NtfsPropertyStream, IMailMsgPropertyStream)

//
// IMailMsgPropertyStream
//
HRESULT STDMETHODCALLTYPE CNtfsPropertyStream::GetSize(
            IMailMsgProperties  *pMsg,
            DWORD           *pdwSize,
            IMailMsgNotify  *pNotify
            )
{
    DWORD   dwHigh, dwLow;
    DWORD   cStreamOffset = m_fStreamHasHeader ? STREAM_OFFSET : 0;

    _ASSERT(m_pDriver || m_fValidation);
    if (!m_fValidation && (!m_pDriver || m_pDriver->IsShuttingDown()))
        return(HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS));

    if (m_hStream == INVALID_HANDLE_VALUE)
        return(E_FAIL);

    if (!pdwSize) return E_POINTER;

    dwLow = GetFileSize(m_hStream, &dwHigh);
    if (dwHigh)
        return(HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW));

    *pdwSize = dwLow - cStreamOffset;
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CNtfsPropertyStream::ReadBlocks(
            IMailMsgProperties  *pMsg,
            DWORD               dwCount,
            DWORD               *pdwOffset,
            DWORD               *pdwLength,
            BYTE                **ppbBlock,
            IMailMsgNotify      *pNotify
            )
{
    DWORD   dwSizeRead;
    DWORD   dwStreamSize;
    DWORD   dwOffsetToRead;
    DWORD   dwLengthToRead;
    HRESULT hrRes = S_OK;
    DWORD   cStreamOffset = m_fStreamHasHeader ? STREAM_OFFSET : 0;

    TraceFunctEnterEx((LPARAM)this, "CNtfsPropertyStream::ReadBlocks");

    if (m_hStream == INVALID_HANDLE_VALUE)
        return(E_FAIL);

    if (!pdwOffset || !pdwLength || !ppbBlock) {
        return E_POINTER;
    }

    if (!m_pDriver && !m_fValidation) {
        return E_UNEXPECTED;
    }

    _ASSERT(m_pDriver || m_fValidation);
    if (m_pDriver && m_pDriver->IsShuttingDown())
    {
        DebugTrace((LPARAM)this, "Reading while shutting down ...");
    }

    // Need to get the file size to determine if there is enough bytes
    // to read for each block. Note that WriteBlocks are to be serialzed so
    // ReadBlocks and WriteBlocks should not be overlapped.
    dwStreamSize = GetFileSize(m_hStream, NULL);
    if (dwStreamSize == 0xffffffff)
    {
        hrRes = HRESULT_FROM_WIN32(GetLastError());
        if (hrRes == S_OK)
            hrRes = STG_E_READFAULT;
        ErrorTrace((LPARAM)this, "Failed to get size of stream (%08x)", hrRes);
        return(hrRes);
    }

    for (DWORD i = 0; i < dwCount; i++, pdwOffset++, pdwLength++, ppbBlock++)
    {
        // For each block, check beforehand that we are not reading past
        // the end of the file. Make sure to be weary about overflow cases
        dwOffsetToRead = (*pdwOffset) + cStreamOffset;
        dwLengthToRead = *pdwLength;
        if ((dwOffsetToRead > dwStreamSize) ||
            (dwOffsetToRead > (dwOffsetToRead + dwLengthToRead)) ||
            ((dwOffsetToRead + dwLengthToRead) > dwStreamSize))
        {
            // Insufficient bytes, abort immediately
            ErrorTrace((LPARAM)this, "Insufficient bytes: Read(%u, %u); Size = %u",
                        dwOffsetToRead, dwLengthToRead, dwStreamSize);
            hrRes = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
            break;
        }

        if (SetFilePointer(
                    m_hStream,
                    dwOffsetToRead,
                    NULL,
                    FILE_BEGIN) == 0xffffffff)
        {
            hrRes = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        if (!ReadFile(
                    m_hStream,
                    *ppbBlock,
                    dwLengthToRead,
                    &dwSizeRead,
                    NULL))
        {
            hrRes = HRESULT_FROM_WIN32(GetLastError());
            break;
        }
        else if (dwSizeRead != dwLengthToRead)
        {
            hrRes = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
            break;
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

HRESULT CNtfsPropertyStream::SetHandle(HANDLE			   hStream,
				                       GUID			       guidInstance,
                                       BOOL                fLiveStream,
                                       IMailMsgProperties  *pMsg)
{
    TraceFunctEnter("CNtfsPropertyStream::SetHandle");

    if (hStream == INVALID_HANDLE_VALUE) return(E_FAIL);
    m_hStream = hStream;
    DWORD dw;
    NTFS_STREAM_HEADER header;

    //
    // if guidInstance is non-NULL then we are dealing with a fresh
    // stream and need to write the header block
    //
    if (guidInstance != GUID_NULL) {
        DebugTrace((LPARAM) this, "writing NTFSDRV header");
        header.dwSignature = STREAM_SIGNATURE_PRECOMMIT;
        header.dwVersion = 1;
        header.guidInstance = guidInstance;
        if (!WriteFile(m_hStream, &header, sizeof(header), &dw, NULL)) {
            return HRESULT_FROM_WIN32(GetLastError());
        }
        m_fStreamHasHeader = TRUE;
        m_guidInstance = guidInstance;
        m_cCommits = 0;
    } else {
        DebugTrace((LPARAM) this, "reading NTFSDRV header, fLiveStream = %lu", fLiveStream);

        // if we are working with :PROPERTIES then we want to set the
        // commit count to 1 so that the next set of writes will go to
        // :PROPERTIES-LIVE
        m_cCommits = (fLiveStream) ? 2 : 1;

        // read the header.  if we can't read it, or there aren't enough
        // bytes to read it, then assume that the header wasn't fully
        // written out.
        if (!ReadFile(m_hStream, &header, sizeof(header), &dw, NULL) ||
            dw != sizeof(header))
        {
            header.dwSignature = STREAM_SIGNATURE_PRECOMMIT;
        }

        // act according to what we find in the signature
        switch (header.dwSignature) {
            case STREAM_SIGNATURE: {
                DebugTrace((LPARAM) this, "signature is valid");
                // the signature (and thus the stream) is valid
                m_fStreamHasHeader = TRUE;
                m_guidInstance = header.guidInstance;
                break;
            }
            case STREAM_SIGNATURE_PRECOMMIT: {
                DebugTrace((LPARAM) this, "signature is STREAM_SIGNATURE_PRECOMMIT");
                // a commit was never completed
                return S_NO_FIRST_COMMIT;
                break;
            }
            case STREAM_SIGNATURE_INVALID: {
                DebugTrace((LPARAM) this, "signature is STREAM_SIGNATURE_INVALID");
                // the valid-stream signature was never written
                IMailMsgValidate *pValidate = NULL;
                HRESULT hr;

                // assume that the stream is valid, and go through a full
                // check
                m_fStreamHasHeader = TRUE;
                m_guidInstance = header.guidInstance;

                // this flag allows the read stream operations to take place
                // before the stream is fully setup
                m_fValidation = TRUE;

                // validate stream can only be trusted on the first
                // property stream.  this is because it can detect
                // truncated streams, but not streams with corrupted
                // properties.  the first stream (:PROPERTIES) can be
                // truncated, but not corrupted.
                //
                // if we see the invalid signature on a :PROPERTIES-LIVE
                // stream then we will always assume that it is corrupted
                // and fall back to the initial stream.
                //
                // call into mailmsg to see if the stream is valid.  if
                // it isn't then we won't allow it to be loaded
                DebugTrace((LPARAM) this, "Calling ValidateStream\n");
                if (fLiveStream ||
                    FAILED(pMsg->QueryInterface(IID_IMailMsgValidate,
                                                (void **) &pValidate)) ||
                    FAILED(pValidate->ValidateStream(this)))
                {
                    DebugTrace((LPARAM) this, "Stream contains invalid data");
                    m_fStreamHasHeader = FALSE;
                    m_guidInstance = GUID_NULL;
                    if (pValidate) pValidate->Release();
                    return S_INVALIDSTREAM;
                }

                // we are done with the validation routines
                if (pValidate) pValidate->Release();
                m_fValidation = FALSE;

                DebugTrace((LPARAM) this, "Stream contains valid data");
                break;
            }
            default: {
                // if it is anything else then it could be a file with
                // no header (older builds generated these) or it could be
                // invalid data.  mailmsg will figure it out.
                m_fStreamHasHeader = FALSE;
                m_guidInstance = GUID_NULL;

                DebugTrace((LPARAM) this, "Unknown signature %x on stream",
                    header.dwSignature);
            }
        }
    }

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CNtfsPropertyStream::StartWriteBlocks(
            IMailMsgProperties  *pMsg,
            DWORD               cBlocksToWrite,
            DWORD               cBytesToWrite)
{
    TraceFunctEnter("CNtfsPropertyStream::StartWriteBlocks");

    NTFS_STREAM_HEADER header;
    DWORD dw;
    m_hrStartWriteBlocks = S_OK;

    // if we have seen one full commit, then fork the stream and start
    // writing to the live stream
    if (m_cCommits == 1) {
        char szLiveStreamFilename[MAX_PATH * 2];
        BOOL fIsFAT = m_pDriver->IsFAT();
        char szFatLiveStreamExtension[] = NTFS_FAT_STREAM_FILE_EXTENSION_LIVE;
        char szNtfsLiveStreamExtension[] = NTFS_STORE_FILE_PROPERTY_STREAM_LIVE;
        const DWORD cCopySize = 64 * 1024;

        // get the filename of the message from the mailmsg object
        //
        // we need to save space in szLiveStreamFilename for the largest
        // extension that we might tack on
        DWORD dwLength = sizeof(char) * ((MAX_PATH * 2) -
                    max(sizeof(szNtfsLiveStreamExtension),
                        sizeof(szFatLiveStreamExtension)));
        m_hrStartWriteBlocks = CDriverUtils::GetMessageContext(pMsg,
                                             (LPBYTE) szLiveStreamFilename,
                                             &dwLength);
        if (FAILED(m_hrStartWriteBlocks)) {
            ErrorTrace((LPARAM) this,
                       "GetMessageContext failed with %x",
                       m_hrStartWriteBlocks);
            TraceFunctLeave();
            return m_hrStartWriteBlocks;
        }

        // allocate memory up front that will be used for copying the
        // streams
        BYTE *lpb = new BYTE[cCopySize];
        if (lpb == NULL) {
            m_hrStartWriteBlocks = E_OUTOFMEMORY;
            ErrorTrace((LPARAM) this, "pvMalloc failed to allocate 64k");
            TraceFunctLeave();
            return m_hrStartWriteBlocks;
        }

        // we know that we have enough space for the strcats because
        // we saved space for it in the GetMessageContext call above
        strcat(szLiveStreamFilename,
            (m_pDriver->IsFAT()) ? szFatLiveStreamExtension :
                                   szNtfsLiveStreamExtension);

        // open the new stream
        HANDLE hLiveStream = CreateFile(szLiveStreamFilename,
                                        GENERIC_READ | GENERIC_WRITE,
                                        FILE_SHARE_READ,
                                        NULL,
                                        CREATE_ALWAYS,
                                        FILE_FLAG_SEQUENTIAL_SCAN,
                                        NULL);
        if (hLiveStream == INVALID_HANDLE_VALUE) {
            delete[] (lpb);
            ErrorTrace((LPARAM) this,
                "CreateFile(%s) failed with %lu",
                szLiveStreamFilename,
                GetLastError());
            m_hrStartWriteBlocks = HRESULT_FROM_WIN32(GetLastError());
            TraceFunctLeave();
            return m_hrStartWriteBlocks;
        }

        // copy the data between the two streams
        BOOL fCopyFailed = FALSE;
        DWORD i = 0, cRead = cCopySize, cWritten;
        SetFilePointer(m_hStream, 0, NULL, FILE_BEGIN);
        while (!fCopyFailed && cRead == cCopySize) {
            if (ReadFile(m_hStream,
                         lpb,
                         cCopySize,
                         &cRead,
                         NULL))
            {
                // if this is the first block then we will touch the
                // signature to mark it as invalid.  it will get
                // rewritten as valid once this commit is complete
                if (i == 0) {
                    DWORD *pdwSignature = (DWORD *) lpb;
                    if (*pdwSignature == STREAM_SIGNATURE) {
                        *pdwSignature = STREAM_SIGNATURE_PRECOMMIT;
                    }
                }
                if (WriteFile(hLiveStream,
                              lpb,
                              cRead,
                              &cWritten,
                              NULL))
                {
                    _ASSERT(cWritten == cRead);
                    fCopyFailed = (cWritten != cRead);
                    if (fCopyFailed) {
                        SetLastError(ERROR_WRITE_FAULT);
                        ErrorTrace((LPARAM) this,
                            "WriteFile didn't write enough bytes"
                            "cWritten = %lu, cRead = %lu",
                            cWritten, cRead);
                    }
                } else {
                    fCopyFailed = TRUE;
                    ErrorTrace((LPARAM) this, "WriteFile failed with %lu",
                        GetLastError());
                }
            } else {
                ErrorTrace((LPARAM) this, "ReadFile failed with %lu",
                    GetLastError());
                fCopyFailed = TRUE;
            }
            i++;
        }

        delete[] (lpb);

        if (fCopyFailed) {
            // there isn't any way to delete the incomplete stream here.
            // however we gave it an invalid signature above, so it won't
            // be loaded during enumeration
            CloseHandle(hLiveStream);

            m_hrStartWriteBlocks = HRESULT_FROM_WIN32(GetLastError());
            TraceFunctLeave();
            return m_hrStartWriteBlocks;
        }

        // close the handle to the current stream and point the stream handle
        // to the new one
        CloseHandle(m_hStream);
        m_hStream = hLiveStream;
    } else {
	    header.dwSignature = STREAM_SIGNATURE_INVALID;
        if (m_fStreamHasHeader) {
            if (SetFilePointer(m_hStream, 0, NULL, FILE_BEGIN) == 0) {
                if (!WriteFile(m_hStream, &header, sizeof(header.dwSignature), &dw, NULL)) {
                    m_hrStartWriteBlocks = HRESULT_FROM_WIN32(GetLastError());
                }
            } else {
                m_hrStartWriteBlocks = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }
    TraceFunctLeave();
    return m_hrStartWriteBlocks;
}

HRESULT STDMETHODCALLTYPE CNtfsPropertyStream::EndWriteBlocks(
            IMailMsgProperties  *pMsg)
{
    HRESULT hr = S_OK;
    DWORD dw;
    NTFS_STREAM_HEADER header;

    _ASSERT(SUCCEEDED(m_hrStartWriteBlocks));
    if (FAILED(m_hrStartWriteBlocks)) {
        return m_hrStartWriteBlocks;
    }

	header.dwSignature = STREAM_SIGNATURE;
    if (m_fStreamHasHeader) {
        if (SetFilePointer(m_hStream, 0, NULL, FILE_BEGIN) == 0) {
            if (!WriteFile(m_hStream, &header, sizeof(header.dwSignature), &dw, NULL)) {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        } else {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    if (hr == S_OK) m_cCommits++;
    return hr;
}

HRESULT STDMETHODCALLTYPE CNtfsPropertyStream::CancelWriteBlocks(
            IMailMsgProperties  *pMsg)
{
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CNtfsPropertyStream::WriteBlocks(
            IMailMsgProperties  *pMsg,
            DWORD               dwCount,
            DWORD               *pdwOffset,
            DWORD               *pdwLength,
            BYTE                **ppbBlock,
            IMailMsgNotify      *pNotify
            )
{
    DWORD   dwSizeWritten;
    HRESULT hrRes = S_OK;
    DWORD   cStreamOffset = m_fStreamHasHeader ? STREAM_OFFSET : 0;

    TraceFunctEnterEx((LPARAM)this, "CNtfsPropertyStream::WriteBlocks");

    if (!pdwOffset || !pdwLength || !ppbBlock) {
        return E_POINTER;
    }

    if (!m_pDriver) {
        return E_UNEXPECTED;
    }

    _ASSERT(m_pDriver);
    if (m_pDriver->IsShuttingDown())
    {
        DebugTrace((LPARAM)this, "Writing while shutting down ...");
    }

    if (m_hStream == INVALID_HANDLE_VALUE)
        return(E_FAIL);

    if (FAILED(m_hrStartWriteBlocks))
        return m_hrStartWriteBlocks;

    for (DWORD i = 0; i < dwCount; i++, pdwOffset++, pdwLength++, ppbBlock++)
    {
        if (SetFilePointer(
                    m_hStream,
                    (*pdwOffset) + cStreamOffset,
                    NULL,
                    FILE_BEGIN) == 0xffffffff)
        {
            hrRes = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        if (!WriteFile(
                    m_hStream,
                    *ppbBlock,
                    *pdwLength,
                    &dwSizeWritten,
                    NULL) ||
            (dwSizeWritten != *pdwLength))
        {
            hrRes = HRESULT_FROM_WIN32(GetLastError());
            break;
        }
    }

    if (SUCCEEDED(hrRes))
    {
        if (!FlushFileBuffers(m_hStream))
            hrRes = HRESULT_FROM_WIN32(GetLastError());
    }
    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\storedrv\dllmain.cpp ===
// dllmain.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f imsgps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"

#include "filehc.h"
#include "mailmsg.h"

#include "seo.h"

#include "ntfs.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_NtfsStoreDriver, CNtfsStoreDriver)
    OBJECT_ENTRY(CLSID_NtfsEnumMessages, CNtfsEnumMessages)
    OBJECT_ENTRY(CLSID_NtfsPropertyStream, CNtfsPropertyStream)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TrHeapCreate();
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);

        //Initialize the critical section used to control access to the
        //global ntfsstore driver instance list
        InitializeCriticalSection(&CNtfsStoreDriver::sm_csLockInstList);
        
        //Init the head of the list
        InitializeListHead(&CNtfsStoreDriver::sm_ListHead);

        // initialize eventlogging
        CNtfsStoreDriver::g_pEventLog = new CEventLogWrapper();
        if (CNtfsStoreDriver::g_pEventLog)
            CNtfsStoreDriver::g_pEventLog->Initialize("smtpsvc");
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();

        if (CNtfsStoreDriver::g_pEventLog)
        {
            delete CNtfsStoreDriver::g_pEventLog;
            CNtfsStoreDriver::g_pEventLog = NULL;
        }

        TrHeapDestroy();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\storedrv\makefile.inc ===
$(O)\seo.h $(O)\seo_i.c : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(O)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

!ifndef INETAMSG_MC_PATH
INETAMSG_MC_PATH=..\..\..\inc
!endif
$(O)\smtpmsg.h $(O)\smtpmsg.rc $(O)\msg00001.bin: ..\server\smtpmsg.mc $(STAXINC)\export\phatqmsg.mc $(INETAMSG_MC_PATH)\inetamsg.mc
    copy /a $(INETAMSG_MC_PATH)\inetamsg.mc + /a ..\server\smtpmsg.mc + /a $(STAXINC)\export\phatqmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\smtpmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\smtpmsg.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\webhlpr\webhlpr.h ===
#ifndef _WEBHELP_INCLUDED_
#define _WEBHELP_INCLUDED_

HRESULT
EnumerateTrustedDomains (
    LPCWSTR     wszComputer,
    LPWSTR *    pmszDomains
    );

HRESULT
GetPrimaryDomain (
    LPCWSTR     wszComputer,
    LPWSTR *    pwszPrimaryDomain
    );

HRESULT
CheckNTAccount (
    LPCWSTR     wszComputer,
    LPCWSTR     wszUsername,
    BOOL *      pfExists
    );

HRESULT
CreateNTAccount (
    LPCWSTR     wszComputer,
    LPCWSTR     wszDomain,
    LPCWSTR     wszUsername,
    LPCWSTR     wszPassword
    );

BOOL
IsValidEmailAddress (
    LPCWSTR     wszEmailAddress
    );

void
StringToUpper (
    LPWSTR      wsz
    );

#if 0

HRESULT
DeleteMailbox (
    LPCWSTR     wszServer,
    LPCWSTR     wszAlias,
    LPCWSTR     wszVirtualDirectoryPath,
    LPCWSTR     wszUsername,    // OPTIONAL
    LPCWSTR     wszPassword     // OPTIONAL
    );

#endif

#endif // _WEBHELP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\storedrv\perf.cpp ===
/*==========================================================================*\

    Module:        perf.cpp

    Copyright Microsoft Corporation 1998, All Rights Reserved.

    Author:        AWetmore

    Descriptions:  Perf Object Definitions.
    
\*==========================================================================*/

#include "stdafx.h"
#include "perf.h"

//////////////////////////////////////////////////////////////////////////////
//
// Perf object definitions.
//
//////////////////////////////////////////////////////////////////////////////
PerfLibrary          * g_cplNtfsDrv  = NULL;
PerfObjectDefinition * g_cpodNtfsDrv = NULL;


//////////////////////////////////////////////////////////////////////////////
//
// Global flag for updating perf counters.
//
//////////////////////////////////////////////////////////////////////////////
BOOL  g_fPerfCounters  = FALSE;
DWORD g_dwPerfInterval = DEFAULT_PERF_UPDATE_INTERVAL;


//$--InitializePerformanceStatistics-------------------------------------------
//
// This function initializes the perf counters defined above. It also checks
//  the registry to see if we want to monitor the perf counters.
//
//-----------------------------------------------------------------------------
BOOL InitializePerformanceStatistics ()
{
    HKEY  hKey   = NULL;
    LONG  status = 0;
    DWORD size   = MAX_PATH;
    DWORD type   = REG_DWORD;
    DWORD fPerf  = 0;
    DWORD msec   = 0;

    //
    // Check the registry to see if we want to monitor the perf counters.
    //
    status = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                           "SYSTEM\\CurrentControlSet\\Services\\NtfsDrv\\Performance",
                           0L,
                           KEY_ALL_ACCESS,
                           &hKey);

    if (status != ERROR_SUCCESS)
        goto Exit;

#if 0
    status = RegQueryValueEx (hKey, 
                              "EnablePerfCounters",
                              NULL,
                              &type,
                              (LPBYTE)&fPerf,
                              &size);

    if (status != ERROR_SUCCESS || 0 == fPerf)
        goto Exit;

    //
    // Check the desired update period.
    //
    type = REG_DWORD;
    status = RegQueryValueEx (hKey,
                              "UpdateInterval",
                              NULL,
                              &type,
                              (LPBYTE)&msec,
                              &size);
    
    if (status == ERROR_SUCCESS)
    {
        // make sure 0 < msec <= 0x7FFFFFFF
        if (msec > 0 && !(msec & 0x80000000) && type == REG_DWORD)
            g_dwPerfInterval = msec;
    }
#endif

    //
    // Initialize the perf counters.
    //
    g_cplNtfsDrv = new PerfLibrary (L"NTFSDrv");
    if (!g_cplNtfsDrv)
        goto Exit;

    g_cpodNtfsDrv = g_cplNtfsDrv->AddPerfObjectDefinition (L"NTFSDRV_OBJ", OBJECT_NTFSDRV, TRUE);
    if (!g_cpodNtfsDrv)
        goto Exit;

    if (!g_cpodNtfsDrv->AddPerfCounterDefinition(NTFSDRV_QUEUE_LENGTH,         PERF_COUNTER_RAWCOUNT) ||
        !g_cpodNtfsDrv->AddPerfCounterDefinition(NTFSDRV_NUM_ALLOCS,           PERF_COUNTER_RAWCOUNT) ||
        !g_cpodNtfsDrv->AddPerfCounterDefinition(NTFSDRV_NUM_DELETES,          PERF_COUNTER_RAWCOUNT) ||
        !g_cpodNtfsDrv->AddPerfCounterDefinition(NTFSDRV_NUM_ENUMERATED,       PERF_COUNTER_RAWCOUNT) ||
        !g_cpodNtfsDrv->AddPerfCounterDefinition(NTFSDRV_MSG_BODIES_OPEN,  PERF_COUNTER_RAWCOUNT) ||
        !g_cpodNtfsDrv->AddPerfCounterDefinition(NTFSDRV_MSG_STREAMS_OPEN, PERF_COUNTER_RAWCOUNT))
    {
        goto Exit;
    }

    g_fPerfCounters = g_cplNtfsDrv->Init();

Exit:
    if (hKey)
        CloseHandle (hKey);

    if (!g_fPerfCounters && g_cplNtfsDrv)
    {
        delete g_cplNtfsDrv;
        g_cplNtfsDrv  = NULL;
        g_cpodNtfsDrv = NULL;
    }

    return g_fPerfCounters;
}


//$--ShutdownPerformanceStatistics--------------------------------------------
//
// This function shuts down the perf objects.
//
//-----------------------------------------------------------------------------
void ShutdownPerformanceStatistics ()
{
    if (g_cplNtfsDrv)
    {
        delete g_cplNtfsDrv;
        g_cplNtfsDrv  = NULL;
        g_cpodNtfsDrv = NULL;
    }
}

//$--CreatePerfObjInstance-----------------------------------------------------
//
// This function relays the creation of perf object instance to the global
//  perf object definition.
//
//-----------------------------------------------------------------------------
PerfObjectInstance * CreatePerfObjInstance (LPCWSTR pwstrInstanceName)
{
    PerfObjectInstance * ppoi = NULL;

    if (g_cpodNtfsDrv)
        ppoi = g_cpodNtfsDrv->AddPerfObjectInstance (pwstrInstanceName);

    return ppoi;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\storedrv\perf.h ===
/*==========================================================================*\

    Module:        perf.h

    Copyright Microsoft Corporation 1998, All Rights Reserved.

    Author:        WayneC, MinYang

    Descriptions:  Interface functions accessing perf object instances.

    Modified:      Awetmore - for NTFSDRV usage
    
\*==========================================================================*/


#ifndef __PERF_H__
#define __PERF_H__

#include "snprflib.h"
#include "ntfsdrct.h"

#define DEFAULT_PERF_UPDATE_INTERVAL  1000    // milliseconds

#define IncCtr(ppoi,x)   { LPDWORD pDword; if (ppoi) { pDword = ppoi->GetDwordCounter(x); if (pDword) InterlockedIncrement((PLONG)pDword); }}
#define DecCtr(ppoi,x)   { LPDWORD pDword; if (ppoi) { pDword = ppoi->GetDwordCounter(x); if (pDword) InterlockedDecrement((PLONG)pDword); }}
#define AddCtr(ppoi,x,y) { LPDWORD pDword; if (ppoi) { pDword = ppoi->GetDwordCounter(x); if (pDword) InterlockedExchangeAdd((PLONG)pDword, (LONG)y); }}
#define SetCtr(ppoi,x,y) { LPDWORD pDword; if (ppoi) { pDword = ppoi->GetDwordCounter(x); if (pDword) (*pDword)=y; } }

BOOL InitializePerformanceStatistics ();
void ShutdownPerformanceStatistics ();

PerfObjectInstance * CreatePerfObjInstance (LPCWSTR pwstrInstanceName);

extern BOOL  g_fPerfCounters;

#endif // __PERF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\storedrv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ntfsdrv.rc
//
#define IDS_PROJNAME                    100
#define IDR_NTFSDRV                     101
#define IDR_NTFSSTM                     102
#define IDR_NTFSENUM                    103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\storedrv\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__2DB263A4_499F_11D1_B78F_0080C731C893__INCLUDED_)
#define AFX_STDAFX_H__2DB263A4_499F_11D1_B78F_0080C731C893__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#ifdef _ASSERT
#undef _ASSERT
#endif //_ASSERT
#include <transmem.h>
#include <dbgtrace.h>

#endif // !defined(AFX_STDAFX_H__2DB263A4_499F_11D1_B78F_0080C731C893__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\admerr.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	AdmErr.cpp

Abstract:

	Common Error handling routines

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "admerr.h"

//$-------------------------------------------------------------------
//
//	Win32ErrorToString
//
//	Description:
//
//		Translates a Win32 error code to a localized string.
//
//	Parameters:
//
//		dwError		- The error code
//		wszError	- The allocated error 
//
//	Returns:
//
//		
//
//--------------------------------------------------------------------

void Win32ErrorToString ( DWORD dwError, WCHAR * wszError, DWORD cchMax )
{
	TraceFunctEnter ( "Win32ErrorToString" );

	_ASSERT ( !IsBadWritePtr ( wszError, cchMax / sizeof(WCHAR) ) );

	HRESULT		hr 				= NOERROR;
	DWORD		dwFormatFlags;

	//----------------------------------------------------------------
	//
	//	Map error codes here:
	//

	//
	//----------------------------------------------------------------

	dwFormatFlags = FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS;

	if ( !FormatMessage ( dwFormatFlags, NULL, dwError, 0,      // Lang ID - Should be nonzero?
			wszError, cchMax - 1, NULL ) ) {

		// Didn't work, so put in a default message:

		WCHAR   wszFormat [ 256 ];

		wszFormat[0] = L'\0';
		if ( !LoadStringW ( _Module.GetResourceInstance (), IDS_UNKNOWN_ERROR, wszFormat, 256 ) ||
			!*wszFormat ) {

            _ASSERT ( FALSE );  // Define IDS_UNKNOWN_ERROR in your .rc file!
			wcscpy ( wszFormat, L"Unknown Error (%1!d!)" );
		}

		FormatMessage (
			FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
			wszFormat, 
			IDS_UNKNOWN_ERROR, 
			0, 
			wszError, 
			cchMax - 1,
			(va_list *) &dwError
			);
	}
	//
	// We need to strip out any " from the string, because
	// Javascript will barf.
	//

	LPWSTR  pch;

	for ( pch = wszError; *pch; pch++ ) {

		if ( *pch == L'\"' ) {
			*pch = L'\'';
		}
	}

	//
	// Strip off any trailing control characters.
	//
	for (pch = &wszError[wcslen(wszError) - 1];
		pch >= wszError && iswcntrl(*pch);
		pch --) {

		*pch = 0;
	}

	TraceFunctLeave ();
}

//$-------------------------------------------------------------------
//
//	CreateException
//
//	Description:
//
//		Creates an OLE Error object and return DISP_E_EXCEPTION
//
//	Parameters:
//
//		hInstance		- The instance of the dll.
//		riid			- Which interface caused the exception.
//		wszHelpFile		- file to get user help.
//		dwHelpContext	- Context to get user help.
//		wszSourceProgId	- ProgID of the class which caused the exception.
//		nDescriptionId	- resource ID of the error string.
//
//	Returns:
//
//		E_FAIL	- Couldn't create the exception.
//		DISP_E_EXCEPTION	- Successfully created the exception.
//				return this value to IDispatch::Invoke.
//
//--------------------------------------------------------------------

HRESULT CreateException ( 
	HINSTANCE	hInstance,
	REFIID 		riid, 
	LPCWSTR		wszHelpFile,
	DWORD		dwHelpContext,
	LPCWSTR		wszSourceProgId,
	int			nDescriptionId
	)
{
	WCHAR						wszDescription[ MAX_DESCRIPTION_LENGTH + 1 ];

	wcscpy ( wszDescription, _T("Unknown Exception") );

	_VERIFY ( ::LoadString ( hInstance, nDescriptionId, wszDescription, MAX_DESCRIPTION_LENGTH ) );

	return CreateException (
		hInstance,
		riid,
		wszHelpFile,
		dwHelpContext,
		wszSourceProgId,
		wszDescription
		);
}

//$-------------------------------------------------------------------
//
//	CreateException
//
//	Description:
//
//		Creates an OLE Error object and return DISP_E_EXCEPTION
//
//	Parameters:
//
//		hInstance		- The instance of the dll.
//		riid			- Which interface caused the exception.
//		wszHelpFile		- file to get user help.
//		dwHelpContext	- Context to get user help.
//		wszSourceProgId	- ProgID of the class which caused the exception.
//		wszDescription	- The error string to display to the user.
//
//	Returns:
//
//		E_FAIL	- Couldn't create the exception.
//		DISP_E_EXCEPTION	- Successfully created the exception.
//				return this value to IDispatch::Invoke.
//
//--------------------------------------------------------------------

HRESULT CreateException ( 
	HINSTANCE	hInstance,
	REFIID 		riid, 
	LPCWSTR		wszHelpFile,
	DWORD		dwHelpContext,
	LPCWSTR		wszSourceProgId,
	LPCWSTR		wszDescription
	)
{
	TraceFunctEnter ( "CreateException" );

	CComPtr <ICreateErrorInfo>	pICreateErr;
	CComPtr <IErrorInfo>		pIErr;
    CComPtr <IErrorInfo>        pOldError;
	HRESULT						hr	= NOERROR;

    if ( S_OK == GetErrorInfo ( NULL, &pOldError ) ) {
        // Don't overwrite the existing error info:
		SetErrorInfo ( 0, pOldError );
        hr = DISP_E_EXCEPTION;
        goto Exit;
    }

	hr = CreateErrorInfo (&pICreateErr);

	if ( FAILED (hr) ) {
		FatalTrace ( 0, "CreateErrorInfo failed", hr );
		goto Exit;
	}

	pICreateErr->SetGUID		( riid );
	pICreateErr->SetHelpFile	( const_cast <LPWSTR> (wszHelpFile) );
	pICreateErr->SetHelpContext	( dwHelpContext );
	pICreateErr->SetSource		( const_cast <LPWSTR> (wszSourceProgId) );
	pICreateErr->SetDescription	( (LPWSTR) wszDescription );

	hr = pICreateErr->QueryInterface (IID_IErrorInfo, (void **) &pIErr);

	if ( FAILED(hr) ) {
		DebugTraceX ( 0, "QI(CreateError) failed %x", hr );
		FatalTrace ( 0, "Can't create exception" );
		hr = E_FAIL;
		goto Exit;
	}

	SetErrorInfo ( 0, pIErr );
	hr = DISP_E_EXCEPTION;

Exit:
	TraceFunctLeave ();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\admerr.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	admerr.h

Abstract:

	Common error handling operations:

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _ADMERR_INCLUDED_
#define _ADMERR_INCLUDED_

//
//	Win32 => Localized string
//

//  ! You must define this in your .rc file !
#define IDS_UNKNOWN_ERROR                                       500

void Win32ErrorToString ( DWORD dwError, WCHAR * wszError, DWORD cchMax );

//
// Creation of Error Objects:
//

const int MAX_DESCRIPTION_LENGTH = 1000;

HRESULT CreateException ( 
	HINSTANCE	hInstance, 
	REFIID 		riid,
	LPCWSTR		wszHelpFile,
	DWORD		dwHelpContext,
	LPCWSTR		wszSourceProgId,
	LPCWSTR		wszDescription
	);

HRESULT CreateException ( 
	HINSTANCE	hInstance, 
	REFIID 		riid,
	LPCWSTR		wszHelpFile,
	DWORD		dwHelpContext,
	LPCWSTR		wszSourceProgId,
	int			nDescriptionId
	);

inline HRESULT	CreateExceptionFromWin32Error (
	HINSTANCE	hInstance,
	REFIID		riid,
	LPCWSTR		wszHelpFile,
	DWORD		dwHelpContext,
	LPCWSTR		wszSourceProgId,
	DWORD		dwErrorCode
	);

inline HRESULT	CreateExceptionFromHresult (
	HINSTANCE	hInstance,
	REFIID		riid,
	LPCWSTR		wszHelpFile,
	DWORD		dwHelpContext,
	LPCWSTR		wszSourceProgId,
	HRESULT		hr
	);

//--------------------------------------------------------------------
//
//	Inlined functions:
//
//--------------------------------------------------------------------

inline HRESULT	CreateExceptionFromWin32Error (
	HINSTANCE	hInstance,
	REFIID		riid,
	LPCWSTR		wszHelpFile,
	DWORD		dwHelpContext,
	LPCWSTR		wszSourceProgId,
	DWORD		dwErrorCode
	)
{
	WCHAR	wszException [ MAX_DESCRIPTION_LENGTH ];

	Win32ErrorToString ( dwErrorCode, wszException, MAX_DESCRIPTION_LENGTH );

	return CreateException ( 
		hInstance,
		riid,
		wszHelpFile,
		dwHelpContext,
		wszSourceProgId,
		wszException
		);
}

inline HRESULT	CreateExceptionFromHresult (
	HINSTANCE	hInstance,
	REFIID		riid,
	LPCWSTR		wszHelpFile,
	DWORD		dwHelpContext,
	LPCWSTR		wszSourceProgId,
	HRESULT		hr
	)
{
	DWORD	dwErrorCode	= HRESULTTOWIN32 ( hr );

	_ASSERT ( dwErrorCode != NOERROR );

	return CreateExceptionFromWin32Error (
		hInstance,
		riid,
		wszHelpFile,
		dwHelpContext,
		wszSourceProgId,
		dwErrorCode
		);
}

#endif // _ADMERR_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\admcmn.h ===
#ifndef _ADMCMN_INCLUDED_
#define _ADMCMN_INCLUDED_

//  ATL code:
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//  Debugging support:
#undef _ASSERT
#include <dbgtrace.h>

//  The Metabase:
#include <iadm.h>
#include <iiscnfg.h>

//  ADSI interfaces:
#include <iads.h>
#include <adsiid.h>
#include <adserr.h>

//  Useful macros
#include "admmacro.h"

//	Error handling routines:
#include "admerr.h"

//  MultiSZ class:
#include "cmultisz.h"

//  Metabase key wrapper:
#include "metakey.h"

//  Base IADs implementation:
#include "adsimpl.h"

//  U2 detection code:
#include "u2detect.h"

//	Property cache
#include "iprops.hxx"

//	ADSI Interface macros
#define RRETURN(x)	return(x);
#include "intf.hxx"
#include "macro.h"
#include "cmacro.h"
#include "fsmacro.h"
#include "adsmacro.h"

// Dispatcher
#include "cdispmgr.hxx"

#endif // _ADMCMN_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\admmacro.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	admmacro.h

Abstract:

	Useful macros used by all admin objects.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _ADMMACRO_INCLUDED_
#define _ADMMACRO_INCLUDED_

//
// Bit mask handling
//

#define IS_FLAG_SET(dw, flag) (((dw & flag) != 0) ? TRUE : FALSE)
#define SET_FLAG(dw, flag)    dw |= flag
#define RESET_FLAG(dw, flag)  dw &= ~(flag)
#define SET_FLAG_IF(cond, dw, flag)\
    if (cond)                      \
    {                              \
        SET_FLAG(dw, flag);        \
    }                              \
    else                           \
    {                              \
        RESET_FLAG(dw, flag);      \
    }


//
//	Error handling:
//

#define BAIL_ON_FAILURE(hr)	\
{							\
	if ( FAILED(hr) ) {		\
		goto Exit;			\
	}						\
}
#define BAIL_WITH_FAILURE(hr, hrFailureCode)	\
{							\
	(hr) = (hrFailureCode);	\
	goto Exit;				\
}

#define TRACE_HRESULT(hr)    \
{                           \
    if ( FAILED(hr) ) {     \
        DebugTrace ( 0, "Returning error: %x", hr );    \
    }                       \
}

//
//	Data validation macros:
//

#define IS_VALID_THIS_POINTER()			( !IsBadWritePtr ( (void *) this, sizeof (*this) ) )
#define IS_VALID_STRING(str)			( !IsBadStringPtr ( (str), (DWORD) -1 ) )
#define IS_VALID_STRING_LEN(str,len)	( !IsBadStringPtr ( (str), (len) ) )
#define IS_VALID_IN_PARAM(pIn)			( !IsBadReadPtr ( (pIn), sizeof ( *(pIn) ) ) )
#define IS_VALID_OUT_PARAM(pOut)		( !IsBadWritePtr ( (pOut), sizeof ( *(pOut) ) ) )

#define IS_VALID_READ_ARRAY(arr,cItems)		( !IsBadReadPtr ( (arr), (cItems) * sizeof ( *(arr) ) ) )
#define IS_VALID_WRITE_ARRAY(arr,cItems)	( !IsBadWritePtr ( (arr), (cItems) * sizeof ( *(arr) ) ) )

//
//	AssertValid for classes:
//

#ifdef DEBUG
	#define DECLARE_ASSERT_VALID()	void AssertValid ( ) const;
	#define DECLARE_VIRTUAL_ASSERT_VALID()	virtual void AssertValid ( ) const;
#else
	#define DECLARE_ASSERT_VALID()	inline void AssertValid ( ) const { }
	#define DECLARE_VIRTUAL_ASSERT_VALID()	inline void AssertValid ( ) const { }
#endif

//
//	Sizing macros:
//

inline DWORD STRING_BYTE_LENGTH ( LPWSTR wsz )
{
    if ( wsz == NULL ) {
        return 0;
    }

    return ( lstrlen ( wsz ) + 1 ) * sizeof wsz[0];
}

//	Use only for statically sized arrays:
#define ARRAY_SIZE(arr)	( sizeof (arr) / sizeof ( (arr)[0] ) )

inline DWORD CB_TO_CCH ( DWORD cb )
{
	return cb / sizeof (WCHAR);
}

inline DWORD CCH_TO_CB ( DWORD cch )
{
	return cch * sizeof (WCHAR);
}

//
//	Bit macros:
//

inline void SetBitFlag ( DWORD * pbv, DWORD bit, BOOL fFlag )
{
	_ASSERT ( IS_VALID_OUT_PARAM ( pbv ) );
	_ASSERT ( bit != 0 );

	if ( fFlag ) {
		*pbv |= bit;
	}
	else {
		*pbv &= ~bit;
	}
}

inline BOOL GetBitFlag ( DWORD bv, DWORD bit )
{
	return !!(bv & bit);
}

//
//	Macros for ole types that aren't wrapped using ATL:
//

inline void SAFE_FREE_BSTR ( BSTR & str )
{
	if ( str != NULL ) {
		::SysFreeString ( str );
		str = NULL;
	}
}

#define SAFE_RELEASE(x) { if ( (x) ) { (x)->Release(); (x) = NULL; } }

#endif // _ADMMACRO_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\smtp\webhlpr\webhlpr.cpp ===
#include <windows.h>
#include "admcmn.h"

// For Net* calls:

#include <lmaccess.h>
#include <lmwksta.h>
#include <lmapibuf.h>
#include <lmerr.h>

// For CAddr:: calls:

#include "cpool.h"
#include "abook.h"
#include "abtype.h"
#include "address.hxx"

#include "webhlpr.h"

static HRESULT	GetDCName ( 
	LPCWSTR 	wszServer,
	LPCWSTR 	wszDomain,
	LPWSTR *	pwszDC
	);

#if 0

// Taken from smtp/shash.hxx
#define TABLE_SIZE 241

static unsigned long ElfHash (const unsigned char * UserName);

static HRESULT  RecursiveDeleteDirectory (
    LPCWSTR     wszPath
    );

#endif

//
// Exported functions:
//

HRESULT
EnumerateTrustedDomains (
    LPCWSTR     wszComputer,
    LPWSTR *    pmszDomains
    )
{
    _ASSERT ( wszComputer && *wszComputer );
    _ASSERT ( pmszDomains );

    HRESULT     hr                  = NOERROR;
    DWORD       dwErr               = NOERROR;
    LPWSTR      mszDomains          = NULL;
    DWORD       cchDomains          = 0;
    DWORD       cchLocalDomain      = 0;
    LPWSTR      wszPrimaryDomain    = NULL;
    DWORD       cchPrimaryDomain    = 0;
    LPWSTR      wszCurrent;
    LPWSTR      mszResult           = NULL;

    *pmszDomains    = NULL;

    //
    // Get a list of the trusted 1st tier domains:
    //

    dwErr = NetEnumerateTrustedDomains (
        const_cast <LPWSTR> (wszComputer),
        &mszDomains
        );
    if ( dwErr != NOERROR ) {
		//
		//	This didn't work, but we should always add the primary
		//	domain & computer name.  Make an empty multisz to signify
		//	no trusted domains.
		//

		dwErr = NetApiBufferAllocate (
			2 * sizeof ( WCHAR ),
			(LPVOID *) &mszDomains
			);
		if ( dwErr != NOERROR ) {
			BAIL_WITH_FAILURE ( hr, HRESULT_FROM_WIN32 ( dwErr ) );
		}

		mszDomains[0] = NULL;
		mszDomains[1] = NULL;
    }

    _ASSERT ( mszDomains );
    if ( mszDomains == NULL ) {
        BAIL_WITH_FAILURE ( hr, E_UNEXPECTED );
    }

    //
    //  Check for an empty domain list:
    //

    if ( mszDomains[0] == NULL && mszDomains[1] == NULL ) {
        cchDomains = 2;
    }
    else {
        wszCurrent = mszDomains;
        if ( mszDomains[0] == _T('\0') && 
            mszDomains[1] == _T('\0') ) {
        }
        while ( wszCurrent && *wszCurrent ) {
            DWORD   cchCurrent;

            cchCurrent = lstrlen ( wszCurrent ) + 1;
            cchDomains += cchCurrent;
            wszCurrent += cchCurrent;
        }
        cchDomains += 1;    // Terminating NULL
    }

    //
    //  Add the local machine and primary domain:
    //

    hr = GetPrimaryDomain ( wszComputer, &wszPrimaryDomain );
    BAIL_ON_FAILURE ( hr );

    //
    //  PREFIX flagged this as something we need to fix.  Easier to 
    //  add check than to argue.
    //
    if ( !wszPrimaryDomain ) {
        hr = E_FAIL;
        goto Exit;
    }

    _ASSERT ( wszPrimaryDomain );
    cchPrimaryDomain = lstrlen ( wszPrimaryDomain ) + 1;

    if ( wszPrimaryDomain[0] != _T('\\') ||
        wszPrimaryDomain[1] != _T('\\') ||
        lstrcmpi ( wszPrimaryDomain + 2, wszComputer ) 
        ) {

        //
        //  The primary domain isn't the local machine, so add the local
        // machine to the list.
        //

        cchLocalDomain = lstrlen ( _T("\\\\") ) + lstrlen ( wszComputer ) + 1;
    }
    else {
        //
        //  The primary domain is the local machine - no need to add it twice.
        //

        cchLocalDomain = 0;
    }

    mszResult = new WCHAR [ cchDomains + cchLocalDomain + cchPrimaryDomain];
    if ( !mszResult ) {
        BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
    }

    if ( cchLocalDomain ) {
        wsprintf ( mszResult, _T("\\\\%s"), wszComputer );
        StringToUpper ( mszResult );
    }

    wsprintf ( mszResult + cchLocalDomain, _T("%s"), wszPrimaryDomain );
    StringToUpper ( mszResult + cchLocalDomain );

    //
    //  Copy the rest of the domains in the domain list:
    //
    CopyMemory (
        mszResult + cchLocalDomain + cchPrimaryDomain,
        mszDomains,
        cchDomains * sizeof (WCHAR)
        );

    *pmszDomains = mszResult;

Exit:
    if ( wszPrimaryDomain ) {
        delete [] wszPrimaryDomain;
    }
    if ( mszDomains ) {
        NetApiBufferFree ( mszDomains );
    }

    return hr;
}

HRESULT
GetPrimaryDomain (
    LPCWSTR         wszComputer,
    LPWSTR *        pwszPrimaryDomain
    )
{
    HRESULT             hr          = NOERROR;
    DWORD               dwErr       = NOERROR;
    WKSTA_INFO_100 *    pwkstaInfo  = NULL;
    LPWSTR              wszLangroup = NULL;

    *pwszPrimaryDomain = NULL;

    //
    // Get the workstation info to get the primary domain:
    //

    dwErr = NetWkstaGetInfo (
        const_cast <LPWSTR> (wszComputer),
        100,
        (LPBYTE *)&pwkstaInfo
        );
    if ( dwErr != NOERROR ) {
        BAIL_WITH_FAILURE ( hr, HRESULT_FROM_WIN32 ( dwErr ) );
    }

    _ASSERT ( pwkstaInfo );

    wszLangroup = pwkstaInfo->wki100_langroup;

    if ( wszLangroup && *wszLangroup ) {
        *pwszPrimaryDomain = new WCHAR [ lstrlen ( wszLangroup ) + 1 ];
        if ( !*pwszPrimaryDomain ) {
            BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
        }

        lstrcpy ( *pwszPrimaryDomain, wszLangroup );
    }
    else {
        //
        //  If there is no primary domain, use the computer name prefixed
        //  by backslashes.
        //

        *pwszPrimaryDomain = new WCHAR [ 2 + lstrlen ( wszComputer ) + 1 ];
        if ( !*pwszPrimaryDomain ) {
            BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
        }

        wsprintf ( *pwszPrimaryDomain, _T("\\\\%s"), wszComputer );
    }
    StringToUpper ( *pwszPrimaryDomain );

Exit:
    if ( pwkstaInfo ) {
        NetApiBufferFree ( pwkstaInfo );
    }
    return hr;
}

HRESULT CheckNTAccount (
    LPCWSTR         wszComputer,
	LPCWSTR         wszUsername,
	BOOL *			pfExists
	)
{
	HRESULT			hr			= NOERROR;
	DWORD			dwErr		= NOERROR;
	BOOL			fFound;
	BYTE			sidUser [ MAX_PATH ];
	DWORD			cbSid		= ARRAY_SIZE ( sidUser );
	WCHAR			wszDomain [ 512 ];
	DWORD			cchDomain	= ARRAY_SIZE ( wszDomain );
	SID_NAME_USE	nuUser;

	*pfExists = FALSE;

	fFound = LookupAccountName ( 
		wszComputer,
		wszUsername,
		&sidUser,
		&cbSid,
		wszDomain,
		&cchDomain,
		&nuUser
		);

	if ( !fFound ) {
		dwErr = GetLastError ( );

		//
		//	The not found error is ERROR_NONE_MAPPED:
		//
		if ( dwErr != ERROR_NONE_MAPPED ) {
			BAIL_WITH_FAILURE ( hr, HRESULT_FROM_WIN32 ( dwErr ) );
		}
	}

	*pfExists = fFound;

Exit:
	return hr;
}

HRESULT	CreateNTAccount	(
    LPCWSTR         wszComputer,
	LPCWSTR			wszDomain,
	LPCWSTR			wszUsername,
	LPCWSTR			wszPassword	// = ""
	)
{
	HRESULT		hr			= NOERROR;
	DWORD		dwErr		= NOERROR;
	DWORD		dwParmErr	= 0;
	LPWSTR		wszDC       = NULL;
	USER_INFO_3	UserInfo;
    WCHAR       wszNull[]   = { 0 };

	hr = GetDCName ( wszComputer, wszDomain, &wszDC );
	BAIL_ON_FAILURE(hr);

	ZeroMemory ( &UserInfo, sizeof ( UserInfo ) );

	UserInfo.usri3_name			= const_cast <LPWSTR> (wszUsername);
	UserInfo.usri3_full_name	= const_cast <LPWSTR> (wszUsername);
	UserInfo.usri3_password		= const_cast <LPWSTR> (wszPassword);
//	UserInfo.usri3_password_age
	UserInfo.usri3_priv			= USER_PRIV_USER;
	UserInfo.usri3_home_dir     = wszNull;
	UserInfo.usri3_comment      = wszNull;
	UserInfo.usri3_flags		= UF_SCRIPT | UF_NORMAL_ACCOUNT;
	UserInfo.usri3_script_path  = wszNull;
	UserInfo.usri3_auth_flags	= 0;
	UserInfo.usri3_usr_comment	= wszNull;
	UserInfo.usri3_parms		= wszNull;
	UserInfo.usri3_workstations	= wszNull;
//	UserInfo.usri3_last_logon	=;
//	UserInfo.usri3_last_logoff	=;
	UserInfo.usri3_acct_expires	= TIMEQ_FOREVER;
	UserInfo.usri3_max_storage	= USER_MAXSTORAGE_UNLIMITED;
//	UserInfo.usri3_units_per_week	=;
//	UserInfo.usri3_logon_hours	= NULL;
//	UserInfo.usri3_bad_pw_count	=;
//	UserInfo.usri3_num_logons	=;
	UserInfo.usri3_logon_server	= wszNull;
	UserInfo.usri3_country_code	= 0;
	UserInfo.usri3_code_page	= CP_ACP;
//	UserInfo.usri3_user_id		=;
	UserInfo.usri3_primary_group_id	= DOMAIN_GROUP_RID_USERS;
	UserInfo.usri3_profile		= wszNull;
	UserInfo.usri3_home_dir_drive	= wszNull;
	UserInfo.usri3_password_expired	= FALSE;

	//
	//	Add the user:
	//

	dwErr = NetUserAdd (
		wszDC,
		3,
		(LPBYTE) &UserInfo,
		&dwParmErr
		);

	if ( dwErr != NOERROR ) {
//		TRACE ( _T("Failed to add user: %d, parmerr = %d\r\n"), dwErr, dwParmErr );
		BAIL_WITH_FAILURE ( hr, HRESULT_FROM_WIN32 ( dwErr ) );
	}

#if 0
    //
    //  Attempt to add the user to the "USERS" group:
    //

    dwErr = NetGroupAddUser (
        wszDC,
//        (LPWSTR) (LPCWSTR) CString ( strDC + L"\\Users" ),
        (LPWSTR) (LPCWSTR) strUsername
        );
    if ( dwErr != NOERROR ) {
		TRACE ( _T("Couldn't add user to USERS group: %d\r\n"), dwErr );
    }
#endif

Exit:
    delete wszDC;

	return hr;
}

LPCWSTR StripBackslashesFromComputerName ( LPCWSTR wsz )
{
	if ( wsz[0] == _T('\\') &&
		wsz[1] == _T('\\') ) {

		return wsz + 2;
	}
	else {
		return wsz;
	}
}

static LPWSTR DuplicateString ( LPCWSTR wsz )
{
    LPWSTR      wszResult;

    _ASSERT ( wsz );

    wszResult = new WCHAR [ lstrlen ( wsz ) + 1 ];
    if ( wszResult ) {
        lstrcpy ( wszResult, wsz );
    }

    return wszResult;
}

void StringToUpper ( LPWSTR wsz )
{
    while ( *wsz ) {
        *wsz = towupper ( *wsz );
		wsz++;
    }
}

HRESULT	GetDCName ( 
	LPCWSTR 	wszServer,
	LPCWSTR 	wszDomain,
	LPWSTR *	pwszDC
	)
{
	HRESULT		hr		        = NOERROR;
	DWORD		dwError         = NOERROR;
	LPWSTR		wszServerCopy   = NULL;
	LPWSTR		wszDomainCopy   = NULL;
    LPCWSTR     wszPlainServer  = NULL;
    LPCWSTR     wszPlainDomain  = NULL;
	LPWSTR		wszDC	        = NULL;

    if ( wszServer == NULL ) {
        wszServer = _T("");
    }

    wszServerCopy = DuplicateString ( wszServer );
    wszDomainCopy = DuplicateString ( wszDomain );

    if ( !wszServerCopy || !wszDomainCopy ) {
        BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
    }

    StringToUpper ( wszServerCopy );
    StringToUpper ( wszDomainCopy );

	wszPlainServer	= StripBackslashesFromComputerName ( wszServerCopy );
	wszPlainDomain	= StripBackslashesFromComputerName ( wszDomainCopy );

	if ( ! lstrcmp ( wszPlainServer, wszPlainDomain ) ) {

        *pwszDC = new WCHAR [ lstrlen (_T("\\\\")) + lstrlen (wszPlainServer) + 1 ];
        if ( *pwszDC == NULL ) {
            BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
        }
        wsprintf ( *pwszDC, _T("\\\\%s"), wszPlainServer );
		goto Exit;
	}

	dwError = NetGetDCName ( wszServer, wszDomain, (LPBYTE *) &wszDC );
	if ( dwError != NOERROR ) {

		//
		//	Error, try to get any DC name:
		//

		_ASSERT ( wszDC == NULL );

		hr = HRESULT_FROM_WIN32 ( dwError );

		dwError = NetGetAnyDCName ( wszServer, wszDomain, (LPBYTE *) &wszDC );
		if ( dwError != NOERROR ) {
			goto Exit;
		}
	}

	_ASSERT ( dwError == NOERROR );
	_ASSERT ( wszDC[0] == _T('\\') );
	_ASSERT ( wszDC[1] == _T('\\') );

	*pwszDC = new WCHAR [ lstrlen ( wszDC ) + 1 ];
    if ( *pwszDC == NULL ) {
        BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
    }
    lstrcpy ( *pwszDC, wszDC );

Exit:
    delete wszServerCopy;
    delete wszDomainCopy;

	if ( wszDC ) {
		NetApiBufferFree ( wszDC );
	}

	return hr;
}

BOOL
IsValidEmailAddress (
    LPCWSTR     wszEmailAddress
    )
{
    char        szBuf[512];
    int         cchCopied;

    cchCopied = WideCharToMultiByte ( CP_ACP, 0, wszEmailAddress, -1, szBuf, sizeof (szBuf), NULL, NULL );

    if ( cchCopied == 0 ) {
        return FALSE;
    }

    return CAddr::ValidateEmailName( szBuf, FALSE );
}

#if 0

HRESULT
DeleteMailbox (
    LPCWSTR     wszServer,
    LPCWSTR     wszAlias,
    LPCWSTR     wszVDirPath,
    LPCWSTR     wszUsername,    // OPTIONAL
    LPCWSTR     wszPassword     // OPTIONAL
    )
{
    TraceFunctEnter ( "DeleteMailbox" );

    HRESULT     hr  = NOERROR;
    UCHAR       szAlias[512];
    ULONG       lHashValue;
    DWORD       cchMailboxPath;
    LPWSTR      wszMailboxPath;
    LPCWSTR     wszFormat;

    if ( !wszServer || !wszAlias || !wszVDirPath ) {
        BAIL_WITH_FAILURE ( hr, E_INVALIDARG );
    }

    if ( !*wszServer || !*wszAlias || !*wszVDirPath ) {
        BAIL_WITH_FAILURE ( hr, E_INVALIDARG );
    }

    //
    //  Compute the mailbox hash value:
    //

    WideCharToMultiByte ( CP_ACP, 0, wszAlias, -1, (char *) szAlias, ARRAY_SIZE ( szAlias ), NULL, NULL );

    DebugTrace ( 0, "Deleting mailbox for %s", szAlias );

    lHashValue = ElfHash ( szAlias ) % TABLE_SIZE;

    DebugTrace ( 0, "Hash value = %u", lHashValue );

    //
    //  Compute the mailbox directory path,
    //  this is: <vdir path>\<alias hash>\<alias>
    //

    cchMailboxPath =
        lstrlen ( wszVDirPath ) +       // <Virtual directory path>
        1 +                             // '\'
        20 +                            // <hash value>
        1 +                             // '\'
        lstrlen ( wszAlias ) +          // <alias>
        1;                              // null terminator

    wszMailboxPath = new WCHAR [ cchMailboxPath ];
    if ( !wszMailboxPath ) {
        BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
    }

    // Avoid too many '\'s
    if ( wszVDirPath [ lstrlen ( wszVDirPath ) - 1 ] == _T('\\') ) {
        wszFormat = _T("%s%u\\%s");
    }
    else {
        wszFormat = _T("%s\\%u\\%s");
    }

    wsprintf (
        wszMailboxPath,
        wszFormat,
        wszVDirPath,
        lHashValue,
        wszAlias
        );

    RecursiveDeleteDirectory ( wszMailboxPath );

Exit:
    TraceFunctLeave ();
    return hr;
}

//---[ ElfHash() ]------------------------------------------------------------
//
//  Pulled this function from the stacks project. Calculates the hash value
//  given a username. The mailbox of a user is stored in a subdirectory of
//  the form <virtual directory root>\<hash value%TABLE_SIZE>\<username>.
//  The username is the lowercase of the name part of the proxy address for
//  e.g. username@x.com.
//
//  Params:
//      UserName  The username to be hashed.
//
//  Return: (HRESULT)
//      NOERROR if success, ADSI error code if failed.
//
//----------------------------------------------------------------------------
unsigned long ElfHash (const unsigned char * UserName)
{
    unsigned long HashValue = 0, g;

    while (*UserName)
    {
        HashValue = (HashValue << 4) + *UserName++;
        if( g = HashValue & 0xF0000000)
            HashValue ^= g >> 24;

        HashValue &= ~g;
    }

    return HashValue;

}

HRESULT  RecursiveDeleteDirectory (
    LPCWSTR     wszPath
    )
{
    TraceFunctEnter ( "DeleteDirectory" );

    HRESULT             hr      = NOERROR;
    DWORD               cchOldCurrentDirectory;
    LPWSTR              wszOldCurrentDirectory = NULL;
    DWORD               cchPath = lstrlen ( wszPath );
    HANDLE              hSearch = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA     find;
    BOOL                fOk     = TRUE;
    HANDLE              hFile;

    //
    //  Save the current directory:
    //

    cchOldCurrentDirectory = GetCurrentDirectory ( 0, NULL );
    _ASSERT ( cchOldCurrentDirectory > 0 );
    wszOldCurrentDirectory = new WCHAR [ cchOldCurrentDirectory ];
    if ( !wszOldCurrentDirectory ) {
        BAIL_WITH_FAILURE(hr, E_OUTOFMEMORY);
    }
    GetCurrentDirectory ( cchOldCurrentDirectory, wszOldCurrentDirectory );

    //
    //  Set the current directory to the path:
    //

    SetCurrentDirectory ( wszPath );

    //
    //  Create the search string:
    //

    hSearch = FindFirstFile ( _T("*.*"), &find );
    while ( hSearch != INVALID_HANDLE_VALUE && fOk ) {

        //
        //  Skip the . and .. directories:
        //

        if (
            lstrcmp ( find.cFileName, _T(".") ) &&
            lstrcmp ( find.cFileName, _T("..") )
            ) {

            if ( find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
                hr = RecursiveDeleteDirectory ( find.cFileName );
                BAIL_ON_FAILURE(hr);
            }
            else {
                //
                //  Delete this file:
                //

                hFile = CreateFile (
                    find.cFileName,
                    GENERIC_WRITE,
                    FILE_SHARE_DELETE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_DELETE_ON_CLOSE,
                    NULL
                    );

                if ( hFile != INVALID_HANDLE_VALUE ) {
                    CloseHandle ( hFile );
                }
                // Otherwise, press on...
            }
        }

        //  Get the next file:
        fOk = FindNextFile ( hSearch, &find );
    }

    //
    //  Delete the directory:
    //
    if ( hSearch != INVALID_HANDLE_VALUE ) {
        FindClose ( hSearch );
        hSearch = INVALID_HANDLE_VALUE;
    }

    hFile = CreateFile (
        wszPath,
        GENERIC_WRITE,
        FILE_SHARE_DELETE,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_DELETE_ON_CLOSE,
        NULL
        );

    if ( hFile != INVALID_HANDLE_VALUE ) {
        CloseHandle ( hFile );
    }

Exit:
    if ( wszOldCurrentDirectory ) {
        //
        // Restore the current directory:
        //

        SetCurrentDirectory ( wszOldCurrentDirectory );
        delete wszOldCurrentDirectory;
    }

    if ( hSearch != INVALID_HANDLE_VALUE ) {
        FindClose ( hSearch );
        hSearch = INVALID_HANDLE_VALUE;
    }

    TraceFunctLeave ( );
    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\adsimp.inl ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:  adsimp.inl
//
//  Contents:  Inline for standard implementations
//
//  History:   5/4/98     KeithLau    Created.
//
//----------------------------------------------------------------------------


//
// This declares methods for the following:
// IADsExtension
// IUnknown
// IDispatch
// IPrivateUnknown
// IPrivateDispatch
//
// The following are implemented partially inline:
// IUnknown (AddRef & Release)
// IPrivateUnknown (AddRef & Release)
//
	DECLARE_GET_CONTROLLING_UNKNOWN()						
															
private:													
	long					_lRefCount;
	IUnknown				*_pUnkOuter;					
    IADs FAR				*_pADs;							
    CAggregateeDispMgr FAR	*_pDispMgr;						
    BOOL					_fDispInitialized;				

															
public:														
	STDMETHODIMP NonDelegatingQueryInterface(				
		REFIID iid,											
		LPVOID FAR* ppv										
		)													
	{														
		if (IsEqualIID(iid, THIS_IID)) {
			*ppv = (IADsUser FAR *) this;					
		} else if (IsEqualIID(iid, IID_IADsExtension)) {	
			*ppv = (IADsExtension FAR *) this;				
		} else if (IsEqualIID(iid, IID_IDispatch)) {	
			*ppv = (IDispatch FAR *) this;
		} else if (IsEqualIID(iid, IID_IADs)) {
			*ppv = (IADs FAR *) this;		
		} else if (IsEqualIID(iid, IID_IPrivateUnknown)) {
			*ppv = (IPrivateUnknown FAR *) this;		
		} else if (IsEqualIID(iid, IID_IPrivateDispatch)) {	
			*ppv = (IPrivateDispatch FAR *) this;		
		} else if (IsEqualIID(iid, IID_IUnknown)) {			
			*ppv = (INonDelegatingUnknown FAR *) this;		
		} else {											
			*ppv = NULL;									
			return E_NOINTERFACE;							
		}													
		NonDelegatingAddRef();
		return(S_OK);										
	}														

	STDMETHOD_(ULONG, NonDelegatingAddRef) (void)			
	{ 
		return(InterlockedIncrement(&_lRefCount));
	}

	STDMETHOD_(ULONG, NonDelegatingRelease) (void)			
	{														
		long lTemp = InterlockedDecrement(&_lRefCount);		
		if (!lTemp) delete this;							
		return(lTemp);										
	}														

	STDMETHODIMP QueryInterface(							
		REFIID iid,											
		LPVOID FAR* ppv										
		)													
	{														
		HRESULT hr = S_OK;
		if (_pUnkOuter == (LPVOID)this)
			hr = NonDelegatingQueryInterface(iid,ppv);
		else
   			hr = _pUnkOuter->QueryInterface(iid,ppv);
		return(hr);
	}														

	STDMETHOD_(ULONG, AddRef) (void)						
	{ 
		return (_pUnkOuter == (LPVOID)this)?NonDelegatingAddRef():_pUnkOuter->AddRef();
	}
	STDMETHOD_(ULONG, Release) (void)						
	{
		return (_pUnkOuter == (LPVOID)this)?NonDelegatingRelease():_pUnkOuter->Release();
	}
															
//    DECLARE_IDispatch_METHODS								
    DECLARE_IPrivateUnknown_METHODS							
    DECLARE_IPrivateDispatch_METHODS						
															
    STDMETHOD(Operate)(THIS_								
				DWORD   dwCode,								
				VARIANT varUserName,						
				VARIANT varPassword,						
				VARIANT varReserved							
				);											
															
    STDMETHOD(PrivateGetIDsOfNames)(THIS_					
				REFIID riid,								
				OLECHAR FAR* FAR* rgszNames,				
				unsigned int cNames,						
				LCID lcid,									
				DISPID FAR* rgdispid);						
															
    STDMETHOD(PrivateInvoke)(THIS_							
				DISPID dispidMember,						
				REFIID riid,								
				LCID lcid,									
				WORD wFlags,								
				DISPPARAMS FAR* pdispparams,				
				VARIANT FAR* pvarResult,					
				EXCEPINFO FAR* pexcepinfo,					
				unsigned int FAR* puArgErr					
				);											

/*
	void SetVoid(void *pVoid)
	{
		_pUnkOuter = (IUnknown *)pVoid;
	}
*/
	HRESULT FinalConstruct()
	{
		IADs FAR *  pADs = NULL;
		CAggregateeDispMgr FAR * pDispMgr = NULL;
		HRESULT hr = S_OK;

		_lRefCount			= 0;
		_pADs				= NULL;
		_pDispMgr			= NULL;
		_fDispInitialized	= FALSE;

		_pUnkOuter = GetControllingUnknown();
		if (!_pUnkOuter)
			_pUnkOuter = (IUnknown *)(IADs *)this;

		pDispMgr = new CAggregateeDispMgr;
		if (pDispMgr == NULL) {
			hr = E_OUTOFMEMORY;
		}
		BAIL_ON_FAILURE(hr);

		hr = pDispMgr->LoadTypeInfoEntry(
					THIS_LIBID,
					THIS_IID,
					this,
					DISPID_VALUE
					//DISPID_REGULAR
					);
		BAIL_ON_FAILURE(hr);

		//
		// Store the IADs Pointer, but again do NOT ref-count
		// this pointer - we keep the pointer around, but do
		// a release immediately.
		//

		if (_pUnkOuter != (LPVOID)this)
		{
			hr = _pUnkOuter->QueryInterface(IID_IADs, (void **)&pADs);
			if (SUCCEEDED(hr))
			{
				_pADs = pADs;
				pADs->Release();
			}
			else
			{
				BAIL_ON_FAILURE(hr);
			}
		}
		else
		{
			_pADs = (IADs FAR *)this;
		}

		_pDispMgr = pDispMgr;

		return(hr);

	Exit:
		delete  pDispMgr;
		return(hr);
	}

	HRESULT FinalRelease()
	{
		if (_pDispMgr)
			delete _pDispMgr;
		return(S_OK);
	}

	STDMETHODIMP                                                          
	GetTypeInfoCount(unsigned int FAR* pctinfo)                      
	{                                                                     
		if (_pADs == (LPVOID)this)                                        
		{                                                                 
			RRETURN(ADSIGetTypeInfoCount(pctinfo));                       
		}                                                                 
		else                                                              
		{                                                                 
			RRETURN(_pADs->GetTypeInfoCount(pctinfo));                    
		}                                                                 
	}                                                                     
																		  
	STDMETHODIMP                                                          
	GetTypeInfo(unsigned int itinfo, LCID lcid,                      
			ITypeInfo FAR* FAR* pptinfo)                                  
	{                                                                     
		if (_pADs == (LPVOID)this)                                        
		{                                                                 
			RRETURN(ADSIGetTypeInfo(itinfo,                               
										   lcid,                          
										   pptinfo                        
										   ));                            
		}                                                                 
		else                                                              
		{                                                                 
			RRETURN(_pADs->GetTypeInfo(itinfo,                            
										   lcid,                          
										   pptinfo                        
										   ));                            
		}                                                                 
	}                                                                     
	STDMETHODIMP                                                          
	GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 
			unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         
	{                                                                     
		if (_pADs == (LPVOID)this)                                        
		{                                                                 
			RRETURN(ADSIGetIDsOfNames(iid,                                
											 rgszNames,                   
											 cNames,                      
											 lcid,                        
											 rgdispid                     
											 ));                          
		}                                                                 
		else                                                              
		{                                                                 
			RRETURN(_pADs->GetIDsOfNames(iid,                             
											 rgszNames,                   
											 cNames,                      
											 lcid,                        
											 rgdispid                     
											 ));                          
		}                                                                 
	}                                                                     
																		  
	STDMETHODIMP                                                          
	Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               
			unsigned short wFlags, DISPPARAMS FAR* pdispparams,           
			VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           
			unsigned int FAR* puArgErr)                                   
	{                                                                     
		if (_pADs == (LPVOID)this)                                        
		{                                                                 
			RRETURN (ADSIInvoke(dispidMember,                             
									   iid,                               
									   lcid,                              
									   wFlags,                            
									   pdispparams,                       
									   pvarResult,                        
									   pexcepinfo,                        
									   puArgErr                           
									   ));                                
		}                                                                 
		else                                                              
		{                                                                 
			RRETURN (_pADs->Invoke(dispidMember,                          
									   iid,                               
									   lcid,                              
									   wFlags,                            
									   pdispparams,                       
									   pvarResult,                        
									   pexcepinfo,                        
									   puArgErr                           
									   ));                                
		}                                                                 
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\adsimpl.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	AdsImpl.cpp

Abstract:

	Implements a simple version of the IADs interface.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include <iads.h>
#include <adsiid.h>
#include <adserr.h>
#include "adsimpl.h"

#define STR_PROVIDER_NAME	_T("IIS")
#define STR_SCHEMA_PATH     _T("schema")

CIADsImpl::CIADsImpl ( ) :
	m_dwInstance ( 1 )
{
}

CIADsImpl::~CIADsImpl ( )
{
}

//
//	IADs Methods:
//

HRESULT CIADsImpl::get_Name		( BSTR * pstrName )
{
	return GetName ( pstrName );
}

HRESULT CIADsImpl::get_Class	( BSTR * pstrClass )
{
	return GetClass ( pstrClass );
}

HRESULT CIADsImpl::get_GUID		( BSTR * pstrGUID )
{
	return GetString ( _T(""), pstrGUID );
}

HRESULT CIADsImpl::get_Schema	( BSTR * pstrSchema )
{
    return BuildSchemaPath ( pstrSchema );
}

HRESULT CIADsImpl::get_ADsPath	( BSTR * pstrADsPath )
{
	return BuildAdsPath ( TRUE, pstrADsPath );
}

HRESULT CIADsImpl::get_Parent	( BSTR * pstrParent )
{
	return BuildAdsPath ( FALSE, pstrParent );
}

HRESULT CIADsImpl::Get			( BSTR strName, VARIANT * pvar )
{
	if ( ! lstrcmpi ( strName, _T("KeyType") ) ) {
		V_VT (pvar) = VT_BSTR;
		V_BSTR (pvar) = ::SysAllocString ( m_strClass );
		return NOERROR;
	}
	else {
		return E_ADS_PROPERTY_NOT_SUPPORTED;
	}
}

HRESULT CIADsImpl::Put			( BSTR strName, VARIANT var )
{
	return E_ADS_PROPERTY_NOT_SUPPORTED;
}

HRESULT CIADsImpl::GetEx		( BSTR strName, VARIANT * pvar )
{
	return Get ( strName, pvar );
}

HRESULT CIADsImpl::PutEx		( long lControlCode, BSTR strName, VARIANT var )
{
	return E_ADS_PROPERTY_NOT_SUPPORTED;
}

HRESULT CIADsImpl::GetInfo ( )
{
	return NOERROR;
}

HRESULT CIADsImpl::SetInfo ( )
{
	return NOERROR;
}

HRESULT CIADsImpl::GetInfoEx	( VARIANT varProps, long lnReserved )
{
	return NOERROR;
}

//
//	Data accessors:
//

HRESULT	CIADsImpl::SetString ( CComBSTR & str, LPCWSTR wsz )
{
	if ( wsz != NULL ) {
		str = wsz;
	}
	else {
		str = _T("");
	}

	if ( !str ) {
		return E_OUTOFMEMORY;
	}
	else {
		return NOERROR;
	}
}

HRESULT	CIADsImpl::GetString ( LPCWSTR wsz, BSTR * pstr )
{
	CComBSTR	str;

	if ( wsz != NULL ) {
		str = wsz;
	}
	else {
		str = _T("");
	}

	if ( !str ) {
		return E_OUTOFMEMORY;
	}

	*pstr = str.Detach();
	return NOERROR;
}

HRESULT	CIADsImpl::SetComputer	( LPCWSTR wszComputer )
{
	return SetString ( m_strComputer, wszComputer );
}

HRESULT	CIADsImpl::SetService	( LPCWSTR wszService )
{
	return SetString ( m_strService, wszService );
}

HRESULT	CIADsImpl::SetInstance	( DWORD dwInstance )
{
	m_dwInstance = dwInstance;
	return NOERROR;
}

HRESULT	CIADsImpl::SetName		( LPCWSTR wszName )
{
	return SetString ( m_strName, wszName );
}

HRESULT CIADsImpl::SetClass ( LPCWSTR wszClass )
{
	return SetString ( m_strClass, wszClass );
}

HRESULT CIADsImpl::SetIADs ( IADs* pADs )
{
    m_pADs = pADs;
    return NOERROR;
}

HRESULT	CIADsImpl::GetComputer ( BSTR * pstrComputer )
{
	return GetString ( m_strComputer, pstrComputer );
}

HRESULT	CIADsImpl::GetService	( BSTR * pstrService )
{
	return GetString ( m_strService, pstrService );
}

HRESULT	CIADsImpl::GetInstance	( DWORD * pdwInstance )
{
	*pdwInstance = m_dwInstance;

	return NOERROR;
}

HRESULT	CIADsImpl::GetName		( BSTR * pstrName )
{
	return GetString ( m_strName, pstrName );
}

HRESULT CIADsImpl::GetClass ( BSTR * pstrClass )
{
	return GetString ( m_strClass, pstrClass );
}

HRESULT CIADsImpl::GetIADs ( IADs** ppADs )
{
    *ppADs = (IADs*)m_pADs;
    if( *ppADs ) (*ppADs)->AddRef();
    return NOERROR;
}

BSTR CIADsImpl::QueryComputer ( )
{
    if( !lstrcmpi(m_strComputer, _T("localhost")) )
        return NULL;

    return (BSTR) m_strComputer;
}

DWORD CIADsImpl::QueryInstance ( )
{
    return m_dwInstance;
}

HRESULT	CIADsImpl::BuildAdsPath ( BOOL fIncludeName, BSTR * pstrPath )
{
	DWORD		cchRequired;
	CComBSTR	strPath;

	cchRequired = 
			lstrlen ( STR_PROVIDER_NAME ) +     //  IIS
            3 +                                 //  ://
			m_strComputer.Length() +            //  <computer>
            1 +                                 //  /
			m_strService.Length() +             //  <service>
            1 +                                 //  /
			25;		// 25 to include NULL terminator & size of Instance #.

	if ( fIncludeName ) {
		cchRequired += 1 + m_strName.Length();  //  /<Name>
	}

	strPath.Attach ( ::SysAllocStringLen ( NULL, cchRequired ) );

	if ( !strPath ) {
		return E_OUTOFMEMORY;
	}

	if ( fIncludeName ) {
		wsprintf ( 
					strPath, 
					_T("%s://%s/%s/%d/%s"),
					STR_PROVIDER_NAME,
					m_strComputer,
					m_strService,
					m_dwInstance,
					m_strName
					);
	}
	else {
		wsprintf ( 
					strPath, 
					_T("%s://%s/%s/%d"),
					STR_PROVIDER_NAME,
					m_strComputer,
					m_strService,
					m_dwInstance
					);
	}

	*pstrPath = strPath.Detach();
	return NOERROR;
}

HRESULT CIADsImpl::BuildSchemaPath ( BSTR * pstrPath )
{
    DWORD       cchRequired;
    CComBSTR    strPath;

    cchRequired =
			lstrlen ( STR_PROVIDER_NAME ) +     //  IIS
            3 +                                 //  ://
			m_strComputer.Length() +            //  <computer>
            1 +                                 //  /
			lstrlen ( STR_SCHEMA_PATH ) +       //  <schema path>
            1 +                                 //  /
			m_strClass.Length () +              //  <class>
			25;		// 25 to include NULL terminator plus buffer.

    strPath.Attach ( ::SysAllocStringLen ( NULL, cchRequired ) );

    if ( !strPath ) {
        return E_OUTOFMEMORY;
    }

    wsprintf (
                strPath,
                _T("%s://%s/%s/%s"),
                STR_PROVIDER_NAME,
                m_strComputer,
                STR_SCHEMA_PATH,
                m_strClass
                );

    *pstrPath = strPath.Detach();
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\adsimpl.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	AdsImpl.h

Abstract:

	A simple implementation of the IADs interface for the
	admin objects

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _ADSIMPL_INCLUDED_
#define _ADSIMPL_INCLUDED_


//
//	Macros to implement the required IADs methods:
//

#define DECLARE_IADS_METHODS()	\
public:                         \
	STDMETHODIMP get_Name	( BSTR * pstrName );	\
	STDMETHODIMP get_Class	( BSTR * pstrClass );	\
	STDMETHODIMP get_GUID	( BSTR * pstrGUID );	\
	STDMETHODIMP get_Schema	( BSTR * pstrSchema );	\
	STDMETHODIMP get_ADsPath( BSTR * pstrADsPath );	\
	STDMETHODIMP get_Parent	( BSTR * pstrParent );	\
	STDMETHODIMP GetInfo 	( );					\
	STDMETHODIMP SetInfo 	( );					\
	STDMETHODIMP Get		( BSTR strName, VARIANT * pvar );	\
	STDMETHODIMP Put		( BSTR strName, VARIANT var );		\
	STDMETHODIMP GetEx		( BSTR strName, VARIANT * pvar );	\
	STDMETHODIMP PutEx		( long lControlCode, BSTR strName, VARIANT var );	\
	STDMETHODIMP GetInfoEx	( VARIANT varProps, long lnReserved );				\
	STDMETHODIMP get_IADsPointer	( IADs** ppADs);				\
	STDMETHODIMP put_IADsPointer	( IADs* pADs);				\
    STDMETHODIMP get_KeyType ( BSTR* pstrKeyType);                   \
    STDMETHODIMP put_KeyType ( BSTR strKeyType );                    \

#define DECLARE_GET_IADS_PROPERTY(cls,m_IADsImpl,prop)		\
	STDMETHODIMP cls :: get_##prop ( BSTR * pstr##prop )	\
	{														\
		return m_IADsImpl . get_##prop( pstr##prop );		\
	}

#define DECLARE_SIMPLE_IADS_IMPLEMENTATION(cls,m_IADsImpl)	\
	DECLARE_GET_IADS_PROPERTY(cls,m_IADsImpl,Name)		\
	DECLARE_GET_IADS_PROPERTY(cls,m_IADsImpl,Class)		\
	DECLARE_GET_IADS_PROPERTY(cls,m_IADsImpl,GUID)		\
	DECLARE_GET_IADS_PROPERTY(cls,m_IADsImpl,Schema)	\
	DECLARE_GET_IADS_PROPERTY(cls,m_IADsImpl,Parent)	\
	DECLARE_GET_IADS_PROPERTY(cls,m_IADsImpl,ADsPath)	\
	\
	STDMETHODIMP cls :: GetInfo ( )		\
	{ return m_IADsImpl.m_pADs->GetInfo (); }	\
	STDMETHODIMP cls :: SetInfo ( )		\
	{ return m_IADsImpl.m_pADs->SetInfo (); }	\
	STDMETHODIMP cls :: Get ( BSTR strName, VARIANT * pvar )	\
	{ return m_IADsImpl.m_pADs->Get ( strName, pvar ); }				\
	STDMETHODIMP cls :: Put ( BSTR strName, VARIANT var )		\
	{ return m_IADsImpl.m_pADs->Put ( strName, var ); }					\
	STDMETHODIMP cls :: GetEx ( BSTR strName, VARIANT * pvar )	\
	{ return m_IADsImpl.m_pADs->GetEx ( strName, pvar ); }                      \
	STDMETHODIMP cls :: PutEx ( long lControlCode, BSTR strName, VARIANT var )	\
	{ return m_IADsImpl.m_pADs->PutEx ( lControlCode, strName, var ); }         \
	STDMETHODIMP cls :: GetInfoEx ( VARIANT varProps, long lnReserved )         \
	{ return m_IADsImpl.m_pADs->GetInfoEx ( varProps, lnReserved ); }           \
	\
	STDMETHODIMP cls :: get_Server ( BSTR * pstrServer )		\
	{ return m_IADsImpl.GetComputer ( pstrServer ); }			\
	STDMETHODIMP cls :: put_Server ( BSTR strServer )			\
	{ return m_IADsImpl.SetComputer ( strServer ); }			\
	STDMETHODIMP cls :: get_ServiceInstance ( long * plInstance )	\
	{ return m_IADsImpl.GetInstance ( (DWORD *) plInstance ); }		\
	STDMETHODIMP cls :: put_ServiceInstance ( long lInstance )		\
	{ return m_IADsImpl.SetInstance ( lInstance ); }				\
    STDMETHODIMP cls :: get_IADsPointer ( IADs** ppADs )                    \
    { return m_IADsImpl.GetIADs ( ppADs ); }                                \
    STDMETHODIMP cls :: put_IADsPointer ( IADs* pADs )                      \
    { return m_IADsImpl.SetIADs ( pADs ); }                                 \
    STDMETHODIMP cls :: get_KeyType ( BSTR* pstrKeyType)                    \
    {                                                                       \
        VARIANT     var;                                                    \
        HRESULT     hr = NOERROR;                                           \
        hr = m_IADsImpl.m_pADs->Get( CComBSTR(_T("KeyType")), &var );       \
        *pstrKeyType = V_BSTR(&var);                                        \
        return hr;                                                          \
    }                                                                       \
    STDMETHODIMP cls :: put_KeyType ( BSTR strKeyType )                     \
    {                                                                       \
        VARIANT     var;                                                    \
        V_VT(&var) = VT_BSTR;                                               \
        V_BSTR(&var) = strKeyType;                                          \
        return m_IADsImpl.m_pADs->Put( CComBSTR(_T("KeyType")), var);       \
    }                                                                       \


//$-------------------------------------------------------------------
//
//	Class:		CIADsImpl
//
//	Description:
//
//		Provides a simple implementation of the IADs interface.
//
//--------------------------------------------------------------------

class CIADsImpl
{
//
//	Methods:
//
public:
	CIADsImpl ( );
	~CIADsImpl ( );

	//
	//	IADs implementation:
	//

	DECLARE_IADS_METHODS()

	//
	//	Accessors:
	//

	HRESULT		SetComputer	( LPCWSTR wszComputer );
	HRESULT		SetService	( LPCWSTR wszService );
	HRESULT		SetInstance	( DWORD dwInstance );
	HRESULT		SetName		( LPCWSTR wszName );
	HRESULT		SetClass    ( LPCWSTR wszSchema );
	HRESULT		SetIADs      ( IADs* pADs );

	HRESULT		GetComputer ( BSTR * pstrComputer );
	HRESULT		GetService	( BSTR * pstrService );
	HRESULT		GetInstance	( DWORD * pdwInstance );
	HRESULT		GetName		( BSTR * pstrName );
	HRESULT		GetClass    ( BSTR * pstrSchema );
	HRESULT		GetIADs      ( IADs** ppADs );

    BSTR        QueryComputer   ( );
    DWORD       QueryInstance   ( );

protected:
	HRESULT		SetString	( CComBSTR & str, LPCWSTR wsz );
	HRESULT		GetString	( LPCWSTR wsz, BSTR * pstr );
	HRESULT		BuildAdsPath ( BOOL fIncludeName, BSTR * pstrPath );
	HRESULT		BuildSchemaPath ( BSTR * pstrPath );

//
//	Data:
//
private:
	CComBSTR	m_strComputer;
	CComBSTR	m_strService;
	DWORD		m_dwInstance;
	CComBSTR	m_strName;

    CComBSTR    m_strClass;
	CComBSTR	m_strSchema;

public:
    CComPtr<IADs>   m_pADs;
};

#endif // _ADSIMPL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\fsmacro.h ===
#define PUT_PROPERTY_LONG(this, Property) \
                RRETURN(put_LONG_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        l##Property \
                                        ))

#define GET_PROPERTY_LONG(this, Property) \
                RRETURN(get_LONG_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_BSTR(this, Property) \
                RRETURN(put_BSTR_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        bstr##Property \
                                        ))

#define GET_PROPERTY_BSTR(this, Property) \
                RRETURN(get_BSTR_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_VARIANT_BOOL(this, Property) \
                RRETURN(put_VARIANT_BOOL_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        f##Property\
                                        ))

#define GET_PROPERTY_VARIANT_BOOL(this, Property) \
                RRETURN(get_VARIANT_BOOL_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_DATE(this, Property) \
                RRETURN(put_DATE_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ))

#define GET_PROPERTY_DATE(this, Property) \
                RRETURN(get_DATE_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_VARIANT(this, Property) \
                RRETURN(put_VARIANT_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        v##Property \
                                        ))

#define GET_PROPERTY_VARIANT(this, Property) \
                RRETURN(get_VARIANT_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\adsmacro.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:  adsmacro.h
//
//  Contents:  Macros for standard method declarations
//
//  History:   4/24/98     KeithLau    Created.
//
//----------------------------------------------------------------------------

#define DISPID_REGULAR	1

//
// This provides implementations for the following:
// IADsExtension
// IUnknown (QI)
// IDispatch
// IPrivateUnknown (QI)
// IPrivateDispatch
//
//	DEFINE_DELEGATING_IDispatch_Implementation(ClassName)

#define DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(BaseName, ClassName, IID)	\
	DEFINE_IPrivateDispatch_Implementation(ClassName)		\
	DEFINE_IADsExtension_Implementation(ClassName)			\
															\
	STDMETHODIMP											\
	C##BaseName::Operate(									\
		THIS_ DWORD dwCode,									\
		VARIANT varUserName,								\
		VARIANT varPassword,								\
		VARIANT varFlags									\
		)													\
	{														\
		RRETURN(E_NOTIMPL);									\
	}														\
															\
	STDMETHODIMP											\
	C##BaseName::ADSIInitializeObject(						\
		THIS_ BSTR lpszUserName,							\
		BSTR lpszPassword,									\
		long lnReserved										\
		)													\
	{														\
		RRETURN(S_OK);										\
	}														\
															\
	STDMETHODIMP											\
	C##BaseName::ADSIReleaseObject()						\
	{														\
		delete this;										\
		RRETURN(S_OK);										\
	}														\
															\
	STDMETHODIMP											\
	C##BaseName::ADSIInitializeDispatchManager(				\
		long dwExtensionId									\
		)													\
	{														\
		HRESULT hr = S_OK;									\
		if (_fDispInitialized) {							\
			RRETURN(E_FAIL);								\
		}													\
		hr = _pDispMgr->InitializeDispMgr(dwExtensionId);	\
		if (SUCCEEDED(hr)) {								\
			_fDispInitialized = TRUE;						\
		}													\
		RRETURN(hr);										\
	}														\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\cdispmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdispmgr.cxx
//
//  Contents:   The dispatch manager -- a class to manage
//		multiple IDispatch-callable interfaces.
//
//  Classes:	CAggregateeDispMgr
//
//  Functions:	None external.
//
//  History:    ??-???-??   KrishnaG   created
//		07-Sep-97   t-blakej   Commented, cleaned up, made
//                                     independent of ADSI.
//
//  See cdispmgr.hxx for a more thorough description of the dispatch manager.
//
//----------------------------------------------------------------------------

//
// Since this class is useful outside of ADSI, some work has been taken to
// make it not depend on any ADSI-specific code.  It needs two ADSI header
// files (cdispmgr.hxx and iprops.hxx), but they only depend on definitions
// from standard system header files.
//
// To accomodate the current building method in ADSI, the precompiled
// header "procs.hxx" is included; this includes all the necessary ADSI
// header files and definitions.  But for use outside of ADSI, the few
// necessary header files are explicitly included below; see the comment by
// "#ifndef ADsAssert".
//
// So if not compiling for ADSI, comment the following two lines out.
//

//
// Necessary system headers.
//
#define _OLEAUT32_
#define INC_OLE2
#include <windows.h>
#include <stdio.h>

//
// Necessary class definitions used by the dispatch manager.
// Edit these paths if necessary.
//
#include "dbgtrace.h"
#include "macro.h"
#include "admmacro.h"
#include "iprops.hxx"
#include "cdispmgr.hxx"

//
// A simple assert function.
//
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertEx
//
//  Synopsis:   Display assertion information.
//
//  Effects:    Called when an assertion is hit.
//
//  History:	Simplified from Win4AssertEx, to make this dispatch manager
//  		not depend on other files.
//
//----------------------------------------------------------------------------
static void
AssertEx(char const *szFile, int iLine, char const *szMessage)
{
    static char szAssertCaption[100];

    sprintf(szAssertCaption, "File: %s line %u, thread id %d",
	szFile, iLine, GetCurrentThreadId());

    if (IDCANCEL == MessageBoxA(
                NULL,
                (char *) szMessage,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                ))
    {
	DebugBreak();
    }
}
# define DispMgrAssert(x)  (void)((x) || (AssertEx(__FILE__, __LINE__, #x),0))
#else
# define AssertEx(f,l,m)   
# define DispMgrAssert(x)  
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Inline routines:

static inline LONG
getDispMgrId(DISPID InputDispId)
{
    return (InputDispId & 0x7f000000) >> 24;
}

static inline LONG
getTypeInfoId(DISPID InputDispId)
{
    return (InputDispId & 0x00ff0000) >> 16;
}

static inline LONG
getDispId(DISPID InputDispId)
{
    return (InputDispId & 0x0000ffff);
}

static inline void
MakeDISPID(
    LONG ExtensionId,
    LONG TypeInfoId,
    LONG DispId,
    DISPID *pResult
    )
{
    if (DispId == DISPID_UNKNOWN){

    	*pResult = DispId;

    }else if (TypeInfoId < 0 || TypeInfoId >= 0x100 ||
	                DispId < 0 || DispId >= 0x10000){

	    //
	    // Might happen if some object has very large dispid's.
	    // But we can't handle it if it does.
	    //
	    *pResult = DISPID_UNKNOWN;
    }
    else{

	    *pResult = ((ExtensionId & 0xff) << 24) |((TypeInfoId & 0xff) << 16) | (DispId & 0xffff);

    }

}


static inline void
MakeDISPIDs(
    LONG ExtensionId,
    LONG TypeInfoId,
    DISPID *rgdispid,
    unsigned int cNames
    )
{
    for (unsigned int i = 0; i < cNames; i++)
    {
        MakeDISPID(ExtensionId, TypeInfoId, rgdispid[i], &rgdispid[i]);
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// Public methods:

CAggregateeDispMgr::CAggregateeDispMgr()
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
    _dwExtensionID = 0;
}

CAggregateeDispMgr::~CAggregateeDispMgr()
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    PTYPEINFOENTRY pTemp = NULL;
    ITypeInfo *pTypeInfo = NULL;

    pTypeInfoEntry = _pTypeInfoEntry;

    while (pTypeInfoEntry) {

        pTemp = pTypeInfoEntry;

        pTypeInfo = (ITypeInfo *)pTypeInfoEntry->ptypeinfo;
        pTypeInfo->Release();

        pTypeInfoEntry = pTemp->pNext;

        LocalFree(pTemp);
    }

}

void
CAggregateeDispMgr::RegisterPropertyCache(IPropertyCache *pPropertyCache)
{
    _pPropertyCache = pPropertyCache;
    _dwPropCacheID = gentypeinfoid();
}


STDMETHODIMP
CAggregateeDispMgr::GetTypeInfoCount(unsigned int *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CAggregateeDispMgr::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

//
// NOTE: This works only for single names; if multiple names are
// passed we die big time. This is help us get going using VB's _NewEnum
//

STDMETHODIMP
CAggregateeDispMgr::GetIDsOfNames(REFIID iid, LPWSTR *rgszNames,
        unsigned int cNames, LCID lcid, DISPID *rgdispid)
{
    PTYPEINFOENTRY pTypeInfo = NULL;
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    // Try our list of TypeInfos.
    //
    pTypeInfo = _pTypeInfoEntry;
    while (pTypeInfo) {
        hr = DispGetIDsOfNames(((ITypeInfo *)pTypeInfo->ptypeinfo),
                                rgszNames,
                                cNames,
                                rgdispid
                                );
        if (SUCCEEDED(hr)) {

            // 
            // aggregatee no longer needs to include extension id
            // in dispid.  
            //

            MakeDISPIDs(0, pTypeInfo->TypeInfoId, rgdispid, cNames);
            return hr;
        }
        pTypeInfo = pTypeInfo->pNext;
    }

    //
    // Try our property cache.
    //
    if (FAILED(hr) && _pPropertyCache) {
	hr = S_OK;
	for (DWORD dw = 0; dw < cNames; dw++) {
	    if (FAILED(_pPropertyCache->locateproperty(rgszNames[dw],
		    (PDWORD)(rgdispid + dw)))) {
		hr = DISP_E_UNKNOWNNAME;
		rgdispid[dw] = DISPID_UNKNOWN;
	    }
	}
	if (SUCCEEDED(hr)) {

            // 
            // aggregatee no longer needs to include extension id
            // in dispid.  
            //

	    MakeDISPIDs(0, _dwPropCacheID, rgdispid, cNames);
	}
    }

    return hr;
}

STDMETHODIMP
CAggregateeDispMgr::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,
	unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
	EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
        //
        // Clear the error object before we call invoke.
        //
        SetErrorInfo(0, NULL);

        return TypeInfoInvoke(dispidMember,
                               iid,
                               lcid,
                               wFlags,
                               pdispparams,
                               pvarResult,
                               pexcepinfo,
                               puArgErr
                               );
}

//////////////////////////////////////////////////////////////////////////////
//
// Private methods and helper functions:

void *
CAggregateeDispMgr::getInterfacePtr(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (pTypeInfoEntry ? pTypeInfoEntry->pInterfacePointer : NULL);
}

ITypeInfo *
CAggregateeDispMgr::getTypeInfo(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (ITypeInfo *)(pTypeInfoEntry ? pTypeInfoEntry->ptypeinfo : NULL);
}

PTYPEINFOENTRY
CAggregateeDispMgr::FindTypeInfoEntry(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->TypeInfoId == TypeInfoId) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

PTYPEINFOENTRY
CAggregateeDispMgr::FindTypeInfo(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->ptypeinfo == pTypeInfo) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

HRESULT
CAggregateeDispMgr::AddTypeInfo(void *ptypeinfo, void *pIntfptr)
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    HRESULT hr;

    if (FindTypeInfo(ptypeinfo)) {
        return E_FAIL;
    }
    pTypeInfoEntry = (PTYPEINFOENTRY)LocalAlloc(LPTR,sizeof(TYPEINFOENTRY));
    if (!pTypeInfoEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTypeInfoEntry->ptypeinfo = ptypeinfo;
    pTypeInfoEntry->TypeInfoId = gentypeinfoid();
    pTypeInfoEntry->pInterfacePointer = pIntfptr;

    pTypeInfoEntry->pNext = _pTypeInfoEntry;
    _pTypeInfoEntry = pTypeInfoEntry;

    return S_OK;

Exit:
    return hr;
}

STDMETHODIMP
CAggregateeDispMgr::TypeInfoInvoke(DISPID dispidMember, REFIID iid, LCID lcid,
	unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
	EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
    void *pInterfacePtr = NULL;
    DISPID dispid = 0;
    DISPID typeinfoid = 0;
    ITypeInfo *pTypeInfo = NULL;
    HRESULT hr = S_OK;

    if (dispidMember <= 0) {

    	//
	    // One of the special DISPIDs.
	    //
	    // If we have an interface pointer for it, use that.
	    // If we don't, and we have a base IDispatch pointer,
	    //   pass it to the base pointer's Invoke() method.
	    // If we don't, and we don't have a base IDispatch pointer,
	    //   return failure.
	    //

        dispid = dispidMember;
        switch (dispid) {

        case DISPID_VALUE:
            if (_pDispidValue) {
                pTypeInfo = (ITypeInfo *)_pDispidValue->ptypeinfo;
                pInterfacePtr = _pDispidValue->pInterfacePointer;
            }
	    break;

        case DISPID_NEWENUM:
            if (_pDispidNewEnum) {
                pTypeInfo = (ITypeInfo *)_pDispidNewEnum->ptypeinfo;
                pInterfacePtr = _pDispidNewEnum->pInterfacePointer;
            }
            break;

        default:
            break;
        }

	    if (!pInterfacePtr) {

	        BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);

	    }else {

            //
            // Fill in the special case scenarios here
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );

            return(hr);

        }

    } else {

        //                           	
	    // A regular DISPID of ours.
	    //

        typeinfoid = getTypeInfoId(dispidMember);
        dispid = getDispId(dispidMember);

	    if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {
	        pInterfacePtr = getInterfacePtr(typeinfoid);
	        pTypeInfo = getTypeInfo(typeinfoid);
	        if (!pTypeInfo)
		        //
		    // Shouldn't happen.
		    //
		    BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
	    }

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {

            //
            // A regular interface.
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        }else {

            //
            // A "dynamic DISPID", for the property cache.
            //

            hr = AggregateeDynamicDispidInvoke(
                        _pPropertyCache,
                        dispid,
                        wFlags,
                        pdispparams,
                        pvarResult
                        );

        }

    }

Exit:
    return hr;
}


HRESULT
AggregateeDynamicDispidInvoke(
    IPropertyCache * pPropertyCache,
    DISPID  dispid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT * pvarResult
    )
{
    HRESULT hr = S_OK;

    if (!pPropertyCache) {

        return(E_INVALIDARG);
    }

    if (wFlags & DISPATCH_PROPERTYGET) {

        if (!pvarResult) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        hr = pPropertyCache->getproperty((DWORD)dispid,pvarResult);

        if (FAILED(hr)) {

#if 1
            // This lets us return S_OK and a VT_EMPTY variant if
            // there's no data.  #if this out to disable it.
            V_VT(pvarResult) = VT_EMPTY;
            hr = S_OK;
#else

            V_VT(pvarResult) = VT_ERROR;
#endif

        }
    }else if (wFlags & DISPATCH_PROPERTYPUT) {

        if (pdispparams[0].cArgs != 1){
            //
            // We only handle one arg for now
            //
            hr = DISP_E_BADPARAMCOUNT;
        }
        else {

            hr = pPropertyCache->putproperty(
                        (DWORD)dispid,
                        pdispparams[0].rgvarg[0]
                        );
        }

    }else {
        hr = E_INVALIDARG;
    }

Exit:
    return(hr);

}


HRESULT
CAggregateeDispMgr::MarkAsNewEnum(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidNewEnum = pTypeInfoEntry;
    return S_OK;
}

HRESULT
CAggregateeDispMgr::MarkAsItem(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidValue = pTypeInfoEntry;
    return S_OK;
}

LONG
CAggregateeDispMgr::gentypeinfoid()
{
    //
    // This would mean we've registered 65536 IDispatch methods
    //   in this object's dispatch manager.  We lose.
    //
    DispMgrAssert(_dwTypeInfoId < 0xffff);

    return (_dwTypeInfoId++);
}

typedef struct _typeinfotable
{
    GUID iid;
    ITypeInfo * pTypeInfo;
    struct _typeinfotable *pNext;
}TYPEINFO_TABLE, *PTYPEINFO_TABLE;


PTYPEINFO_TABLE gpAggregateeTypeInfoTable = NULL;

ITypeInfo *
AggregateeFindTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = pTypeInfoTable;

    while (pTemp) {
        if (IsEqualIID(iid, pTemp->iid)) {
            return pTemp->pTypeInfo;
        }
        pTemp = pTemp->pNext;
    }
    return NULL;
}


PTYPEINFO_TABLE
AggregateeAddTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid,
    ITypeInfo * pTypeInfo
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = (PTYPEINFO_TABLE)LocalAlloc(LPTR, sizeof(TYPEINFO_TABLE));
    if (!pTemp) {
        return NULL;
    }

    memcpy(&pTemp->iid, &iid, sizeof(GUID));
    pTemp->pTypeInfo = pTypeInfo;
    pTemp->pNext = pTypeInfoTable;

    return pTemp;
}

//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
AggregateeLoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    DispMgrAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (hr)
        return hr;

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    return hr;
}

HRESULT
CAggregateeDispMgr::LoadTypeInfoEntry(
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT hr;

    pTypeInfo = ::AggregateeFindTypeInfo(gpAggregateeTypeInfoTable, iid);
    if (!pTypeInfo) {

        hr = AggregateeLoadTypeInfo(libid, iid, &pTypeInfo);
        BAIL_ON_FAILURE(hr);

        gpAggregateeTypeInfoTable = ::AggregateeAddTypeInfo(gpAggregateeTypeInfoTable, iid, pTypeInfo);
        if (!gpAggregateeTypeInfoTable) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }
    }
// this caused a BVT break, putting back in
// awetmore - 83980
// in svcs\adsi\adsiis you can see that IIS has removed this as well
    pTypeInfo->AddRef();


    hr = AddTypeInfo(pTypeInfo, pIntf);
    BAIL_ON_FAILURE(hr);

    if (SpecialId == -4) {
	hr = MarkAsNewEnum(pTypeInfo);
    } else if (SpecialId == DISPID_VALUE) {
	hr = MarkAsItem(pTypeInfo);
    }

    return S_OK;

Exit:
    if (pTypeInfo)
	pTypeInfo->Release();

    return hr;
}

//
// Kept for backwards compatibility.
//
HRESULT
LoadTypeInfoEntry(
    CAggregateeDispMgr *pDispMgr,
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    return pDispMgr->LoadTypeInfoEntry(libid, iid, pIntf, SpecialId);
}

void
AggregateeFreeTypeInfoTable()
{
    PTYPEINFO_TABLE pTypeInfoTable = NULL;
    PTYPEINFO_TABLE pTemp = NULL;
    ITypeInfo * pTypeInfo = NULL;

    pTypeInfoTable = gpAggregateeTypeInfoTable;

    while (pTypeInfoTable) {

        pTypeInfo = pTypeInfoTable->pTypeInfo;

        pTypeInfo->Release();


        pTemp = pTypeInfoTable;

        pTypeInfoTable = pTypeInfoTable->pNext;

        LocalFree(pTemp);
    }
}

HRESULT
CAggregateeDispMgr::InitializeDispMgr(
    DWORD dwExtensionID
    )
{
    if (dwExtensionID > 255) {
        return(E_FAIL);
    }
    _dwExtensionID = dwExtensionID;

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\cmacro.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cmacro.h
//
//  Contents:  Macros for adsi methods
//
//  History:   21-04-97     sophiac    Created.
//
//----------------------------------------------------------------------------

#define DEFINE_CONTAINED_IADs_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_Name(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                              \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_ADsPath(retval));                            \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_Class(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Parent(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Schema(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_GUID(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                    \
{                                                                     \
    RRETURN(_pADs->Get(bstrName, pvProp));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                          \
{                                                                     \
    RRETURN(_pADs->Put(bstrName, vProp));                             \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                  \
{                                                                     \
    RRETURN(_pADs->GetEx(bstrName, pvProp));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)    \
{                                                                     \
    RRETURN(_pADs->PutEx(lnControlCode, bstrName, vProp));            \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetInfo(THIS_)                                                   \
{                                                                     \
    RRETURN(_pADs->GetInfo());                                        \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::SetInfo(THIS_ )                                                  \
{                                                                     \
    RRETURN(_pADs->SetInfo());                                        \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(_pADs->GetInfoEx(vProperties, lnReserved));               \
}


#define DEFINE_CONTAINED_IDSObject_Implementation(cls)                \
STDMETHODIMP                                                          \
cls::SetObjectAttributes(                                             \
    PADS_ATTR_DEF pAttributeEntries,                                  \
    DWORD dwNumAttributes,                                            \
    DWORD *pdwNumAttributesModified                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->SetObjectAttributes(                             \
                        pAttributeEntries,                            \
                        dwNumAttributes,                              \
                        pdwNumAttributesModified                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectAttributes(                                             \
    PADS_ATTR_NAME pAttributeNames,                                   \
    DWORD dwNumberAttributes,                                         \
    PADS_ATTR_DEF *ppAttributeEntries,                                \
    DWORD * pdwNumAttributesReturned                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectAttributes(                             \
                        pAttributeNames,                              \
                        dwNumberAttributes,                           \
                        ppAttributeEntries,                           \
                        pdwNumAttributesReturned                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateDSObject(                                                  \
    LPWSTR pszRDNName,                                                \
    PADS_ATTR_DEF pAttributeEntries,                                  \
    DWORD dwNumAttributes                                             \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->CreateDSObject(                                  \
                        pszRDNName,                                   \
                        pAttributeEntries,                            \
                        dwNumAttributes                               \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteDSObject(                                                  \
    LPWSTR pszRDNName                                                 \
    )                                                                 \
                                                                      \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->DeleteDSObject(                                  \
                        pszRDNName                                    \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectInformation(                                            \
    THIS_ PADS_OBJECT_INFO  *  ppObjInfo                              \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectInformation(                            \
                            ppObjInfo                                 \
                            );                                        \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IADsContainer_Implementation(cls)          \
STDMETHODIMP                                                          \
cls::get_Filter(THIS_ VARIANT FAR* pVar )                             \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Filter( pVar );                    \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::put_Filter(THIS_ VARIANT Var )                                   \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->put_Filter( Var );                     \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Hints(THIS_ VARIANT FAR* pVar )                              \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Hints( pVar );                     \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::put_Hints(THIS_ VARIANT Var )                                    \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->put_Hints( Var );                      \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Count(THIS_ long FAR* retval)                                \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Count( retval );                   \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get__NewEnum(THIS_ IUnknown * FAR * retval )                     \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get__NewEnum( retval );                \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObject(THIS_ BSTR ClassName, BSTR RelativeName,               \
               IDispatch * FAR * ppObject )                           \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->GetObject( ClassName, RelativeName, ppObject ); \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Create(THIS_ BSTR ClassName, BSTR RelativeName,                  \
            IDispatch * FAR * ppObject )                               \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr =_pADsContainer->Create( ClassName, RelativeName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Delete(THIS_ BSTR ClassName, BSTR SourceName )                   \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->Delete( ClassName, SourceName );       \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::CopyHere(THIS_ BSTR SourceName, BSTR NewName,                    \
              IDispatch * FAR * ppObject )                            \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                           \
        hr = _pADsContainer->CopyHere( SourceName, NewName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::MoveHere(THIS_ BSTR SourceName, BSTR NewName,                    \
              IDispatch * FAR * ppObject )                            \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                           \
        hr = _pADsContainer->MoveHere( SourceName, NewName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     

#define DEFINE_CONTAINED_IIsBaseObject_Implementation(cls)            \
STDMETHODIMP                                                          \
cls::GetDataPaths(THIS_ BSTR bstrName, LONG lnAttribute,              \
                  VARIANT FAR* pvProp)                                \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pIIsBaseObject) {                                           \
        hr = _pIIsBaseObject->GetDataPaths( bstrName, lnAttribute, pvProp);   \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetPropertyAttribObj(THIS_ BSTR bstrName,                        \
                          IDispatch * FAR *ppObject)                  \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pIIsBaseObject) {                                           \
        hr = _pIIsBaseObject->GetPropertyAttribObj(bstrName, ppObject); \
    }                                                                 \
    RRETURN(hr);                                                      \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\cmultisz.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	cmultisz.cpp

Abstract:

	Defines a class for manipulating registry style Multi-Sz's.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "cmultisz.h"

DWORD CMultiSz::Count ( ) const
{
	TraceQuietEnter ( "CMultiSz::Count" );

	LPCWSTR	msz		= m_msz;
	DWORD	cCount	= 0;

	_ASSERT ( m_msz );

	// this loop doesn't count \0\0 correctly, so that's a special case:
	if ( msz[0] == NULL && msz[1] == NULL ) {
		return 0;
	}

	do {

		cCount++;
		while ( *msz++ != NULL )
			// Empty while
			;

	} while ( *msz );

	return cCount;
}

HRESULT CMultiSz::ToVariant ( VARIANT * pvar ) const
{
	TraceFunctEnter ( "CMultiSz::ToVariant" );

	HRESULT			hr			= NOERROR;
	SAFEARRAY *		psaResult	= NULL;
	DWORD			cStrings;
	DWORD			i;

	cStrings = Count ();

	if ( cStrings == 0 ) {
		V_VT ( pvar ) = VT_EMPTY;
	}
	else {
		// Allocate a safearray of that size:
		SAFEARRAYBOUND	rgsaBounds[1];
		LPCWSTR			wszCurrent;

		rgsaBounds[0].cElements	= cStrings;
		rgsaBounds[0].lLbound	= 0;

		psaResult = SafeArrayCreate ( VT_VARIANT, 1, rgsaBounds );
		if ( !psaResult ) {
			FatalTrace ( (LPARAM) this, "Failed to allocate array" );
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		// Assign each member to the array:
		for ( 	wszCurrent = m_msz, i = 0; 
				i < cStrings; 
				i++, wszCurrent += lstrlen (wszCurrent) + 1 ) {

			_ASSERT ( wszCurrent && *wszCurrent );
			_ASSERT ( IS_VALID_STRING ( wszCurrent ) );

			long		rgIndex[1];
			BSTR		strCopy;
			VARIANT  	varCurrent;

			// !!!magnush - memory leak here???
			strCopy = ::SysAllocString ( wszCurrent );
			if ( strCopy == NULL ) {
				FatalTrace ( (LPARAM) this, "Out of memory" );
				hr = E_OUTOFMEMORY;
				goto Exit;
			}

			VariantInit ( &varCurrent );
			V_VT ( &varCurrent )	= VT_BSTR;
			V_BSTR ( &varCurrent )	= strCopy;

			rgIndex[0] = i;
			hr = SafeArrayPutElement ( psaResult, rgIndex, &varCurrent );

			if ( FAILED(hr) ) {
				ErrorTraceX ( (LPARAM) this, "Failed to allocate element[%d]: %x", i, hr );
				goto Exit;
			}
		}

		V_VT ( pvar )		= VT_ARRAY | VT_VARIANT;
		V_ARRAY ( pvar )	= psaResult;
	}

Exit:
	if ( FAILED(hr) ) {
		if ( psaResult != NULL ) {
			SafeArrayDestroy ( psaResult );
		}
	}

	TraceFunctLeave ();
	return hr;
}

HRESULT CMultiSz::FromVariant ( const VARIANT * pvar )
{
	TraceFunctEnter ( "CMultiSz::FromVariant" );

	HRESULT		hr			= NOERROR;
	SAFEARRAY *	psaStrings	= NULL;
	long		nLowerBound	= 0;
	long		nUpperBound	= -1;
	DWORD		cch			= 0;
	LPWSTR		mszResult	= NULL;
	LPWSTR		wszCopyTo;
	long		i;

	if ( V_VT ( pvar ) == VT_EMPTY ) {
		mszResult = CreateEmptyMultiSz ();
		if ( !mszResult ) {
			BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
		}
		goto Exit;
	}

	if ( V_VT ( pvar ) != (VT_ARRAY | VT_VARIANT) ) {
		BAIL_WITH_FAILURE ( hr, E_INVALIDARG );
	}

	psaStrings = V_ARRAY ( pvar );

	_ASSERT ( SafeArrayGetDim ( psaStrings ) == 1 );

	// Count the number of characters needed for the multi_sz:
	hr = SafeArrayGetLBound ( psaStrings, 1, &nLowerBound );
	_ASSERT ( SUCCEEDED(hr) );

	hr = SafeArrayGetUBound ( psaStrings, 1, &nUpperBound );
	_ASSERT ( SUCCEEDED(hr) );

	//
	//	Special case: The empty array:
	//
	if ( nLowerBound > nUpperBound ) {
		mszResult = CreateEmptyMultiSz ();
		if ( !mszResult ) {
			BAIL_WITH_FAILURE ( hr, E_OUTOFMEMORY );
		}
		goto Exit;
	}

	cch = 0;
	for ( i = nLowerBound; i <= nUpperBound; i++ ) {
		long				rgIndex[1];
		HRESULT				hr1, hr2, hr3;
		const VARIANT *		pvarCurrent	= NULL;
		CComVariant 		varString;
		LPCWSTR				wszCurrent;

		rgIndex[0] = i;

		hr1 = SafeArrayLock			( psaStrings );
		hr2 = SafeArrayPtrOfIndex	( psaStrings, rgIndex, (void **) &pvarCurrent );
		hr3 = SafeArrayUnlock		( psaStrings );

		_ASSERT ( SUCCEEDED(hr1) );
		_ASSERT ( SUCCEEDED(hr2) );
		_ASSERT ( SUCCEEDED(hr3) );

		if ( FAILED(hr1) || FAILED(hr2) || FAILED(hr3) || !pvarCurrent ) {
			hr = E_INVALIDARG;
			goto Exit;
		}

		hr = VariantChangeType ( &varString, const_cast<VARIANT *>(pvarCurrent), 0, VT_BSTR );
		BAIL_ON_FAILURE(hr);

		_ASSERT ( V_VT ( &varString ) == VT_BSTR );

		wszCurrent = V_BSTR ( &varString );
		_ASSERT ( IS_VALID_STRING ( wszCurrent ) );

		cch += lstrlen ( wszCurrent ) + 1;
	}
	// Add the final NULL terminator:
	cch += 1;

	// Allocate a multi_sz of that size:
	mszResult	= new WCHAR [ cch ];

	if ( mszResult == NULL ) {
		goto Exit;
	}

	wszCopyTo = mszResult;

	// Copy each string into the multi_sz:

	for ( i = nLowerBound; i <= nUpperBound; i++ ) {
		long				rgIndex[1];
		HRESULT				hr1, hr2, hr3;
		const VARIANT *		pvarCurrent = NULL;
		CComVariant 		varString;
		LPCWSTR				wszCurrent;

		rgIndex[0] = i;

		hr1 = SafeArrayLock			( psaStrings );
		hr2 = SafeArrayPtrOfIndex	( psaStrings, rgIndex, (void **) &pvarCurrent );
		hr3 = SafeArrayUnlock		( psaStrings );

		_ASSERT ( SUCCEEDED(hr1) );
		_ASSERT ( SUCCEEDED(hr2) );
		_ASSERT ( SUCCEEDED(hr3) );

		if ( FAILED(hr1) || FAILED(hr2) || FAILED(hr3) || !pvarCurrent ) {
			hr = E_INVALIDARG;
			goto Exit;
		}

		hr = VariantChangeType ( &varString, const_cast<VARIANT *>(pvarCurrent), 0, VT_BSTR );
		BAIL_ON_FAILURE(hr);

		_ASSERT ( V_VT ( &varString ) == VT_BSTR );

		wszCurrent = V_BSTR ( &varString );
		_ASSERT ( IS_VALID_STRING ( wszCurrent ) );

		lstrcpy ( wszCopyTo, wszCurrent );
		wszCopyTo += lstrlen ( wszCurrent ) + 1;
	}
	// Add the final NULL terminator:
	*wszCopyTo = NULL;

	_ASSERT ( CountChars ( mszResult ) == cch );

	_ASSERT ( SUCCEEDED(hr) );

Exit:
	if ( FAILED(hr) ) {
		delete mszResult;
	}

	if ( SUCCEEDED(hr) ) {
		delete m_msz;
		m_msz = mszResult;
	}

	TraceFunctLeave ();
	return hr;
}

SAFEARRAY * CMultiSz::ToSafeArray ( ) const
{
	TraceFunctEnter ( "CMultiSz::ToSafeArray" );

	SAFEARRAY *		psaResult	= NULL;
	DWORD			cCount		= 0;
	HRESULT			hr			= NOERROR;
	DWORD			i;
	const WCHAR *	wszCurrent	= NULL;

	if ( m_msz == NULL ) {
		goto Exit;
	}

	_ASSERT ( IS_VALID_STRING ( m_msz ) );

	// Get the array size:
	cCount = Count ();

	// Allocate a safearray of that size:
	SAFEARRAYBOUND	rgsaBounds[1];

	rgsaBounds[0].cElements	= cCount;
	rgsaBounds[0].lLbound	= 0;

	psaResult = SafeArrayCreate ( VT_BSTR, 1, rgsaBounds );

	if ( !psaResult ) {
		FatalTrace ( (LPARAM) this, "Failed to allocate array" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// Assign each member to the array:
	for ( 	wszCurrent = m_msz, i = 0; 
			i < cCount; 
			i++, wszCurrent += lstrlen (wszCurrent) + 1 ) {

		_ASSERT ( wszCurrent && *wszCurrent );
		_ASSERT ( IS_VALID_STRING ( wszCurrent ) );

		long	rgIndex[1];
		BSTR	strCopy;

		strCopy = ::SysAllocString ( wszCurrent );
		if ( strCopy == NULL ) {
			FatalTrace ( (LPARAM) this, "Out of memory" );
			goto Exit;
		}

		rgIndex[0] = i;
		hr = SafeArrayPutElement ( psaResult, rgIndex, (void *) strCopy );

		if ( FAILED(hr) ) {
			ErrorTraceX ( (LPARAM) this, "Failed to allocate element[%d]: %x", i, hr );
			FatalTrace ( (LPARAM) this, "Out of memory" );
			goto Exit;
		}
	}

Exit:
	// If something went wrong, free the resulting safe array:
	if ( FAILED(hr) ) {
		if ( psaResult ) {
			SafeArrayDestroy ( psaResult );
            psaResult = NULL;
		}
	}

	TraceFunctLeave ();
	return psaResult;
}

void CMultiSz::FromSafeArray ( SAFEARRAY * psaStrings )
{
	TraceFunctEnter ( "CMultiSz::FromSafeArray" );

	HRESULT		hr	= NOERROR;
	LPWSTR		msz = NULL;
	DWORD		cch	= 0;
	long		i;
	long		nLowerBound;
	long		nUpperBound;
	LPCWSTR *	pwszCurrent;
	LPWSTR		wszCopyTo;

	if ( psaStrings == NULL ) {
		m_msz	= NULL;
		goto Exit;
	}

	_ASSERT ( SafeArrayGetDim ( psaStrings ) == 1 );

	// Count the number of characters needed for the multi_sz:
	hr = SafeArrayGetLBound ( psaStrings, 1, &nLowerBound );
	_ASSERT ( SUCCEEDED(hr) );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = SafeArrayGetUBound ( psaStrings, 1, &nUpperBound );
	_ASSERT ( SUCCEEDED(hr) );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	//
	//	Special case: The empty array:
	//
	if ( nLowerBound > nUpperBound ) {
		WCHAR *		mszNew;

		mszNew = new WCHAR [2];

		if ( mszNew != NULL ) {
			delete m_msz;
			m_msz = mszNew;
			m_msz[0] = NULL;
			m_msz[1] = NULL;
		}
		goto Exit;
	}

	cch = 0;
	for ( i = nLowerBound; i <= nUpperBound; i++ ) {
		long		rgIndex[1];
		HRESULT		hr1, hr2, hr3;

		pwszCurrent = NULL;

		rgIndex[0] = i;

		hr1 = SafeArrayLock			( psaStrings );
		hr2 = SafeArrayPtrOfIndex	( psaStrings, rgIndex, (void **) &pwszCurrent );
		hr3 = SafeArrayUnlock		( psaStrings );

		_ASSERT ( SUCCEEDED(hr1) );
		_ASSERT ( SUCCEEDED(hr2) );
		_ASSERT ( SUCCEEDED(hr3) );

		_ASSERT ( IS_VALID_STRING ( *pwszCurrent ) );

		if ( FAILED(hr1) || FAILED(hr2) || FAILED(hr3) || !*pwszCurrent ) {
			goto Exit;
		}

		cch += lstrlen ( *pwszCurrent ) + 1;
	}
	// Add the final NULL terminator:
	cch += 1;

	// Allocate a multi_sz of that size:
	msz	= new WCHAR [ cch ];

	if ( msz == NULL ) {
		goto Exit;
	}

	wszCopyTo = msz;

	// Copy each string into the multi_sz:

	for ( i = nLowerBound; i <= nUpperBound; i++ ) {
		long		rgIndex[1];
		HRESULT		hr1, hr2, hr3;

		pwszCurrent = NULL;

		rgIndex[0] = i;

		hr1 = SafeArrayLock			( psaStrings );
		hr2 = SafeArrayPtrOfIndex	( psaStrings, rgIndex, (void **) &pwszCurrent );
		hr3 = SafeArrayUnlock		( psaStrings );

		_ASSERT ( SUCCEEDED(hr1) );
		_ASSERT ( SUCCEEDED(hr2) );
		_ASSERT ( SUCCEEDED(hr3) );

		_ASSERT ( IS_VALID_STRING ( *pwszCurrent ) );

		if ( FAILED(hr1) || FAILED(hr2) || FAILED(hr3) || !*pwszCurrent ) {
			hr = E_FAIL; //Set HR so msz is deleted (prefix bug)
			goto Exit;
		}

		lstrcpy ( wszCopyTo, *pwszCurrent );
		wszCopyTo += lstrlen ( *pwszCurrent ) + 1;
	}
	// Add the final NULL terminator:
	*wszCopyTo = NULL;

	_ASSERT ( CountChars ( msz ) == cch );

	_ASSERT ( SUCCEEDED(hr) );
	delete m_msz;
	m_msz = msz;

Exit:
	if ( FAILED(hr) && msz) {
		delete msz;
	}

	TraceFunctLeave ();
	return;
}

DWORD CMultiSz::CountChars ( LPCWSTR mszSource )
{
	TraceQuietEnter ( "CMultiSz::CountChars" );

	DWORD		cch	= 0;
	LPCWSTR		msz	= mszSource;

	// _ASSERT ( msz is a multi sz string )
	_ASSERT ( IS_VALID_STRING ( msz ) );

	do {

		while ( *msz != NULL ) {
			msz++;
			cch++;
		}

		// Count the NULL terminator:
		msz++;
		cch++;
	
	} while ( *msz );

	// Count the NULL terminator:
	cch++;

	_ASSERT ( !IsBadReadPtr ( mszSource, cch * sizeof (WCHAR) ) );

	_ASSERT ( mszSource[cch - 1] == NULL );
	_ASSERT ( mszSource[cch - 2] == NULL );

	return cch;
}

LPWSTR CMultiSz::Duplicate ( LPCWSTR msz )
{
	TraceQuietEnter ( "CMultiSz::Duplicate" );

	LPWSTR	mszResult	= NULL;
	DWORD	cch			= 0;

	if ( msz == NULL ) {
		goto Exit;
	}

	cch = CountChars ( msz );

	mszResult = new WCHAR [ cch ];

	if ( mszResult == NULL ) {
		goto Exit;
	}

	CopyMemory ( mszResult, msz, cch * sizeof (WCHAR) );

	_ASSERT ( cch == CountChars ( mszResult ) );

Exit:
	return mszResult;
}

LPWSTR CMultiSz::CreateEmptyMultiSz ( )
{
	LPWSTR		mszResult;

	mszResult = new WCHAR [ 2 ];
	if ( mszResult ) {
		mszResult[0] = _T('\0');
		mszResult[1] = _T('\0');
	}

	return mszResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\macro.h ===
//
//              This NonDelegating interface is completely for 3rd-party 
//              extension objects based on our implementation only. NO need 
//              to export to ADISclients or 3rd part writer or typelib.  
//              Will put it here for now. Move -> ?? 
//

#ifndef _INonDelegatingUnknown
#define _INonDelegatingUnknown
interface INonDelegatingUnknown
{
    virtual HRESULT STDMETHODCALLTYPE
    NonDelegatingQueryInterface(const IID&, void **) = 0; 

    virtual ULONG STDMETHODCALLTYPE 
    NonDelegatingAddRef() = 0;

    virtual ULONG STDMETHODCALLTYPE 
    NonDelegatingRelease() = 0;
};
#endif


#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);




#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}

#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}

#define DEFINE_IADsPutGet_UnImplementation(cls)                          \
STDMETHODIMP                                                             \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                             \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                     \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}


#define DEFINE_IPrivateDispatch_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::ADSIGetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ADSIGetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::ADSIGetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ADSIInvoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}


#define DEFINE_IADsExtension_Implementation(cls)                        \
STDMETHODIMP                                                            \
cls::PrivateGetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,            \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)           \
{                                                                       \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                           \
                                         rgszNames,                     \
                                         cNames,                        \
                                         lcid,                          \
                                         rgdispid                       \
                                         ));                            \
}                                                                       \
                                                                        \
STDMETHODIMP                                                            \
cls::PrivateInvoke(DISPID dispidMember, REFIID iid, LCID lcid,          \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,             \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,             \
        unsigned int FAR* puArgErr)                                     \
{                                                                       \
        RRETURN (_pDispMgr->Invoke(dispidMember,                        \
                                   iid,                                 \
                                   lcid,                                \
                                   wFlags,                              \
                                   pdispparams,                         \
                                   pvarResult,                          \
                                   pexcepinfo,                          \
                                   puArgErr                             \
                                   ));                                  \
}


#define DEFINE_DELEGATING_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
	if (_pADs == (LPVOID)this)                                        \
	{                                                                 \
        RRETURN(ADSIGetTypeInfoCount(pctinfo));                       \
	}                                                                 \
	else                                                              \
	{                                                                 \
        RRETURN(_pADs->GetTypeInfoCount(pctinfo));                    \
	}                                                                 \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
	if (_pADs == (LPVOID)this)                                        \
	{                                                                 \
        RRETURN(ADSIGetTypeInfo(itinfo,                               \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
	}                                                                 \
	else                                                              \
	{                                                                 \
        RRETURN(_pADs->GetTypeInfo(itinfo,                            \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
	}                                                                 \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
	if (_pADs == (LPVOID)this)                                        \
	{                                                                 \
        RRETURN(ADSIGetIDsOfNames(iid,                                \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
	}                                                                 \
	else                                                              \
	{                                                                 \
        RRETURN(_pADs->GetIDsOfNames(iid,                             \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
	}                                                                 \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
	if (_pADs == (LPVOID)this)                                        \
	{                                                                 \
        RRETURN (ADSIInvoke(dispidMember,                             \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
	}                                                                 \
	else                                                              \
	{                                                                 \
        RRETURN (_pADs->Invoke(dispidMember,                          \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
	}                                                                 \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\guids.cpp ===
//
//  Keep the top part in sync with stdafx.h
//


#pragma warning( disable : 4511 )

#include <ctype.h>
extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

//
//  ATL:
//

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <atlimpl.cpp>

//
//  GUIDS:
//

#define INITGUIDS
#include "initguid.h"

#include <iadm.h>

#include <iads.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\metakey.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metakey.h

Abstract:

	CMetabaseKey - A class to help manipulate metabase keys.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _METAKEY_INCLUDED_
#define _METAKEY_INCLUDED_

//
// Creating a metabase object:
//

HRESULT CreateMetabaseObject ( LPCWSTR wszMachine, IMSAdminBase ** ppMetabase );

//
//	The metabase key class:
//

typedef BOOL (*KEY_TEST_FUNCTION) ( LPCWSTR szKey );

class CMetabaseKey
{
public:
	CMetabaseKey	( IMSAdminBase * pMetabase );
	~CMetabaseKey	( );

	//
	// METADATA_HANDLE manipulation:
	//

	inline HRESULT	Open	( IN LPCWSTR szPath, DWORD dwPermissions = METADATA_PERMISSION_READ );
	HRESULT			Open	( IN METADATA_HANDLE hParentKey, IN LPCWSTR szPath, DWORD dwPermissions = METADATA_PERMISSION_READ );
	void			Attach	( METADATA_HANDLE hKey );
	METADATA_HANDLE	Detach	( );
	void			Close 	( );

	HRESULT			EnumObjects ( IN LPCWSTR wszPath, LPWSTR wszSubKey, DWORD dwIndex );
    HRESULT         ChangePermissions ( DWORD dwNewPermissions );
    HRESULT         DeleteKey ( IN LPCWSTR wszPath );
    HRESULT         DeleteAllData ( IN LPCWSTR wszPath = _T("") );

	void			GetLastChangeTime ( FILETIME * pftGMT, LPCWSTR wszPath = _T("") );
	HRESULT			Save	( );

	METADATA_HANDLE	QueryHandle ( ) { return m_hKey; }
	IMSAdminBase *	QueryMetabase ( ) { return m_pMetabase; }

	//
	// Getting metabase values:
	//

    inline HRESULT GetData		( LPCWSTR wszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType, VOID * pvData, DWORD * cbData, DWORD dwFlags );
    inline HRESULT GetDataSize	( LPCWSTR wszPath, DWORD dwPropID, DWORD dwDataType, DWORD * pcbSize, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );

    inline HRESULT GetDword		( LPCWSTR wszPath, DWORD dwPropID, DWORD * pdwValue, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT GetString	( LPCWSTR wszPath, DWORD dwPropID, LPWSTR wszValue, DWORD cbMax, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT GetMultiSz	( LPCWSTR wszPath, DWORD dwPropID, LPWSTR mszValue, DWORD cbMax, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT GetBinary	( LPCWSTR wszPath, DWORD dwPropID, void * pvData, DWORD cbMax, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );

	// These routines default to the current metabase key path:
    inline HRESULT GetDword		( DWORD dwPropID, DWORD * pdwValue, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT GetString	( DWORD dwPropID, LPWSTR wszValue, DWORD cbMax, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT GetMultiSz	( DWORD dwPropID, LPWSTR mszValue, DWORD cbMax, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT GetBinary	( DWORD dwPropID, void * pvData, DWORD cbMax, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );

	//
	// Setting metabase values:
	//

    inline HRESULT SetData		( LPCWSTR wszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType, VOID * pvData, DWORD cbData, DWORD dwFlags );

    inline HRESULT SetDword		( LPCWSTR wszPath, DWORD dwPropID, DWORD dwValue, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT SetString	( LPCWSTR wszPath, DWORD dwPropID, LPCWSTR wszValue, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT SetMultiSz	( LPCWSTR wszPath, DWORD dwPropID, LPCWSTR mszValue, DWORD cbData, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT SetBinary	( LPCWSTR wszPath, DWORD dwPropID, void * pvData, DWORD cbData, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );

	inline HRESULT DeleteData	( LPCWSTR wszPath, DWORD dwPropID, DWORD dwDataType );

	// These routines default to the current metabase key path:
    inline HRESULT SetDword		( DWORD dwPropID, DWORD dwValue, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT SetString	( DWORD dwPropID, LPCWSTR wszValue, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT SetMultiSz	( DWORD dwPropID, LPCWSTR mszValue, DWORD cbData, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT SetBinary	( DWORD dwPropID, void * pvData, DWORD cbData, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );

	inline HRESULT DeleteData	( DWORD dwPropID, DWORD dwDataType );


	//
	// Subkey manipulation:
	//

	HRESULT		GetChildCount			( OUT DWORD * pcChildren );
	HRESULT		GetIntegerChildCount	( OUT DWORD * pcIntegerChildren );
	HRESULT		GetCustomChildCount		( 
		IN KEY_TEST_FUNCTION func, 
		OUT DWORD * pcCustomChildren 
		);

	void		BeginChildEnumeration	( );
	HRESULT		NextChild				( OUT LPWSTR wszChildKey );
	HRESULT		NextIntegerChild		( OUT DWORD * pdwID, OUT LPWSTR wszIntegerChildKey );
	HRESULT		NextCustomChild			( 
		IN KEY_TEST_FUNCTION fpIsCustomKey, 
		OUT LPWSTR wszChildKey 
		);

	HRESULT		CreateChild			( IN LPWSTR wszChildPath );
	HRESULT		DestroyChild		( IN LPWSTR wszChildPath );
	HRESULT		CreateIntegerChild	( OUT DWORD * pdwID, OUT LPWSTR wszChildPath );
	HRESULT		DestroyIntegerChild	( IN DWORD i );

private:
	IMSAdminBase *		m_pMetabase;
	METADATA_HANDLE		m_hKey;

	DWORD				m_indexCursor;
	DWORD				m_cChildren;
	DWORD				m_cIntegerChildren;
	DWORD				m_dwMaxIntegerChild;

	HRESULT	CountSubkeys ( 
		IN  KEY_TEST_FUNCTION fpIsCustomKey,
		OUT DWORD * pcChildren, 
		OUT DWORD * pcIntegerChildren,
		OUT DWORD * pcCustomChildren, 
		OUT DWORD * pdwMaxIntegerChild 
		);
};

//--------------------------------------------------------------------
//
//	Inlined Functions:
//
//--------------------------------------------------------------------

inline HRESULT CMetabaseKey::Open ( IN LPCWSTR szPath, DWORD dwPermissions )
{
	return Open ( METADATA_MASTER_ROOT_HANDLE, szPath, dwPermissions );
}

//--------------------------------------------------------------------
//
//	Simple GetData wrappers:
//
//--------------------------------------------------------------------

inline HRESULT CMetabaseKey::GetDword ( LPCWSTR wszPath, DWORD dwPropID, DWORD * pdwValue, DWORD dwFlags, DWORD dwUserType )
{
	DWORD	dwDummy	= sizeof (DWORD);

	return GetData ( wszPath, dwPropID, dwUserType, DWORD_METADATA, pdwValue, &dwDummy, dwFlags );
}

inline HRESULT CMetabaseKey::GetString ( LPCWSTR wszPath, DWORD dwPropID, LPWSTR wszValue, DWORD cbMax, DWORD dwFlags, DWORD dwUserType )
{
	return GetData ( wszPath, dwPropID, dwUserType, STRING_METADATA, wszValue, &cbMax, dwFlags );
}

inline HRESULT CMetabaseKey::GetMultiSz ( LPCWSTR wszPath, DWORD dwPropID, LPWSTR mszValue, DWORD cbMax, DWORD dwFlags, DWORD dwUserType )
{
	return GetData ( wszPath, dwPropID, dwUserType, MULTISZ_METADATA, mszValue, &cbMax, dwFlags );
}

inline HRESULT CMetabaseKey::GetBinary ( LPCWSTR wszPath, DWORD dwPropID, void * pvData, DWORD cbMax, DWORD dwFlags, DWORD dwUserType )
{
	return GetData ( wszPath, dwPropID, dwUserType, BINARY_METADATA, pvData, &cbMax, dwFlags );
}

// These routines default to the current metabase key path:
inline HRESULT CMetabaseKey::GetDword ( DWORD dwPropID, DWORD * pdwValue, DWORD dwFlags, DWORD dwUserType )
{
	DWORD	dwDummy	= sizeof (DWORD);

	return GetData ( _T(""), dwPropID, dwUserType, DWORD_METADATA, pdwValue, &dwDummy, dwFlags );
}

inline HRESULT CMetabaseKey::GetString ( DWORD dwPropID, LPWSTR wszValue, DWORD cbMax, DWORD dwFlags, DWORD dwUserType )
{
	return GetData ( _T(""), dwPropID, dwUserType, STRING_METADATA, wszValue, &cbMax, dwFlags );
}

inline HRESULT CMetabaseKey::GetMultiSz ( DWORD dwPropID, LPWSTR mszValue, DWORD cbMax, DWORD dwFlags, DWORD dwUserType )
{
	return GetData ( _T(""), dwPropID, dwUserType, MULTISZ_METADATA, mszValue, &cbMax, dwFlags );
}

inline HRESULT CMetabaseKey::GetBinary ( DWORD dwPropID, void * pvData, DWORD cbMax, DWORD dwFlags, DWORD dwUserType )
{
	return GetData ( _T(""), dwPropID, dwUserType, BINARY_METADATA, pvData, &cbMax, dwFlags );
}

//--------------------------------------------------------------------
//
//	Simple SetData wrappers:
//
//--------------------------------------------------------------------

inline HRESULT CMetabaseKey::SetDword ( LPCWSTR wszPath, DWORD dwPropID, DWORD dwValue, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( wszPath, dwPropID, dwUserType, DWORD_METADATA, &dwValue, sizeof (DWORD), dwFlags );
}

inline HRESULT CMetabaseKey::SetString ( LPCWSTR wszPath, DWORD dwPropID, LPCWSTR wszValue, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( 
		wszPath, 
		dwPropID, 
		dwUserType, 
		STRING_METADATA, 
		(void *) wszValue, 
		sizeof (WCHAR) * (lstrlen ( wszValue ) + 1), 
		dwFlags 
		);
}

inline HRESULT CMetabaseKey::SetMultiSz ( LPCWSTR wszPath, DWORD dwPropID, LPCWSTR mszValue, DWORD cbData, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( wszPath, dwPropID, dwUserType, MULTISZ_METADATA, (void *) mszValue, cbData, dwFlags );
}

inline HRESULT CMetabaseKey::SetBinary ( LPCWSTR wszPath, DWORD dwPropID, void * pvData, DWORD cbData, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( wszPath, dwPropID, dwUserType, BINARY_METADATA, pvData, cbData, dwFlags );
}

// These routines default to the current metabase key path:
inline HRESULT CMetabaseKey::SetDword ( DWORD dwPropID, DWORD dwValue, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( _T(""), dwPropID, dwUserType, DWORD_METADATA, &dwValue, sizeof (DWORD), dwFlags );
}

inline HRESULT CMetabaseKey::SetString ( DWORD dwPropID, LPCWSTR wszValue, DWORD dwFlags, DWORD dwUserType )
{
	_ASSERT ( !IsBadStringPtr ( wszValue, -1 ) );

	return SetData ( 
		_T(""), 
		dwPropID, 
		dwUserType,
		STRING_METADATA, 
		(void *) wszValue, 
		sizeof (WCHAR) * ( lstrlen ( wszValue ) + 1 ),
		dwFlags
		);
}

inline HRESULT CMetabaseKey::SetMultiSz ( DWORD dwPropID, LPCWSTR mszValue, DWORD cbData, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( _T(""), dwPropID, dwUserType, MULTISZ_METADATA, (void *) mszValue, cbData, dwFlags );
}

inline HRESULT CMetabaseKey::SetBinary ( DWORD dwPropID, void * pvData, DWORD cbData, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( _T(""), dwPropID, dwUserType, BINARY_METADATA, pvData, cbData, dwFlags );
}

inline HRESULT CMetabaseKey::DeleteData ( DWORD dwPropID, DWORD dwDataType )
{
	return DeleteData ( _T(""), dwPropID, dwDataType );
}

inline HRESULT CMetabaseKey::DeleteData ( LPCWSTR wszPath, DWORD dwPropID, DWORD dwDataType )
{
	TraceQuietEnter ( "CMetabaseKey:DeleteData" );

	HRESULT		hRes;

	hRes = m_pMetabase->DeleteData ( m_hKey, wszPath, dwPropID, dwDataType );
	if ( hRes == MD_ERROR_DATA_NOT_FOUND ) {
		hRes = NOERROR;
	}

	//	Trace the error code:
	if ( FAILED(hRes) ) {
		ErrorTraceX ( 0, "DeleteData failed unexpectedly: Prop(%d) Error(%x)", dwPropID, hRes );
	}

	return hRes;
}

//--------------------------------------------------------------------
//
//	The real work - Set & Get arbitrary metadata:
//
//--------------------------------------------------------------------

inline HRESULT CMetabaseKey::GetDataSize ( 
	LPCWSTR		wszPath, 
	DWORD 		dwPropID, 
	DWORD		dwDataType,
	DWORD *		pcbSize, 
	DWORD		dwFlags, 
	DWORD		dwUserType
	)
{
	TraceQuietEnter ( "CMetabaseKey::GetDataSize" );

    HRESULT         hRes;
    METADATA_RECORD mdRecord;
    DWORD			dwDummy			= 0;
    DWORD           dwRequiredLen	= 0;

	_ASSERT ( !IsBadWritePtr ( pcbSize, sizeof (DWORD) ) );

    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = 0;
    mdRecord.pbMDData        = (PBYTE) &dwDummy;

    hRes = m_pMetabase->GetData( m_hKey,
                                      wszPath,
                                      &mdRecord,
                                      &dwRequiredLen );

    *pcbSize = dwRequiredLen;

	if ( HRESULTTOWIN32 ( hRes ) == ERROR_INSUFFICIENT_BUFFER ) {
		// Of course the buffer is too small!
		hRes = NOERROR;
	}

	//	Trace the error code:
	if ( FAILED(hRes) && hRes != MD_ERROR_DATA_NOT_FOUND ) {
		ErrorTraceX ( 0, "GetDataSize failed unexpectedly: Prop(%d) Error(%x)", dwPropID, hRes );
	}

    return hRes;
}

inline HRESULT CMetabaseKey::GetData (
	LPCWSTR  	pszPath,
	DWORD       dwPropID,
	DWORD       dwUserType,
	DWORD       dwDataType,
	VOID *      pvData,
	DWORD *     pcbData,
	DWORD       dwFlags )
{
	TraceQuietEnter ( "CMetabaseKey::GetData" );

    METADATA_RECORD mdRecord;
    HRESULT         hRes;
    DWORD           dwRequiredLen;

	_ASSERT ( !IsBadReadPtr ( pcbData, sizeof (DWORD) ) );
	_ASSERT ( !IsBadWritePtr ( pvData, *pcbData ) );

    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = *pcbData;
    mdRecord.pbMDData        = (PBYTE) pvData;

    hRes = m_pMetabase->GetData( m_hKey,
                                      pszPath,
                                      &mdRecord,
                                      &dwRequiredLen );

    if ( SUCCEEDED( hRes )) {
        *pcbData = mdRecord.dwMDDataLen;
    }
    else {
	    *pcbData = dwRequiredLen;
	}

	//	Trace the error code:
	if ( FAILED(hRes) && hRes != MD_ERROR_DATA_NOT_FOUND ) {
		ErrorTraceX ( 0, "GetData failed unexpectedly: Prop(%d) Error(%x)", dwPropID, hRes );
	}

    return hRes;
}

inline HRESULT CMetabaseKey::SetData ( 
	LPCWSTR 	pszPath,
	DWORD       dwPropID,
	DWORD       dwUserType,
	DWORD       dwDataType,
	VOID *      pvData,
	DWORD       cbData,
	DWORD       dwFlags )
{
	TraceQuietEnter ( "CMetabaseKey::SetData" );

    METADATA_RECORD mdRecord;
    HRESULT         hRes;

	_ASSERT ( !IsBadReadPtr ( pvData, cbData ) );

    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = cbData;
    mdRecord.pbMDData        = (PBYTE) pvData;

    hRes = m_pMetabase->SetData( m_hKey,
                                      pszPath,
                                      &mdRecord );

	//	Trace the error code:
	if ( FAILED(hRes) ) {
		ErrorTraceX ( 0, "GetData failed unexpectedly: Prop(%d) Error(%x)", dwPropID, hRes );
	}

	return hRes;
}

#endif // _METAKEY_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\regmacro.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	regmacro.h

Abstract:

	Useful macros to do registration stuff

Author:

	KeithLau			4/27/98			Created

Revision History:

--*/

#ifndef _REGMACRO_H_
#define _REGMACRO_H_

#define EXTENSION_BASE_PATH		_T("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\%s\\%s")
#define EXTENSION_BASE_PATH2	_T("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\%s")

typedef struct _EXT_REGISTRATION_INFO
{
	LPTSTR	szClassName;
	CLSID	*clsid;
	IID		*iid;

} EXT_REGISTRATION_INFO, *LPEXT_REGISTRATION_INFO;

extern EXT_REGISTRATION_INFO	rgRegistrationInfo[];
extern DWORD					dwRegistrationInfo;

//
// Declare the start of the extension registration entries
//
#define BEGIN_EXTENSION_REGISTRATION_MAP			\
EXT_REGISTRATION_INFO rgRegistrationInfo[] = {

//
// Declare each entry of extensions
//
#define EXTENSION_REGISTRATION_MAP_ENTRY(ClassName, BaseName)\
	{ _T(#ClassName), (CLSID *)&CLSID_C##BaseName, (IID *)&IID_I##BaseName },

//
// Declare the end of the extension registration entries
//
#define END_EXTENSION_REGISTRATION_MAP				\
	NULL };											\
DWORD dwRegistrationInfo =							\
	(sizeof(rgRegistrationInfo)/					\
		sizeof(EXT_REGISTRATION_INFO))-1;

//
// Register the extension bindings in the registry
//
HRESULT RegisterExtensions()
{	
	HRESULT	hrRes;
	HRESULT	hrTemp;
	HKEY	hKeyTemp;
	DWORD	dwDisposition;
	TCHAR	szSubKey[1024];
	LPTSTR	szCLSID;
	LPTSTR	szIID;

	hrTemp = S_OK;
	for (DWORD i = 0; i < dwRegistrationInfo; i++)
	{
		hrRes = StringFromCLSID(
				*(rgRegistrationInfo[i].clsid), 
				&szCLSID);
		if (FAILED(hrRes))
		{
			hrTemp = hrRes;
			continue;
		}

		hrRes = StringFromIID(
				*(rgRegistrationInfo[i].iid), 
				&szIID);
		if (FAILED(hrRes))
		{
			hrTemp = hrRes;
			continue;
		}

		wsprintf(szSubKey, 
				EXTENSION_BASE_PATH, 
				rgRegistrationInfo[i].szClassName,
				szCLSID);

		if (RegCreateKeyEx(
				HKEY_LOCAL_MACHINE,
				szSubKey,
				NULL, 
				_T(""), 
				REG_OPTION_NON_VOLATILE, 
				KEY_ALL_ACCESS, 
				NULL,
				&hKeyTemp, 
				&dwDisposition) != ERROR_SUCCESS)
		{
			hrTemp = E_UNEXPECTED;
			continue;
		}

		if (RegSetValueEx(
					hKeyTemp, 
					_T("Interfaces"), 
					NULL, 
					REG_MULTI_SZ,
					(BYTE*)szIID,
					lstrlen(szIID) * sizeof(TCHAR)) != ERROR_SUCCESS)
		{
			hrTemp = E_UNEXPECTED;
			RegCloseKey(hKeyTemp);
			continue;
		}

		RegCloseKey(hKeyTemp);
	}

	return(hrTemp);
}

//
// Unregister the extension bindings in the registry
//
HRESULT UnregisterExtensions()
{	
	HRESULT	hrRes;
	TCHAR	szSubKey[1024];
	LPTSTR	szCLSID;

	for (DWORD i = 0; i < dwRegistrationInfo; i++)
	{
		hrRes = StringFromCLSID(
				*(rgRegistrationInfo[i].clsid), 
				&szCLSID);
		if (FAILED(hrRes))
			continue;

		wsprintf(szSubKey, 
				EXTENSION_BASE_PATH, 
				rgRegistrationInfo[i].szClassName,
				szCLSID);
		RegDeleteKey(HKEY_LOCAL_MACHINE, szSubKey);

		wsprintf(szSubKey, 
				EXTENSION_BASE_PATH2, 
				rgRegistrationInfo[i].szClassName);
		RegDeleteKey(HKEY_LOCAL_MACHINE, szSubKey);
	}

	return(S_OK);
}

#endif // _REGMACRO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\cmultisz.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	cmultisz.h

Abstract:

	Defines the CMultiSz class for dealing with multi_sz's (These are
	a double null terminated list of strings).

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _CMULTISZ_INCLUDED_
#define _CMULTISZ_INCLUDED_

//$-------------------------------------------------------------------
//
//	Class:	CMultiSz
//
//	Description:
//
//		Handles double-null terminated strings.
//
//	Interface:
//
//		
//
//--------------------------------------------------------------------

class CMultiSz
{
public:
	// Construction & Destruction:
	inline CMultiSz		( );
	inline CMultiSz		( LPCWSTR msz );
	inline ~CMultiSz	( );

	// Properties of the multi_sz:
	DWORD				Count ( ) const;
	inline DWORD		SizeInBytes ( ) const;

	// Overloaded operators:
	inline 				operator LPCWSTR( );
	inline BOOL			operator!		( ) const;
	inline const CMultiSz &		operator= ( LPCWSTR wszMultiByte );
	inline const CMultiSz &		operator= ( const CMultiSz & msz );

	// Copying:
	inline LPWSTR		Copy			( ) const;

	// Attaching & Detaching:
	inline void			Attach			( LPWSTR msz );
	inline LPWSTR		Detach			( );
	inline void			Empty			( );

	HRESULT ToVariant	( VARIANT * pvar ) const;
	HRESULT FromVariant	( const VARIANT * pvar );

	// !!!magnush - remove these after move to VARIANT:
	// Safearray <--> Multisz:
	SAFEARRAY *			ToSafeArray		( ) const;
	void				FromSafeArray	( /* const */ SAFEARRAY * psaStrings );

private:
	// Data:
	LPWSTR		m_msz;

	// Private Methods:
	static DWORD		CountChars		( LPCWSTR msz );
	static LPWSTR		Duplicate		( LPCWSTR msz );
	static LPWSTR		CreateEmptyMultiSz	( );
};

// Inlined functions:

inline CMultiSz::CMultiSz ()
{
	m_msz	= NULL;
}

inline CMultiSz::CMultiSz ( LPCWSTR msz )
{
	m_msz	= Duplicate ( msz );
}

inline CMultiSz::~CMultiSz ()
{
	delete m_msz;
}

inline DWORD CMultiSz::SizeInBytes () const
{
	return sizeof ( WCHAR ) * CountChars ( m_msz );
}

inline CMultiSz::operator LPCWSTR()
{
	return m_msz;
}

inline BOOL CMultiSz::operator! () const
{
	return (m_msz == NULL) ? TRUE : FALSE;
}

inline const CMultiSz & CMultiSz::operator= ( const CMultiSz & msz )
{
	if ( &msz != this ) {
		m_msz = Duplicate ( msz.m_msz );
	}

	return *this;
}

inline const CMultiSz & CMultiSz::operator= ( LPCWSTR wszMultiByte )
{
	delete m_msz;
	m_msz = Duplicate ( wszMultiByte );

	return *this;
}

inline LPWSTR CMultiSz::Copy ( ) const
{
	return Duplicate ( m_msz );
}

inline void CMultiSz::Attach ( LPWSTR msz )
{
	if ( m_msz != msz ) {
		delete m_msz;
		m_msz	= msz;
	}
}

inline LPWSTR CMultiSz::Detach ( )
{
	LPWSTR	mszResult = m_msz;
	m_msz	= NULL;
	return mszResult;
}

inline void CMultiSz::Empty ( )
{
	delete m_msz;
	m_msz	= NULL;
}

#endif // _CMULTISZ_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma warning( disable : 4511 )

#include <ctype.h>
extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

//  ATL code:
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//  Debugging support:
#undef _ASSERT
#include <dbgtrace.h>

//  The Metabase:
#include <iadm.h>
#include <iiscnfg.h>

#include "admmacro.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\metakey.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metakey.cpp

Abstract:

	A class to help manipulate metabase keys.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "metakey.h"

#define MD_DEFAULT_TIMEOUT      5000
static BOOL IsValidIntegerSubKey ( LPCWSTR wszSubKey );

//$-------------------------------------------------------------------
//
//	CreateMetabaseObject
//
//	Description:
//
//		Creates an instance of the metabase object on the given
//		machine and initializes it.
//
//	Parameters:
//
//		wszMachine - The machine to create the metabase on.
//		ppMetabase - Returns the resulting metabase pointer.
//
//	Returns:
//
//		Error code from CoCreateInstance or the metabase routines.
//
//--------------------------------------------------------------------

HRESULT CreateMetabaseObject ( LPCWSTR wszMachine, IMSAdminBase ** ppMetabaseResult )
{
	TraceFunctEnter ( "CreateMetabaseObject" );

	// Check parameters:
	_ASSERT ( ppMetabaseResult != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( ppMetabaseResult ) );

	if ( ppMetabaseResult == NULL ) {
		FatalTrace ( 0, "Bad Return Pointer" );

		TraceFunctLeave ();
		return E_POINTER;
	}

	// Variables:
	HRESULT				hr	= NOERROR;
	IMSAdminBase		*pMetabase;
	IMSAdminBase		*pMetabaseT;
	MULTI_QI			mqi[1];
	COSERVERINFO		coserver;

	// Zero the out parameter:
	*ppMetabaseResult = NULL;

	// QI for IID_IMSAdminBase:
	mqi[0].pIID	= &IID_IMSAdminBase;
	mqi[0].pItf	= NULL;
	mqi[0].hr	= 0;

	// Which remote server to talk to:
	coserver.dwReserved1	= 0;
	coserver.dwReserved2	= 0;
	coserver.pwszName		= const_cast<LPWSTR> (wszMachine);
	coserver.pAuthInfo		= NULL;

	// Create the object:
	hr = CoCreateInstanceEx (
		CLSID_MSAdminBase,
		NULL,
		CLSCTX_ALL,
		wszMachine ? &coserver : NULL,
		1,
		mqi );

	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "CoCreate(metabase) failed %x", hr );
		goto Exit;
	}

	if ( FAILED(mqi[0].hr) ) {
		hr = mqi[0].hr;
		ErrorTraceX ( 0, "QI(metabase) failed %x", hr );
		goto Exit;
	}

	// Get the interface pointer:
	pMetabaseT = (IMSAdminBase *) mqi[0].pItf;

	// this gets us a version of the metabase which won't go through COM
	// proxy/stubs, so ACL checking will work properly.  If it fails we'll
	// just continue to use the marshalled version.
	_ASSERT(pMetabaseT != NULL);
	pMetabase = NULL;
	if (FAILED(pMetabaseT->UnmarshalInterface((IMSAdminBaseW **)&pMetabase))) {
	    pMetabase = pMetabaseT;
	} else {
		pMetabaseT->Release();
	}

	// Return the interface pointer:
	_ASSERT ( pMetabase );
	*ppMetabaseResult = pMetabase;

Exit:
	TraceFunctLeave ();
	return hr;

	// pMetabase will be released automatically.
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::CMetabaseKey
//
//	Description:
//
//		Initializes the CMetabaseKey
//
//	Parameters:
//
//		pMetabase - a pointer to the metabase object.
//
//--------------------------------------------------------------------

CMetabaseKey::CMetabaseKey ( IMSAdminBase * pMetabase )
{
	_ASSERT ( pMetabase );

	m_pMetabase				= pMetabase;
	m_hKey					= NULL;
	m_cChildren				= 0;
	m_cIntegerChildren		= 0;
	m_indexCursor			= 0;
	m_dwMaxIntegerChild		= 0;

	pMetabase->AddRef ();
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::~CMetabaseKey
//
//	Description:
//
//		Destroys the metabase key
//
//--------------------------------------------------------------------

CMetabaseKey::~CMetabaseKey ( )
{
	Close ();

	if ( m_pMetabase ) {
		m_pMetabase->Release ();
	}
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::Open
//
//	Description:
//
//		Opens a key and associates that key with this object.
//
//	Parameters:
//
//		hParentKey - the already open key to use a base.
//		szPath - path of the key to open
//		dwPermissions - READ or WRITE access.
//
//	Returns:
//
//		see IMSAdminBase::OpenKey
//
//--------------------------------------------------------------------

HRESULT CMetabaseKey::Open ( METADATA_HANDLE hParentKey, IN LPCWSTR szPath, DWORD dwPermissions )
{
	TraceFunctEnter ( "CMetabaseKey::Open" );

	HRESULT		hr	= NOERROR;

	Close ();

	hr = m_pMetabase->OpenKey ( 
		hParentKey,
		szPath,
		dwPermissions,
		MD_DEFAULT_TIMEOUT,
		&m_hKey
		);

	if ( FAILED(hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to open key %s: %x", szPath, hr );
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::Attach
//
//	Description:
//
//		Attaches this object to an already opened metabase key.
//
//	Parameters:
//
//		hKey - the opened metabase key
//
//--------------------------------------------------------------------

void CMetabaseKey::Attach ( METADATA_HANDLE hKey )
{
	Close ();

	_ASSERT ( hKey != NULL );
	m_hKey = hKey;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::Detach
//
//	Description:
//
//		Detaches the metabase key from this object and returns it
//
//	Returns:
//
//		The key handle that this object is holding.
//
//--------------------------------------------------------------------

METADATA_HANDLE CMetabaseKey::Detach ( )
{
	METADATA_HANDLE	hKeyResult;

	hKeyResult = m_hKey;
	m_hKey = NULL;

	return hKeyResult;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::Close
//
//	Description:
//
//		Closes the key that this object has open.
//
//--------------------------------------------------------------------

void CMetabaseKey::Close ( )
{
	TraceFunctEnter ( "CMetabaseKey::Close" );

	HRESULT		hr;

	if ( m_hKey ) {
		hr = m_pMetabase->CloseKey ( m_hKey );

		_ASSERT ( SUCCEEDED(hr) );
		m_hKey = NULL;
	}

	TraceFunctLeave ();
}

void CMetabaseKey::GetLastChangeTime ( FILETIME * pftGMT, LPCWSTR wszPath )
{
	_ASSERT ( m_hKey );
	_ASSERT ( IS_VALID_OUT_PARAM ( pftGMT ) );

	HRESULT		hr;

	hr = m_pMetabase->GetLastChangeTime ( m_hKey, wszPath, pftGMT, FALSE );
	_ASSERT ( SUCCEEDED(hr) );
}

HRESULT CMetabaseKey::EnumObjects ( IN LPCWSTR wszPath, LPWSTR wszSubKey, DWORD dwIndex )
{
	TraceFunctEnter ( "CMetabaseKey::EnumObjects" );

	HRESULT		hr;

	hr = m_pMetabase->EnumKeys ( m_hKey, wszPath, wszSubKey, dwIndex );

	TraceFunctLeave ();
	return hr;
}

HRESULT CMetabaseKey::DeleteKey ( LPCWSTR wszPath )
{
	TraceFunctEnter ( "CMetabaseKey::DeleteKey" );

	HRESULT		hr;

    hr = m_pMetabase->DeleteKey ( m_hKey, wszPath );

    TraceFunctLeave ();
    return hr;
}

HRESULT CMetabaseKey::DeleteAllData ( LPCWSTR wszPath )
{
	TraceFunctEnter ( "CMetabaseKey::DeleteAllData" );

	HRESULT		hr;

    hr = m_pMetabase->DeleteAllData ( m_hKey, wszPath, ALL_METADATA, ALL_METADATA );

    TraceFunctLeave ();
    return hr;
}

HRESULT CMetabaseKey::ChangePermissions ( DWORD dwPermissions )
{
	TraceFunctEnter ( "CMetabaseKey::ChangePermissions" );

	HRESULT		hr;

    _ASSERT (
        dwPermissions == METADATA_PERMISSION_WRITE ||
        dwPermissions == METADATA_PERMISSION_READ
        );

    hr = m_pMetabase->ChangePermissions ( m_hKey, 10, dwPermissions );

    TraceFunctLeave ();
    return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::Save
//
//	Description:
//
//		Saves the changes.
//
//--------------------------------------------------------------------

HRESULT CMetabaseKey::Save ( )
{
	TraceFunctEnter ( "CMetabaseKey::Save" );

	HRESULT		hr = NOERROR;

/*
    This call is now unnecessary.

	hr = m_pMetabase->SaveData ( );
*/

	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::GetChildCount
//
//	Description:
//
//		Returns the number of subkeys of the current metabase key.
//
//	Parameters:
//
//		pcChildren - resulting number of subkeys.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::GetChildCount ( OUT DWORD * pcChildren )
{
	_ASSERT ( m_hKey != NULL );

	if ( m_cChildren != 0 ) {
		*pcChildren = m_cChildren;
		return NOERROR;
	}

	HRESULT		hr;

	hr = CountSubkeys ( 
		NULL,
		&m_cChildren, 
		&m_cIntegerChildren, 
		NULL,
		&m_dwMaxIntegerChild 
		);

	*pcChildren = m_cChildren;
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::GetIntegerChildCount
//
//	Description:
//
//		Returns the number of integer subkeys of the current key.
//
//	Parameters:
//
//		pcIntegerChildren - the number of integer subkeys of the currently
//			opened key.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::GetIntegerChildCount ( OUT DWORD * pcIntegerChildren )
{
	_ASSERT ( m_hKey != NULL );

	if ( m_cChildren != 0 ) {
		*pcIntegerChildren = m_cIntegerChildren;
		return NOERROR;
	}

	HRESULT		hr;

	hr = CountSubkeys ( 
		NULL,
		&m_cChildren, 
		&m_cIntegerChildren, 
		NULL,
		&m_dwMaxIntegerChild 
		);

	*pcIntegerChildren = m_cIntegerChildren;
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::GetCustomChildCount
//
//	Description:
//
//		Returns the number of subkeys of the current metabase key
//		for which fpIsCustomKey returns true.
//
//	Parameters:
//
//		pcCustomChildren - resulting number of subkeys.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::GetCustomChildCount ( 
	KEY_TEST_FUNCTION	fpIsCustomKey,
	OUT DWORD * 		pcCustomChildren 
	)
{
	_ASSERT ( m_hKey != NULL );
	_ASSERT ( fpIsCustomKey );
	_ASSERT ( IS_VALID_OUT_PARAM ( pcCustomChildren ) );

	HRESULT		hr;

	hr = CountSubkeys ( 
		fpIsCustomKey, 
		&m_cChildren, 
		&m_cIntegerChildren, 
		pcCustomChildren, 
		&m_dwMaxIntegerChild 
		);

	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::BeginChildEnumeration
//
//	Description:
//
//		Sets up the object to enumerate subkeys.
//		Call before calling NextChild or NextIntegerChild.
//
//--------------------------------------------------------------------

void CMetabaseKey::BeginChildEnumeration	 	( )
{
	TraceFunctEnter ( "CMetabaseKey::BeginChildEnumeration" );

	_ASSERT ( m_hKey != NULL );

	HRESULT	hr;

	m_indexCursor	= 0;

	StateTrace ( (LPARAM) this, "Changing to Read Permission" );
	hr = m_pMetabase->ChangePermissions ( m_hKey, 1, METADATA_PERMISSION_READ );
	_ASSERT ( SUCCEEDED(hr) );
	if ( FAILED (hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to change permissions to read: %x", hr );
	}

	TraceFunctLeave ();
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::NextChild
//
//	Description:
//
//		Returns the name of the next subkey.
//		Call BeginChildEnumeration before calling NextChild
//
//	Parameters:
//
//		szChildKey - the resulting key name
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::NextChild ( OUT LPWSTR wszChildKey )
{
	TraceFunctEnter ( "CMetabaseKey::NextChild" );

	_ASSERT ( IS_VALID_OUT_PARAM ( wszChildKey ) );

	_ASSERT ( m_hKey != NULL );
	_ASSERT ( m_indexCursor < m_cChildren );

	HRESULT		hr;

	*wszChildKey = NULL;

	// Use the m_indexCursor to enumerated the next child:
	hr = m_pMetabase->EnumKeys ( m_hKey, _T(""), wszChildKey, m_indexCursor );
	if ( FAILED (hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to get next child: %x", hr );
		goto Exit;
	}

	m_indexCursor++;

Exit:
	// This means that you called NextChild more times than
	// was possible:
	_ASSERT ( HRESULTTOWIN32 ( hr ) != ERROR_NO_MORE_ITEMS );

	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::NextIntegerChild
//
//	Description:
//
//		Returns the name of the next integer subkey.
//		Call BeginChildEnumeration before calling NextIntegerChild
//
//	Parameters:
//
//		pdwID - the integer value of the subkey.
//		szIntegerChildKey - the subkey name string.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::NextIntegerChild ( OUT DWORD * pdwID, OUT LPWSTR wszIntegerChildKey )
{
	TraceFunctEnter ( "CMetabaseKey::NextChild" );

	_ASSERT ( IS_VALID_OUT_PARAM ( pdwID ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( wszIntegerChildKey ) );

	_ASSERT ( m_hKey != NULL );
	_ASSERT ( m_indexCursor < m_cChildren );

	HRESULT		hr;
	BOOL		fFoundInteger;

	*pdwID				= 0;
	*wszIntegerChildKey 	= NULL;

	for ( fFoundInteger = FALSE; !fFoundInteger; ) {

		// Use the m_indexCursor to enumerated the next child:
		hr = m_pMetabase->EnumKeys ( m_hKey, _T(""), wszIntegerChildKey, m_indexCursor );
		if ( FAILED (hr) ) {
			goto Exit;
		}

		if ( IsValidIntegerSubKey ( wszIntegerChildKey ) ) {
			fFoundInteger = TRUE;
			*pdwID = _wtoi ( wszIntegerChildKey );
		}

		m_indexCursor++;
	}

Exit:
	// This means that you called NextIntegerChild more times than
	// was possible:
	_ASSERT ( HRESULTTOWIN32 ( hr ) != ERROR_NO_MORE_ITEMS );

	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::NextCustomChild
//
//	Description:
//
//		Returns the name of the next subkey for which fpIsCustomKey
//		returns true.
//		Call BeginChildEnumeration before calling NextCustomChild
//
//	Parameters:
//
//		fpIsCustomKey	- function that returns true if a given key
//			should be returned.
//		szChildKey - the resulting key name
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::NextCustomChild ( 
	KEY_TEST_FUNCTION	fpIsCustomKey,
	OUT LPWSTR wszChildKey 
	)
{
	TraceFunctEnter ( "CMetabaseKey::NextCustomChild" );

	_ASSERT ( fpIsCustomKey );
	_ASSERT ( IS_VALID_OUT_PARAM ( wszChildKey ) );

	_ASSERT ( m_hKey != NULL );
	_ASSERT ( m_indexCursor < m_cChildren );

	HRESULT		hr;
	BOOL		fFoundCustomKey;

	*wszChildKey = NULL;

	for ( fFoundCustomKey = FALSE; !fFoundCustomKey; ) {

		// Use the m_indexCursor to enumerated the next child:
		hr = m_pMetabase->EnumKeys ( m_hKey, _T(""), wszChildKey, m_indexCursor );
		if ( FAILED (hr) ) {
			goto Exit;
		}

		if ( fpIsCustomKey ( wszChildKey ) ) {
			fFoundCustomKey = TRUE;
		}

		m_indexCursor++;
	}

Exit:
	// This means that you called NextCustomChild more times than
	// was possible:
	_ASSERT ( HRESULTTOWIN32 ( hr ) != ERROR_NO_MORE_ITEMS );

	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::CreateChild
//
//	Description:
//
//		Creates the given path under the currently opened key.
//		Changes the current key to write permission.
//		Note: Does not call SaveData.
//
//	Parameters:
//
//		szChildPath - name of the subkey to create.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::CreateChild ( IN LPWSTR wszChildPath )
{
	TraceFunctEnter ( "CMetabaseKey::CreateChild" );

	_ASSERT ( wszChildPath );
	_ASSERT ( m_hKey != NULL );
	
	HRESULT		hr;

	StateTrace ( (LPARAM) this, "Changing to Write Permission" );
	hr = m_pMetabase->ChangePermissions ( m_hKey, MD_DEFAULT_TIMEOUT, METADATA_PERMISSION_WRITE );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = m_pMetabase->AddKey ( m_hKey, wszChildPath );
	if ( FAILED (hr) ) {
		goto Exit;
	}

/*
	// !!!magnush - Should we save the data now?
	hr = m_pMetabase->SaveData ();
	if ( FAILED (hr) ) {
		goto Exit;
	}
*/

	m_cChildren++;
	if ( IsValidIntegerSubKey ( wszChildPath ) ) {
		m_cIntegerChildren++;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::DestroyChild
//
//	Description:
//
//		Deletes the given subkey
//		Changes the current key to write permission.
//		Note: Does not call SaveData
//
//	Parameters:
//
//		szChildPath - the name of the subkey to delete.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::DestroyChild ( IN LPWSTR wszChildPath )
{
	TraceFunctEnter ( "CMetabaseKey::DestroyChild" );

	_ASSERT ( wszChildPath );
	_ASSERT ( m_hKey != NULL );

	HRESULT	hr;

	StateTrace ( (LPARAM) this, "Changing to Write Permission" );
	hr = m_pMetabase->ChangePermissions ( m_hKey, MD_DEFAULT_TIMEOUT, METADATA_PERMISSION_WRITE );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = m_pMetabase->DeleteKey ( m_hKey, wszChildPath );
	if ( FAILED (hr) ) {
		goto Exit;
	}

/*
	// !!!magnush - Should we save the data now?
	hr = m_pMetabase->SaveData ();
	if ( FAILED (hr) ) {
		goto Exit;
	}
*/

	m_cChildren--;
	if ( IsValidIntegerSubKey ( wszChildPath ) ) {
		m_cIntegerChildren--;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::CreateIntegerChild
//
//	Description:
//
//		Creates an integer subkey of the currently open key.
//		This key will be 1 + the highest integer subkey.
//
//	Parameters:
//
//		pdwID - the resulting integer value.
//		szChildPath - the resulting subkey path.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::CreateIntegerChild ( OUT DWORD * pdwID, OUT LPWSTR wszChildPath )
{
	TraceFunctEnter ( "CMetabaseKEy::CreateIntegerChild" );

	_ASSERT ( IS_VALID_OUT_PARAM ( pdwID ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( wszChildPath ) );
	_ASSERT ( m_hKey != NULL );

	HRESULT		hr	= NOERROR;
	DWORD		dwId;

	*pdwID 			= 0;
	*wszChildPath 	= NULL;

	for ( dwId = 1; dwId != 0; dwId++ ) {
		//
		//	Keep trying to add an instance key until it works:
		//

		wsprintf ( wszChildPath, _T("%d"), dwId );

		hr = CreateChild ( wszChildPath );
		if ( SUCCEEDED(hr) ) {
			// We created the child, so lets get out of here.
			break;
		}
		else if ( HRESULTTOWIN32 ( hr ) == ERROR_ALREADY_EXISTS ) {
			// Child already exists, try the next one.
			continue;
		}
		else {
			// Real error: report it and bail.
			ErrorTrace ( (LPARAM) this, "Error %d adding %s\n", HRESULTTOWIN32(hr), wszChildPath );
			goto Exit;
		}
	}

	if ( dwId == 0 ) {
		hr = E_FAIL;
		goto Exit;
	}
	
	_ASSERT ( SUCCEEDED(hr) );
	if ( dwId > m_dwMaxIntegerChild ) {
		m_dwMaxIntegerChild = dwId;
	}

	*pdwID = dwId;

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::DestroyIntegerChild
//
//	Description:
//
//		Deletes the given integer subkey.
//
//	Parameters:
//
//		i - the subkey to delete
//
//	Returns:
//
//		metabase error code
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::DestroyIntegerChild ( IN DWORD i )
{
	TraceFunctEnter ( "CMetabaseKey::DestroyIntegerChild" );

	_ASSERT ( i != 0 );
	_ASSERT ( m_hKey != NULL );

	WCHAR	wszChild [ METADATA_MAX_NAME_LEN ];
	HRESULT	hr;

	wsprintf ( wszChild, _T("%d"), i );

	hr = DestroyChild ( wszChild );

	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::CountSubKeys
//
//	Description:
//
//		Returns the number of subkeys and integer subkeys of the
//		current metabase key.
//		Changes the key to read permission.
//
//	Parameters:
//
//		fpIsCustomKey - Function that takes a key and returns true
//			if that key should be included in the custom child count.
//		pcSubKeys - number of subkeys.
//		pcIntegerSubKeys - number of integer subkeys.
//		pcCustomChildren - the number of keys for which fpIsCustomKey
//			returns true.
//		pdwMaxIntegerSubkey - the highest integer subkey value.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT CMetabaseKey::CountSubkeys ( 
	KEY_TEST_FUNCTION	fpIsCustomKey,
	OUT DWORD * 		pcSubKeys, 
	OUT DWORD *			pcIntegerSubKeys,
	OUT DWORD * 		pcCustomSubKeys,
	OUT DWORD * 		pdwMaxIntegerSubKey
	)
{
	TraceFunctEnter ( "CMetabaseKey::CountSubKeys" );

	_ASSERT ( pcSubKeys );
	_ASSERT ( IS_VALID_OUT_PARAM ( pcSubKeys ) );
	_ASSERT ( pcIntegerSubKeys );
	_ASSERT ( IS_VALID_OUT_PARAM ( pcIntegerSubKeys ) );
//	_ASSERT ( pcCustomSubKeys );
//	_ASSERT ( IS_VALID_OUT_PARAM ( pcCustomSubKeys ) );
	_ASSERT ( m_hKey != NULL );

	// Zero the out parameter:
	*pcSubKeys				= 0;
	*pcIntegerSubKeys		= 0;
	*pdwMaxIntegerSubKey	= 0;
	if ( pcCustomSubKeys ) {
		*pcCustomSubKeys		= 0;
	}

	HRESULT	hr					= NOERROR;
	DWORD	cItems				= 0;
	DWORD	cIntegerItems		= 0;
	DWORD	cCustomItems		= 0;
	DWORD	dwMaxIntegerSubKey	= 0;
	WCHAR	wszName [ METADATA_MAX_NAME_LEN ];
	DWORD	i					= 0;

	StateTrace ( (LPARAM) this, "Changing to Read Permission" );
	hr = m_pMetabase->ChangePermissions ( m_hKey, 1, METADATA_PERMISSION_READ );
	_ASSERT ( SUCCEEDED(hr) );
	if ( FAILED (hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to change permissions to read: %x", hr );
		goto Exit;
	}

	// Because I can't do a count here, I have to assume that the error means
	// there are no more items:
	for ( cItems = 0, cIntegerItems = 0, cCustomItems = 0, i = 0; 
		/* Don't know how long it will last */; 
		i++ ) {

		hr = m_pMetabase->EnumKeys ( m_hKey, _T(""), wszName, i );

		if ( HRESULTTOWIN32 ( hr ) == ERROR_NO_MORE_ITEMS ) {
			// This is expected, end the loop:
			hr = NOERROR;
			break;
		}

		if ( FAILED (hr) ) {
			// Unexpected error case.

			ErrorTraceX ( 0, "Failed to enum object %d : %x", i, hr );
			goto Exit;
		}

		cItems++;

		if ( IsValidIntegerSubKey ( wszName ) ) {
			DWORD	dwSubkey;

			cIntegerItems++;
			dwSubkey = _wtoi ( wszName );

			if ( dwSubkey > dwMaxIntegerSubKey ) {
				dwMaxIntegerSubKey = dwSubkey;
			}
		}
		else {
			// Don't count this one:
			ErrorTrace ( 0, "Bad subkey number: %d", i );
		}

		if ( fpIsCustomKey && fpIsCustomKey ( wszName ) ) {
			cCustomItems++;
		}

		_ASSERT ( i < 0xf000000 ); // Infinite loop
	}

	// Now we have the count of items in cItems.
	*pcSubKeys				= cItems;
	*pcIntegerSubKeys		= cIntegerItems;
	*pdwMaxIntegerSubKey	= dwMaxIntegerSubKey;
	if ( pcCustomSubKeys ) {
		*pcCustomSubKeys		= cCustomItems;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

BOOL IsValidIntegerSubKey ( LPCWSTR wszSubKey )
{
	TraceQuietEnter ( "IsValidIntegerSubKey" );

	WCHAR	wszIntegerKey [ METADATA_MAX_NAME_LEN ];
	DWORD	dwItemValue;

	dwItemValue = _wtoi ( wszSubKey );
	wsprintf ( wszIntegerKey, _T("%d"), dwItemValue );

	// If the key is nonzero AND
	// The key is just the itoa value of the number:
	if ( dwItemValue != 0 &&
		 lstrcmp ( wszIntegerKey, wszSubKey ) == 0 ) {

		 return TRUE;
	}
	else {
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\u2detect.cpp ===
#include "stdafx.h"
#include "u2detect.h"

#define DebugPrint

#define MAX_MACHINE_NAME_SIZE   256
#define PROGID_PM_AUTH_SERVERS  L"MemAdmin.BrokServers"


HRESULT GetAdminIntf( 
    LPTSTR      pszMachName, 
    REFCLSID    rClsID, 
    const IID   *pIID, 
    PVOID       *ppIntf
    )
{
    static DWORD    dwNameSize = 0;
    static TCHAR    szLocalName[MAX_MACHINE_NAME_SIZE];
    HRESULT         hr = NOERROR;
    MULTI_QI        mqi;
    COSERVERINFO    CoSrv;
    COSERVERINFO    *pCoSrv = NULL;

    if (ppIntf)
        *ppIntf = NULL;

    // QI for IID_IBrokServers:
    mqi.pIID    = pIID;
    mqi.pItf    = NULL;
    mqi.hr    = 0;

    if (pszMachName)
    {
        if (dwNameSize == 0)
        {
            dwNameSize = MAX_MACHINE_NAME_SIZE;
            if (!GetComputerName( szLocalName, &dwNameSize ))
                dwNameSize = 0;
        }

        if (lstrcmpi( TEXT("localhost"), pszMachName) == 0 || 
            ( dwNameSize > 0 && lstrcmpi( szLocalName, pszMachName) == 0 ))
        {
            pCoSrv = NULL;
        }
        else
        {
            // Which remote server to talk to:
            //
            ZeroMemory( &CoSrv, sizeof(CoSrv) );
            CoSrv.pAuthInfo   = NULL;

#ifdef UNICODE
            LPWSTR pwszRemoteHost = pszMachName;
            CoSrv.pwszName    =    pwszRemoteHost;
#else
            WCHAR wszRemoteHost[MAX_MACHINE_NAME_SIZE];

            mbstowcs( wszRemoteHost, pszMachName, strlen(pszMachName) + 1 );
            CoSrv.pwszName    =    wszRemoteHost;
#endif

            pCoSrv = &CoSrv;
        }
    }

    // Create the DCOM object:
    //
    hr = CoCreateInstanceEx( rClsID, 
                             NULL, 
                             CLSCTX_SERVER | CLSCTX_REMOTE_SERVER, 
                             pCoSrv, 
                             1, 
                             &mqi );
    if ( FAILED(hr) )
    {
        return hr;
    }

    // Get and save the interface pointer:
    //
    if (ppIntf != NULL)
    {
        // Check in MULTI_QI for errors only if we built the MULTI_QI structure
        // otherwise, let the supplier of MULTI_QI check it themselves
        //
        if ( FAILED(mqi.hr) )
        {
            hr = mqi.hr;
            return hr;
        }

        *ppIntf = mqi.pItf;
        ((IUnknown *)*ppIntf)->AddRef();

        _ASSERT ( *ppIntf != NULL );
    }

    return S_OK;
}


BOOL IsNTSecurity( 
    LPTSTR pszMachine, 
    BSTR bstrSvcName, 
    LONG lInstanceID )
{
    HRESULT hr;
    IDispatch *pIDispatch = NULL;
    CLSID clsid;
    DISPID dispid ;
    OLECHAR* GetSecModeMethod = L"GetSecurityMode" ;
    OLECHAR* InitMethod =       L"Init" ;
    VARIANTARG vargs[3] ;
    DISPPARAMS param;
    CComVariant varSecurityMode;
    BOOL bNT;

    bNT = TRUE;   // default to NT security

    hr = ::CLSIDFromProgID( PROGID_PM_AUTH_SERVERS, &clsid );
    if (FAILED(hr))
    {
        DebugPrint( "P&M is probably not installed\n");
        goto Cleanup;
    }

    //hr = ::CoCreateInstance( clsid, NULL, CLSCTX_SERVER, IID_IDispatch,
    //                         (void**)&pIDispatch );
    hr = GetAdminIntf( pszMachine, clsid, &IID_IDispatch, (void**)&pIDispatch );

    if (FAILED(hr))
    {
        DebugPrint( "CoCreateInstance Failed: 0x%x\n", hr );
        goto Cleanup;
    }
    DebugPrint( "CoCreateInstance Succeeded\n");

    //  Get the method ID for Init()
    //
    hr = pIDispatch->GetIDsOfNames(IID_NULL,
                                   &InitMethod,
                                   1,
                                   GetUserDefaultLCID(),
                                   &dispid) ;
    if (FAILED(hr))
    {
        DebugPrint( "Query GetIDsOfNames failed: 0x%x", hr) ;
        goto Cleanup;
    }

    param.cArgs = param.cNamedArgs = 0; // No parameter to Init           
    param.rgvarg = NULL;
    param.rgdispidNamedArgs = NULL;

    hr = pIDispatch->Invoke(dispid,
                            IID_NULL,
                            GetUserDefaultLCID(),
                            DISPATCH_METHOD,
                            &param,     // No parameter to Init
                            NULL, 
                            NULL,
                            NULL) ;
    //
    //  Since Init() are not critical, ignore the return code for now
    //

    //  Get the method ID for GetSecurityMode()
    //
    dispid = 0;
    hr = pIDispatch->GetIDsOfNames(IID_NULL,
                                   &GetSecModeMethod,
                                   1,
                                   GetUserDefaultLCID(),
                                   &dispid) ;
    if (FAILED(hr))
    {
        DebugPrint( "Query GetIDsOfNames failed: 0x%x", hr) ;
        goto Cleanup;
    }

    DebugPrint( "Invoke the GetSecurityMode method\n" );

    // Allocate and initialize a VARIANT argument.

    VariantInit(&vargs[0]) ;     // Initialize the VARIANT.
    VariantInit(&vargs[1]) ;     // Initialize the VARIANT.

    vargs[0].vt = VT_I4;             // Type of 2nd arg
    vargs[0].lVal = lInstanceID;     // 2nd parameter
    vargs[1].vt = VT_BSTR;           // Type of 1st arg to the method
    vargs[1].bstrVal = bstrSvcName;  // 1st parameter

    param.cArgs = 2;                 // Number of arguments
    param.rgvarg = vargs;            // Arguments
    param.cNamedArgs = 0;            // Number of named args
    param.rgdispidNamedArgs = NULL;  // Named arguments

    hr = pIDispatch->Invoke(dispid,
                            IID_NULL,
                            GetUserDefaultLCID(),
                            DISPATCH_METHOD,
                            &param,
                            &varSecurityMode, 
                            NULL,
                            NULL) ;
    if (FAILED(hr))
    {
        DebugPrint( "Invoke call failed: 0x%x\n", hr );
        goto Cleanup;
    }

    if (V_VT( &varSecurityMode ) != VT_I4)
    {
        DebugPrint( "Unexpected result type %d\n", V_VT(&varSecurityMode) & 0xffff);
    }

    bNT = V_BOOL( &varSecurityMode );

Cleanup:
    if (pIDispatch)
        pIDispatch->Release();

    return bNT;
}


VOID DeleteMapping( 
    LPTSTR pszMachine, 
    BSTR bstrSvcName, 
    LONG lInstanceID )
{
    HRESULT hr;
    IDispatch *pIDispatch = NULL;
    CLSID clsid;
    DISPID dispid ;
    OLECHAR* DeleteMappingMethod = L"ClearMapping" ;
    OLECHAR* InitMethod =       L"Init" ;
    VARIANTARG vargs[3] ;
    DISPPARAMS param;
    BOOL bNT;

    bNT = TRUE;   // default to NT security

    hr = ::CLSIDFromProgID( PROGID_PM_AUTH_SERVERS, &clsid );
    if (FAILED(hr))
    {
        DebugPrint( "P&M is probably not installed\n");
        goto Cleanup;
    }

    hr = GetAdminIntf( pszMachine, clsid, &IID_IDispatch, (void**)&pIDispatch );

    if (FAILED(hr))
    {
        DebugPrint( "CoCreateInstance Failed: 0x%x\n", hr );
        goto Cleanup;
    }
    DebugPrint( "CoCreateInstance Succeeded\n");

    //  Get the method ID for Init()
    //
    hr = pIDispatch->GetIDsOfNames(IID_NULL,
                                   &InitMethod,
                                   1,
                                   GetUserDefaultLCID(),
                                   &dispid) ;
    if (FAILED(hr))
    {
        DebugPrint( "Query GetIDsOfNames failed: 0x%x", hr) ;
        goto Cleanup;
    }

    param.cArgs = param.cNamedArgs = 0; // No parameter to Init           
    param.rgvarg = NULL;
    param.rgdispidNamedArgs = NULL;

    hr = pIDispatch->Invoke(dispid,
                            IID_NULL,
                            GetUserDefaultLCID(),
                            DISPATCH_METHOD,
                            &param,     // No parameter to Init
                            NULL, 
                            NULL,
                            NULL) ;
    //
    //  Since Init() are not critical, ignore the return code for now
    //

    //  Get the method ID for GetSecurityMode()
    //
    dispid = 0;
    hr = pIDispatch->GetIDsOfNames(IID_NULL,
                                   &DeleteMappingMethod,
                                   1,
                                   GetUserDefaultLCID(),
                                   &dispid) ;
    if (FAILED(hr))
    {
        DebugPrint( "Query GetIDsOfNames failed: 0x%x", hr) ;
        goto Cleanup;
    }

    DebugPrint( "Invoke the ClearMapping method\n" );

    // Allocate and initialize a VARIANT argument.

    VariantInit(&vargs[0]) ;     // Initialize the VARIANT.
    VariantInit(&vargs[1]) ;     // Initialize the VARIANT.

    vargs[0].vt = VT_I4;             // Type of 2nd arg
    vargs[0].lVal = lInstanceID;     // 2nd parameter
    vargs[1].vt = VT_BSTR;           // Type of 1st arg to the method
    vargs[1].bstrVal = bstrSvcName;  // 1st parameter

    param.cArgs = 2;                 // Number of arguments
    param.rgvarg = vargs;            // Arguments
    param.cNamedArgs = 0;            // Number of named args
    param.rgdispidNamedArgs = NULL;  // Named arguments

    hr = pIDispatch->Invoke(dispid,
                            IID_NULL,
                            GetUserDefaultLCID(),
                            DISPATCH_METHOD,
                            &param,
                            NULL, 
                            NULL,
                            NULL) ;
    if (FAILED(hr))
    {
        DebugPrint( "Invoke call failed: 0x%x\n", hr );
        goto Cleanup;
    }

    DebugPrint( "Membership Server Mapping Deleted Successfully\n");

Cleanup:
    if (pIDispatch)
        pIDispatch->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\adsiisex\guids.cpp ===
#include <windows.h>
#include <ole2.h>
#include "iads.h"

//
//  ATL:
//

#include "atlbase.h"
#include <atlimpl.cpp>

//
//  GUIDS:
//

#define INITGUID
#include "initguid.h"

#include "nntpadm.h"
#include "smtpadm.h"
#include "pop3adm.h"
#include "imapadm.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\u2detect.h ===
BOOL IsNTSecurity( LPTSTR pszMachine, BSTR bstrSvcName, LONG lInstanceID );

VOID DeleteMapping( LPTSTR pszMachine, BSTR bstrSvcName, LONG lInstanceID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\asynccon\src\asynccon.cxx ===
/*++

   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        asynccon.cxx

   Abstract:


   Author:

--*/

#include <windows.h>
#include <winsock2.h>
#include <dbgtrace.h>
#include <asynccon.hxx>

CAsyncConnection::CAsyncConnection(DWORD PortNo, DWORD TimeOut, char * HostName, USERCALLBACKFUNC CallBack)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncConnection::CAsyncConnection()");

	m_Signature = ASYNCCON_SIGNATURE;
	m_RegisterWaitHandle = NULL;
	m_SignalHandle = NULL;
	AsyncSock = INVALID_SOCKET;
	m_IsFirstTime = TRUE;
	m_fCloseSocket = TRUE;
	m_Error = 0;
	m_fTimedOut = TRUE;
	NextIpToTry = 0;
	m_TimeOut = TimeOut;
	m_IpAddress = 0;
	m_Port = PortNo;
	m_cActiveThreads = 0;
    m_cRefCount = 0;

	lstrcpyn(m_HostName, HostName, sizeof(m_HostName) -1 );
	m_CallBackFunc = CallBack;

	ZeroMemory(m_pLocalIpAddresses, sizeof(m_pLocalIpAddresses));
	ZeroMemory(m_LocalIpAddresses, sizeof(m_LocalIpAddresses));

    TraceFunctLeaveEx((LPARAM)this);
}

CAsyncConnection::~CAsyncConnection()
{
	int Retval = 0;

    TraceFunctEnterEx((LPARAM) this, "CAsyncConnection::~CAsyncConnection()");

    //NK** We call the destructor after decrementing the thread count
    //so it should be zero.
	_ASSERT(GetThreadCount() == 0);
    _ASSERT(GetRefCount() == 0);

	if(m_RegisterWaitHandle)
	{
		UnregisterWait(m_RegisterWaitHandle);
		m_RegisterWaitHandle = NULL;
	}

	if(m_SignalHandle)
	{
		CloseHandle(m_SignalHandle);
		m_SignalHandle = NULL;
	}

	if(m_fCloseSocket && (AsyncSock != INVALID_SOCKET))
	{
		ResetSocketToBlockingMode();
		Retval = closesocket(AsyncSock);
		AsyncSock = INVALID_SOCKET;
	}

	m_Signature = ASYNCCON_SIGNATURE_FREE;

	DebugTrace((LPARAM) this, "Deleteing async conn %X", this);

    TraceFunctLeaveEx((LPARAM)this);
}


void CAsyncConnection::AsyncConnectCallback(PVOID ThisPtr, BOOLEAN fTimedOut)
{
	CAsyncConnection * ThisQueue = (CAsyncConnection *) ThisPtr;
	BOOL fRet = TRUE;

	_ASSERT(ThisQueue->IsValid());

	ThisQueue->SetTimedOutFlag(fTimedOut);

	if(!ThisQueue->IsFirstTime())
	{
		//Call the users callback routine.
		fRet = ThisQueue->ExecuteUserCallBackRoutine(ThisPtr, fTimedOut);
	}
	else
	{
		//If this is the first time we got into this routine,
		//we need to make the first gethostbyname() call, then
		//issue the first asyn connect.
		fRet = ThisQueue->MakeFirstAsyncConnect();
		if(!fRet)
		{
			//let the user know that the gethostbyname failed.
			fRet = ThisQueue->ExecuteUserCallBackRoutine(ThisPtr, fTimedOut);
		}
	}

    //Dec the ref count if it is zero that means no more threads are going to come in
    //here after this
	if(ThisQueue->DecRefCount() == 0)
        delete ThisQueue;
    
}

void CAsyncConnection::StoreHostent(struct hostent *pHostent)
{
	TraceFunctEnterEx((LPARAM)this, "CAsyncConnection::StoreHostent");

	// Initialize our HOSTENT
	if (pHostent)
		CopyMemory(&m_Hostent, pHostent, sizeof(HOSTENT));
	else
		ZeroMemory(&m_Hostent, sizeof(HOSTENT));

	// Provide our own buffer for IP addresses
	m_Hostent.h_addr_list = (char **)m_pLocalIpAddresses;

	ZeroMemory(m_pLocalIpAddresses, sizeof(m_pLocalIpAddresses));
	ZeroMemory(m_LocalIpAddresses, sizeof(m_LocalIpAddresses));

	// Now we copy all IP addresses from the returned HOSTENT to our own
	// data buffers
	if (pHostent)
	{
		struct in_addr	*pin;
		DWORD			dwIndex;
		BOOL			fAddressConverted = FALSE;

		for (dwIndex = 0; pHostent->h_addr_list[dwIndex]; dwIndex++)
		{
			pin = (struct in_addr *)pHostent->h_addr_list[dwIndex];

			//Save all IP addresses up to _MAX_HOSTENT_IP_ADDRESSES
			if (dwIndex < _MAX_HOSTENT_IP_ADDRESSES)
			{
				m_pLocalIpAddresses[dwIndex] = &m_LocalIpAddresses[dwIndex];
				m_LocalIpAddresses[dwIndex] = *pin;
				DebugTrace((LPARAM)this, "IP Address [%2u]: %u.%u.%u.%u",
						dwIndex,
						pin->s_net, pin->s_imp,
						pin->s_impno, pin->s_lh);

			}
			else
				break;
		}

		// Terminate the list and leave
		m_pLocalIpAddresses[dwIndex] = NULL;
	}
	
	TraceFunctLeaveEx((LPARAM)this);
}

BOOL CAsyncConnection::AsyncConnectSuccessfull(void)
{
	BOOL fRet = FALSE;
	int SockRet = 0;
	WSANETWORKEVENTS NetworkEvents;

    TraceFunctEnterEx((LPARAM) this, "CAsyncConnection::AsyncConnectSuccessfull");

	if(!m_Error &&!m_fTimedOut && !IsFirstTime())
	{
		SockRet = WSAEnumNetworkEvents(AsyncSock, m_SignalHandle, &NetworkEvents);
		if(SockRet == 0)
		{
			m_Error = NetworkEvents.iErrorCode[FD_CONNECT_BIT];
			if(m_Error == 0)
			{
				fRet = TRUE;
			}
		}
	}

	ResetSocketToBlockingMode();

	if(fRet)
	{
		//if the connection was successful, set the flag that
		//tells the destructor not to close the socket.
		SetCloseSocketFlag(FALSE);
	}
	else
	{
		//if we got here, it means either means we timed out,
		//or the connect itself was unsuccessfull.
		
		ErrorTrace((LPARAM) this, "%s had error %d connecting", m_HostName, m_Error);

		CloseAsyncSocket();
	}

	m_Error = 0;
    TraceFunctLeaveEx((LPARAM)this);
	return fRet;
}

BOOL CAsyncConnection::IssueTcpConnect(SOCKADDR_IN  &connect_addr)
{
	BOOL fRet = FALSE;
	DWORD Error = 0;
	DWORD IpAddress = 0;

    TraceFunctEnterEx((LPARAM) this, "CAsyncConnection::IssueTcpConnect");

    ErrorTrace((LPARAM) this, "Connecting to %s over %d", m_HostName, m_Port);

	IpAddress = (DWORD) connect_addr.sin_addr.s_addr;
    connect_addr.sin_family =  AF_INET;
    connect_addr.sin_port = htons((u_short) m_Port);

	if(CheckIpAddress(connect_addr.sin_addr.s_addr, m_Port))
	{
        //We increment the ref count
        //We decrement if we complete synchronously or fail
        IncRefCount();
        SetConnectedIpAddress(IpAddress);
		if(connect (GetSockethandle(), (PSOCKADDR) &connect_addr, sizeof(connect_addr)) == 0)
		{
            DecRefCount();
			fRet = TRUE;
		}
		else 
		{
			Error = WSAGetLastError();
			if(Error == WSAEWOULDBLOCK)
			{
				fRet = TRUE;
			}
			else
			{
                DecRefCount();
				m_Error = Error;
			}
		}
	}

    TraceFunctLeaveEx((LPARAM)this);
	return fRet;
}

BOOL CAsyncConnection::MakeNewConnection(void)
{
	struct hostent *hp = NULL;
	BOOL fRet = FALSE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncConnection::MakeNewConnections");

	//nope, try gethostbyname()
	hp = gethostbyname (m_HostName);
	if ( hp != NULL )
	{
		StoreHostent(hp);
		//if(ConnectToHost())
		//{
			fRet = TRUE;
		//}
	}
	else
	{
		//failed...lets get out of  here
		m_Error = WSAGetLastError();

		if(m_Error == ERROR_INVALID_PARAMETER)
		{
			m_Error = WSAHOST_NOT_FOUND;
		}

		ZeroMemory(m_pLocalIpAddresses, sizeof(m_pLocalIpAddresses));
		ZeroMemory(m_LocalIpAddresses, sizeof(m_LocalIpAddresses));
		ZeroMemory(&m_Hostent, sizeof(m_Hostent));
		m_Hostent.h_addr_list = (char **)m_pLocalIpAddresses;
		NextIpToTry = 0;

	}

	SetFirstTime(FALSE);	
    TraceFunctLeaveEx((LPARAM)this);
	return fRet;
}

BOOL CAsyncConnection::DoGetHostByName(void)
{
	struct hostent *hp = NULL;
	BOOL fRet = FALSE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncConnection::DoGetHostByName");

    DebugTrace((LPARAM) this, "resolving %s in DoGetHost", m_HostName);

	ZeroMemory(m_pLocalIpAddresses, sizeof(m_pLocalIpAddresses));
	ZeroMemory(m_LocalIpAddresses, sizeof(m_LocalIpAddresses));
	ZeroMemory(&m_Hostent, sizeof(m_Hostent));
	m_Hostent.h_addr_list = (char **)m_pLocalIpAddresses;
	NextIpToTry = 0;

	if(m_HostName[0] == '[')
	{
		fRet = TRUE;
	}
	else if(hp = gethostbyname (m_HostName))
	{
		StoreHostent(hp);
		fRet = TRUE;
	}

    TraceFunctLeaveEx((LPARAM)this);
	return fRet;
}

BOOL CAsyncConnection::MakeFirstAsyncConnect(void)
{
	struct hostent *hp = NULL;
	BOOL fRet = FALSE;
	BOOL fDomainLiteral = FALSE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncConnection::MakeFirstAsyncConnect");

    DebugTrace((LPARAM) this, "resolving %s", m_HostName);

	if(m_HostName[0] == '[')
	{
		fDomainLiteral = TRUE;

		if(ConnectToHost())
			fRet = TRUE;
	}
	else if (hp = gethostbyname (m_HostName))
	{
		StoreHostent(hp);
		if(ConnectToHost())
		{
			fRet = TRUE;
		}
	}
	else
	{
		m_Error = WSAGetLastError();
	}

	if(!fRet || fDomainLiteral)
	{
		//failed...lets get out of  here
		//m_Error = WSAGetLastError();

		ZeroMemory(m_pLocalIpAddresses, sizeof(m_pLocalIpAddresses));
		ZeroMemory(m_LocalIpAddresses, sizeof(m_LocalIpAddresses));
		ZeroMemory(&m_Hostent, sizeof(m_Hostent));
		m_Hostent.h_addr_list = (char **)m_pLocalIpAddresses;
		NextIpToTry = 0;
	}

	SetFirstTime(FALSE);	
    TraceFunctLeaveEx((LPARAM)this);
	return fRet;
}

BOOL CAsyncConnection::ConnectToHost(void)
{
	unsigned long InetAddr = 0;
    char * pEndIp = NULL;
	char * pRealHost = NULL;
	char OldChar = '\0';
	struct hostent *hp = NULL;
	BOOL fRet = FALSE;
	BOOL IsDomainLiteral = FALSE;
	SOCKADDR_IN  connect_addr;

    TraceFunctEnterEx((LPARAM) this, "ConnectToHost");

	_ASSERT(AsyncSock == INVALID_SOCKET);

	AsyncSock = socket(AF_INET, SOCK_STREAM, 0);
	if(AsyncSock == INVALID_SOCKET)
	{
		m_Error = WSAGetLastError();
        ErrorTrace((LPARAM) this, "socket returned %d", m_Error);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
	}

	SetSocketOptions();

	//turn the socket into non-blocking mode and ask winsock to notify
	//us when the connect happens
	m_Error = WSAEventSelect(AsyncSock, m_SignalHandle, FD_CONNECT);
	if(m_Error == SOCKET_ERROR)
	{
		m_Error = WSAGetLastError();
		closesocket(AsyncSock);
		AsyncSock = INVALID_SOCKET;
        ErrorTrace((LPARAM) this, "WSAEventSelect returned %d", m_Error);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
	}

	pRealHost = m_HostName;

    //see if this is a domain literal
    if(pRealHost[0] == '[')
    {
		pEndIp = strchr(pRealHost, ']');
		if(pEndIp == NULL)
		{
			m_Error = WSAHOST_NOT_FOUND;
			goto Exit;
		}

			//save the old character
			OldChar = *pEndIp;

			//null terminate the string
		*pEndIp = '\0';
		IsDomainLiteral = TRUE;
		pRealHost++;
    }

	if(IsFirstTime())
	{
		SetFirstTime(FALSE);	

		//Is this an ip address
 		InetAddr = inet_addr( (char *) pRealHost );
		if(InetAddr != INADDR_NONE)
		{
			if(IsDomainLiteral)
			{
				//put back the old character
				*pEndIp = OldChar;
			}

			CopyMemory(&connect_addr.sin_addr, &InetAddr, 4);

			return IssueTcpConnect(connect_addr);
		}
	}

	if(m_Hostent.h_addr_list[NextIpToTry] != NULL)
	{
		CopyMemory(&connect_addr.sin_addr, m_Hostent.h_addr_list[NextIpToTry], m_Hostent.h_length);

		IncNextIpToTry();

		DebugTrace((LPARAM) this, "connecting to %s with IpAddress %s",
               m_HostName, inet_ntoa( *(struct in_addr UNALIGNED *) &connect_addr.sin_addr));

		fRet = IssueTcpConnect(connect_addr);
	}
	else
	{
		fRet = FALSE;
	}

Exit:

	 if(IsDomainLiteral)
	 {
		//put back the old character
		*pEndIp = OldChar;
	 }

    //could not connect to any of smarthosts' IP addresses
    //ErrorTrace((LPARAM) 0, "could not connect to host %s , error =%i", HostName, RetError);
    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

BOOL CAsyncConnection::ConnectToHost(DWORD IpAddress)
{
	unsigned long InetAddr = 0;
    char * pEndIp = NULL;
	char * pRealHost = NULL;
	char OldChar = '\0';
	struct hostent *hp = NULL;
	BOOL fRet = FALSE;
	BOOL IsDomainLiteral = FALSE;
	SOCKADDR_IN  connect_addr;

    TraceFunctEnterEx((LPARAM) this, "ConnectToHost(DWORD)");

	_ASSERT(AsyncSock == INVALID_SOCKET);

	AsyncSock = socket(AF_INET, SOCK_STREAM, 0);
	if(AsyncSock == INVALID_SOCKET)
	{
		m_Error = WSAGetLastError();
        ErrorTrace((LPARAM) this, "socket returned %d", m_Error);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
	}

	SetSocketOptions();

	//turn the socket into non-blocking mode and ask winsock to notify
	//us when the connect happens
	m_Error = WSAEventSelect(AsyncSock, m_SignalHandle, FD_CONNECT);
	if(m_Error == SOCKET_ERROR)
	{
		m_Error = WSAGetLastError();
		closesocket(AsyncSock);
		AsyncSock = INVALID_SOCKET;
        ErrorTrace((LPARAM) this, "WSAEventSelect returned %d", m_Error);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
	}

	pRealHost = m_HostName;

    //see if this is a domain literal
    if(pRealHost[0] == '[')
    {
		pEndIp = strchr(pRealHost, ']');
		if(pEndIp == NULL)
		{
			m_Error = WSAHOST_NOT_FOUND;
			goto Exit;
		}

			//save the old character
			OldChar = *pEndIp;

			//null terminate the string
		*pEndIp = '\0';
		IsDomainLiteral = TRUE;
		pRealHost++;
    }

	if(IsFirstTime())
	{
		SetFirstTime(FALSE);	

		//Is this an ip address
 		InetAddr = inet_addr( (char *) pRealHost );
		if(InetAddr != INADDR_NONE)
		{
			if(IsDomainLiteral)
			{
				//put back the old character
				*pEndIp = OldChar;
			}

			CopyMemory(&connect_addr.sin_addr, &InetAddr, 4);

			return IssueTcpConnect(connect_addr);
		}
	}

	CopyMemory(&connect_addr.sin_addr, &IpAddress, 4);

	DebugTrace((LPARAM) this, "connecting to %s with IpAddress %s",
               m_HostName, inet_ntoa( *(struct in_addr UNALIGNED *) &connect_addr.sin_addr));

	fRet = IssueTcpConnect(connect_addr);

Exit:

	 if(IsDomainLiteral)
	 {
		//put back the old character
		*pEndIp = OldChar;
	 }

    //could not connect to any of smarthosts' IP addresses
    //ErrorTrace((LPARAM) 0, "could not connect to host %s , error =%i", HostName, RetError);
    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\adsiisex\adsiisex.cpp ===
#include <windows.h>
#include <ole2.h>

#include <atlbase.h>
#include <iads.h>

#include "adsiisex.hxx"

#include "nntpadm.h"
#include "smtpadm.h"
#include "pop3adm.h"
#include "imapadm.h"

//--------------------------------------------------------------------
//
//	Macros:
//
//--------------------------------------------------------------------

#define BAIL_ON_FAILURE(hr)	\
{							\
	if ( FAILED(hr) ) {		\
		goto Exit;			\
	}						\
}
#define BAIL_WITH_FAILURE(hr, hrFailureCode)	\
{							\
	(hr) = (hrFailureCode);	\
	goto Exit;				\
}

#define ARRAY_SIZE(arr) (sizeof (arr) / sizeof ( (arr)[0] ) )

//--------------------------------------------------------------------
//
//	Types:
//
//--------------------------------------------------------------------

typedef struct tagExtClassEntry
{
	DWORD			dwId;
	LPCWSTR			wszClass;
	const CLSID *	clsid;
	const IID *		iid;
	LPCWSTR			wszInstancePrefix;
} EXT_CLASS_ENTRY;

enum {
	NNTP_REBUILD_ID		= 1,
	NNTP_SESSIONS_ID,
	NNTP_FEEDS_ID,
	NNTP_EXPIRES_ID,
	NNTP_GROUPS_ID,
	SMTP_SESSIONS_ID,
	SMTP_ALIAS_ID,
	SMTP_USER_ID,
	SMTP_DL_ID,
	POP3_SESSIONS_ID,
	IMAP_SESSIONS_ID
};

#define NNTPSVC_KEY     _T("NNTPSVC/")
#define SMTPSVC_KEY     _T("SMTPSVC/")
#define POP3SVC_KEY     _T("POP3SVC/")
#define IMAPSVC_KEY     _T("IMAPSVC/")

//--------------------------------------------------------------------
//
//	Global data:
//
//--------------------------------------------------------------------


static EXT_CLASS_ENTRY s_rgClasses [] = {

	{ NNTP_REBUILD_ID, _T("IIsNntpRebuild"), &CLSID_CNntpAdminRebuild, &IID_INntpAdminRebuild, NNTPSVC_KEY },
	{ NNTP_SESSIONS_ID, _T("IIsNntpSessions"), &CLSID_CNntpAdminSessions, &IID_INntpAdminSessions, NNTPSVC_KEY },
	{ NNTP_FEEDS_ID, _T("IIsNntpFeeds"), &CLSID_CNntpAdminFeeds, &IID_INntpAdminFeeds, NNTPSVC_KEY },
	{ NNTP_EXPIRES_ID, _T("IIsNntpExpiration"), &CLSID_CNntpAdminExpiration, &IID_INntpAdminExpiration, NNTPSVC_KEY },
	{ NNTP_GROUPS_ID, _T("IIsNntpGroups"), &CLSID_CNntpAdminGroups, &IID_INntpAdminGroups, NNTPSVC_KEY },

	{ SMTP_SESSIONS_ID, _T("IIsSmtpSessions"), &CLSID_CSmtpAdminSessions, &IID_ISmtpAdminSessions, SMTPSVC_KEY },
	{ SMTP_ALIAS_ID, _T("IIsSmtpAlias"), &CLSID_CSmtpAdminAlias, &IID_ISmtpAdminAlias, SMTPSVC_KEY },
	{ SMTP_USER_ID, _T("IIsSmtpUser"), &CLSID_CSmtpAdminUser, &IID_ISmtpAdminUser, SMTPSVC_KEY },
	{ SMTP_DL_ID, _T("IIsSmtpDL"), &CLSID_CSmtpAdminDL, &IID_ISmtpAdminDL, SMTPSVC_KEY },

	{ POP3_SESSIONS_ID, _T("IIsPop3Sessions"), &CLSID_CPop3AdminSessions, &IID_IPop3AdminSessions, POP3SVC_KEY },
	{ IMAP_SESSIONS_ID, _T("IIsImapSessions"), &CLSID_CImapAdminSessions, &IID_IImapAdminSessions, IMAPSVC_KEY },
};

//--------------------------------------------------------------------
//
//	Function Prototypes:
//
//--------------------------------------------------------------------

template <class Type>
HRESULT InitializeClass ( 
	IUnknown *		pUnk, 
	const IID *		pIID, 
	LPCWSTR			wszServer, 
	DWORD			dwInstance,
	Type *			pIgnored
	);

static int FindClassIndex ( LPCWSTR wszClass );
static void MakeUpperCase ( LPWSTR wsz );
static HRESULT ExtractInstanceFromPath ( LPCWSTR wszPath, LPCWSTR wszSearch, DWORD * pdwInstance );

//
// Extension DLL interface
//

extern "C"
{
	BOOL STDAPICALLTYPE IsExtensionClass ( LPCWSTR wszClass );

	HRESULT STDAPICALLTYPE CreateExtensionClass ( 
							IADs FAR *				pADs,
							LPCWSTR					wszClass,
							LPCWSTR					wszServerName,
							LPCWSTR					wszAdsPath,
							const GUID *			piid,
							void **					ppObject
							);
}

// Variable declarations to make sure we have the types right:

static IS_EXTENSION_CLASS_FUNCTION			fp1 = IsExtensionClass;
static CREATE_EXTENSION_CLASS_FUNCTION		fp2 = CreateExtensionClass;

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/);

//--------------------------------------------------------------------
//
//	Functions:
//
//--------------------------------------------------------------------

template <class Type>
HRESULT InitializeClass ( 
	IUnknown *		pUnk, 
	const IID *		pIID, 
	LPCWSTR			wszServer, 
	DWORD			dwInstance,
    IADs *          pADs,
	Type *			pIgnored
	)
{
	HRESULT			hr			= NOERROR;
	CComPtr<Type>	pObject;

	hr = pUnk->QueryInterface ( *pIID, (void **) &pObject );
	BAIL_ON_FAILURE(hr);

	hr = pObject->put_Server ( const_cast<BSTR> (wszServer) );
	BAIL_ON_FAILURE(hr);

	hr = pObject->put_ServiceInstance ( dwInstance );
	BAIL_ON_FAILURE(hr);

	hr = pObject->put_IADsPointer ( pADs );
	BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}

int FindClassIndex ( LPCWSTR wszClass )
{
	int i;

	for ( i = 0; i < ARRAY_SIZE(s_rgClasses); i++ ) {
		if ( ! lstrcmpi ( wszClass, s_rgClasses[i].wszClass ) ) {
			return i;
		}
	}

	return -1;
}

void MakeUpperCase ( LPWSTR wsz )
{
	while ( *wsz ) {
		*wsz = towupper ( *wsz );
		wsz++;
	}
}

HRESULT ExtractInstanceFromPath ( 
	LPCWSTR 	wszPath, 
	LPCWSTR 	wszSearch, 
	DWORD * 	pdwInstance 
	)
{
	HRESULT		hr = NOERROR;
	DWORD		dwInstance = 0;
	CComBSTR	strPath;
	CComBSTR	strSearch;
	LPWSTR		wszMatch;
	LPWSTR		wszInstance;

	//
	//	Convert everything to upper case:
	//

	strPath		= wszPath;
	strSearch	= wszSearch;
	if ( !strPath || !strSearch ) {
		BAIL_WITH_FAILURE(hr, E_FAIL);
	}

	MakeUpperCase ( strPath );
	MakeUpperCase ( strSearch );

	wszMatch = wcsstr ( strPath, strSearch );
	if ( !wszMatch ) {
		BAIL_WITH_FAILURE(hr, E_FAIL);
	}

	wszInstance = wszMatch + wcslen ( strSearch );

	dwInstance = (DWORD) _wtoi ( wszInstance );

	if ( dwInstance == 0 ) {
		BAIL_WITH_FAILURE(hr, E_FAIL);
	}

	*pdwInstance = dwInstance;

Exit:
	return hr;
}

//
// Extension DLL interface
//

BOOL STDAPICALLTYPE 
IsExtensionClass ( 
	LPCWSTR wszClass 
	)
{
	return ( FindClassIndex ( wszClass ) != -1 );
}

HRESULT STDAPICALLTYPE 
CreateExtensionClass (
	IADs FAR *				pADs,
	LPCWSTR					wszClass,
	LPCWSTR					wszServerName,
	LPCWSTR					wszAdsPath,
	const GUID *			piid,
	void **					ppObject
	)
{
	HRESULT				hr	= NOERROR;
	int 				index;
	DWORD				dwId;
	const GUID *		clsidClass;
	const GUID *		iidClass;
	LPCWSTR				wszInstancePrefix;

	DWORD				dwInstance;
	CComPtr<IUnknown>	pUnk;

	index = FindClassIndex ( wszClass );
	if ( index == -1 ) {
		BAIL_WITH_FAILURE(hr, E_FAIL);
	}

	dwId 				= s_rgClasses[index].dwId;
	clsidClass			= s_rgClasses[index].clsid;
	iidClass			= s_rgClasses[index].iid;
	wszInstancePrefix	= s_rgClasses[index].wszInstancePrefix;

	//
	//	Parse the path:
	//

	hr = ExtractInstanceFromPath ( wszAdsPath, wszInstancePrefix, &dwInstance );
	BAIL_ON_FAILURE(hr);

	//
	//	Create the object:
	//

	hr = CoCreateInstance ( *clsidClass, NULL, CLSCTX_ALL, IID_IUnknown, (void **) &pUnk );
	BAIL_ON_FAILURE(hr);

	//
	//	Now initialize the class:
	//

	switch ( dwId ) {

		case NNTP_REBUILD_ID:
		{
			hr = InitializeClass ( 
								pUnk, 
								iidClass, 
								wszServerName, 
								dwInstance, 
								pADs, 
								(INntpAdminRebuild *) NULL
								);
			BAIL_ON_FAILURE(hr);

			break;
		}

		case NNTP_SESSIONS_ID:
		{
			hr = InitializeClass ( 
								pUnk, 
								iidClass, 
								wszServerName, 
								dwInstance, 
								pADs, 
								(INntpAdminSessions *) NULL
								);
			BAIL_ON_FAILURE(hr);

			break;
		}

		case NNTP_FEEDS_ID:
		{
			hr = InitializeClass ( 
								pUnk, 
								iidClass, 
								wszServerName, 
								dwInstance, 
								pADs, 
								(INntpAdminFeeds *) NULL
								);
			BAIL_ON_FAILURE(hr);

			break;
		}

		case NNTP_EXPIRES_ID:
		{
			hr = InitializeClass ( 
								pUnk, 
								iidClass, 
								wszServerName, 
								dwInstance, 
								pADs, 
								(INntpAdminExpiration *) NULL
								);
			BAIL_ON_FAILURE(hr);

			break;
		}

		case NNTP_GROUPS_ID:
		{
			hr = InitializeClass ( 
								pUnk, 
								iidClass, 
								wszServerName, 
								dwInstance, 
								pADs, 
								(INntpAdminGroups *) NULL
								);
			BAIL_ON_FAILURE(hr);

			break;
		}

		case SMTP_SESSIONS_ID:
		{
			hr = InitializeClass ( 
								pUnk, 
								iidClass, 
								wszServerName, 
								dwInstance, 
								pADs, 
								(ISmtpAdminSessions *) NULL
								);
			BAIL_ON_FAILURE(hr);

			break;
		}

		case POP3_SESSIONS_ID:
		{
			hr = InitializeClass ( 
								pUnk, 
								iidClass, 
								wszServerName, 
								dwInstance, 
								pADs, 
								(IPop3AdminSessions *) NULL
								);
			BAIL_ON_FAILURE(hr);

			break;
		}

		case IMAP_SESSIONS_ID:
		{
			hr = InitializeClass ( 
								pUnk, 
								iidClass, 
								wszServerName, 
								dwInstance, 
								pADs, 
								(IImapAdminSessions *) NULL
								);
			BAIL_ON_FAILURE(hr);

			break;
		}

		case SMTP_ALIAS_ID:
		{
			hr = InitializeClass ( 
								pUnk, 
								iidClass, 
								wszServerName, 
								dwInstance, 
								pADs, 
								(ISmtpAdminAlias *) NULL
								);
			BAIL_ON_FAILURE(hr);

			break;
		}

		case SMTP_USER_ID:
		{
			hr = InitializeClass ( 
								pUnk, 
								iidClass, 
								wszServerName, 
								dwInstance, 
								pADs, 
								(ISmtpAdminUser *) NULL
								);
			BAIL_ON_FAILURE(hr);

			break;
		}
		
		case SMTP_DL_ID:
		{
			hr = InitializeClass ( 
								pUnk, 
								iidClass, 
								wszServerName, 
								dwInstance, 
								pADs, 
								(ISmtpAdminDL *) NULL
								);
			BAIL_ON_FAILURE(hr);

			break;
		}

		default:
			BAIL_WITH_FAILURE(hr,E_FAIL);
	}

	//
	//	Get the desired interface:
	//

	hr = pUnk->QueryInterface ( *piid, ppObject );
	BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
    }
    return TRUE;    // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\admin\adsiisex\makefile.inc ===
$(O)\nntpadm.h $(O)\nntpadm_i.c : $(STAXINC)\export\nntpadm.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\nntpadm_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\nntpadm_i.c \
    -header $@ \
    -tlb $(O)\nntpadm.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpadm.h $(O)\smtpadm_i.c : $(STAXINC)\export\smtpadm.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpadm_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpadm_i.c \
    -header $@ \
    -tlb $(O)\smtpadm.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\pop3adm.h $(O)\pop3adm_i.c : pop3adm.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\pop3adm_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\pop3adm_i.c \
    -header $@ \
    -tlb $(O)\pop3adm.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\imapadm.h $(O)\imapadm_i.c : imapadm.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\imapadm_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\imapadm_i.c \
    -header $@ \
    -tlb $(O)\imapadm.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

copytlb:
#    xcopy /verifd $(STAXINC)\export\activeds.tlb .
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\basetrac\dbgext\tracext.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: traceext.cpp
//
//  Description:    Debug extension to dump callstack info generated by 
//      basetrac.lib
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/29/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <string.h>
#include <dbgtrace.h>
#include <imagehlp.h>

//Since we are a debugger extension...we will do away with the niceties of C++
//Object encapsulation
#define protected   public
#define private     public

#include <basetrac.h>
#include <transdbg.h>

TRANS_DEBUG_EXTENSION(dumpcallstack)
{
    CCallStackEntry_Base *pkbebAddress = NULL; //address in other process
    BYTE pbCallStack[sizeof(CCallStackEntry_Base)];
    CCallStackEntry_Base *pkbeb = (CCallStackEntry_Base *) pbCallStack;
    DWORD_PTR rgdwptrCallStack[100]; //Buffer for storing call stack data
    DWORD dwStackDepth = 0;
    UCHAR  szSymbol[100];
    ULONG_PTR Displacement = 0;
    ULONG cbBytesRead = 0;
    LPSTR szCallStackType = NULL;

    if (!szArg)
    {
        dprintf("ERROR: Unable to parse arg\n");
        return;
    }

    pkbebAddress = (CCallStackEntry_Base *) GetExpression(szArg);
    if (!ReadMemory((ULONG_PTR) pkbebAddress, pbCallStack,
                    sizeof(CCallStackEntry_Base), &cbBytesRead))
    {
        dprintf("ERROR: Unable to read call stack entry\n");
        return;
    }
    
    if (!ReadMemory((ULONG_PTR) pkbeb->m_pdwptrCallers, 
                    (BYTE *) rgdwptrCallStack, 
                    sizeof(DWORD_PTR)*pkbeb->m_dwCallStackDepth,
                    &cbBytesRead))
    {
        dprintf("ERROR: Unable to read call stack info\n");
        return;
    }

    //See if this entry was ever used..don't dump it if it wasn't
    if (TRACKING_OBJECT_UNUSED == pkbeb->m_dwCallStackType)
        return;

    dprintf("======================================================\n");
    switch(pkbeb->m_dwCallStackType)
    {
      case TRACKING_OBJECT_CONSTRUCTOR:
         szCallStackType = "Object Creation";
         break;
      case TRACKING_OBJECT_ADDREF:
         szCallStackType = "AddRef";
         break;
      case TRACKING_OBJECT_RELEASE:
         szCallStackType = "Release";
         break;
      case TRACKING_OBJECT_DESTRUCTOR:
         szCallStackType = "Object Descructor";
         break;
      default:
         szCallStackType = "User Defined";
    }
    dprintf("Call stack Type: %s (0x%08X)\n", szCallStackType, pkbeb->m_dwCallStackType);
    dprintf("Call stack Depth: %d\n", pkbeb->m_dwCallStackDepth);
    dprintf("Dumping info stored at 0x%08X\n", pkbebAddress);
    for(dwStackDepth = 0; dwStackDepth < pkbeb->m_dwCallStackDepth; dwStackDepth++)
    {
        if (!rgdwptrCallStack[dwStackDepth])
            break;
        GetSymbol((PVOID) rgdwptrCallStack[dwStackDepth], szSymbol, &Displacement);
        dprintf("\t(0x%08X) - %s+0x%X\n", rgdwptrCallStack[dwStackDepth], 
                 szSymbol, Displacement);
    }
    dprintf("======================================================\n");
}

//---[ dumpstacks ]------------------------------------------------------------
//
//
//  Description: 
//      Debugger extension to handle dumping callstack info generated by
//      basetrac.lib
//  Parameters: 
//      szArg    String passed in by debugger
//        ptracbAddress    Pointer to CDebugTrackingObject_Base
//  Returns:
//      -
//  History:
//      10/29/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
TRANS_DEBUG_EXTENSION(dumpstacks)
{
    CDebugTrackingObject_Base *ptracbAddress = NULL; //address on other process
    BYTE pbTrackingObj[sizeof(CDebugTrackingObject_Base)];
    CDebugTrackingObject_Base *ptracb = (CDebugTrackingObject_Base *) pbTrackingObj;
    CCallStackEntry_Base *pkbebAddress = NULL; //address in other process
    ULONG cbBytesRead = 0;
    CHAR szAddress[20];
    DWORD cEntriesToPrint = 0;
    DWORD c2ndPassEntriesToPrint = 0;


    if (!szArg)
    {
        dprintf("USAGE: dumpstacks <address>\n");
        return;
    }
    
    //Get address and read object into memory
    ptracbAddress = (CDebugTrackingObject_Base *) GetExpression(szArg);
    if (!ReadMemory((ULONG_PTR) ptracbAddress, pbTrackingObj, 
                    sizeof(CDebugTrackingObject_Base), &cbBytesRead))
    {
        dprintf("ERROR: Unable to read memory at location 0x%%08X\n", ptracbAddress);
        return;
    }

    if (TRACKING_OBJ_SIG != ptracb->m_dwSignature)
    {
        dprintf("ERROR: Invalid Signature on tracking object\n");
        return;
    }


    //Loop through stack entries and dump them
    pkbebAddress = ptracb->m_pkbebCallStackEntries;

    cEntriesToPrint = ptracb->m_cCurrentStackEntries;
    if (cEntriesToPrint > ptracb->m_cCallStackEntries) //we've wrapped
    {
        cEntriesToPrint = ptracb->m_cCallStackEntries - 
                 (ptracb->m_cCurrentStackEntries % ptracb->m_cCallStackEntries);
        pkbebAddress = (CCallStackEntry_Base *) ( ((BYTE *)pkbebAddress) 
                 + ((ptracb->m_cCurrentStackEntries % 
                     ptracb->m_cCallStackEntries)) *
                   ptracb->m_cbCallStackEntries);
        
        c2ndPassEntriesToPrint = ptracb->m_cCallStackEntries - cEntriesToPrint;
    }

    dprintf("======================================================\n");
    dprintf("Dumping saved call stack info\n");
    dprintf("\t%d Call Stack Entries Logged\n", ptracb->m_cCurrentStackEntries);
    dprintf("\t%d Call Stack Entries Saved\n", c2ndPassEntriesToPrint+cEntriesToPrint);

    if (!cEntriesToPrint) //Nothing to do
        return;

    while(pkbebAddress && cEntriesToPrint)
    {
        wsprintf(szAddress, "0x%08X", pkbebAddress);
        dumpcallstack(hCurrentProcess, hCurrentThread, dwCurrentPc, pExtensionApis, szAddress);
        pkbebAddress = (CCallStackEntry_Base *) ( ((BYTE *)pkbebAddress) 
                        + ptracb->m_cbCallStackEntries);
        cEntriesToPrint--;
    }

    //OK Reset the address and do the first half of the circular buffer.
    pkbebAddress = ptracb->m_pkbebCallStackEntries;
    while(pkbebAddress && c2ndPassEntriesToPrint)
    {
        wsprintf(szAddress, "0x%08X", pkbebAddress);
        dumpcallstack(hCurrentProcess, hCurrentThread, dwCurrentPc, 
                      pExtensionApis, szAddress);
        pkbebAddress = (CCallStackEntry_Base *) ( ((BYTE *)pkbebAddress) 
                        + ptracb->m_cbCallStackEntries);
        c2ndPassEntriesToPrint--;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\basetrac\lib\basetrac.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: basetrac.cpp
//
//  Description:    Tracking of COM-base AddRef's and releases for debug
//      builds.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/28/98 - MikeSwa Created
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <string.h>
#include <dbgtrace.h>
#include <basetrac.h>
#include <imagehlp.h>

CCallStackEntry_Base::CCallStackEntry_Base()
{
    m_dwCallStackType = TRACKING_OBJECT_UNUSED;
    m_dwCallStackDepth = 0;
    m_pdwptrCallers = 0;
}

/*
 -	GetCallStack
 -
 *	Purpose:
 *		Uses the imagehlp APIs to get the call stack.
 *
 *	Parameters:
 *		pdwCaller			An array of return addresses
 *		cFind				Count of stack frames to get
 *
 *	Returns:
 *		VOID
 *
 *  This is a 64-aware version the function from Exchmem.
 *
 */
void CCallStackEntry_Base::GetCallers()
{
    BOOL            fMore;
    STACKFRAME      stkfrm = {0};
    CONTEXT         ctxt;
    HANDLE			hThread;
    HANDLE			hProcess;
    DWORD           cFramesLeft = m_dwCallStackDepth;
    DWORD_PTR      *pdwptrCurrentCaller = m_pdwptrCallers;
    DWORD           i = 0;
    DWORD           dwMachineType =
#ifdef _M_IX86
                        IMAGE_FILE_MACHINE_I386;
#elif defined(_M_AMD64)
                        IMAGE_FILE_MACHINE_AMD64;
#elif defined(_M_IA64)
                        IMAGE_FILE_MACHINE_IA64;
#else
                        IMAGE_FILE_MACHINE_UNKNOWN;
#endif


// This debug code does not currently work on IA64
// Currently, the NT headers to not contain
// the definitions required to make this work:
//  - 64-bit ReadProcessMemory
//  - IA64 Context Full
    if (!m_dwCallStackDepth || !m_pdwptrCallers)
        return;

    hThread = GetCurrentThread();
    hProcess = GetCurrentProcess();

    ZeroMemory(&ctxt, sizeof(CONTEXT));
    ZeroMemory(m_pdwptrCallers, m_dwCallStackDepth * sizeof(DWORD_PTR));

#ifndef CONTEXT_FULL
#define CONTEXT_FULL 0
#pragma message ("Warning: CONTEXT_FULL is not defined in winnt.h")
#endif //CONTEXT_FULL not defined
    ctxt.ContextFlags = CONTEXT_FULL;

    if (!GetThreadContext(hThread, &ctxt))
    {
        stkfrm.AddrPC.Offset = 0;
    }
    else
    {
#if defined(_M_IX86)
        _asm
        {
            mov stkfrm.AddrStack.Offset, esp
            mov stkfrm.AddrFrame.Offset, ebp
            mov stkfrm.AddrPC.Offset, offset DummyLabel
DummyLabel:
        }
#elif defined(_M_MRX000)
        stkfrm.AddrPC.Offset = ctxt.Fir;
        stkfrm.AddrStack.Offset = ctxt.IntSp;
        stkfrm.AddrFrame.Offset = ctxt.IntSp;
#elif defined(_M_ALPHA)
        stkfrm.AddrPC.Offset = ctxt.Fir;
        stkfrm.AddrStack.Offset = ctxt.IntSp;
        stkfrm.AddrFrame.Offset = ctxt.IntSp;
#elif defined(_M_PPC)
        stkfrm.AddrPC.Offset = ctxt.Iar;
        stkfrm.AddrStack.Offset = ctxt.Gpr1;
        stkfrm.AddrFrame.Offset = ctxt.Gpr1;
#else
        stkfrm.AddrPC.Offset = 0;
#endif
    }

    stkfrm.AddrPC.Mode = AddrModeFlat;
    stkfrm.AddrStack.Mode = AddrModeFlat;
    stkfrm.AddrFrame.Mode = AddrModeFlat;


    //Eat the first 2 callers
    for (i = 0; i < 2; i++)
    {
        fMore = StackWalk(
                        dwMachineType,
                        hProcess,
                        hThread,
                        &stkfrm,
                        &ctxt,
                        NULL,
                        SymFunctionTableAccess,
                        SymGetModuleBase,
                        NULL);
        if (!fMore)
            break;
    }

	while (fMore && (cFramesLeft > 0))
	{
        fMore = StackWalk(
                        dwMachineType,
                        hProcess,
                        hThread,
                        &stkfrm,
                        &ctxt,
                        NULL,
                        SymFunctionTableAccess,
                        SymGetModuleBase,
                        NULL);

        if (!fMore)
            break;

        *pdwptrCurrentCaller++ = (DWORD_PTR) stkfrm.AddrPC.Offset;
        cFramesLeft -= 1;
    }
}

CDebugTrackingObject_Base::CDebugTrackingObject_Base()
{
    m_dwSignature = TRACKING_OBJ_SIG;
    m_cCurrentStackEntries = 0;
    m_cCallStackEntries = 0;
    m_cbCallStackEntries = 0;
}

CDebugTrackingObject_Base::~CDebugTrackingObject_Base()
{
    _ASSERT(0 == m_lReferences);
}

void CDebugTrackingObject_Base::LogTrackingEvent(DWORD dwTrackingReason)
{
    CCallStackEntry_Base *pkbeCurrent = NULL;
    DWORD dwIndex = InterlockedIncrement((PLONG) &m_cCurrentStackEntries)-1;
    dwIndex %= m_cCallStackEntries;

    //find pointer to current call stack entry
    pkbeCurrent = (CCallStackEntry_Base *)
        (((BYTE *) m_pkbebCallStackEntries) + dwIndex*m_cbCallStackEntries);
    pkbeCurrent->m_dwCallStackType = dwTrackingReason;
    pkbeCurrent->GetCallers();
}

ULONG CDebugTrackingObject::AddRef()
{
    LogTrackingEvent(TRACKING_OBJECT_ADDREF);
    return CBaseObject::AddRef();
}

ULONG CDebugTrackingObject::Release()
{
    _ASSERT(m_lReferences);
    LogTrackingEvent(TRACKING_OBJECT_RELEASE);
    return CBaseObject::Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\blockmgr\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\blockmgr\blockmgr.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

        blockmgr.cpp

Abstract:

        This module contains the implementation of the block memory manager

Author:

        Keith Lau       (keithlau@microsoft.com)

Revision History:

        keithlau        02/27/98        created

--*/

#include "windows.h"

#include "dbgtrace.h"

#include "filehc.h"
#include "signatur.h"
#include "blockmgr.h"

//
// I really wanted to keep the memory manager completely independent from
// the rest of the stuff, but I realized it makes more sense to have the
// memory manager be aware of the IMailMsgPropertyStream so hrer goes ...
//
// If you remove CommitDirtyBlocks, you can get rid of the include below.
//
#include "mailmsg.h"

//
// A commit writes the entire stream, but possibly using several iterations.
// This specifies how many blocks to write in each iteration.
//
#define CMAILMSG_COMMIT_PAGE_BLOCK_SIZE			256

/***************************************************************************/
// Debug stuff
//
#ifndef _ASSERT
#define _ASSERT(x)		if (!(x)) DebugBreak()
#endif

#ifdef DEBUG_TRACK_ALLOCATION_BOUNDARIES

HRESULT SetAllocationBoundary(
			FLAT_ADDRESS		faOffset,
			LPBLOCK_HEAP_NODE	pNode
			)
{
	DWORD	dwBit;

	faOffset &= BLOCK_HEAP_PAYLOAD_MASK;
	faOffset >>= 2;
	dwBit = (DWORD)(faOffset & 7);
	faOffset >>= 3;
	pNode->stAttributes.rgbBoundaries[faOffset] |= (0x80 >> dwBit);
	return(S_OK);
}

HRESULT VerifyAllocationBoundary(
			FLAT_ADDRESS		faOffset,
			DWORD				dwLength,
			LPBLOCK_HEAP_NODE	pNode
			)
{
	DWORD		dwStartingBit;
	DWORD		dwStartingByte;
	DWORD		dwBitsToScan;

	// 7f because we can start on a boundary and be perfectly cool
	BYTE		bStartingMask = 0x7f;
	BYTE		bEndingMask   = 0xff;

	faOffset &= BLOCK_HEAP_PAYLOAD_MASK;
	faOffset >>= 2;		// DWORD per bit

	// Determine the start
	// note : these casts are safe because the value in faOffset is
	// only 10-bits (BLOCK_HEAP_PAYLOAD_MASK) at this point.
	dwStartingBit = (DWORD)(faOffset & 7);
	dwStartingByte = (DWORD)(faOffset >> 3);
	bStartingMask >>= dwStartingBit;

	// Determine the number of bits to scan, each bit corresponds
	// to a DWORD, rounded up to next DWORD
	dwBitsToScan = dwLength + 3;
	dwBitsToScan >>= 2;

	// Scan it
	// Case 1: Start and End bits within the same byte
	if ((dwStartingBit + dwBitsToScan) <= 8)
	{
		DWORD	dwBitsFromRight = 8 - (dwStartingBit + dwBitsToScan);
		bEndingMask <<= dwBitsFromRight;

		bStartingMask = bStartingMask & bEndingMask;

		if (pNode->stAttributes.rgbBoundaries[dwStartingByte] & bStartingMask)
			return(TYPE_E_OUTOFBOUNDS);
	}
	else
	// Case 2: Multiple bytes
	{
		if (pNode->stAttributes.rgbBoundaries[dwStartingByte++] & bStartingMask)
			return(TYPE_E_OUTOFBOUNDS);

		dwBitsToScan -= (8 - dwStartingBit);
		while (dwBitsToScan >= 8)
		{
			// See if we cross any boundaries
			if (dwBitsToScan >= 32)
			{
				if (*(UNALIGNED DWORD *)(pNode->stAttributes.rgbBoundaries + dwStartingByte) != 0)
					return(TYPE_E_OUTOFBOUNDS);
				dwStartingByte += 4;
				dwBitsToScan -= 32;
			}
			else if (dwBitsToScan >= 16)
			{
				if (*(UNALIGNED WORD *)(pNode->stAttributes.rgbBoundaries + dwStartingByte) != 0)
					return(TYPE_E_OUTOFBOUNDS);
				dwStartingByte += 2;
				dwBitsToScan -= 16;
			}
			else
			{
				if (pNode->stAttributes.rgbBoundaries[dwStartingByte++] != 0)
					return(TYPE_E_OUTOFBOUNDS);
				dwBitsToScan -= 8;
			}
		}

		// Final byte
		if (dwBitsToScan)
		{
			bEndingMask <<= (8 - dwBitsToScan);
			if (pNode->stAttributes.rgbBoundaries[dwStartingByte] & bEndingMask)
				return(TYPE_E_OUTOFBOUNDS);
		}
	}
	return(S_OK);
}

#endif


/***************************************************************************/
// Memory accessor class
//
CPool CBlockMemoryAccess::m_Pool((DWORD)'pBMv');

HRESULT CBlockMemoryAccess::AllocBlock(
			LPVOID	*ppvBlock,
			DWORD	dwBlockSize
			)
{
	TraceFunctEnterEx((LPARAM)this, "CBlockMemoryAccess::AllocBlock");

    _ASSERT(dwBlockSize == BLOCK_HEAP_NODE_SIZE);

	LPVOID pvBlock = m_Pool.Alloc();
    if (pvBlock) {
        ((LPBLOCK_HEAP_NODE) pvBlock)->stAttributes.fFlags = 0;
    } else if (SUCCEEDED(CMemoryAccess::AllocBlock(ppvBlock, BLOCK_HEAP_NODE_SIZE)))
    {
        pvBlock = *ppvBlock;
        ((LPBLOCK_HEAP_NODE) pvBlock)->stAttributes.fFlags = BLOCK_NOT_CPOOLED;
    }

	if (pvBlock)
	{
		ZeroMemory(((LPBLOCK_HEAP_NODE)pvBlock)->rgpChildren, sizeof(LPBLOCK_HEAP_NODE) * BLOCK_HEAP_ORDER);

#ifdef DEBUG_TRACK_ALLOCATION_BOUNDARIES
		ZeroMemory(((LPBLOCK_HEAP_NODE)pvBlock)->stAttributes.rgbBoundaries, BLOCK_HEAP_PAYLOAD >> 5);
#endif
		*ppvBlock = pvBlock;
        TraceFunctLeaveEx((LPARAM) this);
		return(S_OK);
    }

	*ppvBlock = NULL;
	ErrorTrace((LPARAM)this, "CBlockMemoryAccess::AllocBlock failed");

	TraceFunctLeaveEx((LPARAM)this);
	return(E_OUTOFMEMORY);
}

HRESULT CBlockMemoryAccess::FreeBlock(
			LPVOID	pvBlock
			)
{
	TraceFunctEnterEx((LPARAM)this, "CBlockMemoryAccess::FreeBlock");

    if ((((LPBLOCK_HEAP_NODE) pvBlock)->stAttributes.fFlags) &
        BLOCK_NOT_CPOOLED)
    {
        CMemoryAccess::FreeBlock(pvBlock);
    } else {
    	m_Pool.Free(pvBlock);
    }
	return(S_OK);
}


HRESULT CMemoryAccess::AllocBlock(
			LPVOID	*ppvBlock,
			DWORD	dwBlockSize
			)
{
	TraceFunctEnterEx(0, "CMemoryAccess::AllocBlock");

	LPVOID pvBlock = (LPVOID) new BYTE[dwBlockSize];
	if (pvBlock)
	{
		ZeroMemory(pvBlock, dwBlockSize);
		*ppvBlock = pvBlock;
		return(S_OK);
	}

	*ppvBlock = NULL;

	return(E_OUTOFMEMORY);
}

HRESULT CMemoryAccess::FreeBlock(
			LPVOID	pvBlock
			)
{
	TraceFunctEnterEx(0, "CMemoryAccess::FreeBlock");

    delete[] pvBlock;
    TraceFunctLeave();
    return S_OK;
}


/***************************************************************************/
// CBlockContext implementation
//

BOOL CBlockContext::IsValid()
{
	return((m_dwSignature == BLOCK_CONTEXT_SIGNATURE_VALID));
}

void CBlockContext::Set(
			LPBLOCK_HEAP_NODE	pLastAccessedNode,
			FLAT_ADDRESS		faLastAccessedNodeOffset
			)
{
	m_pLastAccessedNode = pLastAccessedNode;
	m_faLastAccessedNodeOffset = faLastAccessedNodeOffset;
	m_dwSignature = BLOCK_CONTEXT_SIGNATURE_VALID;
}

void CBlockContext::Invalidate()
{
	m_dwSignature = BLOCK_CONTEXT_SIGNATURE_INVALID;
}


/***************************************************************************/
// CBlockManager implementation
//

CBlockManager::CBlockManager(
			IMailMsgProperties		*pMsg,
			CBlockManagerGetStream	*pParent
			)
{
	TraceFunctEnterEx((LPARAM)this, "CBlockManager::CBlockManager");

	// Initialize
	m_dwSignature = BLOCK_HEAP_SIGNATURE_VALID;
	m_pRootNode = NULL;
	m_faEndOfData = 0;
	m_idNodeCount = 0;
	m_pParent = pParent;
	m_pMsg = pMsg;
	SetDirty(FALSE);
#ifdef DEBUG
    m_fCommitting = FALSE;
#endif

	TraceFunctLeaveEx((LPARAM)this);
}


CBlockManager::~CBlockManager()
{
	TraceFunctEnterEx((LPARAM)this, "CBlockManager::~CBlockManager");

	// Releases all blocks
	Release();

	// Finally, invalidate signature
	m_dwSignature = BLOCK_HEAP_SIGNATURE_INVALID;

	TraceFunctLeaveEx((LPARAM)this);
}

HRESULT CBlockManager::SetStreamSize(
			DWORD	dwStreamSize
			)
{
	// Initialize the stream size, this is only used when binding a
	// fresh MailMsg object to an existing stream.
	m_faEndOfData = (FLAT_ADDRESS)dwStreamSize;
	m_idNodeCount = ((dwStreamSize + BLOCK_HEAP_PAYLOAD_MASK) >> BLOCK_HEAP_PAYLOAD_BITS);
	return(S_OK);
}

BOOL CBlockManager::IsValid()
{
	return(m_dwSignature == BLOCK_HEAP_SIGNATURE_VALID);
}

HRESULT CBlockManager::GetStream(
			IMailMsgPropertyStream	**ppStream,
			BOOL					fLockAcquired
			)
{
	_ASSERT(ppStream);
	if (!ppStream || !m_pParent)
		return(E_POINTER);

	HRESULT hrRes = m_pParent->GetStream(ppStream, fLockAcquired);
	return(hrRes);
}

HRESULT CBlockManager::MoveToNode(
				LPBLOCK_HEAP_NODE	*ppNode,
				HEAP_NODE_ID		idTargetNode,
				BOOL				fLockAcquired
				)
{
	HRESULT				hrRes = S_OK;
	LPBLOCK_HEAP_NODE	pNode;
	HEAP_NODE_ID		idNode;

	if (!ppNode || !*ppNode)
		return(E_POINTER);

	if (idTargetNode >= m_idNodeCount)
		return(STG_E_INVALIDPARAMETER);

	pNode = *ppNode;
	idNode = pNode->stAttributes.idNode;

	// Jump if in the same parent node
	if (idNode && idTargetNode)
	{
		if (((idNode - 1) >> BLOCK_HEAP_ORDER_BITS) ==
			((idTargetNode - 1) >> BLOCK_HEAP_ORDER_BITS))
		{
			HEAP_NODE_ID		idChildNode = (idTargetNode - 1) & BLOCK_HEAP_ORDER_MASK;
			LPBLOCK_HEAP_NODE	pParent 	= pNode->stAttributes.pParentNode;

			*ppNode = pParent->rgpChildren[idChildNode];
			if (!*ppNode)
				hrRes = LoadBlockIfUnavailable(
							idTargetNode,
							pParent,
							idChildNode,
							ppNode,
							fLockAcquired);
			return(hrRes);
		}
	}
	hrRes = GetNodeFromNodeId(
					idTargetNode,
					ppNode,
					fLockAcquired);
	return(hrRes);
}

HRESULT CBlockManager::GetNextNode(
				LPBLOCK_HEAP_NODE	*ppNode,
				BOOL				fLockAcquired
				)
{
	if (!ppNode || !*ppNode)
		return(E_POINTER);

	HRESULT hrRes = MoveToNode(
				ppNode,
				(*ppNode)->stAttributes.idNode + 1,
				fLockAcquired);
	if (FAILED(hrRes))
		*ppNode = NULL;
	return(hrRes);
}

HRESULT CBlockManager::LoadBlockIfUnavailable(
				HEAP_NODE_ID		idNode,
				LPBLOCK_HEAP_NODE	pParent,
				HEAP_NODE_ID		idChildNode,
				LPBLOCK_HEAP_NODE	*ppNode,
				BOOL				fLockAcquired
				)
{
	_ASSERT(ppNode);

	if (*ppNode)
		return(S_OK);

	HRESULT	hrRes = S_OK;
	IMailMsgPropertyStream	*pStream;

	hrRes = GetStream(&pStream, fLockAcquired);
	if (!SUCCEEDED(hrRes))
		return(E_UNEXPECTED);

	// Calculate the stream offset and load the block

	// idNode shifted really contains an offset not a full pointer here so we
	// can (and must) cast it for the call to ReadBlocks to be OK
	DWORD	dwOffset = (DWORD)(idNode << BLOCK_HEAP_PAYLOAD_BITS);

	if (!fLockAcquired)
		WriteLock();

	if (!*ppNode)
	{
		LPBLOCK_HEAP_NODE	pNode = NULL;
		DWORD				dwLength = BLOCK_HEAP_PAYLOAD;

		hrRes = m_bma.AllocBlock(
					(LPVOID *)&pNode,
					BLOCK_HEAP_NODE_SIZE);
		if (SUCCEEDED(hrRes))
		{
			LPBYTE	pTemp = pNode->rgbData;
			hrRes = pStream->ReadBlocks(
						m_pMsg,
						1,
						&dwOffset,
						&dwLength,
						&pTemp,
						NULL);

			if (FAILED(hrRes) &&
				(hrRes != HRESULT_FROM_WIN32(ERROR_HANDLE_EOF)))
			{
				HRESULT	myRes = m_bma.FreeBlock(pNode);
				_ASSERT(SUCCEEDED(myRes));
			}
			else
			{
				if (pParent)
					pParent->rgpChildren[idChildNode] = pNode;
				pNode->stAttributes.pParentNode = pParent;
                RESET_BLOCK_FLAGS(pNode->stAttributes.fFlags);
				pNode->stAttributes.idChildNode = idChildNode;
				pNode->stAttributes.idNode = idNode;
				pNode->stAttributes.faOffset = dwOffset;
				*ppNode = pNode;
				hrRes = S_OK;
			}
		}
	}

	if (!fLockAcquired)
		WriteUnlock();

	return(hrRes);
}

inline HRESULT CBlockManager::GetEdgeListFromNodeId(
			HEAP_NODE_ID		idNode,
			HEAP_NODE_ID		*rgEdgeList,
			DWORD				*pdwEdgeCount
			)
{
	DWORD			dwCurrentLevel;
	HEAP_NODE_ID	*pEdge = rgEdgeList;

	// This is a strictly internal call, we are assuming the caller
	// will be optimized and will handle cases for idNode <=
	// BLOCK_HEAP_ORDER. Processing only starts for 2 layers or more
	// Debug: make sure we are within range
	_ASSERT(idNode > BLOCK_HEAP_ORDER);
	_ASSERT(idNode <= NODE_ID_ABSOLUTE_MAX);

	// Strip off the root node
	idNode--;

	// We need to do depth minus 1 loops since the top edge will be
	// the remainder of the final loop
	for (dwCurrentLevel = 0;
		 dwCurrentLevel < (MAX_HEAP_DEPTH - 1);
		 )
	{
		// The quotient is the parent node in the upper level,
		// the remainder is the the edge from the parent to the
		// current node.
		*pEdge++ = idNode & BLOCK_HEAP_ORDER_MASK;
		idNode >>= BLOCK_HEAP_ORDER_BITS;
		idNode--;
		dwCurrentLevel++;

		// If the node is less than the number of children per node,
		// we are done.
		if (idNode < BLOCK_HEAP_ORDER)
			break;
	}
	*pEdge++ = idNode;
	*pdwEdgeCount = dwCurrentLevel + 1;
	return(S_OK);
}

//
// Inner-loop optimized for O(1) cost.
//
HRESULT CBlockManager::GetNodeFromNodeId(
			HEAP_NODE_ID		idNode,
			LPBLOCK_HEAP_NODE	*ppNode,
			BOOL				fLockAcquired
			)
{
	HRESULT hrRes = S_OK;

	_ASSERT(IsValid());
	_ASSERT(ppNode);

	// If top level node, we return immediately. Note this is
	// supposed to be the case 90% of the time
	hrRes = LoadBlockIfUnavailable(0, NULL, 0, &m_pRootNode, fLockAcquired);
	if (!idNode || FAILED(hrRes))
	{
		*ppNode = m_pRootNode;
		return(hrRes);
	}

	LPBLOCK_HEAP_NODE	pNode	= m_pRootNode;
	LPBLOCK_HEAP_NODE	*ppMyNode = &m_pRootNode;

	// Now, see if the referenced node exists
	if (idNode >= m_idNodeCount)
		return(STG_E_INVALIDPARAMETER);

	// Optimize for 1 hop, we would scarcely have to go into
	// the else case ...
	if (idNode <= BLOCK_HEAP_ORDER)
	{
		ppMyNode = &(m_pRootNode->rgpChildren[idNode - 1]);
		hrRes = LoadBlockIfUnavailable(idNode, m_pRootNode, idNode - 1, ppMyNode, fLockAcquired);
		if (SUCCEEDED(hrRes))
			*ppNode = *ppMyNode;
	}
	else
	{
		HEAP_NODE_ID		rgEdgeList[MAX_HEAP_DEPTH];
		DWORD				dwEdgeCount;
		HEAP_NODE_ID		CurrentEdge;
		HEAP_NODE_ID		idFactor = 0;

		// Debug: make sure we are within range
		_ASSERT(idNode <= NODE_ID_ABSOLUTE_MAX);

		// Get the edge list, backwards
		GetEdgeListFromNodeId(idNode, rgEdgeList, &dwEdgeCount);
		_ASSERT(dwEdgeCount >= 2);

		// Walk the list backwards
		while (dwEdgeCount--)
		{
			// Find the next bucket and calculate the node ID
			CurrentEdge = rgEdgeList[dwEdgeCount];
			ppMyNode = &(pNode->rgpChildren[CurrentEdge]);
			idFactor <<= BLOCK_HEAP_ORDER_BITS;
			idFactor += (CurrentEdge + 1);

			hrRes = LoadBlockIfUnavailable(idFactor, pNode, CurrentEdge, ppMyNode, fLockAcquired);
			if (FAILED(hrRes))
				break;

			// Set the current node to the bucket in the layer below
			pNode = *ppMyNode;
		}

		// Fill in the results ...
		*ppNode = pNode;
	}

	return(hrRes);
}

//
// Identical optimizations as GetNodeFromNodeId, O(1) cost.
//
HRESULT CBlockManager::GetParentNodeFromNodeId(
			HEAP_NODE_ID		idNode,
			LPBLOCK_HEAP_NODE	*ppNode
			)
{
	HRESULT	hrRes = S_OK;

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::GetParentNodeFromNodeId");

	_ASSERT(IsValid());
	_ASSERT(ppNode);

	// The root node has no parent, this should be avoided
	// before calling this function, be we will fail gracefully
	if (!idNode)
	{
		_ASSERT(idNode != 0);
		*ppNode = NULL;
		return(STG_E_INVALIDPARAMETER);
	}

	// Note m_pRootNode can be NULL if idNode is zero!
	_ASSERT(m_pRootNode);

	LPBLOCK_HEAP_NODE	pNode	= m_pRootNode;
	LPBLOCK_HEAP_NODE	*ppMyNode = &m_pRootNode;

	// Optimize for 1 hop, we would scarcely have to go into
	// the else case ...
	if (idNode > BLOCK_HEAP_ORDER)
	{
		HEAP_NODE_ID		rgEdgeList[MAX_HEAP_DEPTH];
		DWORD				dwEdgeCount;
		HEAP_NODE_ID		CurrentEdge;
		HEAP_NODE_ID		idFactor = 0;

		// Debug: make sure we are within range
		_ASSERT(idNode <= NODE_ID_ABSOLUTE_MAX);

		// Get the edge list, backwards
		GetEdgeListFromNodeId(idNode, rgEdgeList, &dwEdgeCount);
		_ASSERT(dwEdgeCount >= 2);

		// Walk the list backwards
		--dwEdgeCount;
		while (dwEdgeCount)
		{
			// Find the next bucket and calculate the node ID
			CurrentEdge = rgEdgeList[dwEdgeCount];
			ppMyNode = &(pNode->rgpChildren[CurrentEdge]);
			idFactor <<= BLOCK_HEAP_ORDER_BITS;
			idFactor += (CurrentEdge + 1);

			hrRes = LoadBlockIfUnavailable(idFactor, pNode, CurrentEdge, ppMyNode, TRUE);
			if (FAILED(hrRes))
				break;

			// Set the current node to the bucket in the layer below
			pNode = *ppMyNode;

			dwEdgeCount--;
		}
	}

	// Fill in the results ...
	*ppNode = *ppMyNode;
	TraceFunctLeaveEx((LPARAM)this);
	return(hrRes);
}

#define GetNodeIdFromOffset(faOffset)	((faOffset) >> BLOCK_HEAP_PAYLOAD_BITS)

HRESULT CBlockManager::GetPointerFromOffset(
			FLAT_ADDRESS		faOffset,
			LPBYTE				*ppbPointer,
			DWORD				*pdwRemainingSize,
			LPBLOCK_HEAP_NODE	*ppNode
			)
{
	HRESULT				hrRes;
	LPBLOCK_HEAP_NODE	pNode;
	HEAP_NODE_ID		idNode = GetNodeIdFromOffset(faOffset);

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::GetPointerFromOffset");

	_ASSERT(IsValid());
	_ASSERT(m_pRootNode);

	_ASSERT(ppbPointer);
	_ASSERT(pdwRemainingSize);
	_ASSERT(ppNode);

	// Figure out the offset from within the payload
	faOffset &= BLOCK_HEAP_PAYLOAD_MASK;

	hrRes = GetNodeFromNodeId(idNode, &pNode);
	if (SUCCEEDED(hrRes))
	{
		// Fill in the results ...
		*ppbPointer = &(pNode->rgbData[faOffset]);

		// Size of block is always within DWORD boundaries so this cast is OK
		*pdwRemainingSize = (DWORD)(BLOCK_HEAP_PAYLOAD - faOffset);

		*ppNode = pNode;
	}

	TraceFunctLeaveEx((LPARAM)this);
	return(hrRes);
}

HRESULT CBlockManager::InsertNodeGivenPreviousNode(
			LPBLOCK_HEAP_NODE	pNodeToInsert,
			LPBLOCK_HEAP_NODE	pPreviousNode
			)
{
	HRESULT		hrRes = S_OK;

	_ASSERT(IsValid());

	_ASSERT(pNodeToInsert);

	LPBLOCK_HEAP_NODE_ATTRIBUTES	pAttrib		= &pNodeToInsert->stAttributes;

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::InsertNodeGivenPreviousNode");

	if (!pPreviousNode)
	{
		// This is the root node ...
		DebugTrace((LPARAM)this, "Inserting the root node");

		pAttrib->pParentNode = NULL;
		pAttrib->idChildNode = 0;
		pAttrib->idNode = 0;
		pAttrib->faOffset = 0;
        DEFAULT_BLOCK_FLAGS(pAttrib->fFlags);

		m_pRootNode = pNodeToInsert;

		TraceFunctLeaveEx((LPARAM)this);
		return(S_OK);
	}
	else
	{
		LPBLOCK_HEAP_NODE_ATTRIBUTES	pOldAttrib	= &pPreviousNode->stAttributes;

		// Fill out the attributes for the new node, we have a special case for the first node
		// after the root, where we need to explicitly point its parent to the root node
		if (pOldAttrib->idNode == 0)
		{
			pAttrib->pParentNode = m_pRootNode;

			// We are child Id 0 again
			pAttrib->idChildNode = 0;
		}
		else
		{
			pAttrib->pParentNode = pOldAttrib->pParentNode;
			pAttrib->idChildNode = pOldAttrib->idChildNode + 1;
		}
		pAttrib->idNode = pOldAttrib->idNode + 1;
		pAttrib->faOffset = pOldAttrib->faOffset + BLOCK_HEAP_PAYLOAD;
        DEFAULT_BLOCK_FLAGS(pAttrib->fFlags);

		if (pOldAttrib->idChildNode < BLOCK_HEAP_ORDER_MASK)
		{
			// We are in the same parent node, so it's simple
			DebugTrace((LPARAM)this, "Inserting node at slot %u",
					pAttrib->idChildNode);

			pAttrib->pParentNode->rgpChildren[pAttrib->idChildNode] = pNodeToInsert;

			TraceFunctLeaveEx((LPARAM)this);
			return(S_OK);
		}
	}

	// The previous node and the new node have different parents,
	// so we got to work from scratch ...
	LPBLOCK_HEAP_NODE	pNode = NULL;

	// We might as well search from the top ...
	hrRes = GetParentNodeFromNodeId(pAttrib->idNode, &pNode);
	if (SUCCEEDED(hrRes))
	{
		// Update the affected attributes
		DebugTrace((LPARAM)this, "Inserting node at slot 0");

		pAttrib->pParentNode = pNode;
		pAttrib->idChildNode = 0;

		// Hook up our parent
		pNode->rgpChildren[0] = pNodeToInsert;
	}
	else
	{
		// The only reason for failre is that the parent
		// of the requested parent is not allocated
		_ASSERT(hrRes == STG_E_INVALIDPARAMETER);
	}

	TraceFunctLeaveEx((LPARAM)this);
	return(hrRes);
}

HRESULT CBlockManager::GetAllocatedSize(
			FLAT_ADDRESS	*pfaSizeAllocated
			)
{
	HRESULT	hrRes	= S_OK;

	_ASSERT(IsValid());
	_ASSERT(pfaSizeAllocated);

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::GetAllocatedSize");

	if (!pfaSizeAllocated)
		hrRes = STG_E_INVALIDPARAMETER;
	else
		*pfaSizeAllocated = AtomicAdd(&m_faEndOfData, 0);

	TraceFunctLeaveEx((LPARAM)this);
	return(hrRes);
}

HRESULT CBlockManager::AllocateMemory(
			DWORD				dwSizeDesired,
			FLAT_ADDRESS		*pfaOffsetToAllocatedMemory,
			DWORD				*pdwSizeAllocated,
			CBlockContext		*pContext	// Optional
			)
{
	HRESULT			hrRes					= S_OK;

	_ASSERT(IsValid());
	_ASSERT(pfaOffsetToAllocatedMemory);
	_ASSERT(pdwSizeAllocated);

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::AllocateMemory");

	hrRes = AllocateMemoryEx(
					TRUE,
					dwSizeDesired,
					pfaOffsetToAllocatedMemory,
					pdwSizeAllocated,
					pContext);

	TraceFunctLeaveEx((LPARAM)this);
	return (hrRes);
}

HRESULT CBlockManager::AllocateMemoryEx(
			BOOL				fAcquireLock,
			DWORD				dwSizeDesired,
			FLAT_ADDRESS		*pfaOffsetToAllocatedMemory,
			DWORD				*pdwSizeAllocated,
			CBlockContext		*pContext	// Optional
			)
{
	DWORD			dwSize;
	FLAT_ADDRESS	faOffset;
	FLAT_ADDRESS	faStartOfBlock;
	HEAP_NODE_ID	idNode;
	HEAP_NODE_ID	idCurrentNode			= 0;
	HEAP_NODE_ID	idLastNodeToCreate		= 0;
	HRESULT			hrRes					= S_OK;
	BOOL			fMarkStart				= FALSE;

	LPBLOCK_HEAP_NODE	pNode				= NULL;

	_ASSERT(IsValid());
	_ASSERT(pfaOffsetToAllocatedMemory);
	_ASSERT(pdwSizeAllocated);

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::AllocateMemoryEx");

	// First of all, we do an atomic reservation of the memory
	// which allows multiple threads to concurrently call
	// AllocateMemory
	// DWORD-align the allocation
	dwSizeDesired += BLOCK_DWORD_ALIGN_MASK;
	dwSizeDesired &= ~(BLOCK_DWORD_ALIGN_MASK);
	faStartOfBlock = AtomicAdd(&m_faEndOfData, dwSizeDesired);

	// Fill this in first so if we succeed, we won't have to fill
	// this in everywhere and if this fails, it's no big deal.
	*pdwSizeAllocated = dwSizeDesired;

	DebugTrace((LPARAM)this, "Allocating %u bytes", dwSizeDesired);

	// OK, we have two scenarios.
	// 1) The current block is large enough to honor the request
	// 2) We need one or more extra blocks to accomodate the
	// request.
	idNode = GetNodeIdFromOffset(faStartOfBlock);

	// Calculate all the required parameters
	faOffset = faStartOfBlock & BLOCK_HEAP_PAYLOAD_MASK;
	dwSize = BLOCK_HEAP_PAYLOAD - (DWORD)faOffset;

	// Invalidate the context
	if (pContext)
		pContext->Invalidate();

	if (idNode < m_idNodeCount)
	{
		// The starting node exists
		hrRes = GetNodeFromNodeId(idNode, &pNode);
        if (FAILED(hrRes)) {
            TraceFunctLeave();
            return hrRes;
        }

		_ASSERT(pNode);

#ifdef DEBUG_TRACK_ALLOCATION_BOUNDARIES

		// Set the beginning of the allocation
		SetAllocationBoundary(faStartOfBlock, pNode);

#endif

		// Set the context here, most likely a write will follow immediately
		if (pContext)
			pContext->Set(pNode, pNode->stAttributes.faOffset);

		if (dwSize >= dwSizeDesired)
		{
			// Scenario 1: enough space left
			DebugTrace((LPARAM)this, "Allocated from existing node");

			// Just fill in the output parameters
			*pfaOffsetToAllocatedMemory = faStartOfBlock;
			TraceFunctLeaveEx((LPARAM)this);
			return(S_OK);
		}

		// Scenario 2a: More blocks needed, starting from the
		// next block, see how many more we need
		dwSizeDesired -= dwSize;
	}
	else
	{
		// Scenario 2b: More blocks needed.

		// NOTE: This should be a rare code path except for
		// high contention ...

		// Now we have again 2 cases:
		// 1) If our offset is in the middle of a block, then
		// we know another thread is creating the current block
		// and all we have to do is to wait for the block to be
		// created, but create any subsequent blocks.
		// 2) If we are exactly at the start of the block, then
		// it is the responsibility of the current thread to
		// create the block.
		if (faOffset != 0)
		{
			// Scenario 1: We don't have to create the current block.
			// so skip the current block
			dwSizeDesired -= dwSize;
		}
	}

	DebugTrace((LPARAM)this, "Creating new node");

	// We must grab an exclusive lock before we go ahead and
	// create any blocks
#ifndef BLOCKMGR_DISABLE_CONTENTION_CONTROL
	if (fAcquireLock) WriteLock();
#endif

	// At this point, we can do whatever we want with the node
	// list and nodes. We will try to create all the missing
	// nodes, whether or not it lies in our desired region or not.
	//
	// We need to do this because if an allocation failed before,
	// we have missing nodes between the end of the allocated nodes
	// and the current node we are allocating. Since these nodes
	// contain links to the deeper nodes, we will break if we have
	// missing nodes.
	//
	// This is necessary since this function is not serailzed
	// elsewhere. So a thread entering later than another can
	// grab the lock before the earlier thread. If we don't
	// fill in the bubbles, the current thread will still have
	// to wait for the earlier blocks to be created by the
	// earlier thread. We would also have chaos if our allocations
	// worked and the ones in front of us failed. This may be
	// a bottleneck for all threads on this message, but once
	// we're done this lock, they'll all unblock. Moreover, if
	// we fail, they will all have to fail!

	// Figure out how many blocks to create, up to the known limit
	idLastNodeToCreate =
		(m_faEndOfData + BLOCK_HEAP_PAYLOAD_MASK) >> BLOCK_HEAP_PAYLOAD_BITS;

	// We know where the block starts, question is whether we're
	// successful or not.
	*pfaOffsetToAllocatedMemory = faStartOfBlock;

	// The node count could have changed while we were waiting
	// for the lock, so we have to refresh our records.
	// Better yet, if another thread already created our blocks
	// for us, we can just leave ...
	idCurrentNode = m_idNodeCount;

	if (idCurrentNode < idLastNodeToCreate)
	{
		LPBLOCK_HEAP_NODE	pNewNode	= NULL;
		BOOL				fSetContext	= TRUE;

		// No such luck, gotta go in and do the hard work ...

		if (!pContext)
			fSetContext = FALSE;

		// Now, we have a function that inserts a node given
		// the pervious node (not the parent), so we have to
		// go find the previous node. This has got to be
		// there unless our node list is messed up.
		pNode = NULL;
		if (idCurrentNode > 0)
		{
			// This is not the root, so we can find its prev.
			hrRes = GetNodeFromNodeId(idCurrentNode - 1, &pNode, TRUE);
            if (FAILED(hrRes)) {
#ifndef BLOCKMGR_DISABLE_CONTENTION_CONTROL
	            if (fAcquireLock) WriteUnlock();
#endif
                TraceFunctLeave();
                return hrRes;
            }
			_ASSERT(pNode);
			_ASSERT(pNode->stAttributes.idNode == (idCurrentNode -1));
		}

		while (idCurrentNode < idLastNodeToCreate)
		{
			hrRes = m_bma.AllocBlock((LPVOID *)&pNewNode, sizeof(BLOCK_HEAP_NODE));
			if (!SUCCEEDED(hrRes))
			{
				// We can't proceed, but what we've got is cool
				DebugTrace((LPARAM)this,
						"Failed to allocate node %u", idCurrentNode);
				break;
			}

			DebugTrace((LPARAM)this, "Allocated node %u", idCurrentNode);

#ifdef DEBUG_TRACK_ALLOCATION_BOUNDARIES

			// Need to do some work here
			ZeroMemory(pNewNode->stAttributes.rgbBoundaries,
						sizeof(pNewNode->stAttributes.rgbBoundaries));

			// See if we have to mark the start of the
#endif

			// Got the block, fill in the info and insert the block
			// Again, we shouldn't fail if we get this far.
			hrRes = InsertNodeGivenPreviousNode(pNewNode, pNode);
			_ASSERT(SUCCEEDED(hrRes));

			// Set the context value here if we need to note if the
			// following condition is TRUE, we were in scenario 2b above.
			if (idCurrentNode == idNode)
			{
				if (fSetContext)
				{
					// The context is actually the node that marks the
					// start of the reserved block
					// Note we only need to do this if we were in scenario
					// 2b above.
					pContext->Set(pNewNode, pNewNode->stAttributes.faOffset);
					fSetContext = FALSE;
				}

#ifdef DEBUG_TRACK_ALLOCATION_BOUNDARIES

				// Set the beginning of the allocation
				SetAllocationBoundary(faStartOfBlock, pNewNode);

#endif
			}

			// Next
			pNode = pNewNode;
			idCurrentNode++;
		}

		// Now update the counter to reflect what we've created.
		m_idNodeCount = idCurrentNode;
	}

#ifndef BLOCKMGR_DISABLE_CONTENTION_CONTROL
	if (fAcquireLock) WriteUnlock();
#endif

	TraceFunctLeaveEx((LPARAM)this);
	return (hrRes);
}

BOOL CBlockManager::IsMemoryAllocated(
			FLAT_ADDRESS		faOffset,
			DWORD				dwLength
			)
{
	// Note we chack for actually allocated memory by checking
	// m_idNodeCount, where m_faEndOfData includes data that is
	// reserved but not yet allocated.
	HEAP_NODE_ID	idNode = GetNodeIdFromOffset(faOffset);
	if (idNode < m_idNodeCount)
	{
		idNode = GetNodeIdFromOffset(faOffset + dwLength - 1);
		if (idNode < m_idNodeCount)
			return(TRUE);
		_ASSERT(FALSE);
	}

	_ASSERT(FALSE);
	return(FALSE);
}

HRESULT CBlockManager::OperateOnMemory(
			DWORD			dwOperation,
			LPBYTE			pbBuffer,
			FLAT_ADDRESS	faTargetOffset,
			DWORD			dwBytesToDo,
			DWORD			*pdwBytesDone,
			CBlockContext	*pContext	// Optional
			)
{
	BOOL				fUseContext	= (pContext != NULL);
	BOOL				fBounddaryCheck = !(dwOperation & BOP_NO_BOUNDARY_CHECK);
	BOOL				fLockAcquired = (dwOperation & BOP_LOCK_ACQUIRED);
	DWORD   			dwHopsAway	= 0;
	HRESULT				hrRes		= S_OK;
	LPBLOCK_HEAP_NODE	pNode		= NULL;

	_ASSERT(IsValid());
	_ASSERT(pbBuffer);
	_ASSERT(pdwBytesDone);

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::OperateOnMemory");

	// Mask out the operation
	dwOperation &= BOP_OPERATION_MASK;

	if (fUseContext)
	{
		FLAT_ADDRESS	faOffset = pContext->m_faLastAccessedNodeOffset;

		// We will not continue if a bad context is passed in
		if (!pContext->IsValid())
			fUseContext = FALSE;
		else
		{
			// More debug sanity checks
			_ASSERT(pContext->m_pLastAccessedNode->stAttributes.faOffset
						== faOffset);

			// We will see if the context really helps
			if (faOffset <= faTargetOffset)
			{
				// Let's see how many hops away
				dwHopsAway = (DWORD)
					((faTargetOffset - faOffset) >> BLOCK_HEAP_PAYLOAD_BITS);

				// Not worth it if more than a number of hops away
				if (dwHopsAway > BLOCK_MAX_ALLOWED_LINEAR_HOPS)
					fUseContext = FALSE;
			}
			else
				fUseContext = FALSE;
		}
	}

	if (fUseContext)
	{
        DebugTrace((LPARAM) this, "using context");
		// Quickly access the starting target node ...
		pNode = pContext->m_pLastAccessedNode;
		while (dwHopsAway--)
		{
			hrRes = GetNextNode(&pNode, fLockAcquired);
			if (FAILED(hrRes))
			{
				fUseContext = FALSE;
				break;
			}
		}
	}
	if (!fUseContext)
	{
        DebugTrace((LPARAM) this, "ignoring context");
		// Okay, gotta find the desired node from scratch ...
		hrRes = GetNodeFromNodeId( GetNodeIdFromOffset(faTargetOffset),
									&pNode,
									fLockAcquired);
		if (!SUCCEEDED(hrRes))
		{
			ErrorTrace((LPARAM)this, "GetNodeIdFromOffset failed");
			TraceFunctLeaveEx((LPARAM)this);
			return(STG_E_INVALIDPARAMETER);
		}

		_ASSERT(pNode);
	}

    DebugTrace((LPARAM) this, "pNode = 0x%x", pNode);

    _ASSERT(pNode != NULL);

	if (!IsMemoryAllocated(faTargetOffset, dwBytesToDo))
	{
		ErrorTrace((LPARAM)this,
				"Specified range is unallocated");
		TraceFunctLeaveEx((LPARAM)this);
		return(STG_E_INVALIDPARAMETER);
	}

	// Clear the counter ...
	*pdwBytesDone = 0;

	// Do the actual processing
	switch (dwOperation)
	{
	case BOP_READ:
	case BOP_WRITE:
		{
			DWORD dwChunkSize;
			DWORD dwBytesDone = 0;

			faTargetOffset &= BLOCK_HEAP_PAYLOAD_MASK;
			dwChunkSize = (DWORD)(BLOCK_HEAP_PAYLOAD - faTargetOffset);
			while (dwBytesToDo)
			{
				if (dwBytesToDo < dwChunkSize)
					dwChunkSize = dwBytesToDo;

#ifdef DEBUG_TRACK_ALLOCATION_BOUNDARIES
				if (fBounddaryCheck)
				{
					// Make sure we are not stepping over boundaries
					hrRes = VerifyAllocationBoundary(faTargetOffset,
										dwChunkSize,
										pNode);
					if (!SUCCEEDED(hrRes))
						break;
				}
#endif

				if (dwOperation == BOP_READ)
				{
					DebugTrace((LPARAM)this,
							"Reading %u bytes", dwChunkSize);
					MoveMemory((LPVOID)pbBuffer,
							   (LPVOID)&(pNode->rgbData[faTargetOffset]),
							   dwChunkSize);
				}
				else
				{
					DebugTrace((LPARAM)this,
							"Writing %u bytes", dwChunkSize);
					MoveMemory((LPVOID)&(pNode->rgbData[faTargetOffset]),
							   (LPVOID)pbBuffer,
							   dwChunkSize);

					// Set the block to dirty
					pNode->stAttributes.fFlags |= BLOCK_IS_DIRTY;

					SetDirty(TRUE);
				}

				// Adjust the read buffer for the next read/write
				pbBuffer += dwChunkSize;

				// Adjust the counters
				dwBytesToDo -= dwChunkSize;
				dwBytesDone += dwChunkSize;

				// After the first operation, the offset will always
				// be zero, and the default chunk size is a full payload
				faTargetOffset = 0;
				dwChunkSize = BLOCK_HEAP_PAYLOAD;

				// Read next chunk
				if (dwBytesToDo)
				{
					// See if we have to load this ...
					hrRes = GetNextNode(&pNode, fLockAcquired);
					if (FAILED(hrRes))
						break;
				}
			}

			// Fill out how much we've done
			*pdwBytesDone = dwBytesDone;
		}
		break;

	default:
		ErrorTrace((LPARAM)this,
				"Invalid operation %u", dwOperation);
		hrRes = STG_E_INVALIDFUNCTION;
	}

	// Update context if succeeded
	if (SUCCEEDED(hrRes) && pContext)
	{
		pContext->Set(pNode, pNode->stAttributes.faOffset);
	}

	TraceFunctLeaveEx((LPARAM)this);
	return(hrRes);
}

HRESULT CBlockManager::ReadMemory(
			LPBYTE			pbBuffer,
			FLAT_ADDRESS	faTargetOffset,
			DWORD			dwBytesToRead,
			DWORD			*pdwBytesRead,
			CBlockContext	*pContext	// Optional
			)
{
	return(OperateOnMemory(
					BOP_READ,
					pbBuffer,
					faTargetOffset,
					dwBytesToRead,
					pdwBytesRead,
					pContext));
}

HRESULT CBlockManager::WriteMemory(
			LPBYTE			pbBuffer,
			FLAT_ADDRESS	faTargetOffset,
			DWORD			dwBytesToWrite,
			DWORD			*pdwBytesWritten,
			CBlockContext	*pContext	// Optional
			)
{
	return(OperateOnMemory(
					BOP_WRITE,
					pbBuffer,
					faTargetOffset,
					dwBytesToWrite,
					pdwBytesWritten,
					pContext));
}

HRESULT CBlockManager::CopyTo(
			FLAT_ADDRESS	faOffset,
			DWORD			dwBytesToCopy,
			CBlockManager	*pTargetBlockManager,
			BOOL			fLockAcquired
			)
{
	HRESULT				hrRes		= S_OK;
	BYTE				bBuffer[4096];
	FLAT_ADDRESS		faCurrent	= faOffset;
	DWORD				dwCopy		= 0;
	DWORD				dwCopied;
	DWORD				dwReadFlags	= BOP_READ | BOP_NO_BOUNDARY_CHECK;
	DWORD				dwWriteFlags= BOP_WRITE | BOP_NO_BOUNDARY_CHECK;

	_ASSERT(IsValid());
	_ASSERT(pTargetBlockManager);

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::CopyTo");

	if (fLockAcquired)
	{
		dwReadFlags |= BOP_LOCK_ACQUIRED;
		dwWriteFlags |= BOP_LOCK_ACQUIRED;
	}

	// Copy in fixed size chunks
	while (dwBytesToCopy)
	{
		dwCopy = sizeof(bBuffer);
		if (dwBytesToCopy < dwCopy)
			dwCopy = dwBytesToCopy;

		// Read block
		hrRes = OperateOnMemory(
					dwReadFlags,
					bBuffer,
					faCurrent,
					dwCopy,
					&dwCopied,
					NULL);
		if (SUCCEEDED(hrRes))
		{
			hrRes = pTargetBlockManager->OperateOnMemory(
						dwWriteFlags,
						bBuffer,
						faCurrent,
						dwCopy,
						&dwCopied,
						NULL);
			faCurrent += (FLAT_ADDRESS)dwCopy;
		}

		if (!SUCCEEDED(hrRes))
			break;

		dwBytesToCopy -= dwCopy;
	}

	TraceFunctLeaveEx((LPARAM)this);
	return(hrRes);
}

HRESULT CBlockManager::ReleaseNode(
			LPBLOCK_HEAP_NODE	pNode
			)
{
	HRESULT	hrRes = S_OK;
	HRESULT	tempRes;

	// Release all children recursively
	for (DWORD i = 0; i < BLOCK_HEAP_ORDER; i++)
		if (pNode->rgpChildren[i])
		{
			tempRes = ReleaseNode(pNode->rgpChildren[i]);
			if (FAILED(tempRes))
				hrRes = tempRes;
			pNode->rgpChildren[i] = NULL;
		}

	// Release self
	m_bma.FreeBlock(pNode);
	return(hrRes);
}

HRESULT CBlockManager::Release()
{
	HRESULT				hrRes		= S_OK;

	_ASSERT(IsValid());

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::Release");

	// This function assumes that no more threads are using this
	// class and no new threads are inside trying to reserve
	// memory. Though, for good measure, this function still
	// grabs a write lock so that at least it does not get
	// corrupt when stray threads are still lingering around.

	// Grab the lock before we go in and destroy the node list
#ifndef BLOCKMGR_DISABLE_CONTENTION_CONTROL
	WriteLock();
#endif

	if (m_pRootNode)
	{
		hrRes = ReleaseNode(m_pRootNode);
		if (SUCCEEDED(hrRes))
			m_pRootNode = NULL;
	}

#ifndef BLOCKMGR_DISABLE_CONTENTION_CONTROL
	WriteUnlock();
#endif

	TraceFunctLeaveEx((LPARAM)this);
	return (hrRes);
}

HRESULT CBlockManager::AtomicDereferenceAndRead(
			LPBYTE			pbBuffer,
			DWORD			*pdwBufferSize,
			LPBYTE			pbInfoStruct,
			FLAT_ADDRESS	faOffsetToInfoStruct,
			DWORD			dwSizeOfInfoStruct,
			DWORD			dwOffsetInInfoStructToOffset,
			DWORD			dwOffsetInInfoStructToSize,
			CBlockContext	*pContext	// Optional
			)
{
	HRESULT			hrRes				= S_OK;
	FLAT_ADDRESS	faOffset;
	DWORD			dwSizeToRead;
	DWORD			dwSizeRead;

	_ASSERT(IsValid());
	_ASSERT(pbBuffer);
	_ASSERT(pdwBufferSize);
	_ASSERT(pbInfoStruct);
	// pContext can be NULL

	TraceFunctEnterEx((LPARAM)this,
			"CBlockManager::AtomicDereferenceAndRead");

#ifndef BLOCKMGR_DISABLE_ATOMIC_FUNCS
	// Acquire the synchronization object
	WriteLock();
#endif

	do
	{
		BOOL	fInsufficient	= FALSE;
		DWORD	dwBufferSize	= *pdwBufferSize;

		// Read the info struct
		DebugTrace((LPARAM)this, "Reading information structure");
		hrRes = OperateOnMemory(
						BOP_READ | BOP_LOCK_ACQUIRED,
						pbInfoStruct,
						faOffsetToInfoStruct,
						dwSizeOfInfoStruct,
						&dwSizeRead,
						pContext);
		if (!SUCCEEDED(hrRes))
			break;

		// Fill out the parameters
		faOffset = *(UNALIGNED FLAT_ADDRESS *)(pbInfoStruct + dwOffsetInInfoStructToOffset);
		dwSizeToRead = *(UNALIGNED DWORD *)(pbInfoStruct + dwOffsetInInfoStructToSize);

		DebugTrace((LPARAM)this, "Reading %u bytes from offset %u",
					dwSizeToRead, (DWORD)faOffset);

		// See if we have enough buffer
		if (dwBufferSize < dwSizeToRead)
		{
			fInsufficient = TRUE;
			DebugTrace((LPARAM)this,
				"Insufficient buffer, only reading %u bytes",
				dwBufferSize);
		}
		else
			dwBufferSize = dwSizeToRead;

		// Do the read
		hrRes = OperateOnMemory(
						BOP_READ | BOP_LOCK_ACQUIRED,
						pbBuffer,
						faOffset,
						dwBufferSize,
						&dwSizeRead,
						pContext);
		if (!SUCCEEDED(hrRes))
			break;

		*pdwBufferSize = dwSizeToRead;

		// If we had insufficient buffer, we must return the
		// correct HRESULT
		if (fInsufficient)
			hrRes = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

	} while (0);

#ifndef BLOCKMGR_DISABLE_ATOMIC_FUNCS
	WriteUnlock();
#endif

	TraceFunctLeaveEx((LPARAM)this);
	return (hrRes);
}

inline HRESULT CBlockManager::WriteAndIncrement(
			LPBYTE			pbBuffer,
			FLAT_ADDRESS	faOffset,
			DWORD			dwBytesToWrite,
			DWORD			*pdwValueToIncrement,
			DWORD			dwIncrementValue,
			CBlockContext	*pContext	// Optional
			)
{
	HRESULT		hrRes				= S_OK;
	DWORD		dwSize;

	_ASSERT(IsValid());
	_ASSERT(pbBuffer);
	// pdwValueToIncrement and pContext can be NULL

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::WriteAndIncrement");

	// Very simple, this function assumes no contention since the caller
	// is already supposed to be in some sort of atomic operation
	hrRes = OperateOnMemory(
				BOP_WRITE | BOP_LOCK_ACQUIRED,
				pbBuffer,
				faOffset,
				dwBytesToWrite,
				&dwSize,
				pContext);
	if (SUCCEEDED(hrRes))
	{
		// This must be true if the write succeeded, but then ...
		_ASSERT(dwBytesToWrite == dwSize);

		// The write is successful, then increment the value in
		// an interlocked fashion. We do that such that simultaneous
		// reads will be locked out properly. Simultaneous writes
		// should be serialized by design but we do this for good
		// measure in case the caller is not aware of this requirement.
		if (pdwValueToIncrement)
			AtomicAdd(pdwValueToIncrement, dwIncrementValue);
	}

	TraceFunctLeaveEx((LPARAM)this);
	return (hrRes);
}

HRESULT CBlockManager::AtomicWriteAndIncrement(
			LPBYTE			pbBuffer,
			FLAT_ADDRESS	faOffset,
			DWORD			dwBytesToWrite,
			DWORD			*pdwValueToIncrement,
			DWORD			dwReferenceValue,
			DWORD			dwIncrementValue,
			CBlockContext	*pContext	// Optional
			)
{
	HRESULT		hrRes				= S_OK;

	_ASSERT(IsValid());
	_ASSERT(pbBuffer);
	// pdwValueToIncrement and pContext can be NULL

	TraceFunctEnterEx((LPARAM)this,
			"CBlockManager::AtomicWriteAndIncrement");

	// Since acquiring the synchronization is potentially costly,
	// we do a final sanity check to make sure no thread had
	// beaten us in taking this slot
	if (pdwValueToIncrement &&
		*pdwValueToIncrement != dwReferenceValue)
	{
		DebugTrace((LPARAM)this, "Aborting due to change in property count");
		TraceFunctLeaveEx((LPARAM)this);
		return(HRESULT_FROM_WIN32(ERROR_RETRY));
	}

#ifndef BLOCKMGR_DISABLE_ATOMIC_FUNCS
	// This is a pass-thru call to the WriteAndIncrement but
	// after acquiring the synchronization object
	WriteLock();
#endif

	// The wait for the lock could have been long, so we do a second
	// check to see if we're out of luck after all this ...
	if (pdwValueToIncrement &&
		*pdwValueToIncrement != dwReferenceValue)
	{
#ifndef BLOCKMGR_DISABLE_ATOMIC_FUNCS
		// Gotta release it!
		WriteUnlock();
#endif

		DebugTrace((LPARAM)this, "Aborting after acquiring lock");
		TraceFunctLeaveEx((LPARAM)this);
		return(HRESULT_FROM_WIN32(ERROR_RETRY));
	}

	hrRes = WriteAndIncrement(
					pbBuffer,
					faOffset,
					dwBytesToWrite,
					pdwValueToIncrement,
					dwIncrementValue,
					pContext);

#ifndef BLOCKMGR_DISABLE_ATOMIC_FUNCS
	WriteUnlock();
#endif

	TraceFunctLeaveEx((LPARAM)this);
	return (hrRes);
}

HRESULT CBlockManager::AtomicAllocWriteAndIncrement(
			DWORD			dwDesiredSize,
			FLAT_ADDRESS	*pfaOffsetToAllocatedMemory,
			FLAT_ADDRESS	faOffsetToWriteOffsetToAllocatedMemory,
			FLAT_ADDRESS	faOffsetToWriteSizeOfAllocatedMemory,
			LPBYTE			pbInitialValueForAllocatedMemory,
			DWORD			dwSizeOfInitialValue,
			LPBYTE			pbBufferToWriteFrom,
			DWORD			dwOffsetInAllocatedMemoryToWriteTo,
			DWORD			dwSizeofBuffer,
			DWORD			*pdwValueToIncrement,
			DWORD			dwReferenceValue,
			DWORD			dwIncrementValue,
			CBlockContext	*pContext	// Optional
			)
{
	HRESULT		hrRes				= S_OK;
	DWORD		dwAllocatedSize;
	DWORD		dwSize;

	_ASSERT(IsValid());
	_ASSERT(pfaOffsetToAllocatedMemory);
	_ASSERT(pbBufferToWriteFrom);
	_ASSERT(pdwValueToIncrement);
	// pContext can be NULL

	TraceFunctEnterEx((LPARAM)this,
			"CBlockManager::AtomicAllocWriteAndIncrement");

	// Since acquiring the synchronization is potentially costly,
	// we do a final sanity check to make sure no thread had
	// beaten us in taking this slot
	if (*pdwValueToIncrement != dwReferenceValue)
	{
		DebugTrace((LPARAM)this, "Aborting due to change in property count");
		TraceFunctLeaveEx((LPARAM)this);
		return(HRESULT_FROM_WIN32(ERROR_RETRY));
	}

#ifndef BLOCKMGR_DISABLE_ATOMIC_FUNCS
	// This is a pass-thru call to AllocateMemoryEx and
	// WriteAndIncrement after acquiring the synchronization object
	WriteLock();
#endif

	// The wait for the lock could have been long, so we do a second
	// check to see if we're out of luck after all this ...
	if (*pdwValueToIncrement != dwReferenceValue)
	{
#ifndef BLOCKMGR_DISABLE_ATOMIC_FUNCS
		// Gotta release it!
		WriteUnlock();
#endif

		DebugTrace((LPARAM)this, "Aborting after acquiring lock");
		TraceFunctLeaveEx((LPARAM)this);
		return(HRESULT_FROM_WIN32(ERROR_RETRY));
	}

	// Try to allocate the requested block
	hrRes = AllocateMemoryEx(
					FALSE,
					dwDesiredSize,
					pfaOffsetToAllocatedMemory,
					&dwAllocatedSize,
					pContext);
	if (SUCCEEDED(hrRes))
	{
		// Okay, initialize the memory allocated
		if (pbInitialValueForAllocatedMemory)
		{
			hrRes = WriteMemory(
						pbInitialValueForAllocatedMemory,
						*pfaOffsetToAllocatedMemory,
						dwSizeOfInitialValue,
						&dwSize,
						pContext);

			// See if we need to write the size and offset info
			if (SUCCEEDED(hrRes))
			{
				if (faOffsetToWriteOffsetToAllocatedMemory !=
						INVALID_FLAT_ADDRESS)
					hrRes = WriteMemory(
								(LPBYTE)pfaOffsetToAllocatedMemory,
								faOffsetToWriteOffsetToAllocatedMemory,
								sizeof(FLAT_ADDRESS),
								&dwSize,
								pContext);

				if (SUCCEEDED(hrRes) &&
					faOffsetToWriteSizeOfAllocatedMemory !=
						INVALID_FLAT_ADDRESS)
					hrRes = WriteMemory(
								(LPBYTE)&dwAllocatedSize,
								faOffsetToWriteSizeOfAllocatedMemory,
								sizeof(DWORD),
								&dwSize,
								pContext);
			}
		}

		if (SUCCEEDED(hrRes))
		{
			// OK, since we got the memory, the write should not
			// fail, but we check the result anyway.
			hrRes = WriteAndIncrement(
							pbBufferToWriteFrom,
							*pfaOffsetToAllocatedMemory +
								dwOffsetInAllocatedMemoryToWriteTo,
							dwSizeofBuffer,
							pdwValueToIncrement,
							dwIncrementValue,
							pContext);
		}
	}

#ifndef BLOCKMGR_DISABLE_ATOMIC_FUNCS
	WriteUnlock();
#endif


	TraceFunctLeaveEx((LPARAM)this);
	return (hrRes);
}

HRESULT CBlockManager::BuildDirtyBlockList(
			FLAT_ADDRESS	faStartingOffset,
			FLAT_ADDRESS	faLengthToScan,
			DWORD			*pdwCount,
			FLAT_ADDRESS	*pfaOffset,
			DWORD			*pdwSize,
			LPBYTE			*ppbData,
			CBlockContext	*pContext
			)
{
	HRESULT				hrRes = S_OK;
	HEAP_NODE_ID		idNode;
	LPBLOCK_HEAP_NODE	pNode = NULL;
	DWORD				dwBlocksToScan;
	BOOL				fLimitedLength;
	DWORD				dwMaxCount;
	DWORD				dwCount = 0;

	_ASSERT(pdwCount);
	_ASSERT(pfaOffset);
	_ASSERT(pdwSize);
	_ASSERT(ppbData);
	_ASSERT(pContext);

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::BuildDirtyBlockList");

	fLimitedLength = FALSE;
	if (faStartingOffset != INVALID_FLAT_ADDRESS)
	{
		idNode = GetNodeIdFromOffset(faStartingOffset);
		if (idNode >= m_idNodeCount)
		{
			hrRes = STG_E_INVALIDPARAMETER;
			goto Cleanup;
		}

		hrRes = GetNodeFromNodeId(idNode, &pNode);
		if (!SUCCEEDED(hrRes))
			goto Cleanup;

		if (faLengthToScan != INVALID_FLAT_ADDRESS)
		{
			// See how many blocks to scan, rounding up
			faLengthToScan += BLOCK_HEAP_PAYLOAD_MASK;
			dwBlocksToScan = (DWORD)(faLengthToScan >> BLOCK_HEAP_PAYLOAD_BITS);
			fLimitedLength = TRUE;
		}
		else
			dwBlocksToScan = 0;
	}
	else
	{
		if (!pContext->m_pLastAccessedNode)
		{
			hrRes = STG_E_INVALIDPARAMETER;
			goto Cleanup;
		}
		pNode = pContext->m_pLastAccessedNode;
	}

	// Loop until we fill up the array or have no more blocks
	dwCount = 0;
	dwMaxCount = *pdwCount;
	while (pNode)
	{
		if (fLimitedLength && !dwBlocksToScan)
		{
			// We're done the specified length, set the correct
			// code and break out.
			hrRes = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
			break;
		}

		if (pNode->stAttributes.fFlags & BLOCK_IS_DIRTY)
		{
			// Make sure we are not full ...
			if (dwCount == dwMaxCount)
			{
				hrRes = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
				break;
			}

			// Undo the dirty bit and mark as pending
			pNode->stAttributes.fFlags &= BLOCK_CLEAN_MASK;
			pNode->stAttributes.fFlags |= BLOCK_PENDING_COMMIT;

			// Fill in the array elements
			*pfaOffset++ = pNode->stAttributes.faOffset;
			*pdwSize++ = BLOCK_HEAP_PAYLOAD;
			*ppbData++ = pNode->rgbData;
			dwCount++;
		}

		// Next node
		hrRes = GetNextNode(&pNode, FALSE);
	}

Cleanup:

	if (SUCCEEDED(hrRes) ||
		hrRes == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
	{
		// Fill in the output
		*pdwCount = dwCount;
	}

	// Update the context
	pContext->Set(pNode, pNode?pNode->stAttributes.faOffset:0);

	TraceFunctLeaveEx((LPARAM)this);
	return(hrRes);
}

HRESULT CBlockManager::MarkAllPendingBlocks(
			BOOL	fClean
			)
{
	HRESULT				hrRes = S_OK;
	LPBLOCK_HEAP_NODE	pNode = m_pRootNode;

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::MarkAllPendingBlocks");

	while (pNode)
	{
		if (pNode->stAttributes.fFlags & BLOCK_PENDING_COMMIT)
		{
			// Cannot be pending and dirty
			_ASSERT(!(pNode->stAttributes.fFlags & BLOCK_IS_DIRTY));

			// Undo the dirty bit and mark as pending
			pNode->stAttributes.fFlags &= ~(BLOCK_PENDING_COMMIT);
			if (!fClean) {
				SetDirty(TRUE);
				pNode->stAttributes.fFlags |= BLOCK_IS_DIRTY;
			}
		}

		// Next node
		hrRes = GetNextNode(&pNode, FALSE);
	}

	TraceFunctLeaveEx((LPARAM)this);
	return(hrRes);
}

HRESULT CBlockManager::MarkBlockAs(
			LPBYTE			pbData,
			BOOL			fClean
			)
{
	LPBLOCK_HEAP_NODE				pNode;

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::MarkBlockAs");

	// Find the attributes record from the data pointer
	pNode = CONTAINING_RECORD(pbData, BLOCK_HEAP_NODE, rgbData);
	_ASSERT(pNode);

	_ASSERT(pNode->stAttributes.fFlags & BLOCK_PENDING_COMMIT);

	// Cannot be pending and dirty
	_ASSERT(!(pNode->stAttributes.fFlags & BLOCK_IS_DIRTY));

	// Undo the dirty bit and mark as pending
	pNode->stAttributes.fFlags &= ~(BLOCK_PENDING_COMMIT);
	if (!fClean) {
		pNode->stAttributes.fFlags |= BLOCK_IS_DIRTY;
		SetDirty(TRUE);
	}

	TraceFunctLeaveEx((LPARAM)this);
	return(S_OK);
}

HRESULT CBlockManager::CommitDirtyBlocks(
			FLAT_ADDRESS			faStartingOffset,
			FLAT_ADDRESS			faLengthToScan,
			DWORD					dwFlags,
			IMailMsgPropertyStream	*pStream,
			BOOL					fDontMarkAsCommit,
			BOOL                    fComputeBlockCountsOnly,
			DWORD                   *pcBlocksToWrite,
			DWORD                   *pcTotalBytesToWrite,
			IMailMsgNotify			*pNotify
			)
{
	HRESULT				hrRes = S_OK;
	HEAP_NODE_ID		idNode;
	LPBLOCK_HEAP_NODE	pNode;
	DWORD				dwBlocksToScan;
	BOOL				fLimitedLength;
	DWORD				dwCount = 0;
	DWORD				rgdwOffset[CMAILMSG_COMMIT_PAGE_BLOCK_SIZE];
	DWORD				rgdwSize[CMAILMSG_COMMIT_PAGE_BLOCK_SIZE];
	LPBYTE				rgpData[CMAILMSG_COMMIT_PAGE_BLOCK_SIZE];
	DWORD				*pdwOffset;
	DWORD				*pdwSize;
	LPBYTE				*ppbData;

	_ASSERT(pStream);

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::CommitDirtyBlocks");

	fLimitedLength = FALSE;
	pNode = NULL;
	if (faStartingOffset != INVALID_FLAT_ADDRESS)
	{
		idNode = GetNodeIdFromOffset(faStartingOffset);
		if (idNode >= m_idNodeCount)
		{
			hrRes = STG_E_INVALIDPARAMETER;
			goto Cleanup;
		}

		hrRes = GetNodeFromNodeId(idNode, &pNode);
		if (!SUCCEEDED(hrRes))
			goto Cleanup;

		if (faLengthToScan != INVALID_FLAT_ADDRESS)
		{
			// See how many blocks to scan, rounding up
			faLengthToScan += (faStartingOffset & BLOCK_HEAP_PAYLOAD_MASK);
			faLengthToScan += BLOCK_HEAP_PAYLOAD_MASK;
			dwBlocksToScan = (DWORD)(faLengthToScan >> BLOCK_HEAP_PAYLOAD_BITS);
			fLimitedLength = TRUE;
		}
		else
			dwBlocksToScan = 0;
	}
	else
	{
		hrRes = STG_E_INVALIDPARAMETER;
		goto Cleanup;
	}

	// Loop until we fill up the array or have no more blocks
	dwCount = 0;
	pdwOffset = rgdwOffset;
	pdwSize = rgdwSize;
	ppbData = rgpData;
	while (pNode)
	{
		if (fLimitedLength && !dwBlocksToScan--)
			break;

		if ((dwFlags & MAILMSG_GETPROPS_COMPLETE) ||
			(pNode->stAttributes.fFlags & BLOCK_IS_DIRTY))
		{
			// Make sure we are not full ...
			if (dwCount == CMAILMSG_COMMIT_PAGE_BLOCK_SIZE)
			{
				*pcBlocksToWrite += dwCount;

				if (!fComputeBlockCountsOnly) {
					// We are full, then write out the blocks
					hrRes = pStream->WriteBlocks(
								m_pMsg,
								dwCount,
								rgdwOffset,
								rgdwSize,
								rgpData,
								pNotify);
					if (!SUCCEEDED(hrRes))
						break;

					if (!fDontMarkAsCommit) {
						// Go back and mark all blocks as clean
						ppbData = rgpData;
						while (--dwCount)
							MarkBlockAs(*ppbData++, TRUE);
					}
				}
				dwCount = 0;

				// Reset our pointers and go on
				pdwOffset = rgdwOffset;
				pdwSize = rgdwSize;
				ppbData = rgpData;
			}

			if (!fComputeBlockCountsOnly && !fDontMarkAsCommit) {
				// Undo the dirty bit and mark as pending
				pNode->stAttributes.fFlags &= BLOCK_CLEAN_MASK;
				pNode->stAttributes.fFlags |= BLOCK_PENDING_COMMIT;
			}

			// Fill in the array elements

			// faOffset really contains an offset not a full pointer here so we
			// can (and must) cast it for the calls to WriteBlocks to be OK
			*pdwOffset++ = (DWORD)pNode->stAttributes.faOffset;

			*pdwSize++ = BLOCK_HEAP_PAYLOAD;
			*ppbData++ = pNode->rgbData;
			*pcTotalBytesToWrite += BLOCK_HEAP_PAYLOAD;
			dwCount++;
		}

		// Next node, pNode == NULL if no more nodes
		hrRes = GetNextNode(&pNode, FALSE);
        if (hrRes == STG_E_INVALIDPARAMETER) hrRes = S_OK;
        DebugTrace((LPARAM) this, "hrRes = %x", hrRes);
	}

	if (SUCCEEDED(hrRes) && dwCount)
	{
		*pcBlocksToWrite += dwCount;

		if (!fComputeBlockCountsOnly) {
			// Write out the remaining blocks
			hrRes = pStream->WriteBlocks(
						m_pMsg,
						dwCount,
						rgdwOffset,
						rgdwSize,
						rgpData,
						pNotify);
		}
	}

    if (FAILED(hrRes)) SetCommitMode(FALSE);

	if (!fComputeBlockCountsOnly && !fDontMarkAsCommit && dwCount) {
		// Go back and mark all blocks to the correct state
		ppbData = rgpData;
		while (--dwCount)
			MarkBlockAs(*ppbData++, SUCCEEDED(hrRes));
	}

Cleanup:

	TraceFunctLeaveEx((LPARAM)this);
	return(hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\asynccon\src\ntqio.cxx ===
#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This API sets the "last error value" and the "last error string"
    based on the value of Status. For status codes that don't have
    a corresponding error string, the string is set to null.

Arguments:

    Status - Supplies the status value to store as the last error value.

Return Value:

    The corresponding Win32 error code that was stored in the
    "last error value" thread variable.

--*/

{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}

HANDLE
WINAPI
SmtpRegisterWaitForSingleObject(
    HANDLE hObject,
    WAITORTIMERCALLBACKFUNC Callback,
    PVOID Context,
    ULONG dwMilliseconds
    )
{
    HANDLE WaitHandle ;
    NTSTATUS Status ;

    Status = RtlRegisterWait(
                &WaitHandle,
                hObject,
                Callback,
                Context,
                dwMilliseconds,
                0);            // Need WIN32 specifier

    if ( NT_SUCCESS( Status ) )
    {
        return WaitHandle ;
    }
    
	BaseSetLastNTError( Status );
    return NULL ;
}

BOOL
WINAPI
SmtpUnregisterWait(
    HANDLE WaitHandle
    )
/*++

Routine Description:

    This function cancels a wait for a particular object.

Arguments:

    WaitHandle - Handle returned from RegisterWaitForSingleObject

Return Value:

    TRUE - The wait was cancelled
    FALSE - an error occurred, use GetLastError() for more information.

--*/
{
    NTSTATUS Status ;

    if ( WaitHandle )
    {
        Status = RtlDeregisterWait( WaitHandle );

        if ( NT_SUCCESS( Status ) )
        {
            return TRUE ;
        }

        BaseSetLastNTError( Status );

        return FALSE ;

    }

    SetLastError( ERROR_INVALID_HANDLE );

    return FALSE ;
}

BOOL
WINAPI
SmtpQueueUserWorkItem(
    LPTHREAD_START_ROUTINE Function,
    PVOID Context,
    BOOL PreferIo
    )
/*++

Routine Description:

    This function queues a work item to a thread out of the thread pool.  The
    function passed is invoked in a different thread, and passed the Context
    pointer.  The caller can specify whether the thread pool should select
    a thread that has I/O pending, or any thread.

Arguments:

    Function -  Function to call

    Context -   Pointer passed to the function when it is invoked.

    PreferIo -  Indictes to the thread pool that this thread will perform
                I/O.  A thread that starts an asynchronous I/O operation
                must wait for it to complete.  If a thread exits with
                outstanding I/O requests, those requests will be cancelled.
                This flag is a hint to the thread pool that this function
                will start I/O, so that a thread with I/O already pending
                will be used.

Return Value:

    TRUE - The work item was queued to another thread.
    FALSE - an error occurred, use GetLastError() for more information.

--*/

{
    NTSTATUS Status ;

    Status = RtlQueueWorkItem(
                (WORKERCALLBACKFUNC) Function,
                Context,
                PreferIo ? WT_EXECUTEINIOTHREAD : 0 );

    if ( NT_SUCCESS( Status ) )
    {
        return TRUE ;
    }

    BaseSetLastNTError( Status );

    return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\cmmprops\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\cache2\utest\c2test.cpp ===
/*++

	c2test.cpp

	This file contains the code which tests the V2 Cache.

--*/

#pragma	warning( disable : 4786 )

#include	<windows.h>
#include	<stdio.h>
#include	<stdlib.h>
#include    <xmemwrpr.h>
#include	<time.h>
#include	<dbgtrace.h>
#include	"crchash.h"
#include	"cache2.h"
#include	"perfapi.h"
#include	"perferr.h"

//
//	Setup perfmon counters with perfapi.lib
//
//
#define     IFS_PERFOBJECT_NAME             "Cache UnitTest"
#define     IFS_PERFOBJECT_HELP             "Cache Help"
#define     IFS_PERFOBJECT_INSTANCE         "ROOT"

#define     IFS_COUNTER_SUCCESSCREATES_NAME     "Cache Creates"
#define     IFS_COUNTER_SUCCESSCREATES_HELP     "Number of items found or created in cache"

#define     IFS_COUNTER_FAILEDCREATES_NAME     "Cache Failures"
#define     IFS_COUNTER_FAILEDCREATES_HELP     "Number of items failed to be found or created in cache"

#define		IFS_FORC_S_NAME	"FindOrCreate Success"
#define		IFS_FORC_S_HELP	"Number of times items were successfully found or created in cache"

#define		IFS_FORC_F_NAME	"FindOrCreate Fails"
#define		IFS_FORC_F_HELP	"Number of times items were not found or created"

#define		IFS_CACHE_ITEMS_NAME	"Cached Items"
#define		IFS_CACHE_ITEMS_HELP	"Number of items in the cache"

#define		IFS_CACHE_CLRU_NAME		"LRU Items"
#define		IFS_CACHE_CLRU_HELP		"Number of items in the caches LRU List"

#define		IFS_CACHE_EXPIRED_NAME	"Expired Items"
#define		IFS_CACHE_EXPIRED_HELP	"Number of items expired from the cache"

#define		IFS_CACHE_INSERTS_NAME	"Inserted Items"
#define		IFS_CACHE_INSERTS_HELP	"Number of items inserted into the cache over time"

#define		IFS_CACHE_READHITS_NAME	"ReadOnly Search Hits"
#define		IFS_CACHE_READHITS_HELP	"Number of items found in cache with only a readlock during FindOrCreate calls"

#define		IFS_CACHE_SSEARCH_NAME	"Search Hits"
#define		IFS_CACHE_SSEARCH_HELP	"Number of items successfully found with Find()"

#define		IFS_CACHE_FSEARCH_NAME	"Search Misses"
#define		IFS_CACHE_FSEARCH_HELP	"Number of times we've searched and not found anything with Find()"

#define		IFS_CACHE_RESEARCH_NAME	"ReSearch Hits"
#define		IFS_CACHE_RESEARCH_HELP	"Number of times a second search had to happen during FOrC() calls"

#define		IFS_CACHE_WRITEHITS_NAME	"Write Hits"
#define		IFS_CACHE_WRITEHITS_HELP	"Number of times we've had a hit when doing a ReSearch during FOrC() calls"

#define		IFS_CACHE_PCREATES_NAME	"PartialLock Creates"
#define		IFS_CACHE_PCREATES_HELP	"Number of times we've created an item in FOrC() while holding a PartialLock"

#define		IFS_CACHE_ECREATES_NAME	"Exclusive Creates"
#define		IFS_CACHE_ECREATES_HELP	"Number of times we've created an item in FOrC() while hold an Exclusive Lock"

#define		IFS_CACHE_CEFAILS_NAME	"CacheEntry Failures"
#define		IFS_CACHE_CEFAILS_HELP	"Number of times we've failed to allocate a CACHEENTRY structure for the cache"

#define		IFS_CACHE_CALLOCFAILS_NAME	"Alloc Failures"
#define		IFS_CACHE_CALLOCFAILS_HELP	"Number of times we've failed to allocate a client object for the cache during FOrC()"

#define		IFS_CACHE_CINITFAILS_NAME	"Init Failures"
#define		IFS_CACHE_CINITFAILS_HELP	"Number of times we've failed to initialize a client object during FOrC() calls"

#define		IFS_SAMPLEOBJ_NAME	"Number SampleData"
#define		IFS_SAMPLEOBJ_HELP	"Number of SampleData objects that have been created/destructed"

#define		IFS_CACHESTATE_NAME	"Number of CacheState"
#define		IFS_CACHESTATE_HELP	"Number of CacheState objects that have been created/destructed"

#define		IFS_HASHITEMS_NAME	"Hashtable Items"
#define		IFS_HASHITEMS_HELP	"As counter by tfdlhash"

#define		IFS_HASHINSERT_NAME	"Hashtable Inserts"
#define		IFS_HASHINSERT_HELP	"As counted by tfdlhash"

#define		IFS_HASHSPLITINSERTS_NAME	"Hashtable SplitInserts"
#define		IFS_HASHSPLITINSERTS_HELP	"As counted by tfdlhash"

#define		IFS_HASHDELETES_NAME	"Hashtable Deletes"
#define		IFS_HASHDELETES_HELP	"As counted by tfdlhash"

#define		IFS_HASHSEARCHES_NAME	"Hashtable Searches"
#define		IFS_HASHSEARCHES_HELP	"As counted by tfdlhash"

#define		IFS_HASHSEARCHHITS_NAME	"HashTable Search Hits"
#define		IFS_HASHSEARCHHITS_HELP	"As counted by tfdlhash"

#define		IFS_HASHSPLITS_NAME		"HashTable Splits"
#define		IFS_HASHSPLITS_HELP		"As counted by tfdlhash"

#define		IFS_HASHREALLOCS_NAME	"HashTable ReAllocs"
#define		IFS_HASHREALLOCS_HELP	"As counted by tfdlhash"

#define		IFS_HASHDEEPBUCKET_NAME	"HashTable DeepBucket"
#define		IFS_HASHDEEPBUCKET_HELP	"As counted by tfdlhash"

#define		IFS_HASHAVERAGEBUCKET_NAME	"HashTable AverageBucket"
#define		IFS_HASHAVERAGEBUCKET_HELP	"As counted by tfdlhash"

#define		IFS_HASHEMPTYBUCKET_NAME	"HashTable EmptyBucket"
#define		IFS_HASHEMPTYBUCKET_HELP	"As counted by tfdlhash"

#define		IFS_HASHALLOCBUCKETS_NAME	"HashTable AllocBuckets"
#define		IFS_HASHALLOCBUCKETS_HELP	"As counted by tfdlhash"

#define		IFS_HASHACTIVEBUCKETS_NAME	"HashTable ActiveBuckets"
#define		IFS_HASHACTIVEBUCKETS_HELP	"As counted by tfdlhash"

#define		IFS_HASHAVERAGESEARCH_NAME	"HashTable Average Search"
#define		IFS_HASHAVERAGESEARCH_HELP	"as counted by tfdlhash"

#define		IFS_HASHDEEPSEARCH_NAME		"HashTable DeepSearch"
#define		IFS_HASHDEEPSEARCH_HELP		"as counted by tfdlhash"

#define		IFS_HASHSEARCHCOST_NAME	"HashTable SearchCost"
#define		IFS_HASHSEARCHCOST_HELP	"as counted by tfdlhash"

#define		IFS_HASHSEARCHCOSTMISS_NAME	"HashTable SearchCostMiss"
#define		IFS_HASHSEARCHCOSTMISS_HELP	"as counted by tfdlhash"


enum	PERF_COUNTERS	{
	FORC_SUCCESS=0,
	FORC_FAIL,
	CACHE_ITEMS,
	CACHE_CLRU,
	CACHE_EXPIRED,
	CACHE_INSERTS,
	CACHE_READHITS,
	CACHE_SSEARCH,
	CACHE_FSEARCH,
	CACHE_RESEARCH,
	CACHE_WRITEHITS,
	CACHE_PCREATES,
	CACHE_ECREATES,
	CACHE_CEFAILS,
	CACHE_CALLOCFAILS,
	CACHE_CINITFAILS,
	IFS_SAMPLEOBJ,
	IFS_CACHESTATE,
	IFS_HASHITEMS,
	IFS_HASHINSERT,
	IFS_HASHSPLITINSERTS,
	IFS_HASHDELETES,
	IFS_HASHSEARCHES,
	IFS_HASHSEARCHHITS,
	IFS_HASHSPLITS,
	IFS_HASHREALLOCS,
	IFS_HASHDEEPBUCKET,
	IFS_HASHAVERAGEBUCKET,
	IFS_HASHEMPTYBUCKET,
	IFS_HASHALLOCBUCKETS,
	IFS_HASHACTIVEBUCKETS,
	IFS_HASHAVERAGESEARCH,
	IFS_HASHDEEPSEARCH,
	IFS_HASHSEARCHCOST,
	IFS_HASHSEARCHCOSTMISS,
	MAX_PERF_COUNTERS
} ;

CPerfCounter CacheSuccessCreates;
CPerfCounter CacheFailCreates;
CPerfCounter CacheItems;
CPerfCounter CacheCLRU;
CPerfCounter CacheExpired;
CPerfCounter CacheInserts;
CPerfCounter CacheReadHits;
CPerfCounter CacheSSearch;
CPerfCounter CacheFSearch;
CPerfCounter CacheResearch;
CPerfCounter CacheWriteHits;
CPerfCounter CachePCreates;
CPerfCounter CacheECreates;
CPerfCounter CacheCEFails;
CPerfCounter CacheCAllocFails;
CPerfCounter CacheCInitFails;
CPerfCounter IFSSampleObject ;
CPerfCounter IFSCacheState ;
CPerfCounter	HashItems ;
CPerfCounter	HashInserts ;
CPerfCounter	HashSplitInserts ;
CPerfCounter	HashDeletes ;
CPerfCounter	HashSearches ;
CPerfCounter	HashSearchHits ;
CPerfCounter	HashSplits ;
CPerfCounter	HashReallocs ;
CPerfCounter	HashDeepBucket ;
CPerfCounter	HashAverageBucket ;
CPerfCounter	HashEmptyBucket ;
CPerfCounter	HashAllocBuckets ;
CPerfCounter	HashActiveBuckets ;
CPerfCounter	HashAverageSearch ;
CPerfCounter	HashDeepSearch ;
CPerfCounter	HashSearchCost ;
CPerfCounter	HashSearchCostMiss ;


int
MyRand(	int&	seed ) {
	__int64	temp = seed ;
	temp = (temp * 41358) % (2147483647) ;
	int	result = (int)temp ;
	seed = result ;
	return	result ;
}


class	SampleData	{
/*++

Class Description :

	This class implements a Sample class for the cache.

--*/
public:

	//
	//	Make things Fail at specific intervals !
	//
	static	long	g_cFails ;

	//
	//	Make these things easy to spot in memory !
	//
	char	m_szSignature[8] ;

	//
	//	The offset to the data
	//
	DWORD	m_Offset ;

	//
	//	The actual data we are to hold
	//
	DWORD	m_Data ;

	//
	//	Keep track of how many times our Init() function is called !
	//
	long	m_lInit ;

	//
	//	Default constructor should never be invoked !
	//
	SampleData() ;

public :

	//
	//	Required by the cache - must be NULL !
	//
	class	ICacheRefInterface*	m_pCacheRefInterface ;



	static	long	g_cSampleData ;

	SampleData(	DWORD&	Key ) :
		m_Offset( Key ),
		m_Data( 0 ),
		m_pCacheRefInterface( 0 ),
		m_lInit( -1 ) 	{

		TraceFunctEnter( "SampleData::SampleData" ) ;

		CopyMemory( m_szSignature, "SAMPLDAT", sizeof( m_szSignature ) ) ;

		IFSSampleObject++ ;

		DebugTrace( (DWORD_PTR)this, "Created %x", this ) ;

//		printf( "Created %x thread %x\n", this, GetCurrentThreadId() ) ;

	}

	~SampleData()	{

		TraceFunctEnter( "SampleData::~SampleData" ) ;

//		printf( "Destroyed  %x thread %x \n", this, GetCurrentThreadId() ) ;

		IFSSampleObject-- ;

		DebugTrace( (DWORD_PTR)this, "Destoyed %x", this ) ;

	}

	BOOL
	Init(	DWORD&	dwKey,
			class	SampleConstructor&	constructor,
			void*
			) ;

	BOOL
	Init(	class	TestKey&	key,
			class	TestConstructor&	constructor,
			void*
			) ;

	DWORD
	GetData()	{
		return	m_Data ;
	}
} ;

long	SampleData::g_cSampleData = 0 ;
long	SampleData::g_cFails = 1 ;


class	SampleConstructor	{
public :
	static	int	g_cFails ;
	DWORD*		m_pData ;
	DWORD		m_cMax ;

	DWORD
	GetData(	DWORD	dw ) {
		return	m_pData[ (dw%m_cMax) ] ;
	}

	class	SampleData*
	Create( DWORD&	dw, LPVOID	lpv ) {
		if( ((g_cFails ++) % 100) == 0 )
			return	0 ;
		return	new	SampleData( dw ) ;
	}

	long
	Release(	SampleData*	p, void* pv ) {
		_ASSERT( p != 0 ) ;
		delete	p;
		return	0 ;
	}

	static
	long	StaticRelease(	SampleData*	p, void*	pv ) {
		_ASSERT( p != 0 ) ;
		delete	p;
		return	0 ;
	}
} ;

int	SampleConstructor::g_cFails = 1 ;

BOOL
SampleData::Init(	DWORD&	dwKey,
					class	SampleConstructor&	constructor,
					void*	)	{

	TraceFunctEnter( "SampleData::Init" ) ;

	g_cFails ++ ;
	if( g_cFails % 100 == 0 ) {
		DebugTrace( (DWORD_PTR)this, "FAILING Initialization !" ) ;
		return	FALSE ;
	}

	long l = InterlockedIncrement( &m_lInit ) ;

	m_Data = constructor.GetData( dwKey ) ;

	DebugTrace( (DWORD_PTR)this, "Initializaing - l %x m_Data %x", l, m_Data ) ;

	return	TRUE ;
}


//
//	Define the physical cache !
//
typedef	MultiCacheEx<	SampleData,
						DWORD,
						SampleConstructor
						>	TESTCACHE ;


typedef	SampleData*	PSAMPLEDATA ;

//
//	The constructor used to build all cache elements
//
SampleConstructor	constructor ;

//
//	The physical cache !
//
TESTCACHE*	g_ptestInstance = 0 ;

//
//	The event used to signal shutdown !
//
HANDLE		g_hShutdown = 0 ;

//
//	Statistics of the physical cache !
//
CACHESTATS	g_stats ;

//
//	Sample Expunge Class - nails every fouth guy !
//
class	CTestExpunge	:	public	TESTCACHE::EXPUNGEOBJECT	{
private :

	int	i ;
public :

	CTestExpunge() : i( 0 ) {}

	BOOL
	fRemoveCacheItem(	DWORD*	pKey,
						SampleData*	pData
						)	{


		if( ((i++) % 10) == 0 ) {
			return	TRUE ;
		}
		return	FALSE ;
	}
} ;


DWORD
SampleHashFunction(	DWORD*	pdw ) {

	DWORD	holdrand = *pdw ;
	holdrand = ((holdrand * 214013L + 2531011L) >> 16) & 0x7fff ;

	DWORD	dw = *pdw ;
	return	dw * dw * (holdrand * 41358) ;
}

int
SampleMatchKey(	DWORD*	pdw1, DWORD*	pdw2 ) {
	return	*pdw1 -  *pdw2 ;
}




class	TestKey	{
/*++

Class Description :

	This is an alternate key that we use in a second level cache
	implemented on top of TESTCACHE !

	A DWORD is stored in decimal form within our key !

--*/
public :

    typedef     DLIST_ENTRY*    (*PFNDLIST)( class  TestKey*);

	char	m_sz[20] ;

	//
	//	Keep track of the number of these test keys that have been created !
	//
	class	CTestKeyTracker*	m_pTracker ;

	//
	//	Does this key reference a zombie !?
	//
	BOOL	m_fZombieRef ;

	//
	//	DWORD
	//
	DWORD	m_dwZombieOffset ;

	//
	//	Free list of those keys that still exist !
	//
	DLIST_ENTRY	m_list ;

	TestKey(	DWORD	dw,
				CTestKeyTracker*	pTracker
				) ;

	TestKey(	DWORD	dw,
				CTestKeyTracker*	pTracker,
				DWORD	dwZombieOffset
				) ;

	//
	//	Make a zombie key !
	//
	TestKey(	CTestKeyTracker*	pTracker ) ;

	TestKey(	TestKey&	rhs ) ;

	~TestKey() ;

	static
	DLIST_ENTRY*
	Convert( TestKey* p ) {
		return	&p->m_list ;
	}
} ;

typedef	TDListHead<TestKey, &TestKey::Convert >	KEYLIST ;

//
//	This object can keep track of every TestKey object made,
//	and help us track down leaks of the particular object type !
//
class	CTestKeyTracker	{
public :

	CRITICAL_SECTION	m_crit ;

	KEYLIST				m_keylist ;

	long				m_count ;

	BOOL				m_fChain ;

	CTestKeyTracker() {
		InitializeCriticalSection( &m_crit ) ;
		m_count = 0 ;
		m_fChain = TRUE ;
	}

	~CTestKeyTracker()	{
		DeleteCriticalSection( &m_crit ) ;
		_ASSERT( m_count == 0 ) ;
	}

	void
	AddEntry(	TestKey*	pKey ) {
		InterlockedIncrement( &m_count ) ;
		if( m_fChain ) {
			EnterCriticalSection( &m_crit ) ;
			m_keylist.PushFront( pKey ) ;
			LeaveCriticalSection( &m_crit ) ;
		}
	}

	void
	DeleteEntry(	TestKey*	pKey ) {
		InterlockedDecrement( &m_count ) ;
		if( m_fChain ) {
			EnterCriticalSection( &m_crit ) ;
			m_keylist.Remove( pKey ) ;
			LeaveCriticalSection( &m_crit ) ;
		}
	}
} ;



TestKey::TestKey(	CTestKeyTracker*	pTracker ) :
	m_pTracker( pTracker ),
	m_fZombieRef( FALSE ),
	m_dwZombieOffset( 0 )  {
	ZeroMemory( &m_sz, sizeof( m_sz ) ) ;
	if( m_pTracker ) {
		m_pTracker->AddEntry(this) ;
	}
}

TestKey::TestKey(	DWORD	dw,
			CTestKeyTracker*	pTracker
			) :
	m_pTracker( pTracker ),
	m_fZombieRef( FALSE ),
	m_dwZombieOffset(  0 )	{
	ZeroMemory( &m_sz, sizeof( m_sz ) ) ;
	_ultoa(	dw, m_sz, 10 ) ;

	if( m_pTracker ) {
		m_pTracker->AddEntry( this ) ;
	}
}

TestKey::TestKey(	DWORD	dw,
			CTestKeyTracker*	pTracker,
			DWORD	dwZombieOffset
			) :
	m_pTracker( pTracker ),
	m_fZombieRef( TRUE ),
	m_dwZombieOffset(  dwZombieOffset )	{
	ZeroMemory( &m_sz, sizeof( m_sz ) ) ;
	_ultoa(	dw, m_sz, 10 ) ;

	if( m_pTracker ) {
		m_pTracker->AddEntry( this ) ;
	}
}


TestKey::TestKey(	TestKey&	rhs ) :
	m_pTracker( rhs.m_pTracker ),
	m_fZombieRef( rhs.m_fZombieRef ),
	m_dwZombieOffset( rhs.m_dwZombieOffset ) {
	CopyMemory( m_sz, rhs.m_sz, sizeof(rhs.m_sz) ) ;
	if( m_pTracker )	{
		m_pTracker->AddEntry( this ) ;
	}
}

TestKey::~TestKey()	{
	if( m_pTracker ) {
		m_pTracker->DeleteEntry( this ) ;
	}
}



class	TestKeyHex	{
/*++

Class Description :

	This is an alternate key that we use in a second level cache
	implemented on top of TESTCACHE !

	A DWORD is stored in hexadecimal form within our key !

--*/
public :
	char	m_sz[20] ;

	TestKeyHex( DWORD	dw ) {
		ZeroMemory( &m_sz, sizeof( m_sz ) ) ;
		_ultoa(	dw, m_sz, 10 ) ;
	}
} ;


DWORD
TestKeyHashFunction(	TestKey*	pKey ) {
#if 0
	DWORD	dw = 0 ;
	for( char*	p = pKey->m_sz; *p!='\0'; *p++ ) {
		dw+= *p ;
	}
	return	dw ;
#endif
	return	CRCHash( (BYTE*)pKey->m_sz, strlen( pKey->m_sz ) ) ;
}

int
TestKeyCompare( TestKey *	p1, TestKey*	p2 ) {
	return	memcmp( p1->m_sz, p2->m_sz, sizeof( p1->m_sz ) ) ;
}

class	TestConstructor	{
/*++

Class Description :

	This is the constructor used in our 2nd tier cache
	to remove items from the cache !

--*/
public :

	static	int	g_cFails ;

	SampleData*
	Create( TestKey&	pTest, void* )	{

		TraceFunctEnter( "TestConstructor::Create" ) ;
		SampleData*	pReturn = 0 ;

		DWORD	dwKey = atol( pTest.m_sz ) ;
		if( (g_cFails++)%100 != 0 ) {
			pReturn = g_ptestInstance->FindOrCreate(	dwKey,
											constructor
											) ;
		}
		DebugTrace( (DWORD_PTR)this, "TestConstructor returning %x", pReturn ) ;
		return	pReturn ;
	}

	void	Release( SampleData* p, void* pv ) {

		_ASSERT( p != 0 ) ;

		TraceFunctEnter( "TestContructor::Release" ) ;
		DebugTrace( (DWORD_PTR)this, "Checking In %x", pv ) ;
		//
		//	Failure only !	return item to cache
		//
		g_ptestInstance->CheckIn( p ) ;

	}

	static
	long	StaticRelease(	SampleData*	p, void*	pv ) {
		_ASSERT( p!= 0 ) ;
		delete	p;
		return	0 ;
	}
} ;


int	TestConstructor::g_cFails = 1 ;


typedef	MultiCacheEx<	SampleData,
						TestKey,
						TestConstructor
						>	TKEYCACHE ;


//
//	Sample Expunge Class - nails every fouth guy !
//
class	CKeyExpunge	:	public	TKEYCACHE::EXPUNGEOBJECT	{
private :

	int	i ;
public :

	CKeyExpunge() : i( 0 ) {}

	BOOL
	fRemoveCacheItem(	TestKey*	pKey,
						SampleData*	pData
						)	{


		//
		//	Don't expunge zombies !
		//
		if( pKey->m_sz[0] == '\0' ) {
			return	FALSE ;
		}
		if( ((i++) % 10) == 0 ) {
			return	TRUE ;
		}
		return	FALSE ;
	}
} ;




BOOL
SampleData::Init(	class	TestKey&	key,
		class	TestConstructor&	test,
		void*
		)	{

	TraceFunctEnter( "SampleData::Init" ) ;

	g_cFails ++ ;
	if( g_cFails % 100 == 0 ) {
		DebugTrace( (DWORD_PTR)this, "FAILING Initialization !" ) ;
		return	FALSE ;
	}

	long l = InterlockedIncrement( &m_lInit ) ;

	if( key.m_fZombieRef ) {
		DWORD	dwKey = key.m_dwZombieOffset ;
		m_Data = constructor.GetData( dwKey ) ;
	}	else	{
		DWORD	dwKey = (DWORD)atol( key.m_sz ) ;
		m_Data = constructor.GetData( dwKey ) ;
	}

	DebugTrace( (DWORD_PTR)this, "Initializing key %s l %x dwKey %x", key.m_sz, l, m_Data ) ;

	return	TRUE ;
}


//
//	A global 2nd tier cache !
//
TKEYCACHE*	g_pTKEYCache[64] ;

//
//	Count of the number of keys for each 2nd tier cache !
//
CTestKeyTracker		g_rgTracker[64] ;

//
//	Items created in the name caches to fulfill a zombie role !
//
SampleData*	g_pZombies[64] ;

//
//	A lock protecting the Name Cache's !
//
CShareLockNH	g_NameLock ;


struct	TestDistribution	{
	//
	//	Number of samples to be taken from this distribution !
	//
	DWORD	m_cSamples ;
	//
	//	The number that we mod by to put the random number
	//	into this range !
	//
	DWORD	m_dwMax ;
	//
	//
	//
	DWORD	m_cActual ;
} ;

//
//	Array of distribution information for the test !
//
TestDistribution	g_rgDist[10] ;

//
//	Number of threads in the test !
//
DWORD	g_cNumThreads = 4 ;

//
//	Number of items to hold in a checked out state !
//
DWORD	g_cCheckouts = 100 ;

//
//	Amount of time to sleep between each request !
//
DWORD	g_cSleep = 100 ;

//
//	Number of items to request in a Batch from the cache !
//
DWORD	g_cBatch = 5 ;

//
//	Variable holds the file from which we insert all of our hash table entries !
//
char	g_szDataFile[MAX_PATH] ;

//
//	Number of Distributions - MAXIMUM of 10 !
//
DWORD	g_cDistribution = 2 ;

//
//	Number of times to repeat scans of files !
//
DWORD	g_numIterations = 1 ;

//
//	Number of times each thread loops !
//
DWORD	g_cNumIter = 1000 ;

//
//	Number of times we instantiate the cache
//
DWORD	g_cNumGlobalIter = 20 ;

//
//	Number of 2nd tier threads !
//
DWORD	g_cNumTier2Threads = 0 ;

//
//	Number of 2nd tier caches !
//
DWORD	g_cNameCaches	= 4 ;

//
//	Frequency at which to Zap the name caches !
//
DWORD	g_cNameCacheZap = 300 ;

//
//	Number of seconds items live in the cache
//
DWORD	g_cNumExpireSeconds = 30 ;

//
//	Number of parallel caches !
//
DWORD	g_cNumCache = 16 ;

//
//	String constants for retrieving values from .ini file !
//
#define	INI_KEY_DATAFILE		"DataFile"
#define	INI_KEY_THREADS			"Threads"
#define	INI_KEY_TIER2THREADS	"Tier2Threads"
#define	INI_KEY_CHECKOUT		"CheckOuts"
#define	INI_KEY_SLEEP			"Sleep"
#define	INI_KEY_BATCH			"Batch"
#define	INI_KEY_NUMDIST			"NumDistribution"
#define	INI_KEY_RANGE			"Range%d"
#define	INI_KEY_SAMPLES			"Samples%d"
#define	INI_KEY_THREAD_ITER		"NumIter"
#define	INI_KEY_GLOBAL_ITER		"GlobalIter"
#define	INI_KEY_EXPIRE_SECONDS	"ExpireSeconds"
#define	INI_KEY_NUM_CACHE		"NumCache"

char g_szDefaultSectionName[] = "C2TEST";
char *g_szSectionName = g_szDefaultSectionName;

void usage(void) {
/*++

Routine Description :

	Print Usage info to command line user !

Arguments :

	None.

Return Value :

	None.

--*/
	printf("usage: c2test.exe [<ini file>] [<ini section name>]\n"
		"  INI file keys (default section [%s]):\n"
		"    %s Data File - contains items used to validate cache\n"
		"    %s Number of Threads - Default %d\n"
		"	 %s Number of distributions Default %d (Maximum - 10)\n"
		"    %s Time between each cache request (Milliseconds) - Default %d\n"
		"    %s Number of items to hold out of cache - default %d\n"
		"    %s Number of Cache entries to get in a batch - Default %d\n"
		"    %s0 Range - keys vary from 0 to Range - No Default\n"
		"    %s0 Samples - Number of items sampled in the Range - No Default\n"
		"    %s Number of Tier 2 threads Default %d- number of threads touching a logical cache\n"
		"    %s Number of times threads iterate before quitting Default %d\n"
		"    %s Number of seconds items live in the cache Default %d\n"
		"    %s Number of Caches that the work is divided over Default %d\n",
		g_szDefaultSectionName,
		INI_KEY_DATAFILE,
		INI_KEY_THREADS,
		g_cNumThreads,
		INI_KEY_NUMDIST,
		g_cDistribution,
		INI_KEY_SLEEP,
		g_cSleep,
		INI_KEY_CHECKOUT,
		g_cCheckouts,
		INI_KEY_BATCH,
		g_cBatch,
		INI_KEY_RANGE,
		INI_KEY_SAMPLES,
		INI_KEY_TIER2THREADS,
		g_cNumTier2Threads,
		INI_KEY_THREAD_ITER,
		g_cNumIter,
		INI_KEY_EXPIRE_SECONDS,
		g_cNumExpireSeconds,
		INI_KEY_NUM_CACHE,
		g_cNumCache
		) ;
	exit(1);
}


int GetINIDword(
			char *szINIFile,
			char *szKey,
			DWORD dwDefault
			) {
/*++

Routine Description :

	Helper function which retrieves values from .ini file !

Arguments :

	szINIFile - name of the ini file
	szKey - name of the key
	dwDefault - default value for the parameter

Return Value :

	The value retrieved from the .ini file or the default !

--*/
	char szBuf[MAX_PATH];

	GetPrivateProfileString(g_szSectionName,
							szKey,
							"default",
							szBuf,
							MAX_PATH,
							szINIFile);

	if (strcmp(szBuf, "default") == 0) {
		return dwDefault;
	} else {
		return atoi(szBuf);
	}
}

void parsecommandline(
			int argc,
			char **argv
			) {
/*++

Routine Description :

	Get the name of the .ini file and
	setup our test run !

Arguments :

	Command line parameters

Return Value :

	None - will exit() if the user has not
		properly configured the test !

--*/
	if (argc == 0 ) usage();
	if (strcmp(argv[0], "/help") == 0) usage(); 	// show help

	char *szINIFile = argv[0];
	if (argc == 2) char *g_szSectionName = argv[1];

	GetPrivateProfileString(	g_szSectionName,
								INI_KEY_DATAFILE,
								"",
								g_szDataFile,
								sizeof( g_szDataFile ),
								szINIFile
								) ;

	g_cNumThreads =	GetINIDword( szINIFile,
								INI_KEY_THREADS,
								g_cNumThreads
								) ;

	g_cCheckouts =	GetINIDword(	szINIFile,
									INI_KEY_CHECKOUT,
									g_cCheckouts
									) ;

	g_cSleep =		GetINIDword(	szINIFile,
									INI_KEY_SLEEP,
									g_cSleep
									) ;

	g_cBatch	=	GetINIDword(	szINIFile,
									INI_KEY_BATCH,
									g_cBatch
									) ;

	g_cDistribution =	GetINIDword(	szINIFile,
									INI_KEY_NUMDIST,
									g_cDistribution
									) ;

	g_cNumTier2Threads = GetINIDword(	szINIFile,
										INI_KEY_TIER2THREADS,
										g_cNumTier2Threads
										) ;

	g_cNumIter = GetINIDword(	szINIFile,
								INI_KEY_THREAD_ITER,
								g_cNumIter
								) ;

	if( g_cDistribution == 0 ||
		g_cDistribution > 10 ) {
		usage() ;
	}

	g_cNumGlobalIter = GetINIDword(	szINIFile,
									INI_KEY_GLOBAL_ITER,
									g_cNumGlobalIter
									) ;

	g_cNumExpireSeconds = GetINIDword(	szINIFile,
									INI_KEY_EXPIRE_SECONDS,
									g_cNumGlobalIter
									) ;

	g_cNumCache = GetINIDword(	szINIFile,
								INI_KEY_NUM_CACHE,
								g_cNumCache
								) ;

	g_cNumIter = max( g_cNumIter, 1 ) ;
	g_cNumGlobalIter = max( g_cNumGlobalIter, 1 ) ;

	if( g_cDistribution == 0 ||
		g_cDistribution > 10 ) {
		usage() ;
	}

	g_cNumThreads = min( g_cNumThreads, 60 ) ;
	g_cNumThreads = max( g_cNumThreads, 1 ) ;

	g_cNumTier2Threads = min( g_cNumTier2Threads, 60 ) ;

	//
	//	Now - go get the details of the distribution we want !
	//
	for( DWORD	i =0; i<g_cDistribution; i++ ) {
		char	szBuff[100] ;
		sprintf( szBuff, INI_KEY_RANGE, i ) ;
		g_rgDist[i].m_dwMax	= GetINIDword(	szINIFile,
											szBuff,
											0
											) ;
		if( g_rgDist[i].m_dwMax == 0 )
			usage() ;
		sprintf( szBuff, INI_KEY_SAMPLES, i ) ;
		g_rgDist[i].m_cSamples = GetINIDword(	szINIFile,
												szBuff,
												0
												) ;
		if( g_rgDist[i].m_cSamples == 0 )
			usage() ;
	}

	if( g_szDataFile[0] =='\0' ) {
		usage() ;
	}
}


DWORD	WINAPI
TestThread(	LPVOID	lpv ) {
/*++

Routine Description :

	This function performs test operations against the sample cache !

Arguments :

	None.

Return Value :

	None.

--*/

	int	seed = (int)time(NULL ) ;
	seed *= GetCurrentThreadId() * GetCurrentThreadId() ;

	SampleData**	pData = new	PSAMPLEDATA[g_cCheckouts] ;
	if( !pData )
		return	1 ;

	ZeroMemory( pData, sizeof( PSAMPLEDATA ) * g_cCheckouts ) ;

	DWORD	iCheckOut = 0 ;

	for( DWORD	i=0; i < g_cNumIter; i++ ) {

		for( DWORD		j=0; j<g_cDistribution; j++ ) {

			for( DWORD	 k=0; k<g_rgDist[j].m_cSamples; k++ ) {

				for( DWORD	 l=0; l<g_cBatch && k < g_rgDist[j].m_cSamples;
						l++, k++ ) {

					DWORD	dwRand = (DWORD)MyRand(seed) ;
					dwRand %= g_rgDist[j].m_dwMax ;

					SampleData*	p = pData[iCheckOut] ;
					pData[iCheckOut] = 0 ;

					if( p ) {
						if( (l % 3) != 0 ) {
							g_ptestInstance->CheckIn( p ) ;
						}	else	{
							DWORD	dwTestExpungeKey = p->m_Offset ;
							if( (l%12) == 0 ) {
								g_ptestInstance->CheckIn( p ) ;
								//
								//	Expunge the guy we just checked in and see how it works !
								//
								g_ptestInstance->ExpungeKey( &dwTestExpungeKey ) ;
							}	else 	{
								if( (l%6) == 0 ) {
									g_ptestInstance->ExpungeKey( &dwTestExpungeKey ) ;
									g_ptestInstance->CheckIn( p ) ;
								}	else	{
									CTestExpunge	expunge ;
									g_ptestInstance->ExpungeItems( &expunge ) ;
									g_ptestInstance->CheckIn( p ) ;
								}
							}
						}
					}


					p = g_ptestInstance->FindOrCreate(	dwRand,
														constructor
														) ;

					if( p ) {
						CacheSuccessCreates++ ;
					}	else	{
						CacheFailCreates++ ;
					}

					if( p != 0 &&
						p->GetData() != constructor.GetData( dwRand ) ) {
						DebugBreak() ;
					}
					if( p!=0 &&
						p->m_lInit == -1 )
						DebugBreak() ;
					pData[iCheckOut++] = p ;
					if( iCheckOut == g_cCheckouts )
						iCheckOut = 0 ;
				}
				Sleep( g_cBatch * g_cSleep ) ;
			}
		}
	}

	for( i=0; i < g_cCheckouts; i++ ) {

		if( pData[i] != 0 ) {
			g_ptestInstance->CheckIn( pData[i] ) ;
		}
	}

	delete[]	pData ;

	return	 0 ;
}



DWORD	WINAPI
Tier2Thread(	LPVOID	lpv ) {
/*++

Routine Description :

	This function performs test operations against the sample cache !

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "Tier2Thread" ) ;

	DWORD_PTR	iNameCache = (DWORD_PTR)lpv ;
	_ASSERT( iNameCache < g_cNameCaches ) ;

	DWORD	iReset = 1 ;

	int	seed = (int)time(NULL ) ;
	seed *= GetCurrentThreadId() * GetCurrentThreadId() ;

	SampleData**	pData = new	PSAMPLEDATA[g_cCheckouts] ;
	if( !pData )
		return	1 ;

	ZeroMemory( pData, sizeof( PSAMPLEDATA ) * g_cCheckouts ) ;

	DWORD	iTest = 0 ;
	DWORD	iCheckOut = 0 ;

	for( DWORD	i=0; i < g_cNumIter; i++ ) {

		for( DWORD	j=0; j<g_cDistribution; j++ ) {

			for( DWORD	k=0; k<g_rgDist[j].m_cSamples; k++ ) {

				for( DWORD l=0; l<g_cBatch && k < g_rgDist[j].m_cSamples;
						l++, k++ ) {

					g_NameLock.ShareLock() ;
					TKEYCACHE*	pNameCache = g_pTKEYCache[iNameCache] ;

					DWORD	dwRand = (DWORD)MyRand(seed) ;
					dwRand %= g_rgDist[j].m_dwMax ;

					SampleData*	p = pData[iCheckOut] ;
					pData[iCheckOut] = 0 ;

					if( p ) {
						if( (l % 3) != 0 ) {
							pNameCache->CheckIn( p ) ;
						}	else	{
							DWORD	dwTestExpungeKey = p->m_Offset ;
							TestKey	ExpungeKey( dwTestExpungeKey, &g_rgTracker[iNameCache] ) ;
							if( (l%12) == 0 ) {
								pNameCache->CheckIn( p ) ;
								//
								//	Expunge the guy we just checked in and see how it works !
								//
								pNameCache->ExpungeKey( &ExpungeKey ) ;
							}	else 	{
								if( (l%6) == 0 ) {
									pNameCache->ExpungeKey( &ExpungeKey) ;
									pNameCache->CheckIn( p ) ;
								}	else	{
									CKeyExpunge	expunge ;
									pNameCache->ExpungeItems( &expunge ) ;
									pNameCache->CheckIn( p ) ;
								}
							}
						}
					}
					p = 0 ;

					//
					//	Introduce this scope to manage the lifetime of temp key's etc... !
					//	so we don't track down stack variables as memory leaks !
					//
					{
						TestConstructor	test;
						TestKey	key( dwRand, &g_rgTracker[iNameCache] ) ;

						iTest ++ ;
						DWORD	iBranch = iTest % 4 ;


						//
						//	Insert and remove a zombie reference !
						//
						if( (iTest % 32) == 1 ) {

							if( g_pZombies[iNameCache] != 0 ) {
								TestKey	key( dwRand+g_rgDist[j].m_dwMax,
												&g_rgTracker[iNameCache],
												dwRand
												) ;

								DebugTrace( DWORD_PTR(&key), "Inserting Zombie Ref - dwRand %x g_pZombies[iNameCache] %x",
									dwRand + g_rgDist[j].m_dwMax, g_pZombies[iNameCache] ) ;

								//
								//	Insert a extra reference to the zombie thing !
								//
								if( pNameCache->Insert( key, g_pZombies[iNameCache], 0 ) ) {

									//
									//	Try removing and re-inserting !
									//
									pNameCache->ExpungeKey(	&key ) ;

									if( (iTest % 64) == 1 ) {
										pNameCache->Insert( key, g_pZombies[iNameCache], 0 ) ;
									}
								}
							}
						}

						if( iBranch == 0 )	{
							p = pNameCache->FindOrCreate(	key,
															test,
															TRUE
															) ;
						}	else if( iBranch == 1 ) {

							p = g_ptestInstance->FindOrCreate(
														dwRand,
														constructor
														) ;

							if( p )		{
								g_ptestInstance->CheckOut( p ) ;
								g_ptestInstance->CheckIn( p ) ;
							}

							if( p && !pNameCache->Insert(	key,
															p,
															0
															) )	{
								//_ASSERT( 1==0 ) ;
							}

							//
							//	Now, try to do the Insert again, with the same item !
							//
							if( p && !pNameCache->Insert(	key,
															p,
															0
															) ) {
							}

							//
							//	Now, try doing the Insert again with a different item !
							//
							SampleData*	pTest = new	SampleData( dwRand ) ;
							if( pTest && pTest->Init(	key, test, 0 ) ) {
								if( !pNameCache->Insert(	key,
															pTest,
															0
															) ) {
									delete	pTest ;
								}
							}

						}	else {

							p = g_ptestInstance->Find( dwRand ) ;
							//
							DebugTrace( (DWORD_PTR)p, "Searched for and found %x", p ) ;
							if( !p ) {
								SampleData*	pTemp = new SampleData( dwRand ) ;
								DebugTrace( (DWORD_PTR)pTemp, "Create SampleData %x", pTemp ) ;
								if( pTemp && pTemp->Init( dwRand, constructor, 0 ) ) {
									BOOL	f = g_ptestInstance->Insert(	dwRand,
																			pTemp,
																			1
																			) ;

									DebugTrace( (DWORD_PTR)pTemp, "Init pTemp %x f %x", pTemp, f ) ;

									if( !f )	{
										delete	pTemp ;
									}	else	{
										p = pTemp ;
									}
								}	else if( pTemp )	{
									delete	pTemp ;
								}
							}
							//
							//	Now - get the item again !
							//
							if( p )		{
								SampleData*	pTemp = pNameCache->FindOrCreate(	key,
																				test,
																				TRUE
																				) ;
								if( pTemp ) {
									_ASSERT(	pTemp == 0 ||
												pTemp == p ||
												pTemp->m_Offset == dwRand ) ;

									pNameCache->CheckIn( pTemp ) ;
								}
							}
						}
						if( p ) {
							CacheSuccessCreates++ ;
						}	else	{
							CacheFailCreates++ ;
						}

						if( p != 0 &&
							p->GetData() != constructor.GetData( dwRand ) ) {
							DebugBreak() ;
						}
						if( p!=0 &&
							p->m_lInit == -1 )
							DebugBreak() ;

						pData[iCheckOut++] = p ;
						if( iCheckOut == g_cCheckouts )
							iCheckOut = 0 ;
						iReset ++ ;
					}
					g_NameLock.ShareUnlock() ;

					if( (iReset % g_cNameCacheZap) == 0 )	{

						TKEYCACHE*	pNew = new	TKEYCACHE() ;
						if( !pNew->Init(
								TestKeyHashFunction,
								TestKeyCompare,
								g_cNumExpireSeconds,
								100000,
								g_cNumCache,
								0/*&g_stats*/
								) ) {
							delete	pNew ;
						}	else	{

							g_NameLock.ExclusiveLock() ;
							TKEYCACHE*	pdelete = g_pTKEYCache[iNameCache] ;
							g_pTKEYCache[iNameCache] = pNew ;
							if( g_pZombies[iNameCache] != 0 ) {
								pdelete->CheckIn( g_pZombies[iNameCache] ) ;
								g_pZombies[iNameCache] = 0 ;
							}

							{
								//
								//	Make a zombie entry !
								//
								TestKey	key( &g_rgTracker[iNameCache] ) ;

								pdelete->ExpungeKey( &key ) ;
							}

							delete	pdelete ;
							_ASSERT( g_rgTracker[iNameCache].m_count == 0 ) ;
							{
								TestKey	key( &g_rgTracker[iNameCache] ) ;
								DWORD	dw = 0 ;
								SampleData*	p = new	SampleData( dw ) ;


								//
								//	Now, try to do the Insert again, with the same item !
								//
								if( p && pNew->Insert(	key,
														p,
														1
														) ) {
									g_pZombies[iNameCache] = p ;
								}
							}
							g_NameLock.ExclusiveUnlock() ;
						}
					}
				}
				Sleep( g_cBatch * g_cSleep ) ;
			}
		}
	}

	for( i=0; i < g_cCheckouts; i++ ) {

		if( pData[i] != 0 ) {
			g_ptestInstance->CheckIn( pData[i] ) ;
		}
	}

	delete[]	pData ;


	return	 0 ;
}



DWORD	WINAPI
StatThread(	LPVOID	lpv ) {
/*++

Routine Description :

	This function exists solely to copy our statistic information to
	a place where the perfmon stuff can get it !

Arguments :

	None.

Return Value  :

	None.

--*/


	while( 1 ) {

		//
		//	Every quarter second update the stats !
		//
		DWORD	dw = WaitForSingleObject( g_hShutdown, 250 ) ;
		if( dw == WAIT_OBJECT_0 ) {
			break ;
		}

		CacheItems = g_stats.m_cCounters[CACHESTATS::ITEMS] ;
		CacheCLRU  = g_stats.m_cCounters[CACHESTATS::CLRU] ;
		CacheExpired = g_stats.m_cCounters[CACHESTATS::EXPIRED] ;
		CacheInserts = g_stats.m_cCounters[CACHESTATS::INSERTS] ;
		CacheReadHits = g_stats.m_cCounters[CACHESTATS::READHITS] ;
		CacheSSearch = g_stats.m_cCounters[CACHESTATS::SUCCESSSEARCH] ;
		CacheFSearch = g_stats.m_cCounters[CACHESTATS::FAILSEARCH] ;
		CacheResearch = g_stats.m_cCounters[CACHESTATS::RESEARCH] ;
		CacheWriteHits = g_stats.m_cCounters[CACHESTATS::WRITEHITS] ;
		CachePCreates = g_stats.m_cCounters[CACHESTATS::PARTIALCREATES] ;
		CacheECreates = g_stats.m_cCounters[CACHESTATS::EXCLUSIVECREATES] ;
		CacheCEFails = g_stats.m_cCounters[CACHESTATS::CEFAILS] ;
		CacheCAllocFails = g_stats.m_cCounters[CACHESTATS::CLIENTALLOCFAILS] ;
		CacheCInitFails = g_stats.m_cCounters[CACHESTATS::CLIENTINITFAILS] ;
#ifdef  DEBUG
		IFSCacheState = CacheState::g_cCacheState ;
#endif
		HashItems = g_stats.m_cHashCounters[CHashStats::HASHITEMS] ;
		HashInserts = g_stats.m_cHashCounters[CHashStats::INSERTS] ;
		HashSplitInserts = g_stats.m_cHashCounters[CHashStats::SPLITINSERTS] ;
		HashDeletes = g_stats.m_cHashCounters[CHashStats::DELETES] ;
		HashSearches = g_stats.m_cHashCounters[CHashStats::SEARCHES] ;
		HashSearchHits = g_stats.m_cHashCounters[CHashStats::SEARCHHITS] ;
		HashSplits = g_stats.m_cHashCounters[CHashStats::SPLITS] ;
		HashReallocs = g_stats.m_cHashCounters[CHashStats::REALLOCS] ;
		HashDeepBucket = g_stats.m_cHashCounters[CHashStats::DEEPBUCKET] ;
		HashAverageBucket = g_stats.m_cHashCounters[CHashStats::AVERAGEBUCKET] ;
		HashEmptyBucket = g_stats.m_cHashCounters[CHashStats::EMPTYBUCKET] ;
		HashAllocBuckets = g_stats.m_cHashCounters[CHashStats::ALLOCBUCKETS] ;
		HashActiveBuckets = g_stats.m_cHashCounters[CHashStats::ACTIVEBUCKETS] ;
		HashAverageSearch = g_stats.m_cHashCounters[CHashStats::AVERAGESEARCH] ;
		HashDeepSearch = g_stats.m_cHashCounters[CHashStats::DEEPSEARCH] ;
		HashSearchCost = g_stats.m_cHashCounters[CHashStats::SEARCHCOST] ;
		HashSearchCostMiss = g_stats.m_cHashCounters[CHashStats::SEARCHCOSTMISS] ;

	}
	return	0 ;
}


BOOL
InitCaches()	{

	ZeroMemory( &g_stats, sizeof( g_stats ) ) ;

	g_ptestInstance = new	TESTCACHE() ;
	if( !g_ptestInstance ||
		!g_ptestInstance->Init(
					SampleHashFunction,
					SampleMatchKey,
					g_cNumExpireSeconds,
					1000,
					g_cNumCache,
					&g_stats
					) )	{
		return	FALSE	 ;
	}

	if( g_cNumTier2Threads != 0 ) {
		ZeroMemory( g_pTKEYCache, sizeof( g_pTKEYCache ) ) ;
		for( DWORD i=0; i<g_cNameCaches; i++ ) {
			g_pTKEYCache[i] = new TKEYCACHE() ;
			if( g_pTKEYCache[i]==0 || !g_pTKEYCache[i]->Init(
					TestKeyHashFunction,
					TestKeyCompare,
					g_cNumExpireSeconds,
					1000,
					g_cNumCache,
					0/*&g_stats*/
					) ) {
				return	FALSE	;
			}	else	{
				//
				//	Make a zombie entry !
				//
				TestKey	key( &g_rgTracker[i] ) ;
				DWORD	dw = 0 ;
				SampleData*	p = new	SampleData( dw ) ;


				//
				//	Now, try to do the Insert again, with the same item !
				//
				if( p && !g_pTKEYCache[i]->Insert(	key,
												p,
												1
												) ) {
					return	FALSE ;
				}
				g_pZombies[i] = p ;
			}
		}
	}

	return	TRUE ;
}

BOOL
TermCaches()	{
	for( DWORD i = 0; i<g_cNameCaches; i++ ) {
		if( g_pZombies[i] != 0 ) {
			g_pTKEYCache[i]->CheckIn( g_pZombies[i] ) ;
		}
		g_pZombies[i] = 0 ;
		delete	g_pTKEYCache[i] ;
		_ASSERT( g_rgTracker[i].m_count == 0 ) ;
	}
	ZeroMemory( g_pTKEYCache, sizeof( g_pTKEYCache ) ) ;
	if( g_ptestInstance ) {
		delete	g_ptestInstance ;
		g_ptestInstance = 0 ;
	}
	return	TRUE ;
}


void
StartTest()	{

	TraceFunctEnter( "StartTest" ) ;

	g_hShutdown = CreateEvent( 0, TRUE, FALSE, 0 ) ;
	HANDLE	hZapThread = 0 ;
	HANDLE	hStatThread = 0 ;

	HANDLE	hFile = CreateFile( g_szDataFile,
								GENERIC_READ,
								FILE_SHARE_READ,
								0,
								OPEN_EXISTING,
								0,
								INVALID_HANDLE_VALUE ) ;

	if( hFile != INVALID_HANDLE_VALUE ) {

		constructor.m_cMax = GetFileSize( hFile, 0 ) / sizeof( DWORD ) ;

		HANDLE	hMap = CreateFileMapping(	hFile,
											0,
											PAGE_READONLY,
											0,
											0,
											0 ) ;

		if( hMap != 0 ) {

			LPVOID	lpv = MapViewOfFile(	hMap,
											FILE_MAP_READ,
											0,
											0,
											0 ) ;

			if( lpv != 0 ) {

				DWORD	dwJunk ;
#if 0
				hZapThread = CreateThread( 0,
											0,
											ZapThread,
											0,
											0,
											&dwJunk
											) ;
#endif
				hStatThread = CreateThread( 0,
											0,
											StatThread,
											0,
											0,
											&dwJunk
											) ;


				constructor.m_pData = (DWORD*) lpv ;

				//
				//	Just do a little spin to test construction/destruction !
				//
				for( int i=0; i<10; i++ ) {
					if( !InitCaches() )	{
						TermCaches() ;
						continue ;
					}

					if( g_pTKEYCache != 0 ) {
						int	seed = (int)time(NULL ) ;
						seed *= GetCurrentThreadId() * GetCurrentThreadId() ;
						DWORD	dwRand = (DWORD)MyRand(seed) ;
						TestConstructor	test;
						TestKey	key( dwRand, &g_rgTracker[0] ) ;

						SampleData*	p = g_pTKEYCache[0]->FindOrCreate(	key,
																		test,
																		TRUE
																		) ;
						if( p )
							g_pTKEYCache[0]->CheckIn( p ) ;
					}

					TermCaches() ;
					_ASSERT( g_rgTracker[0].m_count == 0 ) ;
				}

				for( DWORD	j = 0; j<g_cNumGlobalIter; j++ ) {


					if( !InitCaches() ) {
						DebugTrace( 0, "Fatal error starting test\n" ) ;
						TermCaches() ;
						return ;
					}

					HANDLE	hThread[64] ;
					for( DWORD	i=0; i<g_cNumThreads; i++ ) {

						hThread[i] = CreateThread(	0,
													0,
													TestThread,
													0,
													0,
													&dwJunk ) ;

						if( hThread[i] == 0 ) {
							break ;
						}
					}

					HANDLE	hTier2Thread[64] ;
					for( DWORD	l=0; l<g_cNumTier2Threads; l++ ) {
						hTier2Thread[l] = CreateThread(	0,
														0,
														Tier2Thread,
														(LPVOID)(SIZE_T)(l % g_cNameCaches),
														0,
														&dwJunk
														) ;
						if( hTier2Thread[l] == 0 ) {
							break ;
						}
					}

					WaitForMultipleObjects( i, hThread, TRUE, INFINITE ) ;
					WaitForMultipleObjects( l, hTier2Thread, TRUE, INFINITE ) ;

					for( DWORD	k=0; k<i; k++ ) {
						CloseHandle( hThread[k] ) ;
						hThread[k] = 0 ;
					}
					for( k=0; k<l; k++ ) {
						CloseHandle( hTier2Thread[k] ) ;
						hTier2Thread[k] = 0 ;
					}

					TermCaches() ;

				}
				SetEvent( g_hShutdown ) ;
				//WaitForSingleObject( hZapThread, INFINITE ) ;
				//CloseHandle( hZapThread ) ;

				WaitForSingleObject( hStatThread, INFINITE ) ;
				CloseHandle( hStatThread ) ;
				UnmapViewOfFile( lpv ) ;

			}
			CloseHandle( hMap ) ;
		}
		CloseHandle( hFile ) ;
	}

	//ptestInstance->ExpungeSpecific(&callback,TRUE);
	//delete	ptestInstance ;

}


struct	TestData	{
	DWORD	dw ;
	DWORD	dw2 ;
	TestData() :
		dw( 1 ), dw2( 2 ) {
	}
	~TestData() {
		dw = 0 ;
		dw2 = 0 ;
		printf( "dw %x dw2 %x", dw, dw2 ) ;
	}
} ;

static	TestData*	ptGlobal = 0 ;

int	__cdecl
main( int argc, char** argv ) {

    _VERIFY( CreateGlobalHeap( 0, 0, 0, 0 ) );

	crcinit() ;

	DeleteFile( "c:\\trace.atf" ) ;

	InitAsyncTrace() ;

	parsecommandline( --argc, ++argv ) ;

    //
    //  Create a perf object
    //
    CPerfObject IfsPerfObject;
    if( !IfsPerfObject.Create(
                    IFS_PERFOBJECT_NAME,    // Name of object
                    TRUE,                   // Has instances
                    IFS_PERFOBJECT_HELP     // Object help
                    )) {
        printf("Failed to create object %s\n",IFS_PERFOBJECT_NAME);
        exit(0);
    }

    //
    //  Create an instance for this object
    //
    INSTANCE_ID iid = IfsPerfObject.CreateInstance(IFS_PERFOBJECT_INSTANCE);
    if( iid == (INSTANCE_ID)-1 ) {
        printf("Failed to create instance\n");
        exit(0);
    }

    //
    //  Create counters for this object
    //
    COUNTER_ID rgCounters[MAX_PERF_COUNTERS];

	DWORD	iCounter = 0 ;

    rgCounters[FORC_SUCCESS] = IfsPerfObject.CreateCounter(
                                                IFS_COUNTER_SUCCESSCREATES_NAME,
                                                PERF_COUNTER_COUNTER,
                                                0,
                                                sizeof(DWORD),
                                                IFS_COUNTER_SUCCESSCREATES_HELP
                                                );
    if( rgCounters[FORC_SUCCESS] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[FORC_FAIL] = IfsPerfObject.CreateCounter(
                                                IFS_COUNTER_FAILEDCREATES_NAME,
                                                PERF_COUNTER_COUNTER,
                                                0,
                                                sizeof(DWORD),
                                                IFS_COUNTER_FAILEDCREATES_HELP
                                                );
    if( rgCounters[FORC_FAIL] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[CACHE_ITEMS] = IfsPerfObject.CreateCounter(
                                                IFS_CACHE_ITEMS_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_CACHE_ITEMS_HELP
                                                );
    if( rgCounters[CACHE_ITEMS] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[CACHE_CLRU] = IfsPerfObject.CreateCounter(
                                                IFS_CACHE_CLRU_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_CACHE_CLRU_HELP
                                                );
    if( rgCounters[CACHE_CLRU] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[CACHE_EXPIRED] = IfsPerfObject.CreateCounter(
                                                IFS_CACHE_EXPIRED_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_CACHE_EXPIRED_HELP
                                                );
    if( rgCounters[CACHE_EXPIRED] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[CACHE_INSERTS] = IfsPerfObject.CreateCounter(
                                                IFS_CACHE_INSERTS_NAME,
                                                PERF_COUNTER_RAWCOUNT,
                                                0,
                                                sizeof(DWORD),
                                                IFS_CACHE_INSERTS_HELP
                                                );
    if( rgCounters[CACHE_INSERTS] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[CACHE_READHITS] = IfsPerfObject.CreateCounter(
                                                IFS_CACHE_READHITS_NAME,
                                                PERF_COUNTER_COUNTER,
                                                0,
                                                sizeof(DWORD),
                                                IFS_CACHE_READHITS_HELP
                                                );
    if( rgCounters[CACHE_READHITS] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[CACHE_SSEARCH] = IfsPerfObject.CreateCounter(
                                                IFS_CACHE_SSEARCH_NAME,
                                                PERF_COUNTER_COUNTER,
                                                0,
                                                sizeof(DWORD),
                                                IFS_CACHE_SSEARCH_NAME
                                                );
    if( rgCounters[CACHE_SSEARCH] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[CACHE_FSEARCH] = IfsPerfObject.CreateCounter(
                                                IFS_CACHE_FSEARCH_NAME,
                                                PERF_COUNTER_COUNTER,
                                                0,
                                                sizeof(DWORD),
                                                IFS_CACHE_FSEARCH_HELP
                                                );
    if( rgCounters[CACHE_FSEARCH] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[CACHE_RESEARCH] = IfsPerfObject.CreateCounter(
                                                IFS_CACHE_RESEARCH_NAME,
                                                PERF_COUNTER_COUNTER,
                                                0,
                                                sizeof(DWORD),
                                                IFS_CACHE_RESEARCH_HELP
                                                );
    if( rgCounters[CACHE_RESEARCH] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[CACHE_WRITEHITS] = IfsPerfObject.CreateCounter(
                                                IFS_CACHE_WRITEHITS_NAME,
                                                PERF_COUNTER_COUNTER,
                                                0,
                                                sizeof(DWORD),
                                                IFS_CACHE_WRITEHITS_HELP
                                                );
    if( rgCounters[CACHE_WRITEHITS] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[CACHE_PCREATES] = IfsPerfObject.CreateCounter(
                                                IFS_CACHE_PCREATES_NAME,
                                                PERF_COUNTER_COUNTER,
                                                0,
                                                sizeof(DWORD),
                                                IFS_CACHE_PCREATES_HELP
                                                );
    if( rgCounters[CACHE_PCREATES] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[CACHE_ECREATES] = IfsPerfObject.CreateCounter(
                                                IFS_CACHE_ECREATES_NAME,
                                                PERF_COUNTER_COUNTER,
                                                0,
                                                sizeof(DWORD),
                                                IFS_CACHE_ECREATES_HELP
                                                );
    if( rgCounters[CACHE_ECREATES] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[CACHE_CEFAILS] = IfsPerfObject.CreateCounter(
                                                IFS_CACHE_CEFAILS_NAME,
                                                PERF_COUNTER_COUNTER,
                                                0,
                                                sizeof(DWORD),
                                                IFS_CACHE_CEFAILS_HELP
                                                );
    if( rgCounters[CACHE_CEFAILS] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[CACHE_CALLOCFAILS] = IfsPerfObject.CreateCounter(
                                                IFS_CACHE_CALLOCFAILS_NAME,
                                                PERF_COUNTER_COUNTER,
                                                0,
                                                sizeof(DWORD),
                                                IFS_CACHE_CALLOCFAILS_HELP
                                                );
    if( rgCounters[CACHE_CALLOCFAILS] == (COUNTER_ID)-1 ) {
        printf("Failed to create counter\n");
        exit(0);
    }

    rgCounters[CACHE_CINITFAILS] = IfsPerfObject.CreateCounter(
                                                IFS_CACHE_CINITFAILS_NAME,
                                                PERF_COUNTER_COUNTER,
                                                0,
       