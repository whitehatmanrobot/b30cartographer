nc Pulse Width         | bits 5,4: upper 2bits HSPW*/
    /*      | Vertical Sync Offset      | bits 3,2: upper 2bits VSO */
    /*      | VSync Pulse Width         | bits 0,1: upper 2bits VSPW*/
    /* ------------------------------------------------------------ */
    /*  1   | Horizontal Image Size     | mm, lower 8 bits          */
    /* ------------------------------------------------------------ */
    /*  1   | Vertical Image Size       | mm, lower 8 bits          */
    /* ------------------------------------------------------------ */
    /*  1   | Horizontal & Vertical     | Upper nibble: upper 4bits */
    /*      | Image Size                | of Horiz Image Size.      */
    /*      |                           | Lower nibble: upper 4bits */
    /*      |                           | of Vert Image Size.       */
    /* ------------------------------------------------------------ */
    /*  1   | Horizontal Border         | Pixels, see vesa spec 3.12*/
    /* ------------------------------------------------------------ */
    /*  1   | Vertical Border           | Lines, see vesa spec 3.12 */
    /* ------------------------------------------------------------ */
    /*  1   | Flags                     | See Vesa Spec 3.16        */
    /* ------------------------------------------------------------ */

    HActive     = (U008)(pFPTable->HActive & 0xFF);
    HBlank      = (U008)(((pFPTable->HTotal - pFPTable->HActive) + 0x01) & 0xFF);
    HAcHBlnk    = (U008)(((pFPTable->HActive & 0x0F00) >> 4) | 
                        (((pFPTable->HTotal - pFPTable->HActive) >> 8) & 0x0F));
    VActive     = (U008)(pFPTable->VActive & 0xFF);
    VBlank      = (U008)(((pFPTable->VTotal - pFPTable->VActive) + 0x01) & 0xFF);
    VAcVBlnk    = (U008)(((pFPTable->VActive & 0x0F00) >> 4) | 
                  (((pFPTable->VTotal - pFPTable->VActive) >> 8) & 0x0F));
    HSyncOffset = (U008)(((pFPTable->HSyncStart - pFPTable->HActive) + 0x01) & 0xFF);
    HSyncPW     = (U008)((pFPTable->HSyncEnd - pFPTable->HSyncStart) & 0xFF);
    VSyncOffset = (U008)(((pFPTable->VSyncStart - pFPTable->VActive) + 0x01) & 0xFF);
    VSyncPW     = (U008)((pFPTable->VSyncEnd - pFPTable->VSyncStart) & 0xFF);
    VSyncOffPW  = (U008)(((VSyncOffset & 0x0F) << 4) | (VSyncPW & 0x0F));
    HVSyncOffPW = (U008)(((pFPTable->HSyncStart - pFPTable->HActive) & 0xC000)  |
                  (((pFPTable->HSyncEnd - pFPTable->HSyncStart) & 0xC000) >> 2) |
                  (((pFPTable->VSyncStart - pFPTable->VActive) & 0xC000) >> 4)  |
                  (((pFPTable->VSyncEnd - pFPTable->VSyncStart) & 0xC000) >> 6));
    HBorder     = (U008)(((pFPTable->HValidEnd - pFPTable->HDispEnd) & 0xFF));
    VBorder     = (U008)(((pFPTable->VValidEnd - pFPTable->VDispEnd) & 0xFF));
    //OR 0x18 into flags. This means:Non-Interlaced, No Stereo, Digital Separate.
    //The lower 2 bits of pFPTable->Flags tells us the sync polarities.
//    Flags       = (U008)(0x18 | (pFPTable->Flags & 0x03)); 
    //Meaning of bits 1 & 2 vary with setting, but for Digital Separate they are
    //Vsync polarity (bit 0 in BMP entry) and Hsync polarity (bit 4 in BMP entry)
    Flags       = (U008)(0x18 | ((pFPTable->Flags << 2) & 0x04) | ((pFPTable->Flags >> 3) & 0x02)); 

    //11 inches x 7 inches
    RegHImageSize = 0x011E;
    RegVImageSize = 0x00D7;

    HImageSize  = (U008)(RegHImageSize & 0xFF);
    VImageSize  = (U008)(RegVImageSize & 0xFF);
    HVImageSize = (U008)(((RegHImageSize & 0x0F00) >> 4) | ((RegVImageSize & 0x0F00) >> 8));

    //Construct a valid version 1 EDID header {00, FF, FF, FF, FF, FF, FF, 00}
    (*(U032*)pEdid)      = 0xFFFFFF00;
    (*(U032*)(pEdid +4)) = 0x00FFFFFF;

    pEdid[0x8] = (U008)((HexManufacturerName & 0xFF00) >> 8);
    pEdid[0x9] = (U008)(HexManufacturerName & 0x00FF);

    pEdid[0xB] = (U008)panelStrap; //Encode strapping number as a monitor ID digit.
                                   //This makes each EDID unique from Windows' perspective.

    //Fill in a version of 0x01
    //Fill in a revision of 0x03
    pEdid[0x12] = 0x01;
    pEdid[0x13] = 0x03;

    //Basic Display parameters
    pEdid[0x14] = 0x80; //Digital Signal level
    pEdid[0x15] = 0x1D; //Max Horiz Image Size (cm)
    pEdid[0x16] = 0x16; //Max Vert Image Size (cm)

    //Set Feature Support to indicate that we support
    //Standby, Suspend, Non-RGB MultiColor display,
    //and our prefered timing is in the first DTD block
    //(defined below).
    pEdid[0x18] = featuresupport; //0xCA;

    //Fill standard timings with 0x01 (means 'unused' in EDID parlance)
    *(U032*)(pEdid + 0x026) = 0x01010101;
    *(U032*)(pEdid + 0x02A) = 0x01010101;
    *(U032*)(pEdid + 0x02E) = 0x01010101;
    *(U032*)(pEdid + 0x032) = 0x01010101;

    //Begin Detailed Timing Description
    pEdid[0x36] = (U008)(pFPTable->PixClk & 0x00FF);
    pEdid[0x37] = (U008)((pFPTable->PixClk & 0xFF00) >> 8);
    pEdid[0x38] = HActive;
    pEdid[0x39] = HBlank;
    pEdid[0x3A] = HAcHBlnk;
    pEdid[0x3B] = VActive;
    pEdid[0x3C] = VBlank;
    pEdid[0x3D] = VAcVBlnk;
    pEdid[0x3E] = HSyncOffset;
    pEdid[0x3F] = HSyncPW;
    pEdid[0x40] = VSyncOffPW;
    pEdid[0x41] = HVSyncOffPW;
    pEdid[0x42] = HImageSize;
    pEdid[0x43] = VImageSize;
    pEdid[0x44] = HVImageSize;
    pEdid[0x45] = HBorder;
    pEdid[0x46] = VBorder;
    pEdid[0x47] = Flags;

    //Fill in panel name.  LPL: should we enforce a null terminator as last char?
    i = 0;
    while (i < MAX_MON_STRING_LENGTH)
    {
        curblk = 0x48 + (blknum * DD_BLOCK_LENGTH);
        pEdid[curblk+3] = 0xFC; //header is
        for (j = DD_BLOCK_DESC_LENGTH; j < DD_BLOCK_LENGTH; j++, i++)
        {
            if (panelname[i] != NULL)
            {
                pEdid[0x48 + (blknum * DD_BLOCK_LENGTH) + j] = panelname[i];
            }
        }
        blknum++;
        if (panelname[i] == NULL) break;
    }


    //Check if there is a full-EDID override key.  Parsing assumes a hexadecimal, comma-separated list.
    //Should we enforce a correct checksum, ignore it, or calculate it for them?  Currently we calc
    // it for them.
    if (osReadRegistryBinary(pDev, strDevNodeRM, EDIDPanelXX, (U008 *)PanelRegKeyVal, &numbytes) == RM_OK) 
    {
        U008 entry;
        i = 0;
        //Parsing presumes a comma-separate list, but is otherwise robust enough for
        // most hex digit formats. (padded to 2 digits or not, leading or trailing $, h, 0x, or none, etc.)
        for (j = 0; j <= numbytes; j++) {   //include terminating null char
            if ((PanelRegKeyVal[j] == ',') || (PanelRegKeyVal[j] == '\0')) {
                pEdid[i++] = entry;
                entry = 0;
            } else {
                convNibbleFromHex(PanelRegKeyVal[j], &entry);
            }
        }
    }


    //Make sure Num 128byte blocks to follow is 0
    pEdid[0x7E] = 0x00;
    //Make sure Checksum makes the edid add up to 0 
    dacInitCalculateEDIDChkSum(pDev, pEdid);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\dacmode.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* DAC Mode Control ***************************\
*                                                                           *
* Module: DACMODE.C                                                         *
*   The DAC mode control management is updated here.                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvhw.h"
#include <vga.h>
#include <nvcm.h>
#include <bios.h>   //For hotkey defs.  Can remove once those are put in nv_ref.h

extern char strDevNodeRM[];
extern char strLastExtDevice[];
extern char strCurWinDevices[];

//------------------------------------------------------------------------
// First 16 colors for mode 13h (compatible R'G'B'RGB)
//
U008 CompatColors[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07,
                        0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F};
                         
//------------------------------------------------------------------------
// Gray values for next 16 (6 bits of intensity)
//
U008 GrayColors[] = {0x00, 0x05, 0x08, 0x0B, 0x0E, 0x11, 0x14, 0x18,
                      0x1C, 0x20, 0x24, 0x28, 0x2D, 0x32, 0x38, 0x3F};
                                                                              
//------------------------------------------------------------------------
// Fixup values for DAC color registers after summing to gray shades
//
U008 FixupColors[] = {0x00, 0x05, 0x11, 0x1C, 0x08, 0x0B, 0x14, 0x28,
                       0x0E, 0x18, 0x2D, 0x32, 0x20, 0x24, 0x38, 0x3F};
                                                                       
//------------------------------------------------------------------------
// 9 groups of five intensities are used to generate the next 216 colors.
// Each group is used to generate 24 colors by walking around a "color
// triangle" with eight colors per side.
//
U008 IntenseTable[] =
{
    0x00, 0x10, 0x1F, 0x2F, 0x3F,
    0x1F, 0x27, 0x2F, 0x37, 0x3F,
    0x2D, 0x31, 0x36, 0x3A, 0x3F,
                                
    0x00, 0x07, 0x0E, 0x15, 0x1C,
    0x0E, 0x11, 0x15, 0x18, 0x1C,
    0x14, 0x16, 0x18, 0x1A, 0x1C,
                                
    0x00, 0x04, 0x08, 0x0C, 0x10,
    0x08, 0x0A, 0x0C, 0x0E, 0x10,
    0x0B, 0x0C, 0x0D, 0x0F, 0x10
};                              

//
// KJK I suspect this could be removed (or at least shortened) since we only used
//      one of the mode settings
//

//------------------------------------------------------------------------
//  Basic VGA mode default settings. This setup is used initially in all 
//  mode sets.
//
VGATBL   VGATable =
{
    // U008   columns;
    // U008   rows;
    // U008   char_height;
    // U016   RegenLenght;
    // SEQ    seq_regs;              // SR1-4
    // U008   PT_Misc;               // Misc Register
    // CRTC   crtc_regs;             // CR0-18
    // U008   PT_ATC[20];            // Attribute Controller
    // GR     gr_regs;               // GR0-8

    // Basic CRTC Table for Packed Pixel Graphics Modes.
     0x50, 0x1D, 0x10,
     0xFFFF,
    {0x01, 0x0F, 0x00, 0x0E},               // Seq
     0xEB,
    {0x5F, 0x4F, 0x4F, 0x83, 0x53, 0x9F,    // CR0-18
     0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0xEA, 0x0C,
     0xDF, 0x50, 0x00, 0xDF, 0x0C, 0xE3,
     0xFF},
    {0x00, 0x01, 0x02, 0x03, 0x04, 0x05,    // Attr
     0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
     0x0C, 0x0D, 0x0E, 0x0F, 0x01, 0x00,
     0x0F, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x40,    // GR
     0x05, 0x0F, 0xFF}
};    

/*************************** Helper functions *******************************/
//
//       dacWriteColor - Writes one color value (three bytes) to the video DAC
//               R(analog) = R * 2Ah + R' * 15h
//               G(analog) = G * 2Ah + G' * 15h
//               B(analog) = B * 2Ah + B' * 15h
//
static VOID dacWriteColor(PHWINFO pDev, U032 head, U008 colorval)
{
    U008   component;          // color component 4=red/2=green/1=blue
    U008   color;              // Color component to write
    
    for (component = 0x04; component; component >>= 1)
    {
        // Color?
        if (colorval & component)
            color = 0x2A;               // Add color
        else
            color = 0;                  // No color on this component
        
        // Intensity?
        if (colorval & (component << 3))
            color += 0x15;
    
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, color, head);
        ////WritePriv08(NV_USER_DAC_PALETTE_DATA, color);
    }
}        
        
//
//       dacWriteColor2 - Writes one color value (three bytes) to the video DAC
//               R(analog) = R * 2Ah + R' * 15h
//               G(analog) = G * 2Ah + G' * 15h
//               B(analog) = B * 2Ah + B' * 15h
//
static VOID dacWriteColor2(PHWINFO pDev, U032 head, U016 red, U016 green, U016 blue, U016 tblidx)
{
    DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+red], head);
    DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+green], head);
    DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+blue], head);

    ////WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+red]);
    ////WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+green]);
    ////WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+blue]);
}

//
//       dacLoadColorDACTable - Load the DAC for the 16-color modes
//
static VOID dacLoadColorDACTable(PHWINFO pDev, U032 head)
{
    U008  i;
    
    // Select the DAC address
    DAC_REG_WR08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00, head);
    ////WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);
    
    // Do the first 64 locations
    for (i = 0; i < 64; i++)
        dacWriteColor(pDev, head, i);
        
}
    
//
//       dacLoadColor256DAC - Load the DAC for the 256-color modes
//
static VOID dacLoadColor256DAC(PHWINFO pDev, U032 head)
{
    U016  i;
    U016  red;
    U016  green;
    U016  blue;
    
    // Select the DAC address
    DAC_REG_WR08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00, head);
    ////WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);
    
    //--------------------------------------------------------------------
    // The first 16 colors are the compatible colors (i.e. 0,1,2,3,4,5,14,
    // 7,38,39,3A,3B,3C,3D,3E,3F).
    //
    for (i = 0; i < 16; i++)
        dacWriteColor(pDev, head, CompatColors[i]);
    
    //--------------------------------------------------------------------
    // The next 16 give various intensities of gray (0,5,8,B,E,11,14,18,
    // 1C,20,24,28,2D,32,38,3F).
    //
    for (i = 0; i < 16; i++)
    {
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i], head);
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i], head);
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i], head);
        
        ////WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
        ////WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
        ////WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
    }                                                
        
    //--------------------------------------------------------------------
    // The next 216 registers give a variety of colors.
    //
    
    red = 0;
    green = 0;
    blue = 4;

    for (i = 0; i < 9; i++)
    {                       
    
        // I know these could probably be a function, but for now...
        // (this is getting tedious).
        
        // Traverse(blue, red);
        do
        {
            // To loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            red++;                                          
        } while (red < blue);
        
        do
        {
            // From loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            blue--;
        } while (blue);
        
        // Traverse(red, green);
        do
        {
            // To loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            green++;
        } while (green < red);
                         
        do
        {
            // From loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            red--;
        } while (red);
                 
            
        // Traverse(green, blue);
        do
        {
            // To loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            blue++;
        } while (blue < green);
                         
        do
        {
            // From loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            green--;
        } while (green);
    }                
             
    //-----------------------------------------------------------------------
    // The last 8 colors are black.
    //
    //               +---+-- 8 blanks * 3 locations (r/g/b)
    for (i = 0; i < (8 * 3); i++)
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, 0x00, head);
        ////WritePriv08(NV_USER_DAC_PALETTE_DATA, 0x00);
}

//
//       dacLoadIdentityDAC - Load the DAC with a gamma ramp
//
static VOID dacLoadIdentityDAC(PHWINFO pDev, U032 head)
{
    U016  i;
    
    // Select the DAC address
    DAC_REG_WR08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00, head);
                                                  
    for (i = 0; i < 256; i++)
    {           
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)i, head);
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)i, head);
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)i, head);
        
    }                                     
}

//
// Program the default video palette
//
static VOID dacLoadPalette
(
    PHWINFO pDev,
    U032    Head,
    U032    PixelDepth
)
{
    U008 i;
    U008 *pal = (U008 *)&(VGATable.PT_ATC); // default packed pixel palette
    volatile U008 scratch8;
    
    scratch8 = REG_RD08(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    ////ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    
    for (i = 0; i < 20; i++)
    {
        ATR_WR(i, *pal++, Head);               
        
        ////WritePriv08(NV_PRMCIO_ARX, i);      // Select AR
        ////WritePriv08(NV_PRMCIO_ARX, *pal++); // Write color data
    }
                                                
    scratch8 = REG_RD08(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    ////ReadPriv32(NV_PRMCIO_INP0__COLOR);        // Reset ATC FlipFlop
    
//    DAC_WR08(NV_PRMCIO_ARX, 0x14);   // Select AR14
//    DAC_WR08(NV_PRMCIO_ARX, 0x00);   // Zero it!
    ATR_WR(0x14, 0, Head);                 // Write 0 to AR14
    DAC_REG_WR08(NV_USER_DAC_PIXEL_MASK, 0xFF, Head);      // Write DAC Mask

    ////WritePriv08(NV_PRMCIO_ARX, 0x14);   // Select AR14
    ////WritePriv08(NV_PRMCIO_ARX, 0x00);   // Zero it!
    ////WritePriv08(NV_USER_DAC_PIXEL_MASK, 0xFF);      // Write DAC Mask

    switch(PixelDepth)
    {
        case    4:          // 4bpp - Planar -- CAN'T HAPPEN IN WINDOWS DRIVER
            dacLoadColorDACTable(pDev, Head);
            break;

        case    8:          // 8bpp - Packed
            dacLoadColor256DAC(pDev, Head);
            break;

        case    16:         // 16bpp - Packed
        case    15:         // 16bpp - Packed
        case    24:
        case    32:
        default:
            dacLoadIdentityDAC(pDev, Head);
            break;
    }
}

static VOID dacLoadIndexRange(PHWINFO pDev, U032 addr, U008 st_idx, U008 count, U008 *regs)
{
    U016  i;
    U016  wv;
    
    // Program <addr> register from <st_idx> to <st_idx + count>, using data from <regs>
    for (i = 0; i < count; i++)
    {               
        wv = *regs++;
        wv <<= 8;               // Put data in high half
        wv |= st_idx++;         // Get index and increment it
        WriteIndexed(addr, wv);
    }               
}                                  



//
// Program the default sequencer/graphics controller parameters
// PRMVIO for head 2 is accessed by setting CR44.
//
static VOID dacProgramSeq
(
    PHWINFO pDev,
    U032    Head
)
{
    U016  wv;
    
    // Load Sequencer and Misc. Output
    WriteIndexed(NV_PRMVIO_SRX, 0x0100);         // Sync Reset
    
    REG_WR08(NV_PRMVIO_MISC__WRITE, VGATable.PT_Misc);
                                                   
    // Load Sequencers, beginning at SR1, load 4 SR's (SR1-4), from the mode table
    dacLoadIndexRange(pDev, NV_PRMVIO_SRX, 1, sizeof(SEQ), (U008 *)&(VGATable.seq_regs));
                                            
    WriteIndexed(NV_PRMVIO_SRX, 0x0300);         // End Sync Reset
                                  
    // Load GDC's
    // Load GR, beginning at GR0, for all GR's (GR0-8), from the mode table
    dacLoadIndexRange(pDev, NV_PRMVIO_GRX, 0, sizeof(GR), (U008 *)&(VGATable.gr_regs));

    //
    // Common area of OEMSetRegs()
    //
    
    // User select MNP for VPLL, enable CPU access to FB, enable CGA I/O space.
    REG_WR08(NV_PRMVIO_MISC__WRITE, 0x2B);
                                                                  
    wv = 0x01;
    wv <<= 8;
    wv |= 0x01;
    WriteIndexed(NV_PRMVIO_SRX, wv); // Write SR01
    
}

//
// Program the CRTC timing (plus PRAMDAC_GENERAL_CONTROL and MISC OUTPUT sync polarities)
//
VOID dacProgramCRTC
(
    PHWINFO pDev,
    U032    Head,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac,
    U032    HorizontalVisible,        // in pixels
    U032    HorizontalBlankStart,     // in pixels
    U032    HorizontalRetraceStart,   // in pixels
    U032    HorizontalRetraceEnd,     // in pixels
    U032    HorizontalBlankEnd,       // in pixels
    U032    HorizontalTotal,          // in pixels
    U032    VerticalVisible,          // in lines
    U032    VerticalBlankStart,       // in lines
    U032    VerticalRetraceStart,     // in lines
    U032    VerticalRetraceEnd,       // in lines
    U032    VerticalBlankEnd,         // in lines
    U032    VerticalTotal,            // in lines
    U032    PixelDepth,
    U032    PixelClock,
    U032    HorizontalSyncPolarity,
    U032    VerticalSyncPolarity,
    U032    DoubleScannedMode
)
{
    U032 logicalwidth;
    U032 ramDacControl;
    U008 val08;
    U016 LC;

    // Here is how these timing values map to nv registers.
    // 
    // HorizontalTotal[8]           -> cr2D[0]  (# of characters - 5)
    // HorizontalTotal[7:0]         -> cr0[7:0] (# of characters - 5)
    // HorizontalVisible[8]         -> cr2D[1]  (in characters - 1)
    // HorizontalVisible[7:0]       -> cr1[7:0] (in characters - 1)
    // HorizontalBlankStart[8]      -> cr2D[2]  (in characters - 1)
    // HorizontalBlankStart[7:0]    -> cr2[7:0] (in characters - 1)
    // HorizontalBlankEnd[6]        -> cr25[4]
    // HorizontalBlankEnd[5]        -> cr5[7]
    // HorizontalBlankEnd[4:0]      -> cr3[4:0]
    // HorizontalRetraceStart[8]    -> cr2D[3]  (in characters + 1)
    // HorizontalRetraceStart[7:0]  -> cr4[7:0] (in characters + 1)
    // HorizontalRetraceEnd         -> cr5[4:0] (RetraceStart + pulseWidth = value programmed in this register)
    // VerticalVisible[10]          -> cr25[1]
    // VerticalVisible[9]           -> cr7[6]
    // VerticalVisible[8]           -> cr7[1]
    // VerticalVisible[7:0]         -> cr12[7:0]
    // VerticalBlankStart[10]       -> cr25[3]
    // VerticalBlankStart[9]        -> cr9[5]
    // VerticalBlankStart[8]        -> cr7[3]
    // VerticalBlankStart[7:0]      -> cr15[7:0]
    // VerticalRetraceStart[10]     -> cr25[2]
    // VerticalRetraceStart[9]      -> cr7[7]
    // VerticalRetraceStart[8]      -> cr7[2]
    // VerticalRetraceStart[7:0]    -> cr10[7:0]
    // VerticalRetraceEnd           -> cr11[3:0] (RetraceStart + pulseWidth = value programmed in this register)
    // VerticalBlankEnd             -> cr16
    // VerticalTotal[10]            -> cr25[0]
    // VerticalTotal[9]             -> cr7[5]
    // VerticalTotal[8]             -> cr7[0]
    // VerticalTotal[7:0]           -> cr6[7:0] (#of scanlines - 2)
    // PixelDepth                   -> cr13 (logical display width)
    //                              -> NV_PRAMDAC_GENERAL_CONTROL
    //                              -> cr28[1:0]
    // PixelClock                   -> NV_PRAMDAC_VPLL_COEFF
    // HorizontalSyncPolarity       -> NV_PRMVIO_MISC__WRITE[6]
    // VerticalSyncPolarity         -> NV_PRMVIO_MISC__WRITE[7]
    // DoubleScannedMode            -> cr9[7]
    //

    // Program up the basic registers first
    //
    
    //
    // Although the VGA spec is not clear on this, there is a single implicit line delay in the VRS and VRE
    // signals, so preadjust these values.
    //
    VerticalRetraceStart--;
    VerticalRetraceEnd--;
    
    // Line compare register is used to split the screen in half. We don't support this feature.
    // So the Line Compare register value is always 0x3ff.
    LC = 0x3ff;

    if (DoubleScannedMode)
    {
        // The verticalVisible and verticalBlankStart need to be doubled. 
        // The rest of the vertical timing modes are already doubled in the table.
        VerticalVisible *= 2;
        VerticalBlankStart *= 2;
    }

    //
    // CR0 (Horizontal Total) 
    //  Total number of horizontal characters in a scan line - 5
    //  Maximum horizontal resolution is 260 * 8 * (0.8), where (0.8) is visible %
    //
    CRTC_WR(NV_CIO_CR_HDT_INDEX, (U008)(HorizontalTotal >> 3) - 5, Head);
    
    //
    // CR1 (Horizontal Display End)
    //  Total number of displayed characters in a scan line - 1
    //
    CRTC_WR(NV_CIO_CR_HDE_INDEX, (U008)(HorizontalVisible >> 3) - 1, Head);
                   
    //
    // CR2 (Horizontal Blanking Start)
    //  Location where the horizontal blanking will start (in characters)
    //
    CRTC_WR(NV_CIO_CR_HBS_INDEX, (U008)((HorizontalBlankStart >> 3) - 1), Head);                   
        
    //
    // CR3 (Horizontal Blanking End)
    //  [7:7] CR (must be 1)
    //  [6:5] Display skew control (should be 0)
    //  [4:0] least significant 5 bits of Horizontal blanking end value (in characters).
    //
    CRTC_WR(NV_CIO_CR_HBE_INDEX, (U008)(((HorizontalBlankEnd >> 3) - 1) & 0x1F) | BIT(7), Head);
                   
    //
    // CR4 (Horizontal Retrace Start)
    //  Character position where the horizontal Retrace becomes active
    //
    CRTC_WR(NV_CIO_CR_HRS_INDEX, (U008)(HorizontalRetraceStart >> 3) + 1, Head);
                   
    //
    // CR5 (Horizontal Retrace End)
    //  [7:7] Bit6 of HBE (CR3)
    //  [6:5] Display skew control (should be 0)
    //  [4:0] Location of the end of the horizontal retrace period (in characters)
    //
    CRTC_WR(NV_CIO_CR_HRE_INDEX, ((U008)(((HorizontalRetraceEnd >> 3) + 1) & 0x1f))
                               | ((((HorizontalBlankEnd >> 3) - 1) & BIT(5)) ? BIT(7) : 0), Head);

    //
    // CR6 (Vertical Total)
    //  Total number of vertical scan lines on the monitor - 2
    //
    CRTC_WR(NV_CIO_CR_VDT_INDEX, (U008)((VerticalTotal - 2) & 0xFF), Head);
                   
    //
    // CR7 (Overflow Register)
    //  [7:7] Bit9 of VRS (CR10)
    //  [6:6] Bit9 of VDE (CR12)
    //  [5:5] Bit9 of VTR (CR6)
    //  [4:4] Bit8 of LC (CR18) 
    //  [3:3] Bit8 of VBS (CR15)
    //  [2:2] Bit8 of VRS (CR10)
    //  [1:1] Bit8 of VDE (CR12)
    //  [0:0] Bit8 of VTR (CR6)
    //
    CRTC_WR(NV_CIO_CR_OVL_INDEX, ((VerticalRetraceStart & BIT(9))     ? BIT(7) : 0x00)
                               | (((VerticalVisible - 1) & BIT(9))    ? BIT(6) : 0x00) 
                               | (((VerticalTotal - 2) & BIT(9))      ? BIT(5) : 0x00)
                               | ((LC & BIT(8))                       ? BIT(4) : 0x00)
                               | (((VerticalBlankStart - 1) & BIT(8)) ? BIT(3) : 0x00)
                               | ((VerticalRetraceStart & BIT(8))     ? BIT(2) : 0x00)
                               | (((VerticalVisible - 1) & BIT(8))    ? BIT(1) : 0x00)
                               | (((VerticalTotal - 2) & BIT(8))      ? BIT(0) : 0x00), Head);
                   
    //
    // CR8 (Screen A preset row scan)
    //  Should be set to 0 for us.
    CRTC_WR(NV_CIO_CR_RSAL_INDEX, 0, Head);

    //
    // CR9 (Character Cell Height register)
    //  [7:7] Scan double mode
    //  [6:6] Bit9 of LC (CR18) 
    //  [5:5] Bit9 of VBS (CR15)
    //  [4:0] Scan lines per character row - 1
    //
    CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, ((DoubleScannedMode)                 ? BIT(7) : 0x00)
                                   | ((LC & BIT(9))                       ? BIT(6) : 0x00)
                                   | (((VerticalBlankStart - 1) & BIT(9)) ? BIT(5) : 0x00), Head);
                 
    if (pDev->pStereoParams &&
       (pDev->pStereoParams->Flags & STEREOCFG_STEREOACTIVATED))
    {
        //The video start address is about to change. We want to turn off stereo as soon as possible
        pDev->pStereoParams->Flags &= ~STEREOCFG_STEREOACTIVATED;
    }            

    //
    // CR0C/CR0D (Start Address)
    //
    /*
    //this should be extracted from the HalInfo structure, not assumed to be zero
    CRTC_WR(NV_CIO_CR_SA_HI_INDEX, 0, Head);                 
    CRTC_WR(NV_CIO_CR_SA_LO_INDEX, 0, Head);
    */
    //program start address through HAL layer function
    dacProgramVideoStart(pDev,Head,pDev->Framebuffer.HalInfo.Start[Head],pVidLutCurDac->Image[0].Pitch);                
                 
    //
    // CR10 (Vertical Retrace Start)
    //  Line position of the vertical Retrace start
    //
    CRTC_WR(NV_CIO_CR_VRS_INDEX, (U008)(VerticalRetraceStart & 0xFF), Head);
                   
    //
    // CR11 (Vertical Retrace End)
    //  [7:7] WriteProtect for CR0-7
    //  [6:6] Reserved (Bandwidth)
    //  [5:5] Vertical Interrupts (0)
    //  [4:4] Clear Vertical Interrupt (0)
    //  [3:0] Vertical Retrace End Width
    //
    CRTC_WR(NV_CIO_CR_VRE_INDEX, (U008)(VerticalRetraceEnd & 0x0f), Head); 
                               
    //
    // CR12 (Vertical Display End)
    //  Total number of displayed lines - 1
    //
    CRTC_WR(NV_CIO_CR_VDE_INDEX, (U008)((VerticalVisible - 1) & 0xFF), Head);
    
    //
    // CR13 (Logical Display Width)
    //  Display Pitch
    //  The value written to CR13/CR19 is the number 8-byte chunks
    //
    logicalwidth = pVidLutCurDac->Image[0].Pitch >> 3;
    CRTC_WR(NV_CIO_CR_OFFSET_INDEX, logicalwidth & 0xFF, Head);
    
    //
    // CR14 (Underline Location)
    //  Double Word mode
    //  Bit 6 is set in some VGA modes to change CRTC addressing
    //
    CRTC_WR(NV_CIO_CR_ULINE_INDEX, 0, Head);
    
    //
    // CR14 (Underline Location)
    //  Double Word mode
    //  Bit 6 is set in some VGA modes to change CRTC addressing into framebuffer
    //
    CRTC_WR(NV_CIO_CR_ULINE_INDEX, 0, Head);
    
    //
    // CR15 (Vertical Blank Start)
    //  Scan line value where the vertical blanking begins
    //
    CRTC_WR(NV_CIO_CR_VBS_INDEX, (U008)((VerticalBlankStart - 1) & 0xFF), Head);
    
    //
    // CR16 (Vertical Blank End)
    //  Scan line value where the vertical blanking Ends
    //
    CRTC_WR(NV_CIO_CR_VBE_INDEX, (U008)((VerticalBlankEnd - 1) & 0xFF), Head);

    //
    // CR17 (Mode register)
    //  bit 7 - retrace enable, bits 1,0 - memory addressing
    //  bit 6 - byte/word addressing -- non-VGA modes always use byte addressing
    CRTC_RD(NV_CIO_CR_MODE_INDEX, val08, Head);
    CRTC_WR(NV_CIO_CR_MODE_INDEX, val08 | BIT(7) | BIT(6) | BIT(1) | BIT(0), Head);

    //
    // CR18 (Line Compare Register)
    //  Bits 7:0 of the line compare value
    //  This is useful only when we want to split the screen. We just program this to 0x3ff
    //
    CRTC_WR(NV_CIO_CR_LCOMP_INDEX, (U008)(LC & 0xFF), Head);

    //
    // CR19 (Repaint control register 0)
    //  [7:5] Bits 10:8 of CRTC Offset register (CR13)
    //
    CRTC_RD(NV_CIO_CRE_RPC0_INDEX, val08, Head);
    val08 = val08 & 0x1F;
    CRTC_WR(NV_CIO_CRE_RPC0_INDEX, (U008)(((logicalwidth & 0x700) >> 8) << 5) | val08, Head);

    //
    // CR1a (Repaint control register 1)
    //  [2] large screen bit. 
    //  NOTE: The manual says bit 2 should be set to 1 for modes < 1280x1024 and 
    //        0 for modes >= 1280x1024. However, that is not correct according to Peter Tong.
    //        It should be set to 0 for all non-vga modes (CR28).
    //          Safer to follow the original meaning of this bit.
    //  The rest of the bits are constant for all modes.
    //
    CRTC_RD(NV_CIO_CRE_RPC1_INDEX, val08, Head);        // grab the current sync status
    val08 = val08 & 0xC0;
    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, ((VerticalVisible < 1024) && (HorizontalVisible < 1280)) ? (0x3c | val08) : (0x38 | val08), Head);

    //
    // CR1c (Enhancement Register)
    //  This is a constant 0x1c for us.
    if (IsNV11(pDev) || IsNV1A(pDev)) {
        CRTC_WR(NV_CIO_CRE_ENH_INDEX, 0x3c, Head);
    } else {
        CRTC_WR(NV_CIO_CRE_ENH_INDEX, 0x1c, Head);
    }

    // Cr25 (Overflow register)
    //  [5:5] Bit 11 of CRTC offset register (this is 0)
    //  [4:4] Bit 6 of Horizontal Blanking End 
    //  [3:3] Bit 10 of Vertical Blank Start
    //  [2:2] Bit 10 of Vertical Retrace Start
    //  [1:1] Bit 10 of Vertical Display End
    //  [0:0] Bit 10 of Vertical Total
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, ((((HorizontalBlankEnd >> 3) - 1) & BIT(6)) ? BIT(4) : 0x00)
                                | (((VerticalBlankStart - 1) & BIT(10))       ? BIT(3) : 0x00)
                                | ((VerticalRetraceStart & BIT(10))           ? BIT(2) : 0x00)
                                | (((VerticalVisible - 1) & BIT(10))          ? BIT(1) : 0x00) 
                                | (((VerticalTotal - 2) & BIT(10))            ? BIT(0) : 0x00), Head);

    // 
    // CR28 (Pixel Format Register)
    //  [1:0] Pixel depth encoded as:
    //        0 - VGA
    //        1 - 8bpp
    //        2 - 16bpp
    //        3 - 32bpp

    // Also set PRAMDAC_GENERAL_CONTROL register. ALT_MODE field depends on the pixel depth. The rest
    // of the fields are the same for all pixel depths.
    
    ramDacControl = DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIXMIX,      _ON) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _VGA_STATE,   _SEL) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BLK_PEDSTL,  _OFF) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _TERMINATION, _37OHM) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC,         _8BITS) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _DAC_SLEEP,   _DIS) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PALETTE_CLK, _EN);
        
    switch (PixelDepth)
    {
        case 8:
            ramDacControl |= DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _NOTSEL);
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, NV_CIO_CRE_PIXEL_FORMAT_8BPP, Head);    
            break;                
        
        case 15:
            ramDacControl |= DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _15);
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, NV_CIO_CRE_PIXEL_FORMAT_16BPP, Head);    
            break;                
        
        case 16:
            ramDacControl |= DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _16);
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, NV_CIO_CRE_PIXEL_FORMAT_16BPP, Head);    
            break;                
        
        case 24:
            ramDacControl |= DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _24);
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, NV_CIO_CRE_PIXEL_FORMAT_32BPP, Head);    
            break;                
        
        case 32:        
            ramDacControl |= DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _30);
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, NV_CIO_CRE_PIXEL_FORMAT_32BPP, Head);    
            break;                
    } // switch on pixel depth       

    DAC_REG_WR32(NV_PRAMDAC_GENERAL_CONTROL, ramDacControl, Head);

    // 
    // cr2D (Horizontal Extra Bits Register)
    //  [5] Bit 23 of start address field (This is 0 for us)
    //  [4] Bit 8 of interlace half field start (This is 0 for us)
    //  [3] Bit 8 of Horizontal Retrace Start
    //  [2] Bit 8 of Horizontal Blank Start
    //  [1] Bit 8 of Horizontal Display End
    //  [0] Bit 8 of Horizontal Total
    CRTC_WR(NV_CIO_CRE_HEB__INDEX, ((((HorizontalRetraceStart >> 3) + 1) & BIT(8)) ? BIT(3) : 0x00)
                                 | ((((HorizontalBlankStart >> 3) - 1) & BIT(8))   ? BIT(2) : 0x00)
                                 | ((((HorizontalVisible >> 3) - 1) & BIT(8)) ? BIT(1) : 0x00) 
                                 | ((((HorizontalTotal >> 3) - 5) & BIT(8))  ? BIT(0) : 0x00), Head);

    // 0x3c2 (Misc output register)
    // Program the sync polarities.
    // [7] Vertical Sync Polarity:   0 - active High, 1 - active low 
    // [6] Horizontal Sync Polarity: 0 - active High, 1 - active low 
    val08 = (REG_RD08(NV_PRMVIO_MISC__READ) & 0x3f); // just take bits 5:0
    val08 |= (HorizontalSyncPolarity) ? BIT(6) : 0;
    val08 |= (VerticalSyncPolarity)   ? BIT(7) : 0;
    REG_WR08(NV_PRMVIO_MISC__WRITE, val08);

} // end of dacProgramCustomCRTC


// This is the entry point for non-multi-head-aware modeset methods.
RM_STATUS dacSetMode
(
    PHWINFO pDev,
    U032 head
)
{
    RM_STATUS rmStatus = RM_ERROR;

    if (pDev->Dac.CrtcInfo[head].pVidLutCurDac)
    {
        rmStatus = dacSetModeMulti(pDev, (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[head].pVidLutCurDac);
    }

    return rmStatus;
}

/***************************** exported functions **********************************/

// Dac HSYNC & VSYNC control
//
// The Mac needs to be able to individually control these for its power management
//

// XXX couldn't find a #define for these 2 bits...
#define HSYNCBIT   BIT(7)
#define VSYNCBIT   BIT(6)

RM_STATUS dacGetSyncState(
    PHWINFO pDev,
    U032    Head,
    U032   *pHsync,
    U032   *pVsync
)
{
    U008 data08;
    U008 lock;
    
    lock = UnlockCRTC(pDev, Head);
    
    if(GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
        if(dacIsFlatPanelOn(pDev,Head))
        {
            //if there was a bit 4 present, it implies *enabled*
            *pHsync=1;
            *pVsync=1;
        }
        else
        {
            *pHsync=0;
            *pVsync=0;
        }
    }
    else
    {
        CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
        *pHsync = ! (data08 & HSYNCBIT);
        *pVsync = ! (data08 & VSYNCBIT);
    }
    
    RestoreLock(pDev, Head, lock);
        
    return RM_OK;
}

RM_STATUS dacSetSyncState(
    PHWINFO pDev,
    U032    Head,
    U032    Hsync,
    U032    Vsync
)
{
    U008 data08;
    U008 lock;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    int  isFp = 0;
    
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: SetSyncState on Head", Head);
    
    if ( !Hsync || !Vsync)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Shutoff of sync requested.");
    }
    
    lock = UnlockCRTC(pDev, Head);
    
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    if (pVidLutCurDac && (pVidLutCurDac->DisplayType == DISPLAY_TYPE_FLAT_PANEL))
        isFp = 1;

#ifdef MACOS
    // Dac.CrtcInfo[Head].pVidLutCurDac is not a safe lookup on the mac, because
    // no modeset has been done to place a valid pVidLutCurDac into the pDev structure.
    // Info in HAL is correct at this point.
    if ( ! pVidLutCurDac && (GETDISPLAYTYPE(pDev, Head)==DISPLAY_TYPE_FLAT_PANEL))
        isFp = 1;
#endif

    if (isFp)
    {
        if((!Hsync)||(!Vsync))
        {
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"NVRM: Specifically the flatpanel\n");
            
            //power off flat panel
            dacPowerOffMobilePanel(pDev,Head);
            
            //kill PWM
            dacZeroPWMController(pDev);
        }
        else
        {            
            //power on the flat panel
            dacPowerOnMobilePanel(pDev,Head);
            
            //restore PWM
            dacSetPWMController(pDev);
        }
    }
    else
    {
        // read current value
        CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
        
        // clear both
        data08 &= ~(HSYNCBIT | VSYNCBIT);

        // set to 1 if no sync
        if ( ! Hsync)
            data08 |= HSYNCBIT;
        if ( ! Vsync)
            data08 |= VSYNCBIT;
        
        CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08, Head);
    }
    
    RestoreLock(pDev, Head, lock);
    
    return RM_OK;
}
#undef HSYNCBIT
#undef VSYNCBIT


RM_STATUS dacSetSpanning(
    PHWINFO pDev,
    U032    data
)
{
    U008 lock, crtcdata;
    //Update a local flag
    pDev->Dac.DeviceProperties.Spanning = data;

    //Also update a BIOS scratch bit
    lock = UnlockCRTC(pDev, 0);

    CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, crtcdata, 0);
    crtcdata &= ~(NV_SPANNING_MODE);
    if (data)
        crtcdata |= NV_SPANNING_MODE;
    CRTC_WR(NV_CIO_CRE_SCRATCH6__INDEX, crtcdata, 0);

    RestoreLock(pDev, 0, lock);

    return RM_OK;
}

//
// Perform any necessary system synchronization that is required at the start
// of a display change.
//
RM_STATUS dacSetModeStart(
    PHWINFO pDev,
    U032    data
)
{
#define TOSHIBA_FP          (0x1 << 0)
#define TOSHIBA_CRT         (0x1 << 1)
#define TOSHIBA_TV          (0x1 << 2)
    U032    DevToBIOSDev[] = {TOSHIBA_CRT, TOSHIBA_TV, 0, TOSHIBA_FP};
    U032    NewDevices;
    U032    OldDevices;

    U008 lock, crtcdata;
    U032 mscounter = 0;

    // check if this brackets a modeset (in the case of win9x, some don't).
    if ((data & NV_CFGEX_DISPLAY_CHANGE_BRACKETS_MODESET) == 0)
        return RM_OK;

    // If there is a change in process (someone called start a second time)
    // get out of here.  This is currently expected behavior -- more than
    // one start, but only one end.
    //
    if (pDev->Dac.DisplayChangeInProgress)
        return (RM_OK);

    //If we get here in a low power state jump out
    if (pDev->Power.State != 0)
    {
        return RM_OK;
    }

    // clear the DISPLAY_CHANGE_BRACKETS_MODESET flag
    data &= (DAC_DD_MASK_IN_MAP | DAC_TV_MASK_IN_MAP | DAC_CRT_MASK_IN_MAP);

    //
    // Determine the device(s) we're switching away from
    //
    OldDevices = 0x0;
    if (pDev->Dac.CrtcInfo[0].pVidLutCurDac && (GETDISPLAYTYPE(pDev, 0) != DISPLAY_TYPE_NONE))
        OldDevices |= DevToBIOSDev[GETDISPLAYTYPE(pDev, 0)];
    if (pDev->Dac.CrtcInfo[1].pVidLutCurDac && (GETDISPLAYTYPE(pDev, 1) != DISPLAY_TYPE_NONE))
        OldDevices |= DevToBIOSDev[GETDISPLAYTYPE(pDev, 1)];
    //
    // If we couldn't determine the device being switched away from, use the tracked value.
    // Win2K has this nasty habit of destroying all the Dac objects before calling the dispaly change start
    // so we never get the current device right so, to safeguard against this, if the OldDevices
    // is still set to none at this point, we'll just use the last device state that was tracked.
    //
    if(!OldDevices)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: dacSetModeStart - Determining OldDevices using fallback method.\n");
        if (pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType != DISPLAY_TYPE_NONE)
            OldDevices |= DevToBIOSDev[pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType];
        if (pDev->Dac.HalInfo.CrtcInfo[1].CurrentDisplayType != DISPLAY_TYPE_NONE)
            OldDevices |= DevToBIOSDev[pDev->Dac.HalInfo.CrtcInfo[1].CurrentDisplayType];
    }

    NewDevices = 0x0;
    if (data & DAC_CRT_MASK_IN_MAP)
        NewDevices |= TOSHIBA_CRT;
    if (data & DAC_TV_MASK_IN_MAP)
        NewDevices |= TOSHIBA_TV;
    if (data & DAC_DD_MASK_IN_MAP)
        NewDevices |= TOSHIBA_FP;

    //
    // ONLY DO THIS ON HEAD0
    //

    lock = ReadCRTCLock(pDev, 0);           //Back up lock state
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 0);    //Unlock CRTC extended regs

    // Notify BIOS we're starting a display driver change.
    CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, crtcdata, 0);
    CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, crtcdata | NV_MOBILE_FLAG_DISPLAY_CHANGING, 0);

    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, 0); // Restore lock state

    //
    // Save change data for use on the final notification
    //
    // This flag also acts as notification that we are in process of a display change
    //
//    pDev->Dac.DisplayChangeInProgress = data;
    pDev->Dac.DisplayChangeInProgress = (NewDevices << 8) | OldDevices;

    // 
    // Notify the system if required
    //
    dacMobileDisplayNotifyBegin(pDev, OldDevices, NewDevices);

    // This delay is here because the SBIOS does not seem to be setting the flag (checked below).
    // We exit the do/while in the first try. We expect that a fix in the SBIOS will make this delay unnecessary.
    osDelay(100); // wait 100 ms
    
    //Wait for SBIOS to finish.
    // Something in the system seems to relock them on us from time to time, so unlock every loop
    lock = UnlockCRTC(pDev, 0);
    do {
        UnlockCRTC(pDev, 0);
        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, crtcdata, 0);
        tmrDelay(pDev, 1000000);    //delay 1ms
        mscounter++;
    } while ((crtcdata & NV_MOBILE_FLAG_SBIOS_CRIT_SEC) && (mscounter < 1000));
    RestoreLock(pDev, 0, lock);

    if (mscounter >= 1000) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: timeout while waiting for SBIOS (CR4A[1]).\r\n");
    }

    return RM_OK;
}

//
// Perform any necessary system synchronization that is required at the end
// of a display change.
//
RM_STATUS dacSetModeEnd(
    PHWINFO pDev,
    U032    data
)
{
    U008 lock, crtcdata;
    U032 mscounter = 0;

    // check if this brackets a modeset (in the case of win9x, some don't).
    if ((data & NV_CFGEX_DISPLAY_CHANGE_BRACKETS_MODESET) == 0)
        return RM_OK;    // if this doesn't bracked the modeset, return

    //
    // If there is not a change in process (someone called end without calling start)
    // get out of here.
    //
    if (!pDev->Dac.DisplayChangeInProgress)
        return (RM_OK);

    //If we get here in a low power state jump out
    if (pDev->Power.State != 0)
    {
        return RM_OK;
    }

    // clear the DISPLAY_CHANGE_BRACKETS_MODESET flag
    data &= (DAC_DD_MASK_IN_MAP | DAC_TV_MASK_IN_MAP | DAC_CRT_MASK_IN_MAP);

    // 
    // Notify the system if required
    //
    dacMobileDisplayNotifyEnd(pDev, pDev->Dac.DisplayChangeInProgress & 0xFF, (pDev->Dac.DisplayChangeInProgress >> 8) & 0xFF);

    //
    // ONLY DO THIS ON HEAD0
    //

    //Wait for SBIOS to finish.
    // Something in the system seems to relock them on us from time to time, so unlock every loop
    // Save current lock state for restore later
    lock = UnlockCRTC(pDev, 0);
    do {
        UnlockCRTC(pDev, 0);
        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, crtcdata, 0);
        tmrDelay(pDev, 1000000);    //delay 1ms
        mscounter++;
    } while ((crtcdata & NV_MOBILE_FLAG_SBIOS_CRIT_SEC) && (mscounter < 1000));

    if (mscounter >= 1000) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: timeout while waiting for SBIOS (CR4A[1]).\r\n");
    }

    // Make sure the CRTC registers are still unlocked
    UnlockCRTC(pDev, 0);

    // Notify BIOS we're done with the display driver change.
    CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, crtcdata, 0);
    crtcdata &= ~(NV_MOBILE_FLAG_DISPLAY_CHANGING);
    CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, crtcdata, 0);

    // Restore the original locking state that was saved off earlier.
    RestoreLock(pDev, 0, lock);

    //Mobile specific: keep around knowledge of that the secondary (non-LCD) display
    // was set to.  Used when returning to Windows to enable TwinView modes.
    // The logic may seem unnecessarily careful, but we've seen problems with
    // the CR registers before due to BIOS problems, so I'm trying to handle
    // possible cases like the same display being set as enabled on more than
    // one head, etc., gracefully.
    if (pDev->Power.MobileOperation) {
        U032 extDevice = DISPLAY_TYPE_NONE;
#if 1
        //We know that if there's more than one device, one is the LCD, and there
        // are no other flat panels.  But I'll code the general case on general principle.
        if (data & (data - 1)) {  //if more than one display is enabled
            if (data & DAC_DD_MASK_IN_MAP) extDevice = DISPLAY_TYPE_FLAT_PANEL; //should always be true in mobile -- lowest priority
            if (data & DAC_TV_MASK_IN_MAP) extDevice = DISPLAY_TYPE_TV;         //higher priority
            if (data & DAC_CRT_MASK_IN_MAP) extDevice = DISPLAY_TYPE_MONITOR;   //highest priority
        } else {
            U008 lock, data08;
        //In NT, we can't count on destruction of the LUT objects as an indicator
        // that displays have been turned off -- both LUT objects are always around.
        // So instead, we clear the CR3B registers here.
        //This would be an acceptable solution on 9x as well, except that at the
        // moment the call to this function occurs before the actual modesets...
        // 6/8/01 (LPL) : have now enabled this for 9x as well.  This call occurs
        // after the modesets now, and we need it in order to straighten out the
        // scratch registers at startup if the display driver opts for a display
        // other than what the VBIOS had picked (in this case we wouldn't otherwise
        // clear CR3B for the other display, since there is no LUT object to destroy).
        // Fixes bug 34209.
            if (data & DAC_DD_MASK_IN_MAP) {
                lock = UnlockCRTC(pDev, 0);
                CRTC_RD(0x3B, data08, 0);
                CRTC_WR(0x3B, (data08 & 0x0F), 0);
                RestoreLock(pDev, 0, lock);
            } else {
                lock = UnlockCRTC(pDev, 1);
                CRTC_RD(0x3B, data08, 1);
                CRTC_WR(0x3B, (data08 & 0x0F), 1);
                RestoreLock(pDev, 1, lock);
            }
            extDevice = DISPLAY_TYPE_NONE;         //don't set any secondary devices
        }
#else   //#if 1
        //Read directly from the CR registers.  Problem: displaychangeend occurs _before_ the modesets.
        extDevice = DISPLAY_TYPE_NONE;  //default, if only one display is enabled
        if ((cr3BhA & 0xF0) && (cr3BhB & 0xF0)) {   //If two displays are enabled.
            //Check for displays other than the internal LCD
            if (cr3BhB & 0xE0) extDevice = cr3BhB;
            if (cr3BhA & 0xE0) extDevice = cr3BhA;  //head A trumps B
        }

        //Now translate into a display type
        if (extDevice & 0x20) {
            extDevice = DISPLAY_TYPE_MONITOR;
        } else if (extDevice & 0x40) {
            extDevice = DISPLAY_TYPE_TV;
        } else if (extDevice & 0x80) {
            extDevice = DISPLAY_TYPE_FLAT_PANEL; //external DFP
        } else {
            extDevice = DISPLAY_TYPE_NONE;
        }
#endif  //#if 1... else...

        osWriteRegistryDword(pDev, strDevNodeRM, strLastExtDevice, extDevice);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: external dev:", extDevice);

        osWriteRegistryDword(pDev, strDevNodeRM, strCurWinDevices, data);
    }

    //
    // Complete the display change -- clear the flag
    //
    pDev->Dac.DisplayChangeInProgress = 0;

    return RM_OK;
}


RM_STATUS dacSetModeStartEx(
    PHWINFO pDev,
    U032    devices,
    U032    properties
)
{
    RM_STATUS status;
    //Note: even if we add other operations here, call dacSetModeStart _first_ --
    // it sets a flag that signals a display change in progress.
    status = dacSetModeStart(pDev, devices);

#ifdef NTRM
    //Currently, the WinNT implementation supports the 'properties' field,
    // and 9x does not.  Get display driver people to unite on a single approach
    // soon!  The 9x display driver doesn't easily have access to this info
    // at display change time, so there is now a separate ConfigSet (NV_CFG_DISPLAY_CHANGE_CONFIG)
    // which can be used.
    status = dacSetSpanning(pDev, (properties & NV_CFGEX_DISPLAY_CHANGE_SPANNING)?1:0);
#endif

    return status;
}

RM_STATUS dacSetModeEndEx(
    PHWINFO pDev,
    U032    devices,
    U032    properties
)
{
    //Note: even if we add other operations here, call dacSetModeEnd _last_ --
    // it clears a flag that signals a display change in progress.
    return dacSetModeEnd(pDev, devices);
}

//
// Program the dac video parameters
//
//  Note that the video parameters have already been deposited in pDev.  This allows us to go
//  through multiple load/unload pairs (like DOS boxes) while still maintaining the original
//  video mode parameters.  It also makes it easier for an applet (like the control panel)
//  to tweak one value, then force an unload/load to make it affective.
//
RM_STATUS dacSetModeMulti(
    PHWINFO pDev,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac
)
{
    RM_STATUS status = RM_OK;
    U016      data,save_sr1 = 0;
    U032      data32;
    U008      shadow,data08, i, cr3Bmod, savedCR3D;
    volatile U032 scratch;
    
    // Extract parameters from the VIDEO_LUT_CURSOR_DAC object.
    U032      HorizontalVisible         = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    U032      HorizontalBlankStart      = pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart;
    U032      HorizontalRetraceStart    = pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart;
    U032      HorizontalRetraceEnd      = (pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart +
                                           pVidLutCurDac->HalObject.Dac[0].HorizontalSyncWidth);
    U032      HorizontalBlankEnd        = (pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart +
                                           pVidLutCurDac->HalObject.Dac[0].HorizontalBlankWidth);
    U032      HorizontalTotal           = pVidLutCurDac->HalObject.Dac[0].TotalWidth;
    U032      VerticalVisible           = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
    U032      VerticalBlankStart        = pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart;
    U032      VerticalRetraceStart      = pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart;
    U032      VerticalRetraceEnd        = (pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart +
                                           pVidLutCurDac->HalObject.Dac[0].VerticalSyncHeight);
    U032      VerticalBlankEnd          = (pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart +
                                           pVidLutCurDac->HalObject.Dac[0].VerticalBlankHeight);
    U032      VerticalTotal             = pVidLutCurDac->HalObject.Dac[0].TotalHeight;
    U032      PixelDepth                = pVidLutCurDac->HalObject.Dac[0].PixelDepth;
    U032      PixelClock                = pVidLutCurDac->HalObject.Dac[0].PixelClock;
    U032      HorizontalSyncPolarity    = pVidLutCurDac->HalObject.Dac[0].Format.HorizontalSyncPolarity;
    U032      VerticalSyncPolarity      = pVidLutCurDac->HalObject.Dac[0].Format.VerticalSyncPolarity;
    U032      DoubleScannedMode         = pVidLutCurDac->HalObject.Dac[0].Format.DoubleScanMode;
    U032      Head                      = pVidLutCurDac->HalObject.Head;
    
    //If we get here in a low power state jump out
    if (pDev->Power.State != 0)
    {
        return RM_OK;
    }
    //
    // Validate this mode is valid for the amount of framebuffer present
    // in this specific device.
    // Watch out for pixel depth of 15; add 1 to ensure it divides by 8 and give correct #bytes
    if ((HorizontalVisible * VerticalVisible * ((PixelDepth+1) >> 3)) > 
        pDev->Framebuffer.HalInfo.RamSize)
            return RM_ERROR;
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"NVRM: dacSetModeMulti,Enter\r\n");

    //
    // There is a bug in NV hardware where the hardware cursor will not clip correctly
    // if a border is defined in the display timings (blank start != visible end).  
    // Borders are only defined in two specific DMT modes.
    //
    // To fix this, set the blank starts to match the visible totals and remove the 
    // implicit borders.
    //
    // Remove this code when the hardware gets fixed.  Since this bug has been in the 
    // hardware since 1994, don't expect a fix soon.
    //
    HorizontalBlankStart = HorizontalVisible;
    HorizontalBlankEnd   = HorizontalTotal;
    VerticalBlankStart   = VerticalVisible;
    VerticalBlankEnd     = VerticalTotal;

    //
    // Now set monitor type.
    //
    switch (pVidLutCurDac->DisplayType)
    {
        case DISPLAY_TYPE_MONITOR:
            SETMONITORTYPE(pDev, Head, MONITOR_TYPE_VGA);
            break;
        case DISPLAY_TYPE_TV:
            switch (pVidLutCurDac->TVStandard)
            {
                case NTSC_M:
                case NTSC_J:
                    SETMONITORTYPE(pDev, Head, MONITOR_TYPE_NTSC);
                    break;
                case PAL_A:
                case PAL_M:
                case PAL_N:
                case PAL_NC:
                    SETMONITORTYPE(pDev, Head, MONITOR_TYPE_PAL);
                    break;
            }
            //
            // Set TV standard.
            //
            pDev->Dac.TVStandard = pVidLutCurDac->TVStandard;

            // Also set it in the cached copy that's used to refresh Macrovision settings.
            pDev->Dac.TVLastMacrovision.tvStandard = pVidLutCurDac->TVStandard;

            break;
        case DISPLAY_TYPE_DUALSURFACE:
            break;
        case DISPLAY_TYPE_FLAT_PANEL:        
            SETMONITORTYPE(pDev, Head, MONITOR_TYPE_FLAT_PANEL);

            if ( IsNV11(pDev) && pDev->Power.MobileOperation && (pDev->Power.MobileOperation != 2) )
            {
                if (dacGetFlatPanelConfig(pDev, Head) == NV_CFGEX_GET_FLATPANEL_INFO_SCALED)
                {
                    if ((HorizontalVisible <= 800) && (DAC_REG_RD32(NV_PRAMDAC_FP_HCRTC, Head) >= 1400))
                    {
                        // PCLK will be lowered
                        // If the PCLK isn't lowered now, we need to turn off the panel to prevent blooming
                        // If we ever change the PCLK, we need to power down the panel and run the reset script.
                        // This fixes bug 32763.
                        if(!(pDev->Dac.DevicesEnabled & DAC_LOW_PCLK_ENABLED))
                            dacPowerOffMobilePanel(pDev, Head);
                    }
                    else
                    {
                        // PCLK will be normal.
                        // If the PCLK is currently lowered, the we need to turn off the panel to prevent blooming
                        // If we ever change the PCLK, we need to power down the panel and run the reset script.
                        // This fixes bug 32763.
                        if(pDev->Dac.DevicesEnabled & DAC_LOW_PCLK_ENABLED)
                            dacPowerOffMobilePanel(pDev, Head);
                    }
                }
            }

            break;
        default:
            break;
    }
    // Work-around for a NV11 HW bug:
    // Find out what the current display is (do this before osPreModeSet sets new display type).
    // If it is TV, and this is NV11, call dacDisableTV to be sure PCLK doesn't get stuck when we change the
    // clock source. dacDisableTV checks for a stalled PCLK and kick-starts it.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)    
    {
        if (IsNV11(pDev)) dacDisableTV(pDev, Head);
    }
    //
    // We are about to set the new mode. Do any os specific actions necessary at this point.
    // This includes any registry overrides that may affect the new mode.
    // Specifically, determine what type of display device (CRT, FP, or TV), and if TV,
    // what format, and if FP, parse EDID to get timings.
    // NOTE: at this point, the new DisplayType is in the VidLutCurDac object, the old DisplayType is in HalInfo.CrtcInfo
    // (which GETDISPLAYTYPE and SETDISPLAYTYPE access).
    osPreModeSet(pDev, Head);

    //
    // Set display type.  We can't rely on the caller to actually
    // have specified an allowable valid type.  As one last check,
    // consult the allowed mask.  Don't reset the DisplayType field,
    // but continue on with the modeset just to be safe...
    //
    if ((GETCRTCHALINFO(pDev, Head, DisplayTypesAllowed) & DISPLAYTYPEBIT(pVidLutCurDac->DisplayType)) != 0)
        SETDISPLAYTYPE(pDev, Head, pVidLutCurDac->DisplayType);

    // 
    // Update the other Head's PrimaryDevice state, so it's consistent with this
    // Head's PrimaryDevice state (opposite head = opposite PrimaryDevice value).
    // 
    pDev->Dac.CrtcInfo[Head^1].PrimaryDevice = pDev->Dac.CrtcInfo[Head].PrimaryDevice^1;
    
    DBG_PRINT_STRING (DEBUGLEVEL_TRACEINFO, "Setting mode \n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "    H Res:", pDev->Framebuffer.HalInfo.HorizDisplayWidth);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "    V Res:", pDev->Framebuffer.HalInfo.VertDisplayWidth);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "Bit Depth:", PixelDepth);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "  Refresh:", pDev->Framebuffer.HalInfo.RefreshRate);

    // Set the requested refresh rate
    pVidLutCurDac->RefreshRate = (PixelClock * 10000) /
                                 (HorizontalTotal * VerticalTotal);

    //
    // Update tiling configuration.
    //
    nvHalFbControl(pDev, FB_CONTROL_TILING_CONFIGURE);

    //
    // Check for a change to nvclk/mclk values.
    //
    // Since we don't go through a STATE_LOAD as part of a mode switch, this is
    // where we'll program these clocks. The values are only interesting to the
    // arbitration code below, so anytime before that should be good.
    //
    // Since we also haven't done a STATE_UNLOAD, we're assuming this SW method
    // in the host FIFO has allowed enough of the chip to idle, so we can change
    // the clocks. In limited testing, this seems to work.
    //
    if (pDev->Dac.UpdateFlags & UPDATE_HWINFO_DAC_NVPLL)
    {
        // Program NVCLK
        status = dacProgramNVClk(pDev);
        pDev->Dac.UpdateFlags &= ~UPDATE_HWINFO_DAC_NVPLL;
    }

    // 
    // Transfer any update flags (i.e. mclk programming request) to pDev.
    //
    if (pDev->halHwInfo.pDacHalInfo->UpdateFlags & NV_HAL_DAC_UPDATE_MPLL)
    {
        pDev->Dac.UpdateFlags |= UPDATE_HWINFO_DAC_MPLL;
        pDev->halHwInfo.pDacHalInfo->UpdateFlags &= ~NV_HAL_DAC_UPDATE_MPLL;
    }

    if (pDev->Dac.UpdateFlags & UPDATE_HWINFO_DAC_MPLL)
    {
        // Program MCLK
        status = dacProgramMClk(pDev, 0);
        pDev->Dac.UpdateFlags &= ~UPDATE_HWINFO_DAC_MPLL;
    }



    //
    // Enable full CRTC access
    //           
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, 0x57, Head);

    //
    // If this is for CRTC2, set CRTC access bit and PRAMDAC address
    // This access bit controls accesses to Sequencer and Graphics Controller (C03xx).
    // CRTC and Attribute Controller must be accessed at different addresses for each head
    // (6103xx/6033xx), since there is only one bus.
    //
    if (IsNV11(pDev))
    {
        //
        // If there hasn't been a modeset on the other head, turn off the sequencer
        // there allowing more FB bandwidth for this head. When a modeset does occur,
        // dacProgramSeq will reset SR1 back. 
        //
        if (pDev->Dac.CrtcInfo[Head^1].pVidLutCurDac == NULL)
        {
            EnableHead(pDev, Head^1);
            REG_WR08(NV_PRMVIO_VSE2, 1);                    // enable VGA subsystem
            data08 = REG_RD08(NV_PRMVIO_MISC__READ);
            REG_WR08(NV_PRMVIO_MISC__WRITE, data08 | 1);    // enable CGA I/O space
        }

        // point CR44 at this head, for the rest of the modeset
        EnableHead(pDev, Head);
        if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
        {
            AssocTV(pDev, Head);
            AssocDDC(pDev, Head);
        }

        REG_WR08(NV_PRMVIO_VSE2, 1);                    // enable VGA subsystem
        data08 = REG_RD08(NV_PRMVIO_MISC__READ);
        REG_WR08(NV_PRMVIO_MISC__WRITE, data08 | 1);    // enable CGA I/O space
    }
        
    // Switching from FP or TV to CRT (CRTC slave mode) can stall the scanline counter. 
    dacDisableCRTCSlave(pDev, Head);

    // Disable flat panel syncs
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _DISABLE, Head); // 
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _DISABLE, Head); // 

    CRTC_RD(NV_CIO_CR_VRE_INDEX, data08, Head);
    CRTC_WR(NV_CIO_CR_VRE_INDEX, data08 & ~0x80, Head);    // unlock CR0-7
    
    // Before unlocking / reading CR21 we should write CR3D[0] to 1 to enable reading of
    // the shadow registers.  This will allow us to read the real CR register values from
    // the locked registers.
    CRTC_RD(0x3D, savedCR3D, Head);     // read CR3D
    savedCR3D |= 0x1;                   // set CR3D[0] to 1
    CRTC_WR(0x3D, savedCR3D, Head);     // write back CR3D[0] = 1

    CRTC_RD(0x21, shadow, Head);        // read shadow lock
    shadow |= 0xfa;                     // enable HDE, VDE, and 8/9 dot chars too, for NV5.

    // Before programming the shadow registers you must set CR3D[0] to 0
    savedCR3D &= ~0x1;                  // set CR3D[0] to 0
    CRTC_WR(0x3D, savedCR3D, Head);     // write back CR3D[0] = 0

    CRTC_WR(0x21, shadow, Head);        // write back shadow

    // Set H and V retrace start to a large value to prevent possible lock-up.
    // This is because if the CRTC is slaved to an external device (the TV encoder),
    // it will stall waiting for retrace start to sync up with the external clock. 
    // When we switch from TV to CRT, we may get stuck in this stall. Setting retrace 
    // start to a large value guarantees this won't happen.
    CRTC_WR(NV_CIO_CR_HRS_INDEX, 0xff, Head);
    CRTC_WR(NV_CIO_CR_VRS_INDEX, 0xff, Head);

    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
        U008 i;

        // bug workaround--disable scanline doubling and then shadow it. This allows writes to CR09 to affect the CRTC,
        //   but not the flat panel controller (else the flat panel controller may quadruple the scanline count).
        CRTC_RD(NV_CIO_CR_CELL_HT_INDEX, data, Head);         // read scanline double
        CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, (data &= ~0x80), Head);   // clear scanline double bit

        // Wait one vsync before shadowing the scanline double bit
        // Use a time-out in case the bit is stuck.
        for (i=0; i<17; i++)    // max time it can take is 16.7 ms (actually less)
        {
            if (DAC_REG_RD32(NV_PCRTC_RASTER, Head) & DRF_DEF(_PCRTC, _RASTER, _VERT_BLANK, _ACTIVE))
                break;      
            tmrDelay(pDev, 1000000);    // wait 1 ms
        }
        for (i=0; i<17; i++)    // max time it can take is 16.7 ms
        {
            if (!(DAC_REG_RD32(NV_PCRTC_RASTER, Head) & DRF_DEF(_PCRTC, _RASTER, _VERT_BLANK, _ACTIVE)))
                break;
            tmrDelay(pDev, 1000000);    // wait 1 ms
        }
    
        // shadow = CR21
        shadow &= ~0x40;                // shadow the scanline double bit
        CRTC_WR(0x21, shadow, Head);    // allow horiz & vert write-thru

        // de-couple vertical sync from flat panel while setting mode
        data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head); 
        data32 |= (NV_PRAMDAC_FP_DEBUG_0_TEST_NEWPIX << 16);   // set VCLK bits
        DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32, Head);

        // power off the panel until the mode is all setup
        //if (pDev->Power.MobileOperation)
        //{
        //    dacPowerOffMobilePanel(pDev, Head);
        //}
        // There's no need to turn off the panel.  We disable the visible screen so the user
        // not see anything.  This gets rid of at least 0.8 seconds in mode transitions.
    }
    else
    {
        //
        // We aren't driving DFP on this head, so we need to make sure to flush the overlay
        // clocking in the chip so it's not accidently left pointing at the DFP clocks.
        //
        // If we're not careful, the fp_newline signal inside the chip may still be driven
        // from fpclk, even though we aren't actively using fpclk.  This will result in
        // the overlay video engine not sending output data
        //
        // Here's the HW description of the bug
        //
        // This is a hardware bug that exists in NV10 and subsequent designs: 
        //  *  the video scaler relies on an a signal from the flat panel timing logic, fp_newline
        //  *  when the CRTC is not slaved to the FP, fp_newline should remain 1, however, this is 
        //     not always true
        //  *  if the FP timing has been previously programmed, and the CRTC is un-slaved from the 
        //     FP timing, fp_newline will continue to toggle as if the CRTC were still slaved to the FP.
        //  * also,  if the FPCLK is powered down at a moment when fp_newline is 0, fp_newline will 
        //    remain 0 until FPCLK is powered back up
        //  * fp_newline can be made to remain 1 by doing these steps before unslaving the CRTC from 
        //    the FP timing
        //    1.) disable vertical FP scaling
        //    2.) wait until the next frame
        //    3.) FPCLK and FP syncs must be enabled during this time (steps 1 and 2), i.e., 
        //        NV_PRAMDAC_FP_TG_CONTROL bits 1 and 5 must both be 0.
        //    4.) un-slave CRTC to FP timing
        //    5.) FPCLK and FP H- and V- syncs may now be disabled if desired
        //
        // This is supposed to be fixed on NV17 and later...
        // 
        
        if (IsNV10(pDev) || IsNV11(pDev) || IsNV1A(pDev) || IsNV15(pDev) || IsNV20(pDev))
        {
            U032 savedPowerState;

            U032 regvalue;
            U032 savemode;
            U032 savecenter;
            
            //Get current state of register
            regvalue   = DAC_REG_RD32(NV_PRAMDAC_FP_TG_CONTROL, Head); 
            savemode   = DRF_VAL(_PRAMDAC, _FP_TG_CONTROL, _MODE,   regvalue);
            savecenter = DRF_VAL(_PRAMDAC, _FP_TG_CONTROL, _CENTER, regvalue);

            // Temporarily turn on the FPCLK
            savedPowerState = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head);
            dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE);

            // Set the fp to centered with valid sync's 
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _NEG, Head);
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _NEG, Head);
            
            DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_START, 1, Head);
            DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_END,   0, Head);
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _CENTER, Head);
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _CENTER, _VERT, Head);

            // need to wait for fp_vsync to be high twice.
            // this could take 4 vsync times if we start at 0.
            // Figure a vsync time is ~20ms.
            // Adding another vsync (now 5) to wait to fix bug 31102
            tmrDelay(pDev, 5 * 20 * (1000 * 1000));

            // Put it back to previous mode
            DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _MODE,   savemode,   Head);
            DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _CENTER, savecenter, Head);

            // Turn FPCLK back off again
            DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, savedPowerState, Head);
            tmrDelay(pDev, 5 * 1000 * 1000);
        }
    }

    // Program the TV encoder if any.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
    {
        status = dacSetupTVEncoder(pDev, Head); 
        if (status)
        {
            switch (status)
            {
                case ERR_I2C_MODE:
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Can't program the TV encoder for this mode.\n");
                    break;
                case ERR_I2C_COMM:
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: I2C error programming mode\n");
                    break;
                case ERR_I2C_UNKNOWN:
                    DBG_PRINT_STRING (DEBUGLEVEL_ERRORS, "NVRM: No TV Encoder detected\n");
                    break;
            }                
            if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)      // if flat panel, leave it that way.
                SETDISPLAYTYPE(pDev, Head, DISPLAY_TYPE_MONITOR);  // No encoder set up for monitor
        }
    }

    //
    // Disable the visible screen
    //
    scratch = REG_RD32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    ////ReadPriv32(NV_PRMCIO_INP0__COLOR);       // Reset ATC FlipFlop
    REG_WR08(NV_PRMCIO_ARX, 0x00);               // Turn off screen at AR
    ////WritePriv08(NV_PRMCIO_ARX, 0x00);        // Turn off screen at AR
        
    //
    // FullCPUOn()
    //
    data = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
    data |= 0x2000;                             // Full Bandwidth bit ON
    WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit

    //
    // Set the sequencer & graphics controller values that are common for all packed-pixel
    // graphics modes.
    //            
    dacProgramSeq(pDev, Head);
    //
    // Program the CRTC & SR values for this particular mode.
    //
    dacProgramCRTC(pDev, Head, pVidLutCurDac,
                         HorizontalVisible,
                         HorizontalBlankStart,
                         HorizontalRetraceStart,
                         HorizontalRetraceEnd,
                         HorizontalBlankEnd,
                         HorizontalTotal,
                         VerticalVisible,
                         VerticalBlankStart,
                         VerticalRetraceStart,
                         VerticalRetraceEnd,
                         VerticalBlankEnd,
                         VerticalTotal,
                         PixelDepth,
                         PixelClock,
                         HorizontalSyncPolarity,
                         VerticalSyncPolarity,
                         DoubleScannedMode);

    // Set the flat panel timing registers (PRAMDAC_FP).
    // We must program the DAC before we load the palette, because the DAC is driving the 
    // VGA clock.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
        U032 fpMode, fpMaxX, fpMaxY;
        BOOL fpConnect;
        BOOL fpNative;
   
// TO DO: do not use the registry for NT
#ifndef NTRM
        status = dacGetFlatPanelInfo(pDev, Head, &fpMode, &fpMaxX, &fpMaxY, &fpConnect, &fpNative,
            ((pDev->Power.MobileOperation)?FALSE:TRUE) /* from registry */);

        //XXX: Special workaround for Toshiba. There are times when doing a modeset on 
        //a flat panel where the CR registers can become locked after we generate an
        //INT10 to our video bios, which in turn generates an INT15 to the system
        //bios. The real solution is to work with either the SBIOS or VBIOS people
        //to ensure that our lock state is being saved and restored correctly. For
        //now re-unlock the extended registers and enable vga subsystem after the
        //ReadEdid call.
        if (pDev->Power.MobileOperation == 2)
        {
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, 0x57, Head);
            EnableHead(pDev, Head);
            REG_WR08(NV_PRMVIO_VSE2, 1);                    // enable VGA subsystem
            data08 = REG_RD08(NV_PRMVIO_MISC__READ);
            REG_WR08(NV_PRMVIO_MISC__WRITE, data08 | 1);    // enable CGA I/O space
        }
#else
        status = dacGetFlatPanelInfo
        (
            pDev, 
            Head, 
            &fpMode, 
            &fpMaxX, 
            &fpMaxY, 
            &fpConnect, 
            &fpNative,
            FALSE           /* NOT from registry for NT */
        );
#endif

        // if Native mode requested, make sure this monitor supports it
        if ((fpMode == NV_CFGEX_GET_FLATPANEL_INFO_NATIVE) && (!fpNative))
            fpMode = NV_CFGEX_GET_FLATPANEL_INFO_SCALED;    // no, then do scaled
        status = dacSetFlatPanelMode(pDev, Head, pVidLutCurDac, fpMode, FALSE /* don't commit changes */);
    }
    else
    {
        //
        // If we aren't driving the panel through this head, or
        // (or the other head) turn it off.
        // 
        if (pDev->Power.MobileOperation)
        {
            if ((pDev->Dac.CrtcInfo[Head^1].pVidLutCurDac == NULL) ||
                (((PVIDEO_LUT_CURSOR_DAC_OBJECT)(pDev->Dac.CrtcInfo[Head^1].pVidLutCurDac))->DisplayType != DISPLAY_TYPE_FLAT_PANEL))
            {
                dacPowerOffMobilePanel(pDev, Head);
            }
        }
    }

    // If using an analog CRT with the external DAC, program the PRAMDAC_FP register to generate timing
    if ((GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_MONITOR) && (Head == 1))
    {
        U032 fpMode, fpMaxX, fpMaxY;
        BOOL fpConnect;
        BOOL fpNative;
   
        status = dacGetFlatPanelInfo(pDev, Head, &fpMode, &fpMaxX, &fpMaxY, &fpConnect, &fpNative, FALSE ); /* NOT from registry */
        status = dacSetFlatPanelMode(pDev, Head, pVidLutCurDac, NV_CFGEX_GET_FLATPANEL_INFO_NATIVE, FALSE);
        dacAdjustCRTCForFlatPanel(pDev, Head, pVidLutCurDac);
    }
    
    // This code is necessary to fix a bug found where the memory controller would hang if a delay
    // was NOT inserted before turning on the display after programming the pixel clock PLL's.
    // Only required for SMA mode.
    if(IsNV0A(pDev)){
        if(pDev->Framebuffer.HalInfo.RamType == BUFFER_CRUSH_UMA){
            save_sr1 = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
            data = save_sr1;
            data |= 0x2000;                             // Full Bandwidth bit ON
            WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit
        }
    }

    //
    // Program the new VPLL clock rate
    // If this is a flat panel, or flat panel engine is driving the analog monitor, we should not change the clocks
    if ((GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_FLAT_PANEL) && (Head != 1))
    {
        dacProgramPClk(pDev, Head, PixelClock);
    }

    //
    // Native modes require a divide-by-2 clock ratio
    //                                    
    if (Head == 0) 
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK_RATIO, _DB2);
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK_TV, _NONE);   // assume no TV for now
    }
    else
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK2_RATIO, _DB2);
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK2_TV, _NONE);  // assume no TV for now
    }
    pDev->Framebuffer.CursorAdjust = 0;   // default to no adjustment of cursor position
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
    {
        dacAdjustCRTCForTV(pDev, Head);              // CRTC tweaks for TV
    }
    else    
    {
        // Not TV, if flat panel, we may need to adjust CRTC's
        if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
            dacAdjustCRTCForFlatPanel(pDev, Head, pVidLutCurDac);
        if (Head == 0) 
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V1SOURCE, _PROG);
        }
        else
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V2SOURCE, _PROG);
        }
    }        
    
    //
    // Load default palette values. Do this after clock is running, else we hang.
    //
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
        // Set NEWPIX before programming palette to prevent hang on some systems (i.e. VIA).
        // This prevents the PCLK from being held off. Stopping PCLK is done to allow the pixel
        // stream to sync with the flat panel controller, but is also causes the palette to stop 
        // responding, causing bus retries. The VIA chipset doesn't like a lot of bus retries, 
        // and may eventually hang the bus.
        data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head);           
        data32 |= (NV_PRAMDAC_FP_DEBUG_0_TEST_NEWPIX << 16);  // set NEWPIX
        DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32, Head);
    }

#ifdef MACOS
    // We don't init the palette on either Mac os; its already been set
    //   to their own style of LUT and these defaults just cause flashing
#else
    dacLoadPalette(pDev, Head, PixelDepth);
#endif

    // Restore normal clocking (flat panel can hold off)
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
        data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head);           
        data32 &= ~(NV_PRAMDAC_FP_DEBUG_0_TEST_BOTH << 16); // set to normal mode
        DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32, Head);
    }

    if(!IsNV0A(pDev)){
        //
        // FullCpuOff()
        //
        data = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
        data &= 0xDFFF;                             // Full Bandwidth bit OFF
        WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit            
    }else{
        if(pDev->Framebuffer.HalInfo.RamType != BUFFER_CRUSH_UMA){
            data = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
            data &= 0xDFFF;                             // Full Bandwidth bit OFF
            WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit            
        }
    }
    
    //
    // ATCOn()
    //
    scratch = REG_RD32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    ////ReadPriv32(NV_PRMCIO_INP0__COLOR);       // Reset ATC FlipFlop
    REG_WR08(NV_PRMCIO_ARX, 0x20);               // Turn off screen at AR
    ////WritePriv08(NV_PRMCIO_ARX, 0x20);        // Turn off screen at AR
    scratch = REG_RD32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    ////ReadPriv32(NV_PRMCIO_INP0__COLOR);       // Reset ATC FlipFlop
      
    // make sure test modes are off, else screen may be blanked
    DAC_REG_WR32(NV_PRAMDAC_TEST_CONTROL, 0, Head); // make sure test modes are off!

    // Enable active display, blank all non-active displays
    //  (TV is blanked in encoder-specific function).
    // + in mobile case, update BIOS's record of enabled displays
    cr3Bmod = 0;
    switch (GETDISPLAYTYPE(pDev, Head))
    {
        case DISPLAY_TYPE_MONITOR:
            if (Head == 0) // if normal VGA (internal DAC) 
            {
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _ON, Head);  // CRT on
                //
                // We need to be careful about powering down the TMDS
                // transmitter on NV11 because we can lose a flat
                // panel connected to the second crtc (head 1).
                //
                // XXX doing this on the P11 kills the FP on head 1.
                // commenting it out doesn't seem to break anything on the Mac....
                
#ifndef MACOS
                if (IsNV11(pDev))
                    dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_FPCLK);     // FPCLK off only;leave TMDS going for secondary crtc
                else
                    dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_BOTH);      // FPCLK/TMDS both off
#endif       
                CRTC_RD(0x33, data08, Head);
                CRTC_WR(0x33, (data08 & ~0x02), Head);  // clear CR33[1] (BIOS flag)

                // enable H&V sync's
                CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
                CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 & 0x3F, Head);
                
                // make sure that head 0 is NOT driving FP output
                CRTC_RD(0x33, data08, Head);
                CRTC_WR(0x33, data08 & ~0x10, Head);    // Bit 4 = 0
                
                dacSetCursorBlink(pDev, Head, 0); // set cursor blink rate for DOS
            }
            else // PRAMDAC_FP is driving analog
            {
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head); // CRT off
                CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
                CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 & ~0x40, Head);
                
                // make head 0 drive FP output
                CRTC_RD(0x33, data08, Head);
                CRTC_WR(0x33, data08 | 0x10, Head);    // Bit 4 = FP 2
                
                dacSetCursorBlink(pDev, Head, 1); // set cursor blink rate for DOS
            }

            // If no head is using TV, blank image.
            for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                if (GETDISPLAYTYPE(pDev, i) == DISPLAY_TYPE_TV)
                    break;
            if (i == pDev->Dac.HalInfo.NumCrtcs)
                dacDisableTV(pDev, Head);
            //Update BIOS's record of enabled displays

            cr3Bmod = 0x20;
            break;                              
        case DISPLAY_TYPE_TV:
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head); // CRT offs
            //
            // We need to be careful about powering down the TMDS
            // transmitter on NV11 because we can lose a flat
            // panel connected to the second crtc (head 1).  This wouldn't
            // be an issue if we could 
            //
            if (IsNV11(pDev))
                dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_FPCLK);     // FPCLK off only;leave TMDS going for secondary crtc
            else
                dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_BOTH);      // FPCLK/TMDS both off
            // Turn Hsync off and Vsync on, or leave both on, depending on what we found in registry
            CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
            data08 &= ~0xC0;
            if (pDev->Dac.HsyncOff) 
            {
                CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 |= 0x80, Head); // disable horiz sync to put CRT in suspend
            }
            else
            {
                CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08, Head);    // leave both syncs on
            }
            dacSetCursorBlink(pDev, Head, 1); // set cursor blink rate for DOS

            //Update BIOS's record of enabled displays
            cr3Bmod = 0x40;
            break;                              
        case DISPLAY_TYPE_FLAT_PANEL:
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head); // CRT off
            // Turn Hsync off and Vsync on, or leave both on, depending on what we found in registry
            CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
            data08 &= ~0xC0;
            if (pDev->Dac.HsyncOff) 
            {
                CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 |= 0x80, Head); // disable horiz sync to put CRT in suspend
            }
            else
            {
                CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08, Head);    // leave both syncs on
            }
            CRTC_RD(0x33, data08, Head);
            CRTC_WR(0x33, data08 | 0x10, Head);    // Bit 4 = FP 2
            // If no head is using TV, blank image.
            for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                if (GETDISPLAYTYPE(pDev, i) == DISPLAY_TYPE_TV)
                    break;
            if (i == pDev->Dac.HalInfo.NumCrtcs)
                dacDisableTV(pDev, Head);
            // Need to actually power on the panel as well
            if (pDev->Power.MobileOperation)
                dacPowerOnMobilePanel(pDev, Head);
            dacSetCursorBlink(pDev, Head, 1); // set cursor blink rate for DOS

            //Update BIOS's record of enabled displays
            if (Head == 1) {
                cr3Bmod = 0x10;    //internal LCD
            } else {
                cr3Bmod = 0x80;    //external DFP
            }
            break;                              
    }

    //Update BIOS's record of enabled displays
    if (pDev->Power.MobileOperation  && !pDev->Vga.Enabled) {
        U008 lock;

        lock = UnlockCRTC(pDev, Head);

        CRTC_RD(0x3B, data08, Head);
        CRTC_WR(0x3B, (data08 & 0x0F) | cr3Bmod, Head);

        RestoreLock(pDev, Head, lock);
    }

    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
    {
        shadow &= ~0x80;          // shadow Horiz only
        CRTC_WR(0x21, shadow, Head);    // restore the shadow lock

        // restore macrovision mode if appropriate
        if (pDev->Dac.TVLastMacrovision.mode & 0x3)
            SetMacrovisionMode(pDev, Head, (RM_MACROVISION_CONTROL *)&(pDev->Dac.TVLastMacrovision));

    }

    //Fix for Crush. TV and Flat Panel share some registers. We must
    //set the mux to pick the correct display.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL) 
    {
        if (IsNV0A(pDev)) 
        {
            data32 = 0x00000005;
            DAC_REG_WR32(NV_PRAMDAC_TV_SETUP, data32, Head); 
        }
    }    
    //
    // For NV4, change the default flip functionality to end of vsync, not start
    //
    // BUG BUG BUG:  There is a hardware bug in NV4/NV5 relating to this particular
    // register.  You must access another register in this general area before
    // accessing PCRTC_CONFIG
    //
    data32 = DAC_REG_RD32(NV_PCRTC_START, Head);
    DAC_FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _NON_VGA, Head);
    
    //
    // Update arb settings for each mode set
    // test: if this is the modeset class' allocation, do arbitration setup. Else skip
    if(pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac==(VOID_PTR)pVidLutCurDac)
    {   
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"updating arb settings for modeset");
        nvHalDacUpdateArbSettings(pDev,(VOID*)&pVidLutCurDac->HalObject);
    }

    // Save the retrace start/end values (display position default)
    dacSaveMonitorDefaultPosition(pDev, Head);

    // We have successfully set a new mode. Do any os specific actions.
    // This includes any registry settings that should take effect at a mode set.
    osPostModeSet(pDev, Head);

    //
    // Determine if it's possible to support a video overlay in this resolution
    //

    //LPL: will later either add a new multichip function for multi-display,
    // or expand the parameter list on the existing fn.  For now, this hack
    // minimizes the changes to other files.
    nvHalDacValidateArbSettings(pDev, 
                                PixelDepth, 
                                1, 0, 
                                (PixelClock * 10000), Head,
                                &(pDev->Video.HalInfo.OverlayAllowed));


    //
    // Set ReadOnly CRTC access
    //           
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, 0x99, Head);

    if(IsNV0A(pDev)){
        if(pDev->Framebuffer.HalInfo.RamType == BUFFER_CRUSH_UMA){
            tmrDelay(pDev,/*U032 nsec*/100000000);
            save_sr1 &= 0xDFFF;                         // Full Bandwidth bit OFF
            WriteIndexed(NV_PRMVIO_SRX, save_sr1);      // Set bit            
        }
    }

    //
    // If we're on an NV11, restore VGA accesses to the primary device.
    //
    if (IsNV11(pDev))
    {
        if ((pDev->Chip.BiosRevision & 0xFF00FFFF) < 0x03000020)
        {
            // Not a multi-head aware BIOS, back to head 0
            EnableHead(pDev, 0);
        }
        else if (pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].PrimaryDevice == FALSE)
        {
            // Point VGA accesses back to the other (primary) head
            EnableHead(pDev, Head^1);
        }
    }
    
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NV_PCRTC_START : ",DAC_REG_RD32(NV_PCRTC_START,Head));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NV_PCRTC_CONFIG: ",DAC_REG_RD32(NV_PCRTC_CONFIG,Head));

    //
    // Clear out panning state.
    //
    pDev->Dac.CrtcInfo[Head].CurrentPanOffset = 0;
    pDev->Video.HalInfo.PanOffsetDeltaX[Head] = 0;
    pDev->Video.HalInfo.PanOffsetDeltaY[Head] = 0;

    //
    // Finally, make sure VBlank will be serviced
    DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, DACGETHEAD(pVidLutCurDac));
    DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_EN_0, _VBLANK, _ENABLED, DACGETHEAD(pVidLutCurDac));
    pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].StateFlags |= DAC_CRTCINFO_VBLANK_ENABLED;
    {
        volatile U032 rasterPos;
        rasterPos = REG_RD32(NV_PCRTC_RASTER + CurDacAdr(Head));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"dacSetModeMulti,Exit, raster : ",rasterPos);

    }
    return RM_OK;
} // end of dacSetModeMulti


//
// Program the dac video parameters, and JUST the dac video parameters
//
// This routine is called primarily during VGA connect testing for
// minimal clocking
//
RM_STATUS dacSetModeMini(
    PHWINFO pDev,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac
)
{
    U016      data,save_sr1 = 0;
    U008      shadow,data08,savedCR3D;
    volatile U032 scratch;
    
    // Extract parameters from the VIDEO_LUT_CURSOR_DAC object.
    U032      HorizontalVisible         = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    U032      HorizontalBlankStart      = pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart;
    U032      HorizontalRetraceStart    = pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart;
    U032      HorizontalRetraceEnd      = (pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart +
                                           pVidLutCurDac->HalObject.Dac[0].HorizontalSyncWidth);
    U032      HorizontalBlankEnd        = (pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart +
                                           pVidLutCurDac->HalObject.Dac[0].HorizontalBlankWidth);
    U032      HorizontalTotal           = pVidLutCurDac->HalObject.Dac[0].TotalWidth;
    U032      VerticalVisible           = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
    U032      VerticalBlankStart        = pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart;
    U032      VerticalRetraceStart      = pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart;
    U032      VerticalRetraceEnd        = (pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart +
                                           pVidLutCurDac->HalObject.Dac[0].VerticalSyncHeight);
    U032      VerticalBlankEnd          = (pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart +
                                           pVidLutCurDac->HalObject.Dac[0].VerticalBlankHeight);
    U032      VerticalTotal             = pVidLutCurDac->HalObject.Dac[0].TotalHeight;
    U032      PixelDepth                = pVidLutCurDac->HalObject.Dac[0].PixelDepth;
    U032      PixelClock                = pVidLutCurDac->HalObject.Dac[0].PixelClock;
    U032      HorizontalSyncPolarity    = pVidLutCurDac->HalObject.Dac[0].Format.HorizontalSyncPolarity;
    U032      VerticalSyncPolarity      = pVidLutCurDac->HalObject.Dac[0].Format.VerticalSyncPolarity;
    U032      DoubleScannedMode         = pVidLutCurDac->HalObject.Dac[0].Format.DoubleScanMode;
    U032      Head                      = pVidLutCurDac->HalObject.Head;
    

    //
    // There is a bug in NV hardware where the hardware cursor will not clip correctly
    // if a border is defined in the display timings (blank start != visible end).  
    // Borders are only defined in two specific DMT modes.
    //
    // To fix this, set the blank starts to match the visible totals and remove the 
    // implicit borders.
    //
    // Remove this code when the hardware gets fixed.  Since this bug has been in the 
    // hardware since 1994, don't expect a fix soon.
    //
    HorizontalBlankStart = HorizontalVisible;
    HorizontalBlankEnd   = HorizontalTotal;
    VerticalBlankStart   = VerticalVisible;
    VerticalBlankEnd     = VerticalTotal;

    //
    // Enable full CRTC access
    //           
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, 0x57, Head);

    //
    // If this is for CRTC2, set CRTC access bit and PRAMDAC address
    // This access bit controls accesses to Sequencer and Graphics Controller (C03xx).
    // CRTC and Attribute Controller must be accessed at different addresses for each head
    // (6103xx/6033xx), since there is only one bus.
    //
    if (IsNV11(pDev))
    {

        // point CR44 at this head, for the rest of the modeset
        EnableHead(pDev, Head);

        REG_WR08(NV_PRMVIO_VSE2, 1);                    // enable VGA subsystem
        data08 = REG_RD08(NV_PRMVIO_MISC__READ);
        REG_WR08(NV_PRMVIO_MISC__WRITE, data08 | 1);    // enable CGA I/O space
    }


    CRTC_RD(NV_CIO_CR_VRE_INDEX, data08, Head);
    CRTC_WR(NV_CIO_CR_VRE_INDEX, data08 & ~0x80, Head);    // unlock CR0-7

    // Before unlocking / reading CR21 we should write CR3D[0] to 1 to enable reading of
    // the shadow registers.  This will allow us to read the real CR register values from
    // the locked registers.
    CRTC_RD(0x3D, savedCR3D, Head);     // read CR3D
    savedCR3D |= 0x1;                   // set CR3D[0] to 1
    CRTC_WR(0x3D, savedCR3D, Head);     // write back CR3D[0] = 1

    CRTC_RD(0x21, shadow, Head);        // read shadow lock
    shadow |= 0xfa;                     // enable HDE, VDE, and 8/9 dot chars too, for NV5.

    // Before programming the shadow registers you must set CR3D[0] to 0
    savedCR3D &= ~0x1;                  // set CR3D[0] to 0
    CRTC_WR(0x3D, savedCR3D, Head);     // write back CR3D[0] = 0

    CRTC_WR(0x21, shadow, Head);        // write back shadow
      
    // Set H and V retrace start to a large value to prevent possible lock-up.
    // This is because if the CRTC is slaved to an external device (the TV encoder),
    // it will stall waiting for retrace start to sync up with the external clock. 
    // When we switch from TV to CRT, we may get stuck in this stall. Setting retrace 
    // start to a large value guarantees this won't happen.
    CRTC_WR(NV_CIO_CR_HRS_INDEX, 0xff, Head);
    CRTC_WR(NV_CIO_CR_VRS_INDEX, 0xff, Head);

    //
    // Disable the visible screen
    //
    scratch = REG_RD32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    REG_WR08(NV_PRMCIO_ARX, 0x00);               // Turn off screen at AR
        
    //
    // FullCPUOn()
    //
    data = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
    data |= 0x2000;                             // Full Bandwidth bit ON
    WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit

    //
    // Set the sequencer & graphics controller values that are common for all packed-pixel
    // graphics modes.
    //            
    dacProgramSeq(pDev, Head);
    //
    // Program the CRTC & SR values for this particular mode.
    //
    dacProgramCRTC(pDev, Head, pVidLutCurDac,
                         HorizontalVisible,
                         HorizontalBlankStart,
                         HorizontalRetraceStart,
                         HorizontalRetraceEnd,
                         HorizontalBlankEnd,
                         HorizontalTotal,
                         VerticalVisible,
                         VerticalBlankStart,
                         VerticalRetraceStart,
                         VerticalRetraceEnd,
                         VerticalBlankEnd,
                         VerticalTotal,
                         PixelDepth,
                         PixelClock,
                         HorizontalSyncPolarity,
                         VerticalSyncPolarity,
                         DoubleScannedMode);


    // This code is necessary to fix a bug found where the memory controller would hang if a delay
    // was NOT inserted before turning on the display after programming the pixel clock PLL's.
    // Only required for SMA mode.
    if(IsNV0A(pDev)){
        if(pDev->Framebuffer.HalInfo.RamType == BUFFER_CRUSH_UMA){
            save_sr1 = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
            data = save_sr1;
            data |= 0x2000;                             // Full Bandwidth bit ON
            WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit
        }
    }

    //
    // Program the new VPLL clock rate
    //
    dacProgramPClk(pDev, Head, PixelClock);

    //
    // Native modes require a divide-by-2 clock ratio
    //                                    
    if (Head == 0) 
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V1SOURCE, _PROG);
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK_RATIO, _DB2);
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK_TV, _NONE);   // assume no TV for now
    }
    else
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V2SOURCE, _PROG);
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK2_RATIO, _DB2);
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK2_TV, _NONE);  // assume no TV for now
    }
        
    if(!IsNV0A(pDev)){
        //
        // FullCpuOff()
        //
        data = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
        data &= 0xDFFF;                             // Full Bandwidth bit OFF
        WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit            
    }else{
        if(pDev->Framebuffer.HalInfo.RamType != BUFFER_CRUSH_UMA){
            data = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
            data &= 0xDFFF;                             // Full Bandwidth bit OFF
            WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit            
        }
    }
    
    //
    // ATCOn()
    //
    scratch = REG_RD32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    REG_WR08(NV_PRMCIO_ARX, 0x20);               // Turn off screen at AR
    scratch = REG_RD32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
      
    //
    // Set ReadOnly CRTC access
    //           
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, 0x99, Head);

    if(IsNV0A(pDev)){
        if(pDev->Framebuffer.HalInfo.RamType == BUFFER_CRUSH_UMA){
            tmrDelay(pDev,/*U032 nsec*/100000000);
            save_sr1 &= 0xDFFF;                         // Full Bandwidth bit OFF
            WriteIndexed(NV_PRMVIO_SRX, save_sr1);      // Set bit            
        }
    }

    return RM_OK;

} // end of dacSetModeMini

//
// Mobile systems may require further notifications be made to the BIOS
// that we are changing display devices.
//
RM_STATUS dacMobileDisplayNotifyBegin
(
    PHWINFO pDev,
    U032    OldDevices,
    U032    NewDevices
)
{
#if !defined(MACOS) 
    U032    EAX, EBX, ECX, EDX;
    RM_STATUS status;
    U008    lock, crtcdata;
    U032    timeHI, timeLO;
#endif

// until osCallVideoBIOS() is added to the other os's
#if !defined(MACOS) 
    //
    // If we're not running mobile, don't do this
    //
    // NOTE: We can probably stop limiting this to just Toshiba
    //
    if (!pDev->Power.MobileOperation)
        return RM_OK;

    //Removed for non-Toshiba mobiles since backlight manufacture script implementation
    //    if (pDev->Power.MobileOperation != 2)
    //            return RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: dacMobileDisplayNotifyBegin\n");

    // If we aren't switching any devices, just ignore this notification
    //
    //Keeping this in will leave one screen blank during resume from hibernation
    // when in clone or extended mode.  Doh.  Other than that, it's a good idea...
//    if (OldDevices == NewDevices)
//        return RM_OK;

    // Incurr smart delay for stalling from power on to power off
    // This fixes 32252 and 31237 - Going from Clone to Extended mode
    // we get called 3 times to change the mode.  This will slow those modechanges down.
    if (pDev->Power.MobileOperation == 2)
    {
        tmrGetCurrentTime(pDev, &timeHI, &timeLO);
        if((pDev->Dac.PanelOffTimestampHI > timeHI) ||
           ((pDev->Dac.PanelOffTimestampHI == timeHI) &&
            (pDev->Dac.PanelOffTimestampLO > timeLO)) )
        {
            // Delay the difference of the times.  Unsigned math shouldn't matter.
            // Somehow this is sending delays over 500 ms. Since in 
            // MobileDisplayEnd we set the delay to 500, this is wrong.
            // So, now, I should just delay if it's under 500 ms.
            if((pDev->Dac.PanelOffTimestampLO - timeLO) < 500000000)
              tmrDelay(pDev, (pDev->Dac.PanelOffTimestampLO - timeLO));
        }
    }

    // 
    // If the FP is involved, unconditionally turn off the backlight
    // (with more work, we probably could make this test smarter).
    //
    if ((OldDevices & TOSHIBA_FP) && (NewDevices & TOSHIBA_FP) && !(pDev->Power.Flags & DAC_POWER_PENDING))
    {
        dacBacklightOffMobilePanel(pDev);

        // 40ms delay between power and bl enable
        // I don't understand it, but it fixes bug 31339.
        // Before removing this, make sure to test 31339.
        // Well now, I'm upping the ante. We're setting this to 100 ms to fix
        // bug 31847.  So before removing this, check bug 31847 as well.
        // Now I'm making it 120 ms to fix 32383.  110 doesn't work.
        tmrDelay(pDev, 120000000);
    }

        //This is Toshiba bios specific code
    if (pDev->Power.MobileOperation == 2)
    {
        //
        // Generate a DeviceControlBegin message to the video BIOS
        // so the system knows we're about to change displays
        //
        EAX = 0x4F14;
        EBX = 0x028F;
        ECX = 0;
    
        //To know the arg order for DX, we have to check a scratch bit that tells
        // us whether this SBIOS got it right or wrong...
        lock = UnlockCRTC(pDev, 0);
        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, crtcdata, 0);
        RestoreLock(pDev, 0, lock);
    
        if (crtcdata & NV_CORRECT_ARG_ORDER) {
            EDX = (NewDevices << 8) | OldDevices;
        } else {
            EDX = (OldDevices << 8) | NewDevices;
        }
    
        status = osCallVideoBIOS(pDev, &EAX, &EBX, &ECX, &EDX, NULL);
    
        // Toshiba turns off the panel if it's not used.
        if(!(NewDevices & TOSHIBA_FP))
            pDev->Dac.DevicesEnabled &= ~(DAC_PANEL_ENABLED);
    
        if (status)
            return status;
    }
#endif

    return RM_OK;
}

RM_STATUS dacMobileDisplayNotifyEnd
(
    PHWINFO pDev,
    U032    OldDevices,
    U032    NewDevices
)
{
#if !defined(MACOS)
    U032    i;
    U032    EAX, EBX, ECX, EDX;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    RM_STATUS status;
#endif

// until osCallVideoBIOS() is added to the other os's
#if !defined(MACOS)
    //
    // If we're not running mobile, don't do this
    //
    // NOTE: We can probably stop limiting this to just Toshiba
    //
    if (!pDev->Power.MobileOperation)
        return RM_OK;


    //Removed for non-Toshiba mobiles since backlight manufacture script implementation
    //    if (pDev->Power.MobileOperation != 2)
    //            return RM_OK;

    // If we aren't switching any devices, just ignore this notification
    //
//    if (OldDevices == NewDevices)
//        return RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: dacMobileDisplayNotifyEnd\n");

    if (pDev->Power.MobileOperation == 2)
    {
        //
        // Track what has been set as the active devices
        // Since this routine can exit early from about 50,000,000,000 different places, I've
        // moved this code to the begining rather than the end, since it should always be executed.
        //
        // For now just set current display type to DISPLAY_TYPE_NONE to effectively disable the 
        // code in dacMobileDisplayNotifyBegin because executing it seems to cause other problems
        // even though it shouldn't.  Need to get Toshiba's help in debugging what's going on in the
        // sbios black box.  I suspect there is a bug in there somewhere.
        //
//        if (pDev->Dac.CrtcInfo[0].pVidLutCurDac)
//            pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType = ((PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[0].pVidLutCurDac)->DisplayType;
//        else
            pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType = DISPLAY_TYPE_NONE;
//        if (pDev->Dac.CrtcInfo[1].pVidLutCurDac)
//            pDev->Dac.HalInfo.CrtcInfo[1].CurrentDisplayType = ((PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[1].pVidLutCurDac)->DisplayType;
//        else
            pDev->Dac.HalInfo.CrtcInfo[1].CurrentDisplayType = DISPLAY_TYPE_NONE;
        //
        // Generate a DeviceControlEnd message to the video BIOS
        // so the system knows we're done changing displays
        //
        EAX = 0x4F14;
        EBX = 0x038F;
        ECX = 0;
        EDX = NewDevices;
        status = osCallVideoBIOS(pDev, &EAX, &EBX, &ECX, &EDX, NULL);
    
        if (status)
            return status;
    }
    else
    {
        //
        // Track what has been set as the active devices
        // Since this routine can exit early from about 50,000,000,000 different places, I've
        // moved this code to the begining rather than the end, since it should always be executed.
        //
        // For non-Toshiba, this still needs to be tracked.
        // And hopefully we can actually do the right thing on non-toshiba and actually track the
        // devices correctly (unlike on Toshiba for some reason).
        //
        if (pDev->Dac.CrtcInfo[0].pVidLutCurDac)
            pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType = ((PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[0].pVidLutCurDac)->DisplayType;
        else
            pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType = DISPLAY_TYPE_NONE;
        if (pDev->Dac.CrtcInfo[1].pVidLutCurDac)
            pDev->Dac.HalInfo.CrtcInfo[1].CurrentDisplayType = ((PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[1].pVidLutCurDac)->DisplayType;
        else
            pDev->Dac.HalInfo.CrtcInfo[1].CurrentDisplayType = DISPLAY_TYPE_NONE;
    }

    // APS -- added for Bug 33993 -- if we are switching to LCD and the BackLights are not on then turn them on
    if (((OldDevices & TOSHIBA_FP) && (NewDevices & TOSHIBA_FP)) || ((NewDevices & TOSHIBA_FP) && (!(pDev->Dac.DevicesEnabled & DAC_PANEL_ENABLED))))
    {
        if(!(pDev->Power.Flags & DAC_POWER_PENDING))
        {
            // For Toshiba only delay a bit to make sure that last bios call has finished up.
            // don't need for non-toshiba, so don't penalize them.
            if (pDev->Power.MobileOperation == 2)
                tmrDelay(pDev, 1000000*75); // 75ms
            // Turn on the backlight
            dacBacklightOnMobilePanel(pDev);
            pDev->Dac.DevicesEnabled |= DAC_PANEL_ENABLED;
        }

        //
        // Note: in the case of a hotkey-based DFP+TV modeset, turning on the
        // backlight displays the DFP, but for some reason turns off the TV.
        //
        // I imagine we've confused Toshiba with our manipulations of the
        // backlight to clean up the modesets. To workaround this, we'll follow
        // up with dacEnableImage calls for any heads that have modes set.
        //
        for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
        {
            pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[i].pVidLutCurDac;
            if (pVidLutCurDac && (pVidLutCurDac->DisplayType != DISPLAY_TYPE_NONE))
                dacEnableImage(pDev, i);
        }
    }

    //We've done for all vendors except Toshiba
    if(pDev->Power.Flags & DAC_POWER_PENDING)
        return RM_OK;
    
    if (pDev->Power.MobileOperation == 2)
    {
        // Start the 500 ms smart delay for stalling from power on to power off
        // This fixes 32252 and 31237 - Going from Clone to Extended mode
        // we get called 3 times to change the mode.  This will slow those modechanges down.
        tmrGetCurrentTime(pDev, 
            &(pDev->Dac.PanelOffTimestampHI), &(pDev->Dac.PanelOffTimestampLO));
            
        // Go ahead and add the delay to the timestamp
        // Check for carry condition
        if((pDev->Dac.PanelOffTimestampLO + 500000000) < pDev->Dac.PanelOffTimestampLO)
        {
            pDev->Dac.PanelOffTimestampHI++;
        }
        pDev->Dac.PanelOffTimestampLO += 500000000;
    }
#endif

    return RM_OK;
}

// Disable slaving the CRTC to an external PCLK
// We must do this in such a way that the scanline counter doesn't stall (it can stall if unslaving during blanking)
VOID dacDisableCRTCSlave
(
    PHWINFO pDev, 
    U032    Head
)
{
        BOOL          bCrtcSlaved;
        volatile U032 retryCount, rasterPos0, rasterPos1, rasterPosBase;
        U008          data08, crHRS;
        // Set HRS to > HT, so we never get into blanking
        // This will prevent the counter from getting stalled
        CRTC_RD(NV_CIO_CR_HDT_INDEX, data08, Head);
        CRTC_RD(NV_CIO_CR_HRS_INDEX, crHRS, Head);
        CRTC_WR(NV_CIO_CR_HRS_INDEX, data08 + 6, Head);
        tmrDelay(pDev, 1000000);
        CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data08, Head);
        bCrtcSlaved = ((data08 & 0x80) != 0);
        data08 &= ~0x84;
        CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data08, Head);
        //
        // Work around a hardware bug that's present on all chips NV20 and earlier.
        // Should be fixed in NV17/NV25.
        //
        // Only do the workaround if the crtc was slaved when 
        //
        if (bCrtcSlaved)
        {
            //
            // After clearing CR28[7] make sure the raster position counter has not gotten stuck.
            // If it has, then re-enable CR28[7] to kick start the raster position counter and try
            // again.
            // It's not elegant but none of the suggested work arounds worked. Fortunately the problem
            // is intermittent enough that a stuck raster position counter should only have to be
            // kick started once.
            //

            U032 usec     = 2000000;
            U032 retryMax = 25;
            retryCount = 0;
            rasterPosBase = REG_RD32(NV_PCRTC_RASTER + CurDacAdr(Head));
            while (bCrtcSlaved && (retryCount < retryMax))
            {
                rasterPos0 = REG_RD32(NV_PCRTC_RASTER + CurDacAdr(Head));
                tmrDelay(pDev, usec);
                rasterPos1 = REG_RD32(NV_PCRTC_RASTER + CurDacAdr(Head));
                if (rasterPos0 == rasterPos1)
                {
                    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, (data08 | 0x80), Head);
                    tmrDelay(pDev, 1000000);
                    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data08, Head);
                    retryCount++;
                }
                else
                    bCrtcSlaved = FALSE;
            }
            if (bCrtcSlaved)
            {
                //
                // failed to kick start the raster position count.
                // unslave the crtc one last time and continue on.  Hopefully nothing bad is about to happen!
                //
                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data08, Head);
                DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: dacDisableCRTCSlave - Exceeded maximum retry count.  Hope nothing bad is about to happen!!\r\n");
            }
            else
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: dacDisableCRTCSlave-Unslaved,Retry count \r\n",retryCount);

            }
        }
        else
        {
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: dacDisableCRTCSlave, not slaved \r\n");

        }
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: dacDisableCRTCSlave,   rasterPosBase : ",rasterPosBase);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: dacDisableCRTCSlave,      rasterPos0 : ",rasterPos0);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: dacDisableCRTCSlave exit, rasterPos1 : ",rasterPos1);
        //
        // Restore the original value of CR_HRS.
        // During power management (monitor off) there isn't any modeset to restore this value,
        // so if it is not restored now, it will result in an incorrect tv display when the tv is
        // turned back on.
        // ***Hopefully restoring this after we've made sure that the raster counter did not get
        // ***stuck will not have any nasty side effects.
        //
        CRTC_WR(NV_CIO_CR_HRS_INDEX, crHRS, Head);
}

RM_STATUS ExtractLastModeset(PHWINFO pDev, U032 Head, PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pHalVidLutCurDac)
{
    U032 TemporaryValue;
    U032 TMVal,TNVal,TPVal;
    U032 TvA;
    U008 * pGeneric;
    U032 count;
    RM_STATUS OpStatus;
    U008 lock;
    
    lock=UnlockCRTC(pDev,Head);

    if(pHalVidLutCurDac)
    {    
        pGeneric=(U008 *)pHalVidLutCurDac;
        
        //clear the structure to all zero's
        for(count=0;count<sizeof(VIDEO_LUT_CURSOR_DAC_HAL_OBJECT);count++)
        {
            pGeneric[count]=(U008)0;
        }
        
        if(pHalVidLutCurDac)
        {
            pHalVidLutCurDac->Head=Head;
            
            pHalVidLutCurDac->Dac[0].TotalWidth = dacGetCRTC(pDev, Head, H_TOTAL);    
            pHalVidLutCurDac->Dac[0].VisibleImageWidth = dacGetCRTC(pDev, Head, H_DISPLAY_END);    
            pHalVidLutCurDac->Dac[0].HorizontalBlankStart = dacGetCRTC(pDev, Head, H_BLANK_START);    
            pHalVidLutCurDac->Dac[0].HorizontalBlankWidth = dacGetCRTC(pDev, Head, H_BLANK_END)-dacGetCRTC(pDev, Head, H_BLANK_START);    
            pHalVidLutCurDac->Dac[0].HorizontalSyncStart = dacGetCRTC(pDev, Head, H_RETRACE_START);    
            pHalVidLutCurDac->Dac[0].HorizontalSyncWidth = dacGetCRTC(pDev, Head, H_RETRACE_END)-dacGetCRTC(pDev, Head, H_RETRACE_START);    
            pHalVidLutCurDac->Dac[0].TotalHeight = dacGetCRTC(pDev, Head, V_TOTAL);    
            pHalVidLutCurDac->Dac[0].VisibleImageHeight = dacGetCRTC(pDev, Head, V_DISPLAY_END);    
            pHalVidLutCurDac->Dac[0].VerticalSyncStart = dacGetCRTC(pDev, Head, V_RETRACE_START);    
            pHalVidLutCurDac->Dac[0].VerticalSyncHeight = dacGetCRTC(pDev, Head, V_RETRACE_END)-dacGetCRTC(pDev, Head, V_RETRACE_START);    
            pHalVidLutCurDac->Dac[0].VerticalBlankStart = dacGetCRTC(pDev, Head, V_BLANK_START);    
            pHalVidLutCurDac->Dac[0].VerticalBlankHeight = dacGetCRTC(pDev, Head, V_BLANK_END)-dacGetCRTC(pDev, Head, V_BLANK_START); 
                    
            //Read raw pixel clock on NV11
            if (Head == 0) 
            {
                TemporaryValue = REG_RD32( NV_PRAMDAC_VPLL_COEFF );
                
                TMVal=DRF_VAL(_PRAMDAC,_VPLL_COEFF,_MDIV,TemporaryValue);
                TNVal=DRF_VAL(_PRAMDAC,_VPLL_COEFF,_NDIV,TemporaryValue);
                TPVal=DRF_VAL(_PRAMDAC,_VPLL_COEFF,_PDIV,TemporaryValue);
            }
            else
            {
                TemporaryValue = REG_RD32( NV_PRAMDAC_VPLL2_COEFF );
                    
                TMVal=DRF_VAL(_PRAMDAC,_VPLL2_COEFF,_MDIV,TemporaryValue);
                TNVal=DRF_VAL(_PRAMDAC,_VPLL2_COEFF,_NDIV,TemporaryValue);
                TPVal=DRF_VAL(_PRAMDAC,_VPLL2_COEFF,_PDIV,TemporaryValue);
            }
            
            pHalVidLutCurDac->Dac[0].PixelDepth=(U032)((TemporaryValue==1)?8:(TemporaryValue==2)?16:(TemporaryValue==3)?32:8);
            
            CRTC_RD(0x28,TvA,Head);
            TemporaryValue=((U032)TvA)&0x3;
            pHalVidLutCurDac->Dac[0].PixelClock=(14318180*(TNVal/TMVal))/(1<<TPVal); 
            
            //educated guess at the color format
            pHalVidLutCurDac->Dac[0].ColorFormat=(U032)((pHalVidLutCurDac->Dac[0].PixelDepth==16)?NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5:(pHalVidLutCurDac->Dac[0].PixelDepth==32)?NVFF6_SET_COLOR_FORMAT_LE_X24Y8:(pHalVidLutCurDac->Dac[0].PixelDepth==8)?NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8:0); 
            
            CRTC_RD(0x09,TvA,Head);
            pHalVidLutCurDac->Dac[0].Format.DoubleScanMode=(BIT(7)&((U032)TvA)?1:0);
            
            CRTC_RD(0x39,TvA,Head);
            pHalVidLutCurDac->Dac[0].Format.InterlacedMode=(((U032)TvA)==0xff?0:1);
            
            TvA=REG_RD08(NV_PRMVIO_MISC__READ);
            pHalVidLutCurDac->Dac[0].Format.HorizontalSyncPolarity=(BIT(6)&((U032)TvA)?1:0);
            pHalVidLutCurDac->Dac[0].Format.VerticalSyncPolarity=(BIT(7)&((U032)TvA)?1:0);
            
        }
        
        //this debug is always active on Mac, though I can disable it if it hurts anyone.
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Start HAL Dac Struct print out");
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: --------------------------------------------------------------------------");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Visible Image Width     : ",pHalVidLutCurDac->Dac[0].VisibleImageWidth);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Visible Image Height    : ",pHalVidLutCurDac->Dac[0].VisibleImageHeight);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Horizontal Blank Start  : ",pHalVidLutCurDac->Dac[0].HorizontalBlankStart);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Horizontal Blank Width  : ",pHalVidLutCurDac->Dac[0].HorizontalBlankWidth);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Horizontal Sync Start   : ",pHalVidLutCurDac->Dac[0].HorizontalSyncStart);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Horizontal Sync Width   : ",pHalVidLutCurDac->Dac[0].HorizontalSyncWidth);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Vertical Blank Start    : ",pHalVidLutCurDac->Dac[0].VerticalBlankStart);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Vertical Blank Height   : ",pHalVidLutCurDac->Dac[0].VerticalBlankHeight);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Vertical Sync Start     : ",pHalVidLutCurDac->Dac[0].VerticalSyncStart);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Vertical Sync Height    : ",pHalVidLutCurDac->Dac[0].VerticalSyncHeight);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Total Width             : ",pHalVidLutCurDac->Dac[0].TotalWidth);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Total Height            : ",pHalVidLutCurDac->Dac[0].TotalHeight);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Pixel Clock             : ",pHalVidLutCurDac->Dac[0].PixelClock);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Color Format            : ",pHalVidLutCurDac->Dac[0].ColorFormat);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Pixel Depth             : ",pHalVidLutCurDac->Dac[0].PixelDepth);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Double Scan Mode        : ",pHalVidLutCurDac->Dac[0].Format.DoubleScanMode);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Interlaced Mode         : ",pHalVidLutCurDac->Dac[0].Format.DoubleScanMode);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Horizontal Sync Polarity: ",pHalVidLutCurDac->Dac[0].Format.DoubleScanMode);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Vertical Sync Polarity  : ",pHalVidLutCurDac->Dac[0].Format.DoubleScanMode);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: --------------------------------------------------------------------------");
        
        OpStatus=RM_OK;
    }
    else
    {
        OpStatus=RM_ERROR;
    }
    
    RestoreLock(pDev,Head,lock);
    
    
    return OpStatus;
}

RM_STATUS initPVidLutCurDacStructs(PHWINFO pDev)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDacObj;
    U032 count;
    RM_STATUS OpStatus=RM_OK;
    
    PHALHWINFO pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    
    pHalHwInfo=&(pDev->halHwInfo);
    pDacHalInfo=(pHalHwInfo->pDacHalInfo);
    
    //all cards have head zero, so scan all heads avail.
    for(count=0;(count<pDev->Dac.HalInfo.NumCrtcs)&&(OpStatus==RM_OK);count++)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"NVRM: init vidlutcurdacs - counting");

        if(GETDISPLAYTYPE(pDev,count)!=DISPLAY_TYPE_NONE)
        {
            OpStatus = osAllocMem((VOID **) &pVidLutCurDacObj, sizeof(VIDEO_LUT_CURSOR_DAC_OBJECT));
            initRmPVidLutCurDacStructs(pDev, count, pVidLutCurDacObj);
            
            pDev->Dac.CrtcInfo[count].pVidLutCurDac=(VOID_PTR)pVidLutCurDacObj;
            
            //set the hal ptrs for this
            pDacHalInfo->CrtcInfo[count].pVidLutCurDac=&(pVidLutCurDacObj->HalObject);
            
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Good VidLutCur created on Head: ",count);
            
            /*
            //this routine assumes there can only be one flat panel on this device
            if(GETDISPLAYTYPE(pDev,count)==DISPLAY_TYPE_FLAT_PANEL)
            {
                //load in data from the registers to the pDev
                pDev->Dac.fpHActive=DAC_REG_RD32(NV_PRAMDAC_FP_HDISPLAY_END,count)+1;
                pDev->Dac.fpHDispEnd=DAC_REG_RD32(NV_PRAMDAC_FP_HDISPLAY_END,count);
                pDev->Dac.fpHValidEnd=DAC_REG_RD32(NV_PRAMDAC_FP_HVALID_END,count);
                pDev->Dac.fpHSyncStart=DAC_REG_RD32(NV_PRAMDAC_FP_HSYNC_START,count);
                pDev->Dac.fpHSyncEnd=DAC_REG_RD32(NV_PRAMDAC_FP_HSYNC_END,count);
                pDev->Dac.fpHValidStart=DAC_REG_RD32(NV_PRAMDAC_FP_HVALID_START,count);
                pDev->Dac.fpHTotal=DAC_REG_RD32(NV_PRAMDAC_FP_HTOTAL,count);
                pDev->Dac.fpVActive=DAC_REG_RD32(NV_PRAMDAC_FP_VDISPLAY_END,count)+1;
                pDev->Dac.fpVDispEnd=DAC_REG_RD32(NV_PRAMDAC_FP_VDISPLAY_END,count);
                pDev->Dac.fpVValidEnd=DAC_REG_RD32(NV_PRAMDAC_FP_VVALID_END,count);
                pDev->Dac.fpVSyncStart=DAC_REG_RD32(NV_PRAMDAC_FP_VSYNC_START,count);
                pDev->Dac.fpVSyncEnd=DAC_REG_RD32(NV_PRAMDAC_FP_VSYNC_END,count);
                pDev->Dac.fpVValidStart=DAC_REG_RD32(NV_PRAMDAC_FP_VVALID_START,count);
                pDev->Dac.fpVTotal=DAC_REG_RD32(NV_PRAMDAC_FP_VTOTAL,count);
            }
            */
        }
        else
        {
            //NULL everything to be consistent with docs in class7c
            //kill it off now while we have the chance!!!
            pDev->Dac.CrtcInfo[count].pVidLutCurDac=NULL;
            
            //set the hal ptrs for this
            pDacHalInfo->CrtcInfo[count].pVidLutCurDac=NULL;
            
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: No display on Head: ",count);
        }
    }
    
    if(OpStatus!=RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"NVRM: Error Detected: Cleaning up.\n");
        
        for(count=0;count < pDev->Dac.HalInfo.NumCrtcs; count++)
        {
            if(pDev->Dac.CrtcInfo[count].pVidLutCurDac)
            {
                //null the hal pointer
                pDacHalInfo->CrtcInfo[count].pVidLutCurDac=NULL;
                
                //free the memory
                osFreeMem((void *)pDev->Dac.CrtcInfo[count].pVidLutCurDac);
                
                //null the second pointer
                pDev->Dac.CrtcInfo[count].pVidLutCurDac=NULL;
            }
        }
    }
            
    return OpStatus;
}

RM_STATUS initRmPVidLutCurDacStructs(PHWINFO pDev, U032 Head, PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac)
{
    RM_STATUS OpStatus=RM_ERROR;  //we might be just passin' thru if we have a NULL pointer
    U032 Height,Width,PixelClock;
    U008 lock;
    
    lock=UnlockCRTC(pDev,Head);
    
    if(pVidLutCurDac)
    {
        OpStatus=RM_OK;
    
        //blank the structure
        osMemSet((void*)pVidLutCurDac,0,sizeof(VIDEO_LUT_CURSOR_DAC_OBJECT));
        
        //setup the Hal object
        ExtractLastModeset(pDev, Head, &(pVidLutCurDac->HalObject));
        
        //code stolen from dacGetDisplayType() (its statically declared)
        //get something
        pVidLutCurDac->DisplayType=GETDISPLAYTYPE(pDev,Head);
        
        //TV guys, feel free to elaborate here if you need the current function
        pVidLutCurDac->TVStandard=0;                                 // variations of NTSC and PAL
        
        //calculate RefreshRate (Pixel clock/)
        Height=pVidLutCurDac->HalObject.Dac[0].TotalHeight;
        Width=pVidLutCurDac->HalObject.Dac[0].TotalWidth;
        PixelClock=pVidLutCurDac->HalObject.Dac[0].PixelClock;
        
        pVidLutCurDac->RefreshRate=PixelClock/(Height*Width);
        
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Display Type        : ",pVidLutCurDac->DisplayType);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Display Pixel Clock : ",pVidLutCurDac->RefreshRate);
    }
    
    RestoreLock(pDev,Head, lock);
   
    return OpStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\dacfp.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* DAC Flat panel Control ********************\
*                                                                           *
* Module: DACFP.C                                                           *
*   Mode set for flat panel is done here.                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <dac.h>
#include <os.h>
#include <nvcm.h>
#include <edid.h>
#include <devinit.h>
#include "nvhw.h"


#if defined(NTRM) && !defined(WriteIndexed)
// For NT these are in modehw.h which is in the miniport.
VOID WriteIndexed(U032 addr, U016 datum);
U016 ReadIndexed(U032 addr, U008 reg);
#endif //NTRM

// Const strings for accessing the registry
extern char strFpMode[];

//*************************** Exported functions *****************************************

// turning on the clocks requires a delay that is easily forgotten,
//   so try to do it all in one place
RM_STATUS dacWriteLinkPLL(
    PHWINFO pDev,
    U032    Head,
    U032    which)
{
    DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, which, Head);     // FP on to access TMDS
    tmrDelay(pDev, 0x400000);
    
    return RM_OK;
}


RM_STATUS dacAdjustCRTCForFlatPanel
(
    PHWINFO pDev, 
    U032 Head,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac
)
{
    U032    Ht, Hre, Vt, Vrs, Vre, Vbs, data32;
    U016    Seq, Vendor;
    U008    lock, Cr03, Cr04, Cr05, Cr07, Cr09, Cr11, Cr25, Cr28, Cr2d, Cr33;
#if 0
    U032 cntl32;
#endif

    dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE);   // power on flat panel

#if 0 // If TMDS not powered up, it will hang
    //
    // First, check if the internal TMDS exists, by trying to read/write
    // the TMDS_CONTROL register. If it exists, only power up the internal
    // TMDS, if we're not using an external one.
    //
    cntl32 = DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | NV_PRAMDAC_INDIR_TMDS_PLL1;
    REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, cntl32);
    if (REG_RD32(NV_PRAMDAC_FP_TMDS_CONTROL) == cntl32)
    {
        // The internal TMDS exists, see if we're using the external TMDS
        if (REG_RD_DRF(_PRAMDAC, _FP_TEST_CONTROL, _TMDS) == NV_PRAMDAC_FP_TEST_CONTROL_TMDS_EXTERNAL)
        {
            dacWriteLinkPLL(pDev, 0, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_TMDS);
        }
    }
#endif
    // Toshiba SBIOS behaves badly: it may lock ext CRTC's on us during SMI.
    lock = UnlockCRTC(pDev, 0);
    if (lock != NV_CIO_SR_UNLOCK_RW_VALUE) 
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ext CRTC's are locked in dacAdjustCRTCForTV\r\n");
    }
    
    // check for pixel doubled modes
    if ((GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_MONITOR) &&
        (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth < 640))
    {
        Seq = ReadIndexed(NV_PRMVIO_SRX, 1);
        Seq |= 0x800;   // divide pixel clock to double size
        WriteIndexed(NV_PRMVIO_SRX, Seq);
    }        
    // Make sure attr is set correctly
    Cr07 = REG_RD08(NV_PRMCIO_INP0__COLOR); // read 3DA to toggle (data = don't care)
    REG_WR08(NV_PRMCIO_ARX, 0x30);          // select reg 0x10, bit 5 set to access reg (not palette)
    REG_WR08(NV_PRMCIO_ARX, 0x01);          // clear bit 5

    // New rules
    // VRS = VT - 3
    // VRE = VT - 2
    // HRS = HT - 3
    // HRE = HT - 2
    // HBE = HT + 4  This is required for the overlay to sync (videos will be offset).
    CRTC_RD(NV_CIO_CRE_HEB__INDEX, Cr2d, Head);
    CRTC_RD(NV_CIO_CR_HDT_INDEX, Ht, Head);
    if (Cr2d & BIT(0))
        Ht |= BIT(8);
    Cr04 = (U008)Ht - 3; // everyone else except SGI
    // SGI is "special". We have to check for their panel and adjust HRS.
    if (pDev->Dac.CrtcInfo[Head].EDID != 0)
    {
    // EDID Version 1 version field should never be 1 on a version 2 (it's an ascii field in V2).
        if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VERSION_NUMBER_INDEX] == 1)
        {
            Vendor = (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VENDOR_ID_INDEX+1])<<8 | pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VENDOR_ID_INDEX];
            if (Vendor == 0xf84c)  //SGI
            {
                Cr04 = (U008)Ht; // All modes
                if ( ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 640) &&
                      (pDev->Framebuffer.HalInfo.VertDisplayWidth  == 480))
                     ||
                     ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 800) &&
                      (pDev->Framebuffer.HalInfo.VertDisplayWidth  == 600))
                   )
                {   
                    Cr04 = (U008)Ht+1;
                }
            }                              
        }
    }
    CRTC_WR(NV_CIO_CR_HRS_INDEX, Cr04, Head);        // HRS
    if (Ht & BIT(8))
        Cr2d |= 8;
    CRTC_WR(NV_CIO_CRE_HEB__INDEX, Cr2d, Head);   // HRS msb
    
    CRTC_RD(NV_CIO_CR_HRE_INDEX, Hre, Head);    // read CR05 and mask 4:0
    Hre &= 0xe0;
    CRTC_WR(NV_CIO_CR_HRE_INDEX, (Ht-2) | Hre, Head);   // HRE = Ht - 2, CR04[4:0]
    
    CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
    CRTC_RD(NV_CIO_CR_HBE_INDEX, Cr03, Head);
    // HBE = HT + 4. HBE[6] = CR25[4], HBE[5] = CR5[7], HBE[4:0] = CR3[4:0]
    Cr03 &= 0xE0;   // lose 4:0, the HBE bits
    Cr03 |= (Ht + 4) & 0x1f;
    CRTC_WR(NV_CIO_CR_HBE_INDEX, Cr03, Head);     // HBE[4:0]
    CRTC_RD(NV_CIO_CR_HRE_INDEX, Cr05, Head);
    Cr05 &= 0x7f;
    if ((Ht + 4) & BIT(5))
        Cr05 |= BIT(7);
    CRTC_WR(NV_CIO_CR_HRE_INDEX, Cr05, Head);     // HBE[5]
    Cr25 &= 0xEF;
    if ((Ht + 4) & BIT(6))
        Cr25 |= BIT(4);
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, Cr25, Head);    // HBE[6]

    // gather VT bits
    CRTC_RD(NV_CIO_CR_VDT_INDEX, Vt, Head);
    if (Cr07 & BIT(0))  // bit 8 of VT
        Vt |= BIT(8);
    if (Cr07 & BIT(5))  // bit 9 of VT
        Vt |= BIT(9);
    if (Cr25 & BIT(0))  // bit 10 of VT
        Vt |= BIT(10);

    // VRS: CR10,7,25
    Vrs = Vt - 3;
    CRTC_WR(NV_CIO_CR_VRS_INDEX, Vrs, Head);
    Cr07 &= ~(BIT(7) | BIT(2)); // clear bits 7 and 2
    if (Vrs & BIT(8)) Cr07 |= BIT(2);
    if (Vrs & BIT(9)) Cr07 |= BIT(7);
    CRTC_WR(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    if (Vrs & BIT(10)) Cr25 |= BIT(2);
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
    
    // VRE: CR11[3:0]
    Vre = (Vt - 2) & 0x0f;
    CRTC_RD(NV_CIO_CR_VRE_INDEX, Cr11, Head);
    Vre |= (Cr11 & 0xf0);
    CRTC_WR(NV_CIO_CR_VRE_INDEX, Vre, Head);
    
    // VBS = VRS
    CRTC_RD(NV_CIO_CR_CELL_HT_INDEX, Cr09, Head);
    Vbs = Vrs;
                
    // write VBS            
    Cr07 &= ~BIT(3); // clear bit 3
    if (Vbs & BIT(8)) Cr07 |= BIT(3);
    Cr09 &= ~BIT(5); // clear bit 5
    if (Vbs & BIT(9)) Cr09 |= BIT(5);
    Cr25 &= ~BIT(3); // clear bit 3
    if (Vbs & BIT(10)) Cr25 |= BIT(3);
    CRTC_WR(NV_CIO_CR_VBS_INDEX, Vbs, Head);
    CRTC_WR(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, Cr09, Head);
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
            
    data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head);    // usual macro won't help us here
    data32 &= ~(NV_PRAMDAC_FP_DEBUG_0_TEST_BOTH << 16);    // clear VCNTR bits
    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32, Head);

    // Also, ensure there's enough bandwidth for video.
    // 
    // With big panels in a scaled low res mode (e.g. 16x12 FP in 8x6), the
    // CRTC slaved off the FP can stall for 1/2 the time, which seems to cause
    // video underflow. To fix this, we lengthen HTOTAL to allow more clocks
    // (see bugid 20010130-110932).
    //
    if (pDev->Power.MobileOperation)
    {
        U032 Hrs, fpHSync, fpHTotal;
 
        // read the horizontal extra bits
        CRTC_RD(NV_CIO_CRE_HEB__INDEX, Cr2d, Head);

        // get the CRTC hsync start
        CRTC_RD(NV_CIO_CR_HRS_INDEX, Hrs, Head);
        if (Cr2d & BIT(3))
            Hrs |= BIT(8);    // add bit8

        // get the FP hsync values
        fpHTotal = DAC_REG_RD32(NV_PRAMDAC_FP_HTOTAL, Head);
        fpHSync = DAC_REG_RD32(NV_PRAMDAC_FP_HCRTC, Head);

        // set the CRTC HTOTAL closer to the FP horiz timings (take off 8
        // chars for the delay between FP_HCRTC and when the CRTC sees it).
        Ht  = (fpHTotal - fpHSync) / 8 + Hrs - 6;
        Ht -= 8;

        // set CR0 and the bit8 overflow, if necessary
        CRTC_WR(NV_CIO_CR_HDT_INDEX, Ht, Head);
        if (Ht & BIT(8))
        {
            Cr2d |= BIT(0);
            CRTC_WR(NV_CIO_CRE_HEB__INDEX, Cr2d, Head);
        }
    }

    // Toshiba SBIOS behaves badly: it may lock ext CRTC's on us during SMI.
    lock = UnlockCRTC(pDev, 0);
    if (lock != NV_CIO_SR_UNLOCK_RW_VALUE) 
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ext CRTC's are locked in dacAdjustCRTCForTV\r\n");
    }
    // Slave the CRTC to timing generator
    // Setup the crtc to work in slave mode (cr28).
    //
    CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head);
    Cr28 |= BIT(7);
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head); 
    CRTC_RD(0x33, Cr33, Head);   // NV_CIO_CRE_LCD__INDEX
    Cr33 |= BIT(0);     // bit 0 is HW
    Cr33 |= BIT(1);     // bit 1 is BIOS flag
    CRTC_WR(0x33, Cr33, Head);   //NV_CIO_CRE_LCD__INDEX
                          
    return RM_OK;
}

VOID dacTMDSWrite
(
    PHWINFO pDev,
    U032    Head,
    U008    Addr,
    U008    Data
)
{
    // Due to a bug in NV15, the procedure is more complicated than intended:
    // Write the index of the register with WRITE DISABLE set.
    // Write the data.
    // Write the index with WRITE DISABLED cleared.
    // Write the index with WRITE DISABLED set.
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | Addr, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_DATA, Data, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _ENABLE) | Addr, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | Addr, Head);
}


U008 dacTMDSRead
(
    PHWINFO pDev,
    U032    Head,
    U008    Addr
)
{
    U008 Data;

    // Write the index of the register with WRITE DISABLE set.
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | Addr, Head);
    // Read the data.
    Data = (U008) ( DAC_REG_RD32(NV_PRAMDAC_FP_TMDS_DATA, Head) & 0xFF );
    return Data;
}


RM_STATUS dacSetFlatPanelScaling
(
    PHWINFO pDev,
    U032    Head,
    U032    FpMode,
    BOOL    CommitChange
)
{
    RM_STATUS rmStatus = RM_OK;
    
    //store the fpMode, regardless
    pDev->Dac.HalInfo.CrtcInfo[Head].fpMode = FpMode;
    
    switch (FpMode)
    {
        case NV_CFGEX_GET_FLATPANEL_INFO_SCALED:
        case NV_CFGEX_GET_FLATPANEL_INFO_CENTERED:
        case NV_CFGEX_GET_FLATPANEL_INFO_NATIVE:
        {
            //
            // TEMPORARY WORKAROUND
            // 
            // The current control panel will lose track of what head it is really talking
            // to, so let's make sure this is the flat panel head.
            //
            if (pDev->Power.MobileOperation)
            {
                // Just hit them both in mobile as there is only one dfp
                DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _MODE, FpMode, 0);
                DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _MODE, FpMode, 1);
            }
            else
            {
                //
                // Change the DFP scaling mode.  For multisync panels, turn of fpclk
                // then delay after the change is being made, in order to ensure the correct
                // setup conditions.  Some multisync panels lose their sync otherwise.
                //

                    if (pDev->Dac.fpNative)
                {
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _BOTH, Head);
                    DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _MODE, FpMode, Head);
                    osDelay(10);
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);
                }
                else
                {
                    DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _MODE, FpMode, Head);
                }    

                //
                // WORKAROUND CONTROL PANEL BUG   (REMOVE REMOVE REMOVE when possible)
                //
                // The current control panel still asks us to set the wrong head.  We need
                // to fix the panel code, but until then, hit both heads.  This code needs 
                // to be removed when the real fix is made, as it will affect operation
                // of dual DVI systems
                //
                DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _MODE, FpMode, Head ^ 1);
            }
            break;
        }

        case NV_CFGEX_GET_FLATPANEL_INFO_SCALED_8BIT:
        {
            // only implemented on headB
            if ( ! IsNV11(pDev))
                goto failed;
            // require B1 or later
            if ( ! (pDev->halHwInfo.pMcHalInfo->MaskRevision >= MC_MASK_REVISION_B1))
                goto failed;
            if (Head != 1)
                goto failed;
            if (GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_FLAT_PANEL)
                goto failed;

            // turn on scaling mode
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _SCALE, Head);

            // disable dithering
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COMPAT, _6B_DITHER, _OFF, Head);
            
            // finally, turn on the scaling
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _YINTERP, _TRUNCATE, Head);
            break;
        }

        case NV_CFGEX_GET_FLATPANEL_INFO_CENTERED_DITHER:
        {
            U032 mode;
            
            // this only supported on NV11 B1 or better.
            if ( ! IsNV11(pDev))
                goto failed;
            // require B1 or later
            if ( ! (pDev->halHwInfo.pMcHalInfo->MaskRevision >= MC_MASK_REVISION_B1))
                goto failed;
            if (Head != 1)
                goto failed;
            if (GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_FLAT_PANEL)
                goto failed;

            mode = DAC_REG_RD_DRF(_PRAMDAC, _FP_TG_CONTROL, _MODE, Head);
            if ((mode != NV_CFGEX_GET_FLATPANEL_INFO_CENTERED) && 
                (mode != NV_CFGEX_GET_FLATPANEL_INFO_NATIVE))
                goto failed;
                
            // turn on centered mode
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _CENTER, Head);
            
            //reset temporal dithering safety counter
            pDev->Dac.CrtcInfo[Head].VBlankTemporalDitherSafetyCounter=0;
            
            // dithering will be enabled in VBlankUpdateDither()

            break;
        }

        case NV_CFGEX_GET_FLATPANEL_INFO_SCALED_ASPECT_CORRECT:
        {
            U032 scaleX, scaleY;
            U032 scaleX1000, scaleY1000;
            U032 visible, unused;
            PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
            
            // this only supported on NV11 and newer (not NV15)
            if ( ! IsNV11orBetter(pDev))
                goto failed;
            if (GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_FLAT_PANEL)
                goto failed;

            pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
            if ( ! pVidLutCurDac)
                goto failed;
                
            // turn on scaling mode
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _SCALE, Head);

            // disable dithering
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COMPAT, _6B_DITHER, _OFF, Head);

            // disable y truncate mode
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _YINTERP, _BILINEAR, Head);

            // now do the work...
            scaleX = DAC_REG_RD_DRF(_PRAMDAC, _FP_DEBUG_3, _XSTEPSIZE, Head);
            scaleY = DAC_REG_RD_DRF(_PRAMDAC, _FP_DEBUG_3, _YSTEPSIZE, Head);
                
            if (scaleY > scaleX)
            {
                // lock the scaling as a forced value
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_1, _XSCALE_TESTMODE, _ENABLE, Head);
                // just use 12 bits of scale
                scaleY &= 0xFFF;
                DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_DEBUG_1, _XSCALE_VALUE, scaleY, Head);
                
                // now center it in X by setting HVALID start & end
                scaleX1000 = (pDev->Dac.HalInfo.fpVMax * 1000) / pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
                visible = (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth * scaleX1000) / 1000;
                unused = pDev->Dac.HalInfo.fpHMax - visible;
                
                // stock away values in the pDev
                pDev->Dac.fpHValidStart=unused / 2;
                pDev->Dac.fpHValidEnd=visible + (unused / 2);
                
                //do the hardware set
                DAC_REG_WR32(NV_PRAMDAC_FP_HVALID_START, unused / 2, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HVALID_END, visible + (unused / 2), Head);
            }
            else
            {
                // lock the scaling as a force value
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_1, _YSCALE_TESTMODE, _ENABLE, Head);
                // just use 12 bits of scale
                scaleX &= 0xFFF;
                DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_DEBUG_1, _YSCALE_VALUE, scaleX, Head);
                
                // now center it in Y by setting VVALID start & end
                scaleY1000 = (pDev->Dac.HalInfo.fpHMax * 1000) / pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
                visible = (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight * scaleY1000) / 1000;
                unused = pDev->Dac.HalInfo.fpVMax - visible;
                
                //store these away in the pDev
                pDev->Dac.fpVValidStart=unused / 2;
                pDev->Dac.fpVValidEnd=visible + (unused / 2);
                
                //do the hardware set
                DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_START, unused / 2, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_END, visible + (unused / 2), Head);
            }

            break;
        }
        
        default:
             return RM_ERROR;
    }
        
    //
    // Do we want to save this setting?
    //
    if (CommitChange)
    {
        // write this mode to the registry
        // fill in the path to the registry key--last character is the display number
       rmStatus = osWriteRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strFpMode, FpMode);
    }

    return rmStatus;
 
failed:
    return RM_ERROR;
}


//Call dacSetFlatPanelScaling, and also commit the change to the system CMOS if
// the system supports that.  Can't be called while at a raised IRQL (e.g.,
// during modesets) because under NT we can't generate an int10h then.
RM_STATUS dacSetFlatPanelScalingCMOS
(
    PHWINFO pDev,
    U032    Head,
    U032    FpMode,
    BOOL    CommitChange
)
{

    RM_STATUS status;
    status = dacSetFlatPanelScaling(pDev, Head, FpMode, CommitChange);

#if !defined(MACOS)  
    if ((pDev->Power.MobileOperation) && (status == RM_OK)) {
        // Call through VGA BIOS to system BIOS to set center/scaling mode CMOS bit.
        // We do this here because under NT we can't make an int10h call during the modeset.
        // (while operating at a raised IRQ level).
//        RM_STATUS status;
        U032 eax, ebx, ecx, edx;
//        U032 FpMode = dacGetFlatPanelConfig(pDev, Head);

        eax = 0x4F14;       // VESA EDID function
//        ebx = (CommitChange?0x8000:0) | 0x0102;       // set center/scale mode
//        ecx = (FpMode == NV_CFGEX_GET_FLATPANEL_INFO_SCALED)?1:0;  // mode
        // XXX; may need to track other NV11 SCALED modes here...
        if (pDev->Power.MobileOperation == 2) {
            ebx = 0x8102;       // set center/scale mode
            ecx = (FpMode == NV_CFGEX_GET_FLATPANEL_INFO_SCALED)?1:0;  // mode
        } else {
            ebx = 0x0102;       // set center/scale mode
            ecx = (FpMode == NV_CFGEX_GET_FLATPANEL_INFO_SCALED)?0:1;  // mode
        }
        edx = 0;

        status = osCallVideoBIOS(pDev, &eax, &ebx, &ecx, &edx, NULL);
//        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: result from updating CMOS:", eax);
    }
#endif

    return status;
}


RM_STATUS dacSetFlatPanelMode
(
    PHWINFO pDev,
    U032    Head,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac,
    U032    FpMode,
    BOOL    commitChange
)
{
U032    data32, cntl32;
U008    est_tim1, est_tim2;
U032    fpHActive=0, fpHDispEnd=0, fpHValidStart=0, fpHValidEnd=0, fpHSyncStart=0, fpHSyncEnd=0, fpHTotal=0;
U032    fpVActive=0, fpVDispEnd=0, fpVValidStart=0, fpVValidEnd=0, fpVSyncStart=0, fpVSyncEnd=0, fpVTotal=0;
U032    fpPixClk, fpPolarity=0, M, N, P, pixels, refresh, dt_refresh;
BOOL    ModeValid, RefreshValid = FALSE;
U016    Vendor = 0x0;
U032    spreadEnabled;

    RM_STATUS rmStatus = RM_OK;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"In:dacSetFlatPanelMode\n");
    
    // check to make sure it's not null.  
    // This fixes bug 32021 "BSOD when switching between scaling/centering"
    if(pVidLutCurDac == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,
                         "NVRM: ERROR!!! dacSetFlatPanelMode() is called with pVidLutCurDac==NULL!\n");
        return RM_ERROR;
    }
    // check to make sure this is a DFP as well!
    // This fixes bug 32060: "LCD blooms when switching btw scaling/centering on LCD/TV extended"
    // There is a case on non-mobile platforms where Monitor is hooked up to Head 1
    // and the resman needs to setup as if it was a flat panel.
    if( (pVidLutCurDac->DisplayType != DISPLAY_TYPE_FLAT_PANEL) &&
        !( IsNV11(pDev) && (pVidLutCurDac->DisplayType == DISPLAY_TYPE_MONITOR) && 
            (Head==1) && !pDev->Power.MobileOperation) )
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,
                         "NVRM: ERROR!!! dacSetFlatPanelMode(): pVidLutCurDac != Flat Panel!\n");
        return RM_ERROR;
    }

    // Find requested refresh rate
    pixels = pVidLutCurDac->HalObject.Dac[0].TotalWidth * pVidLutCurDac->HalObject.Dac[0].TotalHeight;
    refresh = (pVidLutCurDac->HalObject.Dac[0].PixelClock*10000) / pixels;

    // if it didn't come out exactly, set to nearest choice
    // established timings are limited to 60, 70, 72, and 75
    if (refresh < 62)
        refresh = 60;
    else 
        if (refresh < 72)
            refresh = 70;
        else 
            if (refresh < 74)
                refresh = 72;
            else
                refresh = 75;


    // *********************************************************
    // Power On Flat Panel TMDS and FPCLK
    // Later in dacAdjustCRTCForFlatPanel() we will power
    // down the internal TMDS if we are using an external
    // one.  -paul
    // *********************************************************

    dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE);

    //stall now built into the action of turning the TMDS unit and FPCLK on
   

    // Set the scale factor in FP_DEBUG back to 0 in case the BIOS used this to get a special
    // mode, i.e. Japanese DOS. This is only done on NV10. 
    // In Windows modes, the scaling is always set by HW comparing the values in the FP timing
    // registers and the CRTC registers, so the DEBUG registers are always set to 0. 
    // For DOS 475 lines, this method doesn't work, because the scaling value is not in the HW 
    // tables on NV10, so the BIOS has to work around this by setting these DEBUG registers.
    
    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_1, 0, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_2, 0, Head);
#ifdef IKOS
    FpMode = NV_CFGEX_GET_FLATPANEL_INFO_NATIVE;
#endif
    // read strapping bit to set proper control width
    if (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_FP_IFACE) == NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_24BIT)
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _WIDTH, _24, Head);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _WIDTH, _12, Head);
    }

    {
        //Special case for for SGI flat panel.  
        if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VERSION_NUMBER_INDEX] == 1)
        {
            Vendor = (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VENDOR_ID_INDEX+1])<<8 | pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VENDOR_ID_INDEX];
            if (Vendor == 0xf84c)
            {

                if (pDev->Dac.fpNative)
                {
                     if ( 
                         pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 960
                         && FpMode ==  NV_CFGEX_GET_FLATPANEL_INFO_SCALED
                         && !IsNV11orBetter(pDev)
                         ) 
                     {
                         FpMode = NV_CFGEX_GET_FLATPANEL_INFO_NATIVE;
                     }
                }
                else
                {
                     if ( 
                         pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 960
                         && FpMode ==  NV_CFGEX_GET_FLATPANEL_INFO_SCALED
                         && !IsNV11orBetter(pDev)
                         ) 
                     {
                         FpMode = NV_CFGEX_GET_FLATPANEL_INFO_CENTERED;
                     }
                }
            }
        }
    }
    //
    // Set panel scaling mode
    //
    dacSetFlatPanelScaling(pDev, Head, FpMode, commitChange);

    // If we are going native, we must reprogram the dac with new timing
    // We saved the EDID in pDev->Dac.CrtcInfo[Head].EDID[].
    if ((FpMode == NV_CFGEX_GET_FLATPANEL_INFO_NATIVE) &&
        (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL))
    {
        // Check detailed timings first
        DACFPTIMING fpTim;
        U008 block;
        
        fpPixClk = 0;
        for (block=0; block<NUM_DET_TIM; block++)           
        {
            if (edidParseDetailedTimingBlock(pDev, block, &fpTim, Head))
            {
                // Check whether this timing block is for the mode requested
                //  or the doubled mode
                ModeValid = FALSE;
                switch  (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth)
                {
                    case 1600:
                        if (fpTim.HActive == 1600)
                        {
                            if ((fpTim.VActive == 1200) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 1200)) 
                                ModeValid = TRUE;
                            if ((fpTim.VActive == 1024) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 1024))
                                ModeValid = TRUE;
                        }
                        break;
                    case 1280:
                        if (fpTim.HActive == 1280) 
                        {
                            if ((fpTim.VActive == 1024) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 1024))
                                ModeValid = TRUE;
                            if ((fpTim.VActive == 960) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 960))
                                ModeValid = TRUE;
                        }
                        break;
                    case 1024:
                    case 512:
                        if (fpTim.HActive == 1024)
                            if (fpTim.VActive == 768)
                                ModeValid = TRUE;
                        break;
                    case 800:
                    case 400:
                        if (fpTim.HActive == 800)
                            if (fpTim.VActive == 600)
                                ModeValid = TRUE;
                        break;
                    case 640:
                        if (fpTim.HActive == 640) // can be 640x480 or 640x400
                        {
                            if ((fpTim.VActive == 480) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 480))
                                ModeValid = TRUE;
                            if ((fpTim.VActive == 400) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 400))
                                ModeValid = TRUE;
                        }
                        break;
                    case 320:
                        if (fpTim.HActive == 640) // can be 640x480 or 640x400
                        {
                            if ((fpTim.VActive == 480) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 240))
                                ModeValid = TRUE;
                            if ((fpTim.VActive == 400) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 200))
                                ModeValid = TRUE;
                        }
                        break;
                }
                if (ModeValid) // Use detailed timing
                {
                    fpPixClk = fpTim.PixClk;
                    fpHActive = fpTim.HActive;
                    fpHDispEnd = fpTim.HDispEnd;
                    fpHValidEnd = fpTim.HValidEnd;
                    fpHSyncStart = fpTim.HSyncStart;
                    fpHSyncEnd = fpTim.HSyncEnd;
                    fpHValidStart = fpTim.HValidStart;
                    fpHTotal = fpTim.HTotal - 1;
                    
                    fpVActive = fpTim.VActive;
                    fpVDispEnd = fpTim.VDispEnd;
                    fpVValidEnd = fpTim.VValidEnd;
                    fpVSyncStart = fpTim.VSyncStart;
                    fpVSyncEnd = fpTim.VSyncEnd;
                    fpVValidStart = fpTim.VValidStart;
                    fpVTotal = fpTim.VTotal - 1;
                    fpPolarity = (fpTim.Flags); // assume 4&3=1 (digital), then 2=vsync, 1=hsync
                
                    // Got a matching detailed timing, but is it the requested refresh rate?
                    // If not, we have a valid resolution we can use if we don't find right mode in established timing
                    pixels = fpHTotal * fpVTotal;
                    dt_refresh = (fpPixClk*10000) / pixels;
                    if (dt_refresh == refresh) 
                    {
                        RefreshValid = TRUE;
                    }
                }                       
            } // if parseDetailedTimings
        }
#if IKOS // no EDID
        RefreshValid = FALSE;
#endif
        if (!RefreshValid)  // not found in detailed, check established
        {
            est_tim1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_ESTABLISHED_TIMING_1_INDEX];
            est_tim2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_ESTABLISHED_TIMING_2_INDEX];
            fpPolarity = 0x3;   // estab timings use positive polarities on syncs

#if IKOS // give them whatever they ask for
            est_tim1 = 0xff;
            est_tim2 = 0xff;
#endif

            switch (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth)
            {
                case 320:
                case 640:   // 640x400 is not an established timing, but we can do 640x480 panel timing and send 640x400 data within this.
                    if ((pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight==480) 
                        || (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight==240)
                        || (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight==400)
                        || (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight==200))
                    {
                        if ((refresh == 72) && (est_tim1 & EDID_ESTABLISHED_TIMING_640x480_72))
                        {
                            fpHActive =  640;
                            fpHDispEnd = 639;
                            fpHValidStart = 0;
                            fpHValidEnd = 639;
                            fpHSyncStart = 663;
                            fpHSyncEnd =  663+40;
                            fpHTotal = 831;
                            fpVActive = 480;
                            fpVDispEnd = 479;
                            fpVValidStart = 0;
                            fpVValidEnd =  479;
                            fpVSyncStart = 487;
                            fpVSyncEnd = 487+3;
                            fpVTotal = 519;
                            fpPixClk = 3150;    // 31.5 MHz
                            fpPolarity = VSYNC_NEG | HSYNC_NEG;
                            RefreshValid = TRUE;
                        }
                        else if ((refresh == 75) && (est_tim1 & EDID_ESTABLISHED_TIMING_640x480_75))
                        {
                            fpHActive =  640;
                            fpHDispEnd = 639;
                            fpHValidStart = 0;
                            fpHValidEnd = 639;
                            fpHSyncStart = 655;
                            fpHSyncEnd =  719;
                            fpHTotal = 839;
                            fpVActive = 480;
                            fpVDispEnd = 479;
                            fpVValidStart = 0;
                            fpVValidEnd =  479;
                            fpVSyncStart = 480;
                            fpVSyncEnd = 483;
                            fpVTotal = 499;
                            fpPixClk = 3150;    // 31.5 MHz
                            fpPolarity = VSYNC_NEG | HSYNC_NEG;
                            RefreshValid = TRUE;
                        }
                        // if none of the above, use 60 Hz
                        else if (est_tim1 & EDID_ESTABLISHED_TIMING_640x480_ANY)
                        {
                            fpHActive =  640;
                            fpHDispEnd = 639;
                            fpHValidStart = 0;
                            fpHValidEnd = 639;
                            fpHSyncStart = 655;
                            fpHSyncEnd =  655+96;
                            fpHTotal = 799;
                            fpVActive = 480;
                            fpVDispEnd = 479;
                            fpVValidStart = 0;
                            fpVValidEnd =  479;
                            fpVSyncStart = 489;
                            fpVSyncEnd = 489+2;
                            fpVTotal = 524;
                            fpPixClk = 2517;    // 25.17 MHz
                            fpPolarity = VSYNC_NEG | HSYNC_NEG;
                            RefreshValid = TRUE;    // this may not be correct, but we don't check refresh rate in standard timing,
                        }                           // so there is no point in looking further
                    }
                    break;
                case 400:
                case 800:
                    if ((refresh == 72) && (est_tim2 & EDID_ESTABLISHED_TIMING_800x600_72))
                    {
                        fpHActive =  800;
                        fpHDispEnd = 799;
                        fpHValidStart = 0;
                        fpHValidEnd = 799;
                        fpHSyncStart = 855;
                        fpHSyncEnd =  855+120;
                        fpHTotal = 1040;
                        fpVActive = 600;
                        fpVDispEnd = 599;
                        fpVValidStart = 0;
                        fpVValidEnd =  599;
                        fpVSyncStart = 636;
                        fpVSyncEnd = 636+6;
                        fpVTotal = 666;
                        fpPixClk = 5000;    // 50 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                        RefreshValid = TRUE;
                    }
                    else if ((refresh == 75) && (est_tim2 & EDID_ESTABLISHED_TIMING_800x600_75))
                    {
                        fpHActive =  800;
                        fpHDispEnd = 799;
                        fpHValidStart = 0;
                        fpHValidEnd = 799;
                        fpHSyncStart = 815;
                        fpHSyncEnd =  815+80;
                        fpHTotal = 1055;
                        fpVActive = 600;
                        fpVDispEnd = 599;
                        fpVValidStart = 0;
                        fpVValidEnd =  599;
                        fpVSyncStart = 600;
                        fpVSyncEnd = 600+3;
                        fpVTotal = 624;
                        fpPixClk = 4950;    // 49.5 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                        RefreshValid = TRUE;
                    }
                    // if none of the above, use 60 Hz
                    else if ((est_tim1 & EDID_ESTABLISHED_TIMING_800x600_60) 
                        || (est_tim2 & EDID_ESTABLISHED_TIMING_800x600_ANY))
                    {
                        fpHActive =  800;
                        fpHDispEnd = 799;
                        fpHValidStart = 0;
                        fpHValidEnd = 799;
                        fpHSyncStart = 839;
                        fpHSyncEnd =  839+128;
                        fpHTotal = 1055;
                        fpVActive = 600;
                        fpVDispEnd = 599;
                        fpVValidStart = 0;
                        fpVValidEnd =  599;
                        fpVSyncStart = 600;
                        fpVSyncEnd = 600+4;
                        fpVTotal = 627;
                        fpPixClk = 4000;    // 40 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                        RefreshValid = TRUE; // this may not be correct, but we don't check refresh rate in standard timing
                    }
                    break;
                case 512:
                case 1024:
                    if ((refresh == 70) && (est_tim2 & EDID_ESTABLISHED_TIMING_1024x768_70))
                    {
                        fpHActive = 1024;
                        fpHDispEnd = 1023;
                        fpHValidStart = 0;
                        fpHValidEnd = 1023;
                        fpHSyncStart = 1047;
                        fpHSyncEnd = 1047+136;
                        fpHTotal = 1327;
                        fpVActive = 768;
                        fpVDispEnd = 767;
                        fpVValidStart = 0;
                        fpVValidEnd = 767;
                        fpVSyncStart = 770;
                        fpVSyncEnd = 770+6;
                        fpVTotal = 805;
                        fpPixClk = 7500;    // 75 MHz
                        fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        RefreshValid = TRUE;
                    }
                    else if ((refresh == 75) && (est_tim2 & EDID_ESTABLISHED_TIMING_1024x768_75))
                    {
                        fpHActive = 1024;
                        fpHDispEnd = 1023;
                        fpHValidStart = 0;
                        fpHValidEnd = 1023;
                        fpHSyncStart = 1039;
                        fpHSyncEnd = 1039+96;
                        fpHTotal = 1311;
                        fpVActive = 768;
                        fpVDispEnd = 767;
                        fpVValidStart = 0;
                        fpVValidEnd = 767;
                        fpVSyncStart = 769;
                        fpVSyncEnd = 769+3;
                        fpVTotal = 799;
                        fpPixClk = 7875;    // 78.75 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                        RefreshValid = TRUE;
                    }
                    else if (est_tim2 & EDID_ESTABLISHED_TIMING_1024x768_ANY)
                    {
                        fpHActive = 1024;
                        fpHDispEnd = 1023;
                        fpHValidStart = 0;
                        fpHValidEnd = 1023;
                        fpHSyncStart = 1047;
                        fpHSyncEnd = 1047+136;
                        fpHTotal = 1343;
                        fpVActive = 768;
                        fpVDispEnd = 767;
                        fpVValidStart = 0;
                        fpVValidEnd = 767;
                        fpVSyncStart = 770;
                        fpVSyncEnd = 770+6;
                        fpVTotal = 805;
                        fpPixClk = 6500;    // 65 MHz
                        fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        RefreshValid = TRUE; // this may not be correct, but we don't check refresh rate in standard timing
                    }
                    break;
                case 1280:
                    if ((refresh == 75) && (est_tim2 & EDID_ESTABLISHED_TIMING_1280x1024_75))
                    {
                        fpHActive = 1280;
                        fpHDispEnd = 1279;
                        fpHValidStart = 0;
                        fpHValidEnd = 1279;
                        fpHSyncStart = 1295;
                        fpHSyncEnd = 1295+144;
                        fpHTotal = 1687;
                        fpVActive = 1024;
                        fpVDispEnd = 1023;
                        fpVValidStart = 0;
                        fpVValidEnd = 1024;
                        fpVSyncStart = 1024;
                        fpVSyncEnd = 1024+3;
                        fpVTotal = 1065;
                        fpPixClk = 13500;   // 135 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                        RefreshValid = TRUE;
                    }
                    break;
                default:
                    break;
            } //switch
        } // if not PixClk

        if (!RefreshValid) // If not found in detailed or established, try standard timings
        {
            U008 stdTiming1, stdTiming2, i;
            U016 hRes, vRes;

            for (i=0; i<EDID_V1_NUM_STANDARD_TIMINGS; i++) 
            {
                // Translate coded value into H + V resolution
                stdTiming1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_STANDARD_TIMING_1_INDEX + i*2];
                stdTiming2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_STANDARD_TIMING_1_INDEX + i*2 +1];
                hRes = (stdTiming1 + 31) * 8;
                switch (stdTiming2>>6)
                {
                    case 0:
                        vRes = (hRes / 16) * 10;
                        break;
                    case 1:
                        vRes = (hRes / 4) * 3;
                        break;
                    case 2:
                        vRes = (hRes / 5) * 4;
                        break;
                    case 3:
                        vRes = (hRes / 16) * 9;
                        break;
                }
                // Standard timing could also specify any refresh rate from 60-123 Hz. This only handles 60 Hz.
                if (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth == hRes) 
                {
                    switch (hRes) 
                    {
                    case 640:
                        fpHActive =  640;
                        fpHDispEnd = 639;
                        fpHValidStart = 0;
                        fpHValidEnd = 639;
                        fpHSyncStart = 655;
                        fpHSyncEnd =  655+96;
                        fpHTotal = 799;
                        fpVActive = 480;
                        fpVDispEnd = 479;
                        fpVValidStart = 0;
                        fpVValidEnd =  479;
                        fpVSyncStart = 489;
                        fpVSyncEnd = 489+2;
                        fpVTotal = 524;
                        fpPixClk = 2517;    // 25.17 MHz
                        fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        break;
                    case 800:
                        fpHActive =  800;
                        fpHDispEnd = 799;
                        fpHValidStart = 0;
                        fpHValidEnd = 799;
                        fpHSyncStart = 839;
                        fpHSyncEnd =  839+128;
                        fpHTotal = 1055;
                        fpVActive = 600;
                        fpVDispEnd = 599;
                        fpVValidStart = 0;
                        fpVValidEnd =  599;
                        fpVSyncStart = 600;
                        fpVSyncEnd = 600+4;
                        fpVTotal = 627;
                        fpPixClk = 4000;    // 40 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                        break;
                    case 1024:
                        fpHActive = 1024;
                        fpHDispEnd = 1023;
                        fpHValidStart = 0;
                        fpHValidEnd = 1023;
                        fpHSyncStart = 1047;
                        fpHSyncEnd = 1047+136;
                        fpHTotal = 1343;
                        fpVActive = 768;
                        fpVDispEnd = 767;
                        fpVValidStart = 0;
                        fpVValidEnd = 767;
                        fpVSyncStart = 770;
                        fpVSyncEnd = 770+6;
                        fpVTotal = 805;
                        fpPixClk = 6500;    // 65 MHz
                        fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        break;
                    case 1280:
                        if (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 960) 
                        {   // GTF
                            fpHActive = 1280;
                            fpHDispEnd = 1279;
                            fpHValidStart = 0;
                            fpHValidEnd = 1279;
                            fpHSyncStart = 1279+80;
                            fpHSyncEnd = 1279+80+136;
                            fpHTotal = 1711;
                            fpVActive = 960;
                            fpVDispEnd = 959;
                            fpVValidStart = 0;
                            fpVValidEnd = 959;
                            fpVSyncStart = 960;
                            fpVSyncEnd = 963;
                            fpVTotal = 993;
                            fpPixClk = 10200;    // 102 MHz
                            fpPolarity = VSYNC_POS | HSYNC_POS;
                        }
                        if (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 1024) 
                        {   // DMT
                            fpHActive = 1280;
                            fpHDispEnd = 1279;
                            fpHValidStart = 0;
                            fpHValidEnd = 1279;
                            fpHSyncStart = 1327;
                            fpHSyncEnd = 1327+112;
                            fpHTotal = 1687;
                            fpVActive = 1024;
                            fpVDispEnd = 1023;
                            fpVValidStart = 0;
                            fpVValidEnd = 1023;
                            fpVSyncStart = 1024;
                            fpVSyncEnd = 1024+3;
                            fpVTotal = 1065;
                            fpPixClk = 10800;    // 108 MHz
                            fpPolarity = VSYNC_POS | HSYNC_POS;
                        }
                        break;
                    case 1600:
                        fpHActive = 1600;
                        fpHDispEnd = 1599;
                        fpHValidStart = 0;
                        fpHValidEnd = 1599;
                        fpHSyncStart = 1599+104;
                        fpHSyncEnd = 1599+104+176;
                        fpHTotal = 2159;
                        fpVActive = 1024;
                        fpVDispEnd = 1023;
                        fpVValidStart = 0;
                        fpVValidEnd = 1023;
                        fpVSyncStart = 1024;
                        fpVSyncEnd = 1024+3;
                        fpVTotal = 1060;
                        fpPixClk = 16000;    // 160 MHz
                        fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        break;
                    }
                }
                if (fpPixClk) // found? break for loop
                    break;
            } // for loop

        }
        if (!fpPixClk) // Did we find a detailed, established, or standard timings for the requested mode?
        {
            // No, did we find any valid timings in the EDID? Then fall back to adapter scaling.
            if (pDev->Dac.fpPixClk) 
            {
                // These values were gotten when we read the Edid. It should be the preferred mode.
                fpHActive = pDev->Dac.fpHActive;
                fpHDispEnd = pDev->Dac.fpHDispEnd;
                fpHValidStart = pDev->Dac.fpHValidStart;
                fpHValidEnd = pDev->Dac.fpHValidEnd;
                fpHSyncStart = pDev->Dac.fpHSyncStart;
                fpHSyncEnd = pDev->Dac.fpHSyncEnd;
                fpHTotal = pDev->Dac.fpHTotal - 1;
                fpVActive = pDev->Dac.fpVActive;
                fpVDispEnd = pDev->Dac.fpVDispEnd;
                fpVValidStart = pDev->Dac.fpVValidStart;
                fpVValidEnd = pDev->Dac.fpVValidEnd;
                fpVSyncStart = pDev->Dac.fpVSyncStart;
                fpVSyncEnd = pDev->Dac.fpVSyncEnd;
                fpVTotal = pDev->Dac.fpVTotal - 1;
                fpPixClk = pDev->Dac.fpPixClk;
                fpPolarity = (pDev->Dac.fpFlags); // assume 4&3=1 (digital), then 2=vsync, 1=hsync
                
                // Use scaling to get requested mode
                // NV10 & NV15 will not scale above 1024, so fall back to centered
                if ((IsNV10(pDev) || IsNV15(pDev)) && pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth > 1024) // line > 1024?
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _CENTER, Head);
                else
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _SCALE, Head);   // scaled mode
            }
            else
            {
                // No EDID info: set 640x480. We need valid timing, especially the clock, so we will generate interrupts
                // and notifiers which depend on vblank interrupt will get written.
                fpHActive =  640;
                fpHDispEnd = 639;
                fpHValidStart = 0;
                fpHValidEnd = 639;
                fpHSyncStart = 655;
                fpHSyncEnd =  655+96;
                fpHTotal = 799;
                fpVActive = 480;
                fpVDispEnd = 479;
                fpVValidStart = 0;
                fpVValidEnd =  479;
                fpVSyncStart = 489;
                fpVSyncEnd = 489+2;
                fpVTotal = 524;
                fpPixClk = 2517;    // 25.17 MHz
                fpPolarity = VSYNC_NEG | HSYNC_NEG;
                return RM_ERROR;
            }
        }
    }
    else if ((GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_MONITOR))
    {
        fpHActive = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
        fpVActive = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;

        // Use the FP scaler in the low resolution modes
        if (fpHActive <= 512 && fpVActive <= 384)
        {
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _SCALE, Head);
            // Use the line/clock doubled equivalent (or the nearest resolution)
            // I only have 60 Hz refresh rate.
            switch (fpHActive) 
            {
            case 320:
                fpHActive =  640;
                fpHDispEnd = 639;
                fpHValidStart = 0;
                fpHValidEnd = 639;
                fpHSyncStart = 655;
                fpHSyncEnd =  655+96;
                fpHTotal = 799;
                fpVActive = 480;    // We could add 400 line timing if 320x200 doesn't scale into 640x480 well
                fpVDispEnd = 479;
                fpVValidStart = 0;
                fpVValidEnd =  479;
                fpVSyncStart = 489;
                fpVSyncEnd = 489+2;
                fpVTotal = 524;
                fpPixClk = 2517;    // 25.17 MHz
                fpPolarity = VSYNC_NEG | HSYNC_NEG;
                break;
            case 400:
                fpHActive =  800;
                fpHDispEnd = 799;
                fpHValidStart = 0;
                fpHValidEnd = 799;
                fpHSyncStart = 839;
                fpHSyncEnd =  839+128;
                fpHTotal = 1055;
                fpVActive = 600;
                fpVDispEnd = 599;
                fpVValidStart = 0;
                fpVValidEnd =  599;
                fpVSyncStart = 600;
                fpVSyncEnd = 600+4;
                fpVTotal = 627;
                fpPixClk = 4000;    // 40 MHz
                fpPolarity = VSYNC_POS | HSYNC_POS;
                break;
            case 480:   // We could put 960x720 timing in here, but it should scale up into 512 (1024)
            case 512:
            default:    
                fpHActive = 1024;
                fpHDispEnd = 1023;
                fpHValidStart = 0;
                fpHValidEnd = 1023;
                fpHSyncStart = 1047;
                fpHSyncEnd = 1047+136;
                fpHTotal = 1343;
                fpVActive = 768;
                fpVDispEnd = 767;
                fpVValidStart = 0;
                fpVValidEnd = 767;
                fpVSyncStart = 770;
                fpVSyncEnd = 770+6;
                fpVTotal = 805;
                fpPixClk = 6500;    // 65 MHz
                fpPolarity = VSYNC_NEG | HSYNC_NEG;
                break;
            }
        }
        else
        {
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _NATIVE, Head);

            // These values are gotten from the LUT_CURSOR_DAC class
            fpHActive = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
            fpHDispEnd = fpHActive - 1;
            fpHValidStart = 0;
            fpHValidEnd = fpHDispEnd;
            fpHSyncStart = pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart - 1;
            fpHSyncEnd = fpHSyncStart + pVidLutCurDac->HalObject.Dac[0].HorizontalSyncWidth;
            fpHTotal = pVidLutCurDac->HalObject.Dac[0].TotalWidth - 1;

            fpVActive = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
            // check for scanline doubled modes
            if (pVidLutCurDac->HalObject.Dac[0].Format.DoubleScanMode)
                fpVActive *= 2;

            fpVDispEnd = fpVActive - 1;
            fpVValidStart = 0;
            fpVValidEnd = fpVDispEnd;
            fpVSyncStart = pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart - 1;
            fpVSyncEnd = fpVSyncStart + pVidLutCurDac->HalObject.Dac[0].VerticalSyncHeight;
            fpVTotal = pVidLutCurDac->HalObject.Dac[0].TotalHeight - 1;

            fpPixClk = pVidLutCurDac->HalObject.Dac[0].PixelClock;
            // make sure we're not exceeding our max pixclk for this head
            RM_ASSERT((fpPixClk * 10000) <= GETCRTCHALINFO(pDev, Head, PCLKLimit32bpp));

            fpPolarity = ((!pVidLutCurDac->HalObject.Dac[0].Format.VerticalSyncPolarity) << 2) | 
                         ((!pVidLutCurDac->HalObject.Dac[0].Format.HorizontalSyncPolarity) << 1);
        }
    }
    else    // FP not native mode, restore full resolution
    {
        // These values were gotten when we read the Edid.
        fpHActive = pDev->Dac.fpHActive;
        fpHDispEnd = pDev->Dac.fpHDispEnd;
        fpHValidStart = pDev->Dac.fpHValidStart;
        fpHValidEnd = pDev->Dac.fpHValidEnd;
        fpHSyncStart = pDev->Dac.fpHSyncStart;
        fpHSyncEnd = pDev->Dac.fpHSyncEnd;
        fpHTotal = pDev->Dac.fpHTotal - 1;
        fpVActive = pDev->Dac.fpVActive;
        fpVDispEnd = pDev->Dac.fpVDispEnd;
        fpVValidStart = pDev->Dac.fpVValidStart;
        fpVValidEnd = pDev->Dac.fpVValidEnd;
        fpVSyncStart = pDev->Dac.fpVSyncStart;
        fpVSyncEnd = pDev->Dac.fpVSyncEnd;
        fpVTotal = pDev->Dac.fpVTotal - 1;
        fpPixClk = pDev->Dac.fpPixClk;
        fpPolarity = (pDev->Dac.fpFlags); // assume 4&3=1 (digital), then 2=vsync, 1=hsync
        
        // NV10 & NV15 will not scale above 1024, so fall back to centered
        // except in the case of panels which have a max width of 1600, where we
        // can use scaling intended for other modes.
        if (IsNV10(pDev) || IsNV15(pDev)) 
        {
           if (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth > 1024      &&
               !((pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth == 1280 || pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth == 1600) && 
                 (pDev->Dac.HalInfo.fpHMax == 1600))
              )
           {
               DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _CENTER, Head);
           }
        }
    }

    // For mobile, see if dithering is needed on the flat panel
    if (pDev->Power.MobileOperation)
    {
        // If this is NV11 B1 or better, on Head 1
        if (IsNV11(pDev) &&
            (pDev->halHwInfo.pMcHalInfo->MaskRevision >= MC_MASK_REVISION_B1) &&
            (Head == 1))
        {
            // 
            // And, we're in a non-scaled (centered/native) FP mode or scaled,
            // but in the native resolution of the FP, and in 32bpp
            //
            if (((FpMode != NV_CFGEX_GET_FLATPANEL_INFO_SCALED) ||
                    ((fpHActive == pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth) &&
                     (fpVActive == pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight))) &&
                    (pVidLutCurDac->HalObject.Dac[0].PixelDepth == 32))
            {
                // enable dithering (kicked off in VBlankUpdateDither)
                pDev->Dac.HalInfo.CrtcInfo[Head].fpMode = NV_CFGEX_GET_FLATPANEL_INFO_CENTERED_DITHER;

                // reset temporal dithering safety counter
                pDev->Dac.CrtcInfo[Head].VBlankTemporalDitherSafetyCounter = 0;
            }
            else 
            {
                // disable dithering
                pDev->Dac.HalInfo.CrtcInfo[Head].fpMode = 0;
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COMPAT, _6B_DITHER, _OFF, Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COMPAT, _DITHER_RB, _NORMAL, Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COMPAT, _DITHER_G, _NORMAL,  Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COMPAT, _DITHER_Y, _NORMAL,  Head);
            }
        }
    }

    // Work-around for HW bug: can't set HT lsb's to 00 in 1280 mode.
    if (fpHActive == 1280)
        if (!(fpHTotal & 0x03))
            fpHTotal += 1;  // if x...x00, make it 01
    // We are switching modes, so program the DAC with new timings.
    // If switching between scaled and centered, this isn't necessary, but it won't hurt.
    if (fpPolarity & VSYNC_POS)
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _POS, Head);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _NEG, Head);
    }
    if (fpPolarity & HSYNC_POS)
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _POS, Head);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _NEG, Head);
    }
    // Pixel Clock
#ifdef NV11_PCLK_HACK
    if (fpHActive == 1024)
    {
        fpPixClk = 5000;    // lower pixclk on NV11 for demo. 
    }
#endif

    //
    // NV11 workaround for mobile panels when running low-res modes on hi-res panels.  
    // The panel scaler seems to be causing issues with the LVDS data.
    //
    // Drop the PCLK by 20MHz when running in these configurations.  Only deal with
    // 800 width modes and less on panels greater than 1400 native horizontal and
    // the scaler is enabled.
    //
    // Only happens on HSYNC mode panels (Toshiba does not use these!)
    if ( IsNV11(pDev) && pDev->Power.MobileOperation && (pDev->Power.MobileOperation != 2) )
    {
        if (FpMode == NV_CFGEX_GET_FLATPANEL_INFO_SCALED)
        {
            if ((pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth <= 800) && (fpHActive >= 1400))
            {
                fpPixClk -= 2000;  // drop it by 20MHz (10MHz per LVDS channel)

                // Turn on the flag that says we're dropping the PCLK
                pDev->Dac.DevicesEnabled |= (DAC_LOW_PCLK_ENABLED);
            }
            else
            {
                // Turn off the flag that says we're dropping the PCLK
                pDev->Dac.DevicesEnabled &= ~(DAC_LOW_PCLK_ENABLED);
            }
        }
    }

    spreadEnabled = REG_RD_DRF(_PRAMDAC, _SEL_CLK, _SPREAD_SPECTRUM_VPLL1) || REG_RD_DRF(_PRAMDAC, _SEL_CLK, _SPREAD_SPECTRUM_VPLL2);
    if (pDev->Power.MobileOperation && spreadEnabled)
    {
        //
        // Calculate taking spread into account, so cap M at 6
        //
        // This is currently only being done for mobile systems that use
        // spread spectrum of the fpclk.
        //
        dacCalcMNP_MaxM(pDev, Head, fpPixClk, &M, &N, &P, 6);
    }
    else if (IsNV11(pDev) && (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_MONITOR) && (Head == 1) && pDev->Dac.ExtDacMaxM)
    {
        //
        // Calculate taking external dac noise into account, so cap M at the new value (received from registry)
        //
        dacCalcMNP_MaxM(pDev, Head, fpPixClk, &M, &N, &P, pDev->Dac.ExtDacMaxM);
    }
    else
        dacCalcMNP(pDev, Head, fpPixClk, &M, &N, &P);


    // VPLL doesn't follow the pattern of addressing by adding a fixed offset. 
    // VPLL2 has an address in the same range (680xxx) as the
    // primary head. This makes the DAC_REG_WR32 macros useless.
    if (Head == 0) 
    {
        REG_WR32(NV_PRAMDAC_VPLL_COEFF, DRF_NUM(_PRAMDAC, _VPLL_COEFF, _MDIV, M) |
                                        DRF_NUM(_PRAMDAC, _VPLL_COEFF, _NDIV, N) |
                                        DRF_NUM(_PRAMDAC, _VPLL_COEFF, _PDIV, P));
    }
    else
    {
        // Tell DAC to use programmed M,N,P values, then give it M,N,P.
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _MSOURCE, _PROG); 
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V1SOURCE, _PROG); 
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _NVSOURCE, _PROG); 
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V2SOURCE, _PROG); 
        REG_WR32(NV_PRAMDAC_VPLL2_COEFF, DRF_NUM(_PRAMDAC, _VPLL_COEFF, _MDIV, M) |
                                        DRF_NUM(_PRAMDAC, _VPLL_COEFF, _NDIV, N) |
                                        DRF_NUM(_PRAMDAC, _VPLL_COEFF, _PDIV, P));
    }

    //
    // Set Link depending on which head we want to drive fp.
    //
    if (IsNV11(pDev))
    {
        // Some boards have only one link, and that should be connected to the second head
        if (Head == 0)
            FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK1, _SEL_FPCLK1);
        else
            FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK2, _SEL_FPCLK2);

        // Mobile is dual link LVDS, so both links are used
        if (pDev->Power.MobileOperation)
        {
            if (Head == 0)
            {
                // If using Head==0, both links use primary clock
                FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK1, _SEL_FPCLK1);
                FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK2, _SEL_FPCLK1);
            }
            else
            {
                // If using Head==1, both links use secondary clock
                FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK1, _SEL_FPCLK2);
                FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK2, _SEL_FPCLK2);
            }
        }
    }

    //
    // If an integrated TMDS exists (we can read/write TMDS_CONTROL),
    // set the PLL values there, as well.
    //
    // TMDS access is in the address range of the primary head. (680xxx)
    dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE);

    cntl32 = DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | NV_PRAMDAC_INDIR_TMDS_PLL1;
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, cntl32, Head);

    if (IsNV11(pDev) || DAC_REG_RD32(NV_PRAMDAC_FP_TMDS_CONTROL, Head) == cntl32) // IF TMDS present
    {
        U008 tmds_pll0, tmds_pll1, tmds_pll2;

        // make sure PLL is enabled, or we'll hang
        dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE); 

        if (IsNV15(pDev))
        {
            // TMDS settings

            // Run BIOS TMDS single, link A or link B table
            if ( Head == 0 )
            {
                rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_TMDS_SINGLE_A );
            }
            else
            {
                rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_TMDS_SINGLE_B );
            }

            if ( rmStatus != RM_OK )
            {
                BOOL isMode4 = FALSE;

                // clear error
                rmStatus = RM_OK;

                // Determine PLL values based on pixclk
                if (fpPixClk <= 6400)
                {         // pixclk <= 64MHz
                    tmds_pll0 = 0x31;
                    tmds_pll1 = 0x5F;
                }
                else if (fpPixClk == 6500)
                {  // pixclk == 65MHz
                    tmds_pll0 = 0x31;
                    tmds_pll1 = 0x49;
                }
                else if (fpPixClk <= 8000)
                {  // pixclk <= 80Mhz
                    tmds_pll0 = 0x29;
                    tmds_pll1 = 0x4E;
                }
                else if (fpPixClk <= 10000)
                {  // pixclk <= 100Mhz
                    tmds_pll0 = 0x29;
                    tmds_pll1 = 0x49;
                }
                else
                {                        // pixclk > 100MHz
                    tmds_pll0 = 0x30;
                    tmds_pll1 = 0x4F;
                    isMode4 = TRUE;
                }

                if (isMode4)
                {
                    //
                    // To set TMDS_PLL0 to 0x30, we need to transition through 0x31 first
                    // (setting TMDS_PLL1 both times), with a little delay in between.
                    //
                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL0, 0x31);         // set PLL0
                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL1, tmds_pll1);    // set PLL1
                    tmrDelay(pDev, 1 * 1000 * 1000);  // 1 ms
                }

                dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL0, tmds_pll0);    // set PLL0
                dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL1, tmds_pll1);    // set PLL1
            }
        }
        else
        {
            // First, check if we're in TMDS or LVDS mode
            // Currently looking at one of the registers
            // TODO: should look at the BIOS tables instead?
            //DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, 
            //             DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | NV_PRAMDAC_INDIR_TMDS_MODE,
            //             Head);
            //if ((DAC_REG_RD32(NV_PRAMDAC_FP_TMDS_DATA, Head) & 0x1) || pDev->Power.MobileOperation)
            //
            // From what I've found out, there are no LVDS panels that are not Mobile.
            if (pDev->Power.MobileOperation)
            {
                //
                // OK, we're in LVDS mode.
                //
                // Ideally we use the scripts embedded within the BIOS to perform the panel programming.
                // Let's see if the support is in the BIOS for this particular panel.
                //
                //
                // Note the Mac will use the legacy programming until its fcode is updated accordingly
                //

                // script programming only needs to be run if
                // A. We've changed the PCLK
                // B. Or we're powered off.
                // For mobile panels (which are currenly LVDS only), we never change the PCLK on head 1
                // So, only if we're in an off state, should we run the scripts
                // check if the panel is off
                //if((REG_RD32(NV_PCRTC_GPIO_EXT) & 0x33) == 0x00)
                // The old way was to use the GPIO pins to determine off/on status
                // The new way uses the SW variable, pDev->Dac.DevicesEnabled
                if((pDev->Dac.DevicesEnabled & DAC_PANEL_POWER_ENABLED) != DAC_PANEL_POWER_ENABLED)
                {
#ifndef MACOS
                    U008 panelFlags = 0;
                    U032 timeHI, timeLO;
    
                    // Try to run manufacturers script (i.e. BIOS revision >= 0x14)
                    if(DevinitGetManufacturerInfo(pDev) == RM_OK)
                    {
                      // Test if we need to reprogram the links
                      if(pDev->Dac.ManufacturerProperties.Flags & MANUFACTURER_RESET_REQUIRED)
                      {
                        rmStatus = DevinitRunManufacturerScript(pDev, MSCRIPT_LVDS_RESET_SCRIPT);
                      }
                    }
                    else // BIOS is < revision 0x14
                    {
                        rmStatus = DevinitGetFlatPanelFlags( pDev, pDev->Dac.PanelStrap, &panelFlags );
    
                        // We need to first power down if we're not already powered down.
                        // dacPowerOffMobilePanel(pDev, Head);
                        // We should never have to power down the panel since we can't get here unless we're powered down!
                        
                        
                        //  clear the screen: This is needed since the Old Non-Toshiba Mobile VBIOSes
                        // will turn on the screen with the Uber-script.  So we should make sure that
                        // the screen is clear before we turn on the panel.
                        if(pDev->Power.MobileOperation != 2)
                        {
                            U032 page, size, i;  // for clearing the screen

                            page = pDev->Framebuffer.HalInfo.Start[pDev->Framebuffer.Current] / 4;
                            size = (pDev->Dac.HalInfo.Depth / 8) * pDev->Framebuffer.HalInfo.HorizDisplayWidth * pDev->Framebuffer.HalInfo.VertDisplayWidth / 4;
                            for (i = 0; i < size; i++)
                            {
                                fbAddr->Reg032[page + i] = 0;
                            }
                        }
    
                        // We have to add the smart delay here since the old scripts didn't have the required delay
                        // Now incurr the penalty for stalling between power on and off
                        tmrGetCurrentTime(pDev, &timeHI, &timeLO);
                        if((pDev->Dac.PanelOffTimestampHI > timeHI) ||
                           ((pDev->Dac.PanelOffTimestampHI == timeHI) &&
                            (pDev->Dac.PanelOffTimestampLO > timeLO)) )
                        {
                            // Delay the difference of the times.  Unsigned math shouldn't matter if delay is under 2^31 nanoseconds.
                            tmrDelay(pDev, (pDev->Dac.PanelOffTimestampLO - timeLO));
                        }
        
                        //
                        // Attempt to process the scripts.  Note if this fails the code will fall through
                        // and use the legacy programming.
                        //
                        if ( rmStatus == RM_OK )
                        {
                            if ( ( panelFlags & 0x01 ) == 0 )
                            {
                                // Flag is 0
                                // Run BIOS LVDS single table
                                rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_LVDS_SINGLE_B );
                            }
                            else
                            {
                                // Flag is 1
                                // Run BIOS LVDS dual table
                                rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_LVDS_DUAL );
                            }
                        }

                        // Toshiba's uberscript actually does not turn the power on to the panel and backlight
                        // But Dell and everyone else should.  This is only for Mobile platforms which is checked above.
                        if(pDev->Power.MobileOperation != 2)
                        {
                            pDev->Dac.DevicesEnabled |= DAC_PANEL_ENABLED;
  
                            // We also need to turn off the power pending flag.
                            // If we leave this flag on, then we'll end up not allowing the dacBacklightOff script
                            // to run in dacMobileDisplayNotifyBegin(), which will show corruption during the
                            // modeset - Bad driver, bad, bad driver!
                            pDev->Power.Flags &= ~(DAC_POWER_PENDING);
                        }

                    } // end of BIOS is < revision 0x14
        
                    if ( rmStatus == RM_OK )
                    {
                        // Head selection does not occur in BIOS, so we do this manually
                        // after the other stuff is done.
                        if (Head == 0)
                        {
                            U008 Data;
                            // read register NV_PRAMDAC_INDIR_TMDS_MODE in LINK B
                            Data = dacTMDSRead(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_MODE );
                            // Or with 0x0C to say get from alternate source
                            // write register back to Link B
                            dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_MODE, (U008)( Data | 0x0C ));
                        }
                        else
                        {
                            U008 Data;
                            // read register NV_PRAMDAC_INDIR_TMDS_MODE in LINK A
                            Data = dacTMDSRead(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_MODE );
                            // Or with 0x0C to say get from alternate source
                            // write register back to Link A
                            dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_MODE, (U008)( Data | 0x0C ));
                        }
    
                        //
                        // Until the BIOS contains scripts for enabling/disabling the panel
                        // power and backlight, we will still be forced to use separate
                        // routines (dacPowerOnMobilePanel, dacPowerOffMobilePanel) seen
                        // below.  Since those routines don't know yet the chip revision
                        // or BIOS script they're programming, we need to track if we
                        // programmed up the panel using the BIOS script or by using
                        // our legacy code (below).
                        //
                        // As soon as all the BIOS's are updated and we don't have to worry
                        // about legacy programming (yeah right), then we can take out this
                        // flag.
                        //
                        // This flag will be checked in the PowerOn/PowerOff routines to know
                        // what programming to perform.
                        //
                        pDev->Dac.BIOSPanelProgramming = 1;
                    }
                    else  // Failing side of internal script processing, so go to legacy programming
#endif  // MACOS
                    {
                        //
                        // Legacy programming flag -- to be picked up by PowerOn/PowerOff routines.
                        //
                        // Note this will always be the case for mac until the above is turned back
                        // on again for macos.
                        //
                        pDev->Dac.BIOSPanelProgramming = 0;
    
                        // We failed to process the table, so do it the hardcoded way
    
                        if (!IsNV11(pDev))
                        {
                            // We only know how to do NV11
                            return RM_ERROR;
                        }
    
                        // Clear the error
                        rmStatus = RM_OK;
    
                        // Setup Link0
                        dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_PLL0, 0x32);
                        dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_PLL1, 0xD4);
                        //
                        //dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x3A);
                        //dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_PLL1, 0x94);
                        //
                        dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_IDLY, 0x00);
                        if (Head == 0)
                            dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_MODE, 0x81);
                        else
                            dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_MODE, 0x8D);
                        dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_LVDS, 0x6E);
    
                        // Setup Link1
                        DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, 0x1101111, 0x1);
                        tmrDelay(pDev, 0x400000);
    
                        dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_PLL0, 0x32);
                        dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_PLL1, 0xD4);
                        //
                        //dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x3A);
                        //dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_PLL1, 0x94);
                        //
                        dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_IDLY, 0x00);
                        if (Head == 0)
                            dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_MODE, 0x8D);
                        else
                            dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_MODE, 0x81);
                        dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_LVDS, 0x2E);
    
                        // Setup both Links to run at 1/2 the fpclk frequency
                        //
                        // Don't do this for Toshiba which is single link.  We need this info
                        // from either the BIOS (when it takes over the programming) or from
                        // the EDID.  For now, watch for Toshiba flags
                        //
                        if (pDev->Power.MobileOperation != 2)
                        {
                            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _FPCLK_RATIO, _DB2, 0);
                            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _FPCLK_RATIO, _DB2, 1);
                        }
                    } // end of legacy programming
                }  // end of if power is off (Don't run scripts if power is already on.)
            }
            else // failing side of if pDev->Power.MobileOperation
            {
                // TMDS settings

                // Run BIOS TMDS single, link A or link B table
                if ( Head == 0 )
                {
                    rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_TMDS_SINGLE_A );
                }
                else
                {
                    rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_TMDS_SINGLE_B );
                }

                if (rmStatus != RM_OK && IsNV11(pDev))
                {
                    // We failed to process the table, so do it the hardcoded way
                    // We only know how to do NV11.

                    // Determine PLL values based on pixclk
                    if (fpPixClk <= 6500) {         // pixclk <= 65MHz
#ifdef MACOS
                        // on the iMac we need to adjust PLL0 timing to reduce
                        //  emissions (Apple's request)
                        //  Test to detect iMac is a bit hokey, but will go away when we switch to
                        //  using the tables anyway...
                        //  NOTE we already know we are NV11 from above.
                        
                        if (pDev->halHwInfo.pMcHalInfo->MaskRevision < MC_MASK_REVISION_B1)
                            tmds_pll0 = 0xB2;
                        else
                        {
                            tmds_pll0 = 0x81;
                            if (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_SUB_VENDOR) == NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_NO_BIOS)
                                tmds_pll0 = 0x01;
                        }
#else
                        tmds_pll0 = 0xB2;
#endif
                        tmds_pll1 = 0xF7;
                        tmds_pll2 = 0x00;
                    } else {                        // pixclk > 65MHz
                        tmds_pll0 = 0x32;
                        tmds_pll1 = 0x6F;
                        tmds_pll2 = 0x20;
                    }

                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL0, tmds_pll0);    // set PLL0
                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL1, tmds_pll1);    // set PLL1
                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL2, tmds_pll2);    // set PLL2

                    // Link0 gets data from CRTC0; Link1 gets data from CRTC1, so set "normal" for DINSEL
                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_MODE, 0x80);    // get data from CRTCx
                }
            }
        }
    }


    if (IsNV11(pDev) && (FpMode == NV_CFGEX_GET_FLATPANEL_INFO_SCALED))
    {
        U032    HSyncOffset;
        
        // For NV11, there is a clock synchronization problem when scaling:
        // At H display end, the CRTC clock must be held off until sync start, but if the period between end of active display
        // and sync start is too small, there is not enough time to synchronize, so we will reduce HCRTC, which is the synchronization
        // point.
        HSyncOffset = fpHSyncStart - fpHActive;    // find period between display end and sync start
        if (HSyncOffset < 28) 
        {
            fpHActive = fpHActive - (28 - HSyncOffset); // reduce HCRTC by an appropriate amount
        }

        //
        // Workaround to get reduced blanking on Dell's QXGA panels
        // REMOVE REMOVE REMOVE as soon as we have a robust alternative worked
        // out.  The EDID is correct in showing a 2048 horizontal total, but we
        // need to drive 2000 (0x7D0).
        //
        // Let me quote the hw engineer:
        //    We could use 0x7D0 for all QXGA panels, so far
        //    there are no issues with this settings for all QXGA timings.
        //
        if ((fpHActive == 0x800) && pDev->Power.MobileOperation)
            fpHActive = 0x7D0;

    }

    data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, (data32 & 0xfff0ffff) | 0x00020000, Head);
    tmrDelay(pDev, 0x400000);
    
    DAC_REG_WR32(NV_PRAMDAC_FP_HCRTC, fpHActive, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HDISPLAY_END, fpHDispEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HVALID_START, fpHValidStart, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HVALID_END, fpHValidEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HSYNC_START, fpHSyncStart, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HSYNC_END, fpHSyncEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HTOTAL, fpHTotal, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VCRTC, fpVActive, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VDISPLAY_END, fpVDispEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_START, fpVValidStart, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_END, fpVValidEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VSYNC_START, fpVSyncStart, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VSYNC_END, fpVSyncEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VTOTAL, fpVTotal, Head);
    
    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32, Head);

    // Special case for flat panels with horizontal max 1600, 
    // overrides HW scaling for 1280->1600  in pre-nv11 boards
    if (  pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth == 1280
       && pDev->Dac.HalInfo.fpHMax == 1600
       && FpMode == NV_CFGEX_GET_FLATPANEL_INFO_SCALED
       && !IsNV11orBetter(pDev)
       ) 
    {   
        DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_1,  0x00001ccd, Head);
    }
    // NV10/15 seem to be missing table entries for scaling 720 modes
    // Write the scale factor 
    if (IsNV10(pDev) || IsNV15(pDev)) 
    {
        if (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth == 720)
        {
            data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_1, Head);  // This should be 0
            switch (fpHActive) // res we are scaling into
            {
                case 1024:
                    data32 |= 0x1b3f;
                    break;
                case 1280:
                    data32 |= 0x18ff;
                    break;
                case 1600:
                    data32 |= 0x1732;
                    break;
            }
            // Check vertical 576 (480 will scale properly)
            // (These numbers were gotten by taking the factors in the manual for 512 and 600 and proportioning to 576)
            if (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 576)
            {
                switch (fpVActive) 
                {
                case 768:
                    data32 |= 0x1bfe0000;
                    break;
                case 1024:
                    data32 |= 0x18fe0000;
                    break;
                case 1200:
                    data32 |= 0x17ac0000;
                    break;
                }
            }
            DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_1, data32, Head);
        }
    }

    tmrDelay(pDev, 0x400000);

    // since the flat panel is now setup, turn off the reset flag
    pDev->Dac.DevicesEnabled &=  ~(DAC_PANEL_CLK_RESET);

    return RM_OK;
}


// TODOMK: What is this for?  Can it be replaced with BIOS table usage?
RM_STATUS dacPowerOnMobilePanel
(
    PHWINFO pDev,
    U032    Head
)
{
    U008 lock;
    U032 gpio_ext45;
    U032 timeHI, timeLO;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"dacPowerOnMobilePanel on Head");
    DBG_PRINT_VALUE(DEBUGLEVEL_TRACEINFO,Head);
    
    //
    // If we're already on, don't wait around here with the delays
    //
    // also make sure that this is mobile operation before skipping the good bits
    if(pDev->Power.MobileOperation && (((pDev->Dac.DevicesEnabled & DAC_PANEL_ENABLED) == DAC_PANEL_ENABLED) || (pDev->Power.Flags & DAC_POWER_PENDING)))
        return (RM_OK);

    // Retain GPIO_EXT_4 and GPIO_EXT_5 settings
    gpio_ext45  = REG_RD32(NV_PCRTC_GPIO_EXT);
    gpio_ext45 &= 0xFF00;

    // This delay is for non-Toshiba mobiles.
    // Toshiba flat panels are unaffected from this entire function.
    // We do not have direct control over the panel or backlight power for Toshiba.
    // We can call DPMS Sleep/Wake to turn off the backlight.
    // DeviceControlBegin/End BIOS calls also affect the power to the panel.
    // So this delay is unnecessary for Toshiba.
    if(pDev->Power.MobileOperation != 2)
    {
        // Now incurr the penalty for stalling between power on and off
        tmrGetCurrentTime(pDev, &timeHI, &timeLO);
        if((pDev->Dac.PanelOffTimestampHI > timeHI) ||
           ((pDev->Dac.PanelOffTimestampHI == timeHI) &&
            (pDev->Dac.PanelOffTimestampLO > timeLO)) )
        {
            // Delay the difference of the times.  Unsigned math shouldn't matter.
            tmrDelay(pDev, (pDev->Dac.PanelOffTimestampLO - timeLO));
        }
    }

    // First check to see if we can run the manufacturer scripts
    if(DevinitGetManufacturerInfo(pDev) == RM_OK)
    {
      // Let's power up the Manufacturer way
      DevinitRunManufacturerScript(pDev, MSCRIPT_PANEL_ON);
      
      // 100ms delay? why? it fixes the problem when cycling the hotkeys around to LCD
      // then using TwinView to turn on Clone mode (LCD->LCD+TV).  Without the delay,
      // this switch takes 9-12 seconds, because i2c fails.  With the delay, i2c works!
      if(pDev->Power.MobileOperation == 2)
        tmrDelay(pDev, 100000000);
    }
    //
    // Second check to see if we used the BIOS scripts to program the panel.
    // If so, we should use the BIOS scripts to turn on the panel as well,
    // but until that is complete in the BIOS, just perform the simplest
    // GPIO programming
    //
    else if (pDev->Dac.BIOSPanelProgramming == 1)
    {
        //
        // TOSHIBA doesn't like this new programming.  Until I get a Toshiba to 
        // debug...
        //
        // Remember Toshiba really handles their own power sequencing, so skipping
        // this should not be an issue.
        //
        //LPL: removed due to problems caused during display switching
//        if (pDev->Power.MobileOperation == 2)
//            return (RM_OK);

        // Disable breaker, this turns on the panel PLL
        REG_WR32(NV_PCRTC_GPIO_EXT, gpio_ext45 | 0x10);

        // Toshiba does not use the GPIO_EXT to enable/disable bl or power.
        if(pDev->Power.MobileOperation != 2)
          pDev->Dac.DevicesEnabled |= (DAC_PANEL_POWER_ENABLED);

        // 220ms delay between power and bl enable
        tmrDelay(pDev, 220000000);

        // Power on the BL so we can see
        REG_WR32(NV_PCRTC_GPIO_EXT, gpio_ext45 | 0x11);
    }
    else
    {
        if(pDev->Power.MobileOperation)
        {
            //
            // LEGACY PROGRAMMING
            //
            // make sure PLL is enabled, or we'll hang
            dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE);   // FP on to access TMDS

            // Enable Head2 GPIO
            lock = UnlockCRTC(pDev, 1);
            CRTC_WR(NV_CIO_GPIO23_INDEX, 0x00, 1);
            RestoreLock(pDev, 1, lock);

            // Disable panel I/O
            dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x52);    // set PLL0
            dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x52);    // set PLL0

            // Wait a bit
            tmrDelay(pDev, 1000000);

            // Enable GPIO3 to a zero, set breaker
            //REG_WR32(NV_PCRTC_GPIO_EXT, gpio_ext45 | 0x00);
            FLD_WR_DRF_DEF(_PCRTC,_GPIO_EXT,_2_OUTPUT,_0);
            FLD_WR_DRF_NUM(_PCRTC,_GPIO_EXT,_3_OUTPUT,0);
            FLD_WR_DRF_DEF(_PCRTC,_GPIO_EXT,_2_ENABLE,_ENABLE);
            FLD_WR_DRF_DEF(_PCRTC,_GPIO_EXT,_3_ENABLE,_ENABLE);

            // Wait a bit
            tmrDelay(pDev, 1000000);

            // Disable breaker, this turns on the panel PLL
            //REG_WR32(NV_PCRTC_GPIO_EXT, gpio_ext45 | 0x10);
            FLD_WR_DRF_NUM(_PCRTC,_GPIO_EXT,_3_OUTPUT,1);

            // Wait a lot
            tmrDelay(pDev, 8000000);
        
            // Let DivBy7 go
            dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x38);    // set PLL2
            dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x38);    // set PLL2
        
            // Let DivBy10 go
            dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL1, 0x94);    // set PLL1
            dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL1, 0x94);    // set PLL1
        
            // Wait a bit
            tmrDelay(pDev, 1000000);
        
            // Reset DivBy10
            dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL1, 0xD4);    // set PLL1
            dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL1, 0xD4);    // set PLL1
        
            // Wait a bit
            tmrDelay(pDev, 1000000);
        
            // Reset DivBy7
            dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x3A);    // set PLL2
            dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x3A);    // set PLL2
        
            // Wait a bit
            tmrDelay(pDev, 1000000);
        
            // Let DivBy7 go again -- this leaves us in LVDS
            dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL1, 0x94);    // set PLL1
            dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL1, 0x94);    // set PLL1
        
            // Wait a moderate bit
            tmrDelay(pDev, 2000000);
            
            // Power on the BL so we can see
            //
            //REG_WR32(NV_PCRTC_GPIO_EXT, gpio_ext45 | 0x11);
            FLD_WR_DRF_DEF(_PCRTC,_GPIO_EXT,_2_ENABLE,_ENABLE);
            FLD_WR_DRF_NUM(_PCRTC,_GPIO_EXT,_2_OUTPUT,1);
        }
        else
        {   
            if(IsNV11(pDev))
            {
                if(osReadRegistryBoolean(pDev,NULL,"backlight-control"))
                {
                    //do P11 specifics
                    FLD_WR_DRF_NUM(_PCRTC,_GPIO_EXT,_2_OUTPUT,1);
                    FLD_WR_DRF_DEF(_PCRTC,_GPIO_EXT,_2_ENABLE,_ENABLE);
                }
                else
                {
                    //do NV11-P40 specifics
                    FLD_WR_DRF_NUM(_PCRTC,_GPIO_EXT,_3_OUTPUT,1);
                    FLD_WR_DRF_DEF(_PCRTC,_GPIO_EXT,_3_ENABLE,_ENABLE);
                }
            }

        
            //do NV20 specifics (on Mac, our flat panel enable is non standard)
            if(IsNV20(pDev))
            {
                REG_WR32(0x600818,REG_RD32(0x600818)|0x11);
            }
            
            //repair GPIO5 according to the inverter needs
            dacSetExternalInverterCurrentMode(pDev);
        }
    }

    // Toshiba does not use the GPIO_EXT to enable/disable bl or power.
    if(pDev->Power.MobileOperation != 2)
      pDev->Dac.DevicesEnabled |= DAC_PANEL_ENABLED;

        return (RM_OK);
}

RM_STATUS dacPowerOffMobilePanel
(
    PHWINFO pDev,
    U032    Head
)
{
 
    U008 lock;
    U032 gpio_ext45;
    U032 PanelOffOnDelay = 500;  // 500 ms is the default
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"dacPowerOffMobilePanel on Head");
    DBG_PRINT_VALUE(DEBUGLEVEL_TRACEINFO,Head);
    
    //
    // If we're already off, don't wait around here with the delays
    //
    //also make sure this is really mobile operation, not a Mac, not PowerEvent before skipping all the good bits
    // if ((REG_RD32(NV_PCRTC_GPIO_EXT) & 0x33) == 0x00)
    if(pDev->Power.MobileOperation && ((pDev->Dac.DevicesEnabled & DAC_PANEL_ENABLED) == DAC_NOT_ENABLED || (pDev->Power.Flags & DAC_POWER_PENDING)))
        return (RM_OK);


    if (MC_POWER_LEVEL_0 != pDev->Power.State) {
        return (RM_OK);
        }
               

    if(DevinitGetManufacturerInfo(pDev) == RM_OK)
    {
      // Let's power down the Manufacturer way
      DevinitRunManufacturerScript(pDev, MSCRIPT_PANEL_OFF);

      PanelOffOnDelay = pDev->Dac.ManufacturerProperties.PanelOffOnDelay;
    }
    //
    // Second, check to see if we used the BIOS scripts to program the panel.
    // If so, we should use the BIOS scripts to turn on the panel as well,
    // but until that is complete in the BIOS, just perform the simplest
    // GPIO programming
    //
    else if (pDev->Dac.BIOSPanelProgramming == 1)
    {
        //
        // TOSHIBA doesn't like this new programming.  Until I get a Toshiba to 
        // debug...
        //
        // Remember Toshiba really handles their own power sequencing, so skipping
        // this should not be an issue.
        //
        //LPL: removed due to problems caused during display switching
//        if (pDev->Power.MobileOperation == 2)
//            return (RM_OK);

        // Read the register for the panel backlight and power
        gpio_ext45  = REG_RD32(NV_PCRTC_GPIO_EXT);

        // Only disable the backlight if it's actually on!
        // Currently we're forcing the SW flag on in mcPowerState 
        // (Returning to 0 from level 2).  If the panel power is
        // actually off, then writing ((gpio_ext45 & 0xFF00) | 0x10)
        // will turn the panel on.
        REG_WR32(NV_PCRTC_GPIO_EXT, (gpio_ext45 & 0xFFF0));

        // Toshiba does not use the GPIO_EXT to enable/disable bl or power.
        if(pDev->Power.MobileOperation != 2)
          pDev->Dac.DevicesEnabled &= ~(DAC_PANEL_BACKLIGHT_ENABLED);
        
        // 20 ms delay between bl off and power off?
        // According to the Panel Timing Specs worksheet, 20 ms is the minimum
        tmrDelay(pDev, 20000000);
    
        // disable panel power    
        REG_WR32(NV_PCRTC_GPIO_EXT, (gpio_ext45 & 0xFF00));
    }
    else
    {
        //
        // LEGACY PROGRAMMING
        //
        if(pDev->Power.MobileOperation)
        {
            // Enable Head2 GPIO
            lock = UnlockCRTC(pDev, 1);
            CRTC_WR(NV_CIO_GPIO23_INDEX, 0x00, 1);
            RestoreLock(pDev, 1, lock);
        
            // make sure PLL is enabled, or we'll hang
            dacWriteLinkPLL(pDev, 0, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE);     // FP on to access TMDS
            dacWriteLinkPLL(pDev, 1, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE);
        
            // BL disable
            //REG_WR32(NV_PCRTC_GPIO_EXT, gpio_ext45 | 0x10);
            FLD_WR_DRF_DEF(_PCRTC,_GPIO_EXT,_2_ENABLE,_ENABLE);
            FLD_WR_DRF_NUM(_PCRTC,_GPIO_EXT,_2_OUTPUT,0);
        
            // Disable panel I/O
            dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x52);    // set PLL0
            dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x52);    // set PLL0
        
            tmrDelay(pDev, 1000000);
        
            // disable panel power
            //REG_WR32(NV_PCRTC_GPIO_EXT, gpio_ext45 | 0x00);
            FLD_WR_DRF_DEF(_PCRTC,_GPIO_EXT,_3_ENABLE,_ENABLE);
            FLD_WR_DRF_NUM(_PCRTC,_GPIO_EXT,_3_OUTPUT,0);
        }
        else
        {
            if(IsNV11(pDev))
            {
                if(osReadRegistryBoolean(pDev,NULL,"backlight-control"))
                {
                    //Disable panel backlight only on P11
                    FLD_WR_DRF_DEF(_PCRTC,_GPIO_EXT,_2_ENABLE,_ENABLE);
                    FLD_WR_DRF_NUM(_PCRTC,_GPIO_EXT,_2_OUTPUT,0);
                }
                else
                {
                    //disable GPIO3 which is wired to the panel power control on P40
                    FLD_WR_DRF_DEF(_PCRTC,_GPIO_EXT,_3_ENABLE,_ENABLE);
                    FLD_WR_DRF_NUM(_PCRTC,_GPIO_EXT,_3_OUTPUT,0);
                }
            }
            
            //if nv20 (arg!)
            //do NV20 specifics (on Mac, our flat panel enable is non standard)
            //will go away with virtualized GPIOs
            if(IsNV20(pDev))
            {
                REG_WR32(0x600818,REG_RD32(0x600818)&~0x11);
            }
        }
    }
        
        //satisfy GPIO5 reqs.
    dacSetExternalInverterCurrentMode(pDev);

    // Start smart time delay and turn off SW flag for non-Toshiba mobiles
    // Toshiba flat panels are unaffected from this entire function.
    // We do not have direct control over the panel or backlight power for Toshiba.
    // We can call DPMS Sleep/Wake to turn off the backlight.
    // DeviceControlBegin/End BIOS calls also affect the power to the panel.
    // So this delay is unnecessary for Toshiba.
    if(pDev->Power.MobileOperation != 2)
    {
        //
        // Need to abide by minimum 500ms between panel off and back on again, so
        // enforce it here while the panel is black
        // tmrDelay(pDev, 500000000);
        // 500 ms was the old minimum.  This is now changed by using the PanelOffOnDelay.

        // Store the current time, and then stall on the panel on call
        tmrGetCurrentTime(pDev, 
            &(pDev->Dac.PanelOffTimestampHI), &(pDev->Dac.PanelOffTimestampLO));
            
        // Change the PanelOffOnDelay from ms to ns
        PanelOffOnDelay *= 1000000;
        
        // Go ahead and add the delay to the timestamp
        // Check for carry condition
        if((pDev->Dac.PanelOffTimestampLO + PanelOffOnDelay) < pDev->Dac.PanelOffTimestampLO)
        {
            pDev->Dac.PanelOffTimestampHI++;
        }
        pDev->Dac.PanelOffTimestampLO += PanelOffOnDelay;
    
        // Toshiba does not use the GPIO_EXT to enable/disable bl or power.
        pDev->Dac.DevicesEnabled &= ~(DAC_PANEL_ENABLED);
    }

    return (RM_OK);
}

RM_STATUS dacBacklightOnMobilePanel(PHWINFO pDev)
{
    RM_STATUS status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"dacBacklightOnMobilePanel");

    // Only do this if Mobile and the backlight is off
    if ((pDev->Power.MobileOperation) && 
        (!(pDev->Dac.DevicesEnabled & DAC_PANEL_BACKLIGHT_ENABLED)))
    {
        // Toshiba doesn't turn off their backlight with Manufacturer scripts or GPIO pins
        if(pDev->Power.MobileOperation != 2)
        {
            // Try manufacturer scripts first
            // Currently the backlight on script is missing an INIT_DONE.
            // and it turns the backlight on then off.  So for now, just
            // do it the old fashioned way.
            if(0)//DevinitGetManufacturerInfo(pDev) == RM_OK)
            {
                // Let's turn the backlight on the Manufacturer way
                status = DevinitRunManufacturerScript(pDev, MSCRIPT_BACKLIGHT_ON);
            }
            else
            {
                U032 gpio_ext45;
    
                // Retain GPIO_EXT_4 and GPIO_EXT_5 settings
                gpio_ext45  = REG_RD32(NV_PCRTC_GPIO_EXT);
                gpio_ext45 &= 0xFFF0;
      
                // Power on the BL so we can see
                REG_WR32(NV_PCRTC_GPIO_EXT, gpio_ext45 | 0x01);

                status = RM_OK;
            }
        }
        else
        {
            // Turn on the backlight after enabling the DACs
            U032    EAX, EBX, ECX, EDX;
            EAX = 0x4F10;
            EBX = 0x0001; //wake up
            EDX = 0x0000;
            ECX = 0x0000;
            status = osCallVideoBIOS(pDev, &EAX, &EBX, &ECX, &EDX, NULL);
        }
        
        if(status != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"NVRM: ERROR!!! dacBacklightOnMobilePanel failed.  SW State is invalid.\n");
        }

        pDev->Dac.DevicesEnabled |= (DAC_PANEL_BACKLIGHT_ENABLED);
    }
    return status;
}

RM_STATUS dacBacklightOffMobilePanel(PHWINFO pDev)
{
    RM_STATUS status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"dacBacklightOffMobilePanel");

    // Only do this if Mobile and the backlight is on
    if ((pDev->Power.MobileOperation) && 
        (pDev->Dac.DevicesEnabled & DAC_PANEL_BACKLIGHT_ENABLED))
    { 
      if(pDev->Power.MobileOperation != 2)
      {
          if(DevinitGetManufacturerInfo(pDev) == RM_OK)
          {
              // Let's turn the backlight off the Manufacturer way
              status = DevinitRunManufacturerScript(pDev, MSCRIPT_BACKLIGHT_OFF);
          }
          else
          {
              U032 gpio_ext45;
    
              // Retain GPIO_EXT_4 and GPIO_EXT_5 settings
              gpio_ext45  = REG_RD32(NV_PCRTC_GPIO_EXT);
              gpio_ext45 &= 0xFFF0;
    
              // Power off the Backlight
              REG_WR32(NV_PCRTC_GPIO_EXT, gpio_ext45);

              status = RM_OK;
          }
      }
      else  // Toshiba case
      {
          // Turn off the backlight
          U032    EAX, EBX, ECX, EDX;
          EAX = 0x4F10;
          EBX = 0x0401; //sleep
          EDX = 0x0000;
          ECX = 0x0000;
          status = osCallVideoBIOS(pDev, &EAX, &EBX, &ECX, &EDX, NULL);
      }
        
      if(status != RM_OK)
      {
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"NVRM: ERROR!!! dacBacklightOffMobilePanel failed.  SW State is invalid.\n");
      }
          
      pDev->Dac.DevicesEnabled &= ~(DAC_PANEL_BACKLIGHT_ENABLED);
    }
    return status;
}

void dacZeroPWMController(PHWINFO pDev)
{
        REG_WR32(NV_PBUS_PWM,0);
}

void dacSetPWMController(PHWINFO pDev)
{
        REG_WR32(NV_PBUS_PWM,pDev->Dac.fpPWMRegisterContents);
}

void dacSetExternalInverterCurrentMode(PHWINFO pDev)
{
    U032 nvPcrtcGpioExtVal;
    
    if (pDev->Power.MobileOperation)
        return;    // mobile uses GPIO_EXT_5 for controlling spread spectrum

    nvPcrtcGpioExtVal=REG_RD32(NV_PCRTC_GPIO_EXT);
    
    //uninit'd variable check
    switch(pDev->Dac.fpExternalInverterCurrentMode)
    {
        case 0:
        case 1:
            break;
        default:
            pDev->Dac.fpExternalInverterCurrentMode=0;
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"Possible uninitialized fpExternalInverterCurrentMode!.\n");
    }
    
    if(pDev->Dac.fpExternalInverterCurrentMode)
    {       
        //set the bit
        nvPcrtcGpioExtVal|=BIT(12);
        
        //clear the GPIO line disable bit
        nvPcrtcGpioExtVal&=~BIT(13);
    }
    else
    {
        //set the output line to zero
        nvPcrtcGpioExtVal&=~BIT(12);
        
        //clear the GPIO line disable bit
        nvPcrtcGpioExtVal&=~BIT(13);
    }
    
    REG_WR32(NV_PCRTC_GPIO_EXT,nvPcrtcGpioExtVal);
}

void dacGetExternalInverterCurrentMode(PHWINFO pDev)
{
    U032 nvPcrtcGpioExtVal;
    
    if (pDev->Power.MobileOperation)
        return;    // mobile uses GPIO_EXT_5 for controlling spread spectrum

    nvPcrtcGpioExtVal=REG_RD32(NV_PCRTC_GPIO_EXT);
    
    if(BIT(14)&nvPcrtcGpioExtVal)
    {
        pDev->Dac.fpExternalInverterCurrentMode=1;
    }
    else
    {
        pDev->Dac.fpExternalInverterCurrentMode=0;
    }
}

void dacGetPWMController(PHWINFO pDev)
{
        U032 NvPbusPwmHighValue,ControllerRegisterValue,FpDynamicRange;
    U032 NvPbusPwmPeriodValue;
    U032 MinPeriodValue,RelativePeriod;
        
        //we need to init the variable for the flat panel brightness
    if(!pDev->Dac.fpRelativeBrightness)
    {
        ControllerRegisterValue=REG_RD32(NV_PBUS_PWM);
        NvPbusPwmHighValue=(ControllerRegisterValue>>16)&0x7fff;
        NvPbusPwmPeriodValue=ControllerRegisterValue&0x7fff;
        
        //a kludge - 40% to 100%
        MinPeriodValue=((NvPbusPwmPeriodValue*40)+50)/100;
        
        FpDynamicRange=NvPbusPwmPeriodValue-MinPeriodValue;
        
        RelativePeriod=NvPbusPwmHighValue-MinPeriodValue;
        
        pDev->Dac.fpRelativeBrightness=(((RelativePeriod*10000)/(FpDynamicRange*10000/255))*10+5)/10;
        
        //store this raw PWM value also into the DAC.fpPWMRegisterContents save/restore var.
        pDev->Dac.fpPWMRegisterContents=ControllerRegisterValue;
    }
}

RM_STATUS  dacSetFlatPanelBrightness
(
    PHWINFO pDev,
    U032 Head,
    U032 Brightness,
    U032 Frequency,
    U032 MaxPercent,
    U032 MinPercent,
    BOOL ControllerIsOn,
    BOOL InverterCurrentMode
)
{
    U032 TicksNeededForClock;
    U032 TicksNeededForHigh;
    
    //clip if necessary
    if(Brightness>255)
    {
            Brightness=255;
    }
    
    //enable PWM output
    if(ControllerIsOn)
    {
            FLD_WR_DRF_DEF(_PBUS,_PWM,_EN,_ENABLED);
    }
    else
    {
            FLD_WR_DRF_DEF(_PBUS,_PWM,_EN,_DISABLED);
    }
    
    TicksNeededForClock = GetTicksForFrequency(Frequency);
    TicksNeededForHigh = GetRequiredTickCount(Frequency,MaxPercent,MinPercent,Brightness);

    //program the chip
    FLD_WR_DRF_NUM(_PBUS,_PWM,_HI,TicksNeededForHigh);
    FLD_WR_DRF_NUM(_PBUS,_PWM,_PERIOD,TicksNeededForClock);
    
    //store multiplier for get
    pDev->Dac.fpRelativeBrightness=Brightness;
    
    //set current mode
    pDev->Dac.fpExternalInverterCurrentMode=(U032)InverterCurrentMode;
    dacSetExternalInverterCurrentMode(pDev);
    
    TicksNeededForClock=GetTicksForFrequency(Frequency);
    TicksNeededForHigh=GetRequiredTickCount(Frequency,MaxPercent,MinPercent,Brightness);

    //store multiplier for get
    pDev->Dac.fpRelativeBrightness=Brightness;
        
    //store the raw PWM value in case someone triggers an on without an off
    pDev->Dac.fpPWMRegisterContents = REG_RD32(NV_PBUS_PWM);
                    
    return RM_OK;
}

RM_STATUS  dacGetFlatPanelBrightness(PHWINFO pDev, U032 Head, U032 * Brightness,BOOL * ControllerIsOn, BOOL * InverterCurrentMode)
{
        U032 NvPbusPwmEnable;
        
        //read register
        NvPbusPwmEnable=REG_RD_DRF(_PBUS,_PWM,_EN);
        
        //retrieve last brightness setting
        *Brightness=pDev->Dac.fpRelativeBrightness;
        
        //check the status of the control bit
        if(NvPbusPwmEnable)
        {
                *ControllerIsOn=TRUE;
        }
        else
        {
                *ControllerIsOn=FALSE;
        }
        
        dacGetExternalInverterCurrentMode(pDev);
        *InverterCurrentMode=(BOOL)pDev->Dac.fpExternalInverterCurrentMode;

        return RM_OK;
}

U032 GetTicksForFrequency(U032 Frequency)
{
        //this replaced alot of code - overcomplication on my part
        return 33333333/Frequency;
}

U032 GetPortionOfTotalSizeBasedOnPercentage(U032 TotalSize,U032 Percentage)
{

        //do calculation, round up
        return (((TotalSize*Percentage)+50)/100);
}

U032 DetermineFrequencyFromTickCount(U032 NumTicks)
{
        return ((333333330/NumTicks)+5)/10;
}

U032 GetRequiredTickCount(U032 Frequency,U032 MaxPercent,U032 MinPercent,U032 BaseMultiplier)
{
        U032 TicksInClockPeriod;
        U032 MaxTicks;
        U032 MinTicks;
        U032 DynamicRange;
        U032 PreliminaryTickCount;

        TicksInClockPeriod = GetTicksForFrequency(Frequency);
        MaxTicks=GetPortionOfTotalSizeBasedOnPercentage(TicksInClockPeriod,MaxPercent);
        MinTicks=GetPortionOfTotalSizeBasedOnPercentage(TicksInClockPeriod,MinPercent);

        DynamicRange=MaxTicks-MinTicks;

        PreliminaryTickCount=MinTicks+(((((DynamicRange*10)/255)+5)/10)*BaseMultiplier);
        
        if (PreliminaryTickCount>MaxTicks)
        {
                //if rounding produces a number too large, clip it
                PreliminaryTickCount=MaxTicks;
        }
        
        return PreliminaryTickCount;
}

BOOL dacIsFlatPanelOn(PHWINFO pDev,U032 Head)
{
    if((pDev->Dac.DevicesEnabled & DAC_PANEL_POWER_ENABLED)&&pDev->Power.MobileOperation)
      return TRUE;

    if(REG_RD_DRF(_PCRTC,_GPIO_EXT,_3_INPUT))
    {
        //technically, based on policy, this should be a check for GPIO4 up, but this is only the case on P11
        //this interface is insuffecient to determine that.
        return TRUE;
    }
    
    //this must suffice until the HAL function for GPIO arrives
    //reg 0x600818 is NV_PCRTC_GPIO, BIT(24) is GPIO1 input
    if((IsNV20(pDev))&&(REG_RD32(0x600818)&BIT(24)))
    {
        return TRUE;
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\dacstate.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Manager ******************************\
*                                                                           *
* Module: DACSTATE.C                                                        *
*   The DAC state is changed in this module.                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <dac.h>
#include <os.h>
#include <vga.h>
#include "nvhw.h"

VOID enableCursor(PHWINFO, U032);
VOID disableCursor(PHWINFO, U032);

//
// Change DAC hardware state.
//
RM_STATUS stateDac
(
    PHWINFO pDev,
    U032    msg
)
{
    U032 i;

    switch (msg)
    {
        case STATE_UPDATE:
            //
            // Only the Dpm Level and APLL are changed here.  All other
            // updates occur in the VBlank interrupt handler.
            //
            if (pDev->Dac.UpdateFlags & UPDATE_HWINFO_DAC_VPLL)
            {
                dacCalcPLL(pDev);
                pDev->Dac.UpdateFlags &= ~UPDATE_HWINFO_DAC_VPLL;
            }

            // NOTE: MCLK and NVCLK updates are done in mcState.c:stateMc
            
            if (pDev->Framebuffer.UpdateFlags & UPDATE_HWINFO_DISPLAY_PARAMS)
            {

                //
                // Program the new DAC settings
                //    
                // NT NOW calls dacSetMode to do the modesets !!! (Miniport no longer sets the mode)
                // However, the NT driver does NOT use the class interface to do the modeset.
                // Instead it calls RmSetMode.

                dacSetMode(pDev, 0);

#ifdef NTRM
                osSetVideoMode(pDev);
#endif                
                //
                // Perform any necessary OS-specific function
                // after the change to the DAC
                //
                osStateDacEx(pDev, msg);

                pDev->Framebuffer.UpdateFlags &= ~UPDATE_HWINFO_DISPLAY_PARAMS;
            }
            
            if (!pDev->Vga.Enabled)
            {
                for (i = 0; i < MAX_CRTCS; i++)
                {
                    enableCursor(pDev, i);
                    pDev->Dac.CrtcInfo[i].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_IMAGE;	// force an update from image in nvInfo
                }
            }
            else
            {
                for (i = 0; i < MAX_CRTCS; i++)
                    disableCursor(pDev, i);
            }
                
            break;
        case STATE_LOAD:
            //
            // Initialize DAC cursor emulation.
            //
#ifdef NTRM
            for (i = 0; i < MAX_CRTCS; i++)
                pDev->Dac.CrtcInfo[i].CursorType = DAC_CURSOR_TWO_COLOR_XOR;
#else
// Don't turn on cursor until asked to by Windows.
//            pDev->Dac.CursorType      = DAC_CURSOR_TWO_COLOR_XOR;
#endif

            //
            // Make sure we enable the backend video overlay, if req'd
            //
            // KJK: Move this to the new video engine code
            //
            /*
            //
            // New DDraw protocol will enable the overlay on its own
            //
            if ((pDev->Video.Enabled == 1) && !pDev->Vga.Enabled)
                FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _ON);
            */                

            if (!pDev->Vga.Enabled)
            {
#ifdef NTRM
                osSetVideoMode(pDev);
#endif            
                //
                // Perform any necessary OS-specific function
                // after the change to the DAC
                //
                osStateDacEx(pDev, msg);
            
                //
                // Load cursor on boot head only.
                //
                
                enableCursor(pDev, pDev->Dac.HalInfo.InitialBootHead);
                pDev->Dac.CrtcInfo[pDev->Dac.HalInfo.InitialBootHead].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_IMAGE;	// force an update from image in nvInfo
                
                // enable vblank interrupt
                DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, 0);
                DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_EN_0, _VBLANK, _ENABLED, 0);
                pDev->Dac.CrtcInfo[0].StateFlags |= DAC_CRTCINFO_VBLANK_ENABLED;
            }
			else
            {
                for (i = 0; i < MAX_CRTCS; i++)
                    disableCursor(pDev, i);
            }
            break;
        case STATE_UNLOAD:
            //
            // Disable the cursor.
            //
            for (i = 0; i < MAX_CRTCS; i++)
            {
                disableCursor(pDev, i);
                
                DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, i);
                DAC_REG_WR32(NV_PCRTC_INTR_EN_0, 0, i);
                pDev->Dac.CrtcInfo[i].StateFlags &= ~DAC_CRTCINFO_VBLANK_ENABLED;
            }
            break;
        case STATE_INIT:
            initDac(pDev);
            break;
        case STATE_DESTROY:
            break;
    }
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\dacedid.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* EDID Functions *****************************
*                                                                           *
* Module: EDID.C                                                            *
*   All EDID related fuctions are in this module.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nvrm.h>
#include <i2c.h>
#include <tmr.h>
#include <edid.h>
#include "nvhw.h"
#include <dac.h>
#include <devinit.h>
#include <vga.h>


U032 getI2CPort(PHWINFO pDev, U032 Head, U032 dispType )
{
    // We have to know what the mappings of ports to display devices are.
    // Until we can get this from the BIOS, assume the following:
    switch (dispType)
    {
        case DISPLAY_TYPE_MONITOR:
        case DISPLAY_TYPE_DUALSURFACE:
            if (Head == 0) 
                return pDev->Dac.CRTPortID; // VGA Head 0 use port 0
            else
                return pDev->Dac.CRT2PortID; // DVI Head 1 use port 1
        case DISPLAY_TYPE_FLAT_PANEL:
            if (Head == 0) 
                return pDev->Dac.DFPPortID; // DVI Head 0
            else
                return pDev->Dac.DFP2PortID; // DVI Head 1
        case DISPLAY_TYPE_TV:
            return pDev->Dac.TVOutPortID;
        default:
            return NV_I2C_PORT_PRIMARY;
    }
}

static U032 edidTranslateDisplayType(U032 displayType)
{
    switch (displayType)
    {
        case DCB_DEV_REC_TYPE_CRT:
        {
            return DISPLAY_TYPE_MONITOR;
        }
        case DCB_DEV_REC_TYPE_TV:
        {
            return DISPLAY_TYPE_TV;
        }
        case DCB_DEV_REC_TYPE_DD_SLINK:
        case DCB_DEV_REC_TYPE_DD_DLINK:
        case DCB_DEV_REC_TYPE_DD:
        {
            return DISPLAY_TYPE_FLAT_PANEL;
        }
        default:
            return DISPLAY_TYPE_NONE;
    }
}

// Get the monitor to stop driving the DDC bus (DDC1)
// This may only stop the CRT momentarily; we must send a valid DDC2 address
// to be sure it stops permanently.
RM_STATUS StopDDC1(PHWINFO pDev, U032 Head, U032 dispType)
{
U032	i2cPortId = 0;	
U016	status = 1, i;
U008	Data;

    i2cPortId = getI2CPort(pDev, Head, dispType);
    i2cHardwareInit(pDev, Head, i2cPortId);
    tmrDelay(pDev, 15000);
    ResetSCLLine(pDev, Head, i2cPortId);     // drive clock low (data tristated)
    tmrDelay(pDev, 2000000);
    SetSCLLine(pDev, Head, i2cPortId);       // clock high
    SetSDALine(pDev, Head, i2cPortId);       // data high
    for (i=0; i<16; i++)	// give it 16 times
    {
        tmrDelay(pDev, 15000);
        ReadSDA(pDev, Head, i2cPortId, &Data);
        if(Data)        	// SDA = 1?
        {
            status=0;
            break;
        }
    }
    tmrDelay(pDev, 10000);
    i2cStop(pDev, Head, i2cPortId);
    
    // Leave it with clock low (problem with ViewSonic monitors)
    ResetSCLLine(pDev, Head, i2cPortId);     // drive clock low (data tristated)
    tmrDelay(pDev, 2000000);
	
    if (status)
        return (RM_ERROR);
    return (RM_OK);
}

//****************************************************************************************
/*	Determine if monitor is DDC, and in doing so, get it ready to read the EDID or VDIF
	This means get it in DDC2 mode and send the address. Try addresses A0 and A2.
*/
RM_STATUS IsMonitorDDC(PHWINFO pDev, U032 Head, U032 dispType, U008 *dispAddr)
{
    RM_STATUS status;
    U008	Adr, Data;
    U032    i2cPortId;

    i2cPortId = getI2CPort(pDev, Head, dispType);
    // NV11 can drive a CRT on either head; earlier devices only on port 0.
    if (IsNV11(pDev) || (i2cPortId == 0))  
    {
        StopDDC1(pDev, Head, dispType);	// stop the CRT from driving the bus
    }

    // now monitor is in DDC2 mode; we can talk to it
    // send address 0 (start of EDID), no other data
    Adr = 0;
    *dispAddr = DDC_CRT_ADR1;
    if (dispType == DISPLAY_TYPE_MONITOR) {
        status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR1, 1, &Adr, 0, &Data);   // if it fails, its not DDC
    }
    else if (dispType == DISPLAY_TYPE_FLAT_PANEL)
    {
        // if flat panel, device address can be A0, A2, or A6 (50/51/53 shifted left)
	    status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR1, 1, &Adr, 0, &Data);   
        if (status)
        {
            *dispAddr = DDC_CRT_ADR2;
		    status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR2, 1, &Adr, 0, &Data);  
            if (status)
            {
                *dispAddr = DDC_CRT_ADR3;
    		    status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR3, 1, &Adr, 0, &Data);  
            }
        }
    }
    else
    {
        // not a DDC device
        status = RM_ERROR;
    }

    return status;
}

U032 edidGetVersion(PHWINFO pDev, U032 Head)
{
    U008 j, edidV1Head[] = {0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00};

    // check for version 1 edid header
    for (j = 0; j < 8; j++)
    {
        if (pDev->Dac.CrtcInfo[Head].EDID[j] != edidV1Head[j])
        {
            break;
        }
    }

    if (j == 8)
    {
        return 1;
    }

    if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_VERSION_NUMBER_INDEX] & 0xf0) == 0x20)
        return 2;

    return 0;	// Invalid or unknown EDID
}

//****************************************************************************************
/*	Checksum an EDID
 */
BOOL EDIDCheckSumOk(
    PHWINFO pDev, 
    U032    Head, 
    U008   *edid,
    U032    length,
    U008   *checksum
)
{
    U032 j;
    int  chksum;

    // This is version 1 header
    // checksum the block
    chksum = 0;

    for (j=0; j<length; j++)
        chksum += *edid++;
    *checksum = (U008) chksum; 
    return ((U008) chksum) == 0;
}

//****************************************************************************************
/*	Read EDID
    Read the EDID of the specified device into the caller's buffer
    The device is specified by the DWORD which is a bit map of up to 8 CRT's, 8 DFP's, and 8 TV's.
*/
RM_STATUS edidReadDevEDID(PHWINFO pDev, U032 device, U008 *pEdid)
{
    RM_STATUS    status = RM_ERROR;
#ifndef IKOS    // This is just too painfully slow
    int	    i,j;
    U008    block_ID;
    U032    i2cPortID, Head, dispType;
	U008 	dispAddr, chksum;



    status = dacGetDisplayInfo(pDev, device, &Head, &dispType, 0, 0);

    if (status != RM_OK)
    {
        return status;
    }

    dispType = edidTranslateDisplayType(dispType);

    if (dispType == DISPLAY_TYPE_NONE)
    {
        status = RM_ERROR;
        return status;
    }
    //
    // Look for EDID overrides for mobile operation
    //
    if (dispType == DISPLAY_TYPE_FLAT_PANEL && pDev->Power.MobileOperation)
    {
        status = edidConstructMobileInfo(pDev, Head, pEdid);
        if (status == RM_OK)
            return RM_OK;
    }

	// See if device supports DDC and which address it uses
    status = IsMonitorDDC(pDev, Head, dispType, &dispAddr);
    if (status != RM_OK)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
        // Monitor is not DDC compliant.
        goto done;
    }

    if (IsNV15(pDev) && (device == 0x2))        // CRT on DVI-I connector
        i2cPortID = getI2CPort(pDev, 1, dispType);
    else
        i2cPortID = getI2CPort(pDev, Head, dispType);

    for (i=0; i<DDC_RETRIES; i++)
    {
        block_ID = 0;
        // send a write command and read back a block 
        // NOTE: the device address is shifted up in our function (50->A0)
        status = i2cRead(pDev, Head, i2cPortID, dispAddr, 1, &block_ID, 128, pEdid);
        if (status == RM_OK)
        {
            // Check which version of the header. If it was version 2, we need to read
            // another 128 bytes.
            if (pEdid[0] == 0 && pEdid[1] == 0xff &&
                pEdid[EDID_V1_VERSION_NUMBER_INDEX] == 0x1)
            {
            	if (EDIDCheckSumOk(pDev, Head, pEdid, 128, &chksum))
            	    goto done;
            }
            else if ((pEdid[0] >> 4) == 2)
            {
                // This is a version 2 header. Read the next 128 byte block.
                block_ID = 128;
                // send a write command and read the next block 
                // NOTE: the device address is shifted up in our function (50->A0)
                status = i2cRead(pDev, Head, i2cPortID, dispAddr, 1, &block_ID, 128, 
                                 &(pEdid[128]));
                if (status == RM_OK)
	            	if (EDIDCheckSumOk(pDev, Head, pEdid, 256, &chksum))
	            	    goto done;
            }
    	}
        // if we failed, try to reset the slave
        for (j=0; j< 10; j++) 
        {
            i2cStart(pDev, Head, i2cPortID);
            tmrDelay(pDev, 10000);
            i2cStop(pDev, Head, i2cPortID);
            tmrDelay(pDev, 10000);
        }
    } // retry

    // if we fall out of the retry loop, then its an error
    status = RM_ERROR;
	
done:

#endif // defined IKOS

    return status;
}


//****************************************************************************************
/*	Read EDID
	dispType is the display we want to read, not necessarily the current device.
    This will alwasy return RM_OK, since we'll get the BIOS default EDID if none if found,
    UNLESS this if for mobile?
*/
RM_STATUS EDIDRead(PHWINFO pDev, U032 Head, U032 dispType)
{
    RM_STATUS    status = RM_ERROR;
#ifndef IKOS    // This is just too painfully slow
    int	    i,j;
    U008    block_ID;
    U032    i2cPortId;
    U008    dispAddr, chksum;
    U032    oldDDC;

    if (IsNV11(pDev)) 
    {
        oldDDC = CurrentHeadDDC(pDev);
        AssocDDC(pDev, Head);  // Connect the head to the I2C pins
    }
    
    //
    // Look for EDID overrides for mobile operation
    //
    if ((dispType == DISPLAY_TYPE_FLAT_PANEL) && pDev->Power.MobileOperation)
    {
        status = edidConstructMobileInfo(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID);
        if (status == RM_OK)
            goto done;
    }

	// See if device supports DDC and which address it uses
    status = IsMonitorDDC(pDev, Head, dispType, &dispAddr);
    if (status != RM_OK)
    {
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
   	    // Monitor is not DDC compliant.
        goto done;
    }

    i2cPortId = getI2CPort(pDev, Head, dispType);

    for (i=0; i<DDC_RETRIES; i++)
	{
        block_ID = 0;
        // send a write command and read back a block 
        // NOTE: the device address is shifted up in our function (50->A0)
        status = i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &block_ID, 128, pDev->Dac.CrtcInfo[Head].EDID);
        if (status == RM_OK)
        {
            U008 j, Edid_V1_Header[] = {0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00};
            // Check which version of the header. If it was version 2, we need to read
            // another 128 bytes.
            for (j=0; j<8; j++) 
            {
                if (pDev->Dac.CrtcInfo[Head].EDID[j] != Edid_V1_Header[j])
                    break;
            }
            if (j==8) 
            {
// There are monitors with non-zero checksums which we do not want to fail.
//            	if (EDIDCheckSumOk(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID, 128))
            	    goto done;
            }
            else if ((pDev->Dac.CrtcInfo[Head].EDID[0] >> 4) == 2)
            {
                // This is a version 2 header. Read the next 128 byte block.
                block_ID = 128;
                // send a write command and read the next block 
                // NOTE: the device address is shifted up in our function (50->A0)
                status = i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &block_ID, 128, 
                                 &(pDev->Dac.CrtcInfo[Head].EDID[128]));
                if (status == RM_OK)
	            	if (EDIDCheckSumOk(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID, 256, &chksum))
	            	    goto done;
            }
    	}
        // if we failed, try to reset the slave (may be hung up and not responding)
        for (j=0; j< 20; j++) 
        {
            i2cStart(pDev, Head, i2cPortId);
            tmrDelay(pDev, 20000);      // 20 us
            i2cStop(pDev, Head, i2cPortId);
            tmrDelay(pDev, 20000);
            // one last desparate measure 
            StopDDC1(pDev, Head, dispType);	// stop the CRT from driving the bus
            tmrDelay(pDev, 2000000);    // 2 ms
        }


    } // retry

	// if we fall out of the retry loop, then its an error
	status = RM_ERROR;
	
done:
    if (IsNV11(pDev))
    {
        AssocDDC(pDev, oldDDC); //restore previous DDC owner
    }
#endif // defined IKOS

    return status;
}

//****************************************************************************************
/*	See if a device has an EDID 
	dispType is the display we want to read, not necessarily the current device.
*/
RM_STATUS EDIDDetect(PHWINFO pDev, U032 Head, U032 dispType)
{
#ifndef IKOS    // This is just too painfully slow
    int	    i;
    RM_STATUS    status;
    U008    block_ID, lock;
    U032    i2cPortId;
    U008    dispAddr;
    U008    EdidBuffer[128];
    U032    oldDDC;

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);
    
    if (IsNV11(pDev)) 
    {
        oldDDC = CurrentHeadDDC(pDev);
        AssocDDC(pDev, Head);  // Connect the head to the I2C pins
    }

    if (dispType == DISPLAY_TYPE_FLAT_PANEL && pDev->Power.MobileOperation)
    {
        //!!!We have to check here is it really flat panel???
        status = RM_OK;
        goto   done;
    }

	// See if device supports DDC and which address it uses
    if (IsMonitorDDC(pDev, Head, dispType, &dispAddr) != RM_OK)
    {
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
   	    // Monitor is not DDC compliant.
        status = RM_ERROR;
        goto done;
    }

    i2cPortId = getI2CPort(pDev, Head, dispType);

    for (i=0; i<DDC_RETRIES; i++)
	{
        block_ID = 0;
        // send a write command and read back a block (at least 0x50 bytes to get version 2 display technology byte).
        // NOTE: the device address is shifted up in our function (50->A0)
        status = i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &block_ID, 0x50, EdidBuffer);
        if (status == RM_OK)
        {
            // Check which version of the header. If it was version 2,
            if (EdidBuffer[0] == 0 && EdidBuffer[1] == 0xff &&
                EdidBuffer[EDID_V1_VERSION_NUMBER_INDEX] == 0x1)
            {
                // This is version 1 header, get video input definition
                if (EdidBuffer[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7))     // digital device?
                {
                    if (dispType == DISPLAY_TYPE_FLAT_PANEL) 
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
                else
                {
                    if (dispType == DISPLAY_TYPE_MONITOR)                   // we're looking for analog
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
            }
            else if ((EdidBuffer[0] >> 4) == 2)
            {
                // This is a version 2 header.
                if ((EdidBuffer[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) == 0) // analog device?
                {
                    if (dispType == DISPLAY_TYPE_MONITOR)                   // we're looking for analog
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
                else
                {
                    if (dispType == DISPLAY_TYPE_FLAT_PANEL) 
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
            }
            else
            {
                // Unknown edid header.
                status = RM_ERROR;
            }
    	} // Successfully read the first 128 byte block.
    } // retry

done:    
    if (IsNV11(pDev))
    {
        AssocDDC(pDev, oldDDC); //restore previous DDC owner
    }

    RestoreLock(pDev, Head, lock);

    return status;
#else   // defined IKOS
    return RM_ERROR;
#endif  // IKOS
}

//****************************************************************************************
/*	Read VDIF
	VDIF follows after last EDID block, so to read a VDIF block we need to get the
	number of EDID blocks (*128) and add the VDIF block (*64)
*/
RM_STATUS ReadVDIF(PHWINFO pDev, U032 Head, U032 dispType, U008 *buffer, U008 device, U008 address)
{
    int     i;
    RM_STATUS  status;
    U008    Adr;
    U032    i2cPortId;

// FILL IN THIS !!!

    // get number of EDID blocks

    // calc VDIF block address

    // read VDIF
    i2cPortId = getI2CPort(pDev, Head, dispType);
    status = RM_OK;       /* macosX's version of gcc thinks 'status' may not be init before use */
    for (i=0; i<DDC_RETRIES; i++)
    {
        // send a write command and read back a block (NOTE: the device address is shifted up in our function, so 50->A0)
        status = i2cRead(pDev, Head, i2cPortId, 0x50, 0, &Adr, 128, buffer);
        if (status == RM_OK)
            break;		
    }

    return (status);
}

RM_STATUS ReadAnyEdidBlock(PHWINFO pDev, U032 Head, U032 dispType, U016 ByteAddress, U008 *VesaDataBuffer)
{
    U008 dispAddr;
    RM_STATUS status;
    U032 i2cPortId;
    U032 retry_count;
    U008 RealByteAddress;
    U008 RealSegmentAddress;
    U008 LockStat;
    U032 oldDDC;

    LockStat=UnlockCRTC(pDev, Head);

    //Connect the head to the I2C pins
    if (IsNV11(pDev)) 
    {
        oldDDC = CurrentHeadDDC(pDev);
        AssocDDC(pDev, Head);
    }
    
    // See if device supports DDC and which address it uses
    status = IsMonitorDDC(pDev, Head, dispType, &dispAddr);
    
    if (status != RM_OK)
    {
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
   	    // Monitor is not DDC compliant.
        goto done;
    }
    
    if(ByteAddress>128)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Byte Address greater than 128 specified ", Head);
        
        status=RM_ERROR;
        
        goto done;
    }
    
    //the true byte address cannot exceed 255, in the future I will implement the segment access code
    RealByteAddress=(U008)(ByteAddress%256);
    
    //calculate the segment address
    RealSegmentAddress=(U008)(ByteAddress/256);
    
    //be sure the segment does not exceed 0x7f (EDDCv1.pdf Version 1 of the Enhanced DDC spec for retrieving > 256 EDIDs)
    RealSegmentAddress=(U008)((RealSegmentAddress>0x7f)?0:RealSegmentAddress);
    
    i2cPortId = getI2CPort(pDev, Head, dispType);
   
    retry_count=0;
    
    //do read
    do
    {
        //if segment is not zero, set the segment here (segment set is not currently implemented)
        
        /*
        //note, at this rev, we can't actually get the next chunk. Most of the infrastructure is here though
        status=i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &RealByteAddress, 128,VesaDataBuffer);
        */
        
        status=i2cRead_EDDC(pDev, Head, i2cPortId, RealSegmentAddress, dispAddr, RealByteAddress, 128, VesaDataBuffer);

        
    }while((++retry_count!=DDC_RETRIES)&&(status!=RM_OK));
    
    //we do not verify checksum here, as if the user is retrieving a V2 or V3 EDID, the checksum may not fall at 127
    
done:
    if (IsNV11(pDev))
    {
        AssocDDC(pDev, oldDDC); //restore previous DDC owner
    }

    RestoreLock(pDev,Head,LockStat);

    return status;
}

// Checks to see if the EDID is present in the pDev and if it matches a valid version.
// The version and revision is returned, as well as a pointer to the requested EDID buffer.
static BOOL EDIDIsValid
(
    PHWINFO pDev,
    U008    **edidPtr,
    U032    *version,
    U032    *revision,
    U032    Head
)
{
    U008 *edid;


    edid = pDev->Dac.CrtcInfo[Head].EDID;
    // Check the version of the edid header.
	if (!(edid[0] == 0 && edid[1] == 0xff))
	{
		// this is not version 1 edid header
		// check if it is version 2 header.
        // Bits 7-4 of byte 0 is the version and bits 3-0 of byte 0 is the revision
		if (((edid[0] & 0xf0) >> 4) == 2)
		{
            *version = 2;
            *revision = edid[0] & 0x0f;
            *edidPtr = edid;
            return TRUE;
		}

		// Unknown edid header.
        return FALSE;
	}

    // Check for version 1 edid header.
    if (edid[EDID_V1_VERSION_NUMBER_INDEX] == 1)
    {
        *version = 1;
        *revision = edid[EDID_V1_REVISION_NUMBER_INDEX];
        *edidPtr = edid;
        return TRUE;
    }

    // Unknown edid header.
    return FALSE;

}

// Checks to see if the EDID is present in the pDev and if it matches a valid version.
// The version and revision is returned, as well as a pointer to the requested EDID buffer.
BOOL edidLogicalEDIDIsValid
(
    U008    **edidPtr,
    U032    *version,
    U032    *revision
)
{
    U008 *edid;


    edid = *edidPtr;
    // Check the version of the edid header.
	if (!(edid[0] == 0 && edid[1] == 0xff))
	{
		// this is not version 1 edid header
		// check if it is version 2 header.
        // Bits 7-4 of byte 0 is the version and bits 3-0 of byte 0 is the revision
		if (((edid[0] & 0xf0) >> 4) == 2)
		{
            *version = 2;
            *revision = edid[0] & 0x0f;
            *edidPtr = edid;
            return TRUE;
		}

		// Unknown edid header.
        return FALSE;
	}

    // Check for version 1 edid header.
    if (edid[EDID_V1_VERSION_NUMBER_INDEX] == 1)
    {
        *version = 1;
        *revision = edid[EDID_V1_REVISION_NUMBER_INDEX];
        *edidPtr = edid;
        return TRUE;
    }

    // Unknown edid header.
    return FALSE;

}

static RM_STATUS EDIDV1Copy
(
    PHWINFO pDev,
    U008    *edid,
    U008    *buffer,
    U032    *bufLen
)
{
    // version 1
    if (*bufLen < EDID_V1_SIZE)
    {
        // There is not enough space in the buffer.
        *bufLen = 0;
        return RM_ERROR;
    }

    // There is enough space in the buffer.
    *bufLen = EDID_V1_SIZE;

	osMemCopy((U008*) buffer, (U008*) edid, *bufLen);
    return RM_OK;
}

static RM_STATUS EDIDV2Copy
(
    PHWINFO pDev,
    U008    *edid,
    U008    *buffer,
    U032    *bufLen
)
{
    // Version 2
    if (*bufLen < EDID_V2_SIZE)
    {
        // There is not enough space in the buffer.
        *bufLen = 0;
        return RM_ERROR;
    }

    // There is enough space in the buffer.
    *bufLen = EDID_V2_SIZE;
    
    osMemCopy((U008*) buffer, (U008*) edid, *bufLen);
    return RM_OK;
}

// This function copies the edid from the pDev into the buffer passed.
// Currently only version 1 edid header is supported.
RM_STATUS EDIDCopy
(
    PHWINFO pDev,
    U008    *buffer,
    U032    *bufLen,
    U032    Head
)
{
    U032 edidVersion, edidRevision;
    U008 *edid;

    if (!EDIDIsValid(pDev, &edid, &edidVersion, &edidRevision, Head)) // verify EDID and get a pointer to it
    {
        // edid not valid
        *bufLen = 0;
        return RM_ERROR;
    }

    if (edidVersion == 1)
    {
        return EDIDV1Copy (pDev, edid, buffer, bufLen);
    }
    else if (edidVersion == 2)
    {
        return EDIDV2Copy (pDev, edid, buffer, bufLen);
    }

    // Unknown edid header.
    *bufLen = 0;
    return RM_ERROR;
} // end of EDIDCopy

#if 0 // no one calling this, so turn it off 
static RM_STATUS EDIDV1GetMaxRefreshRate
(
    PHWINFO pDev,
    U008   *edid,
    U032    hRes,
    U032    vRes,
    U032   *maxRefreshRate
)
{
    U032      i, j, tmpHRes, tmpVRes = ~0, tmpRefresh;

    *maxRefreshRate = 0;
    // Get the max from the established timing section
    switch (hRes)
    {
        case 720:
            if (vRes == 400)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x40)
                {
                    // Supports 720x400 @ 88Hz.
                    *maxRefreshRate = 88;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x80)
                {
                    // supports 720x400 @ 70Hz
                    *maxRefreshRate = 70;
                }

            }
            break;
        case 640:
            if (vRes == 480)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x04)
                {
                    // Supports 640x480 @ 75Hz.
                    *maxRefreshRate = 75;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x08)
                {
                    // supports 640x480 @ 72Hz
                    *maxRefreshRate = 72;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x10)
                {
                    // supports 640x480 @ 67Hz
                    *maxRefreshRate = 67;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x20)
                {
                    // supports 640x480 @ 60Hz
                    *maxRefreshRate = 60;
                }
            }
            break;
        case 800:
            if (vRes == 600)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x40)
                {
                    // Supports 800x600 @ 75Hz.
                    *maxRefreshRate = 75;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x80)
                {
                    // supports 800x600 @ 72Hz
                    *maxRefreshRate = 72;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x01)
                {
                    // supports 800x600 @ 60Hz
                    *maxRefreshRate = 60;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x02)
                {
                    // supports 800x600 @ 56Hz
                    *maxRefreshRate = 56;
                }
            }
            break;
        case 832:
            if (vRes == 624)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x20)
                {
                    // Supports 832x624 @ 75Hz.
                    *maxRefreshRate = 75;
                }
            }
            break;
        case 1024:
            if (vRes == 768)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x10)
                {
                    // Supports 1024x768 @ 87Hz
                    *maxRefreshRate = 87;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x02)
                {
                    // supports 1024x768 @ 75Hz
                    *maxRefreshRate = 75;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x04)
                {
                    // supports 1024x768 @ 70Hz
                    *maxRefreshRate = 70;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x08)
                {
                    // supports 1024x768 @ 60Hz
                    *maxRefreshRate = 60;
                }
            }
            break;
        case 1280:
            if (vRes == 1024)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x01)
                {
                    // Supports 1280x1024 @ 75Hz
                    *maxRefreshRate = 75;
                }
            }
            break;
        case 1152:
            if (vRes == 870)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_3_INDEX] & 0x80)
                {
                    // Supports 1152x870 @ 75Hz 
                    *maxRefreshRate = 75;
                }
            }
            break;
        default:
            break;
    } // switch on hRes


    // Now check the standard timings to see if there is a higher refresh rate specified.
   	for (i = 0; i < 8; i++)
	{
		if (edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i * 2)] != 0x01)
		{
			// there is a standard timing specification.
			tmpHRes = (edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i*2)] + 31) * 8;
			tmpRefresh = (edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i*2) + 1] & 0x3f) + 60;
			switch ((edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i*2) + 1] & 0xc0) >> 6)
			{
			case 0x0:
				// aspect ratio 1:1
				tmpVRes = tmpHRes;
				break;
			case 0x1:
				// aspect ratio 4:3
				tmpVRes = (tmpHRes * 3) / 4;
				break;
			case 0x2:
				// aspect ratio 5:4
				tmpVRes = (tmpHRes * 4) / 5;
				break;
			case 0x3:
				// aspect ratio 16:9
				tmpVRes = (tmpHRes * 9) / 16;
				break;
			}

            // Check if this standard timing matches the resolution we want.
            if (tmpHRes == hRes && tmpVRes == vRes)
            {
                // Resolution matches. 
                // If this refresh rate is > than the one found in established timings, use it.
                if (tmpRefresh > *maxRefreshRate)
                {
                    *maxRefreshRate = tmpRefresh;
                }
            }
		} // A valid standard timing spec
	} // iterate over all 8 standard timings

    // Now check the detailed timing specification for a macting resolution.
	for (i = 0; i < 4; i++)
	{
		int startIndex = EDID_V1_DETAILED_TIMINGS_START_INDEX + (i * EDID_V1_DETAILED_TIMINGS_SIZE);
		if (edid[startIndex] == 0 && edid[startIndex + 1] == 0)
		{
			// This is a Monitor descriptor instead of a detailed timing descriptor.
			switch (edid[startIndex + 3])
			{
                case 0xFA:
                    // Descriptor contains 6 additional standard timing identifications
                    for (j = 0; j < 6; j++)
                    {
                        if (edid[startIndex + 5 + (j * 2)] != 0x01)
                        {
                            // there is a standard timing specification.
                            tmpHRes = (edid[startIndex + 5 + (j*2)] + 31) * 8;
                            tmpRefresh = (edid[startIndex + 5 + (j*2) + 1] & 0x3f) + 60;
                            switch ((edid[startIndex + 5 + (j*2) + 1] & 0xc0) >> 6)
                            {
                            case 0x0:
                                // aspect ratio 1:1
                                tmpVRes = tmpHRes;
                                break;
                            case 0x1:
                                // aspect ratio 4:3
                                tmpVRes = (tmpHRes * 3) / 4;
                                break;
                            case 0x2:
                                // aspect ratio 5:4
                                tmpVRes = (tmpHRes * 4) / 5;
                                break;
                            case 0x3:
                                // aspect ratio 16:9
                                tmpVRes = (tmpHRes * 9) / 16;
                                break;
                            } // switch on aspect ratio

                            // Check if this standard timing matches the resolution we want.
                            if (tmpHRes == hRes && tmpVRes == vRes)
                            {
                                // Resolution matches. 
                                // If this refresh rate is > than the one found in established timings, use it.
                                if (tmpRefresh > *maxRefreshRate)
                                {
                                    *maxRefreshRate = tmpRefresh;
                                }
                            }
                        } // a valid standard timing spec
                    } // iterate over the 6 additional standard timings
                    break;
                default:
                    break;
			}
		} // monitor descriptor.
		else
		{
			// This is a detailed timing descriptor.
            // The detailed timing specification does not include the refresh rate.
			U032 pixelClock;
			U032 hActive, vActive, hBlank, vBlank;
			U032 hTotal, vTotal;


			hActive = edid[startIndex + 2] | ((edid[startIndex + 4] & 0xf0) << 4);
			vActive = edid[startIndex + 5] | ((edid[startIndex + 7] & 0xf0) << 4);
            if (hActive == hRes && vActive == vRes)
            {
                // Resolution matches the detailed spec.
                // Get the rest of the detailed timing info needed to calculate the refresh rate.
                pixelClock = edid[startIndex] | (edid[startIndex + 1] << 8);
                hBlank  = edid[startIndex + 3] | ((edid[startIndex + 4] & 0x0f) << 8);
                vBlank  = edid[startIndex + 6] | ((edid[startIndex + 7] & 0x0f) << 8);

                // Horizontal Total (hActive + hBlank) gives # of pixels / line
                // Vertical total (vActive + vBlank) gives # of lines / frame
                // so HT * VT = total # pixels per frame.
                // Pixel clock is # pixels drawn / sec
                // so pixelClock / (HT * VT) gives the refresh rate (frames / sec).
                hTotal = hActive + hBlank;
                vTotal = vActive + vBlank;
                pixelClock = pixelClock * 10000;
                tmpRefresh = pixelClock / (hTotal * vTotal);

                if (tmpRefresh > *maxRefreshRate)
                {
                    *maxRefreshRate = tmpRefresh;
                }
            } // resolution matches the detailed spec
		} // This is a detailed timing spec
	} // parse detailed section

    return RM_OK;
}

static RM_STATUS EDIDV2GetMaxRefreshRate
(
    PHWINFO pDev,
    U008   *edid,
    U032    hRes,
    U032    vRes,
    U032   *maxRefreshRate
)
{
    U032 lumTabSize, numLumTables;
    U032 numFreqRanges, numDetailedRanges, numTimingCodes, numDetailedTimings;
    U032 detailedTimingIndex, timingCodesIndex;
    U008 timingMap1, timingMap2;
    U032 index, i;

    // We need to look in the 4-byte timing codes section and the detailed timing section for
    // the given resolution.

    // The way the 127 byte detailed information is used is given by reading bytes 0x7e and 0x7f.
    // The size and the order of the 127 byte timing section that start at byte 0x80 is:
    // x*A + 8*B + 27*c + 4*D + 18*E where
    // A = number of luminance tables (0 or 1), (given by byte 0x7e bit 5)
    // x = size of the luminance table (given by the first byte of the table itself)
    // B = number of frequency rages listed (0-7), (given by bits 4-2 of byte 0x7e)
    // C = number of detailed rage limits (0-3), (given by (bits 1-0 of byte 0x7e)
    // D = number of timing codes (0-31), (given by bits 7-3 of byte 0x7f)
    // E = number of detailed timing descriptions (0-7) (given by bits 2-0 of byte 0x7f)
    timingMap1 = edid[EDID_V2_TIMING_MAP1_INDEX];
    timingMap2 = edid[EDID_V2_TIMING_MAP2_INDEX];
    numLumTables       = (timingMap1 & 0x20) >> 5; // Bit 5
    numFreqRanges      = (timingMap1 & 0x1C) >> 2; // Bits 4-2
    numDetailedRanges  = (timingMap1 & 0x03);      // Bits 1-0
    numTimingCodes     = (timingMap2 & 0xf8) >> 3; // Bits 7-3
    numDetailedTimings = (timingMap2 & 0x07);      // Bits 2-0
    if (numLumTables != 0)
    {
        // Calculate the size of the lum table by reading byte 0x80
        U032 numLumValues;

        numLumValues = edid[EDID_V2_TIMING_SECTION_START_INDEX] & 0x1f; // bits 4-0
        if (edid[EDID_V2_TIMING_SECTION_START_INDEX] & 0x80)
        {
            // size of lum table is ((3 * numLumValues) + 1) bytes
            lumTabSize = 3 * numLumValues + 1;
        }
        else
        {
            // size of lum table is (numLumValues + 1) bytes
            lumTabSize = numLumValues + 1;
        }
    }
    else
        lumTabSize = 0;

    timingCodesIndex = EDID_V2_TIMING_SECTION_START_INDEX 
                       + lumTabSize 
                       + (8 * numFreqRanges)
                       + (27 * numDetailedRanges);
    detailedTimingIndex = timingCodesIndex + (8 * numTimingCodes);

    *maxRefreshRate = 0;

    {
        // Look in the timing codes section.
        U032 hActive;
        U032 aspectRatio;
        U032 vActive;
        for (i = 0; i < numTimingCodes; i++)
        {
            index = timingCodesIndex + (4 * i);
            hActive = (edid[index] * 16) + 256;
            aspectRatio = edid[index + 2];
            // Aspect ratio is stored in terms of N:100.
			// This is not very useful because we don't get the standard vertical values.
			// So we will use the standard aspect ratios whenever we can.
			switch (aspectRatio)
			{
			case 133:
				// 4:3
				vActive = (hActive * 3) / 4;
				break;
			case 125:
				// 5:4
				vActive = (hActive * 4) / 5;
				break;
			case 177:
				// 16:9
				vActive = (hActive * 9) / 16;
				break;
			default:
                vActive = (hActive * 100) / aspectRatio;
				break;
			}
            if (hActive == hRes && vActive == vRes)
            {
                // This is the needed resolution.
                if (edid[index + 3] > *maxRefreshRate)
                {
                    *maxRefreshRate = edid[index + 3];
                }
            } // resolution matches
        } // loop over all the timing codes
    } // look in timing codes

    {
        // look in the detailed timing section
        // The detailed timing specification does not include the refresh rate.
        U032 pixelClock;
        U032 hActive, vActive, hBlank, vBlank;
        U032 hTotal, vTotal;
        U032 tmpRefresh;

        for (i = 0; i < numDetailedTimings; i++)
        {
            index = detailedTimingIndex + (18 * i);
            hActive = edid[index + 2] | ((edid[index + 4] & 0xf0) << 4);
            vActive = edid[index + 5] | ((edid[index + 7] & 0xf0) << 4);
            if (hActive == hRes && vActive == vRes)
            {
                // Resolution matches the detailed spec.
                // Get the rest of the detailed timing info needed to calculate the refresh rate.
                pixelClock = edid[index] | (edid[index + 1] << 8);
                hBlank  = edid[index + 3] | ((edid[index + 4] & 0x0f) << 8);
                vBlank  = edid[index + 6] | ((edid[index + 7] & 0x0f) << 8);

                // Horizontal Total (hActive + hBlank) gives # of pixels / line
                // Vertical total (vActive + vBlank) gives # of lines / frame
                // so HT * VT = total # pixels per frame.
                // Pixel clock is # pixels drawn / sec
                // so pixelClock / (HT * VT) gives the refresh rate (frames / sec).
                hTotal = hActive + hBlank;
                vTotal = vActive + vBlank;
                pixelClock = pixelClock * 10000;
                tmpRefresh = pixelClock / (hTotal * vTotal);

                if (tmpRefresh > *maxRefreshRate)
                {
                    *maxRefreshRate = tmpRefresh;
                }
            } // resolution matches the detailed spec
        } // loop over all the detailed timing specs
    } // look in detailed timing section

    return RM_OK;
}
#endif  // #if 0; no one calling this puppy


// EDID Version 1.3
// Super set of 1.2, allows range limits descriptor to define coeficients for secondary GTF curve,
// and mandates a certain set of monitor descriptors.
RM_STATUS ParseEDID13(PHWINFO pDev, U032 Head)
{
	return ParseEDID11(pDev, Head);	// we can probably treat it the same as rev 1.1
}

// EDID Version 1.2
RM_STATUS ParseEDID12(PHWINFO pDev, U032 Head)
{
	return ParseEDID11(pDev, Head);	// we can probably treat it the same as rev 1.1
}

//	Parse a detailed timing block in the current EDID
//	The EDID has been saved in the global device data structure (nvInfo).
//	When native mode is requested, it is necessary to find the correct detailed timing;
//  otherwise fpParseEDID will be used to get timing info.
U032 edidParseDetailedTimingBlock(PHWINFO pDev, U008 block, PDACFPTIMING fpTim, U032 Head)
{
	switch (pDev->Dac.CrtcInfo[Head].EdidVersion)
	{
		case EDID_VERSION_10:
		case EDID_VERSION_11:
		case EDID_VERSION_12:
		case EDID_VERSION_13:
			return edidParseDetailed1(pDev, block, fpTim, Head);
		case EDID_VERSION_20:
			return edidParseDetailed2(pDev, block, fpTim, Head);
	}

	return(0);
}

//	Parse a specific detailed timing block for EDID version 1.x
//  Detailed timings are at a fixed offset from the start of the buffer.
U032 edidParseDetailed1(PHWINFO pDev, U008 block, PDACFPTIMING fpTim, U032 Head)
{
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW, offset;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags;
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;

		// detailed timing block is 18 (0x12) bytes starting at offset 0x36.
		pClk = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block];
		pClk |= (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block + 1])<<8;
		if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
		{
			// Seems valid, get info
			offset = EDID_V1_DETAILED_TIMINGS_START_INDEX + (18 * block);
			HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
			HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
			HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
			VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
			VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
			VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
			HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
			HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
			VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
			SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
			Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

			// Get timing into useful format
			HRes = HActive1 | (HActive2 & 0xf0)<<4;
			VRes = VActive1 | (VActive2 & 0xf0)<<4;
			HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
			VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
			HTotal = HRes + HBlank;
			VTotal = VRes + VBlank;
			HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
			HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
			VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<2;
			VSyncPulse = (VSyncOff1 & 0xf) | (SyncOvf & 0x30)<<4;

			// Return this resolution
			fpTim->PixClk = pClk;
			fpTim->HActive = HRes;
 			fpTim->HDispEnd = HRes - 1;
			fpTim->HValidEnd = HRes - 1;
	 		fpTim->HSyncStart = HSyncOffset + fpTim->HDispEnd;
 			fpTim->HSyncEnd = HSyncPulse + fpTim->HSyncStart;
 			fpTim->HValidStart = 0;
	 		fpTim->HTotal = HTotal;
				
	 		fpTim->VActive = VRes;
 			fpTim->VDispEnd = VRes - 1;
 			fpTim->VValidEnd = VRes - 1;
	 		fpTim->VSyncStart =  VSyncOffset + fpTim->VDispEnd;
	 		fpTim->VSyncEnd = VSyncPulse + fpTim->VSyncStart;
 			fpTim->VValidStart = 0;
 			fpTim->VTotal = VTotal;
			fpTim->Flags = Flags;	// includes sync polarities
			return TRUE;
		}
		return FALSE;
} // edidParseDetailedTimingBlock

// Parse detailed timings for EDID Version 2.x
// This gets a specific timing block.
// For version 2, we have to parse from the start to find the location of the block.
U032 edidParseDetailed2(PHWINFO pDev, U008 block, PDACFPTIMING fpTim, U032 Head)
{
U008	map1, map2, index, lum, rangeLimits, detailedRangeLimits;
U008	detailedTimings, timingCodes, timingCode[4];
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW, offset;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags, i;
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;

	map1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX];
	map2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX+1];
	index =  EDID_V2_TIMING_SECTION_START_INDEX;
	// if there is a lum table, bump index beyond
	if (map1 & EDID_V2_LUM_TABLE_EXIST)
	{
		// 1st byte in timing section gives # of bytes in lum table
		lum = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_SECTION_START_INDEX];
		if (lum & TRIPLE_LUM_ENTRIES)
			index += (lum & NUM_LUM_ENTRIES*3) + 1;
		else
			index += (lum & NUM_LUM_ENTRIES) + 1;
	}
	// if there are timing range limits, bump index
	if ((rangeLimits = (map1 & EDID_V2_FREQ_RANGES)>>EDID_V2_FREQ_RANGE_SHIFT))
		index += rangeLimits * 8;
	// if there are detailed range limits, bump index
	if ((detailedRangeLimits = map1 & EDID_V2_DETAILED_RANGE_LIMITS))
		index += detailedRangeLimits * 27;
	// if there are timing codes, save them
	if ((timingCodes = (map2 & EDID_V2_TIMING_CODES)>>EDID_V2_TIMING_CODES_SHIFT))
		for (i=0; i!=timingCodes; i++)
		{
			timingCode[i] = pDev->Dac.CrtcInfo[Head].EDID[index];
			timingCode[i+1] = pDev->Dac.CrtcInfo[Head].EDID[index+1];
			timingCode[i+2] = pDev->Dac.CrtcInfo[Head].EDID[index+2];
			timingCode[i+3] = pDev->Dac.CrtcInfo[Head].EDID[index+3];
			index += 4;
		}
	// now index points to the detailed timings (if present)
	if ((detailedTimings = (map2 & EDID_V2_DETAILED_TIMINGS)))
	{
		// detailed timing block is 18 (0x12) bytes starting at offset 0x36.
		pClk = pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block];
		pClk |= (pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block + 1])<<8;
		if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
		{
			// Seems valid, get info
			offset = index + 18 * block;
			HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
			HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
			HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
			VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
			VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
			VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
			HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
			HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
			VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
			SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
			Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

			// Get timing into useful format
			HRes = HActive1 | (HActive2 & 0xf0)<<4;
			VRes = VActive1 | (VActive2 & 0xf0)<<4;
			HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
			VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
			HTotal = HRes + HBlank;
			VTotal = VRes + VBlank;
			HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
			HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
			VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<2;
			VSyncPulse = (VSyncOff1 & 0x0f) | (SyncOvf & 0x30)<<4;

			// Return this resolution
			fpTim->PixClk = pClk;
			fpTim->HActive = HRes;
	 		fpTim->HDispEnd = HRes - 1;
			fpTim->HValidEnd = HRes - 1;
	 		fpTim->HSyncStart = HSyncOffset + fpTim->HDispEnd;
	 		fpTim->HSyncEnd = HSyncPulse + fpTim->HSyncStart;
	 		fpTim->HValidStart = 0;
	 		fpTim->HTotal = HTotal;
				
	 		fpTim->VActive = VRes;
	 		fpTim->VDispEnd = VRes - 1;
	 		fpTim->VValidEnd = VRes - 1;
	 		fpTim->VSyncStart =  VSyncOffset + fpTim->VDispEnd;
	 		fpTim->VSyncEnd = VSyncPulse + fpTim->VSyncStart;
	 		fpTim->VValidStart = 0;
	 		fpTim->VTotal = VTotal;

			fpTim->Flags = Flags;
			return RM_OK;
		} // if 
	} // if detailed timings
	// check 4 byte timing codes

	return RM_ERROR;	// not supported yet
}

// EDID Version 2.0 
// Get flat panel timing from 4 byte timing code
// Use VESA GTF timing.
RM_STATUS GetTimingFromCode(U008 code, PDACFPTIMING fpTim)
{
U016	HorizCode;

	// We should be able to determine the mode from the first byte only, UNLESS
	// we start seeing panels with variable refresh rates.
	// byte 1: active pixels/line (pixels - 256)/16. Range = 256-4336.
	// byte 2: arcane info, don't know what it means. See EDID standard.
	// byte 3: aspect ration H:V.
	// byte 4: refresh rate.
	HorizCode = code * 16 + 256;
	fpTim->Flags = 0;	// sync polarities: neg, neg
	switch (HorizCode)
	{
		case 1280:
			// 1280x1024x75;
			fpTim->HActive = 1280;
			fpTim->HDispEnd = 1279;
			fpTim->HValidStart = 0;
			fpTim->HValidEnd = 1279;
			fpTim->HSyncStart = 1280+15;
			fpTim->HSyncEnd = 1280+15+2;
			fpTim->HTotal = 1280+320;
			fpTim->VActive = 1024;
			fpTim->VDispEnd = 1023;
			fpTim->VValidStart = 0;
			fpTim->VValidEnd = 1023;
			fpTim->VSyncStart = 1023+2;
			fpTim->VSyncEnd = 1023+2+24;
			fpTim->VTotal = 1024+40;
			fpTim->PixClk = 10800;	// 108 MHz
			fpTim->Flags = VSYNC_POS | HSYNC_POS;

			break;
		case 1024:
			fpTim->HActive = 1024;
			fpTim->HDispEnd = 1023;
			fpTim->HValidStart = 0;
			fpTim->HValidEnd = 1023;
			fpTim->HSyncStart = 1040;
			fpTim->HSyncEnd = 1089;
			fpTim->HTotal = 1344;
			fpTim->VActive = 768;
			fpTim->VDispEnd = 767;
			fpTim->VValidStart = 0;
			fpTim->VValidEnd = 767;
			fpTim->VSyncStart = 770;
			fpTim->VSyncEnd = 776;
			fpTim->VTotal = 805;
			fpTim->PixClk = 6500;	// 65 MHz
			fpTim->Flags = VSYNC_NEG | HSYNC_NEG;
			break;
		case 800:
			fpTim->HActive =  800;
			fpTim->HDispEnd = 799;
			fpTim->HValidStart = 0;
			fpTim->HValidEnd = 799;
			fpTim->HSyncStart = 799+16;
			fpTim->HSyncEnd =  799+16+24;
			fpTim->HTotal = 800+320;
			fpTim->VActive = 600;
			fpTim->VDispEnd = 599;
			fpTim->VValidStart = 0;
			fpTim->VValidEnd =  599;
			fpTim->VSyncStart = 599+2;
			fpTim->VSyncEnd = 599+2+24;
			fpTim->VTotal = 600+38;
			fpTim->PixClk = 4000;	// 40 MHz
			fpTim->Flags = VSYNC_POS | HSYNC_POS;
			break;
		default:
			return RM_ERROR;
	}
	return RM_OK;
}
							
// EDID Version 1.1
// Return error if no valid resolution found
RM_STATUS ParseEDID11(PHWINFO pDev, U032 Head)
{
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;
U008	est_tim1, est_tim2, block, offset, mode_count;
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags;
U032	est_tim_total, i;

	// Look for multiple resolutions in established timings to see if it supports native mode.
	// meaning the monitor can do the scaling.
 	est_tim1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_ESTABLISHED_TIMING_1_INDEX];
 	est_tim2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_ESTABLISHED_TIMING_2_INDEX];
	est_tim_total = est_tim1 | (est_tim2<<8);
	mode_count = 0;
	pDev->Dac.fpNative = 0;
	for (i=1; i<0x10000; i<<=1)
		if (est_tim_total & i)
			mode_count++;
	if (mode_count > 1)	// if more than 1 mode, monitor supports native mode.
		pDev->Dac.fpNative = 1;

	// We'll check detailed timings first. If none, look for established timings.
	// Search for largest resolution. 
	// NEED TO ADD: There could be extensions in next EDID block, too.
	pDev->Dac.fpHActive = 0;
	mode_count = 0; // check again--multiple detailed timing block also indicates native
	for (block = 0; block <4; block++)
	{
		// detailed timing block is 18 (0x12) bytes starting at offset 0x36.
		pClk = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block];
		pClk |= (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block + 1])<<8;
		if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
		{
			// Seems valid, get info
			offset = EDID_V1_DETAILED_TIMINGS_START_INDEX + (18 * block);
			HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
			HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
			HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
			VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
			VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
			VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
			HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
			HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
			VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
			SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
			Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

			// Get timing into useful format
			HRes = HActive1 | (HActive2 & 0xf0)<<4;
			VRes = VActive1 | (VActive2 & 0xf0)<<4;
			HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
			VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
			HTotal = HRes + HBlank;
			VTotal = VRes + VBlank;
			HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
			HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
			VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<2;
			VSyncPulse = (VSyncOff1 & 0x0f) | (SyncOvf & 0x30)<<4;
#if 0
			// Do some error checking
			if ((HRes + HSyncOffset + HSyncPulse) > (HTotal))
			{
				HSyncPulse &= 0x0f;		// pulse is too wide
				if (HSyncPulse == 0)
					HSyncPulse = 24;		// should work
			}
			if ((VRes + VSyncOffset + VSyncPulse) > (VTotal))
			{
				HSyncPulse &= 0x0f;		// pulse is too wide
				if (VSyncPulse == 0)
					VSyncPulse = 24;		// should work
			}
#endif
			if (HRes > pDev->Dac.fpHActive)	// largest yet?
			{
				// Does this fp support native mode?
				mode_count++;	
				if (mode_count > 1)
					pDev->Dac.fpNative = 1;	
				// Save this resolution as potential maximum.
				pDev->Dac.fpPixClk = pClk;
				pDev->Dac.fpHActive = HRes;
		 		pDev->Dac.fpHDispEnd = HRes - 1;
				pDev->Dac.fpHValidEnd = HRes - 1;
		 		pDev->Dac.fpHSyncStart = HSyncOffset + pDev->Dac.fpHDispEnd;
		 		pDev->Dac.fpHSyncEnd = HSyncPulse + pDev->Dac.fpHSyncStart;
		 		pDev->Dac.fpHValidStart = 0;
		 		pDev->Dac.fpHTotal = HTotal;
					
		 		pDev->Dac.fpVActive = VRes;
		 		pDev->Dac.fpVDispEnd = VRes - 1;
		 		pDev->Dac.fpVValidEnd = VRes - 1;
		 		pDev->Dac.fpVSyncStart =  VSyncOffset + pDev->Dac.fpVDispEnd;
		 		pDev->Dac.fpVSyncEnd = VSyncPulse + pDev->Dac.fpVSyncStart;
		 		pDev->Dac.fpVValidStart = 0;
		 		pDev->Dac.fpVTotal = VTotal;
				pDev->Dac.fpFlags = Flags;

			}
		}
	}
	// save the max resolution this fp supports 
	pDev->Dac.HalInfo.fpHMax = pDev->Dac.fpHActive;
	pDev->Dac.HalInfo.fpVMax = pDev->Dac.fpVActive;

	// If we found a valid detailed timing descriptor, use it.
	if (pDev->Dac.fpHActive)
		return RM_OK;

	// Check the "established timings" and if more than one, pick the highest.
	// There are currently no flat panels supporting refresh other than 60 Hz, so 
	// treat timings with different refresh but the same resolution as the same.
	if(est_tim1 & 0x3c)
 	{
		pDev->Dac.fpHActive = 0;	// no 640 panels. Return error unless we find higher res.
	}
	if(est_tim1 & 0x03)
	{
		// 800x600 60
		pDev->Dac.fpHActive =  800;
		pDev->Dac.fpHDispEnd = 799;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 799;
		pDev->Dac.fpHSyncStart = 799+16;
		pDev->Dac.fpHSyncEnd =  799+16+24;
		pDev->Dac.fpHTotal = 800+320;
		pDev->Dac.fpVActive = 600;
		pDev->Dac.fpVDispEnd = 599;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd =  599;
		pDev->Dac.fpVSyncStart = 599+2;
		pDev->Dac.fpVSyncEnd = 599+2+24;
		pDev->Dac.fpVTotal = 600+38;
		pDev->Dac.fpPixClk = 4000;	// 40 MHz
		pDev->Dac.fpFlags = VSYNC_POS | HSYNC_POS;
	}

	// established timing 2 should take precedence over 1, since it has higher resolutions
	if(est_tim2 & 0xc0)
 	{
		// 800x600 60
		pDev->Dac.fpHActive =  800;
		pDev->Dac.fpHDispEnd = 799;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 799;
		pDev->Dac.fpHSyncStart = 799+16;
		pDev->Dac.fpHSyncEnd =  799+16+24;
		pDev->Dac.fpHTotal = 800+320;
		pDev->Dac.fpVActive = 600;
		pDev->Dac.fpVDispEnd = 599;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd =  599;
		pDev->Dac.fpVSyncStart = 599+2;
		pDev->Dac.fpVSyncEnd = 599+2+24;
		pDev->Dac.fpVTotal = 600+38;
		pDev->Dac.fpPixClk = 4000;	// 40 MHz
		pDev->Dac.fpFlags = VSYNC_POS | HSYNC_POS;
	}
	if(est_tim2 & 0x1e)	// lumping together 60Hz, 70 Hz, 75 Hz, and 87 Hz under the assumption
						// that DFP's which support > 60 Hz (if any) will have detailed timings.
	{
		// 1024x768x60;
		pDev->Dac.fpHActive = 1024;
		pDev->Dac.fpHDispEnd = 1023;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 1023;
		pDev->Dac.fpHSyncStart = 1040;
		pDev->Dac.fpHSyncEnd = 1089;
		pDev->Dac.fpHTotal = 1344;
		pDev->Dac.fpVActive = 768;
		pDev->Dac.fpVDispEnd = 767;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd = 767;
		pDev->Dac.fpVSyncStart = 770;
		pDev->Dac.fpVSyncEnd = 776;
		pDev->Dac.fpVTotal = 805;
		pDev->Dac.fpPixClk = 6500;	// 65 MHz
		pDev->Dac.fpFlags = VSYNC_NEG | HSYNC_NEG;
	}
	if(est_tim2 & 0x01)
	{
		// 1280x1024x75;
		pDev->Dac.fpHActive = 1280;
		pDev->Dac.fpHDispEnd = 1279;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 1279;
		pDev->Dac.fpHSyncStart = 1280+15;
		pDev->Dac.fpHSyncEnd = 1280+15+2;
		pDev->Dac.fpHTotal = 1280+320;
		pDev->Dac.fpVActive = 1024;
		pDev->Dac.fpVDispEnd = 1023;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd = 1023;
		pDev->Dac.fpVSyncStart = 1023+2;
		pDev->Dac.fpVSyncEnd = 1023+2+24;
		pDev->Dac.fpVTotal = 1024+40;
		pDev->Dac.fpPixClk = 10800;	// 108 MHz
		pDev->Dac.fpFlags = VSYNC_POS | HSYNC_POS;
	}

	if (pDev->Dac.fpHActive)
	{
		// save the max resolution this fp supports 
		pDev->Dac.HalInfo.fpHMax = pDev->Dac.fpHActive;
		pDev->Dac.HalInfo.fpVMax = pDev->Dac.fpVActive;
		return RM_OK;
	}
	else
		return RM_ERROR;
 }

// EDID Version 2.x
// The first 128 bytes is not very interesting to us (I think), except the last 2 bytes,
// which are the map into second 128 bytes, which contain the luminance table and 
// timing descriptions.
// In order to get to the detailed timings, we have to parse thru the lum table, frequency
// ranges, detailed range limits, and timing codes. These are optional fields, so nothing is
// found at a fixed offset. The map bytes tell whether the fields are present.
RM_STATUS ParseEDID2(PHWINFO pDev, U032 Head)
{
RM_STATUS status;
U008	map1, map2, index, lum, rangeLimits, detailedRangeLimits;
U008	detailedTimings, block, timingCodes;
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW, offset;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags, i;
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;
U008    mode_count = 0;
U008	timingCode[4*31];
DACFPTIMING fpTim;

	map1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX];
	map2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX+1];
	index =  EDID_V2_TIMING_SECTION_START_INDEX;
	// if there is a lum table, bump index beyond
	if (map1 & EDID_V2_LUM_TABLE_EXIST)
	{
		// 1st byte in timing section gives # of bytes in lum table
		lum = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_SECTION_START_INDEX];
		if (lum & TRIPLE_LUM_ENTRIES)
			index += ((lum & NUM_LUM_ENTRIES)*3) + 1;
		else
			index += (lum & NUM_LUM_ENTRIES) + 1;
	}
	// if there are timing range limits, bump index
	if ((rangeLimits = (map1 & EDID_V2_FREQ_RANGES)>>EDID_V2_FREQ_RANGE_SHIFT))
		index += rangeLimits * 8;
	// if there are detailed range limits, bump index
	if ((detailedRangeLimits = map1 & EDID_V2_DETAILED_RANGE_LIMITS))
		index += detailedRangeLimits * 27;
	// if there are timing codes, save them
	if ((timingCodes = (map2 & EDID_V2_TIMING_CODES)>>EDID_V2_TIMING_CODES_SHIFT))
		for (i=0; i!=timingCodes; i++)
		{
			timingCode[i] = pDev->Dac.CrtcInfo[Head].EDID[index];
			timingCode[i+1] = pDev->Dac.CrtcInfo[Head].EDID[index+1];
			timingCode[i+2] = pDev->Dac.CrtcInfo[Head].EDID[index+2];
			timingCode[i+3] = pDev->Dac.CrtcInfo[Head].EDID[index+3];
			index += 4;
		}
	// now index points to the detailed timings (if present)
	if ((detailedTimings = (map2 & EDID_V2_DETAILED_TIMINGS)))
	{
		for (block = 0; block < detailedTimings; block++)
		{
			// A detailed timing block is 27 bytes
			// There can be up to 7 detailed timing blocks, immediately following the timing codes
			pClk = pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block];
			pClk |= (pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block + 1])<<8;
			if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
			{
				// Does this fp support native mode?
				// Another way to check would be to see if detailedTimings > 1,
				// but what if we find multiple detailed timings for the same resolution?
				mode_count++;	
				if (mode_count > 1)
					pDev->Dac.fpNative = 1;	

				// Seems valid, get info
				offset = index + 18 * block;
				HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
				HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
				HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
				VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
				VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
				VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
				HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
				HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
				VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
				SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
				Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

				// Get timing into useful format
				HRes = HActive1 | (HActive2 & 0xf0)<<4;
				VRes = VActive1 | (VActive2 & 0xf0)<<4;
				HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
				VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
				HTotal = HRes + HBlank;
				VTotal = VRes + VBlank;
				HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
				HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
				VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<2;
				VSyncPulse = (VSyncOff1 & 0x0f) | (SyncOvf & 0x30)<<4;

				if (HRes > pDev->Dac.fpHActive)	// largest yet?
				{
					// Return this resolution
					pDev->Dac.fpPixClk = pClk;
					pDev->Dac.fpHActive = HRes;
	 				pDev->Dac.fpHDispEnd = HRes - 1;
					pDev->Dac.fpHValidEnd = HRes - 1;
			 		pDev->Dac.fpHSyncStart = HSyncOffset + pDev->Dac.fpHDispEnd;
			 		pDev->Dac.fpHSyncEnd = HSyncPulse + pDev->Dac.fpHSyncStart;
	 				pDev->Dac.fpHValidStart = 0;
	 				pDev->Dac.fpHTotal = HTotal;
				
		 			pDev->Dac.fpVActive = VRes;
			 		pDev->Dac.fpVDispEnd = VRes - 1;
		 			pDev->Dac.fpVValidEnd = VRes - 1;
	 				pDev->Dac.fpVSyncStart =  VSyncOffset + pDev->Dac.fpVDispEnd;
		 			pDev->Dac.fpVSyncEnd = VSyncPulse + pDev->Dac.fpVSyncStart;
		 			pDev->Dac.fpVValidStart = 0;
		 			pDev->Dac.fpVTotal = VTotal;
	
					// save the max resolution this fp supports 
					pDev->Dac.HalInfo.fpHMax = pDev->Dac.fpHActive;
					pDev->Dac.HalInfo.fpVMax = pDev->Dac.fpVActive;
					pDev->Dac.fpFlags = Flags;
				}
			} // if 
		} // for
		return RM_OK;
	} // if detailed timings

	// If no detailed timings, check 4 byte timing codes
	// byte 1: active pixels/line (pixels - 256)/16. Range = 256-4336.
	// byte 2: arcane info, don't know what it means. See EDID standard.
	// byte 3: aspect ration H:V.
	// byte 4: refresh rate.
	pDev->Dac.fpHActive = 0;
	mode_count = 0;
	for (i=0; i < timingCodes; i++)	// search all codes for max res
	{
            status =  GetTimingFromCode(timingCode[i*4], &fpTim);		
            if (status == RM_OK)
            {
                if (fpTim.HActive > pDev->Dac.fpHActive) // new max?
                {
                    mode_count++;
                    pDev->Dac.fpPixClk = fpTim.PixClk;
                    pDev->Dac.fpHActive = fpTim.HActive;
                    pDev->Dac.fpHDispEnd = fpTim.HDispEnd;
                    pDev->Dac.fpHValidEnd = fpTim.HValidEnd;
                    pDev->Dac.fpHSyncStart = fpTim.HSyncStart;
                    pDev->Dac.fpHSyncEnd = fpTim.HSyncEnd;
                    pDev->Dac.fpHValidStart = fpTim.HValidStart;
                    pDev->Dac.fpHTotal = fpTim.HTotal;
                    
                    pDev->Dac.fpVActive = fpTim.VActive;
                    pDev->Dac.fpVDispEnd = fpTim.VDispEnd;
                    pDev->Dac.fpVValidEnd = fpTim.VValidEnd;
                    pDev->Dac.fpVSyncStart = fpTim.VSyncStart;
                    pDev->Dac.fpVSyncEnd = fpTim.VSyncEnd;
                    pDev->Dac.fpVValidStart = fpTim.VValidStart;
                    pDev->Dac.fpVTotal = fpTim.VTotal;
                    pDev->Dac.fpFlags = fpTim.Flags;
                    pDev->Dac.HalInfo.fpHMax = pDev->Dac.fpHActive;
                    pDev->Dac.HalInfo.fpVMax = pDev->Dac.fpVActive;
                }
            }
	}
	if (pDev->Dac.fpHActive)	// if we found a mode
	{
            if (mode_count > 1)
                pDev->Dac.fpNative = 1;	
            return RM_OK;
	}
	return RM_ERROR;
}

// Parse the EDID buffer (read earlier) to determine if we have valid timings.
// 
RM_STATUS fpParseEDID(PHWINFO pDev, U032 Head)
{
U032 status = RM_ERROR;	
// The EDID may contain "established timings", a bit map of flags showing supported 
// resolutions, or "standard timings", a 2-byte description of horizontal res + aspect ratio,
// or "detailed timings", an 18-byte description.
// Version 1.x EDID starts with an 8-byte header: 00 FF FF FF FF FF FF 00.
    if (pDev->Dac.CrtcInfo[Head].EDID[0] == 0)
        if (pDev->Dac.CrtcInfo[Head].EDID[1] == 0xFF)
            if (pDev->Dac.CrtcInfo[Head].EDID[7] == 0)
            {
                // Version 1 header
                if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VERSION_NUMBER_INDEX] == 1)
                {
                    switch (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_REVISION_NUMBER_INDEX]) 
                    {
                        case 0:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_10;
                            status = ParseEDID11(pDev, Head);	// Version 1.0 just like 1.1
                            break;
                        case 1:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_11;
                            status = ParseEDID11(pDev, Head);	// Version 1.1
                            break;
                        case 2:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_12;
                            status = ParseEDID12(pDev, Head);
                            break;
                        case 3:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_13;
                            status = ParseEDID13(pDev, Head);
                            break;
                        default:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_14; // This doesn't currently exist, but just in case
                            status = ParseEDID13(pDev, Head);
                            break;
                    }

                    // Is this is a digital device or analog?
                    if (!(pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7)))
                        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_MONITOR;    
                    else    
                        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_FLAT_PANEL;    
                    return status;	

                }
                else // Version 1 header, but not version 1 ID?
                {
                    return RM_ERROR;
                }
            }
	// Does not have version 1 header, check version 2
    if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) == 0)
    {
        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_MONITOR;    
        return RM_ERROR; // its a CRT	
    }
    else    
    {
        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_FLAT_PANEL;    
    }
    pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_20;
    return	ParseEDID2(pDev, Head);
}

BOOL edidIsAnalogDisplay(PHWINFO pDev, U032 Head) 
{
U032 version;

 	version = edidGetVersion(pDev, Head);
	if (version == 1)
	{
		// Verify this is an analog device
		if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7))
			return FALSE; // 1=digital
		else
			return TRUE;
	}
	if (version == 2)
		if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) == 0)
			return TRUE;
	return FALSE;
}

BOOL edidIsDigitalDisplay(PHWINFO pDev, U032 Head) 
{
U032 version;

 	version = edidGetVersion(pDev, Head);
	if (version == 1)
	{
		// Verify this is an analog device
		if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7))
			return TRUE;
		else
            return FALSE; // 1=digital
	}
	if (version == 2)
		if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) != 0)
			return TRUE;
	return FALSE;
}


//
// Generate an EDID appropriate for the current mobile panel in use
//
RM_STATUS edidConstructMobileInfo
(
    PHWINFO pDev,
    U032    Head,
    U008    *pEdid
)
{

    //
    // We now support generating EDID based on BIOS table information.
    // These tables are created at initialization time.  Note that
    // sometimes EDID requests come in _before_ initDac() has been
    // called (i.e., before the BIOS-based EDID is constructed).  In
    // this case we currently fall back to the hard-coded EDIDs below.
    // These EDIDs are also used for older VBIOSes that do not have
    // the necessary table information.
    //
    // WARNING: make sure each of the EDIDs below has a unique Monitor ID
    // (Locations 0x0A and 0x0B)!!!  Otherwise Windows will not notice that
    // the EDID has changed when panels are changed.  The generated EDID
    // code uses IDs EDID[0x0A] = x000, EDID[0x0B] = strap # (range 0x00-0x1F).
    //
    U032 i, panel_strap;

    // 1024x768
    U008 dfp_edid_XGA[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x02, 0x07, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,    //Monitor ID 0x02 0x07
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x64, 0x19, 0x00, 0x40, 0x41, 0x00,
         0x26, 0x30, 0x18, 0x88, 0x36, 0x00, 0x2C, 0xE4, 0x10, 0x00,
         0x00, 0x18, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x28, 0x4B, 0x1E,
         0x64, 0x0C, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F,
         0x58, 0x47, 0x41, 0x0A, 0x20, 0x20, 0x00, 0x3C
    };

    // 1024x768
    U008 dfp_edid_XGA_POS[] = {
          0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
          0x02, 0x01, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,    //Monitor ID 0x02 0x01
          0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
          0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
          0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
          0x01, 0x01, 0x01, 0x01, 0x64, 0x19, 0x00, 0x40, 0x41, 0x00,
          0x26, 0x30, 0x18, 0x88, 0x36, 0x00, 0x2C, 0xE4, 0x10, 0x00,
          0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x28, 0x4B, 0x1E,
          0x64, 0x0C, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
          0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
          0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F,
          0x58, 0x47, 0x41, 0x0A, 0x20, 0x20, 0x00, 0x3C
    };

    // 1280x1024
    U008 dfp_edid_SXGA[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,    //Monitor ID 0x02 0x02
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x30, 0x2A, 0x00, 0x98, 0x51, 0x00,
         0x2A, 0x40, 0x30, 0x70, 0x13, 0x00, 0x2C, 0xE4, 0x10, 0x00,
         0x00, 0x18, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x28, 0x4B, 0x1E,
         0x64, 0x0C, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F,
         0x53, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0xD8
    };

    // 1400x1050
    U008 dfp_edid_SXGA_PLUS[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x02, 0x03, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,    //Monitor ID 0x02 0x03
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x30, 0x2A, 0x78, 0x20, 0x51, 0x1A,
         0x10, 0x40, 0x30, 0x70, 0x13, 0x00, 0x2C, 0xE4, 0x10, 0x00,
         0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x3c, 0x3c, 0x1E,
         0x64, 0x0C, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F,
         0x53, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0xCC
    };

    // 1600x1200
    U008 dfp_edid_UXGA[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,    //Monitor ID 0x03 0x00
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x48, 0x3F, 0x40, 0x30, 0x62, 0xB0,
         0x32, 0x40, 0x40, 0xC0, 0x13, 0x00, 0x2C, 0xE4, 0x10, 0x00,
         0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x3c, 0x3c, 0x1E,
         0x64, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F,
         0x55, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0x99
    };

    //
    // Alternate IBM UXGA timings
    //
    U008 dfp_edid_UXGA_IBM[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x02, 0x04, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,    //Monitor ID 0x02 0x04
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0xDB, 0x33, 0x40, 0xE0, 0x60, 0xB0,
         0x0E, 0x40, 0x60, 0x10, 0xC1, 0x00, 0x2C, 0xE4, 0x10, 0x00,
         0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x28, 0x4B, 0x1E,
         0x64, 0x12, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x49, 0x42, 0x4D, 0x5F, 0x55, 0x58, 0x47,
         0x41, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x00, 0xEE
    };

    //
    // Alternate Toshiba UXGA timings
    //
    U008 dfp_edid_UXGA_Toshiba[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x02, 0x05, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,    //Monitor ID 0x02 0x05
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x48, 0x3F, 0x40, 0x30, 0x62, 0xB0,
         0x32, 0x40, 0x40, 0xC0, 0x23, 0x00, 0x2C, 0xE4, 0x10, 0x00,
         0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x28, 0x4B, 0x1E,
         0x64, 0x12, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x54, 0x4F, 0x53, 0x48, 0x42, 0x5F, 0x55,
         0x58, 0x47, 0x41, 0x0A, 0x20, 0x20, 0x00, 0xA4,
    };

    // 2048x1536
    U008 dfp_edid_QXGA[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x02, 0x06, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x0A, 0x01, 0x02,    //Monitor ID 0x02 0x06
         0x80, 0x2A, 0x20, 0x6C, 0xEA, 0x04, 0x85, 0xA0, 0x57, 0x4A,
         0x9B, 0x26, 0x12, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x10, 0x40, 0x00, 0x60, 0x80, 0x00,
         0x13, 0x60, 0x30, 0x10, 0x11, 0x04, 0xA7, 0x3D, 0x11, 0x00,
         0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x51, 0x26, 0x46, 0x28,
         0x64, 0x18, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F,
         0x51, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0x76
    };

    U008 dfp_edid_Toshiba_10x7[] = {
        //EDID provided by Toshiba's system BIOS.
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x51, 0xf3, 0x82, 0x50, 0x00, 0x00, 0x00, 0x00,    //Monitor ID 0x82 0x50
        0x00, 0x00, 0x01, 0x03, 0x80, 0x1d, 0x16, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x64, 0x19, 0x00, 0x40, 0x41, 0x00, 0x26, 0x30, 0x18, 0x88,
        0x36, 0x00, 0x1e, 0xd7, 0x10, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x54, 0x4f, 0x53,
        0x48, 0x49, 0x42, 0x41, 0x20, 0x49, 0x6e, 0x74, 0x65, 0x0a, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x72,
        0x6e, 0x61, 0x6c, 0x20, 0x31, 0x30, 0x32, 0x34, 0x78, 0x37, 0x36, 0x0a, 0x00, 0x00, 0x00, 0xfc,
        0x00, 0x38, 0x20, 0x50, 0x61, 0x6e, 0x65, 0x6c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x00, 0xe3
    };

#if 1
    //LPL: must have been a checksum error in the older EDID below -- comparing the two,
    // in addition to two swapped bytes (checksum neutral) there is a 0x00 instead of 0x08
    // at loc. 0x24.  Yet both have a checksum byte of 0xC0.  Manually verified this one.
    U008 dfp_edid_Toshiba_14x10[] = {
        0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x51, 0xF3, 0x86, 0x50, 0x00, 0x00, 0x00, 0x00, //814    //Monitor ID 0x86 0x50
        0x00, 0x00, 0x01, 0x03, 0x80, 0x1F, 0x17, 0x00, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //184
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x40, 0x31, 0x40, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, //147//0D8
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x30, 0x2A, 0x78, 0x20, 0x51, 0x1A, 0x10, 0x40, 0x30, 0x70, //253
        0x13, 0x00, 0x31, 0xE5, 0x10, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x54, 0x4F, 0x53, //343
        0x48, 0x49, 0x42, 0x41, 0x20, 0x49, 0x6E, 0x74, 0x65, 0x0A, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x72, //43C
        0x6E, 0x61, 0x6C, 0x20, 0x31, 0x34, 0x30, 0x30, 0x78, 0x31, 0x30, 0x0A, 0x00, 0x00, 0x00, 0xFC, //3FF
        0x00, 0x35, 0x30, 0x20, 0x50, 0x61, 0x6E, 0x65, 0x6C, 0x20, 0x20, 0x20, 0x20, 0x0A, 0x00, 0x51  //2FF = AF + 51 = 0
    };
#else
    U008 dfp_edid_Toshiba_14x10[] = {
        0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x51, 0xF3, 0x86, 0x50, 0x00, 0x00, 0x00, 0x00,     //Monitor ID 0x86 0x50
        0x00, 0x00, 0x01, 0x03, 0x80, 0x1F, 0x17, 0x00, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x90, 0x40, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x2A, 0x30, 0x78, 0x20, 0x51, 0x1A, 0x10, 0x40, 0x30, 0x70, 
        0x13, 0x00, 0x31, 0xE5, 0x10, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x54, 0x4F, 0x53, 
        0x48, 0x49, 0x42, 0x41, 0x20, 0x49, 0x6E, 0x74, 0x65, 0x0A, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x72, 
        0x6E, 0x61, 0x6C, 0x20, 0x31, 0x34, 0x30, 0x30, 0x78, 0x31, 0x30, 0x0A, 0x00, 0x00, 0x00, 0xFC, 
        0x00, 0x35, 0x30, 0x20, 0x50, 0x61, 0x6E, 0x65, 0x6C, 0x20, 0x20, 0x20, 0x20, 0x0A, 0x00, 0xC0, 
    };
#endif
    U008 dfp_edid_Toshiba_16x12[] = {
        0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x51, 0xF3, 0x88, 0x50, 0x00, 0x00, 0x00, 0x00,     //Monitor ID 0x88 0x50
        0x00, 0x00, 0x01, 0x03, 0x80, 0x1F, 0x17, 0x00, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x21, 0x09, 0x81, 0x80, 0xA9, 0x40, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x48, 0x3F, 0x40, 0x30, 0x62, 0xB0, 0x32, 0x40, 0x40, 0xC0,
        0x13, 0x00, 0x31, 0xE5, 0x10, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x54, 0x4F, 0x53,
        0x48, 0x49, 0x42, 0x41, 0x20, 0x49, 0x6E, 0x74, 0x65, 0x0A, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x72,
        0x6E, 0x61, 0x6C, 0x20, 0x31, 0x36, 0x30, 0x30, 0x78, 0x31, 0x32, 0x0A, 0x00, 0x00, 0x00, 0xFC,
        0x00, 0x30, 0x30, 0x20, 0x50, 0x61, 0x6E, 0x65, 0x6C, 0x20, 0x20, 0x20, 0x20, 0x0A, 0x00, 0x4F,
    };

    U008 *pBaseEdid = NULL;

    // Make sure we've read the strap value.
    dacPreInitEDID(pDev);

    panel_strap = pDev->Dac.PanelStrap;

    if (!pDev->Dac.MobileEDID[0])   //If the constructed EDID is valid
    {
        //Use a calculated EDID based on the BIOS BMP table
        pBaseEdid = pDev->Dac.MobileEDID;
    }
    else // use OEM to decide the EDID 
    {
        switch(pDev->Power.MobileOperation)
        {
            case 2: // Toshiba
            {
                //Default - use a hardwired version (not needed in 9x version, unless
                // osCallVideoBIOS fails).
                if (panel_strap == 2) 
                {
                    pBaseEdid = dfp_edid_Toshiba_10x7;
                }
                else if (panel_strap == 6)
                {
                    pBaseEdid = dfp_edid_Toshiba_16x12;
                }
                else
                {
                    pBaseEdid = dfp_edid_Toshiba_14x10;
                }
//
// When the active device is the CRT, this call takes 30 seconds to complete
// and returns an error code.
//
// Until we get this straightened out with Toshiba, just go with the fallback
// info
//
#if !defined(MACOS) && !defined(NTRM)
                {
                    RM_STATUS status;
                    U032 eax, ebx, ecx, edx;
  
                    // 
                    // We need to recover the DFP EDID from the Toshiba BIOS by running through
                    // our VESA EDID call.  Only implemented in Win9x at this point.
                    //
                    eax = 0x4F15;       // VESA EDID function
                    ebx = 0x0001;
                    ecx = Head;            // controller number
                    edx = 0;            // EDID block number
                    status = osCallVideoBIOS(pDev, &eax, &ebx, &ecx, &edx, pEdid);
                    if (status == RM_OK) pBaseEdid = NULL;  //Don't use the fallback if this call succeeded.
                }
#endif
                break;
            }
            case 3: // Quanta/E46?
            {
                //
                //
                // Quanta/E46 Strapping assignments
                //
                //                          Panel ID     Timing        
                //- XGA panels
                //    Unknown supplier       0x0          XGA (normal neg syncs)
                //    Unknown supplier       0x1          XGA (positive syncs)
                //
                //- SXGA panel
                //    Unknown supplier       0x2          SXGA
                //
                //- SXGA+ panels
                //    Unknown supplier       0x3          SXGA+
                //    Sharp 15"              0x8          SXGA+       
                //    Unknown supplier       0x7          SXGA+      
                //  
                //- UXGA panels                
                //    Unknown supplier       0x4          UXGA
                //    Unknown supplier       0xA          UXGA
                //    Unknown supplier       0xB          UXGA
                //
                //- QXGA panels
                //    Unknown supplier       0x5          QXGA
                //
                // All other panel straps default to standard XGA (neg)
                //
  
                if ((panel_strap == 0x3) || (panel_strap == 0x7) || (panel_strap == 0x8))
                {
                    pBaseEdid = dfp_edid_SXGA_PLUS;
                }
                else if (panel_strap == 0x02)
                {
                    pBaseEdid = dfp_edid_SXGA;
                }
                else if ((panel_strap == 0x04) || (panel_strap == 0x0A) || (panel_strap == 0x0B))
                {
                    pBaseEdid = dfp_edid_UXGA;
                }
                else if (panel_strap == 0x05)
                {
                    pBaseEdid = dfp_edid_QXGA;
                }
                else if (panel_strap == 0x01)
                {
                    pBaseEdid = dfp_edid_XGA_POS;
                }
                else    // assume XGA if nothing else
                {
                    pBaseEdid = dfp_edid_XGA;
                }
                break;
            }
            case 4: // Compal?
            {
                //
                // Compal Strapping assignments
                //
                //                          Panel ID     Timing        
                //
                //- SXGA+ panels
                //    Sharp 15"              0x8          SXGA+       
                //    Unknown supplier       0x7          SXGA+  
                //                           0xB          SXGA+
                //  
                // All other panel straps default to standard XGA (neg)
                //
  
                if ((panel_strap == 0x7) || (panel_strap == 0x8) || (panel_strap == 0xB))
                {
                    pBaseEdid = dfp_edid_SXGA_PLUS;
                }
                else    // assume XGA if nothing else
                {
                    pBaseEdid = dfp_edid_XGA;
                }
                break;
            }
            case 5: // Quanta Gateway?
            {
                //
                // Quanta Gateway Strapping assignments
                //
                //                          Panel ID     Timing        
                //- SXGA panel
                //    Unknown supplier       0x5          SXGA
                //
                //- SXGA+ panels
                //    Unknown supplier       0x3          SXGA+
                //    Unknown supplier       0x4          SXGA+       
                //  
                // All other panel straps default to standard XGA (neg)
                //
  
                if ((panel_strap == 0x3) || (panel_strap == 0x4))
                {
                    pBaseEdid = dfp_edid_SXGA_PLUS;
                }
                else if (panel_strap == 0x05)
                {
                    pBaseEdid = dfp_edid_SXGA;
                }
                else    // assume XGA if nothing else
                {
                    pBaseEdid = dfp_edid_XGA;
                }
                break;
            }
            default: 
            {
                //
                // Dell Strapping assignments
                //
                //- SXGA+ panels            Panel ID     Timing        
                //    Hitachi  15"           0xE          SXGA+ (pclk = 108Mhz)      
                //    Sharp 15"              0x8          SXGA+       
                //    Unknown supplier       0x2          SXGA+       
                //    Unknown supplier       0x7          SXGA+      
                //  
                //- UXGA panels                
                //    Unknown supplier       0x3          UXGA  ( pclk =162Mhz )
                //    Unknown supplier       0x4          UXGA  ( pclk =162Mhz )
                //    Unknown supplier       0x5          UXGA  ( pclk =162Mhz )
                //    Unknown supplier       0xB          UXGA  ( pclk =162Mhz )
                //
                //- QXGA panels
                //    Unknown supplier       0xA          QXGA  ( pclk =164MHz )
                //
                //
                // Strapped for UXGA???
                //
  
                if ((panel_strap == 0x03) || (panel_strap == 0x04) || (panel_strap == 0x05))
                {
                    pBaseEdid = dfp_edid_UXGA;
                }
                //
                // Strapped for alternate IBM UXGA?
                //
                else if (panel_strap == 0x0B)
                {
                    pBaseEdid = dfp_edid_UXGA_IBM;
                }
                //
                // Strapped for QXGA?
                //
                else if (panel_strap == 0x0A)
                {
                    pBaseEdid = dfp_edid_UXGA_Toshiba;
                }
                //
                // Strapped for SXGA+???
                //
                else    // assume SXGA+ if nothing else
                {
                    //pDev->Dac.CrtcInfo[Head].EDID = dfp_edid_SXGA;
                    pBaseEdid = dfp_edid_SXGA_PLUS;
                }
                break;
            }
        } // End of switch(pDev->Power.MobileOperation)
    } // end of else side of if (!pDev->Dac.MobileEDID[0])

    // load the EDID
    if (pBaseEdid)  //check if we already loaded it via an SBIOS call, otherwise...
        for (i=0;i<128;i++) pEdid[i] = pBaseEdid[i];

    return RM_OK;
}


//  Get the VESA DDC Capabilites status word
//  The lower 5 bits is a bit map of addresses at which a display will respond (A0, A2, A6);
//  bit 7 is set if there is more than one controller;
//  the upper byte is the response latency in seconds.
U032 edidGetDDCCaps
(
    PHWINFO pDev
)
{
    U008 lock, Adr = 0, Data = 0;
    U032 Caps = 0x100;  // set 1 second response (minimum)
    U032 Head, i2cPortId;
    U032 oldDDC;

    if (IsNV5orBetter(pDev)) 
    {
        Caps |= 0x80;   // multiple DDC ports
    }

    if (pDev->Power.MobileOperation) {
        Caps |= 0x02;        // fake DDC to the always attached flatpanel
    }

    if (IsNV11(pDev))
    {
        oldDDC = CurrentHeadDDC(pDev);
    }

    // Currently we can access any device from Head 0, but in the future, who knows?
    //    for (Head = 0; Head < pDev->Dac.HalInfo.NumCrtcs; Head++)   // for all heads
    for (Head = 0; Head < 1; Head++) 
    {
        // unlock the extended regs
        lock = UnlockCRTC(pDev, Head);

        if (IsNV11(pDev)) 
        {
           AssocDDC(pDev, Head);  // Connect the head to the I2C pins
        }
        // Try all I2c ports
        // NOTE: we have to know how many I2C ports there are--there is no define.
        for (i2cPortId = 0; i2cPortId < 3; i2cPortId++) 
        {
            // Send a byte (any data) to subaddress 0 and see if the device acks it.
            // Try all three monitor addresses
            if (!(Caps & 0x02)) // if we already set this bit, no need to do it again, as there is a noticeable delay
                if (!i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR1, 1, &Adr, 0, &Data))
                    Caps |= 0x02;
            if (!(Caps & 0x08))
                if (!i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR2, 1, &Adr, 0, &Data))
                    Caps |= 0x08;
            if (!(Caps & 0x10))
                if (!i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR3, 1, &Adr, 0, &Data))
                    Caps |= 0x10;
        }
        RestoreLock(pDev, Head, lock);
    }

    if (IsNV11(pDev))
    {
        AssocDDC(pDev, oldDDC); //restore previous DDC owner
    }

    return Caps;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\dactv.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* DAC TV Control ****************************\
*                                                                           *
* Module: DACTV.C                                                           *
*   Mode set for TV is done here.                                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <dac.h>
#include <os.h>
#include "nvhw.h"
#include "vga.h"
#include "i2c.h"
#include "tv.h"
#include <nvcm.h>
#include <edid.h>

extern char strDevNodeRM[];

U008 dacGetTVmode(PHWINFO, U032);

//
//  I2C  Strings
//
//---------------------------------------------------------------------------------------
// Philips


//-----------------------------------------------------------------------------
U008 Ph_Gen_Init0[] = {  
              0x01,            //subaddress 01
              0x00,            //reg 1 - load macrovision registers with 0's ???  
              0x00,            //reg 2  
              0x00,            //reg 3  
              0x00,            //reg 4  
              0x00,            //reg 5  
              0x00,            //reg 6  
              0x00,            //reg 7  
              0x00,            //reg 8  
              0x00,            //reg 9  
              0x00,            //reg a  
              0x00,            //reg b  
              0x00,            //reg c  
              0x00,            //reg d  
              0x00,            //reg e  
              0x00,            //reg f  
              0x00,            //reg 10 
              0x00,            //reg 11 
              0x00,            //reg 12 
              0x00,            //reg 13  
              0x00,            //reg 14
              0x00,            //reg 15  
              0x00,            //reg 16
              0x1b,            //reg 17
              0x1b,            //reg 18  
              0x1f,            //reg 19
              0x46,            //reg 1a
              0x00,            //reg 1b  
              0x00,            //reg 1c
              0x00,            //reg 1d  
              0x00,            //reg 1e
              0x00,            //reg 1f  
              0x00,            //reg 20
              0x1b,            //reg 21
              0x00,            //reg 22
              0x00,            //reg 23  
              0x00,            //reg 24
              0x00,            //reg 25  
              0xff,            //reg26                  
              0x3f,            //reg27                  
              0x19,            //reg28 Burst start: PAL=21h,NTSC=19h                 
              0x1d,            //reg29 Burst End: PAL=1dh,NTSC=1dh                 
              0xff,            //reg2a copy guard          
              0xff,            //reg2b copy guard          
              0x0f,            //reg2c cg data             
              0xb4,            //reg2d (clock polarity) 
              0x00,            //reg2e null             
              0x00,            //reg2f null             
              0x00,            //reg30 macro-vision     
              0x00,            //reg31 macro data 0        
              0x00,            //reg32                  
              0x00,            //reg33 data                
              0x00,            //reg34                  
              0x00,            //reg35                  
              0x00,            //reg36 data             
              0x00,            //reg37                  
              0x1a,            //reg38 RGB luma gain       
              0x1a,            //reg39 color gain diff.    
              0x00             //reg3a Color burst Enable    3Ah = 58
};
#define Ph_Gen_Init0_Len sizeof(Ph_Gen_Init0)
        
//----------------------------------------------------------------------------
U008 Ph_Gen_Init1[] = {
              0xa2,            //subaddress a2                2
              0x10,            //rega2 border color black     3   
              0x80,            //rega3 border color           4   
              0x80             //rega4 border color           5
};
#define Ph_Gen_Init1_Len sizeof(Ph_Gen_Init1)

//-----------------------------------------------------------------------------
U008 Ph_Gen_Init2[] = {
              0xfc,            
              0x03,            //regfc cursor position, move cursor off screen     
              0x98             //regfd lut off for now...         
};
#define Ph_Gen_Init2_Len sizeof(Ph_Gen_Init2)

// Format dependent init tables
// Init string 0
U008 Ph_NTSC_Init0[] = {
              0x54,            //start at address 54,
              0x01,            //reg 54 Internal PPD1 & PPD2 clock edge
              0x0f,            //reg 55
              0xc3,            //reg 56
              0x00,            //reg 57
              0x02,            //reg 58
              0x30,            //reg 59
              0x00,            //reg 5a Chrominance Phase (was 88)
              0x76,            //reg 5b
              0xa5,            //reg 5c 
              0x3a,            //reg 5d 
              0x2e,            //reg 5e 
              0x2e,            //reg 5f Cross Color Reduction (was 6e)
              0x00,            //reg 60                 
              0x15,            //reg 61 
              0x3f,            //reg 62 
              0x1f,            //reg 63 
              0x7c,            //reg 64 
              0xf0,            //reg 65  
              0x21,            //reg 66  
              0x00,            //reg 67  
              0x00,            //reg 68  
              0x00,            //reg 69  
              0x00,            //reg 6a
              0x00,            //reg 6b reserved
              0x01,            //reg 6c  
              0x20,            //reg 6d  
              0x00,            //reg 6e Blanking Control
              0x42,            //reg 6f CCN b[7:6], SCCLN b[4:0] (was 00)
              0x48,            //reg 70
              0x44,            //reg 71
              0x61,            //reg 72
              0x90,            //reg 73
              0x94,            //reg 74
              0xB0,            //reg 75
              0x78,            //reg 76
              0xf9,            //reg 77
              0x2a,            //reg 78
              0x2a,            //reg 79
              0x29,            //reg 7a >>> was 29, maybe 1d
              0x01,            //reg 7b >>> was 01, maybe f9 or de
              0x00,            //reg 7c
              0x00,            //reg 7d
              0x0c,            //reg 7e
              0x0d,            //reg 7f
              0x00,            //reg 80
              0x48,            //reg 81 >>> was 48, maybe ad
              0x2a,            //reg 82
              0x21             //reg 83
};
#define Ph_NTSC_Init0_Len sizeof(Ph_NTSC_Init0)

//-----------------------------------------------------------------------------
U008 Ph_NTSC_Init1[] = {
              0x90,            //start at address 90,
              0x5c,            //reg 90
              0x40,            //reg 91
              0x58,            //reg 92
              0x58,            //reg 93
              0x04,            //reg 94
              0xa0,            //reg 95
              0x02,            //reg 96
              0x2e,            //reg 97
              0x1f,            //reg 98
              0x13,            //reg 99
              0xf4,            //reg 9a
              0x33,            //reg 9b
              0x7f,            //reg 9c
              0x99,            //reg 9d
              0x99             //reg 9e
};
#define Ph_NTSC_Init1_Len sizeof(Ph_NTSC_Init1)

// Init string 0
U008 Ph_PAL_Init0[] = {
              0x54,            //start at address 54,
              0x01,            //reg 54 Internal PPD1 & PPD2 clock edge
              0x0f,            //reg 55
              0xc3,            //reg 56
              0x00,            //reg 57
              0x02,            //reg 58
              0x30,            //reg 59
              0x00,            //reg 5a Chrominance Phase (was 88)
              0x7d,            //reg 5b
              0xaf,            //reg 5c 
              0x33,            //reg 5d 
              0x35,            //reg 5e 
              0x75,            //reg 5f Cross Color Reduction (was 6e)
              0x00,            //reg 60                 
              0x02,            //reg 61 
              0x2f,            //reg 62 
              0xcb,            //reg 63 
              0x8a,            //reg 64 
              0x09,            //reg 65  
              0x2a,            //reg 66  
              0x00,            //reg 67  
              0x00,            //reg 68  
              0x00,            //reg 69  
              0x00,            //reg 6a
              0x00,            //reg 6b reserved
              0x01,            //reg 6c  
              0x20,            //reg 6d  
              0x00,            //reg 6e Blanking Control
              0x42,            //reg 6f CCN b[7:6], SCCLN b[4:0] (was 00)
              0x56,            //reg 70
              0x52,            //reg 71
              0x61,            //reg 72
              0x90,            //reg 73
              0x94,            //reg 74
              0xB0,            //reg 75
              0x78,            //reg 76
              0xf9,            //reg 77
              0x2a,            //reg 78
              0xfa,            //reg 79
              0x26,            //reg 7a >>> was 29, maybe 1d
              0x27,            //reg 7b >>> was 01, maybe f9 or de
              0x40,            //reg 7c
              0x00,            //reg 7d
              0x0c,            //reg 7e
              0x0d,            //reg 7f
              0x00,            //reg 80
              0x00,            //reg 81 >>> was 48, maybe ad
              0x00,            //reg 82
              0x1c             //reg 83
};
#define Ph_PAL_Init0_Len sizeof(Ph_PAL_Init0)

//-----------------------------------------------------------------------------
U008 Ph_PAL_Init1[] = {
              0x90,            //start at address 90,
              0x68,            //reg 90
              0x40,            //reg 91
              0x45,            //reg 92
              0x45,            //reg 93
              0x04,            //reg 94
              0xb8,            //reg 95
              0x02,            //reg 96
              0x2e,            //reg 97
              0x25,            //reg 98
              0x53,            //reg 99
              0xf4,            //reg 9a
              0x89,            //reg 9b
              0x8f,            //reg 9c
              0x43,            //reg 9d
              0x43,            //reg 9e
              0x4c
};
#define Ph_PAL_Init1_Len sizeof(Ph_PAL_Init1)

// Mode Tables
U008 Ph_NTSC_640[] = {
                0x70,       //start at address 70  
                0x3e,       //reg 70 Active display H Start (horizontal centering)
                0x3e,       //reg 71 Active display H End
                0x61,       //reg 72=0x61
                0x90,       //reg 73=0x90
                0x94,       //reg 74=0x94
                0xb0,       //reg 75=0xb0
                0x78,       //reg 76=0x78
                0xf9,       //reg 77=0xf9
                0x2a,       //reg 78=0x2a
                0xfa,       //reg 79=0xfa
                0x20,       //reg 7a
                0xf6,       //reg 7b
                0x00,       //reg 7c=0x00
                0x00,       //reg 7d=0x00
                0x0c,       //reg 7e=0x0c
                0x0d,       //reg 7f=0x0d
                0x00,       //reg 80=0x00
                0x00,       //reg 81  Pix clk 0
                0x00,       //reg 82  Pix clk 1
                0x20,       //reg 83  Pix Clk 2
                0x00,       //reg 84=0x00
                0x00,       //reg 85=0x00
                0x00,       //reg 86=0x00
                0x00,       //reg 87=0x00
                0x00,       //reg 88=0x00
                0x00,       //reg 89=0x00
                0x00,       //reg 8a=0x00
                0x00,       //reg 8b=0x00
                0x00,       //reg 8c=0x00
                0x00,       //reg 8d=0x00
                0x00,       //reg 8e=0x00
                0x00,       //reg 8f=0x00
                0x64,       //reg 90=0x60
                0x40,       //reg 91=0x40
                0x45,       //reg 92
                0x45,       //reg 93
                0x04,       //reg 94=0x04
                0xa0,       //reg 95=0xa0
                0x02,       //reg 96=0x02
                0x2e,       //reg 97=0x2e
                0xf9,       //reg 98=0x1f
                0x12,       //reg 99=0x13
                0x00,       //reg 9a=0x00
                0x1b,       //reg 9b
                0x70,       //reg 9c
                0x8d,       //reg 9d
                0x8d,       //reg 9e
                0x3b,       //reg 9f=0x3b
                0x00,       //reg a0=0x00
                0x00,       //reg a1=0x00
                0x10,       //reg a2 
                0x80,       //reg a3  
                0x80        //reg a4  
};
#define Ph_NTSC_Res_Len sizeof(Ph_NTSC_640)

U008 Ph_NTSC_800[] = {
                0x70,        //begin at register 70
                0x4b,        //reg 70
                0x23,        //reg 71
                0x61,        //reg 72
                0x90,        //reg 73
                0x94,        //reg 74
                0xb0,        //reg 75
                0x78,        //reg 76
                0xf9,        //reg 77
                0x2a,        //reg 78
                0xfa,        //reg 79
                0x1e,        //reg 7a
                0xf4,        //reg 7b
                0x00,        //reg 7c
                0x00,        //reg 7d
                0x0c,        //reg 7e
                0x0d,        //reg 7f
                0x00,        //reg 80
                0x00,        //reg 81 Pix clk 0
                0x00,        //reg 82 Pix clk 1
                0x40,        //reg 83 Pix clk 2
                0x00,        //reg 84
                0x00,        //reg 85
                0x00,        //reg 86
                0x00,        //reg 87
                0x00,        //reg 88
                0x00,        //reg 89
                0x00,        //reg 8a
                0x00,        //reg 8b
                0x00,        //reg 8c
                0x00,        //reg 8d
                0x00,        //reg 8e
                0x00,        //reg 8f
                0x62,        //reg 90 [Wiped out by fine adjust]
                0x90,        //reg 91
                0x51,        //reg 92
                0x51,        //reg 93
                0x04,        //reg 94
                0xb8,        //reg 95
                0x02,        //reg 96
                0x2e,        //reg 97
                0xc5,        //reg 98 HLen 
                0x64,        //reg 99 IDEL + HLen
                0x67,        //reg 9a
                0xb1,        //reg 9b
                0x5c,        //reg 9c
                0xd8,        //reg 9d
                0xd8,        //reg 9e
                0x2a,        //reg 9f
                0x00,        //reg a0
                0x00,        //reg a1
                0x10,        //reg a2
                0x80,        //reg a3
                0x80         //reg a4
};

U008 Ph_PAL_640[] = {
                0x70,       //start at address 70  
                0x81,       //reg 70=0x44
                0x59,       //reg 71=0x44
                0x61,       //reg 72=0x61
                0x90,       //reg 73=0x90
                0x94,       //reg 74=0x94
                0xb0,       //reg 75=0xb0
                0x78,       //reg 76=0x78
                0xf9,       //reg 77=0xf9
                0x2a,       //reg 78=0x2a
                0xfa,       //reg 79=0xfa
                0x26,       //reg 7a=0x29  >>> was 29, maybe 1d
                0x27,       //reg 7b=0x01  >>> was 01, maybe f9 or de
                0x40,       //reg 7c=0x00
                0x00,       //reg 7d=0x00
                0x0c,       //reg 7e=0x0c
                0x0d,       //reg 7f=0x0d
                0x00,       //reg 80=0x00
                0x00,       //reg 81=0x48  Pix clk 0
                0x00,       //reg 82=0x21  Pix clk 1
                0x1c,       //reg 83=0x21  Pix Clk 2
                0x00,       //reg 84=0x00
                0x00,       //reg 85=0x00
                0x00,       //reg 86=0x00
                0x00,       //reg 87=0x00
                0x00,       //reg 88=0x00
                0x00,       //reg 89=0x00
                0x00,       //reg 8a=0x00
                0x00,       //reg 8b=0x00
                0x00,       //reg 8c=0x00
                0x00,       //reg 8d=0x00
                0x00,       //reg 8e=0x00
                0x00,       //reg 8f=0x00
                0x68,       //reg 90=0x60
                0x40,       //reg 91=0x40
                0x45,       //reg 92=0x58  >>> was 58, maybe 3d
                0x45,       //reg 93=0x58  >>> was 58, maybe 3d
                0x04,       //reg 94=0x04
                0xb8,       //reg 95=0xa0
                0x02,       //reg 96=0x02
                0x2e,       //reg 97=0x2e
                0x25,       //reg 98=0x1f
                0x53,       //reg 99=0x13
                0x81,       //reg 9a=0x00
                0x89,       //reg 9b=0x33  >>> was 33, maybe 4e
                0x8f,       //reg 9c=0x70  >>> was 70, maybe 70
                0x43,       //reg 9d=0x99  >>> was 99, maybe a6
                0x43,       //reg 9e=0x99  >>> was 99, maybe a6
                0x4c,       //reg 9f=0x3b
                0x00,       //reg a0=0x00
                0x00,       //reg a1=0x00
                0x10,       //reg a2 
                0x80,       //reg a3  
                0x80        //reg a4  
};
#define Ph_PAL_Res_Len sizeof(Ph_PAL_640)

U008 Ph_PAL_800[] = {
                0x70,        //begin at register 70
                0x5d,        //reg 70
                0x51,        //reg 71
                0x61,        //reg 72
                0x90,        //reg 73
                0x94,        //reg 74
                0xb0,        //reg 75
                0x78,        //reg 76
                0xf9,        //reg 77
                0x2a,        //reg 78
                0xfa,        //reg 79
                0x24,        //reg 7a
                0x29,        //reg 7b
                0x40,        //reg 7c
                0x00,        //reg 7d
                0x0c,        //reg 7e
                0x0d,        //reg 7f
                0x00,        //reg 80
                0x00,        //reg 81 Pix clk 0
                0x00,        //reg 82 Pix clk 1
                0x2c,        //reg 83 Pix clk 2
                0x00,        //reg 84
                0x00,        //reg 85
                0x00,        //reg 86
                0x00,        //reg 87
                0x00,        //reg 88
                0x00,        //reg 89
                0x00,        //reg 8a
                0x00,        //reg 8b
                0x00,        //reg 8c
                0x00,        //reg 8d
                0x00,        //reg 8e
                0x00,        //reg 8f
                0x66,        //reg 90 [Wiped out by fine adjust]
                0x90,        //reg 91
                0x50,        //reg 92
                0x50,        //reg 93
                0x04,        //reg 94
                0xb8,        //reg 95
                0x02,        //reg 96
                0x2e,        //reg 97
                0x07,        //reg 98 ,LEN was 0xxff, c,anged to non-sentinel value
                0x54,        //reg 99
                0xaf,        //reg 9a
                0xf2,        //reg 9b
                0x6c,        //reg 9c
                0x77,        //reg 9d
                0x77,        //reg 9e
                0x3b,        //reg 9f
                0x00,        //reg a0
                0x00,        //reg a1
                0x10,        //reg a2
                0x80,        //reg a3
                0x80         //reg a4
};


// Autoconfigure hack
U008    Bt_NM800[] = { 0xB8, 0x02, 0xff };
U008    Bt_NM640[] = { 0xB8, 0x00, 0xff };
//
// Brooktree strings
//

//  Init string               C4    C6    C8            CA           CC             CE
U008    BT_Init[] = { 0xC4, 0x01, 0x98, BT_FLICKER_MED, BT_LUMA_DEF, BT_CHROMA_DEF, (BT_OUT_MUX_B_SVID | BT_OUT_MUX_C_ALL), 0xff };
U008    BT871_Init[] = { 0xC4, 0x01, 0x98, BT_FLICKER_MED, BT871_LUMA_DEF, BT871_CHROMA_DEF, (BT_OUT_MUX_B_SVID | BT_OUT_MUX_C_ALL), 0xff };

/************************************************************************************************
    We now support 6 distinct TV standards: NTSC M, NTSC J, PAL NC, PAL M, PAL N, and
    PAL B, D, G, I (which are the same as far as we are concerned).
*/
//---------------------------------------------------------------------------------------
// Brooktree 800x600

// NTSC M 800x600
U008 Bt_NM600[] = {
// 0x6e, 0xe7, 0xc2, 0x00, 0x01,
// 76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90
 0x76, 
 0xA0, 0x20, 0xB6, 0xD8, 0xB9, 0x55, 0x20, 0xD8, 0x39, 0x00, 0x70, 0x42, 0x03, 0xDF,
// 92    94    96    98    9A    9C    9E    A0    A2    A4    A6    A8    AA    AC    AE
 0x56, 0x58, 0x3A, 0xCD, 0x9C, 0x14, 0x3B, 0x11, 0x0A, 0xE5, 0x74, 0x77, 0x43, 0x85, 0xBA,
// B0    B2    B4    B6
 0xE8, 0xA2, 0x17, 0x00, 
 0xff};

// NTSC J 800x600
U008 Bt_NJ600[] = {
// 0x6e, 0xe7, 0xc2, 0x00, 0x01,
 0x76, 
 0xA0, 0x20, 0xB6, 0xD8, 0xB9, 0x55, 0x20, 0xD8, 0x39, 0x00, 0x70, 0x42, 0x03, 0xDF,
 0x56, 0x58, 0x3A, 0xCD, 0x9C, 0x14, 0x3B, 0x11, 0x08, 0xE5, 0x74, 0x77, 0x43, 0x85, 0xBA,
 0xE8, 0xA2, 0x17, 0x00,
 0xff};

// PAL NC 800x600
U008 Bt_NC600[] = {
// 0x6e, 0xe7, 0xc2, 0x00, 0x01,
 0x76, 
 0x00, 0x20, 0xAA, 0xCA, 0xA4, 0x0D, 0x29, 0xFC, 0x39, 0x00, 0xC0, 0x8C, 0x03, 0xEE, 
 0x5F, 0x58, 0x3A, 0x66, 0x96, 0x00, 0x00, 0x10, 0x24, 0xF0, 0x56, 0x7F, 0x47, 0x8C, 0x35,
 0xEF, 0x78, 0x19, 0x00,
 0xff};

// PAL B,D,G,I 800x600
U008 Bt_PA600[] = {
// 0x6e, 0x31, 0x02, 0x00, 0x01,
 0x76, 
 0x00, 0x20, 0xAA, 0xCA, 0x9A, 0x0D, 0x29, 0xFC, 0x39, 0x00, 0xC0, 0x8C, 0x03, 0xEE,
 0x5F, 0x58, 0x3A, 0x66, 0x96, 0x00, 0x00, 0x10, 0x24, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x18,
 0x28, 0x87, 0x1F, 0x00,
 0xff};

// PAL M 800x600
U008 Bt_PM600[] = {
// 0x6e, 0x31, 0x02, 0x00, 0x01,
 0x76, 
 0xA0, 0x20, 0xB6, 0xE0, 0xC2, 0x55, 0x20, 0xD8, 0x39, 0x00, 0x70, 0x42, 0x03, 0xDF,
 0x56, 0x58, 0x3A, 0xCD, 0x9C, 0x14, 0x3B, 0x11, 0x2A, 0xF0, 0x56, 0x7E, 0x47, 0x8C, 0x7E,
 0x42, 0x9C, 0x17, 0x00,
 0xff};

// PAL N 800x600
U008 Bt_PN600[] = {
// 0x6e, 0x31, 0x02, 0x00, 0x01,
0x76, 
0x00, 0x20, 0xAA, 0xCA, 0x9A, 0xF3, 0x29, 0xFC, 0x39, 0x00, 0xC0, 0x8C, 0x03, 0xEE,
0x5F, 0x58, 0x3A, 0x66, 0x56, 0x00, 0x00, 0x10, 0x2E, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x18,
0x28, 0x87, 0x1F, 0x00,
0xff};

//---------------------------------------------------------------------------------------
// Native TV modes with no overscan.  For use when playing DVD's

// Brooktree 720x480 NTSC
U008 Bt_NMDVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90    92    94
    0x76, 
    0xE0, 0xD0, 0x82, 0x92, 0x5C, 0x1B, 0x13, 0xF2, 0x26, 0x00, 0x70, 0x8C, 0x03, 0x0D, 0x24, 0xE0, 
    0x36, 0x00, 0x50, 0xC5, 0x4E, 0x0C, 0x0A, 0xE5, 0x76, 0x79, 0x44, 0x85, 0xD1, 0x45, 0x17, 0x21, 
    0x00, 0xff};

U008 Bt_NJDVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90    92    94
    0x76, 
    0x66, 0xD0, 0x82, 0x92, 0x5C, 0x1B, 0x13, 0xF2, 0x27, 0x00, 0x70, 0x8C, 0x03, 0x0D, 0x24, 0xE0, 
    0x36, 0x00, 0x50, 0xC5, 0x4E, 0x0C, 0x08, 0xE5, 0x76, 0x79, 0x44, 0x85, 0xD1, 0x45, 0x17, 0x21, 
    0x00, 0xff};

U008 Bt_NCDVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C	  8E	90    92    94
    0x76,
    0xF0, 0xD0, 0x82, 0x9C, 0x5A, 0x31, 0x16, 0x22, 0xa6, 0x00, 0x78, 0x93, 0x03, 0x71, 0x2A, 0x40,
    0x3A, 0x00, 0x50, 0x55, 0x55, 0x0C, 0x24, 0xF0, 0x59, 0x82, 0x49, 0x8C, 0x8E, 0xB0, 0xE6, 0x28,
    0x00, 0xff};

U008 Bt_PADVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C	  8E	90    92    94
    0x76,
    0xF0, 0xD0, 0x82, 0x9C, 0x5A, 0x31, 0x16, 0x22, 0xa6, 0x00, 0x78, 0x93, 0x03, 0x71, 0x2A, 0x40,
    0x3A, 0x00, 0x50, 0x55, 0x55, 0x0C, 0x24, 0xF0, 0x59, 0x82, 0x49, 0x8C, 0x8E, 0xB0, 0xE6, 0x28,
    0x00, 0xff};

U008 Bt_PMDVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C	  8E	90    92    94
    0x76,
    0xF0, 0xD0, 0x82, 0x9C, 0x5A, 0x31, 0x16, 0x22, 0xa6, 0x00, 0x78, 0x93, 0x03, 0x71, 0x2A, 0x40,
    0x3A, 0x00, 0x50, 0x55, 0x55, 0x0C, 0x24, 0xF0, 0x59, 0x82, 0x49, 0x8C, 0x8E, 0xB0, 0xE6, 0x28,
    0x00, 0xff};

U008 Bt_PNDVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C	  8E	90    92    94
    0x76,
    0xF0, 0xD0, 0x82, 0x9C, 0x5A, 0x31, 0x16, 0x22, 0xa6, 0x00, 0x78, 0x93, 0x03, 0x71, 0x2A, 0x40,
    0x3A, 0x00, 0x50, 0x55, 0x55, 0x0C, 0x24, 0xF0, 0x59, 0x82, 0x49, 0x8C, 0x8E, 0xB0, 0xE6, 0x28,
    0x00, 0xff};

//---------------------------------------------------------------------------------------

// Two no-overscan modes, which will be the default on X-box:

// Brooktree 640x480 NTSC
U008 Bt_NM480x[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C	   8E	 90
    0x76,
    0x08, 0x80, 0x72, 0x80, 0x42, 0xf1, 0x13, 0xf2, 0x26, 0x00, 0x04, 0x73, 0x03, 0x0d, 
    0x24, 0xe0, 0x00, 0x00, 0x10, 0x15, 0xcc, 0x0a, 0x0a, 0xe5, 0x77, 0x7a, 0x45, 0x85, // 92-AC
    0x81, 0x5f, 0xb8, 0x25, 0x00,             // AE-B6 (stop here: B8 is the autoconfig mode register)
    0xff};

// Brooktree 640x480 PAL. This one starts at reg 38.
U008 Bt_PA480x[] = {
// 38,   3A,   3C,   3E,   40,   42,   44,   46,   48,   4A,   4C,   4E,   50,   52,   54,   56,   58,   5A,   5C,   5E 
 0x38,
 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x01, 0x2e, 0x1a, 0x01, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x46, 0x00, 0x01,                                  // 60-74
 0x3c, 0x80, 0x76, 0x8c, 0x44, 0x1b, 0x16, 0x20, 0xA6, 0x00, 0xB6, 0xFB, 0x03, 0x0D,    // 76-90
 0x23, 0xe0, 0x06, 0xe1, 0x4a, 0x55, 0x15, 0x0b, 0x24, 0xf0, 0x59, 0x83, 0x4a, 0x8c,    // 92-AC
 0x33, 0x98, 0x83, 0x2d, 0x00,                                                          // AE-B6
 0xff};

// Normal modes used with 868/869:

 //---------------------------------------------------------------------------------------
// Brooktree 640x480

// NTSC 640x480
U008 Bt_NM480[] = {
// 0x6e, 0x26, 0x02, 0x00, 0x01,
// 76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90
 0x76, 
 0x00, 0x80, 0x84, 0x9E, 0x65, 0x7D, 0x22, 0xD4, 0x27, 0x00, 0x10, 0x7E, 0x03, 0x58,
 0x4B, 0xE0, 0x36, 0x92, 0x54, 0x0E, 0x88, 0x0C, 0x0A, 0xE5, 0x76, 0x79, 0x44, 0x85, 0x00,
 0x00, 0x80, 0x20, 0x00,
 0xff};

// NTSC J 640x480
U008 Bt_NJ480[] = {
// 0x6e, 0x26, 0x02, 0x00, 0x01,
 0x76, 
 0x00, 0x80, 0x84, 0x9E, 0x65, 0x7D, 0x22, 0xD4, 0x27, 0x00, 0x10, 0x7E, 0x03, 0x58, 
 0x4B, 0xE0, 0x36, 0x92, 0x54, 0x0E, 0x88, 0x0C, 0x08, 0xE5, 0x76, 0x79, 0x44, 0x85, 0x00,
 0x00, 0x80, 0x20, 0x00,
 0xff};

// PAL NC 640x480
U008 Bt_NC480[] = {
// 0x6e, 0xb2, 0x02, 0x00, 0x01,
 0x76, 
 0x60, 0x80, 0x8A, 0xA6, 0x70, 0xC1, 0x2E, 0xF2, 0x27, 0x00, 0xB0, 0x0A, 0x0B, 0x71, 
 0x5A, 0xE0, 0x36, 0x00, 0x50, 0x72, 0x1C, 0x0D, 0x24, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x1E,
 0xC0, 0x15, 0x1F, 0x00,
 0xff};

// PAL B,D,G,I 640x480
U008 Bt_PA480[] = {
// 0x6e, 0xb2, 0x02, 0x00, 0x01,
// 0x76, 78    7a    7c    7e    80    82    84    86    88    8a    8c    8e    90
 0x76,
 0x60, 0x80, 0x8A, 0xA6, 0x68, 0xC1, 0x2E, 0xF2, 0x27, 0x00, 0xB0, 0x0A, 0x0B, 0x71,
// 92    94    96    98    9a    9c    a0    a2    a4    a6    a8    aa    ac    ae    b0
 0x5A, 0xE0, 0x36, 0x00, 0x50, 0x72, 0x1C, 0x0D, 0x24, 0xF0, 0x58, 0x81, 0x49, 0x8C, 0x0C,
 0x8C, 0x79, 0x26, 0x00,
 0xff};

// PAL M 640x480
U008 Bt_PM480[] = {
// 0x6e, 0xb2, 0x02, 0x00, 0x01,
 0x76, 
 0x00, 0x80, 0x84, 0xA4, 0x6A, 0x7D, 0x22, 0xD4, 0x27, 0x00, 0x10, 0x7E, 0x03, 0x58, 
 0x4B, 0xE0, 0x36, 0x92, 0x54, 0x0E, 0x88, 0x0C, 0x2A, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x6E, 
 0xDB, 0x76, 0x20, 0x00,
 0xff};

// PAL N 640x480
U008 Bt_PN480[] = {
// 0x6e, 0xb2, 0x02, 0x00, 0x01,
 0x76, 
 0x60, 0x80, 0x8A, 0xA6, 0x68, 0xAB, 0x2E, 0xF2, 0x27, 0x00, 0xB0, 0x0A, 0x0B, 0x71, 
 0x5A, 0xE0, 0x36, 0x00, 0x50, 0x72, 0x1C, 0x0D, 0x2E, 0xF0, 0x58, 0x81, 0x49, 0x8C, 0x0C,
 0x8C, 0x79, 0x26, 0x00,
 0xff};

//---------------------------------------------------------------------------------------
// Brooktree 640x400

// NTSC M 640x400
U008 Bt_NM400[] = {
// 0x6e, 0xb2, 0x02, 0x00, 0x01,
 0x76, 
 0x00, 0x80, 0x84, 0x96, 0x60, 0x7D, 0x20, 0xD8, 0x27, 0x00, 0xC0, 0x18, 0x0B, 0xEA, 
 0x39, 0x90, 0x35, 0xDE, 0x4D, 0x0E, 0x88, 0x0C, 0x0A, 0xE5, 0x76, 0x79, 0x44, 0x85, 0x00,
 0x00, 0x80, 0x20, 0x00,
 0xff};

// NTSC J 640x400
U008 Bt_NJ400[] = {
// 0x6e, 0xc0, 0x02, 0x00, 0x01,
 0x76, 
 0x00, 0x80, 0x84, 0x96, 0x60, 0x7D, 0x20, 0xD8, 0x27, 0x00, 0xC0, 0x18, 0x0B, 0xEA, 
 0x39, 0x90, 0x35, 0xDE, 0x4D, 0x0E, 0x88, 0x0C, 0x08, 0xE5, 0x76, 0x79, 0x44, 0x85, 0x00, 
 0x00, 0x80, 0x20, 0x00,
 0xff};

// PAL NC 640x400
U008 Bt_NC400[] = {
// 0x6e, 0xc0, 0x02, 0x00, 0x01,
0x76, 
0x90, 0x80, 0x8E, 0xAA, 0x76, 0xDD, 0x35, 0xE5, 0x27, 0x00, 0x4C, 0x92, 0x0C, 0x26, 
0x5B, 0x90, 0x36, 0x29, 0x4C, 0xC7, 0x71, 0x0D, 0x24, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x6B, 
0x73, 0x50, 0x1E, 0x00, 
0xff};

// PAL B,D,G,I 640x400
U008 Bt_PA400[] = {
 0x6e, 0x20, 0x42, 0x00, 0x01,
//0x76,  78    7a    7c    7e    80    82    84    86    88    8a    8c    8e    90
  0x90, 0x80, 0x8E, 0xAA, 0x6E, 0xDD, 0x35, 0xE5, 0x27, 0x00, 0x4C, 0x92, 0x0C, 0x26, 
//  92    94    96    98    9a    9c    a0    a2    a4    a6    a8    aa    ac    ae    b0
  0x5B, 0x90, 0x36, 0x29, 0x4C, 0xC7, 0x71, 0x0D, 0x24, 0xF0, 0x58, 0x81, 0x49, 0x8C, 0xEA, 
  0x57, 0x85, 0x25, 0x00,
 0xff};

// PAL M 640x400
U008 Bt_PM400[] = {
 0x6e, 0x20, 0x42, 0x00, 0x01,
// 0x76, 
 0x00, 0x80, 0x84, 0xA4, 0x6A, 0x7D, 0x20, 0xD8, 0x27, 0x00, 0xC0, 0x18, 0x0B, 0xEA, 
 0x39, 0x90, 0x35, 0xDE, 0x4D, 0x0E, 0x88, 0x0C, 0x2A, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x6E, 
 0xDB, 0x76, 0x20, 0x00,
 0xff};

// PAL N 640x400
U008 Bt_PN400[] = {
 0x6e, 0x20, 0x42, 0x00, 0x01,
//0x76 
0x90, 0x80, 0x8E, 0xAA, 0x6E, 0xC5, 0x35, 0xE5, 0x27, 0x00, 0x4C, 0x92, 0x0C, 0x26, 
0x5B, 0x90, 0x36, 0x29, 0x4C, 0xC7, 0x71, 0x0D, 0x2E, 0xF0, 0x58, 0x81, 0x49, 0x8C, 0xEA, 
0x57, 0x85, 0x25, 0x00, 
0xff};


//---------------------------------------------------------------------------------------
//  Centering
//  H, V Offset. 6E = H Offset Low, 70[7,6] = H Offset High, 70[5:0] = H Sync Width
//               72 = V Offset Low, 74[5:3] = V Offset High, 74[2:0] = V Sync Width
//  NV4 Horizontal Offset should be 8 pixels less than NV5 & up (see programBrooktree()).
//---------------------------------------------------------------------------------------

// NTSC M 800x600
U008 Btc_NM600[] = {
 0x6e, 0xe0, 0xc2, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 800x600
U008 Btc_PA600[] = {
 0x6e, 0x2a, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC 720x480
U008 Btc_NMDVD[] = {
 0x6e, 0x28, 0x02, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 720x576
U008 Btc_PADVD[] = {
 0x6e, 0x28, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC 640x480
U008 Btc_NM480[] = {
 0x6e, 0x1e, 0x02, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 640x480
U008 Btc_PA480[] = {
 0x6e, 0xac, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 640x400
U008 Btc_NM400[] = {
 0x6e, 0xb6, 0x02, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 640x400
U008 Btc_PA400[] = {
 0x6e, 0x2e, 0x42, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 320x400
// CURRENTLY UNUSED
U008 Btc_NM3x4[] = {
 0x6e, 0x00, 0x42, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 320X400
U008 Btc_PA3x4[] = {
 0x6e, 0x20, 0x42, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 512x384
U008 Btc_NM384[] = {
 0x6e, 0x08, 0x42, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 512x384
U008 Btc_PA384[] = {
 0x6e, 0x80, 0x42, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 480x360
U008 Btc_NM360[] = {
 0x6e, 0x08, 0x42, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 480x360
U008 Btc_PA360[] = {
 0x6e, 0x80, 0x42, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 400x300
U008 Btc_NM300[] = {
 0x6e, 0xac, 0xc2, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 400x300
U008 Btc_PA300[] = {
 0x6e, 0x05, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 320x240
U008 Btc_NM240[] = {
 0x6e, 0xd2, 0xc2, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 320x240
U008 Btc_PA240[] = {
 0x6e, 0x60, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// Brooktree 320x200

// NTSC M 320x200
U008 Btc_NM200[] = {
 0x6e, 0x6b, 0x02, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 320x200
U008 Btc_PA200[] = {
 0x6e, 0xd8, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// Brooktree I2C tables for TV modes 0..9
// Some modes are scanline and/or character doubled (e.g. 320x200 is really 640x400)
// Some modes do not have specific encoder tables; they use the next larger format
// (e.g. 512x384 uses 640x400).
// DVD native mode is the native TV resolution with overscan compensation disabled
// There are 3 sets of tables (400, 480, 600) times 6 TV formats.
//    320x200   320x240   320x400   400x300   480x360   512x384   640x400   640x480   800x600  DVD native
U008 *Bt_NM[] =    // NTSC M
    {Bt_NM400, Bt_NM480, Bt_NM400, Bt_NM600, Bt_NM400, Bt_NM400, Bt_NM400, Bt_NM480, Bt_NM600, Bt_NMDVD};

U008 *Bt_NJ[] =    // NTSC J
    {Bt_NJ400, Bt_NJ480, Bt_NJ400, Bt_NJ600, Bt_NJ400, Bt_NJ400, Bt_NJ400, Bt_NJ480, Bt_NJ600, Bt_NJDVD};

U008 *Bt_PM[] =    // PAL M
    {Bt_PM400, Bt_PM480, Bt_PM400, Bt_PM600, Bt_PM400, Bt_PM400, Bt_PM400, Bt_PM480, Bt_PM600, Bt_PMDVD};

U008 *Bt_PA[] =    // PAL BDHGI
    {Bt_PA400, Bt_PA480, Bt_PA400, Bt_PA600, Bt_PA400, Bt_PA400, Bt_PA400, Bt_PA480, Bt_PA600, Bt_PADVD};

U008 *Bt_PN[] =    // PAL N
    {Bt_PM400, Bt_PN480, Bt_PN400, Bt_PN600, Bt_PN400, Bt_PN400, Bt_PN400, Bt_PN480, Bt_PN600, Bt_PNDVD};

U008 *Bt_NC[] =   // PAL NC
    {Bt_NC400, Bt_NC480, Bt_NC400, Bt_NC600, Bt_NC400, Bt_NC400, Bt_NC400, Bt_NC480, Bt_NC600, Bt_NCDVD};

//---------------------------------------------------------------------------------------
// Brooktree Centering tables
// Centering is NTSC-like (NTSC-M, NTSC-J, PAL-M) or PAL-like (PAL-BDGHI, PAL-N, PAL-NC).
// There are 2 sets of tables for 6 TV formats.
//    320x200   320x240    320x400    400x300    480x360    512x384    640x400    640x480    800x600
U008 *Btc_NM[] =    // NTSC M
    {Btc_NM200, Btc_NM240, Btc_NM3x4, Btc_NM300, Btc_NM360, Btc_NM384, Btc_NM400, Btc_NM480, Btc_NM600, Btc_NMDVD};

U008 *Btc_NJ[] =    // NTSC J
    {Btc_NM400, Btc_NM480, Btc_NM3x4, Btc_NM300, Btc_NM360, Btc_NM384, Btc_NM400, Btc_NM480, Btc_NM600, Btc_NMDVD};

U008 *Btc_PM[] =   // PAL M
    {Btc_NM200, Btc_NM480, Btc_NM3x4, Btc_NM300, Btc_NM360, Btc_NM384, Btc_NM400, Btc_NM480, Btc_NM600, Btc_NMDVD};

U008 *Btc_PA[] =   // PAL BDHGI
    {Btc_PA200, Btc_PA240, Btc_PA3x4, Btc_PA300, Btc_PA360, Btc_PA384, Btc_PA400, Btc_PA480, Btc_PA600, Btc_PADVD};

U008 *Btc_PN[] =   // PAL N
    {Btc_PA200, Btc_PA480, Btc_PA3x4, Btc_PA300, Btc_PA360, Btc_PA384, Btc_PA400, Btc_PA480, Btc_PA600, Btc_PADVD};

U008 *Btc_NC[] =   // PAL NC
    {Btc_PA200, Btc_PA480, Btc_PA3x4, Btc_PA300, Btc_PA360, Btc_PA384, Btc_PA400, Btc_PA480, Btc_PA600, Btc_PADVD};


//---------------------------------------------------------------------------------------
// Brooktree Autoconfig tables
//
// Bit 0 indicates NTSC/PAL
// Bits 5:4 indicate overscan ratio, but not in a consistent way (640x480 standard is 0 for PAL and 1 for NTSC, and lower is the reverse).
#define BTAN_640x400    0x08    //001000b
#define BTAN_640x480    0x10    //010000b   Conexant has taken this out of the data sheet -- but with mode 0 we lose some pixels in horiz
#define BTAN_800x600    0x12    //010010b
#define BTAN_1024x768   0x0a    //001010b
#define BTAP_640x400    0x09    //001001b
#define BTAP_640x480    0x01    //000001b
#define BTAP_800x600    0x13    //010011b
#define BTAP_1024x768   0x0b    //001011b

//              640x400  640x480  800x600  1024x768
U008 BTA[] = {  BTAN_640x400, BTAN_640x480, BTAN_800x600, BTAN_1024x768,
                BTAP_640x400, BTAP_640x480, BTAP_800x600, BTAP_1024x768
};
#define BTA_LEN sizeof(BTA)/2

// H Sync
U008 BTHS0[] = { 0x1B, 0x19, 0xEB, 0x23,
                 0xAC, 0xAA, 0x35, 0xE5};
U008 BTHS1[] = { 0x02, 0x02, 0x02, 0x02,
                 0x02, 0x02, 0x02, 0x02};
// Coring & Attenuation
U008 BTCA0[] = { 0xC3, 0xC3, 0xC3, 0xC3,
                 0xC3, 0xC3, 0xC3, 0xC3 };
U008 BTCA1[] = { 0xC2, 0xC2, 0xC2, 0xC2,
                 0xC2, 0xC2, 0xC2, 0xC2 };
// V Active & Lines
U008 BTVAL[] = { 0x06, 0x06, 0x0A, 0x0F,
                 0x06, 0x06, 0x0B, 0x0F };
// Flicker Filter
U008 BTFF0[] = { 0x1B, 0x1B, 0x1B, 0x00,
                 0x12, 0x12, 0x1B, 0x00 };
U008 BTFF1[] = { 0x9B, 0x9B, 0x80, 0x80,
                 0x9B, 0x9B, 0x80, 0x80 };
U008 BTFF2[] = { 0xC0, 0xC0, 0x92, 0xF6,
                 0xC0, 0xC0, 0x92, 0xF6 };

//
//  Chrontel strings
//

//  The I2C init string
//  Reg 3D and reg 10[7:5] are Macrovision bits, and on the 7008 they must be cleared when the device
//  powers up (standby D3 cold) or else the clock will stop.
U008 CH_Init[] = { 0xea, CH_REG_04, 0x05, CH_REG_06, 0x40, CH_REG_0D, 0x07, CH_REG_0E, 0x0B, CH_REG_10, 
                   0x00, CH_REG_1B, 0x20, CH_REG_1C, 0xC0, CH_REG_3D, 0x00, 0xff };

CH_string  CH_NULL_STRING = {   0xff    };

//  The I2C disable string
U008    CH_Disable[] = { 0xea, CH_REG_0D, 0x03, CH_REG_0E, 0x09, 0xff };

//  Flicker filter, Brightness, and Contrast.
U008    CH_FBC[] = { 0xea, CH_REG_01, CH_FF, CH_REG_09, CH_BL, CH_REG_11, CH_CE, 0xff };

//
// Chrontel I2C timing tables. All resolutions are multiples of these modes.
// Reg A is horizontal position; Reg B is vertical position
// DEVICE REG 0       REG 7       REG A       REG B       REG13, AUTOINC TO REG 15
CH_string  CH_NTSC320X200 =
{   0xea, CH_REG_00, 0x49, CH_REG_07, 0x70, CH_REG_0A, 0x34, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x0b, 0x16, 0xff };  // NTSC 320x200 (640x400)
CH_string  CH_NTSC320X240 =
{   0xea, CH_REG_00, 0x6a, CH_REG_07, 0x5C, CH_REG_0A, 0x2a, CH_REG_0B, 0x04, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3f, 0x7e, 0xff };  // NTSC 320x240 (640x480)
CH_string CH_NTSC400X300 =
{   0xea, CH_REG_00, 0x8d, CH_REG_07, 0x84, CH_REG_0A, 0x38, CH_REG_0B, 0xe8, CH_REG_13 | I2C_AUTOINC, 0x02, 0x59, 0x2E, 0xff };  // NTSC 400x300 (800x600)
CH_string  CH_NTSC480X360 =
{   0xea, CH_REG_00, 0x49, CH_REG_07, 0x70, CH_REG_0A, 0x34, CH_REG_0B, 0x16, CH_REG_13 | I2C_AUTOINC, 0x00, 0x0b, 0x16, 0xff };  // NTSC 480x360 (640x400) 
CH_string  CH_NTSC512X384 = 
//{   0xea, CH_REG_00, 0x09, CH_REG_07, 0xd4, CH_REG_0A, 0x0a, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x63, 0x16, 0xff };  // NTSC 512x384
{   0xea, CH_REG_00, 0x49, CH_REG_07, 0x70, CH_REG_0A, 0x48, CH_REG_0B, 0x10, CH_REG_13 | I2C_AUTOINC, 0x00, 0x0b, 0x16, 0xff };  // use NTSC 640x400 
CH_string  CH_NTSC640X400 =
{   0xea, CH_REG_00, 0x49, CH_REG_07, 0x70, CH_REG_0A, 0x34, CH_REG_0B, 0x10, CH_REG_13 | I2C_AUTOINC, 0x00, 0x0b, 0x16, 0xff };  // NTSC 640x400 mode 11
CH_string  CH_NTSC640X480 = 
{   0xea, CH_REG_00, 0x6A, CH_REG_07, 0x5e, CH_REG_0A, 0x2b, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3F, 0x7E, 0xff };  // NTSC 640x480 mode 17
CH_string  CH_NTSC720X480 = 
//{   0xea, CH_REG_00, 0x69, CH_REG_07, 0x46, CH_REG_0A, 0x1E, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3F, 0x6E, 0xff };
//{   0xea, CH_REG_00, 0x8C, CH_REG_07, 0x84, CH_REG_0A, 0x2D, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x13, 0x3E, 0xff };  //mode 23
{   0xea, CH_REG_00, 0x8D, CH_REG_07, 0x8E, CH_REG_0A, 0x3c, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x02, 0x59, 0x2E, 0xff };  // copy of NTSC 800x600 mode 24
CH_string  CH_NTSC720X576 = 
{   0xea, CH_REG_00, 0x8B, CH_REG_07, 0x7C, CH_REG_0A, 0x29, CH_REG_0B, 0xF4, CH_REG_13 | I2C_AUTOINC, 0x00, 0x21, 0x5E, 0xff };
CH_string  CH_NTSC800X600 = 
{   0xea, CH_REG_00, 0x8D, CH_REG_07, 0x8E, CH_REG_0A, 0x3c, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x02, 0x59, 0x2E, 0xff };  // NTSC 800x600 mode 24

// PAL values 
CH_string  CH_PAL320X200 =
{   0xea, CH_REG_00, 0x42, CH_REG_07, 0xf0, CH_REG_0A, 0x30, CH_REG_0B, 0x08, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3d, 0x6c, 0xff };  // PAL 320x200 (640x400)
CH_string  CH_PAL320X240 =
{   0xea, CH_REG_00, 0x61, CH_REG_07, 0xc0, CH_REG_0A, 0x38, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x04, 0x09, 0xff };  // PAL 320x240 (640x480)
CH_string  CH_PAL400X300 = 
{   0xea, CH_REG_00, 0x83, CH_REG_07, 0x8c, CH_REG_0A, 0x40, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x21, 0x56, 0xff };  // PAL  800x600 (800x600)
CH_string  CH_PAL480X360 = 
{   0xea, CH_REG_00, 0x42, CH_REG_07, 0x5c, CH_REG_0A, 0x40, CH_REG_0B, 0x10, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3d, 0x6c, 0xff };  // PAL  480x360 (640x400)
CH_string  CH_PAL512X384 = 
{   0xea, CH_REG_00, 0x42, CH_REG_07, 0xc0, CH_REG_0A, 0x20, CH_REG_0B, 0x10, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3d, 0x6c, 0xff };  // PAL  512x384 (640x400)
CH_string  CH_PAL640X400 = 
{   0xea, CH_REG_00, 0x42, CH_REG_07, 0xee, CH_REG_0A, 0x30, CH_REG_0B, 0x10, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3d, 0x6c, 0xff };  // PAL  640x400 100
CH_string  CH_PAL640X480 = 
{   0xea, CH_REG_00, 0x61, CH_REG_07, 0x6e, CH_REG_0A, 0x34, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x04, 0x09, 0xff };  // PAL  640x480 101
CH_string  CH_PAL720X480 = 
{   0xea, CH_REG_00, 0x83, CH_REG_07, 0x7e, CH_REG_0A, 0x40, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x21, 0x56, 0xff };  // PAL  800x600 103
//{   0xea, CH_REG_00, 0x81, CH_REG_07, 0x84, CH_REG_0A, 0x2D, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x05, 0x39, 0x87, 0xff };  // PAL  720x480
CH_string  CH_PAL720X576 = 
{   0xea, CH_REG_00, 0x81, CH_REG_07, 0x84, CH_REG_0A, 0x2D, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x05, 0x39, 0x87, 0xff };  // PAL  720x576
CH_string  CH_PAL800X600 = 
{   0xea, CH_REG_00, 0x83, CH_REG_07, 0x7e, CH_REG_0A, 0x40, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x21, 0x56, 0xff };  // PAL  800x600 103

// FSCI data (subcarrier frequency adjustment). If reg 21 bit 0 is set, the subcarrier frequency is automatically selected.
U008 CH_FSCI_640x480[] = {0x02, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00 }; // mode 17
//U008 CH_FSCI_720x480[] = {0x01, 0x0D, 0x09, 0x0C, 0x00, 0x04, 0x06, 0x0F }; // mode 23
U008 CH_FSCI_720x480[] = {0x01, 0x09, 0x08, 0x0B, 0x03, 0x0A, 0x06, 0x03 }; // mode 24
//U008 CH_FSCI_720x576[] = {0x02, 0x05, 0x02, 0x04, 0x09, 0x0C, 0x07, 0x0A }; // mode 16
U008 CH_FSCI_720x576[] = {0x01, 0x0F, 0x01, 0x0C, 0x07, 0x0A, 0x05, 0x00 }; // mode 22
U008 CH_FSCI_800x600[] = {0x01, 0x09, 0x08, 0x0B, 0x03, 0x0A, 0x06, 0x03 }; // mode 24
U008 CH_FSCI_640x480NC[] = {0x01, 0x0f, 0x00, 0x0d, 0x05, 0x04, 0x05, 0x0e }; // PAL NC 640x480
//U008 CH_FSCI_720x480NC[] = {0x02, 0x06, 0x07, 0x09, 0x08, 0x0C, 0x00, 0x0C }; // mode 19
U008 CH_FSCI_720x480NC[] = {0x01, 0x09, 0x07, 0x08, 0x0e, 0x0f, 0x03, 0x05 }; // PAL NC 800x600
U008 CH_FSCI_720x576NC[] = {0x02, 0x06, 0x07, 0x39, 0xC8, 0x0C, 0x00, 0x0C }; // ??
U008 CH_FSCI_800x600NC[] = {0x01, 0x09, 0x07, 0x08, 0x0e, 0x0f, 0x03, 0x05 }; // PAL NC 800x600

#define numFSCIbytes    sizeof CH_FSCI_640x480

//
//  NV4 TV adjustments for Chrontel
//
TV_ADJUST CHRONTEL_NTSC[] =
{
//   hRes  vRes  SR01  CR00  CR04  CR06  CR07  CR08  CR10  CR12  CR28  encoderStringPtr,          htotal vtotal hdelay
    {320,  200,  0x09, 0x2b, 0x2b, 0x0c, 0x3e, 0x00, 0xc0, 0x8f, 0x98, (U008 *)(&CH_NTSC320X200), 0x1A4, 0x20D, 0x18},
    {320,  240,  0x09, 0x2b, 0x2b, 0x3c, 0x3e, 0x40, 0xe4, 0xdf, 0x88, (U008 *)(&CH_NTSC320X240), 0x188, 0x258, 0x0d},
    {400,  300,  0x09, 0x3d, 0x3d, 0x72, 0xf0, 0x20, 0x59, 0x57, 0x80, (U008 *)(&CH_NTSC400X300), 0x000, 0x000, 0x00},
    // 480x360 and 512x384 use 640x400 encoder mode 
    {480,  360,  0x01, 0x49, 0x40, 0x20, 0xB3, 0x00, 0x90, 0x67, 0x80, (U008 *)(&CH_NTSC480X360), 0x000, 0x000, 0x00}, 
    {512,  384,  0x01, 0x5b, 0x57, 0x3c, 0x3e, 0x00, 0xd0, 0x7f, 0x80, (U008 *)(&CH_NTSC512X384), 0x000, 0x000, 0x00},
    {640,  400,  0x01, 0x5b, 0x57, 0x3c, 0x3e, 0x00, 0xd0, 0x8f, 0x80, (U008 *)(&CH_NTSC640X400), 0x348, 0x20D, 0x03},
    {640,  480,  0x01, 0x5f, 0x5c, 0x3c, 0x3e, 0x00, 0xe4, 0xdf, 0x80, (U008 *)(&CH_NTSC640X480), 0x310, 0x258, 0x0d},
    {720,  480,  0x01, 0x68, 0x6f, 0x80, 0xf0, 0x00, 0x59, 0x57, 0x80, (U008 *)(&CH_NTSC720X480), 0x428, 0x2EE, 0x00}, //correct?
    {720,  576,  0x01, 0x65, 0x6f, 0x92, 0xf0, 0x00, 0x50, 0x57, 0x80, (U008 *)(&CH_NTSC720X576), 0x410, 0x276, 0x00},
    {800,  600,  0x01, 0x76, 0x6d, 0xb8, 0xf0, 0x00, 0x59, 0x57, 0x80, (U008 *)(&CH_NTSC800X600), 0x428, 0x2EE, 0x0d},
};
//
TV_ADJUST  CHRONTEL_PAL[] =
{
//   hRes  vRes  SR01  CR00  CR04  CR06  CR07  CR08  CR10  CR12  CR28  encoderStringPtr,         htotal vtotal hdelay
    {320,  200,  0x09, 0x2e, 0x29, 0x0c, 0x3e, 0x00, 0xc0, 0x8f, 0x98, (U008 *)(&CH_PAL320X200), 0x1F4, 0x1F4, 0x06},
    {320,  240,  0x09, 0x2c, 0x2a, 0x3c, 0x3e, 0x00, 0xe4, 0xdf, 0x88, (U008 *)(&CH_PAL320X240), 0x1A4, 0x271, 0x08},
    {400,  300,  0x09, 0x3c, 0x3c, 0xb0, 0xf0, 0x00, 0x57, 0x57, 0x80, (U008 *)(&CH_PAL400X300), 0x000, 0x000, 0x00},
    // 480x360 and 512x384 use 640x400 encoder mode
    {480,  360,  0x01, 0x49, 0x48, 0xf0, 0xB2, 0x00, 0x90, 0x67, 0x80, (U008 *)(&CH_PAL480X360), 0x000, 0x000, 0x00},
    {512,  384,  0x01, 0x75, 0x57, 0x0e, 0x3e, 0x00, 0xc0, 0x7f, 0x80, (U008 *)(&CH_PAL512X384), 0x000, 0x000, 0x00},
    {640,  400,  0x01, 0x6a, 0x56, 0x0C, 0x3e, 0x00, 0xc0, 0x8f, 0x80, (U008 *)(&CH_PAL640X400), 0x3E8, 0x1F4, 0x05},
    {640,  480,  0x01, 0x5a, 0x56, 0x3c, 0x3e, 0x00, 0xe4, 0xdf, 0x80, (U008 *)(&CH_PAL640X480), 0x348, 0x271, 0x05},
    {720,  480,  0x01, 0x74, 0x6a, 0xe0, 0xf0, 0x00, 0x59, 0x57, 0x80, (U008 *)(&CH_PAL720X480), 0x3C0, 0x2EE, 0x05},  //copied from 720x576
//    {720,  576,  0x01, 0x6f, 0x6a, 0xb8, 0xf0, 0x00, 0x59, 0x57, 0x80, (U008 *)(&CH_PAL720X576) },
//    {720,  576,  0x01, 0x65, 0x6f, 0x92, 0xf0, 0x00, 0x50, 0x57, 0x80, (U008 *)(&CH_PAL720X576) },
    {720,  576,  0x01, 0x6f, 0x6a, 0x70, 0xf0, 0x00, 0x48, 0x57, 0x80, (U008 *)(&CH_PAL720X576), 0x3B0, 0x271, 0x00},
    {800,  600,  0x01, 0x70, 0x6a, 0xb8, 0xf0, 0x00, 0x59, 0x57, 0x80, (U008 *)(&CH_PAL800X600), 0x3C0, 0x2EE, 0x05},
};
    
//
//  adjustments for Brooktree 
//
// New method eliminates most of the table entries. Only VT needs to be table driven.
// Now we can use normal CRTC values, except HRS = HDE + 1, HT = HRS + 1.
// There are some exceptions to this (see programTV()).
U008    VT_BT_NTSC[] =
   // 320x200,320x240,320x400,400x300,480x360,512x384,640x400,640x480,800x600, DVD
    { 0xd3,   0x32,   0xc8,   0xac,   0xe4,   0x39,   0xca,   0x34,   0xac,    0x0D}; 
U008    VT_BT_PAL[] =
    { 0xf5,   0x42,   0xcf,   0xb6,   0xe8,   0x5a,   0xf4,   0x43,   0xb6,    0x54};


/*************************** Helper functions *******************************/

// Read register, mask off bits, or with new value
// Write Mask is positive mask of data (e.g. use 0x14 to alter bits 4 and 2)
U008 dacTVReadModifyWrite
(
    PHWINFO pDev, 
    U032    Head,
    U008    Reg,
    U008    WriteData,
    U008    WriteMask
)
{
U008 ReadData, ack;

     // Read register
     i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) Reg); 
     i2cStart(pDev, Head, pDev->Dac.TVOutPortID); // Start w/o Stop = Restart
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
     i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &ReadData, 1);
     i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
     
     // Combine data and write
     WriteData &= WriteMask;   // just to be safe
     WriteData |= (ReadData & ~WriteMask);
     
     i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) Reg); 
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) WriteData); 
     i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
     
     return ReadData;
}

//  Read encoder register
//  This will work on Chrontel, Philips, and Conexant 870/871, but not 868/869
U008 dacTVReadReg
(
    PHWINFO pDev,
    U032    Head,
    U008    Reg
)
{
    U008 read;

    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID));     
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) Reg);                        // subaddress
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID+1));     
    i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read, 1);
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    return read;
}
 
static U032 dacGetTVAdjustTableArray
(
    PHWINFO pDev,
    U032 Head,
    TV_ADJUST **adjustTablePtr
)
{
    U032  numEntries;

    numEntries = 0;
    if (TV_ENCODER_FAMILY(pDev->Dac.EncoderType) == TV_ENCODER_CHRONTEL)
    {
        // Chrontel encoder.
        switch (pDev->Dac.TVStandard)
        {
            // modes with NTSC CRTC timing
            case NTSC_M:
            case NTSC_J:
            case PAL_M:
                *adjustTablePtr = (TV_ADJUST *)&CHRONTEL_NTSC;
                numEntries = sizeof(CHRONTEL_NTSC) / sizeof(TV_ADJUST);
                break;
            // modes with PAL CRTC timing
            case PAL_A:
            case PAL_N:
            case PAL_NC:
                *adjustTablePtr = (TV_ADJUST *)&CHRONTEL_PAL;
                numEntries = sizeof(CHRONTEL_PAL) / sizeof(TV_ADJUST);
                break;
        }
    }
#if 0   // this style table lookup not used
    else
    {
        // Brooktree encoder.
        if (pDev->Dac.TVStandard == NTSC)
        {
            // NTSC 
            *adjustTablePtr = (TV_ADJUST *)&BROOKTREE_NTSC;
            numEntries = sizeof(BROOKTREE_NTSC) / sizeof(TV_ADJUST);
        }
        else
        {
            // PAL
            *adjustTablePtr = (TV_ADJUST *)&BROOKTREE_PAL;
            numEntries = sizeof(BROOKTREE_PAL) / sizeof(TV_ADJUST);
        }
    }
#endif

    return numEntries;
} // end of dacGetTVAdjustTableArray

static RM_STATUS dacGetI2CModeString
(
    PHWINFO pDev, 
    U032 Head,
    U032 hRes, 
    U032 vRes,
    U008 **encoderStringPtr,
    U032 *hTotalPM, //(optional) pseudo-master mode param
    U032 *vTotalPM, //(optional) pseudo-master mode param
    U008 *hDelayPM  //(optional) pseudo-master mode param
)
{
    U032 i, numEntries;
    TV_ADJUST * adjustTable;

    numEntries = dacGetTVAdjustTableArray(pDev, Head, &adjustTable);
    for (i = 0; i < numEntries; i++)
    {
        if (adjustTable[i].hRes == hRes &&
            adjustTable[i].vRes == vRes)
        {
            // found a match.
            *encoderStringPtr = adjustTable[i].encoderString;
            if (hTotalPM) *hTotalPM = adjustTable[i].hTotalPM;
            if (vTotalPM) *vTotalPM = adjustTable[i].vTotalPM;
            if (hDelayPM) *hDelayPM = adjustTable[i].hDelayPM;

            return RM_OK;
        }
    }

    // did not find a match.
    return RM_ERROR;
} // end of dacGetI2CModeString

static RM_STATUS dacGetTVAdjustTableEntry
(
    PHWINFO pDev,
    U032 Head,
    U032 hRes,
    U032 vRes,
    TV_ADJUST **adjustTableEntry
)
{
    U032 i, numEntries;
    TV_ADJUST * adjustTable;

    numEntries = dacGetTVAdjustTableArray(pDev, Head, &adjustTable);
    for (i = 0; i < numEntries; i++)
    {
        if (adjustTable[i].hRes == hRes &&
            adjustTable[i].vRes == vRes)
        {
            // found a match.
            *adjustTableEntry = &adjustTable[i];
            return RM_OK;
        }
    }

    // did not find a match.
    return RM_ERROR;
} // end of dacGetTVAdjustTableEntry

// Autoconfiguration requires writing a single register.
// The resolution, TV standard, and overscan ration is encapsulated in this mode number.
// Currently, only "standard" overscan is used. 
// Note: in order to get non-overscan modes for 640x480, we can't use autoconfig, so I've added discrete tables.
RM_STATUS dacProgramBrooktreeAuto(PHWINFO pDev, U032 Head)
{
    U032    hRes, vRes;
    U016    status = 0;
    U008    mode, config1, config2, autoConfigMode, *strptr, i, bths0, bths_override=0;
    hRes = pDev->Framebuffer.HalInfo.HorizDisplayWidth;
    vRes = pDev->Framebuffer.HalInfo.VertDisplayWidth;

    // generate an index into our mode table
    mode = 0; // not really needed but some compilers complain about uninitialized use
    
    switch (hRes) 
    {
        case 320:
            switch (vRes) 
            {
                case 200:
                    mode = 0;       // 640x400
                    bths0 = 0x10;   //table override
                    bths_override = 1;
                    break;
                case 240:
                    mode = 1;   // 640x480
                    bths_override = 1;
                    if (pDev->Dac.TVStandard == PAL_M)
                        bths0 = 0x00;
                    else
                        bths0 = 0x02;
                    break;
                default:
                    return RM_ERROR;
            }
            break;
        case 400:
            if (vRes == 300) 
                mode = 2; // 800x600
            else
                return RM_ERROR;
            break;
        case 480:
            if (vRes == 360) 
                mode = 1;   // 640x480
            else
                return RM_ERROR;
            break;
        case 512:
            if (vRes == 384) 
                mode = 3;   // 1024x768
            break;
        case 640:
            switch (vRes)
            {
                case 400:
                    mode = 0;   // 640x400
                    break;
                case 480:
                    mode = 1;
                    break;
                default:
                    return RM_ERROR;
            }
            break;
        case 800:
            if (vRes == 600) 
            {
                mode = 2;
                if (pDev->Dac.TVStandard == PAL_M)
                {
                    bths_override = 1;
                    bths0 = 0x3C;
                }
            }
            else
                return RM_ERROR;
            break;
        case 1024:
            if (vRes == 768) 
                mode = 3;
            else
                return RM_ERROR;
            break;
        default:
            return RM_ERROR;
    }
    // 640x480 defaults to non-overscan, for which there is no autoconfig. Use tables.
    if ((mode == 1) && pDev->Dac.TVOverscanDisabled)
    {
        // Set the auto-config mode 0
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CONFIG);	// subaddress
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0);	// 
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
        
        // send an init string
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        strptr = (U008 *)&BT871_Init;          // send init sequence
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        for (i=0; *strptr != 0xff; i++)
        {
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  
            if (status)
                break;
        }     
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C
        
        switch (pDev->Dac.TVStandard)
        {
            case NTSC_M:
            case NTSC_J:
                strptr = (U008 *)&Bt_NM480x;
                break;
            case PAL_NC:
            case PAL_A:
            case PAL_M:
            case PAL_N:
                strptr = (U008 *)&Bt_PA480x;                
                break;
            default:
                break;
        }
        
        // send a timing string
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        for (i=0; *strptr != 0xff; i++)
        {
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);
            if (status)
                break;
        }
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C
        
        // Toggle TIMING_RST
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);  
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x44);  
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C
        tmrDelay(pDev, 10000000);
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);  
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0xC4);  
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C

    }
    else // do autoconfig
    {
        // Now adjust index for TV standard
        switch (pDev->Dac.TVStandard)
        {
            case NTSC_M:
            case NTSC_J:
                break;
            case PAL_NC:
            case PAL_A:
            case PAL_M:
            case PAL_N:
                mode += BTA_LEN;  // second row of table
                break;
            default:
                break;
        }
        autoConfigMode = BTA[mode];
        // The HW designer shoved a reserved bit into the middle of the config info.
        // I could account for this in the table, but I want my table to correspond to the values in the manual, and
        // if the reserved bit is ever used, we'll have to preserve it, so it's better to leave the table as is, and insert
        // into the config byte here.
        config1 = autoConfigMode & 0x07;
        config2 = autoConfigMode & 0x38;
        config2 <<= 1;   // put a 0 in bit 3
        autoConfigMode = config2 | config1;

        // Set the auto-config mode
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CONFIG);	// subaddress
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) autoConfigMode);	// 
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        strptr = (U008 *)&BT871_Init;          // send init sequence
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        for (i=0; *strptr != 0xff; i++)
        {
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  
            if (status)
                break;
        }     
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C
    }
    
    
    if (!bths_override)
        bths0 = BTHS0[mode];

    // Some adjustments
    // Hsync offset + width
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_HS0);	    // subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) bths0);	        // 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_HS1);	    // subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTHS1[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    // Coring + attenuation
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CA0);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTCA0[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CA1);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTCA1[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    // VActive + VLines
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_VAL);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTVAL[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    // Flicker Filter
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_FF0);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTFF0[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_FF1);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTFF1[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_FF2);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTFF2[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    // Set proper clock edge (default for autoconfig is wrong)
// This causes worse problems: the encoder is sometimes not readable after setting this.
//    dacTVReadModifyWrite(pDev, Head, 0xA0, 0x80, 0x80);
    
    // Save positioning regs. These will become our defaults
    pDev->Dac.TV871_80 = (U032)dacTVReadReg(pDev, Head, 0x80);
    pDev->Dac.TV871_82 = (U032)dacTVReadReg(pDev, Head, 0x82);
    pDev->Dac.TV871_92 = (U032)dacTVReadReg(pDev, Head, 0x92);
    pDev->Dac.TV871_98 = (U032)dacTVReadReg(pDev, Head, 0x98);
    pDev->Dac.TV871_9A = (U032)dacTVReadReg(pDev, Head, 0x9a);
    pDev->Dac.TV871_C8 = (U032)dacTVReadReg(pDev, Head, 0xC8);
    pDev->Dac.TV871_CA = (U032)dacTVReadReg(pDev, Head, 0xCA);
    pDev->Dac.TV871_CC = (U032)dacTVReadReg(pDev, Head, 0xCC);
    return(RM_OK);
}

//****************************************************************************************
//  Program the Brooktree device for a display mode
static RM_STATUS dacProgramBrooktree(PHWINFO pDev, U032 Head)
{
U016    i, status;
U008    *strptr, *strptr2;
U008    Data, TVmode;

    status = RM_OK;

    // to send a string to the I2C: send the start sequence, send the string, send the stop sequence

    TVmode = dacGetTVmode(pDev, Head);
    // Turn DAC on
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);   // subaddress
    status |= i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, (U008) BT_DAC_ON);    // DAC ON
    i2cStop(pDev, Head,  pDev->Dac.TVOutPortID);
    tmrDelay(pDev, 20000000);   // delay 20 ms to allow DAC to power up. If we don't wait, check status could give wrong input.
    
    // Use Autoconfiguration for 871
    if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871)
    {
        dacProgramBrooktreeAuto(pDev, Head);

        // Set Check Status bit to tell encoder to check for TV connected.
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);    // subaddress
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_STAT);   // set check stat
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

        // Using 871 non-legacy readback, Read Monitor Status bits into Data.
        Data = dacTVReadReg(pDev, Head, 0x6);

        // Reset Check Status -- not documented, but very important (can't program encoder if not done).
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);    // subaddress
        if (Data & BT_MONSTAT_A)   // see if A is loaded
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_OFF); // set check stat off, turn on all DAC's
        else
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_OFF_A_OFF); // set check stat, turn off DAC A
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    }
    else
    {
        // send an init string
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        strptr = (U008 *)&BT_Init;          // send init sequence
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        for (i=0; *strptr != 0xff; i++)
        {
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  
            if (status)
                break;
        }     
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C

        // Get pointers to the strings to write to the I2C controller.
        // One string sets the timing for a particular resolution.
        // The other string sets the position (centering).
        switch (pDev->Dac.TVStandard)
        {
            case NTSC_M:
                strptr = (U008 *)Bt_NM[TVmode];
                strptr2 = (U008 *)Btc_NM[TVmode];
                break;
            case NTSC_J:
                strptr = (U008 *)Bt_NJ[TVmode];
                strptr2 = (U008 *)Btc_NJ[TVmode];
                break;
            case PAL_NC:
                strptr = (U008 *)Bt_NC[TVmode];
                strptr2 = (U008 *)Btc_NC[TVmode];
                break;
            case PAL_A:
                strptr = (U008 *)Bt_PA[TVmode];
                strptr2 = (U008 *)Btc_PA[TVmode];
                break;
            case PAL_M:
                strptr = (U008 *)Bt_PM[TVmode];
                strptr2 = (U008 *)Btc_PM[TVmode];
                break;
            case PAL_N:
                strptr = (U008 *)Bt_PN[TVmode];
                strptr2 = (U008 *)Btc_PN[TVmode];
                break;
            default:
                strptr = (U008 *)Bt_NM[TVmode];
                strptr2 = (U008 *)Btc_NM[TVmode];
                break;
        }
        // send a timing string
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        for (i=0; *strptr != 0xff; i++)
        {
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);
            if (status)
                break;
        }
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C

        // send a centering string
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        for (i=0; *strptr2 != 0xff; i++)
        {
            Data = *strptr2++;
            if (i == 1) // second byte is H Offset, which differs between NV4 and NV5
            {
                if(IsNV4(pDev))
                {
                    // NV4 timing 8-16 pixels different, generally
                    if (TVmode <= TV_MODE_400x300)
                        Data -= 16;
                    else
                        Data -= 8; 
                    switch (TVmode)
                    {
                        case TV_MODE_400x300:
                            if ((pDev->Dac.TVStandard != NTSC_M) && (pDev->Dac.TVStandard != NTSC_J))
                                Data = 0x31;
                            break;
                        case TV_MODE_640x480:                                           
                            if ((pDev->Dac.TVStandard != NTSC_M) && (pDev->Dac.TVStandard != NTSC_J))
                                Data = 0xa2;
                            break;
                        case TV_MODE_800x600:
                            if ((pDev->Dac.TVStandard != NTSC_M) && (pDev->Dac.TVStandard != NTSC_J))
                                Data = 0x22;
                            else
                                Data = 0xd8;
                            break;
                        case TV_MODE_320x200:
                            if ((pDev->Dac.TVStandard != NTSC_M) && (pDev->Dac.TVStandard != NTSC_J))
                                Data = 0xca;
                            break;
                    }
                }
            }
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, Data);
            if (status)
                break;
        }
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C

        // Set Check Status bit to tell encoder to check for TV connected.
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);    // subaddress
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_STAT);   // set check stat
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

        // Set Estat to select status register 1
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0xC4);  // subaddress
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x41);  // set estat (estat 01 + en_out)
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

        // Read Monitor Status bits into Data
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID+1));
        i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &Data, 1);
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

        // Reset Check Status -- not documented, but very important (can't program encoder if not done).
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);    // subaddress
        if (Data & BT_MONSTAT_A)   // see if A is loaded
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_OFF); // set check stat off, turn on all DAC's
        else
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_OFF_A_OFF); // set check stat, turn off DAC A
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    }

    // Read registry to decide how to output on the S-video connector--do we use straight
    // S-video, or do we output composite?
    // DAC A is always composite out. DAC B and C are S-video (chroma and luma).
    // If the user has an S-video cable attached to a TV with composite input, we want
    // to output composite on the S-video (DAC C). We try to sense whether both 
    // B and C are loaded (S-video) or only C is loaded (composite).
    // Unfortunately, we may falsely detect composite even with an S-video monitor,
    // so the registry setting is necessary to override our detection.
    // Brooktree reg CE: D7  D6  D5  D4  D3  D2  D1  D0
    //                   MUX D   MUX C   MUX  B  MUX  A 
    // MUX n:   00 = output Video 0 on DAC n
    //          01 =              1
    //          10 =              2
    //          11 =              3
    // Our default init is 18 -- DAC A = mode 0, DAC B = mode 2, DAC C = mode 1
    // DAC A is always set to composite out (mode 0), which has a value of 0.
    switch (pDev->Dac.TVoutput)
    {
        case NV_CFG_VIDEO_OUTPUT_FORMAT_AUTOSELECT:
            if ((Data & BT_MONSTAT) == BT_MONSTAT_C)    // Stat A, B, C
            {
                // Set composite out on B if DAC C only is loaded.
                // Set DAC C to output composite.
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX);    // subaddress
                // mode 2 on DAC B,  mode 0 on DAC C
                status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (BT_OUT_MUX_B_COMP | BT_OUT_MUX_C_COMP));
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }
            else
            {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX);    // subaddress
                // mode 2 on DAC B, mode 1 on DAC C
                status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (BT_OUT_MUX_B_SVID | BT_OUT_MUX_C_ALL));    
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }
            break;
        case NV_CFG_VIDEO_OUTPUT_FORMAT_FORCE_COMPOSITE:
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX);    // subaddress
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (BT_OUT_MUX_B_COMP | BT_OUT_MUX_C_COMP));   
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            break;
        case NV_CFG_VIDEO_OUTPUT_FORMAT_FORCE_SVIDEO:
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX);    // subaddress
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (BT_OUT_MUX_B_SVID | BT_OUT_MUX_C_ALL));    
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            break;
        default:
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX);    // subaddress
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX_B_SVID | BT_OUT_MUX_C_ALL);  
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            break;
    }

    // If no head is using TV, blank image.
    for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
        if (GETDISPLAYTYPE(pDev, i) == DISPLAY_TYPE_TV)
            break;
    if (i == pDev->Dac.HalInfo.NumCrtcs)
        dacDisableTV(pDev, Head);

    return (status);
} // end of dacProgramBrooktree

//****************************************************************************************
//
//  Program the Chrontel device for a display mode
//  args:       internal TV mode
//  returns:    status word
static RM_STATUS dacProgramChrontel(PHWINFO pDev, U032 Head)
{    
    RM_STATUS status;
    U016    i;
    U008    *strptr, FsciReg, read, hDelayPM;
    U032    hRes, vRes, reg32, hTotalPM, vTotalPM;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
   
    if (pDev->Dac.EncoderType == NV_ENCODER_NONE) 
    {
        // Used to check for known Chrontel types. Checking in dacinit now, this is probably useless.
        return ERR_I2C_UNKNOWN;
    }
    status = RM_OK;
    // to send a string to the I2C: send the start sequence, send the string, send the stop sequence
    // Chrontel 7007 wants bit 7 of the register address set (on others it's a don't care).
        
    // Get resolution
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    hRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    vRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;

    // power up
    dacEnableTV(pDev, Head);
    
    // send an init string
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   // start state for I2C
    strptr = (U008 *)&CH_Init;     // send init sequence
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    strptr++;                                  // string includes ID, skip it
    for (i=0; *strptr != 0xff; i++)
    {
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  
        if (status)
            break;
    }     
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C

    // get a pointer to the string to write to the I2C controller
    status = dacGetI2CModeString(pDev, Head, hRes, vRes, &strptr, &hTotalPM, &vTotalPM, &hDelayPM);
    if (status)
    {
        // could not get the encoder string for this mode.
        return ERR_I2C_MODE;
    }
            
    //the init string may have put put the 7007 into master mode.
    //but we may want pseudo-master mode (where we provide syncs, 7007 provides clock)
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_0D);
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                                        //restart
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));    //read
    i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read, 1);
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

    read |= 0x04;
    switch (pDev->Dac.EncoderType)
    {
        case NV_ENCODER_CHRONTEL_7007:
        case NV_ENCODER_CHRONTEL_7008:
            if (IsNV11(pDev) || IsNV20(pDev))
            {
                if (!pDev->Dac.TVMasterMode)
                {
                    //these sync widths apply to every mode
                    DAC_REG_WR32(NV_PRAMDAC_TV_VSYNC_START,  0x00000001, Head);
                    DAC_REG_WR32(NV_PRAMDAC_TV_VSYNC_END,    0x00000010, Head);
                    DAC_REG_WR32(NV_PRAMDAC_TV_HSYNC_START,  0x00000001, Head);
                    DAC_REG_WR32(NV_PRAMDAC_TV_HSYNC_END,    0x00000040, Head);

                    //some modes need a horizontal sync delay
                    reg32  =  DAC_REG_RD32(NV_PRAMDAC_TV_SYNC_DELAY,   Head);
                    reg32 &= ~DRF_NUM(_PRAMDAC, _TV_SYNC_DELAY, _HSYNC,  0xFFFFFFFF);
                    reg32 |=  DRF_NUM(_PRAMDAC, _TV_SYNC_DELAY, _HSYNC,  hDelayPM);
                    DAC_REG_WR32(NV_PRAMDAC_TV_SYNC_DELAY, reg32,  Head);

                    //htotal and vtotal need to match what
                    //the encoder will expect to receive.
                    reg32  =  DAC_REG_RD32(NV_PRAMDAC_TV_HTOTAL,   Head);
                    reg32 &= ~DRF_NUM(_PRAMDAC, _TV_HTOTAL, _VAL,  0xFFFFFFFF);
                    reg32 |=  DRF_NUM(_PRAMDAC, _TV_HTOTAL, _VAL,  hTotalPM);
                    DAC_REG_WR32(NV_PRAMDAC_TV_HTOTAL, reg32,  Head);

                    reg32  =  DAC_REG_RD32(NV_PRAMDAC_TV_VTOTAL,   Head);
                    reg32 &= ~DRF_NUM(_PRAMDAC, _TV_VTOTAL, _VAL,  0xFFFFFFFF);
                    reg32 |=  DRF_NUM(_PRAMDAC, _TV_VTOTAL, _VAL,  vTotalPM);
                    DAC_REG_WR32(NV_PRAMDAC_TV_VTOTAL, reg32,  Head);
                    
                    //tell Chrontel to expect syncs from the slave
                    read &= ~0x04;
                }
            }
            break;
    }

    //write modified reg 0x0D back out to hardware
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_0D);
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

    // send a timing string
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   // start state for I2C
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    strptr++;                                  // string includes ID, skip it
    for (i=0; *strptr != 0xff; i++)
    {
//        DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, " ", *strptr);
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);
        if (status)
            break;
    }
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C

    // send default flicker filter, brightness, and contrast
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   // start state for I2C
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    strptr = (U008 *)&CH_FBC;
    strptr++;                                  // string includes ID, skip it
    for (i=0; *strptr != 0xff; i++)
    {
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);
        if (status)
            break;
    }
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C
    
    // Set register 21 for PAL/NTSC, and reg 3 for mode 24 (800x600 NTSC)
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   // start state for I2C
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    
    // Reg 3 bit 7 set for mode 24 only. (Flicker filter used in 7/10 scaling modes)
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_03); // reg 3 
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x00); // 
    
    switch (pDev->Dac.TVStandard) // not supporting scaling on PAL. What happens on NTSC unscaled modes?
    {
        case NTSC_J:
        case NTSC_M:
            if ((hRes == 800) || (hRes == 720) || ((hRes == 640) && (vRes == 480)))
            {
                // 800x600 & 640x480 modes use programmed FSCI values (subcarrier frequency), others use subcarrier free-run
                // set carrier free-run bit in reg 6 and clear ACIV bit in reg 21

                // set carrier free-run bit
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // 
                read |= CH_CFR;                                             // set carrier freerun
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
                
                // Clear ACIV bit            
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_21); // reg 21
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x00); 
                
                switch (hRes)
                {
                case 800:
                    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_03); // reg 3 
                    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x80); // 
                    strptr = (U008 *)&CH_FSCI_800x600;
                    break;
                case 720:
                    if (vRes == 576) {
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_03); // reg 3 
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x80); // 
                
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_08); // reg 8
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x30); // 

                        strptr = (U008 *)&CH_FSCI_720x576;
                    } else {
                        strptr = (U008 *)&CH_FSCI_720x480;
                    }
                    break;
                case 640:
                default:
                    strptr = (U008 *)&CH_FSCI_640x480;
                    break;
                }

                FsciReg = CH_REG_18; // starting at reg 0x18
                for (i=0; i<numFSCIbytes; i++) 
                {
                    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, FsciReg++); // 
                    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++); // 
                }
            }
            else    // Other NTSC modes use subcarrier free run
            {
                // set ACIV 
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_21); // reg 21
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, 0x01); // reg 21 bit 0 = 1 -> automatically increment subcarrier
                i2cStop(pDev, Head,  pDev->Dac.TVOutPortID);                       // end state for I2C

                // clear carrier free-run bit when in ACIV mode
                i2cStart(pDev, Head,  pDev->Dac.TVOutPortID);                      // start state for I2C
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
                i2cStart(pDev, Head,  pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                i2cReceiveByte(pDev, Head,  pDev->Dac.TVOutPortID, &read,1);
                i2cStop(pDev, Head,  pDev->Dac.TVOutPortID);                       // 
                read &= ~CH_CFR;                                            // clear carrier freerun
                i2cStart(pDev, Head,  pDev->Dac.TVOutPortID);                      // start state for I2C
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, read);  
            }
            break;
        case PAL_NC:
            // set carrier free-run bit
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // 
            read |= CH_CFR;                                             // set carrier freerun
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  

            // Clear ACIV bit            
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_21); // reg 21
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x00); 
            switch (hRes) 
            {
                case 640:
                case 320:
                    strptr = (U008 *)&CH_FSCI_640x480NC;
                break;
                case 720:
                    if (vRes == 576) {
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_08); // reg 8
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x01); // 
                        strptr = (U008 *)&CH_FSCI_720x576NC;
                    } else {
                        strptr = (U008 *)&CH_FSCI_720x480NC;
                    }
                break;
                case 800:
                case 400:
                    strptr = (U008 *)&CH_FSCI_800x600NC;
                break;
                default:
                    strptr = (U008 *)&CH_FSCI_640x480NC;    // 512x384 will fit in 640x480
            }
            FsciReg = CH_REG_18; // starting at reg 0x18
            for (i=0; i<numFSCIbytes; i++) 
            {
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, FsciReg++); // 
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++); // 
            }
            break;
        default:
        {
            // set ACIV 
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_21); // reg 21
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x01); // reg 21 bit 0 = 1 -> automatically increment subcarrier
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C

            // clear carrier free-run bit when in ACIV mode
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // 
            read &= ~CH_CFR;                                            // clear carrier freerun
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
        }
    }
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C
    
    // Set gain of DAC. Read/modify/write reg 4. NTSC-M and PAL-M use one level, all others use another level.
    switch (pDev->Dac.TVStandard) 
    {
        case NTSC_M:
        case PAL_M:
        {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_04); // reg 4
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
            read &= CH_GAIN;                                            // set GAIN bits
            read |= CH_GAIN_NTSC;
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_04); // reg 4
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
            break;
        }
        default:
        {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_04); // reg 4
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
            read &= CH_GAIN;                                            // set GAIN bits
            read |= CH_GAIN_PAL;
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_04); // reg 4
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
        }
    }
    // Default TV standards (in Chrontel reg 0) is 00 (PAL) or 01 (NTSC). There are 2 bits, so 4 combinations.
    // PAL B, D, G, H, I, N, NC = 00
    // NTSC-M                   = 01
    // PAL-M                    = 10
    // NTSC-J                   = 11
    
    // Set special TV standards
    if (pDev->Dac.TVStandard == NTSC_J) 
    {
        // NTSC-J should have reg 0[4:3] = 11
        // Read/Modify/Write reg 0
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_00); // reg 0
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
        i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
        read |= CH_NTSC_J;                                          // set NTSC-J bits
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_00); // reg 0
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
        
        // Brightness range for NTSC-J is wider
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_09); // reg 9
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_BL_J);  
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
    
    }
    if (pDev->Dac.TVStandard == PAL_M) 
    {
        // PAL-M should have reg 0[4:3] = 10. 
        // Read/Modify/Write reg 0
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_00); // reg 0
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
        i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
        read &= 0xe7;                                               // mask bits 4:3
        read |= CH_PAL_M;                                           // set PAL_M bits
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_00); // reg 0
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
    }
    // Fix for NV15/NV20: invert encoder clock out, to give NV a little more time to sample HSYNC.
    if (IsNV15orBetter(pDev)) 
    {
        // check for registry key to override this default behavior
        if (!pDev->Dac.TVClockInversionDisabled)
            dacTVReadModifyWrite(pDev, Head, CH_REG_1B, 0x10, 0x10);
    }
    return (status);
} // end of dacProgramChrontel

//****************************************************************************************
RM_STATUS dacSendEncoderString(PHWINFO pDev, U032 Head, U008 *strptr, U016 len)
{
RM_STATUS status;
U016 i;

    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   // start state for I2C
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    for (i=0; i<len; i++)
    {
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  
        if (status)
            break;
    }     
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C
    return (status);
}

//****************************************************************************************
//
//  Program the Philips device for a display mode
//  args:       internal TV mode
//  returns:    status word
static RM_STATUS dacProgramPhilips(PHWINFO pDev, U032 Head)
{    
    RM_STATUS status;
    U008    read, tvdacs;
    U032    hRes, vRes;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    // to send a string to the I2C: send the start sequence, send the string, send the stop sequence

    // Get resolution
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    hRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    vRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;

    // Send the init strings
    // Each string is a block of consecutive registers, some blocks are unique to the TV standard.
    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_Gen_Init0, Ph_Gen_Init0_Len);
    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_Gen_Init1, Ph_Gen_Init1_Len);
    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_Gen_Init2, Ph_Gen_Init2_Len);

    switch (pDev->Dac.TVStandard)
    {
        case NTSC_M:
        case NTSC_J:
            // Do NTSC init
            status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_NTSC_Init0, Ph_NTSC_Init0_Len);
            status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_NTSC_Init1, Ph_NTSC_Init1_Len);
            // Program the resolution    
            switch (hRes)
            {
                case 320:
                case 640:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_NTSC_640, Ph_NTSC_Res_Len);
                    break;        
                case 400:
                case 800:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_NTSC_800, Ph_NTSC_Res_Len);
                    break;
                default:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_NTSC_640, Ph_NTSC_Res_Len);
            }            
            break;        
        break;

        case PAL_M:
        case PAL_A:
        case PAL_N:
        case PAL_NC:
            // Do PAL init
            status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_PAL_Init0, Ph_PAL_Init0_Len);
            status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_PAL_Init1, Ph_PAL_Init1_Len);
            // Program the resolution    
            switch (hRes)
            {
                case 320:
                case 640:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_PAL_640, Ph_PAL_Res_Len);
                    break;        
                case 400:
                case 800:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_PAL_800, Ph_PAL_Res_Len);
                    break;
                default:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_PAL_640, Ph_PAL_Res_Len);
            }            
            break;
        break;
    }

    if (pDev->Dac.EncoderType == NV_ENCODER_PHILIPS_7108B)
    {
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);  
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x54); // reg 54[1:0] = clocking mode (inverted on B)
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 2);    // 1 on later devices, 2 on 7108B
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
    }

    switch (pDev->Dac.EncoderType)
    {
        case NV_ENCODER_PHILIPS_7102:
        case NV_ENCODER_PHILIPS_7108:
        case NV_ENCODER_PHILIPS_7108B:
            //read output port control
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
            status  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x2d);
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &tvdacs,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

            switch (pDev->Dac.TVoutput)
            {
                case NV_CFG_VIDEO_OUTPUT_FORMAT_FORCE_COMPOSITE:
                    read = ~0x03;  //GREEN and BLUE connected
                    break;

                case NV_CFG_VIDEO_OUTPUT_FORMAT_FORCE_SVIDEO:
                    read = ~0x06;  //RED and GREEN connected
                    break;

                default:
                case NV_CFG_VIDEO_OUTPUT_FORMAT_AUTOSELECT:
                    //set monitor sense threshold
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                    status  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1a);   // subaddress
                    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x46);   // MSM threshold
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    
                    //set monitor sense mode
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                    status  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1b);   // subaddress
                    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x80);   // MSM
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

                    //read sense bits
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    status  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x1b);
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART
                    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                    i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

                    //reset monitor sense mode
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                    status  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1b);   // subaddress
                    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x00);   // MSM
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                    break;
            }

            if (~read & 0x01)  //BLUE connected
                tvdacs |=  0x20;  //CVBSEN0=1  (CVBS out the blue DAC)

            switch (~read & 0x06)
            {
                case 0x02: //GREEN only
                    tvdacs |=  0x40;    //CVBSEN1=1
                    tvdacs &= ~0x80;    //VBSEN=0 (CVBS out the green DAC.)
                    break;

                case 0x06: //RED and GREEN
                    tvdacs &= ~0x40;    //CVBSEN1=0 (luminance out the green DAC.)
                    tvdacs |=  0x90;    //CEN=1, VBSEN=1 (chroma out the red DAC, luma out the green DAC.)
                    break;
            }

            //set output port control
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
            status  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x2d);
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, tvdacs);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            break;
    }

    return (status);
} // end of dacProgramPhilips

//*************************** Exported functions *****************************************
//
//  Program the I2C device for a display mode
//  returns:    status word
RM_STATUS dacSetupTVEncoder(PHWINFO pDev, U032 Head)   
{
    RM_STATUS status;

    pDev->Dac.DevicesEnabled |= DAC_TV_ENABLED;
    // Identify which part: Chrontel or Brooktree?
    // ID was done at dacInit.
    switch (TV_ENCODER_FAMILY(pDev->Dac.EncoderType))
    {
        case TV_ENCODER_NONE:
            status = ERR_I2C_UNKNOWN;
            break;                        
        case TV_ENCODER_BROOKTREE:
            i2cInit(pDev, Head, pDev->Dac.TVOutPortID);
            status = dacProgramBrooktree(pDev, Head);
            break;
        case TV_ENCODER_CHRONTEL:
            i2cInit(pDev, Head, pDev->Dac.TVOutPortID);
            status = dacProgramChrontel(pDev, Head);
            break;                        
        case TV_ENCODER_PHILIPS:
            i2cInit(pDev, Head, pDev->Dac.TVOutPortID);
            status = dacProgramPhilips(pDev, Head);
            break;                        
        default:
            status = ERR_I2C_UNKNOWN;
            break;                        
    }
    return (status);
}

RM_STATUS dacAdjustCRTC_CH(PHWINFO pDev, U032 Head)
{
    RM_STATUS status;
    U008    data, hbeAdjust;
    U016    data16;
    TV_ADJUST * adjustEntry;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032    hRes, vRes;
    
    // Get resolution
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    hRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    vRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;

    // Look up the array of CRTC adjustments for Chrontel
    status = dacGetTVAdjustTableEntry(pDev,Head,
                                      hRes,
                                      vRes,
                                      &adjustEntry);
    if (status)
    {
        // did not find a match.
        return status;
    }
    switch (pDev->Dac.TVStandard)
    {
        case NTSC_M:
        case NTSC_J:
            if ((hRes == 720) && (vRes == 576)) {
                CRTC_WR(NV_CIO_CR_HDT_INDEX, adjustEntry->CR00, Head);
                CRTC_WR(NV_CIO_CR_VRS_INDEX, adjustEntry->CR10, Head);
                break;
            }
            //else, fall through to next section
        case PAL_M:
            if ((hRes == 720) && (vRes == 480)) {
                CRTC_WR(NV_CIO_CR_HDT_INDEX, adjustEntry->CR00, Head);
                CRTC_WR(NV_CIO_CR_VDT_INDEX, adjustEntry->CR06, Head);
            }
            else
            {
                CRTC_WR(NV_CIO_CR_HDT_INDEX, adjustEntry->CR00, Head);
                CRTC_WR(NV_CIO_CR_HRS_INDEX, adjustEntry->CR04, Head);
                CRTC_WR(NV_CIO_CR_VDT_INDEX, adjustEntry->CR06, Head);
                CRTC_WR(NV_CIO_CR_OVL_INDEX, adjustEntry->CR07, Head);
                CRTC_WR(NV_CIO_CR_RSAL_INDEX, adjustEntry->CR08, Head);
                CRTC_WR(NV_CIO_CR_VRS_INDEX, adjustEntry->CR10, Head);
                CRTC_WR(NV_CIO_CR_VDE_INDEX, adjustEntry->CR12, Head);
                if (IsNV4(pDev))    // NV4 timing is slightly different
                {
                    if (vRes == 240) 
                        CRTC_WR(NV_CIO_CR_RSAL_INDEX, 0x60, Head);
                    if  (vRes == 300)
                        CRTC_WR(NV_CIO_CR_RSAL_INDEX, 0x40, Head);
                }
                CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);      // read pixel format
                data |= adjustEntry->CR28;        // OR with horizontal pixel adjust and slave TV to encoder
                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);
                // write Seq 01
                WriteIndexed(NV_PRMVIO_SRX, (U016) ((adjustEntry->SR01 << 8) | NV_PRMVIO_SR_CLOCK_INDEX));         
            }
            break;

        case PAL_A:
        case PAL_N:
        case PAL_NC:
            CRTC_WR(NV_CIO_CR_HDT_INDEX, adjustEntry->CR00, Head);
            CRTC_WR(NV_CIO_CR_HRS_INDEX, adjustEntry->CR04, Head);
            CRTC_WR(NV_CIO_CR_VDT_INDEX, adjustEntry->CR06, Head);
            CRTC_WR(NV_CIO_CR_OVL_INDEX, adjustEntry->CR07, Head);
            CRTC_WR(NV_CIO_CR_RSAL_INDEX, adjustEntry->CR08, Head);
            CRTC_WR(NV_CIO_CR_VRS_INDEX, adjustEntry->CR10, Head);
            CRTC_WR(NV_CIO_CR_VDE_INDEX, adjustEntry->CR12, Head);
            if (IsNV4(pDev))    // NV4 timing is slightly different
            {
                if ((vRes == 200) ||
                    (vRes == 240) ||
                    (vRes == 300) ||
                    (vRes == 384))
                    CRTC_WR(NV_CIO_CR_RSAL_INDEX, 0x20, Head);
                if (vRes == 480)
                    CRTC_WR(NV_CIO_CR_HRS_INDEX, adjustEntry->CR04 + 1, Head);
            }
            CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);      // read pixel format
            data |= adjustEntry->CR28;           // OR with horizontal pixel adjust and slave TV to encoder
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);

            // write Seq 01
            WriteIndexed(NV_PRMVIO_SRX, (U016) ((adjustEntry->SR01 << 8) | NV_PRMVIO_SR_CLOCK_INDEX));         
            break;
    }
    if (hRes == 320)
    {
        // adjust HBE = HT. This lets the cursor move across the whole screen.
        CRTC_RD(NV_CIO_CR_HDT_INDEX, data16, Head);           // get HT (CR0)
        CRTC_RD(NV_CIO_CR_HBE_INDEX, data, Head);             // CR03
        data &= ~0x1f;                                  // lose the HBE bits
        data |= (U008) data16 & 0x1F;
        CRTC_WR(NV_CIO_CR_HBE_INDEX, data, Head);             // HBE 4:0
        pDev->Framebuffer.CursorAdjust = 8;
    }
    else
    {
        if (hRes == 400)
        {
            // 400x300
            CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);          // get CR28
            data &= ~0x38;
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data | (5<<3), Head); // bits[5:3] shift 5 pixels right        
            pDev->Framebuffer.CursorAdjust = 0;
            if (pDev->Dac.TVStandard == NTSC)   // PAL 400x300 requires special case for HBE for cursor position
                hbeAdjust = 4;
            else                
                hbeAdjust = 2;
        }
        else
        {
            pDev->Framebuffer.CursorAdjust = 5;
            hbeAdjust = 4;
        }
        // adjust HBE = HT + 4. This lets the cursor move across the whole screen.
        CRTC_RD(NV_CIO_CR_HDT_INDEX, data16, Head);           // get HT (CR0)
        CRTC_RD(NV_CIO_CRE_HEB__INDEX, data, Head);           // MS bit HT (CR2D)            
        if (data & 1)
            data16 |= 0x100;
        data16 += hbeAdjust;                            // HT effective
    
        CRTC_RD(NV_CIO_CR_HBE_INDEX, data, Head);             // CR03
        data &= ~0x1f;                                  // lose the HBE bits
        data |= (U008) data16 & 0x1F;
        CRTC_WR(NV_CIO_CR_HBE_INDEX, data, Head);             // HBE 4:0

        CRTC_RD(NV_CIO_CR_HRE_INDEX, data, Head);             // CR05
        data &= ~0x80;                                  // lose the HBE bit
        if (data16 & 0x20)
            data |= 0x80;
        CRTC_WR(NV_CIO_CR_HRE_INDEX, data, Head);             // HBE 5
                            
        CRTC_RD(NV_CIO_CRE_LSR_INDEX, data, Head);            // CR25
        data &= ~0x10;
        if (data16 & 0x40)
            data |= 0x10;
        CRTC_WR(NV_CIO_CRE_LSR_INDEX, data, Head);            // HBE 6
    }
    // adjust normally scanline doubled modes which are not doubled for TV
    // (512x384 and 480x360)
    if (hRes == 512 ||   // 512x384
        hRes == 480)     // 480x360
    {
        CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, 0x40, Head);
    }
    if (!IsNV4(pDev))
        pDev->Framebuffer.CursorAdjust = 0; // cursor adjust not needed 

    return status;
}

RM_STATUS dacAdjustCRTC_BT(PHWINFO pDev, U032 Head)
{
RM_STATUS status = RM_OK;
U008    tvmode, data;
U016    data16;

        // Use the "TV mode number" lookup method
        tvmode = dacGetTVmode(pDev, Head);

        // adjust normally scanline doubled modes which are not doubled for TV
        if ((tvmode == TV_MODE_512x384) | (tvmode == TV_MODE_480x360))
            CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, 0x40, Head);

        if (tvmode <= TV_MODE_400x300)
            WriteIndexed(NV_PRMVIO_SRX, 0x901); // dot clock /2 for low res modes

        // Horizontal adjustment is very simple: HT = HDE + 2, HRS = HDE + 1
        CRTC_RD(NV_CIO_CR_HDE_INDEX, data, Head);           // get HDE
        CRTC_WR(NV_CIO_CR_HRS_INDEX, data + 1, Head);       // write HRS
        if (tvmode == TV_MODE_400x300)  // 400x300 is a special case
            data += 1;
        else
            data += 2;
        CRTC_WR(NV_CIO_CR_HDT_INDEX, data, Head);   // write HT=DE+2
        
        // NV10 makes us do some more special casing. The reason is that the video overlay
        // syncs to the CRTC differntly. Instead of using display end, it syncs off the blank
        // signal, so we have to make an adjustment to HBE.
        // We'll also add offsets via PVIDEO_POINT_OUT (see class63 for NV10).
        if (IsNV10orBetter(pDev)) 
        {
            if (tvmode == TV_MODE_640x480)
            {
                CRTC_WR(NV_CIO_CR_HBE_INDEX, 0x95, Head);       // write HBE
                CRTC_WR(NV_CIO_CR_HRE_INDEX, 0x1F, Head);       // write HBE msb
            }
            if (tvmode == TV_MODE_800x600)
            {
                CRTC_WR(NV_CIO_CR_HBE_INDEX, 0x89, Head);       // write HBE
                CRTC_WR(NV_CIO_CR_HRE_INDEX, 0x9A, Head);       // write HBE msb
            }
        }
        // Vertical total must be adjusted per resolution
        switch (pDev->Dac.TVStandard)
        {
            case NTSC_M:
            case NTSC_J:
            case PAL_M:
                CRTC_WR(NV_CIO_CR_VDT_INDEX, VT_BT_NTSC[ tvmode ], Head);
                break;              
            case PAL_A:
            case PAL_N:
            case PAL_NC:
                CRTC_WR(NV_CIO_CR_VDT_INDEX, VT_BT_PAL[ tvmode ], Head);
                break;
            default:
                CRTC_WR(NV_CIO_CR_VDT_INDEX, VT_BT_NTSC[ 0 ], Head);    // default to NTSC_M
        }
        if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871)
        {
            // Adjust CRTC vertical -- adjustment is dependent on mode (Conexant mode, i.e. overscan ration, as well as resolution)
            if (tvmode == TV_MODE_640x480)
            {
//                CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x18, Head);   
                CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x41, Head);     // normal 
//                CRTC_WR(NV_CIO_CR_VRS_INDEX, 0xF6, Head);     
            }
            if (tvmode == TV_MODE_800x600)
            {
                switch (pDev->Dac.TVStandard)
                {
                    case PAL_NC:
                    case PAL_A:
                    case PAL_N:
                        CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x64, Head);
                        CRTC_WR(NV_CIO_CR_HDE_INDEX, 0x64, Head);
                        CRTC_WR(NV_CIO_CR_HBS_INDEX, 0x65, Head);
                        CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x65, Head);
                        CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xC5, Head);
                        break;

                    case PAL_M:     //525,60Hz PAL
                        CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x62, Head);
                        CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xC4, Head);
                        break;

                    case NTSC_M:
                    case NTSC_J:
                        // Adjust CRTC vertical
                        CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xB5, Head);
                        break;              
                }
            }
            if (tvmode == TV_MODE_1024x768)
            {
                CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x83, Head);   
                // Adjust horizontal skew
                CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);          // get CR28
                data &= ~0x38;
                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data | (4<<3), Head); // bits[5:3] shift 4 pixels right        
            }
            if (IsNV15orBetter(pDev))   //RYAN@20010420, this might apply to older, too... but I don't know.
            {
                if (tvmode == TV_MODE_640x400)
                {
                    switch (pDev->Dac.TVStandard)
                    {
                        case PAL_M:     //525,60Hz PAL
                        case NTSC_M:
                        case NTSC_J:
                            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x62, Head);
                            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xE6, Head);
                            break;              
                    }
                }
                if (tvmode == TV_MODE_320x200)
                {
                    switch (pDev->Dac.TVStandard)
                    {
                        case PAL_M:     //525,60Hz PAL
                        case NTSC_M:
                        case NTSC_J:
                            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x2C, Head);
                            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xE5, Head);
                            break;              
                    }
                }
                if (tvmode == TV_MODE_320x240)
                {
                    //RYAN@TVOUT, it doesn't seem possible to dial these modes in perfectly.
                    //perhaps if we switch to pseudo-master mode...
                    switch (pDev->Dac.TVStandard)
                    {
                        case PAL_A:
                        case PAL_NC:
                        case PAL_N:
                            //add more front porch to the total horizontal time
                            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x3E, Head);   //increase HTOTAL
                            CRTC_WR(NV_CIO_CR_HDE_INDEX, 0x27, Head);   //start of HBLANK
                            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x38, Head);   //put sync near end of line
                            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x41, Head);
                            break;

                        case PAL_M:     //525,60Hz PAL
                            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x2E, Head);
                            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x42, Head);
                            break;

                        case NTSC_M:
                        case NTSC_J:
                            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x25, Head);
                            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x41, Head);
                            break;
                    }
                }
            }
        }
        if (tvmode == TV_MODE_480x360)  // a special case
        {
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0xe806);     // VT
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0xb207);     // extra bits
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x9010);     // VRS
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x6712);     // VDE
        }
        if (tvmode == TV_MODE_512x384)  // another special case
        {
            // On a monitor, the vertical is 768, scan doubled.
            // On the TV, we want 384.
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x7f12);     // VDE
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0xb707);     // extra bits
        }
        // NV4 has a hw bug which requires adjustment to the cursor position
        if (IsNV4(pDev))
        {
            // adjust HBE = HT + 4. This lets the cursor move across the whole screen.
            CRTC_RD(NV_CIO_CR_HDT_INDEX, data16, Head);           // get HT (CR0)
            CRTC_RD(NV_CIO_CRE_HEB__INDEX, data, Head);           // MS bit HT (CR2D)            
            if (data & 1)
                data16 |= 0x100;
            data16 += 4;                                    // HT effective

            CRTC_RD(NV_CIO_CR_HBE_INDEX, data, Head);             // CR03
            data &= ~0x1f;                                  // lose the HBE bits
            data |= (U008) data16 & 0x1F;
            CRTC_WR(NV_CIO_CR_HBE_INDEX, data, Head);             // HBE 4:0

            CRTC_RD(NV_CIO_CR_HRE_INDEX, data, Head);             // CR05
            data &= ~0x80;                                  // lose the HBE bit
            if (data16 & 0x20)
                data |= 0x80;
            CRTC_WR(NV_CIO_CR_HRE_INDEX, data, Head);             // HBE 5
                            
            CRTC_RD(NV_CIO_CRE_LSR_INDEX, data, Head);            // CR25
            data &= ~0x10;
            if (data16 & 0x40)
                data |= 0x10;
            CRTC_WR(NV_CIO_CRE_LSR_INDEX, data, Head);            // HBE 6
            switch (tvmode)
            {
                // modes which are shoehorned in to 640x400 need a horiz cursor adjustment
                case TV_MODE_512x384:
                case TV_MODE_480x360:
                // likewise 640 modes
                case TV_MODE_640x400:
                case TV_MODE_640x480:
                case TV_MODE_800x600:
                    pDev->Framebuffer.CursorAdjust = 5;
                    break;          
                default:
                    pDev->Framebuffer.CursorAdjust = 0;
            }
        }
        return status;
} 


void dacSetTvoutLatency(PHWINFO pDev, U032 Head, U008 latency)
{
    U008 data;

    latency &= 0x07;

    CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);
    data &= ~0x38;
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data | (latency<<3), Head); // bits[5:3]
}


RM_STATUS dacAdjustCRTC_PH(PHWINFO pDev, U032 Head)
{
    RM_STATUS status = RM_OK;

    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032    hRes, vRes, std;

    // Get resolution
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    hRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    vRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;

#define NV_ARCH(pDev) ((pDev->halHwInfo.pMcHalInfo->Architecture & 0x30)   >> 4) //2 bits
#define NV_IMPL(pDev) ((pDev->halHwInfo.pMcHalInfo->Implementation & 0x07) >> 0) //3 bits
#define NV_CHIP(pDev) ((NV_ARCH(pDev) << 3) | NV_IMPL(pDev))  //5 bits

#define TV_CHIPMASK 0xFE000000  /* 7  bits */
#define TV_HRESMASK 0x01FFC000  /* 11 bits */
#define TV_VRESMASK 0x00003FF8  /* 11 bits */
#define TV_STDMASK  0x00000007  /* 3  bits */

#define NV11 (((MC_ARCHITECTURE_NV10 & 0x30)>>1) | (MC_IMPLEMENTATION_NV11 & 0x07))
#define NV20 (((MC_ARCHITECTURE_NV20 & 0x30)>>1) | (MC_IMPLEMENTATION_NV20 & 0x07))

#define PDEV_TVMODE(pDev, h, v, std) ((NV_CHIP(pDev)<<27) | (((h-1)&0x7FF)<<14) | (((v-1)&0x7FF)<<3) | (std&0x07))
#define TV_MODE(nv, h, v, std)       ((nv<<27)            | (((h-1)&0x7FF)<<14) | (((v-1)&0x7FF)<<3) | (std&0x07))

    //special handling for certain low-res modes.
    switch (hRes)
    {
        case 320:
        case 400:
            WriteIndexed(NV_PRMVIO_SRX, 0x901); // dot clock /2 for low res modes
            break;
    }

    //PAL_Nc only differs from PAL_BDGHI by its color subcarrier.
    std = pDev->Dac.TVStandard;
    if (std == PAL_NC) { std = PAL_A; }
    if (std == PAL_M)  { std = NTSC_M; }

    //RYAN@TV: TODO: PAL_N tweakage (need Uruguay TV)
    //RYAN@TV: TODO: Try to compact this code a little more

    switch (PDEV_TVMODE(pDev, hRes, vRes, std))
    {
        case TV_MODE(NV11, 320, 200, PAL_N):
        case TV_MODE(NV11, 320, 200, PAL_A):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x30, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xD4, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0x90, Head);   // CR10
            //vertical scale is too narrow
            break;

        case TV_MODE(NV20, 320, 200, PAL_N):
        case TV_MODE(NV20, 320, 200, PAL_A):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x30, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xD4, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0x90, Head);   // CR10
            //vertical scale is too narrow
            //image needs moved to the left a little, but this seems to be impossible with CRTCs
            break;

        case TV_MODE(NV11, 320, 200, NTSC_M):
        case TV_MODE(NV11, 320, 200, NTSC_J):
        case TV_MODE(NV20, 320, 200, NTSC_M):
        case TV_MODE(NV20, 320, 200, NTSC_J):
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x27, Head);   // CR0
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xDE, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0x9A, Head);   // CR10
            //image needs moved to the left a little, but this seems to be impossible with CRTCs
            break;

        case TV_MODE(NV11, 320, 240, PAL_N):
        case TV_MODE(NV11, 320, 240, PAL_A):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x30, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x24, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0xE0, Head);   // CR10
            break;

        case TV_MODE(NV20, 320, 240, PAL_N):
        case TV_MODE(NV20, 320, 240, PAL_A):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x30, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x24, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0xE0, Head);   // CR10
            //image needs moved to the left a little, but this seems to be impossible with CRTCs
            break;

        case TV_MODE(NV11, 320, 240, NTSC_M):
        case TV_MODE(NV11, 320, 240, NTSC_J):
        case TV_MODE(NV20, 320, 240, NTSC_M):
        case TV_MODE(NV20, 320, 240, NTSC_J):
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x27, Head);   // CR0
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x2C, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0xE8, Head);   // CR10
            //image needs moved to the left a little, but this seems to be impossible with CRTCs
            break;

        case TV_MODE(NV11, 640, 400, PAL_N):
        case TV_MODE(NV11, 640, 400, PAL_A):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x5D, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xEF, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0x8F, Head);   // CR10
            dacSetTvoutLatency(pDev, Head, 1);
            //vertical scale is too narrow
            break;
        
        case TV_MODE(NV20, 640, 400, PAL_N):
        case TV_MODE(NV20, 640, 400, PAL_A):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x5E, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xEF, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0x8F, Head);   // CR10
            dacSetTvoutLatency(pDev, Head, 6);
            //vertical scale is too narrow
            break;

        case TV_MODE(NV11, 640, 400, NTSC_M):
        case TV_MODE(NV11, 640, 400, NTSC_J):
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x54, Head);   // CR0
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x53, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xDC, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0x90, Head);   // CR10
            dacSetTvoutLatency(pDev, Head, 7);
            //vertical scale is narrow
            //horizontal scale is too wide
            break;

        case TV_MODE(NV20, 640, 400, NTSC_M):
        case TV_MODE(NV20, 640, 400, NTSC_J):
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x54, Head);   // CR0
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x53, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xDC, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0x90, Head);   // CR10
            dacSetTvoutLatency(pDev, Head, 4);
            //vertical scale is narrow
            //horizontal scale is too wide
            break;

        case TV_MODE(NV11, 640, 480, PAL_N):
        case TV_MODE(NV11, 640, 480, PAL_A):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x5D, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x25, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0xDF, Head);   // CR10
            dacSetTvoutLatency(pDev, Head, 1);
            break;

        case TV_MODE(NV20, 640, 480, PAL_N):
        case TV_MODE(NV20, 640, 480, PAL_A):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x5E, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x25, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0xDF, Head);   // CR10
            dacSetTvoutLatency(pDev, Head, 6);
            break;

        case TV_MODE(NV11, 640, 480, NTSC_M):
        case TV_MODE(NV11, 640, 480, NTSC_J):
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x54, Head);   // CR0
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x53, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x2F, Head);   // CR6
            dacSetTvoutLatency(pDev, Head, 7);
            //horizontal scale is too wide
            break;

        case TV_MODE(NV20, 640, 480, NTSC_M):
        case TV_MODE(NV20, 640, 480, NTSC_J):
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x54, Head);   // CR0
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x53, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x2F, Head);   // CR6
            dacSetTvoutLatency(pDev, Head, 4);
            //horizontal scale is too wide
            break;

        case TV_MODE(NV11, 800, 600, PAL_N):
        case TV_MODE(NV11, 800, 600, PAL_A):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x7D, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xA8, Head);   // CR6
            dacSetTvoutLatency(pDev, Head, 5);
            break;

        case TV_MODE(NV20, 800, 600, PAL_N):
        case TV_MODE(NV20, 800, 600, PAL_A):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x7D, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xA8, Head);   // CR6
            dacSetTvoutLatency(pDev, Head, 2);
            break;

        case TV_MODE(NV11, 800, 600, NTSC_M):
        case TV_MODE(NV11, 800, 600, NTSC_J):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x7E, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xA9, Head);   // CR6
            dacSetTvoutLatency(pDev, Head, 4);
            break;

        case TV_MODE(NV20, 800, 600, NTSC_M):
        case TV_MODE(NV20, 800, 600, NTSC_J):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x7E, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xA9, Head);   // CR6
            dacSetTvoutLatency(pDev, Head, 1);
            break;

        default:  //RYAN@TV, what is this for?!?
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x54, Head);   // CR0
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x52, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x30, Head);   // CR6
            break;
    }
    return status;

#undef NV11
#undef NV20
}

RM_STATUS dacAdjustCRTCForTV(PHWINFO pDev, U032 Head)
{
    U008    data, lock;
    U032    hRes, vRes;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    // Get resolution
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    hRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    vRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
    
    CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 0x20, Head);     // if TV, we can fix low water mark at 20.
    
    // slave the CRTC clock to the encoder
    CRTC_RD(NV_CIO_CRE_LCD__INDEX, data, Head);
    data &= ~(DRF_MASK(NV_CIO_CRE_LCD_LCD_SELECT) << DRF_SHIFT(NV_CIO_CRE_LCD_LCD_SELECT)); // don't slave to LCD
    data &= ~(DRF_MASK(NV_CIO_CRE_LCD_EXT_SELECT) << DRF_SHIFT(NV_CIO_CRE_LCD_EXT_SELECT)); // don't drive LCD ext data pins
    CRTC_WR(NV_CIO_CRE_LCD__INDEX, data, Head); // clear LCD bits
    
    // Toshiba SBIOS behaves badly: it may lock ext CRTC's on us during SMI.
    lock = UnlockCRTC(pDev, 0);
    if (lock != NV_CIO_SR_UNLOCK_RW_VALUE) 
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ext CRTC's are locked in dacAdjustCRTCForTV\r\n");
    }
    CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);
    data |= 0x80;       // slave mode
    data &= ~0x38;      // clear the pixel skew
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);

    //  fix up CRTC timing per encoder
    //  NOTE: Brooktree and Chrontel have incompatible CRTC and encoder tables.
    //  Until this is resolved, this code is going to be ugly.
    switch (TV_ENCODER_FAMILY(pDev->Dac.EncoderType))
    {
        case TV_ENCODER_CHRONTEL:
            dacAdjustCRTC_CH(pDev, Head);
            break;
        case TV_ENCODER_BROOKTREE: 
            dacAdjustCRTC_BT(pDev, Head);
            break;
        case TV_ENCODER_PHILIPS:
            dacAdjustCRTC_PH(pDev, Head);
            break;
        default:
            return RM_ERROR;
    }        
    // Fix the video scalar vertical on NV4. Also allows full range of cursor movement.
    if(IsNV4(pDev))
    {
        // adjust VBE = VT. This adjusts the position of the video scalar window.
        CRTC_RD(NV_CIO_CR_VDT_INDEX, data, Head);             // CR6
        // 7 bits of CR16 are used
        CRTC_WR(NV_CIO_CR_VBE_INDEX, data, Head);             // CR16
    }

    if (hRes <= 400)    // if clock doubling
    {
        // Clock doubled mode
//        DAC_REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, 0x01030700, Head);   
        if (Head == 0) 
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _TVCLK_RATIO, _DB2);
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK_RATIO, _DB1);
        }
        else
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _TVCLK_RATIO, _DB2);
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK2_RATIO, _DB1);
        }
    }
    else
    {
        // Normal clock mode
//        DAC_REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, 0x10030700, Head);
        if (Head == 0) 
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _TVCLK_RATIO, _DB1);
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK_RATIO, _DB1);
        }
        else
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _TVCLK_RATIO, _DB1);
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK2_RATIO, _DB1);
        }
    }
    // Set source of PCLK and VSCLK to be TV encoder
    if (Head == 0) 
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK_TV, _BOTH);
    }
    else
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK2_TV, _BOTH);
    }

    switch (pDev->Dac.EncoderType)
    {
        case NV_ENCODER_CHRONTEL_7007:
        case NV_ENCODER_CHRONTEL_7008:
            if (IsNV11(pDev) || IsNV20(pDev))
            {
                if (!pDev->Dac.TVMasterMode)
                {
                    //setup the head as the pseudo-slave.  Because of a hardware bug,
                    //we have to do this to  both heads.  dacProgramChrontel()
                    //already set up the timing parameters required for this.
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TV_SETUP, _DEV_TYPE, _SLAVE, 0);
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TV_SETUP, _DEV_TYPE, _SLAVE, 1);
                    break;
                }
            }
            //intentional fall-through to default

        default:
            // setup the appropriate head as the master.
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TV_SETUP, _DEV_TYPE, _MASTER, Head);
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TV_SETUP, _DEV_TYPE, _MASTER, Head^1);
    }

    return RM_OK;
} // end of dacAdjustCRTCForTV

// Chrontel and Brooktree tables are incompatible
// Until we have a uniform way to deal with this, we'll use the "mode number"
// method for Brooktree (ala release 2) and the table lookup for Chrontel.
// This function is for Brooktree only.
U008 dacGetTVmode(PHWINFO pDev, U032 Head)
{
U032    hRes, vRes;
U008    TVmode;
PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

        // Get resolution
        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
        hRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
        vRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
        
        // Assign a mode number based on the resolution
        switch (hRes)
        {
            case 320:
                if (vRes == 200)
                    TVmode = TV_MODE_320x200;
                else
                    TVmode = TV_MODE_320x240;
                break;
            case 400:
                TVmode = TV_MODE_400x300;
                break;
            case 480:
                TVmode = TV_MODE_480x360;
                break;
            case 512:
                TVmode = TV_MODE_512x384;
                break;
            case 640:
                if (vRes == 400)
                    TVmode = TV_MODE_640x400;
                else
                    TVmode = TV_MODE_640x480;
                break;
            case 800:
                TVmode = TV_MODE_800x600;
                break;
            case 720:
            case 704:
                TVmode = TV_MODE_DVD;
                break;
            case 1024:
                TVmode = TV_MODE_1024x768;
                break;
            default:
                TVmode = TV_MODE_640x480;
                break;
        }
        return TVmode;
}

//  Return the default register values for position, brightness, contrast and flicker filter.
VOID dacGetDefaultTVPosition
(
    PHWINFO pDev,
    U032    Head,
    U032    EncoderId,
    U008    Default,
    U032    *encoderParms
)
{
    U008    Cr07, Cr25;
    U032    Hrs, Hre, Vrs, Vre;
    U008    TVmode;
    U032    hRes, vRes;
    U008   *strptr;
    RM_STATUS status;
        
    if (EncoderId & TV_ENCODER_BROOKTREE)
    {
        PARAMS_BROOKTREE *regsBt;
        BT_MODE_REGS *pReg;
        BT_INIT_REGS *pRegI;

        // Get default parameters from tables
        TVmode = dacGetTVmode(pDev, Head);
        regsBt = (PARAMS_BROOKTREE *)encoderParms;

        if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871)
        {
            pRegI = (BT_INIT_REGS *) &BT871_Init;
            regsBt->reg0xC8 = (U008)pDev->Dac.TV871_C8;
            regsBt->reg0xCA = (U008)pDev->Dac.TV871_CA;
            regsBt->reg0xCC = (U008)pDev->Dac.TV871_CC;
            
            regsBt->reg0x80 = (U008)pDev->Dac.TV871_80;
            regsBt->reg0x82 = (U008)pDev->Dac.TV871_82;
            regsBt->reg0x92 = (U008)pDev->Dac.TV871_92;
            regsBt->reg0x98 = (U008)pDev->Dac.TV871_98;
            regsBt->reg0x9A = (U008)pDev->Dac.TV871_9A;
        }
        else
        {
            pRegI = (BT_INIT_REGS *) &BT_Init;
            regsBt->reg0xC8 = pRegI->reg0xC8;
            regsBt->reg0xCA = pRegI->reg0xCA;
            regsBt->reg0xCC = pRegI->reg0xCC;
            switch (pDev->Dac.TVStandard)
            {
                case NTSC_M:
                    strptr = (U008 *)Bt_NM[TVmode];
                    break;
                case NTSC_J:
                    strptr = (U008 *)Bt_NJ[TVmode];
                    break;
                case PAL_NC:
                    strptr = (U008 *)Bt_NC[TVmode];
                    break;
                case PAL_A:
                    strptr = (U008 *)Bt_PA[TVmode];
                    break;
                case PAL_M:
                    strptr = (U008 *)Bt_PM[TVmode];
                    break;
                case PAL_N:
                    strptr = (U008 *)Bt_PN[TVmode];
                    break;
                default:
                    strptr = (U008 *)Bt_NM[TVmode];
                break;
            }
            pReg = (BT_MODE_REGS *) strptr;
            regsBt->reg0x80 = pReg->reg0x80;
            regsBt->reg0x82 = pReg->reg0x82;
            regsBt->reg0x92 = pReg->reg0x92;
            regsBt->reg0x98 = pReg->reg0x98;
            regsBt->reg0x9A = pReg->reg0x9A;
        }

        // Construct Horizontal Retrace Start, End, and Vertical Retrace Start, End
        CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
        CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);

        // Construct Hrs
        CRTC_RD(NV_CIO_CR_HRS_INDEX, Hrs, Head);

        // Construct Hre
        CRTC_RD(NV_CIO_CR_HRE_INDEX, Hre, Head);
        Hre = Hrs + ( ((short)Hre - (short)Hrs) & BITS0_4 );

        // Construct Vrs
        CRTC_RD(NV_CIO_CR_VRS_INDEX, Vrs, Head);
        if (Cr25 & BIT2)
            Vrs |= BIT10;
        if (Cr07 & BIT7)
            Vrs |= BIT9;
        if (Cr07 & BIT2)
            Vrs |= BIT8;

        // Construct Vre
        CRTC_RD(NV_CIO_CR_VRE_INDEX, Vre, Head);
        Vre = Vrs + ( ((short)Vre - (short)Vrs) & BITS0_3 );

        regsBt->HRetraceStart = Hrs;        
        regsBt->HRetraceEnd = Hre;      
        regsBt->VRetraceStart = Vrs;        
        regsBt->VRetraceEnd = Vre;      
    }
    if (EncoderId & TV_ENCODER_CHRONTEL)
    {
        PARAMS_CHRONTEL *regsCh;
        PCH_string  pReg;

        regsCh = (PARAMS_CHRONTEL *)encoderParms;

        hRes = pDev->Framebuffer.HalInfo.HorizDisplayWidth;
        vRes = pDev->Framebuffer.HalInfo.VertDisplayWidth;
        status = dacGetI2CModeString(pDev, Head, hRes, vRes, &strptr, NULL, NULL, NULL);
        pReg = (PCH_string) strptr;
        if (status)
        {
            regsCh->reg0x0A = 0;
            regsCh->reg0x0B = 0;
        }
        else
        {
            regsCh->reg0x0A = pReg->data0x0A;
            regsCh->reg0x0B = pReg->data0x0B;
        }
        regsCh->reg0x08 = 0x00;
        regsCh->reg0x09 = 0x7f;
        regsCh->reg0x11 = 0x03;
        if (EncoderId == NV_ENCODER_CHRONTEL_7003)
            regsCh->reg0x01 = 0x03;
        else
            regsCh->reg0x01 = 0x29;
    }
}
//  Write TV encoder positioning registers, as well as contrast, brightness, flicker filter
//  For Brooktree positioning, we must change the CRTC's also.
VOID dacSetTVPosition
(
    PHWINFO pDev,
    U032    Head,
    U032    *encoderParms
)
{
    U008 Adr, Data, Device, lock;
    NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS *Parms = (NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS *) encoderParms;

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);
    if (TV_ENCODER_FAMILY(Parms->Encoder_ID) == TV_ENCODER_BROOKTREE)
    {
        // Write CRTC values (we can use the monitor position function)
        dacSetMonitorPosition(pDev, Head, Parms->u.regsBt.HRetraceStart, Parms->u.regsBt.HRetraceEnd,
                                Parms->u.regsBt.VRetraceStart, Parms->u.regsBt.VRetraceEnd);

        Data = Parms->u.regsBt.reg0x80;
        Adr = 0x80;
        Device = (U008)(pDev->Dac.EncoderID >> 1);
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0x82;
        Adr = 0x82;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0x92;
        Adr = 0x92;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0x98;
        Adr = 0x98;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0x9A;
        Adr = 0x9a;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0xC8;
        Adr = 0xc8;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0xCA;
        Adr = 0xca;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0xCC;
        Adr = 0xcc;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
    } else if (TV_ENCODER_FAMILY(Parms->Encoder_ID) == TV_ENCODER_CHRONTEL)
    {
        // Chrontel is positioned completely thru the encoder
        Data = Parms->u.regsCh.reg0x01;
        Adr = 0x01;
        Device = (U008)(pDev->Dac.EncoderID >> 1);
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsCh.reg0x08;
        Adr = 0x08;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsCh.reg0x09;
        Adr = 0x09;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsCh.reg0x0A;
        Adr = 0x0A;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsCh.reg0x0B;
        Adr = 0x0B;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsCh.reg0x11;
        Adr = 0x11;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
    }
    RestoreLock(pDev, Head, lock);
}


//  Return the default TV mode stored in the bios.
RM_STATUS dacGetBiosDefaultTVType
(
    PHWINFO pDev,
    U032    *biostvdefault
)
{
 
    U008  data, lock;
    U032  Head = 0;  // BIOS knows only about head 0

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);
    
    CRTC_RD(NV_CIO_CRE_SCRATCH0__INDEX, data, Head); 
    
    RestoreLock(pDev, Head, lock);
    
    *biostvdefault = data & 0x07;
    
    return RM_OK;
}

// Set the default TV mode stored in the bios.
// Normally, this will only persist till shutdown.  But in the
// mobile case we call through the VGA BIOS to the system BIOS
// to commit the new setting to CMOS.
// This register is referred to (through a call to dacGetBiosDefaultTVType)
// by the control panel and QuickTweak to determine the preferred TV setting
// when referring to the registry is not appropriate.
RM_STATUS dacSetBiosDefaultTVType
(
    PHWINFO pDev,
    U032    biosTVSetting
)
{
 
    U008  data, lock;
    U032  Head = 0;  // BIOS knows only about head 0

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);
    
    CRTC_RD(NV_CIO_CRE_SCRATCH0__INDEX, data, Head);
    data &= ~0x07;
    data |= (biosTVSetting & 0x07);
    CRTC_WR(NV_CIO_CRE_SCRATCH0__INDEX, data, Head); 
    
    RestoreLock(pDev, Head, lock);
    
#if !defined(MACOS) && !defined(LINUX)
    //
    // If this is a mobile BIOS that supports storing the tv state in the system
    // cmos, we need to pass the information down.
    //
    if (pDev->Power.MobileOperation == 2)
    {
        // Call through VGA BIOS to system BIOS to set tv mode CMOS bit.
        RM_STATUS status;
        U032 eax, ebx, ecx, edx;
        eax = 0x4F14;       // NV VESA function
        ebx = 0x8105;       // set TV format and commit to CMOS
        ecx = biosTVSetting;
        edx = 0;
        status = osCallVideoBIOS(pDev, &eax, &ebx, &ecx, &edx, NULL);
    }
#endif
    return RM_OK;
}
        
//  Detect TV encoder 
//  Find the encoder ID (i2c address) and the type (maker and version) and save in the pDev dac structure.
VOID    dacDetectEncoder
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    lock, ack, read, retry;

    // see if we have a TV encoder, and what type it is.
    // Identify which part: Chrontel or Brooktree? There are 2 possible ID's for each part
    // Unlock CRTC extended regs
    if (IsNV11(pDev))
    {
        AssocDDC(pDev, Head);
        AssocTV(pDev, Head);
    }

    lock = UnlockCRTC(pDev, Head);

    if (IsNV4(pDev) && Head == 0)   // TV and CRT share the i2c port
        EDIDRead(pDev, Head, DISPLAY_TYPE_MONITOR);   // this will stop the CRT from driving DDC1 data on the bus

    i2cInit(pDev, Head, pDev->Dac.TVOutPortID);

    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x8A);     // is it Brooktree?
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    }
    if (ack == 0) { // We got a response, so this must be our device
        pDev->Dac.EncoderID = 0x8A;
        pDev->Dac.EncoderType = TV_ENCODER_BROOKTREE;
    } else {    // Not address 8A, try alternate
        for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x88); // Brooktree alt address
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
        }
        if (ack == 0) { // We got a response, so this must be our device
            pDev->Dac.EncoderID = 0x88;
            // Differentiate between Brooktree and Philips
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1C); // Philips ID reg
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID); // Start w/o Stop = Restart
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            if (ack) 
                pDev->Dac.EncoderType = TV_ENCODER_BROOKTREE;
            else
            {
                pDev->Dac.EncoderType = TV_ENCODER_PHILIPS; // generic ID
                switch (read) 
                {
                    case 0x02:
                        pDev->Dac.EncoderType = NV_ENCODER_PHILIPS_7102;
                        break;    
                    case 0x03:
                        pDev->Dac.EncoderType = NV_ENCODER_PHILIPS_7103;
                        break;    
                }
                // If there is a decoder on the chip, then it is considered to be a 7108 or 7109
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x40); // 7114 decoder address    
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                if (ack == 0) 
                {
                    if (pDev->Dac.EncoderType == NV_ENCODER_PHILIPS_7102) 
                    {
                        pDev->Dac.EncoderType = NV_ENCODER_PHILIPS_7108;
                    }
                    if (pDev->Dac.EncoderType == NV_ENCODER_PHILIPS_7103) 
                    {
                        pDev->Dac.EncoderType = NV_ENCODER_PHILIPS_7109;
                    }
                }
            }
        } else {    // Not Brooktree
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0xEA); // is it Chrontel?
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }
            if (ack == 0) { // We got a response, so this must be our device
                pDev->Dac.EncoderID = 0xEA;
                pDev->Dac.EncoderType = TV_ENCODER_CHRONTEL;
            } else {    // Try alternate Chrontel address
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                    ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0xEC); // try Chrontel alt address
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                }
                if (ack == 0) { // We got a response, so this must be our device
                    pDev->Dac.EncoderID = 0xEC;
                    pDev->Dac.EncoderType = TV_ENCODER_CHRONTEL;
                } else {
                    pDev->Dac.EncoderType = NV_ENCODER_NONE;
                }
            }
        }
    }

    // if the part responded to the Chrontel address, check subaddress
    // we may have another Chrontel part (7002?)
    if (pDev->Dac.EncoderType == TV_ENCODER_CHRONTEL)
    {
        // See what BIOS booted to.
        if (dacGetBiosDisplayType(pDev, Head) == DISPLAY_TYPE_TV)  // H
            // Temporarily set DisplayType to TV. This prevents the BIOS from hanging when
            // it gets called to do a modeset, because TVConnectStatus will turn off the encoder
            // if its not the current display. The correct display type will be set later.
            // If the VCLK is coming from the encoder, we must not turn it off.

            SETDISPLAYTYPE(pDev, Head, DISPLAY_TYPE_TV);

        for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        }
        if ((ack != 0) || (i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x25))) // 25 = version register
        {
            pDev->Dac.EncoderType = NV_ENCODER_NONE;                    
        }
        else
        {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            if (ack)    // if read failed, the reg doesn't exist, probably 7002
            {
                pDev->Dac.EncoderType = NV_ENCODER_NONE; 
            }
            else
            {
                switch (read & 0xFF)
                {
                    case 0x00:  // 7003 according to spec
                    case 0x01:  // 7003 observed
                    case 0x02:  // 7003B
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7003;
                        break;
                    case 0x30:  // 7004A  From Chrontel, their data sheets are incorrect.
                    case 0x31:  // 7004B
                    case 0x32:  // 7004C
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7004;
                        break;
                    case 0x38:  // 7005A
                    case 0x39:  // 7005B
                    case 0x3a:  // 7005C
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7005;
                        break;
                    case 0x28:  // 7006A
                    case 0x29:  // 7006B
                    case 0x2A:  // 7006C
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7006;
                        break;
                    case 0x50:  // 7007
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7007;
                        break;
                    case 0x40:  // 7008
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7008;
                        break;
                    default:    // 7002 should return FF
                        pDev->Dac.EncoderType = NV_ENCODER_NONE;
                        break;
                }
            }
        }
    }

    // if Brooktree, identify which variety
    if (pDev->Dac.EncoderType == TV_ENCODER_BROOKTREE)
    {
        // enable non-legacy readback mode for 870/871 by doing a reset - harmless for older parts
        // (this enables read of any register on 87x -- 868/869 has only one read subaddress)
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);     // subaddress
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x44);     // TIMING_RST low, set readback mode, EACTIVE
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         
        tmrDelay(pDev, 10000000);
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);  
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0xC4);      // TIMING_RST high
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         

        // Read register 0 for the device ID.
        // If this is an 86x part, we need to set Estat so that the reg read from subaddress 0 is reg 0.
        // (There are four registers which can be read at subaddress 0; Estat selects which one.)
        // If this is an 87x part and we are in non-legacy mode, setting Estat doesn't matter.
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);  
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0xC4);   // subaddress
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x01);   // set estat (estat 0 + en_out)
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         
        // Now read register 0, the ID register.
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID));     
        ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0);              // subaddress
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID+1));     
        ack |= i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read, 1);
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
        
        // Check upper 3 bits: 000 = 868, 001 = 869, 010 = 870, 011 = 871
        switch (read & 0xe0) 
        {
            case 0:
                pDev->Dac.EncoderType = NV_ENCODER_BROOKTREE_868;
                break;
            case 0x20:
                pDev->Dac.EncoderType = NV_ENCODER_BROOKTREE_869;
                break;
            case 0x60:
                pDev->Dac.EncoderType = NV_ENCODER_BROOKTREE_871;
                // disable Macrovision
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   
                i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);  
                i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0xFC);   // subaddress
                i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x00);   //
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         
                
                break;
            case 0x40:
                pDev->Dac.EncoderType = NV_ENCODER_BROOKTREE_870;
                break;
            default:
                pDev->Dac.EncoderType = NV_ENCODER_BROOKTREE_868;
        }
    }                
      
    //
    // Relock if necessary
    //
    RestoreLock(pDev, Head, lock);            
}

VOID dacTV871Readback
(
    PHWINFO  pDev,
    U032     Head,
    U008     Mode
)
{
    U008 lock;

    if (IsNV11(pDev))
    {
        AssocDDC(pDev, Head);
        AssocTV(pDev, Head);
    }

    lock = UnlockCRTC(pDev, Head);
    if (Mode == 0) 
    {
        // enable legacy readback mode for 870/871
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);     // subaddress
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x04);     // TIMING_RST low, set legacy readback mode, !EACTIVE
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         
        tmrDelay(pDev, 10000000);
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);  
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x84);      // TIMING_RST high
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         
    }
    else
    {
        // enable non-legacy readback mode for 870/871
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);     // subaddress
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x44);     // TIMING_RST low, set legacy readback mode, !EACTIVE
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         
        tmrDelay(pDev, 10000000);
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);  
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0xC4);      // TIMING_RST high
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         
    }
    RestoreLock(pDev, Head, lock);
    
    // restore TV connection if TV is connected on the other head
    if (GETDISPLAYTYPE(pDev, Head ^ 0x1) == DISPLAY_TYPE_TV) 
    {
        AssocDDC(pDev, Head ^ 0x1);
        AssocTV(pDev, Head ^ 0x1);
    }
}

VOID
dacDisableTV
(
    PHWINFO pDev,
    U032 Head
)
{
    U032 data32;
    U008 lock;
    U008 data08;

	// Another check to see if we're already off.
	if(!(pDev->Dac.DevicesEnabled & DAC_TV_ENABLED))
		return;

    if (pDev->Power.MobileOperation) Head = 0;  //Set to proper head to unlock and
                                                //modify CR28.

    // On dual-headed devices, enable I2C interface
    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);
    }
    lock = UnlockCRTC(pDev, Head);
    //
    // Sequence per KevinM:
    //  - clear bits 7,2 in CR28
    //  - clear bits 24,20,17:16 in PLL_COEFF_SELECT
    //  - delay 200ms
    //  - turn off encoder
    //
    if ((GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
        || (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_NONE)) {    //This fn is called during dacSetModeMulti
        // with a Head parameter that need not be the one with the TV.  In that case, it would be
        // dangerous to go overwriting these registers...
        dacDisableCRTCSlave(pDev, Head); 
    }
    //
    // We're about to turn off the encoder, so be sure to
    // clear any pixel clock dependencies on tv.
    //
    data32 = REG_RD32(NV_PRAMDAC_PLL_COEFF_SELECT);
    data32 &= ~((DRF_MASK(NV_PRAMDAC_PLL_COEFF_SELECT_VS_PCLK_TV) <<
                 DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_VS_PCLK_TV)) |
                (DRF_MASK(NV_PRAMDAC_PLL_COEFF_SELECT_VS_PCLK2_TV) <<
                 DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_VS_PCLK2_TV)) |
                (DRF_MASK(NV_PRAMDAC_PLL_COEFF_SELECT_TVCLK_SOURCE) <<
                 DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_TVCLK_SOURCE)) |
                (DRF_MASK(NV_PRAMDAC_PLL_COEFF_SELECT_TVCLK_RATIO) <<
                 DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_TVCLK_RATIO)));
    REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, data32);

    tmrDelay(pDev, 200000000);   // delay 200 ms

    
    // Toshiba can do an SMI, and they may leave the ext CRTC's locked!!!
    // So before doing I2C, make sure they are still unlocked.
    CRTC_RD(NV_CIO_SR_LOCK_INDEX, data08, Head);
    if (!data08) 
    {
        lock = UnlockCRTC(pDev, Head);  // do it again.
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ext CRTC's are locked in dacDisableTV\r\n");
    }
    switch (TV_ENCODER_FAMILY(pDev->Dac.EncoderType))
    {
        case TV_ENCODER_CHRONTEL:
            // power down to blank screen
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                    // start state for I2C
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_0E);      // PM register 
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_OFF);         // power down (+ reset high)  
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C
            break;
        case TV_ENCODER_BROOKTREE:
            // Turn DAC off
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);    // subaddress
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_OFF);    // DAC OFF
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            dacTVReadModifyWrite(pDev, Head, BT_EN_OUT, BT_EN_OUT_OFF, BT_EN_OUT_ON);
            break;
        case TV_ENCODER_PHILIPS:
            dacTVReadModifyWrite(pDev, Head, PH_STDCTL, PH_DAC_OFF, PH_DAC_POWER);
            break;
        case TV_ENCODER_NONE:
        default:
            // what can we do?
            break;
    }
    RestoreLock(pDev, Head, lock);
    
	pDev->Dac.DevicesEnabled &= ~(DAC_TV_ENABLED);
}

VOID
dacEnableTV
(
    PHWINFO pDev,
    U032 Head
)
{
    U008 lock;
    // On dual-headed devices, enable I2C interface
    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);
    }
    lock = UnlockCRTC(pDev, Head);
    
    switch (TV_ENCODER_FAMILY(pDev->Dac.EncoderType))
    {
        case TV_ENCODER_CHRONTEL:
            // power up DAC
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                // start state for I2C
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_0E);  // PM register 
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_ON);      // power on (+ reset high)  
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                 // end state for I2C
            break;
        case TV_ENCODER_BROOKTREE:
            // Turn DAC on
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);    // subaddress
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_ON);    // DAC ON
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            dacTVReadModifyWrite(pDev, Head, BT_EN_OUT, BT_EN_OUT_ON, BT_EN_OUT_ON);
            break;
        case TV_ENCODER_PHILIPS:
            dacTVReadModifyWrite(pDev, Head, PH_STDCTL, PH_DAC_ON, PH_DAC_POWER);
            break;
        case TV_ENCODER_NONE:
        default:
            // what can we do?
            break;
    }
    RestoreLock(pDev, Head, lock);

	pDev->Dac.DevicesEnabled |= DAC_TV_ENABLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\i2c.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* I2C Control *******************************\
*                                                                           *
* Module: I2C.C                                                             *
*   The I2C port is managed within this module.                             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvhw.h"
#include <vga.h>
#include "i2c.h"

#include <nvmisc.h>
#define xxx(d, fmt) nv_debug(99, fmt)

//---------------------------------------------------------------------------
//
//  I2C support routines.
//
//---------------------------------------------------------------------------

// Serial Port Bits
#define I2C_SRCK        0x20    // Serial Clock write
#define I2C_SRD         0x10    // Serial Data  write
#define I2C_SRCK_IN     0x04    // Serial Clock read
#define I2C_SRD_IN      0x08    // Serial Data  read
#define I2C_ENABLE      0x01    // Enable Serial Port Function

///////////////////////////////////////////////////////////////////

// Constants used by I2C Protocol:

#define SDA_REG         0x02
#define SCL_REG         0x01


#define ACK             0   // I2C Acknowledge
#define NACK            1   // I2C No Acknowledge

#define I2CDELAY 10000   // 10usec
	
// Module Global Variables

// variables could be modified via INI file
// U008 iniFlag = FALSE;
#ifdef  IKOS
U032 wMaxWaitStates=2;     // max wait states for I2C bus syncronisation
#else   // IKOS
U032 wMaxWaitStates=3000;  // max wait states for I2C bus syncronisation
#endif  // IKOS
U032 wGpo=0;               // GPO bits for switching to I2C operation

//
// Insure register updates have been flushed out of the write buffer
// by performing a cpuid instruction
//
// XXX this should be in common/nvUtil/ or somewhere else
#ifdef WIN31

#ifdef NEWWIN31

void __cdecl FlushWB(void)
{
    __asm push esi
    __asm push edi
    __asm push ebx
    __asm mov eax, 0x0
        __asm _emit 0x0f
        __asm _emit 0xa2
    __asm pop ebx
    __asm pop edi
    __asm pop esi
}

#else  //old win31

void FlushWB(void);
#pragma aux FlushWB =				\
            "mov    EAX, 0x0"			\
            0x0F 0xA2
#endif

#elif defined(__PPC__)

void FlushWB(void)
{
    __eieio();
}


#elif defined(__GNUC__)		// UNIX and DJPP
void FlushWB(void)
{
#ifndef IA64
    // save regs (especially ebx) that might get stomped by 'cpuid'
    __asm__("push %esi");
    __asm__("push %edi");
    __asm__("push %ebx");
        __asm__("xorl %eax, %eax");
        __asm__("cpuid");
    __asm__("pop %ebx");
    __asm__("pop %edi");
    __asm__("pop %esi");
#endif
}

#else   // !WIN31 !UNIX !DJPP

void __cdecl FlushWB(void)
{
// TO DO: what to do about inline asm for IA-64?       
#ifndef IA64
    __asm push esi
    __asm push edi
    __asm push ebx
    __asm mov eax, 0x0
        __asm _emit 0x0f
        __asm _emit 0xa2
    __asm pop ebx
    __asm pop edi
    __asm pop esi
#endif // IA-64 cannot tolerate inline asm
}

#endif

void i2cWriteCRTCWrIndex
(
    PHWINFO pDev,
    U032 Head,
    U032 portID,
    U008 data
)
{
    switch (portID) 
    {
    case NV_I2C_PORT_PRIMARY:
        CRTC_WR(pDev->Dac.I2CPrimaryWriteIndex, data, Head);
        break;
    case NV_I2C_PORT_SECONDARY:
        CRTC_WR(pDev->Dac.I2CSecondaryWriteIndex, data, Head);
        break;
    case NV_I2C_PORT_TERTIARY:
        CRTC_WR(pDev->Dac.I2CTertiaryWriteIndex, data, Head);
        break;
    }
}

   
U008 i2cReadCRTCWrIndex
(
    PHWINFO pDev,
    U032 Head,
    U032 portID
)
{
    U008 data = 0xFF;

    switch (portID) 
    {
    case NV_I2C_PORT_PRIMARY:
        CRTC_RD(pDev->Dac.I2CPrimaryWriteIndex, data, Head);
        break;
    case NV_I2C_PORT_SECONDARY:
        CRTC_RD(pDev->Dac.I2CSecondaryWriteIndex, data, Head);
        break;
    case NV_I2C_PORT_TERTIARY:
        CRTC_RD(pDev->Dac.I2CTertiaryWriteIndex, data, Head);
        break;
    }
    return data;
}
   

U008 i2cReadCRTCStatusIndex
(
    PHWINFO pDev,
    U032 Head,
    U032 portID
)
{
    U008 data = 0xFF;

    switch (portID) 
    {
    case NV_I2C_PORT_PRIMARY:
        CRTC_RD(pDev->Dac.I2CPrimaryStatusIndex, data, Head);
        break;
    case NV_I2C_PORT_SECONDARY:
        CRTC_RD(pDev->Dac.I2CSecondaryStatusIndex, data, Head);
        break;
    case NV_I2C_PORT_TERTIARY:
        CRTC_RD(pDev->Dac.I2CTertiaryStatusIndex, data, Head);
        break;
    }
    return data;
}

U008 i2cHardwareInit
(
    PHWINFO pDev,
    U032 Head,
    U032 portID
)
{
    // On dual-headed devices, enable I2C interface
    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);
    }
    
    //
    // If the initialization has already been done then just return
    //
    // if (iniFlag == TRUE)
    //    return TRUE;

    i2cWriteCRTCWrIndex(pDev, Head, portID, 0x31);
	
	pDev->Dac.I2cIniFlag = TRUE;
	return TRUE;
}


VOID i2cWriteCtrl
(
    PHWINFO pDev,
    U032 Head,
    U032 portID,
    U008 reg,
    U008 bit
)
{
    U008 data;

    //
    // Get the current status and toggle
    //
	data = i2cReadCRTCWrIndex(pDev, Head, portID);

	data &= 0xf0;
    data |= I2C_ENABLE;
    
    if (reg == SCL_REG)
    {
      if (bit)
        data |=  I2C_SRCK;
      else
        data &= ~I2C_SRCK;
    }
    else
    {
      if (bit)
        data |=  I2C_SRD;
      else
        data &= ~I2C_SRD;
    }    

	i2cWriteCRTCWrIndex(pDev, Head, portID, data);
    FlushWB();
}

U008 i2cReadCtrl
(
    PHWINFO pDev,
    U032 Head,
    U032 portID,
    U008 reg
)
{
    U008 data;
   
    data = i2cReadCRTCStatusIndex(pDev, Head, portID);    

    if (reg == SCL_REG)
        return ( (data & I2C_SRCK_IN) != 0);
    else
        return ( (data & I2C_SRD_IN) != 0);
}
   
/**********************************************************************/

VOID ReadSDA(PHWINFO pDev, U032 Head, U032 portID, U008 *data)
{
	*data = i2cReadCtrl(pDev, Head, portID, SDA_REG);
}

VOID ReadSCL(PHWINFO pDev, U032 Head, U032 portID, U008 *data)
{
	*data = i2cReadCtrl(pDev, Head, portID, SCL_REG);
}   

VOID SetSCLLine(PHWINFO pDev, U032 Head, U032 portID)
{
	i2cWriteCtrl(pDev, Head, portID, SCL_REG, 1);
}

VOID ResetSCLLine(PHWINFO pDev, U032 Head, U032 portID)
{
	i2cWriteCtrl(pDev, Head, portID, SCL_REG, 0);
}

VOID SetSDALine(PHWINFO pDev, U032 Head, U032 portID)
{
	i2cWriteCtrl(pDev, Head, portID, SDA_REG, 1);
}

VOID ResetSDALine(PHWINFO pDev, U032 Head, U032 portID)
{
	i2cWriteCtrl(pDev, Head, portID, SDA_REG, 0);
} 
 
/*
 * waits for a specified line til it goes high
 * giving up after MAX_WAIT_STATES attempts
 * return:  0 OK
 *         -1 fail (time out)
 */
U008 WaitHighSDALine(PHWINFO pDev, U032 Head, U032 portID)
{
    U008    data_in;
    U032    retries = wMaxWaitStates;

    do
    {
        ReadSDA(pDev, Head, portID, &data_in);      // wait for the line going high
        if (data_in)
            break;
        tmrDelay(pDev, I2CDELAY); 
    } while (--retries);        // count down is running

    if (!retries)
        return((U008)-1);
    return 0;
}                    

U008 WaitHighSCLLine(PHWINFO pDev, U032 Head, U032 portID)
{
    U008    data_in;
    U032    retries = wMaxWaitStates;

    do
    {
        tmrDelay(pDev, 1000);              // 1.0 us delay   NEEDED?? 
        ReadSCL(pDev, Head, portID, (U008 *)&data_in);   // wait for the line going high
        if (data_in)
            break;
    } while (--retries);            // count down is running

    if (!retries)
        return((U008)-1);
    return(0);    
}


VOID i2cStart(PHWINFO pDev, U032 Head, U032 portID)
{
    SetSDALine(pDev, Head, portID); 
    tmrDelay(pDev, I2CDELAY); 
    SetSCLLine(pDev, Head, portID); 
    tmrDelay(pDev, I2CDELAY);     // spec requires clock to be high min of 4us
    WaitHighSCLLine(pDev, Head, portID);
    ResetSDALine(pDev, Head, portID);
    tmrDelay(pDev, I2CDELAY);
    ResetSCLLine(pDev, Head, portID);
}


VOID i2cStop(PHWINFO pDev, U032 Head, U032 portID)
{
    tmrDelay(pDev, I2CDELAY * 20);
    ResetSCLLine(pDev, Head, portID);
    ResetSDALine(pDev, Head, portID);
    tmrDelay(pDev, I2CDELAY); 
    SetSCLLine(pDev, Head, portID); 
    tmrDelay(pDev, I2CDELAY);     // spec requires clock to be high min of 4us
    WaitHighSCLLine(pDev, Head, portID); 
    SetSDALine(pDev, Head, portID); 
    tmrDelay(pDev, I2CDELAY);
}


/*
 * I2cAck() returns 1: fail
 *                  0: acknolege
 */

U008 i2cAck(PHWINFO pDev, U032 Head, U032 portID)
{
    U008 ack;

    ResetSCLLine(pDev, Head, portID); 
    tmrDelay(pDev, I2CDELAY);
    SetSDALine(pDev, Head, portID); 
    tmrDelay(pDev, I2CDELAY);
    SetSCLLine(pDev, Head, portID); 
    tmrDelay(pDev, I2CDELAY);     // spec requires clock to be high min of 4us
    WaitHighSCLLine(pDev, Head, portID);
    ReadSDA(pDev, Head, portID, &ack);
    ResetSCLLine(pDev, Head, portID);
    return (ack);
}


VOID i2cInit(PHWINFO pDev, U032 Head, U032 portID)
{
    SetSCLLine(pDev, Head, portID); 
    tmrDelay(pDev, I2CDELAY);     // spec requires clock to be high min of 4us
    WaitHighSCLLine(pDev, Head, portID);
    SetSDALine(pDev, Head, portID); 
}


U008 i2cSendByte(PHWINFO pDev, U032 Head, U032 portID, U008 byte)
{
    U008 i;

    for (i=0;i<8;i++)
    {
	    ResetSCLLine(pDev, Head, portID);
	    tmrDelay(pDev, I2CDELAY/2);
        if (byte & 0x80)
		    SetSDALine(pDev, Head, portID);
	    else
		    ResetSDALine(pDev, Head, portID);
	    tmrDelay(pDev, I2CDELAY/2);
	    SetSCLLine(pDev, Head, portID);
	    tmrDelay(pDev, I2CDELAY);    // clock must be high at least 4us
	    WaitHighSCLLine(pDev, Head, portID);
	    byte <<= 1;
    }
    
    return i2cAck(pDev, Head, portID);
}


RM_STATUS i2cReceiveByte(PHWINFO pDev, U032 Head, U032 portID, U008 *byte, U008 nack)
{
    U008 data=0;
    U008 i;
    RM_STATUS status;

    ResetSCLLine(pDev, Head, portID);
    SetSDALine(pDev, Head, portID); 
    tmrDelay(pDev, 1000);

    for (i=0;i<8;i++)
	{
        ResetSCLLine(pDev, Head, portID);
        ResetSCLLine(pDev, Head, portID);  // 2nd needed?
        tmrDelay(pDev, I2CDELAY);
	    SetSCLLine(pDev, Head, portID); 
        status = WaitHighSCLLine(pDev, Head, portID) ? RM_ERROR : RM_OK;
        if (status != RM_OK)
            goto done;
	    tmrDelay(pDev, I2CDELAY);    // clock must be high at least 4us

	    ReadSDA(pDev, Head, portID, &data);
	    *byte <<= 1;
	    *byte  |= (data == 1);
	}

    ResetSCLLine(pDev, Head, portID);
    if (nack) 
    {
        SetSDALine(pDev, Head, portID);         // send Nack
    }
    else
        ResetSDALine(pDev, Head, portID);       // send Ack

    tmrDelay(pDev, I2CDELAY);
    SetSCLLine(pDev, Head, portID); 
    status = WaitHighSCLLine(pDev, Head, portID) ? RM_ERROR : RM_OK;
	tmrDelay(pDev, I2CDELAY);    // clock must be high at least 4us
    ResetSCLLine(pDev, Head, portID);
    tmrDelay(pDev, I2CDELAY);   // clock width must be 4.7us

done:
    return status;
}


RM_STATUS i2cWrite(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    i2cStart(pDev, Head, portID);
    if ( i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1)) ) // send chip adr. with write bit
    {
        i2cStop(pDev, Head, portID);                         // ack failed --> generate stop condition
        return(RM_ERROR); 
    }
    for ( ; AdrLen; AdrLen--)             
    {
        if ( i2cSendByte(pDev, Head, portID, *Adr++) )        // send sub-register byte(s)
        {
            i2cStop(pDev, Head, portID);                    // ack failed --> generate stop condition
            return(RM_ERROR); 
        }
    }
    for ( ; DataLen; DataLen--)            // send data byte(s)
    {
        if ( i2cSendByte(pDev, Head, portID, *Data++) )
        {
            i2cStop(pDev, Head, portID);                     // ack failed --> generate stop condition
            return(RM_ERROR);
        }
    }
    i2cStop(pDev, Head, portID);
    return(RM_OK);
}


RM_STATUS i2cRead(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    U008 dat;
    RM_STATUS status = RM_ERROR;        // pessimist
    
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: ChipAdr ", (U032)ChipAdr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: AdrLen ", (U032)AdrLen);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Adr ", (U032)*Adr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: DataLen ", (U032)DataLen);

    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    i2cStart(pDev, Head, portID);
    i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1));        // send chip adr. with write bit

    for ( ; AdrLen; AdrLen--)               // send sub-register address byte(s)
    {
        if ( i2cSendByte(pDev, Head, portID, *Adr++) )
        {
            goto done;
        }
    }
    
    tmrDelay(pDev, I2CDELAY);    // give the device some time to parse the subaddress
    
    i2cStart(pDev, Head, portID);                             // send again chip address for switching to read mode
    if ( i2cSendByte(pDev, Head, portID, (U008)((ChipAdr<<1) | 1)) )  // send chip adr. with read bit
    {
        goto done;
    }

    for (status = RM_OK; DataLen && (status == RM_OK); DataLen--)
    {
        status = i2cReceiveByte(pDev,
                                Head,
                                portID, 
                                (U008 *)&dat, 
                                (U008)((DataLen == 1) ? NACK : ACK));         // receive byte(s)
        *Data++ = dat;
    }

done:
    i2cStop(pDev, Head, portID);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Data ", (U032)*Data);
    
    return status;
}

RM_STATUS i2cRead_EDDC(PHWINFO pDev, U032 Head, U032 portID, U008 SegmentAddr,U008 ChipAdr, U008 SubByteAddr,U016 DataLen, U008 *Data)
{
    //extended DDC compatibility not confirmed on date modified. No monitors with edids greater than 256 are
    //easily obtainable or locatable.

    U008 dat;
    RM_STATUS status = RM_ERROR;        // pessimist
    
    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    //if segment!=0, set the segment with this sequence first
    if(SegmentAddr)
    {
        //send start
        i2cStart(pDev, Head, portID);
        
        //send segment register addr
        i2cSendByte(pDev, Head, portID, 0x60);
        
        //send the segment number
        i2cSendByte(pDev, Head, portID, SegmentAddr);
    }

    i2cStart(pDev, Head, portID);
    i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1));        // send chip adr. with write bit    
    i2cSendByte(pDev, Head, portID, (U008)SubByteAddr);

    i2cStart(pDev, Head, portID);                             // send again chip address for switching to read mode
    if ( i2cSendByte(pDev, Head, portID, (U008)((ChipAdr<<1) | 1)) )  // send chip adr. with read bit
    {
        goto done;
    }

    for (status = RM_OK; DataLen && (status == RM_OK); DataLen--)
    {
        status = i2cReceiveByte(pDev,
                                Head,
                                portID, 
                                (U008 *)&dat, 
                                (U008)((DataLen == 1) ? NACK : ACK));         // receive byte(s)
        *Data++ = dat;
    }

done:
    i2cStop(pDev, Head, portID);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Data ", (U032)*Data);
    
    return status;
}

RM_STATUS i2cSend(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data, U032 NoStopFlag)
{

    if ( ChipAdr ) {
        //
        // Enable writes to the I2C port
        //
        i2cHardwareInit(pDev, Head, portID);

        i2cStart(pDev, Head, portID);
        if ( i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1)) ) // send chip adr. with write bit
        {
            i2cStop(pDev, Head, portID);                         // ack failed --> generate stop condition
            return(RM_ERROR); 
        }
    }

    for ( ; AdrLen; AdrLen--)             
    {
        if ( i2cSendByte(pDev, Head, portID, *Adr++) )        // send sub-register byte(s)
        {
            i2cStop(pDev, Head, portID);                    // ack failed --> generate stop condition
            return(RM_ERROR); 
        }
    }

    for ( ; DataLen; DataLen--)            // send data byte(s)
    {
        if ( i2cSendByte(pDev, Head, portID, *Data++) )
        {
            i2cStop(pDev, Head, portID);                     // ack failed --> generate stop condition
            return(RM_ERROR);
        }
    }

    if ( NoStopFlag == 0 )
        i2cStop(pDev, Head, portID);

    return(RM_OK);
}


RM_STATUS i2cWrite_ALT(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    i2cStart(pDev, Head, portID);
    if ( i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1)) ) // send chip adr. with write bit
    {
        i2cStop(pDev, Head, portID);                         // ack failed --> generate stop condition
        return(RM_ERROR); 
    }
    for ( ; DataLen; DataLen--)            // send data byte(s)
    {
        if ( i2cSendByte(pDev, Head, portID, *Data++) )
        {
            i2cStop(pDev, Head, portID);                     // ack failed --> generate stop condition
            return(RM_ERROR);
        }
    }
    i2cStop(pDev, Head, portID);
    return(RM_OK);
}


RM_STATUS i2cRead_ALT(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    U008 dat;
    
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: ChipAdr ", (U032)ChipAdr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: AdrLen ", (U032)AdrLen);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Adr ", (U032)*Adr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: DataLen ", (U032)DataLen);

    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    i2cStart(pDev, Head, portID);
    i2cSendByte(pDev, Head, portID, (U008)((ChipAdr<<1) | 1));        // send chip adr. with write bit
    for ( ; DataLen ; DataLen--)
    {
        i2cReceiveByte(pDev, Head, portID, (U008 *)&dat, (U008)((DataLen == 1) ? NACK : ACK));         // receive byte(s)
        *Data++ = dat;
    }
    i2cStop(pDev, Head, portID);
    
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Data ", (U032)*Data);
    
    return(RM_OK);
}


RM_STATUS i2cRead_ALT2(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    U008 dat;
    
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: ChipAdr ", (U032)ChipAdr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: AdrLen ", (U032)AdrLen);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Adr ", (U032)*Adr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: DataLen ", (U032)DataLen);

    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    i2cStart(pDev, Head, portID);
    i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1));        // send chip adr. with write bit

    for ( ; AdrLen; AdrLen--)               // send sub-register address byte(s)
    {
        if ( i2cSendByte(pDev, Head, portID, *Adr++) )
        {
            i2cStop(pDev, Head, portID);                      // ack failed --> generate stop condition
            return(RM_ERROR); 
        }
    }
    i2cStop(pDev, Head, portID);
    
    i2cStart(pDev, Head, portID);                             // send again chip address for switching to read mode
    if ( i2cSendByte(pDev, Head, portID, (U008)((ChipAdr<<1) | 1)) )  // send chip adr. with read bit
    {
        i2cStop(pDev, Head, portID);                         // ack failed --> generate stop condition
        return(RM_ERROR); 
    }

    for ( ; DataLen ; DataLen--)
    {
        i2cReceiveByte(pDev, Head, portID, (U008 *)&dat, (U008)((DataLen == 1) ? NACK : ACK));         // receive byte(s)
        *Data++ = dat;
    }

    i2cStop(pDev, Head, portID);
    
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Data ", (U032)*Data);
    
    return(RM_OK);
}

RM_STATUS i2cAccess
(
    PHWINFO pDev,
    U032 Head,
    NVRM_I2C_ACCESS_CONTROL    *pCtrl
)
{

    RM_STATUS rmStatus = RM_OK;

    U032	startFlag;
    U032	stopFlag;
    U032	ackFlag;
    U032	port;
    U008	data = 0;
    U008    lock;
    
    /*
     * verify the token
     *
     * NOTE: we allow I2C Access if the token is 0 AND no one
     * else has acquired it.  The idea is that 3rd party vendors
     * will not be able to acquire/lock I2C; however, we can still
     * acquire/lock I2C internally and lock 3rd party access out.
     * The reason is that we don't a 3rd party app to crash while
     * still holding a lock on I2C and thus lock us out from internal
     * access.  We have priority in this scheme and 3rd party
     * apps must deal with contention by checking return codes for
     * errors.
     */
     
    if (pDev->Power.State == MC_POWER_LEVEL_3)
    {
    	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Attempted I2C access before waking up. Invalid request denied.\n");
    
    	//if we are at a state of power management, we need to reject this call
    	return NVRM_I2C_ACCESS_STATUS_ERROR;
    }

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);

	//point to correct head and enable i2c
	EnableHead(pDev, Head);
	AssocDDC(pDev, Head);

    if ((pCtrl->cmd == NVRM_I2C_ACCESS_CMD_WRITE_BYTE) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_READ_BYTE) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_NULL) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_RESET) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_READ_SDA) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_READ_SCL) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_WRITE_SDA) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_WRITE_SCL)) {

        if (pCtrl->token != pDev->I2CAcquired) {
            pCtrl->status = NVRM_I2C_ACCESS_STATUS_DEVICE_BUSY;
            rmStatus = RM_ERROR;
            goto done;
        }
    }

    /*
     * retrieve the flags and port
     */

    startFlag = pCtrl->flags & NVRM_I2C_ACCESS_FLAG_START;
    stopFlag = pCtrl->flags & NVRM_I2C_ACCESS_FLAG_STOP;
    ackFlag = pCtrl->flags & NVRM_I2C_ACCESS_FLAG_ACK;

    if ( pCtrl->port == NVRM_I2C_ACCESS_PORT_PRIMARY ) {
        port = NV_I2C_PORT_PRIMARY;
    }
    else {
        port = NV_I2C_PORT_SECONDARY;
    }

    /*
     * handle the command
     */

    pCtrl->status = NVRM_I2C_ACCESS_STATUS_SUCCESS;

    switch ( pCtrl->cmd ) {

      case NVRM_I2C_ACCESS_CMD_ACQUIRE:

        if ( pDev->I2CAcquired ) {
            pCtrl->status = NVRM_I2C_ACCESS_STATUS_DEVICE_BUSY;
            rmStatus = RM_ERROR;
        }
        else {
            pDev->I2CAcquired = 0xbeeffeed; /* arbtrary */
            pCtrl->token = pDev->I2CAcquired;
            i2cHardwareInit(pDev, Head, port);
        }

        break;

      case NVRM_I2C_ACCESS_CMD_RELEASE:

        if ( pDev->I2CAcquired != pCtrl->token ) {
            pCtrl->status = NVRM_I2C_ACCESS_STATUS_ERROR;
            rmStatus = RM_ERROR;
        }
        else {
            pDev->I2CAcquired = 0;
            pCtrl->token = 0;
            pCtrl->status = NVRM_I2C_ACCESS_STATUS_SUCCESS;
        }

        break;

      case NVRM_I2C_ACCESS_CMD_WRITE_BYTE:

        if ( startFlag ) {
            i2cStart(pDev, Head, port);
        }

        data = (U008)(pCtrl->data);
        if ( i2cSendByte(pDev, Head, port,data) ) {
            i2cStop(pDev, Head, port);
            pCtrl->status = NVRM_I2C_ACCESS_STATUS_PROTOCOL_ERROR;
            rmStatus = RM_ERROR;
        }

        if ( stopFlag ) {
            i2cStop(pDev, Head, port);
        }

      	break;

      case NVRM_I2C_ACCESS_CMD_READ_BYTE:

        if ( startFlag ) {
            i2cStart(pDev, Head, port);
        }

        // check for restart read 
        if ( startFlag ) {
            data = (U008)(pCtrl->data);
            if ( i2cSendByte(pDev, Head, port,data) ) {
                i2cStop(pDev, Head, port);
                pCtrl->status = NVRM_I2C_ACCESS_STATUS_PROTOCOL_ERROR;
                rmStatus = RM_ERROR;
            }
        }
        else {
            i2cReceiveByte(pDev, Head, port, &data, (U008)((ackFlag) ? 0 : 1));
            pCtrl->data = data;
        }

        if ( stopFlag ) {
            i2cStop(pDev, Head, port);
        }

      	break;

      case NVRM_I2C_ACCESS_CMD_NULL:

        if ( startFlag ) {
            i2cStart(pDev, Head, port);
        }

        if ( stopFlag ) {
            i2cStop(pDev, Head, port);
        }

      	break;

      case NVRM_I2C_ACCESS_CMD_RESET:

        i2cStop(pDev, Head, port);

      	break;

      case NVRM_I2C_ACCESS_CMD_READ_SDA:

        ReadSDA(pDev, Head, port, &data);
        pCtrl->data = data;

        break;

      case NVRM_I2C_ACCESS_CMD_READ_SCL:

        ReadSCL(pDev, Head, port, &data);
        pCtrl->data = data;

        break;

      case NVRM_I2C_ACCESS_CMD_WRITE_SDA:

        if ( pCtrl->data ) {
            SetSDALine(pDev, Head, port);
        }
        else {
            ResetSDALine(pDev, Head, port);
        }

      case NVRM_I2C_ACCESS_CMD_WRITE_SCL:

        if ( pCtrl->data ) {
            SetSCLLine(pDev, Head, port);
        }
        else {
            ResetSCLLine(pDev, Head, port);
        }

        break;

      default:

        pCtrl->status = NVRM_I2C_ACCESS_STATUS_ERROR;
        rmStatus = RM_ERROR;
        break;

    }

done:
    RestoreLock(pDev, Head, lock);
    return rmStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\mvision.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Macrovision support **************************\
*                                                                           *
* Module: MVISION.C                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <i2c.h>
#include <os.h>
#include "nvhw.h"
#include <vga.h>
#include <nvcm.h>
#include "mvision.h"


/*;==============================================================================
;
; Function:     HW_SetMacrovisionMode
;
; Purpose:      Sets the current Macrovision capable TV Out device to
;               the requested Macrovision copy protection mode.
;
; Arguments:    
;               
;		
;
; Returns:      
;               
;
;==============================================================================*/

#define REF(proc) (U008*)(&(proc[0]))

/*; First byte is the starting sub-address*/
U008 BtNtscMVDataMode0[] =  {0xDA, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C,
			    0xF3, 0x09, 0xBD, 0x67, 0xB5, 0x90, 0xB2, 0x7D, 0x00, 0x00};
U008 BtNtscMVDataMode1[] =  {0xDA, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C,
			    0xF3, 0x09, 0xBD, 0x67, 0xB5, 0x90, 0xB2, 0x7D, 0x63, 0x00};
U008 BtNtscMVDataMode2[] =  {0xDA, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C,
			    0xF3, 0x09, 0xBD, 0x6C, 0x31, 0x92, 0x32, 0xDD, 0xE3, 0x00};
U008 BtNtscMVDataMode3[] =  {0xDA, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C,
			    0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0xE3, 0x00};

U008 *BtNtscModeTable[] = {
    REF(BtNtscMVDataMode0), REF(BtNtscMVDataMode1), REF(BtNtscMVDataMode2), REF(BtNtscMVDataMode3)
};

U008 BtPalMVDataMode0[]	=   {0xDA, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F,
			    0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, 0x00};
U008 BtPalMVDataMode1[]	=   {0xDA, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F,
			    0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x63, 0x00};

U008 *BtPalModeTable[] = {
    REF(BtPalMVDataMode0), REF(BtPalMVDataMode1)
};

/*;Format is:  REG, OR, AND,  REG, OR, AND,  REG, OR, AND,  REG, OR, AND,  REG, OR, AND,  REG, OR, AND*/
U008 PhNtscMVDataMode0[] =  {0x5D, 0x3A, 0xC0, 0x5E, 0x2E, 0xC0, 0x7D, 0x00, 0x16, 0xFF};

U008 PhNtscMVDataMode1[] =  {0x5D, 0x1B, 0xC0, 0x5E, 0x0E, 0xC0, 0x5F, 0x2E, 0xC0, 0x60, 0x40, 0x80, 0x7D, 0xC8, 0x16,
			    0x01, 0x1E, 0xC0, 0x03, 0x11, 0xC0, 0x04, 0x26, 0xC0, 0x05, 0x0A, 0x00, 0x06, 0xC5, 0x00,
			    0x07, 0xFF, 0x00, 0x08, 0x03, 0xFC, 0x10, 0x11, 0xC0, 0x11, 0xAD, 0x00, 0x12, 0x60, 0x00,
			    0x14, 0x0F, 0x00, 0x15, 0x78, 0x80, 0x20, 0x9B, 0x40, 0x21, 0x04, 0x00, 0x24, 0x00, 0x00,
			    0x25, 0x00, 0x80, 0x30, 0x1B, 0xC0, 0x31, 0x04, 0xF8, 0x33, 0x0F, 0x00, 0x36, 0x0F, 0x00, 0xFF};

U008 PhNtscMVDataMode2[] =  {0x5D, 0x1B, 0xC0, 0x5E, 0x0E, 0xC0, 0x5F, 0x2E, 0xC0, 0x60, 0x40, 0x80, 0x7D, 0xE8, 0x16,
			    0x01, 0x1E, 0xC0, 0x03, 0x11, 0xC0, 0x04, 0x26, 0xC0, 0x05, 0x0A, 0x00, 0x06, 0xC5, 0x00,
			    0x07, 0xFF, 0x00, 0x08, 0x03, 0xFC, 0x10, 0x11, 0xC0, 0x11, 0xAD, 0x00, 0x12, 0x60, 0x00,
			    0x14, 0x0F, 0x00, 0x15, 0x78, 0x80, 0x20, 0x9B, 0x40, 0x21, 0x04, 0x00, 0x24, 0x00, 0x00,
			    0x25, 0x00, 0x80, 0x30, 0x1B, 0xC0, 0x31, 0x04, 0xF8, 0x33, 0x0F, 0x00, 0x36, 0x0F, 0x00, 0xFF};

U008 PhNtscMVDataMode3[] =  {0x5D, 0x1B, 0xC0, 0x5E, 0x0E, 0xC0, 0x5F, 0x2E, 0xC0, 0x60, 0x40, 0x80, 0x7D, 0xE8, 0x16,
			    0x01, 0x18, 0xC0, 0x03, 0x15, 0xC0, 0x04, 0x22, 0xC0, 0x05, 0x0A, 0x00, 0x06, 0xC5, 0x00,
			    0x07, 0xFF, 0x00, 0x08, 0x03, 0xFC, 0x10, 0x15, 0xC0, 0x11, 0xAD, 0x00, 0x12, 0x60, 0x00,
			    0x14, 0x0F, 0x00, 0x15, 0x78, 0x80, 0x20, 0x9B, 0x40, 0x21, 0x04, 0x00, 0x24, 0x00, 0x00,
			    0x25, 0x00, 0x80, 0x30, 0x1B, 0xC0, 0x31, 0x04, 0xF8, 0x33, 0x0F, 0x00, 0x36, 0x0F, 0x00, 0xFF};

U008 *PhNtscModeTable[] = {
    REF(PhNtscMVDataMode0), REF(PhNtscMVDataMode1), REF(PhNtscMVDataMode2), REF(PhNtscMVDataMode3)
};

U008 PhPalMVDataMode0[] =   {0x5D, 0x3A, 0xC0, 0x5E, 0x2E, 0xC0, 0x7D, 0x00, 0x16, 0xFF};

U008 PhPalMVDataMode1[] =   {0x5D, 0x17, 0xC0, 0x5E, 0x19, 0xC0, 0x5F, 0x35, 0xC0, 0x60, 0x40, 0x80, 0x7D, 0xC8, 0x16,
			    0x01, 0x1B, 0xC0, 0x03, 0x22, 0xC0, 0x04, 0x2B, 0xC0, 0x05, 0x08, 0x00, 0x06, 0x74, 0x00,
			    0x07, 0x55, 0x00, 0x08, 0x01, 0xFC, 0x10, 0x22, 0xC0, 0x11, 0x15, 0x00, 0x12, 0x60, 0x00,
			    0x14, 0x07, 0x00, 0x15, 0x7E, 0x80, 0x20, 0xBB, 0x40, 0x21, 0x72, 0x00, 0x24, 0x02, 0x00,
			    0x25, 0x54, 0x80, 0x30, 0x2C, 0xC0, 0x31, 0x04, 0xF8, 0x33, 0xFE, 0x00, 0x36, 0x7E, 0x00, 0xFF};

U008 *PhPalModeTable[] = {
    REF(PhPalMVDataMode0), REF(PhPalMVDataMode1)
};

/*;Format is:  REG, OR, AND,  REG, OR, AND,  REG, OR, AND,  REG, OR, AND,  REG, OR, AND,  REG, OR, AND*/
U008 Ch_PAL_Mode00_APS1[] = { /*; MODE 0 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x6C,0x00,0x04,0x00,0x7F,0x05,0x2E,0x00,0x08,0x18,0x07,
        0x0C,0x33,0x00,0x0E,0x40,0x3F,0x16,0x38,0x00,0x2B,0x00,0xF0,0x2C,0x9F,0x00,0x2D,0x9F,0x00,
        0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0xBA,0x00,0x0D,0x80,0x0F,0x0F,0x22,0xC0,0x13,0x40,0x1F,
        0x18,0x20,0x0F,0x19,0xA0,0x0F,0x1A,0x20,0x0F,0x2F,0x9B,0x00,0x30,0x64,0x00,0x2A,0x40,0x80,
        0x2B,0x10,0x0F,0x31,0x0A,0x00,0x32,0xEE,0x00,0x33,0x26,0x80,0x34,0x2A,0x80,0x35,0x7E,0x00,
        0x36,0x9A,0x00,0x37,0x3F,0x80,0x38,0xE0,0x00,0x39,0x15,0x80,0x3A,0x40,0x00,0x3B,0xFE,0x00,
        0x3C,0x7E,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_PAL_APS0[] = { /*; MODE 0 APS=00*/
        0x10,0x00,0x0F,0x11,0x00,0x07,0x12,0x00,0x00,0x3D,0x00,0xF8,0xFF
};

U008 Ch_NTSC_Mode03_APS3[] = { /*; MODE3 APS=11*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x00,0x7F,0x05,0x30,0x00,0x08,0x30,0x07,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x01,0xF0,0x2C,0x98,0x00,0x2D,0x98,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0xBB,0x00,0x0D,0xB0,0x0F,0x0F,0x15,0xC0,0x13,0x80,0x1F,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2F,0x98,0x00,0x30,0x29,0x00,0x2A,0x4A,0x80,
        0x2B,0x00,0x0F,0x31,0xBD,0x00,0x32,0xBD,0x00,0x33,0x37,0x80,0x34,0x37,0x80,0x35,0xBD,0x00,
        0x36,0xBD,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode03_APS2[] = { /*; MODE3 APS=10*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x00,0x7F,0x05,0x30,0x00,0x08,0x30,0x07,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x01,0xF0,0x2C,0x98,0x00,0x2D,0x98,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0xBB,0x00,0x0D,0xD0,0x0F,0x0F,0x11,0xC0,0x13,0x40,0x1F,
        0x18,0x10,0x0F,0x19,0x50,0x0F,0x1A,0x10,0x0F,0x2F,0x9E,0x00,0x30,0x2D,0x00,0x2A,0x4A,0x80,
        0x2B,0x00,0x0F,0x31,0xBD,0x00,0x32,0xBD,0x00,0x33,0x37,0x80,0x34,0x37,0x80,0x35,0xBD,0x00,
        0x36,0xBD,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode03_APS1[] = { /*; MODE3 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x00,0x7F,0x05,0x30,0x00,0x08,0x30,0x07,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0x00,0x00,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2A,0x4A,0x80,0x2B,0x00,0x0F,0x31,0xBD,0x00,
        0x32,0xBD,0x00,0x33,0x37,0x80,0x34,0x37,0x80,0x35,0xBD,0x00,0x36,0xBD,0x00,0x37,0x0F,0x80,
        0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_APS0[] = { /*; MODE3 APS=00 */
        0x10,0x00,0x0F,0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0x00,0x00,0x3D,0x00,0xF8,0xFF
};

U008 Ch_PAL_Mode08_APS1[] = { /*; MODE 8 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x6C,0x00,0x04,0x00,0x7F,0x05,0x37,0x00,0x08,0x18,0x07,
        0x0C,0x33,0x00,0x0E,0x40,0x3F,0x16,0x38,0x00,0x2B,0x00,0xF0,0x2C,0xBD,0x00,0x2D,0xBD,0x00,
        0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0xDE,0x00,0x0D,0x80,0x0F,0x0F,0x22,0xC0,0x13,0x40,0x1F,
        0x18,0x20,0x0F,0x19,0xA0,0x0F,0x1A,0x20,0x0F,0x2F,0x9B,0x00,0x30,0x64,0x00,0x2A,0x4C,0x80,
        0x2B,0x30,0x0F,0x31,0x3C,0x00,0x32,0x1B,0x00,0x33,0x2E,0x80,0x34,0x32,0x80,0x35,0x96,0x00,
        0x36,0xB7,0x00,0x37,0x3F,0x80,0x38,0xE0,0x00,0x39,0x15,0x80,0x3A,0x40,0x00,0x3B,0xFE,0x00,
        0x3C,0x7E,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode11_APS3[] = { /*; MODE11 APS=11*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x00,0x7F,0x05,0x3A,0x00,0x08,0x30,0x07,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x01,0xF0,0x2C,0x67,0x00,0x2D,0x67,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0xE2,0x00,0x0D,0xB0,0x0F,0x0F,0x15,0xC0,0x13,0x80,0x1F,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2F,0x98,0x00,0x30,0x29,0x00,0x2A,0x59,0x80,
        0x2B,0xF0,0x0F,0x31,0x08,0x00,0x32,0x08,0x00,0x33,0x42,0x80,0x34,0x42,0x80,0x35,0x08,0x00,
        0x36,0x08,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode11_APS2[] = { /*; MODE11 APS=10*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x00,0x7F,0x05,0x3A,0x00,0x08,0x30,0x07,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x01,0xF0,0x2C,0x67,0x00,0x2D,0x67,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0xE2,0x00,0x0D,0xD0,0x0F,0x0F,0x11,0xC0,0x13,0x40,0x1F,
        0x18,0x10,0x0F,0x19,0x50,0x0F,0x1A,0x10,0x0F,0x2F,0x9E,0x00,0x30,0x2D,0x00,0x2A,0x59,0x80,
        0x2B,0xF0,0x0F,0x31,0x08,0x00,0x32,0x08,0x00,0x33,0x42,0x80,0x34,0x42,0x80,0x35,0x08,0x00,
        0x36,0x08,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode11_APS1[] = { /*; MODE11 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x00,0x7F,0x05,0x3A,0x00,0x08,0x30,0x07,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0x00,0x00,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2A,0x59,0x80,0x2B,0xF0,0x0F,0x31,0x08,0x00,
        0x32,0x08,0x00,0x33,0x42,0x80,0x34,0x42,0x80,0x35,0x08,0x00,0x36,0x08,0x00,0x37,0x0F,0x80,
        0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_PAL_Mode14_APS1[] = { /*; MODE 14 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x6C,0x00,0x04,0x00,0x7F,0x05,0x3A,0x00,0x08,0x18,0x07,
        0x0C,0x33,0x00,0x0E,0x40,0x3F,0x16,0x38,0x00,0x2B,0x00,0xF0,0x2C,0xC8,0x00,0x2D,0xC8,0x00,
        0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0xEA,0x00,0x0D,0x80,0x0F,0x0F,0x22,0xC0,0x13,0x40,0x1F,
        0x18,0x20,0x0F,0x19,0xA0,0x0F,0x1A,0x20,0x0F,0x2F,0x9B,0x00,0x30,0x64,0x00,0x2A,0x50,0x80,
        0x2B,0x30,0x0F,0x31,0x4C,0x00,0x32,0x29,0x00,0x33,0x30,0x80,0x34,0x34,0x80,0x35,0x9D,0x00,
        0x36,0xC0,0x00,0x37,0x3F,0x80,0x38,0xE0,0x00,0x39,0x15,0x80,0x3A,0x40,0x00,0x3B,0xFE,0x00,
        0x3C,0x7E,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode17_APS3[] = { /*; MODE17 APS=11*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x40,0x3F,0x05,0x37,0x00,0x06,0x80,0x7F,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x01,0xF0,0x2C,0xAE,0x00,0x2D,0xAE,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0xD6,0x00,0x0D,0xB0,0x0F,0x0F,0x15,0xC0,0x13,0x80,0x1F,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2F,0x98,0x00,0x30,0x29,0x00,0x2A,0x54,0x80,
        0x2B,0x00,0x0F,0x31,0xFA,0x00,0x32,0xFA,0x00,0x33,0x3F,0x80,0x34,0x3F,0x80,0x35,0xFA,0x00,
        0x36,0xFA,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0x08,0x30,0x07,0xFF
};

U008 Ch_NTSC_Mode17_APS2[] = { /*; MODE17 APS=10*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x40,0x3F,0x05,0x37,0x00,0x06,0x80,0x7F,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x01,0xF0,0x2C,0xAE,0x00,0x2D,0xAE,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0xD6,0x00,0x0D,0xD0,0x0F,0x0F,0x11,0xC0,0x13,0x40,0x1F,
        0x18,0x10,0x0F,0x19,0x50,0x0F,0x1A,0x10,0x0F,0x2F,0x9E,0x00,0x30,0x2D,0x00,0x2A,0x54,0x80,
        0x2B,0x00,0x0F,0x31,0xFA,0x00,0x32,0xFA,0x00,0x33,0x3F,0x80,0x34,0x3F,0x80,0x35,0xFA,0x00,
        0x36,0xFA,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0x08,0x30,0x07,0xFF
};

U008 Ch_NTSC_Mode17_APS1[] = { /*; MODE17 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x40,0x3F,0x05,0x37,0x00,0x06,0x80,0x7F,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0x00,0x00,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2A,0x54,0x80,0x2B,0x00,0x0F,0x31,0xFA,0x00,
        0x32,0xFA,0x00,0x33,0x3F,0x80,0x34,0x3F,0x80,0x35,0xFA,0x00,0x36,0xFA,0x00,0x37,0x0F,0x80,
        0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,0x3C,0x0F,0x00,0x3D,0x05,0xF8,
	0x08,0x30,0x07,0xFF
};

U008 Ch_PAL_Mode20_APS1[] = { /*; MODE20 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x6C,0x00,0x04,0x00,0x7F,0x05,0x47,0x00,0x08,0x18,0x07,
        0x0C,0x33,0x00,0x0E,0x40,0x3F,0x16,0x38,0x00,0x2B,0x08,0xF0,0x2C,0xF3,0x00,0x2D,0xF3,0x00,
        0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0x1C,0x00,0x0D,0x80,0x0F,0x0F,0x22,0xC0,0x13,0x40,0x1F,
        0x18,0x20,0x0F,0x19,0xA0,0x0F,0x1A,0x20,0x0F,0x2F,0x9B,0x00,0x30,0x64,0x00,0x2A,0x61,0x80,
        0x2B,0x30,0x0F,0x31,0x94,0x00,0x32,0x6A,0x00,0x33,0x3B,0x80,0x34,0x40,0x80,0x35,0xC0,0x00,
        0x36,0xEA,0x00,0x37,0x3F,0x80,0x38,0xE0,0x00,0x39,0x15,0x80,0x3A,0x40,0x00,0x3B,0xFE,0x00,
        0x3C,0x7E,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode22_APS3[] = { /*; MODE22 APS=11*/
        0x10,0xF0,0x0F,  
        0x04,0x40,0x3F, 0x05,0x3A,0x00, 0x01,0x80,0x3F, 0x02,0x0B,0x00, 0x08,0x30,0x07,
        0x0E,0x40,0x3F, 0x0C,0x05,0x00, 0x17,0x40,0x3F, 0x16,0x0d,0x00,
        0x2B,0xF1,0x00, 0x2C,0xB5,0x00, 0x2D,0xB5,0x00, 0x2E,0xDF,0x00, 0x11,0xC8,0x07, 
        0x12,0xFF,0x00, 0x13,0x80,0x1F, 0x0D,0xB0,0x0F, 0x0F,0x15,0xC0, 0x2F,0x98,0x00,
        0x30,0x29,0x00, 0x19,0x50,0x0F, 0x18,0x50,0x0F, 0x1A,0x50,0x0F, 	
        0x31,0x06,0x00, 0x32,0x06,0x00, 0x2A,0x58,0x80, 0x33,0x41,0x80, 0x34,0x41,0x80, 
        0x35,0x06,0x00, 0x36,0x06,0x00, 0x3B,0x0F,0x00, 0x3C,0x0F,0x00, 0x37,0x0F,0x80, 
        0x38,0xF0,0x00, 0x39,0x00,0x80,	0x3A,0x00,0x00, 0x3D,0x05,0xF8, 0xFF
};

U008 Ch_NTSC_Mode22_APS2[] = { /*; MODE22 APS=10*/
        0x10,0xF0,0x0F,  
        0x04,0x40,0x3F, 0x05,0x3A,0x00, 0x01,0x80,0x3F, 0x02,0x0B,0x00, 0x08,0x30,0x07,
        0x0E,0x40,0x3F, 0x0C,0x05,0x00, 0x17,0x40,0x3F, 0x16,0x0d,0x00, 
        0x2B,0xF1,0x00, 0x2C,0xB5,0x00, 0x2D,0xB5,0x00, 0x2E,0xDF,0x00, 0x11,0xC8,0x07, 
        0x12,0xFF,0x00, 0x13,0x40,0x1F, 0x0D,0xD0,0x0F, 0x0F,0x11,0xC0, 0x2F,0x9E,0x00,
        0x30,0x2D,0x00, 0x19,0x50,0x0F, 0x18,0x10,0x0F, 0x1A,0x10,0x0F, 	
        0x31,0X06,0x00, 0x32,0x06,0x00, 0x2A,0x58,0x80, 0x33,0x41,0x80, 0x34,0x41,0x80, 
        0x35,0x06,0x00, 0x36,0x06,0x00, 0x3B,0x0F,0x00, 0x3C,0x0F,0x00, 0x37,0x0F,0x80, 
        0x38,0xF0,0x00, 0x39,0x00,0x80,	0x3A,0x00,0x00, 0x3D,0x05,0xF8, 0xFF
};

U008 Ch_NTSC_Mode22_APS1[] = { /*; MODE22 APS=01*/	
        0x10,0xE0,0x0F, 
        0x04,0x40,0x3F, 0x05,0x3A,0x00, 0x01,0x80,0x3F, 0x02,0x0B,0x00, 0x08,0x30,0x07, 
        0x0E,0x40,0x3F, 0x0C,0x05,0x00, 0x17,0x40,0x3F, 0x16,0x0d,0x00,
        0x2B,0xF0,0x00, 0x2C,0x00,0x00, 0x2D,0x00,0x00, 0x2E,0x00,0x00, 0x11,0x00,0x07,	
        0x12,0x00,0x00, 0x13,0x00,0x1F, 0x0D,0x00,0x0F, 0x0F,0x00,0xC0, 0x2F,0x00,0x00,
        0x30,0x00,0x00, 0x19,0x50,0x0F, 0x18,0x50,0x0F, 0x1A,0x50,0x0F, 	
        0x31,0x06,0x00, 0x32,0x06,0x00, 0x2A,0x58,0x80, 0x33,0x41,0x80, 0x34,0x41,0x80, 
        0x35,0x06,0x00, 0x36,0x06,0x00, 0x3B,0x0F,0x00, 0x3C,0x0F,0x00, 0x37,0x0F,0x80, 
        0x38,0xF0,0x00, 0x39,0x00,0x80,	0x3A,0x00,0x00, 0x3D,0x05,0xF8, 0xFF
};

U008 Ch_PAL_Mode19_APS1[] = { /*; MODE19 APS=01*/	
        0x10,0xE0,0x0F, 
        0x04,0x40,0x3F, 0x05,0x3a,0x00, 0x01,0x80,0x3F, 0x02,0x6c,0x00, 0x08,0x18,0x07, 
        0x0e,0x40,0x3F, 0x0c,0x33,0x00, 0x17,0x40,0x3F, 0x16,0x38,0x00,
        0x2b,0x30,0x00, 0x2c,0xc8,0x00, 0x2d,0xc8,0x00, 0x2e,0xea,0x00, 0x11,0x00,0x07, 
        0x12,0x00,0x00, 0x13,0x40,0x1F, 0x0d,0x80,0x0F, 0x0f,0x22,0xC0, 0x2f,0x9b,0x00,
        0x30,0x64,0x00, 0x19,0xa0,0x0F, 0x18,0x20,0x0F, 0x1a,0x20,0x0F, 
        0x31,0x4c,0x00, 0x32,0x29,0x00, 0x2a,0x50,0x80, 0x33,0x30,0x80, 0x34,0x34,0x80, 
        0x35,0x9d,0x00, 0x36,0xc0,0x00, 0x3b,0xfe,0x00, 0x3c,0x7e,0x00, 0x37,0x3f,0x80,
        0x38,0xe0,0x00, 0x39,0x15,0x80,	0x3a,0x40,0x00, 0x3d,0x05,0xF8, 0xFF
};

U008 Ch_NTSC_Mode24_APS3[] = { /*; MODE24 APS=11*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x40,0x3F,0x05,0x40,0x00,0x06,0x80,0x7F,
	0x08,0x30,0x07,0x1B,0x0B,0xF0,0x1C,0x04,0xF0,0x1D,0x01,0xF0,0x1E,0x06,0xF0,0x1F,0x05,0xF0,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x09,0xF0,0x2C,0xDD,0x00,0x2D,0xDD,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0x11,0x00,0x0D,0xB0,0x0F,0x0F,0x15,0xC0,0x13,0x80,0x1F,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2F,0x98,0x00,0x30,0x29,0x00,0x2A,0x6B,0x80,
        0x2B,0xF0,0x0F,0x31,0x3F,0x00,0x32,0x3F,0x00,0x33,0x50,0x80,0x34,0x50,0x80,0x35,0x3F,0x00,
        0x36,0x3F,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode24_APS2[] = { /*; MODE24 APS=10*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x40,0x3F,0x05,0x40,0x00,0x06,0x80,0x7F,
        0x08,0x30,0x07,0x1B,0x0B,0xF0,0x1C,0x04,0xF0,0x1D,0x01,0xF0,0x1E,0x06,0xF0,0x1F,0x05,0xF0,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x09,0xF0,0x2C,0xDD,0x00,0x2D,0xDD,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0x11,0x00,0x0D,0xD0,0x0F,0x0F,0x11,0xC0,0x13,0x40,0x1F,
        0x18,0x10,0x0F,0x19,0x50,0x0F,0x1A,0x10,0x0F,0x2F,0x9E,0x00,0x30,0x2D,0x00,0x2A,0x6B,0x80,
        0x2B,0xF0,0x0F,0x31,0x3F,0x00,0x32,0x3F,0x00,0x33,0x50,0x80,0x34,0x50,0x80,0x35,0x3F,0x00,
        0x36,0x3F,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode24_APS1[] = { /*; MODE24 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x40,0x3F,0x05,0x40,0x00,0x06,0x80,0x7F,
        0x08,0x30,0x07,0x1B,0x0B,0xF0,0x1C,0x04,0xF0,0x1D,0x01,0xF0,0x1E,0x06,0xF0,0x1F,0x05,0xF0,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0x00,0x00,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2A,0x6B,0x80,0x2B,0xF0,0x0F,0x31,0x3F,0x00,
        0x32,0x3F,0x00,0x33,0x50,0x80,0x34,0x50,0x80,0x35,0x3F,0x00,0x36,0x3F,0x00,0x37,0x0F,0x80,
        0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 *Ch_PAL_Table[] = { /*; PAL formats only support APS=01*/
        REF(Ch_PAL_APS0), REF(Ch_PAL_Mode00_APS1), REF(Ch_PAL_Mode00_APS1), REF(Ch_PAL_Mode00_APS1),
        REF(Ch_PAL_APS0), REF(Ch_PAL_Mode08_APS1), REF(Ch_PAL_Mode08_APS1), REF(Ch_PAL_Mode08_APS1),
        REF(Ch_PAL_APS0), REF(Ch_PAL_Mode14_APS1), REF(Ch_PAL_Mode14_APS1), REF(Ch_PAL_Mode14_APS1),
        REF(Ch_PAL_APS0), REF(Ch_PAL_Mode19_APS1), REF(Ch_PAL_Mode19_APS1), REF(Ch_PAL_Mode19_APS1),
        REF(Ch_PAL_APS0), REF(Ch_PAL_Mode20_APS1), REF(Ch_PAL_Mode20_APS1), REF(Ch_PAL_Mode20_APS1)
};

U008 *Ch_NTSC_Table[] = { /*; NTSC formats support all Macrovision modes*/
        REF(Ch_NTSC_APS0), REF(Ch_NTSC_Mode03_APS1), REF(Ch_NTSC_Mode03_APS2), REF(Ch_NTSC_Mode03_APS3),
        REF(Ch_NTSC_APS0), REF(Ch_NTSC_Mode11_APS1), REF(Ch_NTSC_Mode11_APS2), REF(Ch_NTSC_Mode11_APS3),
        REF(Ch_NTSC_APS0), REF(Ch_NTSC_Mode17_APS1), REF(Ch_NTSC_Mode17_APS2), REF(Ch_NTSC_Mode17_APS3),
        REF(Ch_NTSC_APS0), REF(Ch_NTSC_Mode22_APS1), REF(Ch_NTSC_Mode22_APS2), REF(Ch_NTSC_Mode22_APS3),
        REF(Ch_NTSC_APS0), REF(Ch_NTSC_Mode24_APS1), REF(Ch_NTSC_Mode24_APS2), REF(Ch_NTSC_Mode24_APS3)
};

U032 CH_Mode_Table[] = { 512, 384, 640, 400, 640, 480, 720, 576, 800, 600, 0 };

RM_STATUS ReadChRegister(
    PHWINFO pDev,
    U032    Head,
    U032    dwPort,
    U008    TVOutDeviceAddr,
	U008	RegNum,
	U008	*pData
	)
{
    RM_STATUS   rmStatus = RM_ERROR;

    i2cStart(pDev, Head, dwPort);

    /* First generate the DEVICE ID with WRITE */
    if ( i2cSendByte(pDev, Head, dwPort, TVOutDeviceAddr) )
		goto RCR_Exit;

    /* Next generate the REGISTER ADDRESS */
    if ( i2cSendByte(pDev, Head, dwPort, RegNum) )
		goto RCR_Exit;

    /*  Next generate a RESTART and the DEVICE ID with READ */
    i2cStart(pDev, Head, dwPort);
    if ( i2cSendByte(pDev, Head, dwPort, (U008)(TVOutDeviceAddr+1)) )
		goto RCR_Exit;

    /* Finally, READ the data from the device */
    if( i2cReceiveByte(pDev, Head, dwPort, pData, 1) == -1 )
		goto RCR_Exit;

	rmStatus = RM_OK;

RCR_Exit:
    i2cStop(pDev, Head, dwPort);
	return rmStatus;
}

RM_STATUS WriteChRegister(
    PHWINFO pDev,
    U032    Head,
    U032    dwPort,
    U008    TVOutDeviceAddr,
	U008	RegNum,
	U008	Data
	)
{
    RM_STATUS   rmStatus = RM_ERROR;

    i2cStart(pDev, Head, dwPort);

    /* First generate the DEVICE ID with WRITE */
    if ( i2cSendByte(pDev, Head, dwPort, TVOutDeviceAddr) )
		goto WCR_Exit;

    /* Next generate the REGISTER ADDRESS */
    if ( i2cSendByte(pDev, Head, dwPort, RegNum) )
		goto WCR_Exit;

    /*  Finally, WRITE the DATA */
    if ( i2cSendByte(pDev, Head, dwPort, Data) )
		goto WCR_Exit;

	rmStatus = RM_OK;

WCR_Exit:
    i2cStop(pDev, Head, dwPort);
	return rmStatus;
}

RM_STATUS SetMacrovisionMode(
    PHWINFO pDev,
    U032    Head,
    RM_MACROVISION_CONTROL	*pCtrl
    )
{
    RM_STATUS   rmStatus;
    U032        dwCount;
    U008        *pReg, data, tb, brValue = 0;
    U032        i; 
    U032        dwNewMode, dwChangeBrightness, dwPort, dwEncoderType, dwTVStandard;
    U008        TVOutDeviceAddr;
    U008        lock;
    U032        dwTVWidth, dwTVHeight;


    rmStatus = RM_OK;

    TVOutDeviceAddr = (U008)pCtrl->devAddr;
    dwNewMode = pCtrl->mode & 0x3;
    dwChangeBrightness = pCtrl->mode & 0x4;
    dwPort = pCtrl->port;
    dwEncoderType = pCtrl->encoderType;
    dwTVStandard = pCtrl->tvStandard;

    pCtrl->status = RM_OK;

    //
    // Update rolling "last" macrovision setting
    //
    pDev->Dac.TVLastMacrovision.devAddr         = pCtrl->devAddr;
    pDev->Dac.TVLastMacrovision.mode            = pCtrl->mode;
    pDev->Dac.TVLastMacrovision.port            = pCtrl->port;
    pDev->Dac.TVLastMacrovision.encoderType     = pCtrl->encoderType;
    pDev->Dac.TVLastMacrovision.tvStandard      = pCtrl->tvStandard;
    pDev->Dac.TVLastMacrovision.resx            = pCtrl->resx;
    pDev->Dac.TVLastMacrovision.resy            = pCtrl->resy;

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);

    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);  // Connect the head to the I2C pins
    }

    switch( dwEncoderType )
    {
	default:
#ifdef DEBUG
        DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: Unknown encoder type");
        DBG_BREAKPOINT();
#endif
	case NV_ENCODER_BROOKTREE_868:
	case NV_ENCODER_CHRONTEL_7003:
	case NV_ENCODER_CHRONTEL_7006:
	case NV_ENCODER_CHRONTEL_7008:
	    /* Macrovosion not supported */
	    pCtrl->status = RM_ERROR;
	    return RM_ERROR;

	case NV_ENCODER_BROOKTREE_869:
	case NV_ENCODER_BROOKTREE_871:

	    switch( dwTVStandard)
	    {
		case NTSC_M:
		case NTSC_J:
		    /* Limit MV mode to [0,3] */
		    if( dwNewMode > 3 )
                        dwNewMode = 3;
		    pReg = BtNtscModeTable[dwNewMode];
		    break;

		case PAL_M:
		case PAL_A:
		case PAL_N:
		case PAL_NC:
		    /* Limit MV mode to 0 or 1 */
		    if( dwNewMode > 1 )
                        dwNewMode = 1;
		    pReg = BtPalModeTable[dwNewMode];
		    break;

		default:
#ifdef DEBUG
		    DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: Unknown TV Standard");
		    DBG_BREAKPOINT();
#endif
		    pCtrl->status = RM_ERROR;
                    rmStatus = RM_ERROR;
                    goto done;
	    }

            i2cStart(pDev, Head, dwPort);
	    
	    /* First generate the DEVICE ID with WRITE */
	    if ( i2cSendByte(pDev, Head, dwPort, TVOutDeviceAddr) )
	    {
                pCtrl->status = RM_ERROR;
                rmStatus = RM_ERROR;
                break;
	    }

            /* Now, write the data */
	    for (dwCount = 0; dwCount < 19; dwCount++)
            {
                if ( i2cSendByte(pDev, Head, dwPort, pReg[dwCount]) )
                {
                    pCtrl->status = RM_ERROR;
                    rmStatus = RM_ERROR;
                    break;
                }
            }

            i2cStop(pDev, Head, dwPort);

	    break;

	case TV_ENCODER_PHILIPS:
	case NV_ENCODER_PHILIPS_7102:
	case NV_ENCODER_PHILIPS_7103:
	case NV_ENCODER_PHILIPS_7108:
	case NV_ENCODER_PHILIPS_7109:

	    switch( dwTVStandard)
	    {
		case NTSC_M:
		case NTSC_J:
			brValue = 0;
		    /* Limit MV mode to [0,3] */
		    if( dwNewMode > 3 )
                        dwNewMode = 3;
		    pReg = PhNtscModeTable[dwNewMode];
		    break;

		case PAL_M:
		case PAL_A:
		case PAL_N:
		case PAL_NC:
			brValue = 0;
		    /* Limit MV mode to 0 or 1 */
		    if( dwNewMode > 1 )
                        dwNewMode = 1;
		    pReg = PhPalModeTable[dwNewMode];
		    break;

		default:
#ifdef DEBUG
		    DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: Unknown TV Standard");
		    DBG_BREAKPOINT();
#endif
		    pCtrl->status = RM_ERROR;
            return RM_ERROR;
	    }

		goto CommonForPhilipsAndChrontel;

	case NV_ENCODER_CHRONTEL_7005:
	case NV_ENCODER_CHRONTEL_7007:

        // Read Chrontel register zero to determine current TV resolution.
		// Special case for 720x576, which is actually a 800x600 mode.  Checking additional bit field for case 4
		// to set 720x576 instead of 800x600.
		ReadChRegister(pDev, Head, dwPort, TVOutDeviceAddr, 0x00, &data);
        switch (data >> 5) {
        case 0: dwTVWidth = 512; dwTVHeight = 384; break;
        case 1: dwTVWidth = 720; dwTVHeight = 400; break;
        case 2: dwTVWidth = 640; dwTVHeight = 400; break;
        case 3: dwTVWidth = 640; dwTVHeight = 480; break;
        case 4:
            if ((data == 0x8b) || (data == 0x81)) /* Check for Mode 19 or 22 which are 720x576 resolutions */
            {
                dwTVWidth = 720; dwTVHeight = 576;
            }
            else
            {
                dwTVWidth = 800; dwTVHeight = 600;
            }
            break;
        default: dwTVWidth = 800; dwTVHeight = 600; break;
        }

	    for( i=0; ;i++ )
	    {
            if( !CH_Mode_Table[i*2] )
            {
                // If we get to the end of the TV mode table without a match,
                // default to the index for 800x600 mode.
                i--;
                break;
            }

            if( CH_Mode_Table[i*2] == dwTVWidth && CH_Mode_Table[i*2+1] == dwTVHeight )
                break;
	    }

	    dwNewMode &= 3;
	    switch( dwTVStandard)
	    {
		case NTSC_M:
		case NTSC_J:
			brValue = 0x49;     /* supplied by Chrontel */
		    pReg = Ch_NTSC_Table[i*4+dwNewMode];
		    break;

		case PAL_M:
		case PAL_A:
		case PAL_N:
		case PAL_NC:
			brValue = 0x4b;     /* supplied by Chrontel */
		    pReg = Ch_PAL_Table[i*4+dwNewMode];
		    break;

		default:
#ifdef DEBUG
		    DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: Unknown TV Standard");
		    DBG_BREAKPOINT();
#endif
		    pCtrl->status = RM_ERROR;
                    return RM_ERROR;
	    }

CommonForPhilipsAndChrontel:

        if(brValue != 0 && dwChangeBrightness != 0 && dwNewMode != 0)
		{
			/*1. Upon switching to ACP1, 2 or 3, save the current state of Reg0x09
				and set reg 0x09 to 0x4b as recommended by Eric Tzou.*/
			if(ReadChRegister(pDev, Head, dwPort, TVOutDeviceAddr, 0x09, &data) != RM_OK)
			{
				pCtrl->status = RM_ERROR;
				rmStatus = RM_ERROR;
				break;
			}
			pDev->Dac.SavedReg09H = data;

			/* When MVC is turned on (APS = 1, 2, 3), fill the register with 49h (NTSC) or 4b (PAL) ; */
            if(WriteChRegister(pDev, Head, dwPort, TVOutDeviceAddr, 0x09, brValue) != RM_OK)
            {
                pCtrl->status = RM_ERROR;
                rmStatus = RM_ERROR;
                break;
            }
		}

	    for(; *pReg != 0xFF; pReg += 3 )
	    {
                data = 0;
            if( *(pReg+2) != 0 )
            {
                if(ReadChRegister(pDev, Head, dwPort, TVOutDeviceAddr, *pReg, &data) != RM_OK)
                {
                    pCtrl->status = RM_ERROR;
                    rmStatus = RM_ERROR;
                    break;
                }
            }

            tb = data;
            data = (data & *(pReg+2)) | *(pReg+1);

            if ( data == 0 || data != tb )
            {
                if(WriteChRegister(pDev, Head, dwPort, TVOutDeviceAddr, *pReg, data) != RM_OK)
                {
                    pCtrl->status = RM_ERROR;
                    rmStatus = RM_ERROR;
                    break;
                }
            }
	    }

        if(brValue == 0 || dwChangeBrightness == 0 || dwNewMode != 0)
            break;

        /* Restore brightness */
		/* When MVC is turned off (APS = 0) or DVD player is exited, fill the
			register with 64h. */
#if 0
        data = (U008)pDev->Dac.SavedReg09H;
        if(WriteChRegister(pDev, Head, dwPort, TVOutDeviceAddr, 0x09, data) != RM_OK)
#else
        if(WriteChRegister(pDev, Head, dwPort, TVOutDeviceAddr, 0x09, 0x64) != RM_OK)
#endif
        {
            pCtrl->status = RM_ERROR;
            rmStatus = RM_ERROR;
            break;
        }

        break;
            
    }

 done:
    RestoreLock(pDev, Head, lock);

    return rmStatus;
}

RM_STATUS GetMacrovisionMode(
    PHWINFO pDev,
    U032    Head,
    RM_MACROVISION_CONTROL	*pCtrl
    )
{
    RM_STATUS   rmStatus;

    rmStatus = RM_OK;

    //
    // retrieve last settings
    //
    pCtrl->devAddr     = pDev->Dac.TVLastMacrovision.devAddr;
    pCtrl->mode        = pDev->Dac.TVLastMacrovision.mode;
    pCtrl->port        = pDev->Dac.TVLastMacrovision.port;
    pCtrl->encoderType = pDev->Dac.TVLastMacrovision.encoderType;
    pCtrl->tvStandard  = pDev->Dac.TVLastMacrovision.tvStandard;
    pCtrl->resx        = pDev->Dac.TVLastMacrovision.resx;
    pCtrl->resy        = pDev->Dac.TVLastMacrovision.resy;

    pCtrl->status = RM_OK;

    return rmStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\edid.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* EDID Functions *****************************
*                                                                           *
* Module: EDID.C                                                            *
*   All EDID related fuctions are in this module.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nvrm.h>
#include <i2c.h>
#include <tmr.h>
#include <edid.h>
#include "nvhw.h"
#include <dac.h>
#include <devinit.h>
#include <vga.h>


U032 getI2CPort(PHWINFO pDev, U032 Head, U032 dispType )
{
    // We have to know what the mappings of ports to display devices are.
    // Until we can get this from the BIOS, assume the following:
    switch (dispType)
    {
        case DISPLAY_TYPE_MONITOR:
        case DISPLAY_TYPE_DUALSURFACE:
            if (Head == 0) 
                return pDev->Dac.CRTPortID; // VGA Head 0 use port 0
            else
                return pDev->Dac.CRT2PortID; // DVI Head 1 use port 1
        case DISPLAY_TYPE_FLAT_PANEL:
            if (Head == 0) 
                return pDev->Dac.DFPPortID; // DVI Head 0
            else
                return pDev->Dac.DFP2PortID; // DVI Head 1
        case DISPLAY_TYPE_TV:
            return pDev->Dac.TVOutPortID;
        default:
            return NV_I2C_PORT_PRIMARY;
    }
}

static U032 edidTranslateDisplayType(U032 displayType)
{
    switch (displayType)
    {
        case DCB_DEV_REC_TYPE_CRT:
        {
            return DISPLAY_TYPE_MONITOR;
        }
        case DCB_DEV_REC_TYPE_TV:
        {
            return DISPLAY_TYPE_TV;
        }
        case DCB_DEV_REC_TYPE_DD_SLINK:
        case DCB_DEV_REC_TYPE_DD_DLINK:
        {
            return DISPLAY_TYPE_FLAT_PANEL;
        }
        default:
            return DISPLAY_TYPE_NONE;
    }
}

static RM_STATUS getDefaultEDIDFromBIOS(PHWINFO, U032, U032);

// Get the monitor to stop driving the DDC bus (DDC1)
// This may only stop the CRT momentarily; we must send a valid DDC2 address
// to be sure it stops permanently.
RM_STATUS StopDDC1(PHWINFO pDev, U032 Head, U032 dispType)
{
U032	i2cPortId = 0;	
U016	status = 1, i;
U008	Data;

    i2cPortId = getI2CPort(pDev, Head, dispType);
    i2cHardwareInit(pDev, Head, i2cPortId);
    tmrDelay(pDev, 15000);
    ResetSCLLine(pDev, Head, i2cPortId);     // drive clock low (data tristated)
    tmrDelay(pDev, 2000000);
    SetSCLLine(pDev, Head, i2cPortId);       // clock high
    SetSDALine(pDev, Head, i2cPortId);       // data high
    for (i=0; i<16; i++)	// give it 16 times
    {
        tmrDelay(pDev, 15000);
        ReadSDA(pDev, Head, i2cPortId, &Data);
        if(Data)        	// SDA = 1?
        {
            status=0;
            break;
        }
    }
    tmrDelay(pDev, 10000);
    i2cStop(pDev, Head, i2cPortId);
    
    // Leave it with clock low (problem with ViewSonic monitors)
    ResetSCLLine(pDev, Head, i2cPortId);     // drive clock low (data tristated)
    tmrDelay(pDev, 2000000);
	
    if (status)
        return (RM_ERROR);
    return (RM_OK);
}

//****************************************************************************************
/*	Determine if monitor is DDC, and in doing so, get it ready to read the EDID or VDIF
	This means get it in DDC2 mode and send the address. Try addresses A0 and A2.
*/
RM_STATUS IsMonitorDDC(PHWINFO pDev, U032 Head, U032 dispType, U008 *dispAddr)
{
    RM_STATUS status;
    U008	Adr, Data;
    U032    i2cPortId;
    BOOL    NV15Retry = FALSE;

    i2cPortId = getI2CPort(pDev, Head, dispType);
    // NV11 can drive a CRT on either head; earlier devices only on port 0.
    if (IsNV11(pDev) || (i2cPortId == 0))  
    {
        StopDDC1(pDev, Head, dispType);	// stop the CRT from driving the bus
    }

    // now monitor is in DDC2 mode; we can talk to it
    // send address 0 (start of EDID), no other data
IsMonitorDDC_NV15_Retry:
    Adr = 0;
    *dispAddr = DDC_CRT_ADR1;
    if (dispType == DISPLAY_TYPE_MONITOR) {
        status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR1, 1, &Adr, 0, &Data);   // if it fails, its not DDC
    }
    else if (dispType == DISPLAY_TYPE_FLAT_PANEL)
    {
        // if flat panel, device address can be A0, A2, or A6 (50/51/53 shifted left)
	    status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR1, 1, &Adr, 0, &Data);   
        if (status)
        {
            *dispAddr = DDC_CRT_ADR2;
		    status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR2, 1, &Adr, 0, &Data);  
            if (status)
            {
                *dispAddr = DDC_CRT_ADR3;
    		    status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR3, 1, &Adr, 0, &Data);  
            }
        }
    }
    else
    {
        // not a DDC device
        status = RM_ERROR;
    }

    if ((status != RM_OK) && IsNV15(pDev) && (dispType == DISPLAY_TYPE_MONITOR) && !NV15Retry) {
        NV15Retry = TRUE;
        i2cPortId = getI2CPort(pDev, 1, dispType);
        goto IsMonitorDDC_NV15_Retry;
    }

    return status;
}

U032 edidGetVersion(PHWINFO pDev, U032 Head)
{
    U008 i, index = 0;

    // check for version 1
    if (pDev->Dac.CrtcInfo[Head].EDID[0]	== 0x00)
    {
        for (i=1; i<8; i++)
            if (pDev->Dac.CrtcInfo[Head].EDID[i] == 0xff)
                index = i;
            else 
                break;
        if (pDev->Dac.CrtcInfo[Head].EDID[index+1]	== 0x00)
            return 1;		
    }	
    if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_VERSION_NUMBER_INDEX] & 0xf0) == 0x20)
        return 2;

    return 0;	// Invalid or unknown EDID
}

//****************************************************************************************
/*	Checksum an EDID
 */
static BOOL EDIDCheckSumOk(
    PHWINFO pDev, 
    U032    Head, 
    U008   *edid,
    U032    length
)
{
    U032 j;
    int  chksum;

    // This is version 1 header
    // checksum the block
    chksum = 0;

    for (j=0; j<length; j++)
        chksum += *edid++;
 
    return ((U008) chksum) == 0;
}

//****************************************************************************************
/*	Read EDID
    Read the EDID of the specified device into the caller's buffer
    The device is specified by the DWORD which is a bit map of up to 8 CRT's, 8 DFP's, and 8 TV's.
*/
RM_STATUS edidReadDevEDID(PHWINFO pDev, U032 device, U008 *pEdid)
{
    RM_STATUS    status = RM_ERROR;
#ifndef IKOS    // This is just too painfully slow
    int	    i,j;
    U008    block_ID;
    U032    i2cPortID, Head, dispType;
	U008 	dispAddr;



    status = dacGetDisplayInfo(pDev, device, &Head, &dispType, 0, 0);

    if (status != RM_OK)
    {
        return status;
    }

    dispType = edidTranslateDisplayType(dispType);

    if (dispType == DISPLAY_TYPE_NONE)
    {
        status = RM_ERROR;
        return status;
    }
    //
    // Look for EDID overrides for mobile operation
    //
    if (dispType == DISPLAY_TYPE_FLAT_PANEL && pDev->Power.MobileOperation)
    {
        status = edidConstructMobileInfo(pDev, Head, pEdid);
        if (status == RM_OK)
            return RM_OK;
    }

	// See if device supports DDC and which address it uses
    status = IsMonitorDDC(pDev, Head, dispType, &dispAddr);
    if (status != RM_OK)
    {
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
   	    // Monitor is not DDC compliant.
        goto done;
    }

    if (IsNV15(pDev) && (device == 0x2))        // CRT on DVI-I connector
        i2cPortID = getI2CPort(pDev, 1, dispType);
    else
        i2cPortID = getI2CPort(pDev, Head, dispType);

	for (i=0; i<DDC_RETRIES; i++)
	{
        block_ID = 0;
        // send a write command and read back a block 
        // NOTE: the device address is shifted up in our function (50->A0)
        status = i2cRead(pDev, Head, i2cPortID, dispAddr, 1, &block_ID, 128, pEdid);
        if (status == RM_OK)
        {
            // Check which version of the header. If it was version 2, we need to read
            // another 128 bytes.
            if (pEdid[0] == 0 && pEdid[1] == 0xff &&
                pEdid[EDID_V1_VERSION_NUMBER_INDEX] == 0x1)
            {
            	if (EDIDCheckSumOk(pDev, Head, pEdid, 128))
            	    goto done;
            }
            else if ((pEdid[0] >> 4) == 2)
            {
                // This is a version 2 header. Read the next 128 byte block.
                block_ID = 128;
                // send a write command and read the next block 
                // NOTE: the device address is shifted up in our function (50->A0)
                status = i2cRead(pDev, Head, i2cPortID, dispAddr, 1, &block_ID, 128, 
                                 &(pEdid[128]));
                if (status == RM_OK)
	            	if (EDIDCheckSumOk(pDev, Head, pEdid, 256))
	            	    goto done;
            }
    	}
        // if we failed, try to reset the slave
        for (j=0; j< 10; j++) 
        {
            i2cStart(pDev, Head, i2cPortID);
            tmrDelay(pDev, 10000);
            i2cStop(pDev, Head, i2cPortID);
            tmrDelay(pDev, 10000);
        }


    } // retry

	// if we fall out of the retry loop, then its an error
	status = RM_ERROR;
	
done:
	if (status == RM_OK)
	    return RM_OK;

    // one last chance to get an EDID
    status = getDefaultEDIDFromBIOS(pDev, Head, dispType);
#endif // defined IKOS

    return status;
}


//****************************************************************************************
/*	Read EDID
	dispType is the display we want to read, not necessarily the current device.
    This will alwasy return RM_OK, since we'll get the BIOS default EDID if none if found,
    UNLESS this if for mobile?
*/
RM_STATUS EDIDRead(PHWINFO pDev, U032 Head, U032 dispType)
{
    RM_STATUS    status = RM_ERROR;
#ifndef IKOS    // This is just too painfully slow
    int	    i,j;
    U008    block_ID;
    U032    i2cPortId;
	U008 	dispAddr;
    BOOL    NV15Retry = FALSE;

    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);  // Connect the head to the I2C pins
    }
    
    //
    // Look for EDID overrides for mobile operation
    //
    if ((dispType == DISPLAY_TYPE_FLAT_PANEL) && pDev->Power.MobileOperation)
    {
        status = edidConstructMobileInfo(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID);
        if (status == RM_OK)
            return RM_OK;
    }

	// See if device supports DDC and which address it uses
    status = IsMonitorDDC(pDev, Head, dispType, &dispAddr);
    if (status != RM_OK)
    {
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
   	    // Monitor is not DDC compliant.
        goto done;
    }

    i2cPortId = getI2CPort(pDev, Head, dispType);

EDIDRead_NV15_Retry:
	for (i=0; i<DDC_RETRIES; i++)
	{
        block_ID = 0;
        // send a write command and read back a block 
        // NOTE: the device address is shifted up in our function (50->A0)
        status = i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &block_ID, 128, pDev->Dac.CrtcInfo[Head].EDID);
        if (status == RM_OK)
        {
            // Check which version of the header. If it was version 2, we need to read
            // another 128 bytes.
            if (pDev->Dac.CrtcInfo[Head].EDID[0] == 0 && pDev->Dac.CrtcInfo[Head].EDID[1] == 0xff &&
                pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VERSION_NUMBER_INDEX] == 0x1)
            {
            	if (EDIDCheckSumOk(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID, 128))
            	    goto done;
            }
            else if ((pDev->Dac.CrtcInfo[Head].EDID[0] >> 4) == 2)
            {
                // This is a version 2 header. Read the next 128 byte block.
                block_ID = 128;
                // send a write command and read the next block 
                // NOTE: the device address is shifted up in our function (50->A0)
                status = i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &block_ID, 128, 
                                 &(pDev->Dac.CrtcInfo[Head].EDID[128]));
                if (status == RM_OK)
	            	if (EDIDCheckSumOk(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID, 256))
	            	    goto done;
            }
    	}
        // if we failed, try to reset the slave (may be hung up and not responding)
        for (j=0; j< 20; j++) 
        {
            i2cStart(pDev, Head, i2cPortId);
            tmrDelay(pDev, 20000);      // 20 us
            i2cStop(pDev, Head, i2cPortId);
            tmrDelay(pDev, 20000);
            // one last desparate measure 
            StopDDC1(pDev, Head, dispType);	// stop the CRT from driving the bus
            tmrDelay(pDev, 2000000);    // 2 ms
        }


    } // retry

	// if we fall out of the retry loop, then its an error
	status = RM_ERROR;
	
done:
    if ((status != RM_OK) && IsNV15(pDev) && (dispType == DISPLAY_TYPE_MONITOR) && !NV15Retry) {
        NV15Retry = TRUE;
        i2cPortId = getI2CPort(pDev, 1, dispType);
        goto EDIDRead_NV15_Retry;
    }

	if (status == RM_OK)
	    return RM_OK;

    // one last chance to get an EDID
    status = getDefaultEDIDFromBIOS(pDev, Head, dispType);
#endif // defined IKOS

    return status;
}

//****************************************************************************************
/*	See if a device has an EDID 
	dispType is the display we want to read, not necessarily the current device.
*/
RM_STATUS EDIDDetect(PHWINFO pDev, U032 Head, U032 dispType)
{
#ifndef IKOS    // This is just too painfully slow
    int	    i;
    RM_STATUS    status;
    U008    block_ID, lock;
    U032    i2cPortId;
    U008    dispAddr;
    U008    EdidBuffer[128];
    BOOL    NV15Retry = FALSE;

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);
    
    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);  // Connect the head to the I2C pins
    }
	// See if device supports DDC and which address it uses
    if (IsMonitorDDC(pDev, Head, dispType, &dispAddr) != RM_OK)
    {
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
   	    // Monitor is not DDC compliant.
        status = RM_ERROR;
        goto done;
    }

    i2cPortId = getI2CPort(pDev, Head, dispType);

EDIDDetect_NV15_Retry:
	for (i=0; i<DDC_RETRIES; i++)
	{
        block_ID = 0;
        // send a write command and read back a block (at least 0x50 bytes to get version 2 display technology byte).
        // NOTE: the device address is shifted up in our function (50->A0)
        status = i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &block_ID, 0x50, EdidBuffer);
        if (status == RM_OK)
        {
            // Check which version of the header. If it was version 2,
            if (EdidBuffer[0] == 0 && EdidBuffer[1] == 0xff &&
                EdidBuffer[EDID_V1_VERSION_NUMBER_INDEX] == 0x1)
            {
                // This is version 1 header, get video input definition
                if (EdidBuffer[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7))     // digital device?
                {
                    if (dispType == DISPLAY_TYPE_FLAT_PANEL) 
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
                else
                {
                    if (dispType == DISPLAY_TYPE_MONITOR)                   // we're looking for analog
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
            }
            else if ((EdidBuffer[0] >> 4) == 2)
            {
                // This is a version 2 header.
                if ((EdidBuffer[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) == 0) // analog device?
                {
                    if (dispType == DISPLAY_TYPE_MONITOR)                   // we're looking for analog
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
                else
                {
                    if (dispType == DISPLAY_TYPE_FLAT_PANEL) 
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
            }
            else
            {
                // Unknown edid header.
                status = RM_ERROR;
            }
    	} // Successfully read the first 128 byte block.
    } // retry
done:    
    if ((status != RM_OK) && IsNV15(pDev) && (dispType == DISPLAY_TYPE_MONITOR) && !NV15Retry) {
        NV15Retry = TRUE;
        i2cPortId = getI2CPort(pDev, 1, dispType);
        goto EDIDDetect_NV15_Retry;
    }


    RestoreLock(pDev, Head, lock);

    return status;
#else   // defined IKOS
    return RM_ERROR;
#endif  // IKOS
}

static RM_STATUS getDefaultEDIDFromBIOS(
    PHWINFO pDev,
    U032    Head,
    U032    dispType
)
{
#ifdef MACOS
    U032 edid_len;               //012345
    char edid_registry_name[16] = "EDID,x";

    // on the Mac, a fallback EDID could be in the registry (published by fcode)
    // Check here before falling back to the BIOS image
    // If it is in the registry
    // XXX this could be generic, I guess.
    
    edid_len = sizeof(pDev->Dac.CrtcInfo[Head].EDID);
    edid_registry_name[5] = 'A' + Head;     // "EDID,A" or "EDID,B"
    
	if ((RM_OK == osReadRegistryBinary(pDev, "", edid_registry_name, pDev->Dac.CrtcInfo[Head].EDID, &edid_len)))
	{
    	if (EDIDCheckSumOk(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID, edid_len))
        {
        	// Ok, it looks good so far, but is it the right "type" (fp or crt)
        	// Can't be too careful, you know....
        	BOOL analog_display;
        	BOOL expected_analog;

        	analog_display  = edidIsAnalogDisplay(pDev, Head);
        	expected_analog = dispType == DISPLAY_TYPE_MONITOR;
        	
        	if (analog_display != expected_analog)
        	{
	            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: found 'canned' EDID; but wrong type\n");
        	    return RM_ERROR;
        	}
        	
	        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: using 'canned' EDID from registry\n");
    	    return RM_OK;
    	}
	}
#endif //  MACOS

    return RM_ERROR;
}


//****************************************************************************************
/*	Read VDIF
	VDIF follows after last EDID block, so to read a VDIF block we need to get the
	number of EDID blocks (*128) and add the VDIF block (*64)
*/
RM_STATUS ReadVDIF(PHWINFO pDev, U032 Head, U032 dispType, U008 *buffer, U008 device, U008 address)
{
    int     i;
    RM_STATUS  status;
    U008    Adr;
    U032    i2cPortId;

// FILL IN THIS !!!

    // get number of EDID blocks

    // calc VDIF block address

    // read VDIF
    i2cPortId = getI2CPort(pDev, Head, dispType);
    status = RM_OK;       /* macosX's version of gcc thinks 'status' may not be init before use */
    for (i=0; i<DDC_RETRIES; i++)
    {
        // send a write command and read back a block (NOTE: the device address is shifted up in our function, so 50->A0)
        status = i2cRead(pDev, Head, i2cPortId, 0x50, 0, &Adr, 128, buffer);
        if (status == RM_OK)
            break;		
    }

    return (status);
}

RM_STATUS ReadAnyEdidBlock(PHWINFO pDev, U032 Head, U032 dispType, U016 ByteAddress, U008 *VesaDataBuffer)
{
    U008 dispAddr;
    RM_STATUS status;
    U032 i2cPortId;
    U032 retry_count;
    U008 RealByteAddress;
    U008 RealSegmentAddress;
    U008 LockStat;

    LockStat=UnlockCRTC(pDev, Head);

    //Connect the head to the I2C pins
    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);
    }
    
    // See if device supports DDC and which address it uses
    status = IsMonitorDDC(pDev, Head, dispType, &dispAddr);
    
    if (status != RM_OK)
    {
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
   	    // Monitor is not DDC compliant.
        goto done;
    }
    
    if(ByteAddress>128)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Byte Address greater than 128 specified ", Head);
        
        status=RM_ERROR;
        
        goto done;
    }
    
    //the true byte address cannot exceed 255, in the future I will implement the segment access code
    RealByteAddress=(U008)(ByteAddress%256);
    
    //calculate the segment address
    RealSegmentAddress=(U008)(ByteAddress/256);
    
    //be sure the segment does not exceed 0x7f (EDDCv1.pdf Version 1 of the Enhanced DDC spec for retrieving > 256 EDIDs)
    RealSegmentAddress=(U008)((RealSegmentAddress>0x7f)?0:RealSegmentAddress);
    
    i2cPortId = getI2CPort(pDev, Head, dispType);
   
    retry_count=0;
    
    //do read
    do
    {
        //if segment is not zero, set the segment here (segment set is not currently implemented)
        
        /*
        //note, at this rev, we can't actually get the next chunk. Most of the infrastructure is here though
        status=i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &RealByteAddress, 128,VesaDataBuffer);
        */
        
        status=i2cRead_EDDC(pDev, Head, i2cPortId, RealSegmentAddress, dispAddr, RealByteAddress, 128, VesaDataBuffer);

        
    }while((++retry_count!=DDC_RETRIES)&&(status!=RM_OK));
    
    //we do not verify checksum here, as if the user is retrieving a V2 or V3 EDID, the checksum may not fall at 127
    
done:
    RestoreLock(pDev,Head,LockStat);

    return status;
}

// Checks to see if the EDID is present in the pDev and if it matches a valid version.
// The version and revision is returned, as well as a pointer to the requested EDID buffer.
static BOOL EDIDIsValid
(
    PHWINFO pDev,
    U008    **edidPtr,
    U032    *version,
    U032    *revision,
    U032    Head
)
{
    U008 *edid;


    edid = pDev->Dac.CrtcInfo[Head].EDID;
    // Check the version of the edid header.
	if (!(edid[0] == 0 && edid[1] == 0xff))
	{
		// this is not version 1 edid header
		// check if it is version 2 header.
        // Bits 7-4 of byte 0 is the version and bits 3-0 of byte 0 is the revision
		if (((edid[0] & 0xf0) >> 4) == 2)
		{
            *version = 2;
            *revision = edid[0] & 0x0f;
            *edidPtr = edid;
            return TRUE;
		}

		// Unknown edid header.
        return FALSE;
	}

    // Check for version 1 edid header.
    if (edid[EDID_V1_VERSION_NUMBER_INDEX] == 1)
    {
        *version = 1;
        *revision = edid[EDID_V1_REVISION_NUMBER_INDEX];
        *edidPtr = edid;
        return TRUE;
    }

    // Unknown edid header.
    return FALSE;

}

// Checks to see if the EDID is present in the pDev and if it matches a valid version.
// The version and revision is returned, as well as a pointer to the requested EDID buffer.
BOOL edidLogicalEDIDIsValid
(
    U008    **edidPtr,
    U032    *version,
    U032    *revision
)
{
    U008 *edid;


    edid = *edidPtr;
    // Check the version of the edid header.
	if (!(edid[0] == 0 && edid[1] == 0xff))
	{
		// this is not version 1 edid header
		// check if it is version 2 header.
        // Bits 7-4 of byte 0 is the version and bits 3-0 of byte 0 is the revision
		if (((edid[0] & 0xf0) >> 4) == 2)
		{
            *version = 2;
            *revision = edid[0] & 0x0f;
            *edidPtr = edid;
            return TRUE;
		}

		// Unknown edid header.
        return FALSE;
	}

    // Check for version 1 edid header.
    if (edid[EDID_V1_VERSION_NUMBER_INDEX] == 1)
    {
        *version = 1;
        *revision = edid[EDID_V1_REVISION_NUMBER_INDEX];
        *edidPtr = edid;
        return TRUE;
    }

    // Unknown edid header.
    return FALSE;

}

static RM_STATUS EDIDV1Copy
(
    PHWINFO pDev,
    U008    *edid,
    U008    *buffer,
    U032    *bufLen
)
{
    // version 1
    if (*bufLen < EDID_V1_SIZE)
    {
        // There is not enough space in the buffer.
        *bufLen = 0;
        return RM_ERROR;
    }

    // There is enough space in the buffer.
    *bufLen = EDID_V1_SIZE;

	osMemCopy((U008*) buffer, (U008*) edid, *bufLen);
    return RM_OK;
}

static RM_STATUS EDIDV2Copy
(
    PHWINFO pDev,
    U008    *edid,
    U008    *buffer,
    U032    *bufLen
)
{
    // Version 2
    if (*bufLen < EDID_V2_SIZE)
    {
        // There is not enough space in the buffer.
        *bufLen = 0;
        return RM_ERROR;
    }

    // There is enough space in the buffer.
    *bufLen = EDID_V2_SIZE;
    
    osMemCopy((U008*) buffer, (U008*) edid, *bufLen);
    return RM_OK;
}

// This function copies the edid from the pDev into the buffer passed.
// Currently only version 1 edid header is supported.
RM_STATUS EDIDCopy
(
    PHWINFO pDev,
    U008    *buffer,
    U032    *bufLen,
    U032    Head
)
{
    U032 edidVersion, edidRevision;
    U008 *edid;

    if (!EDIDIsValid(pDev, &edid, &edidVersion, &edidRevision, Head)) // verify EDID and get a pointer to it
    {
        // edid not valid
        *bufLen = 0;
        return RM_ERROR;
    }

    if (edidVersion == 1)
    {
        return EDIDV1Copy (pDev, edid, buffer, bufLen);
    }
    else if (edidVersion == 2)
    {
        return EDIDV2Copy (pDev, edid, buffer, bufLen);
    }

    // Unknown edid header.
    *bufLen = 0;
    return RM_ERROR;
} // end of EDIDCopy

#if 0 // no one calling this, so turn it off 
static RM_STATUS EDIDV1GetMaxRefreshRate
(
    PHWINFO pDev,
    U008   *edid,
    U032    hRes,
    U032    vRes,
    U032   *maxRefreshRate
)
{
    U032      i, j, tmpHRes, tmpVRes = ~0, tmpRefresh;

    *maxRefreshRate = 0;
    // Get the max from the established timing section
    switch (hRes)
    {
        case 720:
            if (vRes == 400)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x40)
                {
                    // Supports 720x400 @ 88Hz.
                    *maxRefreshRate = 88;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x80)
                {
                    // supports 720x400 @ 70Hz
                    *maxRefreshRate = 70;
                }

            }
            break;
        case 640:
            if (vRes == 480)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x04)
                {
                    // Supports 640x480 @ 75Hz.
                    *maxRefreshRate = 75;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x08)
                {
                    // supports 640x480 @ 72Hz
                    *maxRefreshRate = 72;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x10)
                {
                    // supports 640x480 @ 67Hz
                    *maxRefreshRate = 67;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x20)
                {
                    // supports 640x480 @ 60Hz
                    *maxRefreshRate = 60;
                }
            }
            break;
        case 800:
            if (vRes == 600)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x40)
                {
                    // Supports 800x600 @ 75Hz.
                    *maxRefreshRate = 75;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x80)
                {
                    // supports 800x600 @ 72Hz
                    *maxRefreshRate = 72;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x01)
                {
                    // supports 800x600 @ 60Hz
                    *maxRefreshRate = 60;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x02)
                {
                    // supports 800x600 @ 56Hz
                    *maxRefreshRate = 56;
                }
            }
            break;
        case 832:
            if (vRes == 624)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x20)
                {
                    // Supports 832x624 @ 75Hz.
                    *maxRefreshRate = 75;
                }
            }
            break;
        case 1024:
            if (vRes == 768)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x10)
                {
                    // Supports 1024x768 @ 87Hz
                    *maxRefreshRate = 87;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x02)
                {
                    // supports 1024x768 @ 75Hz
                    *maxRefreshRate = 75;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x04)
                {
                    // supports 1024x768 @ 70Hz
                    *maxRefreshRate = 70;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x08)
                {
                    // supports 1024x768 @ 60Hz
                    *maxRefreshRate = 60;
                }
            }
            break;
        case 1280:
            if (vRes == 1024)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x01)
                {
                    // Supports 1280x1024 @ 75Hz
                    *maxRefreshRate = 75;
                }
            }
            break;
        case 1152:
            if (vRes == 870)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_3_INDEX] & 0x80)
                {
                    // Supports 1152x870 @ 75Hz 
                    *maxRefreshRate = 75;
                }
            }
            break;
        default:
            break;
    } // switch on hRes


    // Now check the standard timings to see if there is a higher refresh rate specified.
   	for (i = 0; i < 8; i++)
	{
		if (edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i * 2)] != 0x01)
		{
			// there is a standard timing specification.
			tmpHRes = (edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i*2)] + 31) * 8;
			tmpRefresh = (edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i*2) + 1] & 0x3f) + 60;
			switch ((edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i*2) + 1] & 0xc0) >> 6)
			{
			case 0x0:
				// aspect ratio 1:1
				tmpVRes = tmpHRes;
				break;
			case 0x1:
				// aspect ratio 4:3
				tmpVRes = (tmpHRes * 3) / 4;
				break;
			case 0x2:
				// aspect ratio 5:4
				tmpVRes = (tmpHRes * 4) / 5;
				break;
			case 0x3:
				// aspect ratio 16:9
				tmpVRes = (tmpHRes * 9) / 16;
				break;
			}

            // Check if this standard timing matches the resolution we want.
            if (tmpHRes == hRes && tmpVRes == vRes)
            {
                // Resolution matches. 
                // If this refresh rate is > than the one found in established timings, use it.
                if (tmpRefresh > *maxRefreshRate)
                {
                    *maxRefreshRate = tmpRefresh;
                }
            }
		} // A valid standard timing spec
	} // iterate over all 8 standard timings

    // Now check the detailed timing specification for a macting resolution.
	for (i = 0; i < 4; i++)
	{
		int startIndex = EDID_V1_DETAILED_TIMINGS_START_INDEX + (i * EDID_V1_DETAILED_TIMINGS_SIZE);
		if (edid[startIndex] == 0 && edid[startIndex + 1] == 0)
		{
			// This is a Monitor descriptor instead of a detailed timing descriptor.
			switch (edid[startIndex + 3])
			{
                case 0xFA:
                    // Descriptor contains 6 additional standard timing identifications
                    for (j = 0; j < 6; j++)
                    {
                        if (edid[startIndex + 5 + (j * 2)] != 0x01)
                        {
                            // there is a standard timing specification.
                            tmpHRes = (edid[startIndex + 5 + (j*2)] + 31) * 8;
                            tmpRefresh = (edid[startIndex + 5 + (j*2) + 1] & 0x3f) + 60;
                            switch ((edid[startIndex + 5 + (j*2) + 1] & 0xc0) >> 6)
                            {
                            case 0x0:
                                // aspect ratio 1:1
                                tmpVRes = tmpHRes;
                                break;
                            case 0x1:
                                // aspect ratio 4:3
                                tmpVRes = (tmpHRes * 3) / 4;
                                break;
                            case 0x2:
                                // aspect ratio 5:4
                                tmpVRes = (tmpHRes * 4) / 5;
                                break;
                            case 0x3:
                                // aspect ratio 16:9
                                tmpVRes = (tmpHRes * 9) / 16;
                                break;
                            } // switch on aspect ratio

                            // Check if this standard timing matches the resolution we want.
                            if (tmpHRes == hRes && tmpVRes == vRes)
                            {
                                // Resolution matches. 
                                // If this refresh rate is > than the one found in established timings, use it.
                                if (tmpRefresh > *maxRefreshRate)
                                {
                                    *maxRefreshRate = tmpRefresh;
                                }
                            }
                        } // a valid standard timing spec
                    } // iterate over the 6 additional standard timings
                    break;
                default:
                    break;
			}
		} // monitor descriptor.
		else
		{
			// This is a detailed timing descriptor.
            // The detailed timing specification does not include the refresh rate.
			U032 pixelClock;
			U032 hActive, vActive, hBlank, vBlank;
			U032 hTotal, vTotal;


			hActive = edid[startIndex + 2] | ((edid[startIndex + 4] & 0xf0) << 4);
			vActive = edid[startIndex + 5] | ((edid[startIndex + 7] & 0xf0) << 4);
            if (hActive == hRes && vActive == vRes)
            {
                // Resolution matches the detailed spec.
                // Get the rest of the detailed timing info needed to calculate the refresh rate.
                pixelClock = edid[startIndex] | (edid[startIndex + 1] << 8);
                hBlank  = edid[startIndex + 3] | ((edid[startIndex + 4] & 0x0f) << 8);
                vBlank  = edid[startIndex + 6] | ((edid[startIndex + 7] & 0x0f) << 8);

                // Horizontal Total (hActive + hBlank) gives # of pixels / line
                // Vertical total (vActive + vBlank) gives # of lines / frame
                // so HT * VT = total # pixels per frame.
                // Pixel clock is # pixels drawn / sec
                // so pixelClock / (HT * VT) gives the refresh rate (frames / sec).
                hTotal = hActive + hBlank;
                vTotal = vActive + vBlank;
                pixelClock = pixelClock * 10000;
                tmpRefresh = pixelClock / (hTotal * vTotal);

                if (tmpRefresh > *maxRefreshRate)
                {
                    *maxRefreshRate = tmpRefresh;
                }
            } // resolution matches the detailed spec
		} // This is a detailed timing spec
	} // parse detailed section

    return RM_OK;
}

static RM_STATUS EDIDV2GetMaxRefreshRate
(
    PHWINFO pDev,
    U008   *edid,
    U032    hRes,
    U032    vRes,
    U032   *maxRefreshRate
)
{
    U032 lumTabSize, numLumTables;
    U032 numFreqRanges, numDetailedRanges, numTimingCodes, numDetailedTimings;
    U032 detailedTimingIndex, timingCodesIndex;
    U008 timingMap1, timingMap2;
    U032 index, i;

    // We need to look in the 4-byte timing codes section and the detailed timing section for
    // the given resolution.

    // The way the 127 byte detailed information is used is given by reading bytes 0x7e and 0x7f.
    // The size and the order of the 127 byte timing section that start at byte 0x80 is:
    // x*A + 8*B + 27*c + 4*D + 18*E where
    // A = number of luminance tables (0 or 1), (given by byte 0x7e bit 5)
    // x = size of the luminance table (given by the first byte of the table itself)
    // B = number of frequency rages listed (0-7), (given by bits 4-2 of byte 0x7e)
    // C = number of detailed rage limits (0-3), (given by (bits 1-0 of byte 0x7e)
    // D = number of timing codes (0-31), (given by bits 7-3 of byte 0x7f)
    // E = number of detailed timing descriptions (0-7) (given by bits 2-0 of byte 0x7f)
    timingMap1 = edid[EDID_V2_TIMING_MAP1_INDEX];
    timingMap2 = edid[EDID_V2_TIMING_MAP2_INDEX];
    numLumTables       = (timingMap1 & 0x20) >> 5; // Bit 5
    numFreqRanges      = (timingMap1 & 0x1C) >> 2; // Bits 4-2
    numDetailedRanges  = (timingMap1 & 0x03);      // Bits 1-0
    numTimingCodes     = (timingMap2 & 0xf8) >> 3; // Bits 7-3
    numDetailedTimings = (timingMap2 & 0x07);      // Bits 2-0
    if (numLumTables != 0)
    {
        // Calculate the size of the lum table by reading byte 0x80
        U032 numLumValues;

        numLumValues = edid[EDID_V2_TIMING_SECTION_START_INDEX] & 0x1f; // bits 4-0
        if (edid[EDID_V2_TIMING_SECTION_START_INDEX] & 0x80)
        {
            // size of lum table is ((3 * numLumValues) + 1) bytes
            lumTabSize = 3 * numLumValues + 1;
        }
        else
        {
            // size of lum table is (numLumValues + 1) bytes
            lumTabSize = numLumValues + 1;
        }
    }
    else
        lumTabSize = 0;

    timingCodesIndex = EDID_V2_TIMING_SECTION_START_INDEX 
                       + lumTabSize 
                       + (8 * numFreqRanges)
                       + (27 * numDetailedRanges);
    detailedTimingIndex = timingCodesIndex + (8 * numTimingCodes);

    *maxRefreshRate = 0;

    {
        // Look in the timing codes section.
        U032 hActive;
        U032 aspectRatio;
        U032 vActive;
        for (i = 0; i < numTimingCodes; i++)
        {
            index = timingCodesIndex + (4 * i);
            hActive = (edid[index] * 16) + 256;
            aspectRatio = edid[index + 2];
            // Aspect ratio is stored in terms of N:100.
			// This is not very useful because we don't get the standard vertical values.
			// So we will use the standard aspect ratios whenever we can.
			switch (aspectRatio)
			{
			case 133:
				// 4:3
				vActive = (hActive * 3) / 4;
				break;
			case 125:
				// 5:4
				vActive = (hActive * 4) / 5;
				break;
			case 177:
				// 16:9
				vActive = (hActive * 9) / 16;
				break;
			default:
                vActive = (hActive * 100) / aspectRatio;
				break;
			}
            if (hActive == hRes && vActive == vRes)
            {
                // This is the needed resolution.
                if (edid[index + 3] > *maxRefreshRate)
                {
                    *maxRefreshRate = edid[index + 3];
                }
            } // resolution matches
        } // loop over all the timing codes
    } // look in timing codes

    {
        // look in the detailed timing section
        // The detailed timing specification does not include the refresh rate.
        U032 pixelClock;
        U032 hActive, vActive, hBlank, vBlank;
        U032 hTotal, vTotal;
        U032 tmpRefresh;

        for (i = 0; i < numDetailedTimings; i++)
        {
            index = detailedTimingIndex + (18 * i);
            hActive = edid[index + 2] | ((edid[index + 4] & 0xf0) << 4);
            vActive = edid[index + 5] | ((edid[index + 7] & 0xf0) << 4);
            if (hActive == hRes && vActive == vRes)
            {
                // Resolution matches the detailed spec.
                // Get the rest of the detailed timing info needed to calculate the refresh rate.
                pixelClock = edid[index] | (edid[index + 1] << 8);
                hBlank  = edid[index + 3] | ((edid[index + 4] & 0x0f) << 8);
                vBlank  = edid[index + 6] | ((edid[index + 7] & 0x0f) << 8);

                // Horizontal Total (hActive + hBlank) gives # of pixels / line
                // Vertical total (vActive + vBlank) gives # of lines / frame
                // so HT * VT = total # pixels per frame.
                // Pixel clock is # pixels drawn / sec
                // so pixelClock / (HT * VT) gives the refresh rate (frames / sec).
                hTotal = hActive + hBlank;
                vTotal = vActive + vBlank;
                pixelClock = pixelClock * 10000;
                tmpRefresh = pixelClock / (hTotal * vTotal);

                if (tmpRefresh > *maxRefreshRate)
                {
                    *maxRefreshRate = tmpRefresh;
                }
            } // resolution matches the detailed spec
        } // loop over all the detailed timing specs
    } // look in detailed timing section

    return RM_OK;
}
#endif  // #if 0; no one calling this puppy


// EDID Version 1.3
// Super set of 1.2, allows range limits descriptor to define coeficients for secondary GTF curve,
// and mandates a certain set of monitor descriptors.
RM_STATUS ParseEDID13(PHWINFO pDev, U032 Head)
{
	return ParseEDID11(pDev, Head);	// we can probably treat it the same as rev 1.1
}

// EDID Version 1.2
RM_STATUS ParseEDID12(PHWINFO pDev, U032 Head)
{
	return ParseEDID11(pDev, Head);	// we can probably treat it the same as rev 1.1
}

//	Parse a detailed timing block in the current EDID
//	The EDID has been saved in the global device data structure (nvInfo).
//	When native mode is requested, it is necessary to find the correct detailed timing;
//  otherwise fpParseEDID will be used to get timing info.
U032 edidParseDetailedTimingBlock(PHWINFO pDev, U008 block, PDACFPTIMING fpTim, U032 Head)
{
	switch (pDev->Dac.CrtcInfo[Head].EdidVersion)
	{
		case EDID_VERSION_10:
		case EDID_VERSION_11:
		case EDID_VERSION_12:
		case EDID_VERSION_13:
			return edidParseDetailed1(pDev, block, fpTim, Head);
		case EDID_VERSION_20:
			return edidParseDetailed2(pDev, block, fpTim, Head);
	}

	return(0);
}

//	Parse a specific detailed timing block for EDID version 1.x
//  Detailed timings are at a fixed offset from the start of the buffer.
U032 edidParseDetailed1(PHWINFO pDev, U008 block, PDACFPTIMING fpTim, U032 Head)
{
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW, offset;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags;
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;

		// detailed timing block is 18 (0x12) bytes starting at offset 0x36.
		pClk = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block];
		pClk |= (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block + 1])<<8;
		if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
		{
			// Seems valid, get info
			offset = EDID_V1_DETAILED_TIMINGS_START_INDEX + (18 * block);
			HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
			HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
			HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
			VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
			VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
			VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
			HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
			HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
			VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
			SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
			Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

			// Get timing into useful format
			HRes = HActive1 | (HActive2 & 0xf0)<<4;
			VRes = VActive1 | (VActive2 & 0xf0)<<4;
			HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
			VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
			HTotal = HRes + HBlank;
			VTotal = VRes + VBlank;
			HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
			HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
			VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<2;
			VSyncPulse = (VSyncOff1 & 0xf) | (SyncOvf & 0x30)<<4;

			// Return this resolution
			fpTim->PixClk = pClk;
			fpTim->HActive = HRes;
 			fpTim->HDispEnd = HRes - 1;
			fpTim->HValidEnd = HRes - 1;
	 		fpTim->HSyncStart = HSyncOffset + fpTim->HDispEnd;
 			fpTim->HSyncEnd = HSyncPulse + fpTim->HSyncStart;
 			fpTim->HValidStart = 0;
	 		fpTim->HTotal = HTotal;
				
	 		fpTim->VActive = VRes;
 			fpTim->VDispEnd = VRes - 1;
 			fpTim->VValidEnd = VRes - 1;
	 		fpTim->VSyncStart =  VSyncOffset + fpTim->VDispEnd;
	 		fpTim->VSyncEnd = VSyncPulse + fpTim->VSyncStart;
 			fpTim->VValidStart = 0;
 			fpTim->VTotal = VTotal;
			fpTim->Flags = Flags;	// includes sync polarities
			return TRUE;
		}
		return FALSE;
} // edidParseDetailedTimingBlock

// Parse detailed timings for EDID Version 2.x
// This gets a specific timing block.
// For version 2, we have to parse from the start to find the location of the block.
U032 edidParseDetailed2(PHWINFO pDev, U008 block, PDACFPTIMING fpTim, U032 Head)
{
U008	map1, map2, index, lum, rangeLimits, detailedRangeLimits;
U008	detailedTimings, timingCodes, timingCode[4];
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW, offset;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags, i;
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;

	map1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX];
	map2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX+1];
	index =  EDID_V2_TIMING_SECTION_START_INDEX;
	// if there is a lum table, bump index beyond
	if (map1 & EDID_V2_LUM_TABLE_EXIST)
	{
		// 1st byte in timing section gives # of bytes in lum table
		lum = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_SECTION_START_INDEX];
		if (lum & TRIPLE_LUM_ENTRIES)
			index += (lum & NUM_LUM_ENTRIES*3) + 1;
		else
			index += (lum & NUM_LUM_ENTRIES) + 1;
	}
	// if there are timing range limits, bump index
	if ((rangeLimits = (map1 & EDID_V2_FREQ_RANGES)>>EDID_V2_FREQ_RANGE_SHIFT))
		index += rangeLimits * 8;
	// if there are detailed range limits, bump index
	if ((detailedRangeLimits = map1 & EDID_V2_DETAILED_RANGE_LIMITS))
		index += detailedRangeLimits * 27;
	// if there are timing codes, save them
	if ((timingCodes = (map2 & EDID_V2_TIMING_CODES)>>EDID_V2_TIMING_CODES_SHIFT))
		for (i=0; i!=timingCodes; i++)
		{
			timingCode[i] = pDev->Dac.CrtcInfo[Head].EDID[index];
			timingCode[i+1] = pDev->Dac.CrtcInfo[Head].EDID[index+1];
			timingCode[i+2] = pDev->Dac.CrtcInfo[Head].EDID[index+2];
			timingCode[i+3] = pDev->Dac.CrtcInfo[Head].EDID[index+3];
			index += 4;
		}
	// now index points to the detailed timings (if present)
	if ((detailedTimings = (map2 & EDID_V2_DETAILED_TIMINGS)))
	{
		// detailed timing block is 18 (0x12) bytes starting at offset 0x36.
		pClk = pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block];
		pClk |= (pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block + 1])<<8;
		if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
		{
			// Seems valid, get info
			offset = index + 18 * block;
			HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
			HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
			HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
			VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
			VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
			VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
			HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
			HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
			VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
			SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
			Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

			// Get timing into useful format
			HRes = HActive1 | (HActive2 & 0xf0)<<4;
			VRes = VActive1 | (VActive2 & 0xf0)<<4;
			HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
			VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
			HTotal = HRes + HBlank;
			VTotal = VRes + VBlank;
			HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
			HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
			VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<2;
			VSyncPulse = (VSyncOff1 & 0x0f) | (SyncOvf & 0x30)<<4;

			// Return this resolution
			fpTim->PixClk = pClk;
			fpTim->HActive = HRes;
	 		fpTim->HDispEnd = HRes - 1;
			fpTim->HValidEnd = HRes - 1;
	 		fpTim->HSyncStart = HSyncOffset + fpTim->HDispEnd;
	 		fpTim->HSyncEnd = HSyncPulse + fpTim->HSyncStart;
	 		fpTim->HValidStart = 0;
	 		fpTim->HTotal = HTotal;
				
	 		fpTim->VActive = VRes;
	 		fpTim->VDispEnd = VRes - 1;
	 		fpTim->VValidEnd = VRes - 1;
	 		fpTim->VSyncStart =  VSyncOffset + fpTim->VDispEnd;
	 		fpTim->VSyncEnd = VSyncPulse + fpTim->VSyncStart;
	 		fpTim->VValidStart = 0;
	 		fpTim->VTotal = VTotal;

			fpTim->Flags = Flags;
			return RM_OK;
		} // if 
	} // if detailed timings
	// check 4 byte timing codes

	return RM_ERROR;	// not supported yet
}

// EDID Version 2.0 
// Get flat panel timing from 4 byte timing code
// Use VESA GTF timing.
RM_STATUS GetTimingFromCode(U008 code, PDACFPTIMING fpTim)
{
U016	HorizCode;

	// We should be able to determine the mode from the first byte only, UNLESS
	// we start seeing panels with variable refresh rates.
	// byte 1: active pixels/line (pixels - 256)/16. Range = 256-4336.
	// byte 2: arcane info, don't know what it means. See EDID standard.
	// byte 3: aspect ration H:V.
	// byte 4: refresh rate.
	HorizCode = code * 16 + 256;
	fpTim->Flags = 0;	// sync polarities: neg, neg
	switch (HorizCode)
	{
		case 1280:
			// 1280x1024x75;
			fpTim->HActive = 1280;
			fpTim->HDispEnd = 1279;
			fpTim->HValidStart = 0;
			fpTim->HValidEnd = 1279;
			fpTim->HSyncStart = 1280+15;
			fpTim->HSyncEnd = 1280+15+2;
			fpTim->HTotal = 1280+320;
			fpTim->VActive = 1024;
			fpTim->VDispEnd = 1023;
			fpTim->VValidStart = 0;
			fpTim->VValidEnd = 1023;
			fpTim->VSyncStart = 1023+2;
			fpTim->VSyncEnd = 1023+2+24;
			fpTim->VTotal = 1024+40;
			fpTim->PixClk = 10800;	// 108 MHz
			fpTim->Flags = VSYNC_POS | HSYNC_POS;

			break;
		case 1024:
			fpTim->HActive = 1024;
			fpTim->HDispEnd = 1023;
			fpTim->HValidStart = 0;
			fpTim->HValidEnd = 1023;
			fpTim->HSyncStart = 1040;
			fpTim->HSyncEnd = 1089;
			fpTim->HTotal = 1344;
			fpTim->VActive = 768;
			fpTim->VDispEnd = 767;
			fpTim->VValidStart = 0;
			fpTim->VValidEnd = 767;
			fpTim->VSyncStart = 770;
			fpTim->VSyncEnd = 776;
			fpTim->VTotal = 805;
			fpTim->PixClk = 6500;	// 65 MHz
			fpTim->Flags = VSYNC_NEG | HSYNC_NEG;
			break;
		case 800:
			fpTim->HActive =  800;
			fpTim->HDispEnd = 799;
			fpTim->HValidStart = 0;
			fpTim->HValidEnd = 799;
			fpTim->HSyncStart = 799+16;
			fpTim->HSyncEnd =  799+16+24;
			fpTim->HTotal = 800+320;
			fpTim->VActive = 600;
			fpTim->VDispEnd = 599;
			fpTim->VValidStart = 0;
			fpTim->VValidEnd =  599;
			fpTim->VSyncStart = 599+2;
			fpTim->VSyncEnd = 599+2+24;
			fpTim->VTotal = 600+38;
			fpTim->PixClk = 4000;	// 40 MHz
			fpTim->Flags = VSYNC_POS | HSYNC_POS;
			break;
		default:
			return RM_ERROR;
	}
	return RM_OK;
}
							
// EDID Version 1.1
// Return error if no valid resolution found
RM_STATUS ParseEDID11(PHWINFO pDev, U032 Head)
{
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;
U008	est_tim1, est_tim2, block, offset, mode_count;
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags;
U032	est_tim_total, i;

	// Look for multiple resolutions in established timings to see if it supports native mode.
	// meaning the monitor can do the scaling.
 	est_tim1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_ESTABLISHED_TIMING_1_INDEX];
 	est_tim2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_ESTABLISHED_TIMING_2_INDEX];
	est_tim_total = est_tim1 | (est_tim2<<8);
	mode_count = 0;
	pDev->Dac.fpNative = 0;
	for (i=1; i<0x10000; i<<=1)
		if (est_tim_total & i)
			mode_count++;
	if (mode_count > 1)	// if more than 1 mode, monitor supports native mode.
		pDev->Dac.fpNative = 1;

	// We'll check detailed timings first. If none, look for established timings.
	// Search for largest resolution. 
	// NEED TO ADD: There could be extensions in next EDID block, too.
	pDev->Dac.fpHActive = 0;
	mode_count = 0; // check again--multiple detailed timing block also indicates native
	for (block = 0; block <4; block++)
	{
		// detailed timing block is 18 (0x12) bytes starting at offset 0x36.
		pClk = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block];
		pClk |= (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block + 1])<<8;
		if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
		{
			// Seems valid, get info
			offset = EDID_V1_DETAILED_TIMINGS_START_INDEX + (18 * block);
			HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
			HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
			HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
			VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
			VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
			VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
			HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
			HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
			VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
			SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
			Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

			// Get timing into useful format
			HRes = HActive1 | (HActive2 & 0xf0)<<4;
			VRes = VActive1 | (VActive2 & 0xf0)<<4;
			HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
			VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
			HTotal = HRes + HBlank;
			VTotal = VRes + VBlank;
			HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
			HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
			VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<6;
			VSyncPulse = (VSyncOff1 & 0x0f) | (SyncOvf & 0x30)<<4;
#if 0
			// Do some error checking
			if ((HRes + HSyncOffset + HSyncPulse) > (HTotal))
			{
				HSyncPulse &= 0x0f;		// pulse is too wide
				if (HSyncPulse == 0)
					HSyncPulse = 24;		// should work
			}
			if ((VRes + VSyncOffset + VSyncPulse) > (VTotal))
			{
				HSyncPulse &= 0x0f;		// pulse is too wide
				if (VSyncPulse == 0)
					VSyncPulse = 24;		// should work
			}
#endif
			if (HRes > pDev->Dac.fpHActive)	// largest yet?
			{
				// Does this fp support native mode?
				mode_count++;	
				if (mode_count > 1)
					pDev->Dac.fpNative = 1;	
				// Save this resolution as potential maximum.
				pDev->Dac.fpPixClk = pClk;
				pDev->Dac.fpHActive = HRes;
		 		pDev->Dac.fpHDispEnd = HRes - 1;
				pDev->Dac.fpHValidEnd = HRes - 1;
		 		pDev->Dac.fpHSyncStart = HSyncOffset + pDev->Dac.fpHDispEnd;
		 		pDev->Dac.fpHSyncEnd = HSyncPulse + pDev->Dac.fpHSyncStart;
		 		pDev->Dac.fpHValidStart = 0;
		 		pDev->Dac.fpHTotal = HTotal;
					
		 		pDev->Dac.fpVActive = VRes;
		 		pDev->Dac.fpVDispEnd = VRes - 1;
		 		pDev->Dac.fpVValidEnd = VRes - 1;
		 		pDev->Dac.fpVSyncStart =  VSyncOffset + pDev->Dac.fpVDispEnd;
		 		pDev->Dac.fpVSyncEnd = VSyncPulse + pDev->Dac.fpVSyncStart;
		 		pDev->Dac.fpVValidStart = 0;
		 		pDev->Dac.fpVTotal = VTotal;
				pDev->Dac.fpFlags = Flags;

			}
		}
	}
	// save the max resolution this fp supports 
	pDev->Dac.fpHMax = pDev->Dac.fpHActive;
	pDev->Dac.fpVMax = pDev->Dac.fpVActive;

	// If we found a valid detailed timing descriptor, use it.
	if (pDev->Dac.fpHActive)
		return RM_OK;

	// Check the "established timings" and if more than one, pick the highest.
	// There are currently no flat panels supporting refresh other than 60 Hz, so 
	// treat timings with different refresh but the same resolution as the same.
	if(est_tim1 & 0x3c)
 	{
		pDev->Dac.fpHActive = 0;	// no 640 panels. Return error unless we find higher res.
	}
	if(est_tim1 & 0x03)
	{
		// 800x600 60
		pDev->Dac.fpHActive =  800;
		pDev->Dac.fpHDispEnd = 799;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 799;
		pDev->Dac.fpHSyncStart = 799+16;
		pDev->Dac.fpHSyncEnd =  799+16+24;
		pDev->Dac.fpHTotal = 800+320;
		pDev->Dac.fpVActive = 600;
		pDev->Dac.fpVDispEnd = 599;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd =  599;
		pDev->Dac.fpVSyncStart = 599+2;
		pDev->Dac.fpVSyncEnd = 599+2+24;
		pDev->Dac.fpVTotal = 600+38;
		pDev->Dac.fpPixClk = 4000;	// 40 MHz
		pDev->Dac.fpFlags = VSYNC_POS | HSYNC_POS;
	}

	// established timing 2 should take precedence over 1, since it has higher resolutions
	if(est_tim2 & 0xc0)
 	{
		// 800x600 60
		pDev->Dac.fpHActive =  800;
		pDev->Dac.fpHDispEnd = 799;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 799;
		pDev->Dac.fpHSyncStart = 799+16;
		pDev->Dac.fpHSyncEnd =  799+16+24;
		pDev->Dac.fpHTotal = 800+320;
		pDev->Dac.fpVActive = 600;
		pDev->Dac.fpVDispEnd = 599;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd =  599;
		pDev->Dac.fpVSyncStart = 599+2;
		pDev->Dac.fpVSyncEnd = 599+2+24;
		pDev->Dac.fpVTotal = 600+38;
		pDev->Dac.fpPixClk = 4000;	// 40 MHz
		pDev->Dac.fpFlags = VSYNC_POS | HSYNC_POS;
	}
	if(est_tim2 & 0x1e)	// lumping together 60Hz, 70 Hz, 75 Hz, and 87 Hz under the assumption
						// that DFP's which support > 60 Hz (if any) will have detailed timings.
	{
		// 1024x768x60;
		pDev->Dac.fpHActive = 1024;
		pDev->Dac.fpHDispEnd = 1023;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 1023;
		pDev->Dac.fpHSyncStart = 1040;
		pDev->Dac.fpHSyncEnd = 1089;
		pDev->Dac.fpHTotal = 1344;
		pDev->Dac.fpVActive = 768;
		pDev->Dac.fpVDispEnd = 767;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd = 767;
		pDev->Dac.fpVSyncStart = 770;
		pDev->Dac.fpVSyncEnd = 776;
		pDev->Dac.fpVTotal = 805;
		pDev->Dac.fpPixClk = 6500;	// 65 MHz
		pDev->Dac.fpFlags = VSYNC_NEG | HSYNC_NEG;
	}
	if(est_tim2 & 0x01)
	{
		// 1280x1024x75;
		pDev->Dac.fpHActive = 1280;
		pDev->Dac.fpHDispEnd = 1279;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 1279;
		pDev->Dac.fpHSyncStart = 1280+15;
		pDev->Dac.fpHSyncEnd = 1280+15+2;
		pDev->Dac.fpHTotal = 1280+320;
		pDev->Dac.fpVActive = 1024;
		pDev->Dac.fpVDispEnd = 1023;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd = 1023;
		pDev->Dac.fpVSyncStart = 1023+2;
		pDev->Dac.fpVSyncEnd = 1023+2+24;
		pDev->Dac.fpVTotal = 1024+40;
		pDev->Dac.fpPixClk = 10800;	// 108 MHz
		pDev->Dac.fpFlags = VSYNC_POS | HSYNC_POS;
	}

	if (pDev->Dac.fpHActive)
	{
		// save the max resolution this fp supports 
		pDev->Dac.fpHMax = pDev->Dac.fpHActive;
		pDev->Dac.fpVMax = pDev->Dac.fpVActive;
		return RM_OK;
	}
	else
		return RM_ERROR;
 }

// EDID Version 2.x
// The first 128 bytes is not very interesting to us (I think), except the last 2 bytes,
// which are the map into second 128 bytes, which contain the luminance table and 
// timing descriptions.
// In order to get to the detailed timings, we have to parse thru the lum table, frequency
// ranges, detailed range limits, and timing codes. These are optional fields, so nothing is
// found at a fixed offset. The map bytes tell whether the fields are present.
RM_STATUS ParseEDID2(PHWINFO pDev, U032 Head)
{
RM_STATUS status;
U008	map1, map2, index, lum, rangeLimits, detailedRangeLimits;
U008	detailedTimings, block, timingCodes;
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW, offset;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags, i;
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;
U008    mode_count = 0;
U008	timingCode[4*31];
DACFPTIMING fpTim;

	map1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX];
	map2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX+1];
	index =  EDID_V2_TIMING_SECTION_START_INDEX;
	// if there is a lum table, bump index beyond
	if (map1 & EDID_V2_LUM_TABLE_EXIST)
	{
		// 1st byte in timing section gives # of bytes in lum table
		lum = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_SECTION_START_INDEX];
		if (lum & TRIPLE_LUM_ENTRIES)
			index += ((lum & NUM_LUM_ENTRIES)*3) + 1;
		else
			index += (lum & NUM_LUM_ENTRIES) + 1;
	}
	// if there are timing range limits, bump index
	if ((rangeLimits = (map1 & EDID_V2_FREQ_RANGES)>>EDID_V2_FREQ_RANGE_SHIFT))
		index += rangeLimits * 8;
	// if there are detailed range limits, bump index
	if ((detailedRangeLimits = map1 & EDID_V2_DETAILED_RANGE_LIMITS))
		index += detailedRangeLimits * 27;
	// if there are timing codes, save them
	if ((timingCodes = (map2 & EDID_V2_TIMING_CODES)>>EDID_V2_TIMING_CODES_SHIFT))
		for (i=0; i!=timingCodes; i++)
		{
			timingCode[i] = pDev->Dac.CrtcInfo[Head].EDID[index];
			timingCode[i+1] = pDev->Dac.CrtcInfo[Head].EDID[index+1];
			timingCode[i+2] = pDev->Dac.CrtcInfo[Head].EDID[index+2];
			timingCode[i+3] = pDev->Dac.CrtcInfo[Head].EDID[index+3];
			index += 4;
		}
	// now index points to the detailed timings (if present)
	if ((detailedTimings = (map2 & EDID_V2_DETAILED_TIMINGS)))
	{
		for (block = 0; block < detailedTimings; block++)
		{
			// A detailed timing block is 27 bytes
			// There can be up to 7 detailed timing blocks, immediately following the timing codes
			pClk = pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block];
			pClk |= (pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block + 1])<<8;
			if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
			{
				// Does this fp support native mode?
				// Another way to check would be to see if detailedTimings > 1,
				// but what if we find multiple detailed timings for the same resolution?
				mode_count++;	
				if (mode_count > 1)
					pDev->Dac.fpNative = 1;	

				// Seems valid, get info
				offset = index + 18 * block;
				HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
				HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
				HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
				VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
				VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
				VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
				HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
				HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
				VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
				SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
				Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

				// Get timing into useful format
				HRes = HActive1 | (HActive2 & 0xf0)<<4;
				VRes = VActive1 | (VActive2 & 0xf0)<<4;
				HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
				VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
				HTotal = HRes + HBlank;
				VTotal = VRes + VBlank;
				HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
				HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
				VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<2;
				VSyncPulse = (VSyncOff1 & 0x0f) | (SyncOvf & 0x30)<<4;

				if (HRes > pDev->Dac.fpHActive)	// largest yet?
				{
					// Return this resolution
					pDev->Dac.fpPixClk = pClk;
					pDev->Dac.fpHActive = HRes;
	 				pDev->Dac.fpHDispEnd = HRes - 1;
					pDev->Dac.fpHValidEnd = HRes - 1;
			 		pDev->Dac.fpHSyncStart = HSyncOffset + pDev->Dac.fpHDispEnd;
			 		pDev->Dac.fpHSyncEnd = HSyncPulse + pDev->Dac.fpHSyncStart;
	 				pDev->Dac.fpHValidStart = 0;
	 				pDev->Dac.fpHTotal = HTotal;
				
		 			pDev->Dac.fpVActive = VRes;
			 		pDev->Dac.fpVDispEnd = VRes - 1;
		 			pDev->Dac.fpVValidEnd = VRes - 1;
	 				pDev->Dac.fpVSyncStart =  VSyncOffset + pDev->Dac.fpVDispEnd;
		 			pDev->Dac.fpVSyncEnd = VSyncPulse + pDev->Dac.fpVSyncStart;
		 			pDev->Dac.fpVValidStart = 0;
		 			pDev->Dac.fpVTotal = VTotal;
	
					// save the max resolution this fp supports 
					pDev->Dac.fpHMax = pDev->Dac.fpHActive;
					pDev->Dac.fpVMax = pDev->Dac.fpVActive;
					pDev->Dac.fpFlags = Flags;
				}
			} // if 
		} // for
		return RM_OK;
	} // if detailed timings

	// If no detailed timings, check 4 byte timing codes
	// byte 1: active pixels/line (pixels - 256)/16. Range = 256-4336.
	// byte 2: arcane info, don't know what it means. See EDID standard.
	// byte 3: aspect ration H:V.
	// byte 4: refresh rate.
	pDev->Dac.fpHActive = 0;
	mode_count = 0;
	for (i=0; i < timingCodes; i++)	// search all codes for max res
	{
		status =  GetTimingFromCode(timingCode[i*4], &fpTim);		
		if (status == RM_OK)
			if (fpTim.HTotal > pDev->Dac.fpHActive) // new max?
			{
				mode_count++;
				pDev->Dac.fpPixClk = fpTim.PixClk;
				pDev->Dac.fpHActive = fpTim.HActive;
			 	pDev->Dac.fpHDispEnd = fpTim.HDispEnd;
				pDev->Dac.fpHValidEnd = fpTim.HValidEnd;
	 			pDev->Dac.fpHSyncStart = fpTim.HSyncStart;
			 	pDev->Dac.fpHSyncEnd = fpTim.HSyncEnd;
			 	pDev->Dac.fpHValidStart = fpTim.HValidStart;
			 	pDev->Dac.fpHTotal = fpTim.HTotal;
					
	 			pDev->Dac.fpVActive = fpTim.VActive;
			 	pDev->Dac.fpVDispEnd = fpTim.VDispEnd;
			 	pDev->Dac.fpVValidEnd = fpTim.VValidEnd;
			 	pDev->Dac.fpVSyncStart = fpTim.VSyncStart;
		 		pDev->Dac.fpVSyncEnd = fpTim.VSyncEnd;
			 	pDev->Dac.fpVValidStart = fpTim.VValidStart;
	 			pDev->Dac.fpVTotal = fpTim.VTotal;
				pDev->Dac.fpFlags = fpTim.Flags;
				pDev->Dac.fpHMax = pDev->Dac.fpHActive;
				pDev->Dac.fpVMax = pDev->Dac.fpVActive;
			}
	}
	if (pDev->Dac.fpHActive)	// if we found a mode
	{
		if (mode_count > 1)
			pDev->Dac.fpNative = 1;	
		return RM_OK;
	}
	return RM_ERROR;
}

// Parse the EDID buffer (read earlier) to determine if we have valid timings.
// 
RM_STATUS fpParseEDID(PHWINFO pDev, U032 Head)
{
U032 status = RM_ERROR;	
    // The EDID may contain "established timings", a bit map of flags showing supported 
	// resolutions, or "standard timings", a 2-byte description of horizontal res + aspect ratio,
	// or "detailed timings", an 18-byte description.
	// Version 1.x EDID starts with an 8-byte header: 00 FF FF FF FF FF FF 00.
    if (pDev->Dac.CrtcInfo[Head].EDID[0] == 0)
        if (pDev->Dac.CrtcInfo[Head].EDID[1] == 0xFF)
            if (pDev->Dac.CrtcInfo[Head].EDID[7] == 0)
            {
                // Version 1 header
                if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VERSION_NUMBER_INDEX] == 1)
                {
                    switch (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_REVISION_NUMBER_INDEX]) 
                    {
                        case 0:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_10;
                            status = ParseEDID11(pDev, Head);	// Version 1.0 just like 1.1
                            break;
                        case 1:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_11;
                            status = ParseEDID11(pDev, Head);	// Version 1.1
                            break;
                        case 2:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_12;
                            status = ParseEDID12(pDev, Head);
                            break;
                        case 3:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_13;
                            status = ParseEDID13(pDev, Head);
                            break;
                        default:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_14; // This doesn't currently exist, but just in case
                            status = ParseEDID13(pDev, Head);
                            break;
                    }

                    // Is this is a digital device or analog?
                    if (!(pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7)))
                        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_MONITOR;    
                    else    
                        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_FLAT_PANEL;    
                    return status;	

                }
                else // Version 1 header, but not version 1 ID?
                {
                    return RM_ERROR;
                }
            }
	// Does not have version 1 header, check version 2
    if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) == 0)
    {
        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_MONITOR;    
        return RM_ERROR; // its a CRT	
    }
    else    
    {
        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_FLAT_PANEL;    
    }

    pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_20;
    return	ParseEDID2(pDev, Head);
}

BOOL edidIsAnalogDisplay(PHWINFO pDev, U032 Head) 
{
U032 version;

 	version = edidGetVersion(pDev, Head);
	if (version == 1)
	{
		// Verify this is an analog device
		if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7))
			return FALSE; // 1=digital
		else
			return TRUE;
	}
	if (version == 2)
		if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) == 0)
			return TRUE;
	return FALSE;
}

BOOL edidIsDigitalDisplay(PHWINFO pDev, U032 Head) 
{
U032 version;

 	version = edidGetVersion(pDev, Head);
	if (version == 1)
	{
		// Verify this is an analog device
		if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7))
			return TRUE;
		else
            return FALSE; // 1=digital
	}
	if (version == 2)
		if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) != 0)
			return TRUE;
	return FALSE;
}

//
// Generate an EDID appropriate for the current mobile panel in use
//
RM_STATUS edidConstructMobileInfo
(
    PHWINFO pDev,
    U032    Head,
    U008    *pEdid
)
{

    //
    // We need to generate an EDID given the current BIOS default panel
    // info, but until the BIOS is ready for this, just return the
    // default EDID for the mobile panels
    //
    // 
    // We need to construct the EDID from the BIOS data, but for now just drop in a std panel EDID
    //
    U032 i, panel_type;
    U008 dfp_edid_SXGA[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x30, 0x2A, 0x78, 0x20, 0x51, 0x1A,
         0x10, 0x40, 0x30, 0x70, 0x13, 0x00, 0x2C, 0xE4, 0x10, 0x00,
         0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x3c, 0x3c, 0x1E,
         // original 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x28, 0x4B, 0x1E,
         0x64, 0x0C, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F,
         0x53, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0xCF
         // original 0x53, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0xD4
    };

    U008 dfp_edid_UXGA[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x48, 0x3F, 0x40, 0x30, 0x62, 0xB0,
         0x32, 0x40, 0x40, 0xC0, 0x13, 0x00, 0x2C, 0xE4, 0x10, 0x00,
         0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x3c, 0x3c, 0x1E,
         // original 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x28, 0x4B, 0x1E,
         0x64, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         // original 0x64, 0x0C, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F,
         0x55, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0x99
         // original 0x55, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0xA4
    };

    U008 dfp_edid_Toshiba_10x7[] = {
        //EDID provided by Toshiba's system BIOS.
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x51, 0xf3, 0x82, 0x50, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x03, 0x80, 0x1d, 0x16, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x64, 0x19, 0x00, 0x40, 0x41, 0x00, 0x26, 0x30, 0x18, 0x88,
        0x36, 0x00, 0x1e, 0xd7, 0x10, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x54, 0x4f, 0x53,
        0x48, 0x49, 0x42, 0x41, 0x20, 0x49, 0x6e, 0x74, 0x65, 0x0a, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x72,
        0x6e, 0x61, 0x6c, 0x20, 0x31, 0x30, 0x32, 0x34, 0x78, 0x37, 0x36, 0x0a, 0x00, 0x00, 0x00, 0xfc,
        0x00, 0x38, 0x20, 0x50, 0x61, 0x6e, 0x65, 0x6c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x00, 0xe3
    };

#if 1
    //LPL: must have been a checksum error in the older EDID below -- comparing the two,
    // in addition to two swapped bytes (checksum neutral) there is a 0x00 instead of 0x08
    // at loc. 0x24.  Yet both have a checksum byte of 0xC0.  Manually verified this one.
    U008 dfp_edid_Toshiba_14x10[] = {
        0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x51, 0xF3, 0x86, 0x50, 0x00, 0x00, 0x00, 0x00, //814
        0x00, 0x00, 0x01, 0x03, 0x80, 0x1F, 0x17, 0x00, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //184
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x40, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, //0D8
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x30, 0x2A, 0x78, 0x20, 0x51, 0x1A, 0x10, 0x40, 0x30, 0x70, //253
        0x13, 0x00, 0x31, 0xE5, 0x10, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x54, 0x4F, 0x53, //343
        0x48, 0x49, 0x42, 0x41, 0x20, 0x49, 0x6E, 0x74, 0x65, 0x0A, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x72, //43C
        0x6E, 0x61, 0x6C, 0x20, 0x31, 0x34, 0x30, 0x30, 0x78, 0x31, 0x30, 0x0A, 0x00, 0x00, 0x00, 0xFC, //3FF
        0x00, 0x35, 0x30, 0x20, 0x50, 0x61, 0x6E, 0x65, 0x6C, 0x20, 0x20, 0x20, 0x20, 0x0A, 0x00, 0xC0  //2FF = 40 + C0 = 0
    };
#else
    U008 dfp_edid_Toshiba_14x10[] = {
        0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x51, 0xF3, 0x86, 0x50, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x01, 0x03, 0x80, 0x1F, 0x17, 0x00, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x90, 0x40, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x2A, 0x30, 0x78, 0x20, 0x51, 0x1A, 0x10, 0x40, 0x30, 0x70, 
        0x13, 0x00, 0x31, 0xE5, 0x10, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x54, 0x4F, 0x53, 
        0x48, 0x49, 0x42, 0x41, 0x20, 0x49, 0x6E, 0x74, 0x65, 0x0A, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x72, 
        0x6E, 0x61, 0x6C, 0x20, 0x31, 0x34, 0x30, 0x30, 0x78, 0x31, 0x30, 0x0A, 0x00, 0x00, 0x00, 0xFC, 
        0x00, 0x35, 0x30, 0x20, 0x50, 0x61, 0x6E, 0x65, 0x6C, 0x20, 0x20, 0x20, 0x20, 0x0A, 0x00, 0xC0, 
    };
#endif

    // Toshiba?
    if (pDev->Power.MobileOperation == 2)
    {
#if !defined(MACOS) && !defined(NTRM)
        RM_STATUS status;
        U032 eax, ebx, ecx, edx;
#endif

        //Default - use a hardwired version (not needed in 9x version, unless
        // osCallVideoBIOS fails).
        U032 strap = REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_USER_MOBILE);
        if (strap == 2) {
            for (i=0;i<128;i++) pEdid[i] = dfp_edid_Toshiba_10x7[i];
        } else {
            for (i=0;i<128;i++) pEdid[i] = dfp_edid_Toshiba_14x10[i];
        }
//
// When the active device is the CRT, this call takes 30 seconds to complete
// and returns an error code.
//
// Until we get this straightened out with Toshiba, just go with the fallback
// info
//
#if !defined(MACOS) && !defined(NTRM)
        // 
        // We need to recover the DFP EDID from the Toshiba BIOS by running through
        // our VESA EDID call.  Only implemented in Win9x at this point.
        //
        eax = 0x4F15;       // VESA EDID function
        ebx = 0x0001;
        ecx = Head;            // controller number
        edx = 0;            // EDID block number
        status = osCallVideoBIOS(pDev, &eax, &ebx, &ecx, &edx, pEdid);
#endif
    } 
    else
    {

        //
        // Dell Strapping assignments
        //
        //- SXGA+ panels            Panel ID     Timing        
        //    Hitachi  15"           0xE          SXGA+ (pclk = 108Mhz)      
        //    Sharp 15"              0x8          SXGA+       
        //    Unknown supplier       0x2          SXGA+       
        //    Unknown supplier       0x7          SXGA+      
        //  
        //- UXGA panels                
        //    Unknown supplier       0x3          UXGA  ( pclk =162Mhz )
        //    Unknown supplier       0x4          UXGA  ( pclk =162Mhz )
        //    Unknown supplier       0x5          UXGA  ( pclk =162Mhz )
        //    Unknown supplier       0xA          UXGA  ( pclk =162Mhz )
        //    Unknown supplier       0xB          UXGA  ( pclk =162Mhz )
    
        //
        // Strapped for UXGA???
        //
        panel_type = REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_USER_MOBILE) & 0x0F; 
        if ((panel_type == 0x03) || (panel_type == 0x04) || (panel_type == 0x05) 
            || (panel_type == 0x0A) || (panel_type == 0x0B))
        {
            for (i=0;i<128;i++)
                //pDev->Dac.CrtcInfo[Head].EDID[i] = dfp_edid_UXGA[i];
                pEdid[i] = dfp_edid_UXGA[i];
        }
        //
        // Strapped for SXGA+???
        //
        else    // assume SXGA+ if nothing else
        {
            for (i=0;i<128;i++)
                //pDev->Dac.CrtcInfo[Head].EDID[i] = dfp_edid_SXGA[i];
                pEdid[i] = dfp_edid_SXGA[i];
        }
    }

    return RM_OK;

}

//  Get the VESA DDC Capabilites status word
//  The lower 5 bits is a bit map of addresses at which a display will respond (A0, A2, A6);
//  bit 7 is set if there is more than one controller;
//  the upper byte is the response latency in seconds.
U032 edidGetDDCCaps
(
    PHWINFO pDev
)
{
    U008 lock, Adr = 0, Data = 0;
    U032 Caps = 0x100;  // set 1 second response (minimum)
    U032 Head, i2cPortId;

    if (IsNV5orBetter(pDev)) 
    {
        Caps |= 0x80;   // multiple DDC ports
    }

    if (pDev->Power.MobileOperation) {
        Caps |= 0x02;        // fake DDC to the always attached flatpanel
    }

    // Currently we can access any device from Head 0, but in the future, who knows?
    //    for (Head = 0; Head < pDev->Dac.HalInfo.NumCrtcs; Head++)   // for all heads
    for (Head = 0; Head < 1; Head++) 
    {
        // unlock the extended regs
        lock = UnlockCRTC(pDev, Head);

        if (IsNV11(pDev)) 
        {
           AssocDDC(pDev, Head);  // Connect the head to the I2C pins
        }
        // Try all I2c ports
        // NOTE: we have to know how many I2C ports there are--there is no define.
        for (i2cPortId = 0; i2cPortId < 3; i2cPortId++) 
        {
            // Send a byte (any data) to subaddress 0 and see if the device acks it.
            // Try all three monitor addresses
            if (!(Caps & 0x02)) // if we already set this bit, no need to do it again, as there is a noticeable delay
                if (!i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR1, 1, &Adr, 0, &Data))
                    Caps |= 0x02;
            if (!(Caps & 0x08))
                if (!i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR2, 1, &Adr, 0, &Data))
                    Caps |= 0x08;
            if (!(Caps & 0x10))
                if (!i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR3, 1, &Adr, 0, &Data))
                    Caps |= 0x10;
        }
        RestoreLock(pDev, Head, lock);
    }
    return Caps;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dac\nv20\dacnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Arbitration **************************\
*                                                                           *
* Module: DACNV20.C                                                         *
*   The DAC manager.                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include <vga.h>

/* This file simulates the NV arbitor */
#include <arb_fifo.h>
#include "nvhalcpp.h"

//////////////////////////////////////////
//
// Arbitration routines
//

//
// We're using NV11-style arbitration in anticipation of dualhead
// support on nv20.
//
static U032
adjust_scaler_burstsize(U032 raw, U032 min, U032 max)
{
  U032 adj;
  
  /* scaler burst sizes are a multiple of min bytes */
  adj = (raw + (min - 1)) / min * min;
  /* max burst size is 2048 bytes */
  if (adj > max)
    adj = max;  
  return adj;
}

//LPL Moved from init.c area.
static void
check_scaler_burstsize(scaler_t *scaler)
{
  U032 raw;

  if (!(scaler->enable)) 
    return;

  raw = adjust_scaler_burstsize(scaler->burst_size, scaler->min_burst_size, scaler->max_burst_size);

  if (raw != scaler->burst_size)
    scaler->burst_size = raw;
}


// Data structure init routines

static void
check_crtc_burstsizes(crtc_t *crtc)
{
  U032 raw = crtc->burst_size;
  
  if (!crtc->enable) return;
 
  /* crtc burst sizes are a multiple of 32 bytes */
  raw = (raw + 31) / 31 * 31;
  /* burst sizes step by 16 up to 2048 bytes*/
  if (raw > crtc->max_burst_size)
    raw = crtc->max_burst_size;
  if (raw != crtc->burst_size)
    crtc->burst_size = raw;
}

static void
init_crtc(crtc_t *crtc,
      U032 enable,
      U032 hres,
      U032 vres,
      U032 nativeVRes,
      U032 depth,
      U032 refresh,
      U032 request_delay_mclks,
      U032 request_delay_pclks,
      U032 burst_size,
      U032 min_burst_size,
      U032 max_burst_size,
      U032 cursor_burst_size,
      U032 pclk,
      U032 htotal,
      mem_t *mem
      )
{
  crtc->fifo.lwm = 0;
  crtc->enable = enable;
  crtc->hres = hres;
  crtc->vres = vres;
  crtc->nativeVRes = nativeVRes;
  crtc->depth = depth;
  crtc->drain_rate = depth*100 / 8;
  crtc->refresh = refresh;
  crtc->pclk = pclk;
  crtc->pclk_period = 1000000 / crtc->pclk; //now in ps, no longer ns
  crtc->request_delay = request_delay_mclks * mem->mclk_period + request_delay_pclks * crtc->pclk_period;
  crtc->burst_size = burst_size;
  crtc->min_burst_size = min_burst_size;
  crtc->max_burst_size = max_burst_size;
  crtc->cursor_burst_size = cursor_burst_size;
  /* make sure set burst sizes are legitimate */
  check_crtc_burstsizes(crtc);
  crtc->fifo.size = 0;
  crtc->hclk_period = crtc->pclk_period * htotal / 1000;
}

static void
init_scaler(scaler_t *scaler,
        crtc_t *crtc,
        crtc_t *crtc2,
        U032 nvclk,
        U032 enable,
        U032 source_hres,
        U032 source_vres,
        U032 h2_owns_vs,
        U032 depth,
        U032 hres,
        U032 vres,
        U032 burst_size,
        U032 min_burst_size,
        U032 max_burst_size,
        U032 request_delay_nvclks,
        U032 request_delay_pclks,
        U032 max_fifo_size
        )
{
  if (h2_owns_vs)
    scaler->pclk_period = crtc2->pclk_period;
  else
    scaler->pclk_period = crtc->pclk_period;

  scaler->h2_owns_vs    = h2_owns_vs;
  scaler->max_fifo_size = max_fifo_size;
 
  scaler->enable = enable;
  if (!enable) {
    scaler->burst_size = 0;
    return;
  }
  scaler->depth = depth;

  scaler->source_hres = source_hres;
  scaler->source_vres = source_vres;

  /* assume full screen scaling */
  scaler->window_hres = (h2_owns_vs) ? crtc2->hres : crtc->hres;
  scaler->window_vres = (h2_owns_vs) ? crtc2->vres : crtc->vres;

  /* This code does not allow for distorted scaling.
   * I.e., the horizontal and vertical scale factors are 
   * forced to be the same such that the video window is as
   * large as possible on the display without any geometric
   * distortion.
   */
  scaler->hscale = (1000*scaler->window_hres) / scaler->source_hres;
  scaler->vscale = (1000*scaler->window_vres) / scaler->source_vres;
  if (scaler->hscale > scaler->vscale)
    scaler->hscale = scaler->vscale;
  else
    scaler->vscale = scaler->hscale;

  //Normally, the bandwidth taken by the video scaler is:
  //  source_hres*source_vres*refresh rate*(2 bytes)
  //However, if the soruce width is greater than can be stored
  //in the video scaler's FIFOs, then two source lines are fetched
  //for each destination line.
  //Also, for large downscaling greater than or equal to 2x, two
  //source lines are fetched for each destination line.
  if (((scaler->source_hres*scaler->depth/8) > scaler->max_fifo_size) || (scaler->vscale <= 500))
    scaler->bwFactor = 2 * scaler->vscale;
  else
    scaler->bwFactor = 1;

  scaler->burst_size = burst_size;
  scaler->min_burst_size = min_burst_size;
  scaler->max_burst_size = max_burst_size;
  scaler->request_delay = request_delay_pclks * scaler->pclk_period + request_delay_nvclks * (1000000 / nvclk);
  /* note that we never read more than the source image,
     even if we're upscaling. that's why we take the MIN
     of 1 and hscale. */
  //scaler->drain_rate = ((scaler->depth / 8)*100000) / MIN(scaler->hscale, 1000);
  scaler->drain_rate = ((scaler->depth / 8)*100000) / ((scaler->hscale < 1000) ? scaler->hscale:1000);
  if ((scaler->vscale < 1000) || 
      ((max_fifo_size != 0) && 
       ((scaler->source_hres*(scaler->depth/8)) > max_fifo_size)
      ) 
     )
    /* we're going to decimate, so we may read 2 new lines for an output line */
    scaler->drain_rate *= 2;
  /* check for a legitimate burst size */
  check_scaler_burstsize(scaler);
  scaler->fifo.size = 0;
  scaler->fifo.lwm  = 0;
}

static void
init_mem(mem_t *mem,
     U032 mclk,
     U032 ddr,
     arb_type arbiter,
     U032 partitions,
     U032 partition_data_width,
     U032 page_fault_penalty,
     U032 page_fault_width,
     U032 refresh_penalty,
     U032 arbitration_latency,
     U032 pipeline_latency,
     U032 stall_cycles,
     U032 depth_cmd,
     U032 depth_rw,
     U032 interrupt_rate
     )
{
  mem->mclk = mclk;
  mem->mclk_period = 1000000 / mclk;
  mem->partitions = partitions;
  mem->ddr = ddr;
  mem->arbiter = arbiter;
  mem->data_rate = ((ddr) ? 2 : 1) * partitions * partition_data_width / 8;
  mem->page_fault_penalty = page_fault_penalty;
  mem->page_fault_width = page_fault_width;
  mem->refresh_penalty = refresh_penalty;
  mem->arbitration_latency = arbitration_latency;
  mem->pipeline_latency = pipeline_latency;
  mem->stall_cycles = stall_cycles;
  mem->cmdq_depth_cmd = depth_cmd;
  mem->cmdq_depth_rw = depth_rw;
  /* the first number is the amount of time taken to process all the read/write
     commands; the second is to allow for bus turnaround from read->write.
     the third and fourth allow for two page faults and a refresh in the
     command queue. */
//the command_latency is included in the pipeline_latency of the FBI.
//mem->command_latency = depth_rw * ((ddr) ? 2 : 4) + (depth_rw / 2) + (depth_cmd - 1) * page_fault_penalty + refresh_penalty;
  mem->command_latency = 0;
  mem->interrupt_rate = interrupt_rate;
}

static void
init_rtr(rtr_t *rtr,
     U032 burst_size,
     U032 request_delay_mclks,
     mem_t *mem
     )
{
  rtr->burst_size = burst_size;
  rtr->request_delay_mclks = request_delay_mclks;
  rtr->request_delay = request_delay_mclks * mem->mclk_period;
  rtr->latency = 0;
}


// Actual buffer size calculation routines
static void
guess_scaler_burstsize(scaler_t *scaler, crtc_t *crtc, crtc_t *crtc2)
{
  U032 raw, raw1, raw2;
  
  /* take a simplistic approach to guess this */

  raw1 = ((scaler->drain_rate*1000)/crtc->drain_rate )*crtc->burst_size;
  raw2 = ((scaler->drain_rate*1000)/crtc2->drain_rate)*crtc2->burst_size;
  raw  = (scaler->h2_owns_vs) ? raw2/1000 : raw1/1000;
 
  if (raw < scaler->min_burst_size) raw = scaler->min_burst_size;
  scaler->burst_size = adjust_scaler_burstsize(raw, scaler->min_burst_size, scaler->max_burst_size);
}

static U032
adjust_crtc2_burstsize(U032 raw, U032 min, U032 max)
{
  U032 adj;
  
  /* scaler burst sizes are a multiple of min bytes */
  adj = (raw + (min - 1)) / min * min;
  /* max burst size is 2048 bytes */
  if (adj > max)
    adj = max;  
  return adj;
}
    
static void
guess_crtc2_burstsize(crtc_t *crtc2, crtc_t *crtc)
{
  U032 raw;
  U032 period_factorx100, drain_factorx100;
  /* take a simplistic approach to guess this */
  period_factorx100 = (100*crtc->pclk_period)/crtc2->pclk_period;
  drain_factorx100  = (100*crtc2->drain_rate)/crtc->drain_rate;
  raw = (crtc->burst_size*period_factorx100*drain_factorx100)/10000;
  if (raw < crtc2->min_burst_size) raw = crtc2->min_burst_size;
  crtc2->burst_size = adjust_crtc2_burstsize(raw, crtc2->min_burst_size, crtc->max_burst_size);
}

/************************************************/
static U032
compute_fifo_size(fifo_params *fifo, U032 hres, U032 drain_rate, U032 burst_size, U032 request_delay, U032 dclk_period,
          U032 burst_latency, U032 bursts_during_active, mem_t *mem)
{
  U032 lwm, lwm_min;
  U032 fifo_size;
  U032 bursts_to_fill_lwm;
  
  /* figure out the low water mark in the fifo */
  if (((hres * drain_rate)/100) > (bursts_during_active * burst_size))
    lwm = (hres * drain_rate)/100 - bursts_during_active * burst_size;
  else
    lwm = 0;

  /* make sure we have enough data in the fifo to satisfy the
     initial wait in the active phase */
//LPL need:  NVASSERT((request_delay + mem->pipeline_latency + mem->command_latency + burst_latency - burst_size) >= 0);
  lwm_min = ((((request_delay + mem->pipeline_latency + mem->command_latency + burst_latency - burst_size)
      * mem->mclk_period) / mem->data_rate) * (drain_rate / dclk_period)
      +99)/100; //forces rounding up, needed because drain_rateis 100x

  //LPL: Eep!  How many loops are possible here?
  while (lwm < lwm_min) {
    lwm += burst_size;
    bursts_during_active--;
  }

  /*added because bursts during active could be more than necessary to fetch a line*/
  bursts_to_fill_lwm = lwm/burst_size;
  if (lwm%burst_size)
    bursts_to_fill_lwm++;

  while (((bursts_to_fill_lwm + bursts_during_active - 1)*burst_size) >= ((hres*drain_rate)/100)) {
    bursts_during_active--;
  }
  
  /* fifo_size is lwm + burst_size */
  fifo_size = lwm + burst_size;

  fifo->lwm_min = lwm_min;
  fifo->lwm     = lwm;
  fifo->size    = fifo_size;

  return bursts_during_active;
}

/************************************************/
/* check to see that we are consuming sufficient bandwidth. this
   is really just an approximation since it only really considers
   the bandwidth consumed by the crtc and scaler. */
static U032
not_consuming_sufficient_bandwidth(crtc_t *crtc, crtc_t *crtc2, scaler_t *scaler, mem_t *mem, U032 burst_latency, U032 cursor_latency)
{
  U032 reqd_crtc_bw, reqd_crtc2_bw, reqd_scaler_bw;
  U032 actual_bw;
  U032 error;

  //LPL is this if needed? What's the correct return in case of error?
  //LPL Range check.
  if ((crtc->hclk_period > cursor_latency/1000) && (crtc2->hclk_period > cursor_latency/1000)) {
      reqd_crtc_bw   = (100*crtc->enable)  *crtc->hres *(crtc->depth /8) / (crtc->hclk_period  - cursor_latency/1000);
      reqd_crtc2_bw  = (100*crtc2->enable) *crtc2->hres*(crtc2->depth/8) / (crtc2->hclk_period - cursor_latency/1000);
      reqd_scaler_bw = (100*scaler->enable)*scaler->source_hres * (scaler->depth / 8) * ((scaler->vscale <= 500) ? 2 : 1) / 
                       (crtc->hclk_period - cursor_latency/1000);
      actual_bw = (1000*100*(crtc->enable*crtc->burst_size + crtc2->enable*crtc2->burst_size + scaler->enable*scaler->burst_size))
                  / (burst_latency * mem->mclk_period); //x1000000 because other bw as bytes/ns, not bytes/ps
    error = (actual_bw < (reqd_crtc_bw + reqd_crtc2_bw + reqd_scaler_bw)) ? 1 : 0;
  } else {
      error = 0;    //LPL: proper failure?
  }
//  if (actual_bw < 0) error = 0;//overflow in weird cases
  return error;
}

/*makes sure fifo size isn't larger than the maximum*/
static U032 test_fifo_constraints(U032 fifo_size, crtc_t *crtc, crtc_t *crtc2, scaler_t *scaler) 
{
  /* If dm ("Display Matrix") isn't specified at the command line, dm
   * (fifo_size here) will be 0.  In this case, no error will be returned since
   * any fifo size is OK.
   */
  if (fifo_size == 0)
    return (0);

  /* Note that fifo.size is initialized to zero for the CRTCs and scaler.
   * So, this function will not return an error just because a fifo size has 
   * yet to be computed.
   */
  return (( crtc->enable  && (crtc->fifo.size   > fifo_size))             || 
          ( crtc2->enable && (crtc2->fifo.size  > fifo_size))             || 
          (scaler->enable && (scaler->fifo.size > scaler->max_fifo_size))   );
}

/* check that there is sufficient total bandwidth available to
   support this resolution. */
static U032
insufficient_total_bandwidth(crtc_t *crtc, crtc_t *crtc2, scaler_t *scaler, mem_t *mem)
{
  U032 error;
  U032 video_bandwidth;
  U032 available_bandwidth;

  //nativeVRes is used in place of VRes because, for flat panels, one line is read from memory for each
  //destination line, not each source line.  For non-flat panels (i.e., the FP scaler is not used),
  //nativeVRes should be the same as vres.
  video_bandwidth = (crtc->enable  *(crtc->hres  * crtc->nativeVRes  * crtc->depth  / 8 ) *  crtc->refresh / 10 + 
                     crtc2->enable *(crtc2->hres * crtc2->nativeVRes * crtc2->depth / 8 ) * crtc2->refresh / 10 + 
                     scaler->enable*(scaler->source_hres * scaler->source_vres * 2) * scaler->bwFactor *
                       ((scaler->h2_owns_vs)?crtc2->refresh : crtc->refresh) / 10           );

  //LPL: this overflowed before, but switch to /10 and U032 should
  // give us plenty of breathing room
  available_bandwidth = mem->data_rate * mem->mclk * 90000;
  error = (video_bandwidth > available_bandwidth) ? 1 : 0;
  return error;
}

/* check to see that we can read sufficient data during active time assuming LWM is already reached*/
/* ASSUMES that LWM can be filled during blank.  That is, this function should always be used with 
   cant_fill_to_lwm.  Also assumes that bursts_during_active actually fits in active. */
static U032
insufficient_data(U032 hres, U032 depth, U032 lwm, U032 bursts_during_active, U032 burst_size)
{
  U032 error;
  error = ((hres * depth / 8) > 
           ((lwm + burst_size - 1) / burst_size + bursts_during_active) * burst_size
          ) ? 1 : 0;
  return error;
}


/**************************************************/
/*use for NV11, NV20 and onward*/
/*should also be used for scaler NV10 onward*/
static U032
new_cant_fill_to_lwm(crtc_t *crtc, mem_t *mem, U032 burst_latency, U032 cursor_latency, U032 bursts_during_active)
{
    U032 error;
    U032 bursts_during_available;

#if 1//def TWINHEAD_OPTS
    U032 temp;
    temp = (bursts_during_active * burst_latency + cursor_latency + mem->pipeline_latency)
        * mem->mclk_period + crtc->request_delay;
    if ((crtc->hclk_period * 1000) >= temp) {
        bursts_during_available = (crtc->hclk_period * 1000 - temp)
            / (burst_latency * mem->mclk_period);
        error = (crtc->fifo.lwm > bursts_during_available * crtc->burst_size) ? 1 : 0;
    } else {
        error = 1;  //LPL: proper error?
    }
#else    //#ifdef TWINHEAD_OPTS
  bursts_during_available = ((crtc->hclk_period * 1000 -
                  bursts_during_active * burst_latency * mem.mclk_period -
                  cursor_latency                       * mem.mclk_period -
                  mem.pipeline_latency                 * mem.mclk_period -
                  crtc->request_delay
                 ) /
                 (burst_latency * mem.mclk_period)
                );
  error = (crtc->fifo.lwm > bursts_during_available * crtc->burst_size) ? 1 : 0;
#endif    //#ifdef TWINHEAD_OPTS

  return error;
}

static U032
scaler_cant_fill_to_lwm(scaler_t *scaler, crtc_t *crtc, crtc_t *crtc2, mem_t *mem, U032 burst_latency, U032 cursor_latency, U032 bursts_during_active)
{
    U032 error;
    U032 bursts_during_available;
    U032 hclk_period;

#if 1//def TWINHEAD_OPTS
    U032 temp;

    if (scaler->h2_owns_vs) hclk_period = crtc2->hclk_period;
    else hclk_period = crtc->hclk_period;

    temp = (bursts_during_active * burst_latency + cursor_latency + mem->pipeline_latency) * mem->mclk_period
        + scaler->request_delay;

    if ((hclk_period * 1000) >= temp) {
        bursts_during_available = (hclk_period * 1000 - temp)
            / (burst_latency * mem->mclk_period);
        error = (scaler->fifo.lwm > bursts_during_available * scaler->burst_size) ? 1 : 0;
    } else {
        error = 0;  //LPL proper error?
    }
#else    //#ifdef TWINHEAD_OPTS
  if (scaler->h2_owns_vs)
  {
    bursts_during_available = ((crtc2->hclk_period * 1000 -
                      bursts_during_active * burst_latency * mem.mclk_period -
                    cursor_latency                       * mem.mclk_period -
                    mem.pipeline_latency                 * mem.mclk_period -
                    scaler->request_delay
                   ) /
                   (burst_latency * mem.mclk_period)
                  );
  } else
  {
    bursts_during_available = ((crtc->hclk_period * 1000  -
                      bursts_during_active * burst_latency * mem.mclk_period -
                    cursor_latency                       * mem.mclk_period -
                    mem.pipeline_latency                 * mem.mclk_period -
                    crtc->request_delay
                   ) /
                   (burst_latency * mem.mclk_period)
                  );
  }
  error = (scaler->fifo.lwm > bursts_during_available * scaler->burst_size) ? 1 : 0;
#endif    //#ifdef TWINHEAD_OPTS

  return error;
}

/***********************************************/
/*Note: this function is analogous to test_scaler_constraints.  
  Any modifications here will often also need to be made to 
  test_scaler_constraints.
  "someday" the crtc_t and scaler_t data types should be unified so these
  two functions can also be unified.  OOP would have been nice here. . .
  */
static U032
test_crtc_constraints(crtc_t *crtc, crtc_t *crtc2, scaler_t *scaler, rtr_t *rtr, mem_t *mem)
{
  U032 errors = 0;
  U032 burst_latency;
  U032 cursor_latency;
  U032 bursts_during_active;
  U032 final_bursts_during_active;
  U032 num_rtrs, total_burst_size;
  U032 burst_temp, burst_temp2;

  if (!crtc->enable) return 0;
 
  num_rtrs         = crtc->enable + crtc2->enable + scaler->enable;
  total_burst_size =  crtc->enable*crtc->burst_size + crtc2->enable*crtc2->burst_size + scaler->enable*scaler->burst_size;

  burst_latency = num_rtrs         * mem->arbitration_latency + 
                  total_burst_size / mem->data_rate           +
                  num_rtrs         * mem->stall_cycles        +
                  (crtc->enable    * ((crtc->burst_size   + mem->page_fault_width - 1) / mem->page_fault_width) +
                   crtc2->enable   * ((crtc2->burst_size  + mem->page_fault_width - 1) / mem->page_fault_width) +
                   scaler->enable  * ((scaler->burst_size + mem->page_fault_width - 1) / mem->page_fault_width)
                  ) * mem->page_fault_penalty;

  
  /*note that cursor_latency is a on a per-CRTC basis, not total cusor_latency.*/
  /*note also that NV11 needs to treat cursor latency as taking a CRTC burst.  */
  cursor_latency = mem->arbitration_latency + (crtc->cursor_burst_size) / mem->data_rate + mem->stall_cycles;
  if (not_consuming_sufficient_bandwidth(crtc, crtc2, scaler, mem, burst_latency, cursor_latency * mem->mclk_period)) {
    errors++;
  }
  if (errors)
    return errors;

  /* optimistic case */
#if 1
  burst_temp = crtc->hres * crtc->pclk_period + crtc->burst_size * mem->mclk_period / mem->data_rate;
  burst_temp2 =  crtc->request_delay
      + (mem->pipeline_latency + mem->command_latency) * mem->mclk_period
      + 100 * crtc->burst_size * crtc->pclk_period / crtc->drain_rate;

  if (burst_temp >= burst_temp2) {
      bursts_during_active =  (burst_temp - burst_temp2) / (burst_latency * mem->mclk_period);
  } else {
      bursts_during_active = 0;
  }

#else
  bursts_during_active = (crtc->hres           * crtc->pclk_period -
                  crtc->request_delay                      -
                  mem->pipeline_latency * mem->mclk_period   -
                  mem->command_latency  * mem->mclk_period   -
                  100 * crtc->burst_size     * crtc->pclk_period / crtc->drain_rate +
                  crtc->burst_size     * mem->mclk_period   / mem->data_rate
                 ) /
                 (burst_latency * mem->mclk_period);
#endif

  final_bursts_during_active = compute_fifo_size(&crtc->fifo, crtc->hres, crtc->drain_rate, crtc->burst_size,
                         crtc->request_delay, crtc->pclk_period, burst_latency, bursts_during_active,
                         mem);

  /* can we fill to the LWM mark in the blanking period?
     note that we have to wait for the cursor burst to go first.
     for "new" mode operation, we can also start filling during
     the previous scan-out. */
  if (new_cant_fill_to_lwm(crtc, mem, burst_latency, (crtc->enable+crtc2->enable)*cursor_latency, final_bursts_during_active)) {
    errors++;
  }
  
  /* can we get enough data? */
  if (insufficient_data(crtc->hres, crtc->depth, crtc->fifo.lwm, final_bursts_during_active, crtc->burst_size)) {
    errors++;
  }

  if (errors) return errors;

  /* pessimistic case -- if this is the pessimistic case, why even try the previous case?*/
  //burst_latency += MAX(((100*crtc->burst_size * crtc->pclk_period / crtc->drain_rate / mem.mclk_period) - burst_latency, 0);
  burst_temp = 100 * crtc->burst_size * crtc->pclk_period / crtc->drain_rate / mem->mclk_period;
  if (burst_temp > burst_latency)
      burst_latency = burst_temp;

#if 1
    burst_temp = crtc->hres * crtc->pclk_period + crtc->burst_size * mem->mclk_period / mem->data_rate;
    burst_temp2 = crtc->request_delay
        + (mem->pipeline_latency + mem->command_latency) * mem->mclk_period
        + 100 * crtc->burst_size * crtc->pclk_period / crtc->drain_rate;

    if (burst_temp >= burst_temp2) {
        bursts_during_active = (burst_temp - burst_temp2) / (burst_latency * mem->mclk_period);
    } else {
      bursts_during_active = 0;
    }
#else
    bursts_during_active = (crtc->hres * crtc->pclk_period -
              crtc->request_delay -
              mem->pipeline_latency * mem->mclk_period -
              mem->command_latency * mem->mclk_period -
              100*crtc->burst_size * crtc->pclk_period / crtc->drain_rate +
              crtc->burst_size * mem->mclk_period / mem->data_rate
              ) /
             (burst_latency * mem->mclk_period);
#endif

  final_bursts_during_active = compute_fifo_size(&crtc->fifo, crtc->hres, crtc->drain_rate, crtc->burst_size,
                       crtc->request_delay, crtc->pclk_period, burst_latency, bursts_during_active,
                         mem);

  /* can we fill to the LWM mark in the blanking period? */
  if (new_cant_fill_to_lwm(crtc, mem, burst_latency, (crtc->enable+crtc2->enable)*cursor_latency, final_bursts_during_active)) {
    errors++;
  }
  
  /* can we get enough data? */
  if (insufficient_data(crtc->hres, crtc->depth, crtc->fifo.lwm, final_bursts_during_active, crtc->burst_size)) {
    errors++;
  }

  return errors;
}

/***********************************************/
static U032
test_scaler_constraints(scaler_t *scaler, crtc_t *crtc, crtc_t *crtc2, rtr_t *rtr, mem_t *mem)
{
  U032 errors = 0;
  U032 burst_latency;
  U032 bursts_during_active;
  U032 final_bursts_during_active;
  U032 num_rtrs, total_burst_size;
  U032 burst_temp, burst_temp2;
      
  if (!scaler->enable) return 0;

  /*intermediate values used to calculate burst_latency*/
  num_rtrs         = crtc->enable + crtc2->enable + scaler->enable;
  total_burst_size = crtc->enable*crtc->burst_size + crtc2->enable*crtc2->burst_size + scaler->enable*scaler->burst_size;

  burst_latency = num_rtrs         * mem->arbitration_latency + 
                  total_burst_size / mem->data_rate           +
                  num_rtrs         * mem->stall_cycles        +
                  (crtc->enable   * ((crtc->burst_size  +mem->page_fault_width-1) / mem->page_fault_width) +
                   crtc2->enable  * ((crtc2->burst_size +mem->page_fault_width-1) / mem->page_fault_width) +
                   scaler->enable * ((scaler->burst_size+mem->page_fault_width-1) / mem->page_fault_width)
                  ) * mem->page_fault_penalty;

  
  /* optimistic case */
#if 1
  burst_temp = scaler->window_hres * scaler->pclk_period + scaler->burst_size * mem->mclk_period / mem->data_rate;
  burst_temp2 = scaler->request_delay
      + (mem->pipeline_latency + mem->command_latency) * mem->mclk_period
      + 100 * scaler->burst_size * scaler->pclk_period / scaler->drain_rate;

    if (burst_temp >= burst_temp2) {
        bursts_during_active = (burst_temp - burst_temp2) / (burst_latency * mem->mclk_period);
    } else {
      bursts_during_active = 0;
    }
#else
  bursts_during_active = (scaler->window_hres  * scaler->pclk_period -
                 scaler->request_delay -
                 mem->pipeline_latency * mem->mclk_period -
                 mem->command_latency  * mem->mclk_period -
                 100*scaler->burst_size   * scaler->pclk_period / scaler->drain_rate +
                 scaler->burst_size   * mem->mclk_period / mem->data_rate
                 ) /
                (burst_latency * mem->mclk_period);
#endif

  final_bursts_during_active = compute_fifo_size(&scaler->fifo, scaler->window_hres, scaler->drain_rate, scaler->burst_size,
               scaler->request_delay, scaler->pclk_period, burst_latency, bursts_during_active,
               mem);

  if (scaler_cant_fill_to_lwm(scaler, crtc, crtc2, mem, burst_latency, 0, final_bursts_during_active)) {
    errors++;
  }
  
  /* can we get enough data? */
  if (insufficient_data(scaler->source_hres, scaler->depth, scaler->fifo.lwm, final_bursts_during_active, scaler->burst_size)) {
    errors++;
  }

  if (errors) return errors;

  /* pessimistic case */
  //burst_latency += MAX((100* scaler->burst_size * scaler->pclk_period / scaler->drain_rate / mem.mclk_period) - burst_latency, 0);
  burst_temp = 100* scaler->burst_size * scaler->pclk_period / scaler->drain_rate / mem->mclk_period;
  if (burst_temp > burst_latency)
      burst_latency = burst_temp;

#if 1
  burst_temp = scaler->window_hres * scaler->pclk_period + scaler->burst_size * mem->mclk_period / mem->data_rate;
  burst_temp2 = scaler->request_delay
      + (mem->pipeline_latency + mem->command_latency) * mem->mclk_period
      + 100 * scaler->burst_size * scaler->pclk_period / scaler->drain_rate;

    if (burst_temp >= burst_temp2) {
        bursts_during_active = (burst_temp - burst_temp2) / (burst_latency * mem->mclk_period);
    } else {
      bursts_during_active = 0;
    }
#else
  bursts_during_active = (scaler->window_hres  * scaler->pclk_period -
                 scaler->request_delay -
                 mem->pipeline_latency * mem->mclk_period -
                 mem->command_latency  * mem->mclk_period -
                 100* scaler->burst_size   * scaler->pclk_period / scaler->drain_rate +
                 scaler->burst_size   * mem->mclk_period / mem->data_rate
                 ) /
                (burst_latency * mem->mclk_period);
#endif

  final_bursts_during_active = compute_fifo_size(&scaler->fifo, scaler->window_hres, scaler->drain_rate, scaler->burst_size,
               scaler->request_delay, scaler->pclk_period, burst_latency, bursts_during_active,
               mem);

  /* can we fill to the LWM mark in the blanking period? */
  if (scaler_cant_fill_to_lwm(scaler, crtc, crtc2, mem, burst_latency, 0, final_bursts_during_active)) {
    errors++;
  }
  
  /* can we get enough data? */
  if (insufficient_data(scaler->source_hres, scaler->depth, scaler->fifo.lwm, final_bursts_during_active, scaler->burst_size)) {
    errors++;
  }

  return errors;
}

/******************************/
static U032
test_configuration(crtc_t *crtc, crtc_t *crtc2, scaler_t *scaler, rtr_t *rtr, U032 max_burst_size, mem_t *mem, U032 fifo_size)
{
  U032 error;

  error = insufficient_total_bandwidth(crtc, crtc2, scaler, mem);
  if (error) {
    return error;
  }

  for (crtc->burst_size = crtc->min_burst_size; crtc->burst_size <= max_burst_size; crtc->burst_size += 32) {

    error = 0;

    if (scaler->enable)
    guess_scaler_burstsize(scaler, crtc, crtc2);
    if (crtc2->enable)
    guess_crtc2_burstsize(crtc2, crtc);

    error = test_crtc_constraints(crtc, crtc2, scaler, rtr, mem);
    if (error)
      continue;
    if (crtc2->enable) {
      error = test_crtc_constraints(crtc2, crtc, scaler, rtr, mem);
      if (error)
        continue;
    }
    if (test_scaler_constraints(scaler, crtc, crtc2, rtr, mem))
      error++;
    if (scaler->burst_size > max_burst_size)
    error++;

    if (test_fifo_constraints(fifo_size, crtc, crtc2, scaler))
      error++;
    if (!error) 
      break;

     if (scaler->enable) {
    for (scaler->burst_size += scaler->min_burst_size; scaler->burst_size <= max_burst_size; scaler->burst_size += 32) {
        if (test_scaler_constraints(scaler, crtc, crtc2, rtr, mem))
          error = 1;
        if (test_fifo_constraints(fifo_size, crtc, crtc2, scaler))
          error++;
      if (!error) break;
    }
    if (!error) {
      if (test_crtc_constraints(crtc, crtc2, scaler, rtr, mem))
            error = 1;
      if (crtc2->enable && test_crtc_constraints(crtc2, crtc, scaler, rtr, mem))
            error++;
    }
    }
    if (test_fifo_constraints(fifo_size, crtc, crtc2, scaler))
      error++;
    if (!error) break;
  }

  return(error);
}

void
NV20_dacCalculateArbitration
(
    PHALHWINFO pHalHwInfo,
    fifo_info *fifo,
    sim_state *arb
)
{
    crtc_t crtc;
    crtc_t crtc2;
    scaler_t scaler;
    rtr_t rtr;
    mem_t mem;
//  U032 i;
//  U032 maxd, maxr;
    U032 error;
    U032 data_in_line1, data_in_line2, data_in_lineS;
 
    /*NV20 default values*/
    U032 page_fault_penalty   = 0;
    U032 page_fault_width     = 256;
    U032 arbitration_latency  = 34;
    U032 pipeline_latency     = 40;
    U032 stall_cycles         = 10;

    U032 min_burst_size   =   32;
    U032 max_burst_size   = 4096;
    U032 crtc_fifo_size   = 4096; /*CRTC fifo size in bytes*/
    U032 scaler_fifo_size = 4096; /*video scaler's fifo size*/
 
    U032 partition_data_width;
    U032 ddr;
 
    /* set up some default values for the CRTC ... */
    U032 hres    ;
    U032 htotal  ;
    U032 hres2   ;
    U032 htotal2 ;
    U032 vres    ;
    U032 vres2   ;
    U032 nativeVRes;
    U032 nativeVRes2;
    U032 refresh ;
    U032 refresh2;
    U032 depth   ;
    U032 depth2  ;
    U032 crtc_request_delay_mclks = 6;
    U032 crtc_request_delay_pclks = 6;
    U032 crtc_burst_size = 0;
    U032 cursor_burst_size = 256;
    U032 crtc2_enable, crtc_enable;
    U032 video_source_hres;
    U032 video_source_vres;
    U032 h2_owns_vs  ;
    U032 mclk;
    U032 pclk, pclk2;
 
    /* ... the scaler ... */
    U032 scaler_disable;
    U032 scaler_depth = 16;
    U032 scaler_burst_size = 0;
    /*Same as FBI interface, in bytes*/
    U032 scaler_window_hres = 0;
    U032 scaler_window_vres = 0;
    U032 scaler_request_delay_mclks = 4;
    U032 scaler_request_delay_pclks = 6;
  
    /* ... the memory controller ... */
    U032 partitions = 1;
    U032 refresh_penalty = 9;
    arb_type arbiter = round_robin;
    U032 depth_cmd = 3;
    U032 depth_rw = 8;
    U032 rtr_interrupt_rate = 0;
  
    /* ... and the real-time requestor */
    /* to disable this, just leave the burst_size as 0 */
    U032 rtr_request_delay_mclks = 4;
    U032 rtr_burst_size = 0;

    U032 who_owns_scaler;

    crtc_enable       = arb->enable_h1;
    crtc2_enable      = arb->enable_h2;
    scaler_disable    = !(arb->enable_video);
    video_source_hres = arb->video_source_hres;
    video_source_vres = arb->video_source_vres;
    h2_owns_vs        = arb->h2_owns_vs;

    hres         = arb->hres;
    htotal       = arb->htotal;
    vres         = arb->vres;
    depth        = arb->pix_bpp;
    refresh      = arb->refresh;
    pclk         = arb->pclk_khz / 1000;
    nativeVRes   = arb->nativeVRes;

    hres2        = arb->hres2;
    htotal2      = arb->htotal2;
    vres2        = arb->vres2;
    depth2       = arb->pix_bpp_h2;
    refresh2     = arb->refresh2;
    pclk2        = arb->pclk2_khz / 1000;
    nativeVRes2  = arb->nativeVRes2;

    partition_data_width = arb->memory_width;
    ddr                  = arb->memory_type;
    mclk                 = arb->mclk_khz / 1000;

    init_mem(&mem, mclk, ddr, arbiter, partitions, partition_data_width,
             page_fault_penalty, page_fault_width, refresh_penalty,
             arbitration_latency, pipeline_latency, stall_cycles,
             depth_cmd, depth_rw, rtr_interrupt_rate);
    init_crtc(&crtc, crtc_enable,
              hres, vres, nativeVRes, depth, refresh,
              crtc_request_delay_mclks, crtc_request_delay_pclks,
              crtc_burst_size, min_burst_size, max_burst_size,
              cursor_burst_size, pclk, htotal, &mem);
    init_crtc(&crtc2, crtc2_enable,
              hres2, vres2, nativeVRes2, depth2, refresh2,
              crtc_request_delay_mclks, crtc_request_delay_pclks,
              crtc_burst_size, min_burst_size, max_burst_size,
              cursor_burst_size, pclk2, htotal2, &mem);
    init_scaler(&scaler, &crtc, &crtc2, mclk,
                (scaler_disable) ? 0 : 1,
                video_source_hres, video_source_vres, h2_owns_vs, scaler_depth,
                scaler_window_hres, scaler_window_vres,
                scaler_burst_size, min_burst_size, max_burst_size,
                scaler_request_delay_mclks, scaler_request_delay_pclks,
                scaler_fifo_size);
    init_rtr(&rtr, rtr_burst_size, rtr_request_delay_mclks, &mem);

//  if ((hres2*depth2*1000/crtc2.hclk_period) > (hres*depth*1000/crtc.hclk_period)) {
    //For the purposes of this calc, assign scaler to head with worst bandwidth constraints.
    who_owns_scaler = 0;
    if (crtc2.enable && crtc.enable) {
        if ((hres2*depth2*1000/crtc2.hclk_period) > (hres*depth*1000/crtc.hclk_period))
            who_owns_scaler = 1;
    } else {
        if (crtc2.enable)
            who_owns_scaler = 1;
    }

    if (!crtc.enable) {
        /*swap which head scaler is owned by when swapping heads*/
        scaler.h2_owns_vs = !scaler.h2_owns_vs;
        error = test_configuration(&crtc2, &crtc,  &scaler, &rtr,
                                   max_burst_size, &mem, crtc_fifo_size); 
        scaler.h2_owns_vs = !scaler.h2_owns_vs;
    } else if (!crtc2.enable) {
        error = test_configuration(&crtc,  &crtc2, &scaler, &rtr,
                                   max_burst_size, &mem, crtc_fifo_size); 
    } else if (who_owns_scaler) {
        /*swap which head scaler is owned by when swapping heads*/
        scaler.h2_owns_vs = !scaler.h2_owns_vs;
        error = test_configuration(&crtc2, &crtc,  &scaler, &rtr,
                                   max_burst_size, &mem, crtc_fifo_size); 
        scaler.h2_owns_vs = !scaler.h2_owns_vs;
    } else
        error = test_configuration(&crtc,  &crtc2, &scaler, &rtr,
                                   max_burst_size, &mem, crtc_fifo_size); 


    //Compute the amount of data in a single horizontal line
    data_in_line1 = crtc.hres          * crtc.depth   / 8;
    data_in_line2 = crtc2.hres         * crtc2.depth  / 8; 
    data_in_lineS = scaler.source_hres * scaler.depth / 8;

    //It is really inefficent to have a burst size smaller than 256 bytes.
    if (crtc.burst_size   < 256)
        crtc.burst_size   = 256;
    if (crtc2.burst_size  < 256)
        crtc2.burst_size  = 256;
    if (scaler.burst_size < 256)
        scaler.burst_size = 256;

    //It is wasteful to have a burst size larger than the amount of data in a line
    if (crtc.burst_size   > data_in_line1)
        crtc.burst_size   = data_in_line1;
    if (crtc2.burst_size  > data_in_line2)
        crtc2.burst_size  = data_in_line2;
    if (scaler.burst_size > data_in_lineS)
        scaler.burst_size = data_in_lineS;


    //LPL: addition to set watermarks as high as possible instead
    // of as low as possible.  This presumably obviates the need
    // for some other calculation effort earler.

    //Get best performance for the real-time requestors by setting LWM
    //as high as possible without risking overflow.
    crtc.fifo.lwm   = crtc_fifo_size   - crtc.burst_size  ;
    crtc2.fifo.lwm  = crtc_fifo_size   - crtc2.burst_size ;
    scaler.fifo.lwm = scaler_fifo_size - scaler.burst_size;

    //LWM should not be larger than the amount of data in a line
    if (crtc.fifo.lwm > data_in_line1)
        crtc.fifo.lwm = data_in_line1;
    if (crtc2.fifo.lwm > data_in_line2)
        crtc2.fifo.lwm = data_in_line2;
    if (scaler.fifo.lwm > data_in_lineS)
        scaler.fifo.lwm = data_in_lineS;
 
    fifo->valid = !error;
    fifo->crtc1_lwm = crtc.fifo.lwm;
    fifo->crtc2_lwm = crtc2.fifo.lwm;
    fifo->video_lwm = scaler.fifo.lwm;
    fifo->crtc1_burst_size = crtc.burst_size;
    fifo->crtc2_burst_size = crtc2.burst_size;
    fifo->video_burst_size = scaler.burst_size;
}

/*
//
// Determine if the video overlay is usable in the current configuration.  This
// routine will also update the global variables in pDev which determine the 
// maximum downscaling allowed at various source image sizes.
//
//  Return 0 if not capable (at any upscale or downscale factor)
//  Return ~0 if capable (see pDev for downscale limits)
//
U032 NV20_dacCalculateVideoCaps
(
    PHWINFO pDev
)
{
    //
    // First look for a match of memory type, resolution, and clocks.
    //
    // NOTE: For now, until I can straighten out all of the hardware data,
    // assume a conservative limit.
    //
    switch (pDev->Chip.HalInfo.MaskRevision)
    {
        case 0xA1:
        case 0xA2:
        case 0xA6:
        
            pDev->Video.OverlayMaxDownscale_768  = 2;
            pDev->Video.OverlayMaxDownscale_1280 = 2;
            pDev->Video.OverlayMaxDownscale_1920 = 2;
            break;
            
        default:

            pDev->Video.OverlayMaxDownscale_768  = 8;
            pDev->Video.OverlayMaxDownscale_1280 = 4;
            pDev->Video.OverlayMaxDownscale_1920 = 2;
            break;
    }

    //
    // For now, always assume we can support some level of overlay
    // (although not to the same level of downscale ability)
    //
    return 1;
}
*/

typedef struct tagNV20_DacAGPClockEntry
{
    U032 frequency;
    U032 setting;
} NV20_DacAGPClockEntry;

NV20_DacAGPClockEntry NV20_dacAGPClockTable[] =
{
    { 133000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_133MHZ },
    { 126000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_126MHZ },
    { 120000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_120MHZ },
    { 113000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_113MHZ },
    { 106000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_106MHZ },
    { 100000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_100MHZ },
    { 94000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_94MHZ },
    { 87000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_87MHZ },
    { 80000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_80MHZ },
    { 73000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_73MHZ },
    { 66000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ },
    { 0, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ - 1 }
};

//
// HAL stuff
//

// forwards
RM_STATUS nvHalDacControl_NV20(VOID *);
RM_STATUS nvHalDacAlloc_NV20(VOID *);
RM_STATUS nvHalDacFree_NV20(VOID *);
RM_STATUS nvHalDacSetStartAddr_NV20(VOID *);
RM_STATUS nvHalDacProgramMClk_NV20(VOID *);
RM_STATUS nvHalDacProgramNVClk_NV20(VOID *);
RM_STATUS nvHalDacProgramPClk_NV20(VOID *);
RM_STATUS nvHalDacProgramCursorImage_NV20(VOID *);
RM_STATUS nvHalDacGetRasterPosition_NV20(VOID *);
RM_STATUS nvHalDacValidateBandwidth_NV20(VOID *arg);
RM_STATUS nvHalDacValidateArbSettings_NV20(VOID *arg);
RM_STATUS nvHalDacUpdateArbSettings_NV20(VOID *arg);

//
// nvHalDacControl
//
RM_STATUS
nvHalDacControl_NV20(VOID *arg)
{
    PDACCONTROLARG_000 pDacControlArg = (PDACCONTROLARG_000)arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;
    PDACHALINFO_NV20    pDacHalPvtInfo;

    //
    // Verify interface revision.
    //
    if (pDacControlArg->id != DAC_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacControlArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;
    pDacHalPvtInfo = (PDACHALINFO_NV20)pHalHwInfo->pDacHalInfo;

    switch (pDacControlArg->cmd)
    {
        case DAC_CONTROL_INIT:
        {
            U032 i, data32, crtcAddr;
            U008 lock;

            // default to 128bit wide bus on nv20
            pDacHalInfo->InputWidth = 128;
            pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 350000000;
            pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 350000000;
            pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 300000000;
            pDacHalInfo->CrtcInfo[0].RegOffset = 0x00000000;

            //
            // Head 0 supports everything (?).
            //
            pDacHalInfo->CrtcInfo[0].DisplayTypesAllowed =
                DISPLAYTYPEBIT(DISPLAY_TYPE_MONITOR) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_TV) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_DUALSURFACE) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_FLAT_PANEL);

            //
            // Head 1 supports TV and flat panel.
            //
            pDacHalInfo->CrtcInfo[1].DisplayTypesAllowed =
                DISPLAYTYPEBIT(DISPLAY_TYPE_TV) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_FLAT_PANEL);


            // turn on CRTC big endian on 2nd head if we're setup for big endian mode
            if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
            {
                U032 crtcOffset;
                U032 config;
                crtcOffset = pDacHalInfo->CrtcInfo[1].RegOffset;
                config = REG_RD32(NV_PCRTC_CONFIG + crtcOffset);
                config |= DRF_DEF(_PCRTC, _CONFIG, _ENDIAN, _BIG);
                REG_WR32(NV_PCRTC_CONFIG + crtcOffset, config);
            }

            //
            // While we're here, increase TV out latency.
            //
            for (i = 0; i < pDacHalInfo->NumCrtcs; i++)
            {
                crtcAddr = pDacHalInfo->CrtcInfo[i].RegOffset;

                // Unlock CRTC extended regs
                HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, crtcAddr);
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, crtcAddr);

                // Add 4 per Raj Rao...
                HAL_CRTC_RD(NV_CIO_CRE_TVOUT_LATENCY, data32, crtcAddr);
                data32 += 4;
                HAL_CRTC_WR(NV_CIO_CRE_TVOUT_LATENCY, data32, crtcAddr);

                // Relock if necessary...
                if (lock == 0)
                    HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, crtcAddr);
            }

            //
            // Set default downscale values.
            // 
            pVideoHalInfo->OverlayMaxDownscale_768  = 8;
            pVideoHalInfo->OverlayMaxDownscale_1280 = 8;
            pVideoHalInfo->OverlayMaxDownscale_1920 = 8;

            // turn on CRTC big endian if we're setup for big endian mode
            if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
            {
                FLD_WR_DRF_NUM(_PCRTC, _CONFIG, _ENDIAN, NV_PCRTC_CONFIG_ENDIAN_BIG);
	        }
            break;
        }
        case DAC_CONTROL_DITHER_DISABLE:
            FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_DITHER_2D, _DISABLED);
            FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_DITHER_2D, _DISABLED);
            break;
        case DAC_CONTROL_DITHER_ENABLE:
            FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_DITHER_2D, _ENABLED);
            FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_DITHER_2D, _ENABLED);
            break;
        case DAC_CONTROL_LOAD:
        case DAC_CONTROL_UNLOAD:
        case DAC_CONTROL_DESTROY:
        case DAC_CONTROL_UPDATE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

RM_STATUS
nvHalDacAlloc_NV20(VOID *arg)
{
    PDACALLOCARG_000 pDacAllocArg = (PDACALLOCARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDacAllocArg->id != DAC_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    return (RM_OK);
}

RM_STATUS
nvHalDacFree_NV20(VOID *arg)
{
    PDACFREEARG_000 pDacFreeArg = (PDACFREEARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDacFreeArg->id != DAC_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);    

    return (RM_OK);
}

RM_STATUS
nvHalDacSetStartAddr_NV20(VOID *arg)
{
    PDACSETSTARTADDRARG_000 pDacSetStartAddrArg = (PDACSETSTARTADDRARG_000)arg;
    PHALHWINFO  pHalHwInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    PDACHALINFO pDacHalInfo;
    U032        crtcOffset;

    //
    // Verify interface revision.
    //
    if (pDacSetStartAddrArg->id != DAC_SET_START_ADDR_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacSetStartAddrArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT)pDacSetStartAddrArg->pHalObjInfo;

    crtcOffset = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;
    REG_WR32(NV_PCRTC_START + crtcOffset, pDacSetStartAddrArg->startAddr);

    return (RM_OK);
}

//
// nvHalDacProgramMClk_NV20 - Program MCLK based on the value in pDev->Dac.HalInfo.MClk
//
// This routine uses the value in pDev->Dac.HalInfo.MClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramMClk_NV20(VOID *arg)
{
    PDACPROGRAMMCLKARG_000 pDacProgramMClkArg = (PDACPROGRAMMCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 oldMClkScaled;
    U032 newMClkScaled;
    U032 oldTiming2Refresh;
    U032 newTiming2Refresh;
    U032 Loops;
    U032 IsPllLocked;
    U032 Emrs;
    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramMClkArg->id != DAC_PROGRAMMCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramMClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;

    mNew = pDacHalInfo->MPllM;
    nNew = pDacHalInfo->MPllN;
    pNew = pDacHalInfo->MPllP;

    // Program the hardware

    // Retrieve original coefficients
    coeff = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
    mOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first
	    REG_WR32
            (
                NV_PRAMDAC_MPLL_COEFF,
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _PDIV, pOld)
            );

        // Wait until M PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _MPLL_LOCK)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _MPLL_LOCK)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: M PLL not locked\n");
        }
    }

    // Now we can write the final value
	REG_WR32
        (
            NV_PRAMDAC_MPLL_COEFF,
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _PDIV, pNew)
        );

    // Wait for M PLL to lock.
    osDelay(64 /* ms */);

    // Reset EMRS.
    Emrs = REG_RD32(NV_PFB_EMRS);
    Emrs |= DRF_DEF(_PFB, _EMRS, _BA0, _1);
    REG_WR32(NV_PFB_EMRS, Emrs);

    // Reset (resync) the frame buffer DRAM DLL.
    FLD_WR_DRF_DEF(_PFB, _MRS, _A8, _1);

    // Update the number of clock cycles per memory refresh cycle.
    
    // Determine original frequency from old M, N, P values, 
    // scale down both old and new to avoid 32-bit overflow later.  
    // NV_PFB_TIMING2_REFRESH is max 11 bits, mclk is max 30 bits.
    
    oldMClkScaled  = (nOld * pMcHalInfo->CrystalFreq / (1 << pOld) / mOld) >> (11 + 30 - 32);
    
    newMClkScaled  = pDacHalInfo->MClk >> (11 + 30 - 32);

    if (oldMClkScaled != newMClkScaled)
    {
        // Scale the refresh-delay by the ratio between new and old frequencies.
        // Be careful to round rather than truncate.
        //
        // NOTE: we are accumulating round-off errors in NV_PFB_TIMING2_REFRESH.
        //       Over many changes of mclk, the refresh interval may drift up or down.
        //       We really should be calculating from the initial bios refresh and
        //       mclk each time, but we don't have that data cached away anywhere.
        
        oldTiming2Refresh = REG_RD_DRF( _PFB, _TIMING2, _REFRESH );
    
        newTiming2Refresh = (oldTiming2Refresh * newMClkScaled + oldMClkScaled/2) / oldMClkScaled;
        
        DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "old cycles per refresh=", oldTiming2Refresh*32);
        DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "new cycles per refresh=", newTiming2Refresh*32);
        
        // Store the new value
        FLD_WR_DRF_NUM( _PFB, _TIMING2, _REFRESH, newTiming2Refresh );
    }       
    return status;
}

//
// nvHalDacProgramNVClk_NV20 - Program NVCLK based on the value in pDev->Dac.HalInfo.NVClk
//
// This routine uses the value in pDev->Dac.HalInfo.NVClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramNVClk_NV20(VOID *arg)
{
    PDACPROGRAMNVCLKARG_000 pDacProgramNVClkArg = (PDACPROGRAMNVCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 i;
    U032 Loops;
    U032 IsPllLocked;
    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramNVClkArg->id != DAC_PROGRAMNVCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramNVClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;

    mNew = pDacHalInfo->NVPllM;
    nNew = pDacHalInfo->NVPllN;
    pNew = pDacHalInfo->NVPllP;

    // Program the hardware

    // Retrieve original coefficients
    coeff = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
    mOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first
	    REG_WR32
            (
                NV_PRAMDAC_NVPLL_COEFF,
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _PDIV, pOld)
            );

        // Wait until NV PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _NVPLL_LOCK)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_NVPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _NVPLL_LOCK)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_NVPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: NV PLL not locked\n");
        }
    }

    // Now we can write the final value
	REG_WR32
        (
            NV_PRAMDAC_NVPLL_COEFF,
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _PDIV, pNew)
        );

    // Update NV_PBUS_DEBUG_3 to control data throttling in AGP 4X mode
    i = 0;
    while ( ( pDacHalInfo->NVClk <= NV20_dacAGPClockTable[ i ].frequency ) &&
        ( i < sizeof( NV20_dacAGPClockTable ) / sizeof( NV20_dacAGPClockTable[ 0 ] ) - 1 ) )
    {
        i++;
    }

    FLD_WR_DRF_NUM( _PBUS, _DEBUG_3, _AGP_4X_NVCLK, NV20_dacAGPClockTable[ i ].setting );
    
    return status;
}

//
// nvHalDacProgramPClk_NV20
//
RM_STATUS
nvHalDacProgramPClk_NV20(VOID *arg)
{
    PDACPROGRAMPCLKARG_000 pDacProgramPClkArg = (PDACPROGRAMPCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032            CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo
    U032            Head;
    U032            PixelClock;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 Loops;
    U032 IsPllLocked;

    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramPClkArg->id != DAC_PROGRAMPCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramPClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacProgramPClkArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    mNew = pDacHalInfo->VPllM;
    nNew = pDacHalInfo->VPllN;
    pNew = pDacHalInfo->VPllP;

    Head = pDacHalObj->Head;
    PixelClock = pDacProgramPClkArg->PixelClock;

    // Program the hardware

    // Retrieve original coefficients
    // NV11 VPLL2 unfortunately is not at the "expected" offset, so we can't use the HAL macro (DAC_REG_RD32)
    if (Head == 0) 
    {
        coeff = REG_RD32( NV_PRAMDAC_VPLL_COEFF );
    }
    else
    {
        coeff = REG_RD32( NV_PRAMDAC_VPLL2_COEFF );
    }
    mOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first. 
        if (Head == 0) 
        {
            REG_WR32
            (
                NV_PRAMDAC_VPLL_COEFF,
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pOld)
            );
        }
        else
        {
            REG_WR32
            (
                NV_PRAMDAC_VPLL2_COEFF,
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pOld)
            );
        }

        // Wait until V PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                HAL_DAC_REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _VPLL_LOCK, CurDacAdr)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    HAL_DAC_REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _VPLL_LOCK, CurDacAdr)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: VPLL not locked\n");
        }
    }

    // Now we can write the final value
    if (Head == 0) 
    {
        REG_WR32
        (
            NV_PRAMDAC_VPLL_COEFF,
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pNew)
        );
    }
    else
    {
        REG_WR32
        (
            NV_PRAMDAC_VPLL2_COEFF,
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pNew)
        );
    }

    return status;
}

//
// nvHalDacProgramCursorImage_NV20
//
RM_STATUS
nvHalDacProgramCursorImage_NV20(VOID *arg)
{
    PDACPROGRAMCURSORARG_000 pDacProgramCursorImgArg = (PDACPROGRAMCURSORARG_000) arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032        CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo
    U032        cursorConfig;

    //
    // Verify interface revision.
    //
    if (pDacProgramCursorImgArg->id != DAC_PROGRAMCURSOR_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramCursorImgArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacProgramCursorImgArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    // Read the cursorConfig register.
    cursorConfig = HAL_DAC_REG_RD32(NV_PCRTC_CURSOR_CONFIG, CurDacAdr);

    // Preserve the enable and scan_double bits. Clear the rest
    cursorConfig &= ((1 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_ENABLE)) |
                     (1 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_SCAN_DOUBLE)));

    // Mark the Address Space Indicator to indicate where the cursor image is, 
    // based on the param "asi".
    cursorConfig |= (pDacProgramCursorImgArg->asi << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_ADDRESS_SPACE));

    // The supported cursor image sizes are 32x32 or 64x64.
    if (pDacProgramCursorImgArg->width == 32)
    {
        // 32x32
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_PIXELS, NV_PCRTC_CURSOR_CONFIG_CUR_PIXELS_32);
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_LINES, NV_PCRTC_CURSOR_CONFIG_CUR_LINES_32);
    }
    else
    {
        //64x64
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_PIXELS, NV_PCRTC_CURSOR_CONFIG_CUR_PIXELS_64);
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_LINES, NV_PCRTC_CURSOR_CONFIG_CUR_LINES_64);
    }

    // The different color formats are implemented by two bits: The Blend bit and Bpp bit.
    //       Blend      Bpp        Format
    //       ----------------------------
    //         0         0     ->  ROP1R5G5B5
    //         0         1     ->  PM_A8R8G8B8  *** This format is only supported in NV15 or later.
    //         1         0     ->  A1R5G5B5
    //         1         1     ->  A8R8G8B8
    switch (pDacProgramCursorImgArg->colorFormat)
    {
        case NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A1R5G5B5:
            // Set blend = 0. Bpp is already 0
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BLEND_ALPHA << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BLEND));
            break;
        case NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A8R8G8B8:
            // set blend = 1, bpp = 1
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BLEND_ALPHA << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BLEND));
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BPP_32 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BPP));
            break;
        case NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8:
        case NV207C_SET_CURSOR_IMAGE_FORMAT_COLOR_XOR_LE_A8R8G8B8:
            // set bpp = 1, blend already 0 (only supported in NV15 or later)
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BPP_32 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BPP));
            break;
        default:
            // Leave blend and bpp both 0 (ROP1R5G5B5)
            break;
    }

    // write the new cursor config register value.
    HAL_DAC_REG_WR32(NV_PCRTC_CURSOR_CONFIG, cursorConfig, CurDacAdr);

    //
    // Turn on LONG_PIPE to extend the cursor FIFO.
    //
    HAL_DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIPE, _LONG, CurDacAdr);

    // preset xor cursor control to disabled
    HAL_DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _CUR_32B_ROP, _DISABLE, CurDacAdr); 

    //
    // Set xor mode if specified.
    //
    if (pDacProgramCursorImgArg->colorFormat == NV207C_SET_CURSOR_IMAGE_FORMAT_COLOR_XOR_LE_A8R8G8B8)
        HAL_DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _CUR_32B_ROP, _ENABLE, CurDacAdr);

    // Program the start address.
    // If the address space indicator says it is in Instance Memory, the startAddr is in terms of 
    // paragraphs instead of bytes. Adjust it to bytes.
    if (pDacProgramCursorImgArg->asi == NV_PCRTC_CURSOR_CONFIG_ADDRESS_SPACE_PINST)
    {
        pDacProgramCursorImgArg->startAddr <<= 4;
    }

    HAL_DAC_REG_WR32(NV_PCRTC_CURSOR, pDacProgramCursorImgArg->startAddr, CurDacAdr);

    return RM_OK;
}

//
// nvHalDacGetRasterPosition_NV20
//
RM_STATUS
nvHalDacGetRasterPosition_NV20(VOID *arg)
{
    PDACRASTERPOSARG_000 pDacRasterPosArg = (PDACRASTERPOSARG_000) arg;
    PHALHWINFO pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pDacRasterPosArg->id != DAC_RASTERPOS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacRasterPosArg->pHalHwInfo;

    // TO DO: use head number

    // no RL0/RL1 index regs, so return NV_PCRTC_RASTER_POSITION
    pDacRasterPosArg->result =  (U016) REG_RD_DRF(_PCRTC, _RASTER, _POSITION);

    return (RM_OK);
}


//
// Called from display driver to confirm that sufficient bandwidth is available
// for the proposed configuration.
// For this chip, stubbed out to always return success...
//
RM_STATUS
nvHalDacValidateBandwidth_NV20( VOID *arg)
{
    return RM_OK;
}


//
// Attempt to validate the given parameters will work with the current configuration
//
//  Return 0  if not capable
//  Return ~0 if valid
//
RM_STATUS
nvHalDacValidateArbSettings_NV20(VOID *arg)
{
    PDACVALIDATEARBSETTINGSARG_000    pDacValidateArbSettingsArg = (PDACVALIDATEARBSETTINGSARG_000) arg;
    PHALHWINFO          pHalHwInfo;
    PDACHALINFO         pDacHalInfo;
    PFBHALINFO          pFbHalInfo;
    PMCHALINFO          pMcHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;

	fifo_info   fifo_data;
	sim_state   sim_data;
    U032        i, pclk_limit;
    U032        head;

    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pVidLutCurDac0;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pVidLutCurDac1;

    //
    // Verify interface revision.
    //
    if (pDacValidateArbSettingsArg->id != DAC_VALIDATEARBSETTINGS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacValidateArbSettingsArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;

    pVidLutCurDac0 = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHalInfo->CrtcInfo[0].pVidLutCurDac;
    pVidLutCurDac1 = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHalInfo->CrtcInfo[1].pVidLutCurDac;

    head = pDacValidateArbSettingsArg->head;

    //
    // First we must validate that the incoming vclk is within our DAC range.
    //
    switch (pDacValidateArbSettingsArg->bpp)
    {
        case 8:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp;
            break;
        case 15:
        case 16:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp;
            break;
        case 24:
        case 32:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp;
            break;
        default:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp;
            break;
    }

    //
    // If incoming clock is greater than DAC range, return failure
    //
    if (pDacValidateArbSettingsArg->vclk > pclk_limit)
    {
        pDacValidateArbSettingsArg->result = 0;
        return (RM_OK);
    }

    // Make sure any uninitialized sim data starts with 0's
    for (i = 0; i < sizeof(sim_data); i++)
        ((U008 *)&sim_data)[i] = 0x0;

    //
    // Build the sim table using current system settings
    //
    sim_data.enable_video   = pDacValidateArbSettingsArg->video_enabled ? 1 : 0;
    sim_data.enable_mp      = pDacValidateArbSettingsArg->mport_enabled ? 1 : 0;
    sim_data.memory_width   = pDacHalInfo->InputWidth;
    sim_data.mem_latency    = 3;
    sim_data.memory_type    = (pFbHalInfo->RamType == BUFFER_DDRAM) ? 1 : 0; //1=DD,0=SD
    sim_data.mem_aligned    = 1;
    sim_data.mem_page_miss  = 10;
    sim_data.gr_during_vid  = pVideoHalInfo->ColorKeyEnabled ? 1 : 0;
    sim_data.pclk_khz       = pDacValidateArbSettingsArg->vclk / 1000;  // in kHz, not MHz
    sim_data.mclk_khz       = pDacHalInfo->MClk / 1000;     // in kHz, not MHz
    sim_data.nvclk_khz      = pDacHalInfo->NVClk / 1000;    // in kHz, not MHz

    //NV11
    fifo_data.crtc1_lwm = 0;
    fifo_data.crtc2_lwm = 0;
    fifo_data.video_lwm = 0;
    fifo_data.crtc1_burst_size = 0;
    fifo_data.crtc2_burst_size = 0;
    fifo_data.video_burst_size = 0;
    fifo_data.valid = 0;

    //
    // We're using NV11-style arbitration here in anticipation
    // of dual-head support for nv20.
    //
    sim_data.enable_h1      =    (pVidLutCurDac0)?1:0;
    if (pVidLutCurDac0) {
        sim_data.pix_bpp    = pVidLutCurDac0->Dac[0].PixelDepth;
        sim_data.hres       = pVidLutCurDac0->Dac[0].VisibleImageWidth;
        sim_data.htotal     = pVidLutCurDac0->Dac[0].TotalWidth;
        sim_data.vres       = pVidLutCurDac0->Dac[0].VisibleImageHeight;
        sim_data.nativeVRes = (HAL_GETDISPLAYTYPE(0) == DISPLAY_TYPE_FLAT_PANEL)?pDacHalInfo->fpVMax:sim_data.vres;

        //LPL: copied math below, but I don't get it... *10000?
        sim_data.refresh    =
            (pVidLutCurDac0->Dac[0].PixelClock*10000) /
            (pVidLutCurDac0->Dac[0].TotalWidth * pVidLutCurDac0->Dac[0].TotalHeight);    //75;

        // sim_data.pix_bpp   =   32;
        sim_data.pclk_khz   =  pVidLutCurDac0->Dac[0].PixelClock * 10;
    } else {
        sim_data.hres       = 640;
        sim_data.htotal     = 832;
        sim_data.vres       = 480;
        sim_data.nativeVRes = sim_data.vres;
        sim_data.refresh    = 85;    //75;
        // sim_data.pix_bpp    =   32;
        sim_data.pclk_khz   =  36000;   //3404772;
    }
    
    sim_data.enable_h2    = (pVidLutCurDac1)?1:0;       //0
    if (pVidLutCurDac1) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "nvHalDacValidateArbSettings: head1 has a dac object!!!\n");
        DBG_BREAKPOINT();
        sim_data.pix_bpp_h2   = pVidLutCurDac1->Dac[0].PixelDepth; 
        sim_data.hres2        = pVidLutCurDac1->Dac[0].VisibleImageWidth;
        sim_data.htotal2      = pVidLutCurDac1->Dac[0].TotalWidth;
        sim_data.vres2        = pVidLutCurDac1->Dac[0].VisibleImageHeight;
        sim_data.nativeVRes2  = (HAL_GETDISPLAYTYPE(1) == DISPLAY_TYPE_FLAT_PANEL)?pDacHalInfo->fpVMax:sim_data.vres2;

        //LPL: copied math below, but I don't get it... *10000?
        sim_data.refresh2     = (pVidLutCurDac1->Dac[0].PixelClock*10000) /
                                (pVidLutCurDac1->Dac[0].TotalWidth * pVidLutCurDac1->Dac[0].TotalHeight);    //60;

        sim_data.pclk2_khz    =   pVidLutCurDac1->Dac[0].PixelClock * 10;  //641088;
    } else {
        sim_data.hres2        = 640;
        sim_data.htotal2      = 832;
        sim_data.vres2        = 480;
        sim_data.nativeVRes2  = sim_data.vres2;
        sim_data.refresh2     = 85;    //75;
        // sim_data.pix_bpp      =   32;
        sim_data.pclk2_khz    =  36000;   //3404772;
    }

//    sim_data.enable_video =    1;
//    sim_data.enable_mp    =    0;

//    sim_data.memory_width =  128;
//    sim_data.memory_type  =    0;
//    sim_data.mclk_mhz     =  166;

    //
    // If the overlay is active, use the head that owns the video scaler,
    // otherwise, for calculating if the overlay is allowed, assume this
    // head.
    //
	if (pVideoHalInfo->ActiveVideoOverlayObject)
        sim_data.h2_owns_vs = pVideoHalInfo->Head;
    else
        sim_data.h2_owns_vs = head;

    sim_data.video_source_hres = 720;
    sim_data.video_source_vres = 480;
//end NV11

    //Override the bit plane depth with passed parameter.
    if (head) {
        sim_data.pix_bpp_h2 = pDacValidateArbSettingsArg->bpp;   //32;
    } else {
        sim_data.pix_bpp    = pDacValidateArbSettingsArg->bpp;   //bpp;
    }

    //
    // What if we're still not sure?  Well, for now let's pick
    // the worst case...
    if (!sim_data.pix_bpp) sim_data.pix_bpp = 32;
    if (!sim_data.pix_bpp_h2) sim_data.pix_bpp_h2 = 32;

    //
    // Run the numbers through the ringer
    //
    NV20_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);

    /*
    //
    // If the CRTC can do this, double check to make sure the overlay is able as well
    //
    if (fifo_data.valid && video_enabled)
        fifo_data.valid = NV20_dacCalculateVideoCaps(pDev);
    */

    pDacValidateArbSettingsArg->result = (U032)fifo_data.valid;    

    return (RM_OK);
}

RM_STATUS
nvHalDacUpdateArbSettings_NV20(VOID *arg)
{
    PDACUPDATEARBSETTINGSARG_000     pDacUpdateArbSettingsArg = (PDACUPDATEARBSETTINGSARG_000) arg;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    PHALHWINFO          pHalHwInfo;
    PDACHALINFO         pDacHalInfo;
    PFBHALINFO          pFbHalInfo;
    PMCHALINFO          pMcHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;
    PMPHALINFO          pMpHalInfo;
    U032                Head;
    U032                CurDacAdr;
    DACVALIDATEARBSETTINGSARG_000   dacValidateArbSettingsArg;

    fifo_info   fifo_data;
    sim_state   sim_data;
    U008        lock0, lock1;
    U032        i;
    U032        M, N, O, P;

    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pVidLutCurDac0;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pVidLutCurDac1;

    //
    // Verify interface revision.
    //
    if (pDacUpdateArbSettingsArg->id != DAC_UPDATEARBSETTINGS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacUpdateArbSettingsArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;
    pMpHalInfo = pHalHwInfo->pMpHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacUpdateArbSettingsArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;
    Head = pDacHalObj->Head;

    pVidLutCurDac0 = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHalInfo->CrtcInfo[0].pVidLutCurDac;
    pVidLutCurDac1 = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHalInfo->CrtcInfo[1].pVidLutCurDac;

    //
    // Recalculate the current PCLK setting.  We might have changed modes
    // recently.
    //
    M = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _MDIV);
    N = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _NDIV);
    P = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _PDIV);
    O = 1;
    
    pDacHalInfo->VPllM = M;
    pDacHalInfo->VPllN = N;
    pDacHalInfo->VPllO = O;
    pDacHalInfo->VPllP = P;
    pDacHalInfo->VClk  = (N * pMcHalInfo->CrystalFreq / (1 << P) / M);

    // Make sure any uninitialized sim data starts with 0's
    for (i = 0; i < sizeof(sim_data); i++)
        ((U008 *)&sim_data)[i] = 0x0;

    RM_ASSERT(pDacHalInfo->CrtcInfo[Head].pVidLutCurDac);
    
    //
    // Check if we can support an overlay in this resolution.  If we can, set the default desktop timings
    // to assume we are running an overlay.
    //
    dacValidateArbSettingsArg.id = DAC_VALIDATEARBSETTINGS_000;
    dacValidateArbSettingsArg.pHalHwInfo = pHalHwInfo;
    dacValidateArbSettingsArg.bpp = (pDacHalInfo->CrtcInfo[Head].pVidLutCurDac)
                                  ? ((PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHalInfo->CrtcInfo[Head].pVidLutCurDac)->Dac[0].PixelDepth
                                  : 32;
    dacValidateArbSettingsArg.video_enabled = 1;
    dacValidateArbSettingsArg.mport_enabled = 0;
    dacValidateArbSettingsArg.vclk = pDacHalInfo->PixelClock * 10000;
    dacValidateArbSettingsArg.head = Head;

    nvHalDacValidateArbSettings_NV20(&dacValidateArbSettingsArg);
    if (dacValidateArbSettingsArg.result)
        sim_data.enable_video = 1;
    else
        sim_data.enable_video = 0;

    // Need to update the flag
    pVideoHalInfo->OverlayAllowed = sim_data.enable_video;

    //sim_data.pix_bpp      = (char)pDacHalInfo->Depth;
    //sim_data.enable_video = pDev->Video.Enabled ? 1 : 0;
    sim_data.enable_mp      = pMpHalInfo->Enabled ? 1 : 0;
    sim_data.memory_width   = pDacHalInfo->InputWidth;
    sim_data.mem_aligned    = 1;
    sim_data.memory_type    = (pFbHalInfo->RamType == BUFFER_DDRAM) ? 1 : 0; //1=DD,0=SD
    sim_data.mem_latency    = 3;
    sim_data.mem_page_miss  = 10;
    sim_data.gr_during_vid  = pVideoHalInfo->ColorKeyEnabled ? 1 : 0;
    sim_data.pclk_khz       = pDacHalInfo->VClk / 1000;     // in kHz, not MHz
    sim_data.mclk_khz       = pDacHalInfo->MClk / 1000;     // in kHz, not MHz
    sim_data.nvclk_khz      = pDacHalInfo->NVClk / 1000;    // in kHz, not MHz
 
    // 
    // Get those new numbers
    //
    fifo_data.crtc1_lwm = 0;
    fifo_data.crtc2_lwm = 0;
    fifo_data.video_lwm = 0;
    fifo_data.crtc1_burst_size = 0;
    fifo_data.crtc2_burst_size = 0;
    fifo_data.video_burst_size = 0;
    fifo_data.valid = 0;

    sim_data.enable_h1        = (pVidLutCurDac0)?1:0;    //1
    if (pVidLutCurDac0) {
        sim_data.pix_bpp      = pVidLutCurDac0->Dac[0].PixelDepth;          //May override below

        sim_data.hres         = pVidLutCurDac0->Dac[0].VisibleImageWidth;   //2048;
        sim_data.htotal       = pVidLutCurDac0->Dac[0].TotalWidth;          //2832;
        sim_data.vres         = pVidLutCurDac0->Dac[0].VisibleImageHeight;  //1536;
        sim_data.nativeVRes = (HAL_GETDISPLAYTYPE(0) == DISPLAY_TYPE_FLAT_PANEL)?pDacHalInfo->fpVMax:sim_data.vres;

        //LPL: copied math below, but I don't get it... *10000?
        sim_data.refresh      = (pVidLutCurDac0->Dac[0].PixelClock*10000) /
                                (pVidLutCurDac0->Dac[0].TotalWidth * pVidLutCurDac0->Dac[0].TotalHeight);    //75;

    //    sim_data.pix_bpp    =   32;
        sim_data.pclk_khz     =  pVidLutCurDac0->Dac[0].PixelClock * 10;    //3404772;
    } else {
        sim_data.hres         = 640;
        sim_data.htotal       = 832;
        sim_data.vres         = 480;
        sim_data.nativeVRes   = sim_data.vres;
        sim_data.refresh      = 85;     //75;
    //    sim_data.pix_bpp    = 32;
        sim_data.pclk_khz     = 36000;  //3404772;
    }
    
    sim_data.enable_h2    = (pVidLutCurDac1)?1:0;       //0
    if (pVidLutCurDac1) {
        sim_data.pix_bpp_h2   = pVidLutCurDac1->Dac[0].PixelDepth;          //May override below
        sim_data.hres2        = pVidLutCurDac1->Dac[0].VisibleImageWidth;   //1024;
        sim_data.htotal2      = pVidLutCurDac1->Dac[0].TotalWidth;          //1344;
        sim_data.vres2        = pVidLutCurDac1->Dac[0].VisibleImageHeight;  //768;
        sim_data.nativeVRes2  = (HAL_GETDISPLAYTYPE(1) == DISPLAY_TYPE_FLAT_PANEL)?pDacHalInfo->fpVMax:sim_data.vres2;

        //LPL: copied math below, but I don't get it... *10000?
        sim_data.refresh2     = (pVidLutCurDac1->Dac[0].PixelClock*10000) /
                                (pVidLutCurDac1->Dac[0].TotalWidth * pVidLutCurDac1->Dac[0].TotalHeight);    //60;

        sim_data.pclk2_khz    =   pVidLutCurDac1->Dac[0].PixelClock * 10;   //641088;
    } else {
        sim_data.hres2        = 640;
        sim_data.htotal2      = 832;
        sim_data.vres2        = 480;
        sim_data.nativeVRes2  = sim_data.vres2;
        sim_data.refresh2     = 85;     //75;
    //    sim_data.pix_bpp    = 32;
        sim_data.pclk2_khz    = 36000;  //3404772;
    }

    if (!sim_data.pix_bpp) sim_data.pix_bpp = 32;
    if (!sim_data.pix_bpp_h2) sim_data.pix_bpp_h2 = 32;

//    sim_data.enable_video =    1;
//    sim_data.enable_mp    =    0;

//    sim_data.memory_width =  128;
//    sim_data.memory_type  =    0;
//    sim_data.mclk_mhz     =  166;

    //
    // If the overlay is active, use the head that owns the video scaler,
    // otherwise, for calculating if the overlay is allowed, assume this
    // head.
    //
	if (pVideoHalInfo->ActiveVideoOverlayObject)
        sim_data.h2_owns_vs = pVideoHalInfo->Head;
    else
        sim_data.h2_owns_vs = Head;

    sim_data.video_source_hres = 720;
    sim_data.video_source_vres = 480;

    // 
	// Get those new numbers
	//
    NV20_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);
    
    // for now, assume pass
    //fifo_data.valid = 1;
	
//	For TV, we should not change some of these. Gfx Fifo Low Water Mark in particular should
//		not be changed. 
//    if (pDev->Framebuffer.DisplayType != DISPLAY_TYPE_TV) // leave alone if TV

    //
    // If valid settings found, update the hardware
    //
    if (fifo_data.valid)
    {
        //
        // Set the DAC FIFO Thresholds and burst size

#ifdef IKOS
        if (do_pvideo)
        {
#endif
        //
        // Check overlay capabilities.
        //
        //if (!NV20_dacCalculateVideoCaps(pDev))
        //    pDev->Video.HalInfo.OverlayAllowed = 0;


        // Eliminate delay between memory requests by the video scalar
        REG_WR32(NV_PVIDEO_DEBUG_1, 0);

        //Final clipping -- check with Jeff to see if the values are already 'safe'
        fifo_data.video_burst_size /= 32;
        if (!fifo_data.video_burst_size) fifo_data.video_burst_size = 1;
        if (fifo_data.video_burst_size > 16) fifo_data.video_burst_size = 16;
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST1, fifo_data.video_burst_size);
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST2, fifo_data.video_burst_size);

        fifo_data.video_lwm /= 16;
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK1, fifo_data.video_lwm);
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK2, fifo_data.video_lwm);

#ifdef IKOS
        }
#endif

        //
        // Update the CRTC watermarks
        //
        if (pVidLutCurDac0)
        {
            // Unlock CRTC extended regs
            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock0, 0);
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 0);

            //
            // Set the CRTC watermarks and burst size
            //
            fifo_data.crtc1_lwm /= 8;
            if (fifo_data.crtc1_lwm > 511) fifo_data.crtc1_lwm = 511;
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, (fifo_data.crtc1_lwm & 0xff), 0);
            if (fifo_data.crtc1_lwm > 255)
            {
                HAL_CRTC_WR(NV_CIO_CRE_FFLWM_MSB_INDEX, 1, 0);
            }
            else
            {
                HAL_CRTC_WR(NV_CIO_CRE_FFLWM_MSB_INDEX, 0, 0);
            }

            fifo_data.crtc1_burst_size /= 32;
            if (fifo_data.crtc1_burst_size) fifo_data.crtc1_burst_size--;
            if (!fifo_data.crtc1_burst_size) fifo_data.crtc1_burst_size++;
            if (fifo_data.crtc1_burst_size >= (2048/32)) fifo_data.crtc1_burst_size = 2048/32 - 1;
            HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, fifo_data.crtc1_burst_size, 0);

            // Relock if necessary
            if (lock0 == 0)
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, 0);
        }

        if (pVidLutCurDac1)
        {
            // Unlock CRTC extended regs
            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock1, 1);
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 1);

            //
            // Set the CRTC watermarks and burst size
            //
            fifo_data.crtc2_lwm /= 8;
            if (fifo_data.crtc2_lwm > 511) fifo_data.crtc2_lwm = 511;
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, (fifo_data.crtc2_lwm & 0xff), 1);
            if (fifo_data.crtc2_lwm > 255)
            {
                HAL_CRTC_WR(NV_CIO_CRE_FFLWM_MSB_INDEX, 1, 1);
            }
            else
            {
                HAL_CRTC_WR(NV_CIO_CRE_FFLWM_MSB_INDEX, 0, 1);
            }

            fifo_data.crtc2_burst_size /= 32;
            if (fifo_data.crtc2_burst_size) fifo_data.crtc2_burst_size--;
            if (!fifo_data.crtc2_burst_size) fifo_data.crtc2_burst_size++;
            if (fifo_data.crtc2_burst_size >= (2048/32)) fifo_data.crtc2_burst_size = 2048/32 - 1;
            HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, fifo_data.crtc2_burst_size, 1);

            // Relock if necessary
            if (lock1 == 0)
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, 1);
        }

        //
        // Relock if necessary
        //
        return (RM_OK);
    }
    else    //if (fifo_data.valid)
    {
        //
        // No valid setting was found!!!
        //
        //  Make a conservative guess and fail.
        //
        
        // Unlock CRTC extended regs
        if (pVidLutCurDac0)
        {
            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock0, 0);
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 0);
        
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 0x72, 0);
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM_MSB_INDEX, 0, 0);
            HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 1024/32 - 32, 0);

            if (lock0 == 0)
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, 0);
        }
        if (pVidLutCurDac1)
        {
            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock1, 1);
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 1);
        
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 0x72, 1);
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM_MSB_INDEX, 0, 1);
            HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 1024/32 - 32, 1);

            if (lock1 == 0)
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, 1);
        }
        
        return (RM_ERROR);
    }
}

RM_STATUS
nvHalDacHotPlugInterrupts_NV20(VOID * pArgs)
{
    return RM_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dac\nv4\dacnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Arbitration **************************\
*                                                                           *
* Module: DACARB.C                                                          *
*   The DAC Arbitration management.                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvhw.h"
#include <vga.h>

/* This file simulates the NV arbitor */
#include <arb_fifo.h>
#include "nvhalcpp.h"

//////////////////////////////////////////
//
// Arbitration routines
//

//
// Calculate the closest arbitration values for a given system configuration
//

static
VOID NV04_dacCalculateArbitration
(
    PHALHWINFO pHalHwInfo,
    fifo_info *fifo,
    sim_state  *arb
)
{
    PFBHALINFO      pFbHalInfo = pHalHwInfo->pFbHalInfo;
    PMCHALINFO      pMcHalInfo = pHalHwInfo->pMcHalInfo;
    PVIDEOHALINFO   pVideoHalInfo = pHalHwInfo->pVideoHalInfo;

    int data, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
    int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
    int nvclk_fill, us_extra, clwm_mt;
    int found, mclk_extra, mclk_loop, cbs, m1;
    int mclk_freq, pclk_freq, nvclk_freq, mp_enable;
    int us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;
    int vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt,clwm;
    int craw, vraw, m2us, us_pipe, p1clk, p2;
    int h_size, v_size;
    int ram_conf;
  
    fifo->valid = 1;
    pclk_freq = arb->pclk_khz; // freq in KHz
    mclk_freq = arb->mclk_khz;
    nvclk_freq = arb->nvclk_khz;
    pagemiss = arb->mem_page_miss;
    cas = arb->mem_latency;
    width = arb->memory_width/64;
    video_enable = arb->enable_video;
    color_key_enable = arb->gr_during_vid;
    bpp = arb->pix_bpp;
    align = arb->mem_aligned;
    mp_enable = arb->enable_mp;
    clwm = 0;
    vlwm = 0;

    h_size   = pFbHalInfo->HorizDisplayWidth;
    v_size   = pFbHalInfo->VertDisplayWidth;
    ram_conf = arb->ram_config;

    // NV4 can not support 256 burst
    if (IsNV4_NV04(pMcHalInfo))
        cbs = 128;
    else
        cbs = 256;

    pclks = 2;   // lwm detect.

    nvclks = 2;  // lwm -> sync.
    nvclks += 2; // fbi bus cycles (1 req + 1 busy)
    nvclks += 1; // fbi reqsync

    mclks = 5;  // Fifo
    mclks += 3; // MA0 -> MA2
    mclks += 1; // pad->out
    mclks += cas; // Cas Latency.
    mclks += 1; // pad in
    mclks += 1; // latch data
    mclks += 1; // fifo load
    mclks += 1; // fifo write
  
  
    if ((video_enable) && (arb->memory_width == 128))
        mclk_extra = 3; // Margin of error
    else    
        mclk_extra = 17; // Margin of error

    nvclks += 2; // fifo sync
    nvclks += 1; // read data
    nvclks += 1; // fbi_rdata
    nvclks += 1; // crtfifo load

    if(mp_enable)
        mclks+=4; // Mp can get in with a burst of 8.
        
    // Extra clocks determined by heuristics
    nvclks += 0;
    pclks += 0;
    found = 0;
    while(found != 1) 
    {
        fifo->valid = 1;
        found = 1;
        mclk_loop = mclks+mclk_extra;
        us_m = mclk_loop *1000*1000 / mclk_freq;    // Mclk latency in us
        us_n = nvclks*1000*1000 / nvclk_freq;       // nvclk latency in us
        us_p = nvclks*1000*1000 / pclk_freq;        // nvclk latency in us
        us_pipe = us_m + us_n + us_p;
        us_extra = 0;
        if(video_enable) 
        {
            video_drain_rate = pclk_freq * 2;       // MB/s
            crtc_drain_rate = pclk_freq * bpp/8;    // MB/s

            vpagemiss = 1; // self generating page miss
            vpagemiss += 1; // One higher priority before

            crtpagemiss = 2; // self generating page miss

            vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;


            if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
                video_fill_us = 256*1000*1000 / 16 / nvclk_freq ;
            else
                video_fill_us = 256*1000*1000 / (8 * width) / mclk_freq;

            us_video = vpm_us + us_m + us_n + us_p + video_fill_us;

            vlwm = us_video * video_drain_rate/(1000*1000);
            vlwm+=2; // fixed point <= float_point - 1.  Fixes that
            vbs = 128;

            //
            // Video tweaking specific to Canopus
            //
            if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
            {
                //
                // Canopus specific code
                //      
                if (IsNV4_NV04(pMcHalInfo))
                {
                    if(bpp == 32)
                    {
                        if(vlwm > 110)
                            vbs = 64;
                        if(vlwm > (256-64))
                            vbs = 32;
                    }
                    else
                    {
                        if(vlwm > 110)
                            vbs = 64;
                        if(vlwm > (256-27)) // 229
                            vbs = 32;
                    }
                }
                else
                {
                    if(bpp == 32)
                    {
                        if(vlwm > 77)
                            vbs = 64;
                        if(vlwm > (256-64)) // 192
                            vbs = 32;
                    }
                    else
                    {
                        if(vlwm > 135)      // 146)
                            vbs = 64;
                        if(vlwm > 201)
                            vbs = 32;
                    }
                }

            } else {
                //
                // Generic code
                //
                if(vlwm > 256 - 64)
                    vbs = 32;
                else if(vlwm > 146) 
                    vbs = 64;
            }        

            if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
                video_fill_us = vbs *1000*1000/ 16 / nvclk_freq ;
            else
                video_fill_us = vbs*1000*1000 / (8 * width) / mclk_freq;

            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
            us_crt =
              us_video  // Wait for video
              +video_fill_us // Wait for video to fill up
              +cpm_us // CRT Page miss
              +us_m + us_n +us_p // other latency
              ;
              
            clwm = us_crt * crtc_drain_rate/(1000*1000);
            clwm++; // fixed point <= float_point - 1.  Fixes that

            //
            // Video tweaking specific to Canopus
            //
            if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
            {
                if(ram_conf == 0x0003)  
                {
                    clwm -= 32;     // SPECTRA Lite 
                    if(bpp == 32)
                        clwm -= 72; // SPECTRA Lite 
                }
            }

        } 
        else    // !video_enable
        {
        
            crtc_drain_rate = pclk_freq * bpp/8; // bpp * pclk/8

            crtpagemiss = 1; // self generating page miss
            crtpagemiss += 1; // MA0 page miss
            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
            us_crt =  cpm_us + us_m + us_n + us_p ;
            clwm = us_crt * crtc_drain_rate/(1000*1000);
            clwm++; // fixed point <= float_point - 1.  Fixes that
    
            //
            // Another concern, only for high pclks so don't do this
            // with video:
            // What happens if the latency to fetch the cbs is so large that
            // fifo empties.  In that case we need to have an alternate clwm value
            // based off the total burst fetch
            //
            us_crt = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
            us_crt = us_crt + us_m + us_n + us_p + (4 * 1000 * 1000)/mclk_freq;
            clwm_mt = us_crt * crtc_drain_rate/(1000*1000); 
            clwm_mt ++;
            if(clwm_mt > clwm)
                clwm = clwm_mt;
                
            //    
            // Finally, a heuristic check when width == 64 bits
            //
            if(width == 1)
            {
                nvclk_fill = nvclk_freq * 8;
                if(crtc_drain_rate * 100 >= nvclk_fill * 102) 
                    clwm = 0xfff; //Large number to fail
                else if (crtc_drain_rate * 100  >= nvclk_fill * 98) 
                {
                    clwm = 512;
                    cbs = 256;
                    us_extra = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
                    //if(crtc_drain_rate * 100 >= nvclk_fill * 102) 
                    //    clwm = 0xfff; //Large number to fail
                }
            }         
        }
    
    
        //
        // Overfill check:
        //

        m1 = clwm + cbs -  512; /* Amount of overfill */

        //
        // Video tweaking specific to Canopus
        //
        if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
        {
            p2 = m1 * pclk_freq / mclk_freq;  // pclk cycles to drain
            p2 = p2 * bpp / 8;                // bytes drained.
        }
        else
        {
            // Generic coding
            //      
            m2us = us_pipe + us_extra;
            p1clk = m2us * pclk_freq/(1000*1000); /* pclk cycles to drain */
            p2 = p1clk * bpp / 8; // bytes drained.
        }   
           
        if((p2 < m1) && (m1 > 0)) 
        {
            fifo->valid = 0;
            found = 0;
            if (video_enable)
            {
                if(cbs <= 32) 
                    found = 1;      // Can't adjust anymore!
                else
                    cbs = cbs/2;    // reduce the burst size
            } 
            else
            {
            
                //
                // Video tweaking specific to Canopus
                //
                if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
                {
                    if(mclk_extra ==0)   
                        found = 1; // Can't adjust anymore!
                    mclk_extra--;
                }
                else
                {         
                    //
                    // Generic coding
                    //   
                    if(mclk_extra ==0)   
                    {
                        if(cbs <= 32) 
                            found = 1;      // Can't adjust anymore!
                        else
                            cbs = cbs/2;    // reduce the burst size
                    } 
                    else 
                        mclk_extra--;
                }            
            }            
        }
        else if (video_enable)
        {

            //
            // Canopus specific code
            //
            if (IsNV4_NV04(pMcHalInfo) && (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS))
            {
                if ((clwm > 621) || (vlwm > 255)) 
                {
                    fifo->valid = 0;
                    found = 0;
                    if(mclk_extra == 0)   
                        found = 1; // Can't adjust anymore!
                    mclk_extra--;
                }
            }
            else
            {
                //
                // Generic coding
                //
                if ((clwm > 511) || (vlwm > 255)) 
                {
                    fifo->valid = 0;
                    found = 0;
                    if(mclk_extra <= 5)   
                        found = 1; // Can't adjust anymore!
                    mclk_extra--;
                }
            }            
            
        } 
        else 
        {  
            if (clwm > 519)
            { // Have some margin
                fifo->valid = 0;
                found = 0;
                if(mclk_extra ==0)   
                    found = 1; // Can't adjust anymore!
                mclk_extra--;
            }
        }
        
        craw = clwm;
        vraw = vlwm;
        //if(clwm < 256) clwm = 256;
        if (clwm < (512-cbs)) 
            clwm = 512-cbs;

        //
        // Video tweaking specific to Canopus
        //
        if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
        {    
            if (IsNV4_NV04(pMcHalInfo))
            {
                if (vlwm < 128)
                {
                    if (bpp == 32)
                    {
                        if (h_size == 1408)
                        {
                            vlwm = 176;
                            vbs = 64;
                        }
                        else if (h_size == 1024)
                        {
                            vlwm = 144;
                            vbs = 64;
                        }
                        else if (h_size < 1024)
                        {
                            vlwm = 128-16;
                        }
                        else
                        {
                            vlwm = 160;
                            vbs = 64;
                        }
                    }
                    else
                        vlwm = 128;
                }
            }
            else
            {
                if (vlwm < 128)
                {
                    if (bpp == 32)  
                    {
                        if (h_size >= 1152)
                        {
                            vlwm = 176;
                            vbs = 64;
                        }
                        else
                            vlwm = 144-16;
                    }
                    else
                        vlwm = 128;
                }

                if ((!video_enable) && (ram_conf == 0x0003))    
                {
                    if (bpp == 32)
                    {
                        if ((h_size >= 1024) && (h_size <= 1408))
                            clwm += 88;     // SPECTRA Lite 
                        else if (h_size == 960)
                            clwm += 48;
                        else
                            clwm += 32;
                    }
                    else if ((bpp == 16) && (h_size == 1920) && (v_size == 1440))
                    {
                        clwm += 8;
                    }
                }

                if (cbs == 256)    
                {
                    if (clwm > 271)    
                        clwm -= 16;
                    if ((!video_enable) && (ram_conf == 0x0003))    
                    {
                        if (clwm > 400)     // SP Lite
                            clwm = 400;
                    }
                    else
                    {
                        if (clwm > 384)     
                            clwm = 384; // 400;
                    }
                }

                // For 1920x1440x32 of Spectra5400PE
                if ((!video_enable) && (ram_conf != 0x0003) && (clwm < 384) &&
                    (h_size == 1920) && (v_size == 1440) && (bpp == 32))
                {
                    clwm = 384;
                }

            }
            
            if(clwm > 511)
                clwm = 511;
        } 
        else
        {    
            //
            // Generic coding
            //
            if(vlwm < 128) 
                vlwm = 128;
        }        
    
    
        if(vlwm < 128) vlwm = 128;
    
        data = (int)(clwm);
        //  printf("CRT LWM: %f bytes, prog: 0x%x, bs: 256\n", clwm, data );
        fifo->crtc1_lwm = data;   fifo->crtc1_burst_size = cbs;
        //    fifo->craw = craw;

        //
        // Video tweaking specific to Canopus
        //
        if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
        {    
            if (IsNV4_NV04(pMcHalInfo))
                data = (int)((vlwm+24));
            else
                data = (int)((vlwm+24));        // 15));

            if (data > 255)
                data = 255;
        }
        else      
        {
            // Generic coding    
            //
            data = (int)((vlwm+15));
            
            // Preset ranges for vlwm and vbs based on calculated vlwm
            if (vlwm > 256-32) 
            {
                data = 256;
                vbs = 32;
            } 
            else if (vlwm > 256-64) 
            {
                data = 256-32+16;
                vbs = 32;
            } 
            else if (vlwm > 256-128) 
            {
                data = 256-64+16;
                vbs = 64;
            } 
            else 
            {
                data = 256-128+16;
                vbs = 128;
            }
            
        }        

        //  printf("VID LWM: %f bytes, prog: 0x%x, bs: %d\n, ", vlwm, data, vbs );
        fifo->video_lwm = data;  
        fifo->video_burst_size = vbs;
    }
}


static
void NV04_dacCalculateArbitration_SMA
(
    PHALHWINFO pHalHwInfo,
    fifo_info *fifo,
    sim_state  *arb
)
{
    PFBHALINFO  pFbHalInfo = pHalHwInfo->pFbHalInfo;

    int data, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
    int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
    int nvclk_fill, us_extra, clwm_mt;
    int found, mclk_extra, mclk_loop, cbs, m1;
    int mclk_freq, pclk_freq, nvclk_freq, mp_enable;
    int us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;
    int vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt,clwm;
    int craw, vraw, m2us, us_pipe, p1clk, p2;
    int h_size, v_size;
    int ram_conf;
  
  
    fifo->valid = 1;
    pclk_freq = arb->pclk_khz; // freq in KHz
    //mclk_freq = arb->mclk_khz;
    mclk_freq = 100000;
    nvclk_freq = arb->nvclk_khz;
    //pagemiss = arb->mem_page_miss;
    pagemiss = 7;
    //cas = arb->mem_latency;
    cas = 3;
    width = 1;
    video_enable = arb->enable_video;
    color_key_enable = arb->gr_during_vid;
    bpp = arb->pix_bpp;
    align = arb->mem_aligned;
    mp_enable = arb->enable_mp;
    clwm = 0;
    vlwm = 0;

    h_size   = pFbHalInfo->HorizDisplayWidth;
    v_size   = pFbHalInfo->VertDisplayWidth;
    ram_conf = arb->ram_config;

    // NV4 can not support 256 burst
    //if (IsNV4(pDev))
    if (/*IsNV4(pDev)*/ 1)
        cbs = 128;
    else
        cbs = 256;

    pclks = 2;   // lwm detect.

    nvclks = 2;  // lwm -> sync.
    nvclks += 2; // fbi bus cycles (1 req + 1 busy)
    nvclks += 1; // fbi reqsync

    mclks = 5;  // Fifo
    mclks += 3; // MA0 -> MA2
    mclks += 4; // prev burst
    mclks += 2; // ALI arb
    mclks += 1; // pad->out
    mclks += cas; // Cas Latency.
    mclks += 1; // pad in
    mclks += 2; // ALI rd pipe
    mclks += 1; // latch data
    mclks += 1; // fifo load
    mclks += 1; // fifo write
  
  
    if ((video_enable) && (arb->memory_width == 128))
        mclk_extra = 12; // Margin of error
    else    
        mclk_extra = 17; // Margin of error

    nvclks += 2; // fifo sync
    nvclks += 1; // read data
    nvclks += 1; // fbi_rdata
    nvclks += 1; // crtfifo load

    if(mp_enable)
        mclks+=4; // Mp can get in with a burst of 8.
        
    // Extra clocks determined by heuristics
    nvclks += 0;
    pclks += 0;
    found = 0;
    while(found != 1) 
    {
        fifo->valid = 1;
        found = 1;
        mclk_loop = mclks+mclk_extra;
        us_m = mclk_loop *1000*1000 / mclk_freq; // Mclk latency in us
        us_n = nvclks*1000*1000 / nvclk_freq;// nvclk latency in us
        us_p = nvclks*1000*1000 / pclk_freq;// nvclk latency in us
        us_pipe = us_m + us_n + us_p;
        us_extra = 0;
        if(video_enable) 
        {
            video_drain_rate = pclk_freq * 2; // MB/s
            crtc_drain_rate = pclk_freq * bpp/8; // MB/s

            vpagemiss = 1; // self generating page miss
            vpagemiss += 1; // One higher priority before

            crtpagemiss = 2; // self generating page miss

            vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;


            if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
                video_fill_us = 256*1000*1000 / 16 / nvclk_freq ;
            else
                video_fill_us = 256*1000*1000 / (8 * width) / mclk_freq;

            us_video = vpm_us + us_m + us_n + us_p + video_fill_us;

            vlwm = us_video * video_drain_rate/(1000*1000);
            vlwm+=2; // fixed point <= float_point - 1.  Fixes that
            vbs = 128;

            //
            // Generic code
            //
            if(vlwm > 256 - 64)
                vbs = 32;
            else if(vlwm > 146) 
                vbs = 64;

            if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
                video_fill_us = vbs *1000*1000/ 16 / nvclk_freq ;
            else
                video_fill_us = vbs*1000*1000 / (8 * width) / mclk_freq;

            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
            us_crt =
              us_video  // Wait for video
              +video_fill_us // Wait for video to fill up
              +cpm_us // CRT Page miss
              +us_m + us_n +us_p // other latency
              ;
              
            clwm = us_crt * crtc_drain_rate/(1000*1000);
            clwm++; // fixed point <= float_point - 1.  Fixes that

        } 
        else    // !video_enable
        {
            crtc_drain_rate = pclk_freq * bpp/8; // bpp * pclk/8

            crtpagemiss = 1; // self generating page miss
            crtpagemiss += 1; // MA0 page miss
            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
            us_crt =  cpm_us + us_m + us_n + us_p ;
            clwm = us_crt * crtc_drain_rate/(1000*1000);
            clwm++; // fixed point <= float_point - 1.  Fixes that
    
            //
            // Another concern, only for high pclks so don't do this
            // with video:
            // What happens if the latency to fetch the cbs is so large that
            // fifo empties.  In that case we need to have an alternate clwm value
            // based off the total burst fetch
            //
            us_crt = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
            us_crt = us_crt + us_m + us_n + us_p + (4 * 1000 * 1000)/mclk_freq;
            clwm_mt = us_crt * crtc_drain_rate/(1000*1000); 
            clwm_mt ++;
            if(clwm_mt > clwm)
                clwm = clwm_mt;
                
            //    
            // Finally, a heuristic check when width == 64 bits
            //
            if(width == 1)
            {
                nvclk_fill = nvclk_freq * 8;
                if(crtc_drain_rate * 100 >= nvclk_fill * 102) 
                    clwm = 0xfff; //Large number to fail
                else if (crtc_drain_rate * 100  >= nvclk_fill * 98) 
                {
                    clwm = 512;
                    cbs = 256;
                    us_extra = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
                    //if(crtc_drain_rate * 100 >= nvclk_fill * 102) 
                    //    clwm = 0xfff; //Large number to fail
                }
        }         
        }
    
        //
        // Overfill check:
        //

        m1 = clwm + cbs -  512; /* Amount of overfill */

        // Generic coding
        //      
        m2us = us_pipe + us_extra;
        p1clk = m2us * pclk_freq/(1000*1000); /* pclk cycles to drain */
        p2 = p1clk * bpp / 8; // bytes drained.
           
        if((p2 < m1) && (m1 > 0)) 
        {
            fifo->valid = 0;
            found = 0;
            if (video_enable)
            {
                if(cbs <= 32) 
                    found = 1;      // Can't adjust anymore!
                else
                    cbs = cbs/2;    // reduce the burst size
            } 
            else
            {
            
                //
                // Generic coding
                //   
                if(mclk_extra ==0)   
                {
                    if(cbs <= 32) 
                        found = 1;      // Can't adjust anymore!
                    else
                        cbs = cbs/2;    // reduce the burst size
                } 
                else 
                    mclk_extra--;
            }            
        }
        else if (video_enable)
        {

            //
            // Generic coding
            //
            if ((clwm > 511) || (vlwm > 255)) 
            {
                fifo->valid = 0;
                found = 0;
                if(mclk_extra <= 5)   
                    found = 1; // Can't adjust anymore!
                mclk_extra--;
            }
            
        } 
        else 
        {  
            if (clwm > 519)
            { // Have some margin
                fifo->valid = 0;
                found = 0;
                if(mclk_extra ==0)   
                    found = 1; // Can't adjust anymore!
                mclk_extra--;
            }
        }
        
        craw = clwm;
        vraw = vlwm;
        //if(clwm < 256) clwm = 256;
        if (clwm < (512-cbs)) 
            clwm = 512-cbs;

        //
        // Generic coding
        //
        if(vlwm < 128) 
            vlwm = 128;
    
    
        if(vlwm < 128) vlwm = 128;
    
        data = (int)(clwm);
        //  printf("CRT LWM: %f bytes, prog: 0x%x, bs: 256\n", clwm, data );
        fifo->crtc1_lwm = data;   fifo->crtc1_burst_size = cbs;
        if (data > 511) fifo->valid = 0;
        //    fifo->craw = craw;

        //
        // Video tweaking 
        //
        data = (int)((vlwm+15));
        
        // Preset ranges for vlwm and vbs based on calculated vlwm
        if (vlwm > 256-32) 
        {
            data = 256;
            vbs = 32;
        } 
        else if (vlwm > 256-64) 
        {
            data = 256-32+16;
            vbs = 32;
        } 
        else if (vlwm > 256-128) 
        {
            data = 256-64+16;
            vbs = 64;
        } 
        else 
        {
            data = 256-128+16;
            vbs = 128;
        }
            

        if (data > 255) fifo->valid = 0;

        //  printf("VID LWM: %f bytes, prog: 0x%x, bs: %d\n, ", vlwm, data, vbs );
        fifo->video_lwm = data;  
        fifo->video_burst_size = vbs;
    }
}


typedef struct tagNV04_DacAGPClockEntry
{
    U032 frequency;
    U032 setting;
} NV04_DacAGPClockEntry;

NV04_DacAGPClockEntry NV04_dacAGPClockTable[] =
{
    { 133000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_133MHZ },
    { 126000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_126MHZ },
    { 120000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_120MHZ },
    { 113000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_113MHZ },
    { 106000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_106MHZ },
    { 100000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_100MHZ },
    { 94000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_94MHZ },
    { 87000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_87MHZ },
    { 80000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_80MHZ },
    { 73000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_73MHZ },
    { 66000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ },
    { 0, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ - 1 }
};

//
// HAL stuff
//
 
// forwards
RM_STATUS nvHalDacAlloc_NV04(VOID *);
RM_STATUS nvHalDacFree_NV04(VOID *);
RM_STATUS nvHalDacControl_NV04(VOID *);
RM_STATUS nvHalDacUpdateStartAddress_NV04(VOID *);
RM_STATUS nvHalDacProgramMClk_NV04(VOID *);
RM_STATUS nvHalDacProgramNVClk_NV04(VOID *);
RM_STATUS nvHalDacProgramPClk_NV04(VOID *);
RM_STATUS nvHalDacProgramCursorImage_NV04(VOID *);
RM_STATUS nvHalDacGetRasterPosition_NV04(VOID *);
RM_STATUS nvHalDacValidateBandwidth_NV04(VOID *arg);
RM_STATUS nvHalDacValidateArbSettings_NV04(VOID *arg);
RM_STATUS nvHalDacUpdateArbSettings_NV04(VOID *arg);

//
// nvHalDacControl
//
RM_STATUS
nvHalDacControl_NV04(VOID *arg)
{
    PDACCONTROLARG_000 pDacControlArg = (PDACCONTROLARG_000)arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PFBHALINFO  pFbHalInfo;
    PMCHALINFO  pMcHalInfo;
    PVIDEOHALINFO pVideoHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PDACHALINFO_NV04    pDacHalPvtInfo;

    //
    // Verify interface revision.
    //
    if (pDacControlArg->id != DAC_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacControlArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pDacHalPvtInfo = (PDACHALINFO_NV04)pHalHwInfo->pDacHalPvtInfo;

    switch (pDacControlArg->cmd)
    {
        case DAC_CONTROL_INIT:
            //
            // Set bus width.
            //
            if (REG_RD_DRF(_PFB, _BOOT_0, _RAM_WIDTH_128) == NV_PFB_BOOT_0_RAM_WIDTH_128_ON)
                pDacHalInfo->InputWidth = 128;
            else
                pDacHalInfo->InputWidth = 64;

            //
            // Initialize video clock.
            //
            pDacHalInfo->VClk = 0;

            //
            // Determine the maximum pixel clock for 8bpp, 16bpp, and 32bpp for this configuration.
            //
            // This will rely on silicon DAC speed, memory bandwidth, and arbitration limits.
            //
            // For now, hardcode the known values.
            //
            if (IsNV4_NV04(pMcHalInfo))
            {
                pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 215000000;
            }
            else if (IsNV5_NV04(pMcHalInfo))
            {
                switch (REG_RD_DRF(_PBUS, _PCI_NV_0, _DEVICE_ID_FUNC))
                {
                    // Std TNT2
                    case NV_PBUS_PCI_NV_0_DEVICE_ID_FUNC_VGA:
                    // Std Ultra
                    case NV_PBUS_PCI_NV_0_DEVICE_ID_FUNC_ALT1:
                    // Std TNT2 Model64
                    case NV_PBUS_PCI_NV_0_DEVICE_ID_FUNC_LC1:
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 300000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 300000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 250000000;
                        break;

                    // Std Vanta
                    case NV_PBUS_PCI_NV_0_DEVICE_ID_FUNC_LC0:
                        //
                        // VantaLT check; drop the clocks for those chips below 100MHz
                        //
                        if (pDacHalInfo->NVClk < 100000000)
                        {
                            pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                            pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                            pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 162000000;  //32bpp hard limit at 162MHz
                        } 
                        else // regular Vanta
                        {
                            pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                            pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                            pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 203000000;
                        }
                        break;

                    // Default
                    default:
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 215000000;
                        break;
                } 

                // 
                // If we're running in SMA mode, drop down the limits accordingly
                //
                if (pFbHalInfo->RamType == BUFFER_CRUSH_UMA)
                {
                    //
                    // Determine how much bandwidth we probably have to system memory
                    //
                    if (pProcessorHalInfo->SystemMemoryFreq == 133000000)
                    {
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 300000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 300000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 162000000;
                    }
                    else if (pProcessorHalInfo->SystemMemoryFreq == 100000000)
                    {
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 126000000;
                    }
                    else // (pProcessorHalInfo->SystemMemoryFreq == 66000000)
                    {
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 162000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 162000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp =  85000000;
                    }
                }

            }
            else
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: unknown chip; using pixelclock defaults\n");
                // defaults
                pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 215000000;
            }
            pDacHalInfo->CrtcInfo[0].RegOffset = 0x00000000;

            //
            // All display types allowed.
            //
            pDacHalInfo->CrtcInfo[0].DisplayTypesAllowed =
                DISPLAYTYPEBIT(DISPLAY_TYPE_MONITOR) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_TV) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_DUALSURFACE) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_FLAT_PANEL);

            //
            // No downscaling on nv4 and family...
            // 
            pVideoHalInfo->OverlayMaxDownscale_768  = 1;
            pVideoHalInfo->OverlayMaxDownscale_1280 = 1;
            pVideoHalInfo->OverlayMaxDownscale_1920 = 1;

            break;
        case DAC_CONTROL_DITHER_DISABLE:
            return (RM_ERR_BAD_ARGUMENT);
        case DAC_CONTROL_DITHER_ENABLE:
            return (RM_ERR_BAD_ARGUMENT);
        case DAC_CONTROL_LOAD:
        case DAC_CONTROL_UNLOAD:
        case DAC_CONTROL_DESTROY:
        case DAC_CONTROL_UPDATE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

RM_STATUS
nvHalDacAlloc_NV04(VOID *arg)
{
    PDACALLOCARG_000 pDacAllocArg = (PDACALLOCARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDacAllocArg->id != DAC_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    return (RM_OK);
}

RM_STATUS
nvHalDacFree_NV04(VOID *arg)
{
    PDACFREEARG_000 pDacFreeArg = (PDACFREEARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDacFreeArg->id != DAC_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);    

    return (RM_OK);
}

RM_STATUS
nvHalDacSetStartAddr_NV04(VOID *arg)
{
    PDACSETSTARTADDRARG_000 pDacSetStartAddrArg = (PDACSETSTARTADDRARG_000)arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032 StartAddress = pDacSetStartAddrArg->startAddr;
    U032 prev_bit24, curr_bit24;
    U008 lock, crtc_index, temp;
    U032 CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo
    //
    // Verify interface revision.
    //
    if (pDacSetStartAddrArg->id != DAC_SET_START_ADDR_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacSetStartAddrArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT)pDacSetStartAddrArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;
    
    // Only NV5 needs special treatment regarding PCRTC_START
    if (!IsNV5_NV04(pHalHwInfo->pMcHalInfo))
    {
        REG_WR32(NV_PCRTC_START, StartAddress);
        return (RM_OK);
    }

    //
    // NV5 Bug. Eventhough bit24 should be writable in PCRTC_START, it's not.
    // So, if we need to change its value (i.e. bit24 goes from 0->1 or 1->0),
    // then we'll set/clear bit24 value via the CRE_HEB CRTC reg.
    //
    prev_bit24 = REG_RD32(NV_PCRTC_START) & 0x1000000;
    curr_bit24 = StartAddress & 0x1000000;

    // For NV5, this will properly write bits 23:0
    REG_WR32(NV_PCRTC_START, StartAddress);
    if (prev_bit24 ^ curr_bit24)
    {
        // Save the current CRTC index
        if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)          // color or mono?
            crtc_index = REG_RD08(NV_PRMCIO_CRX__COLOR);    // save crtc index
        else
            crtc_index = REG_RD08(NV_PRMCIO_CRX__MONO);     // save crtc index

        // Unlock CRTC extended regs (following is from ReadCRTCLock)
        // lock = ReadCRTCLock(pDev);
        CRTC_READ(NV_CIO_SR_LOCK_INDEX, temp);
        switch (temp)
        {
            case 0x03:
                lock = 0x57;
                break;
            case 0x01:
                lock = 0x75;
                break;
            case 0x00:
                lock = 0x99;
                break;
            default:
                lock = temp;
                break;
        }
        CRTC_WRITE(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE);

        // bit6 corresponds to StartAddress bit24. All other
        // bits were successfully written via PCRTC_START.
        CRTC_READ(NV_CIO_CRE_HEB__INDEX, temp);
        temp &= 0xBF;                           // mask off bit6
        temp |= ((curr_bit24 >> 24) << 6);      // set/clear bit6
        CRTC_WRITE(NV_CIO_CRE_HEB__INDEX, temp);

        // Relock extended regs
        CRTC_WRITE(NV_CIO_SR_LOCK_INDEX, lock);
        // Restore index
        if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)
            REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index);     // restore crtc index
        else
            REG_WR08(NV_PRMCIO_CRX__MONO, crtc_index);      // restore crtc index
    }

    return (RM_OK);
}

//  Read extended CRTC lock register and return corresponding write value
static U008 ReadCRTCLock_NV04
(
    PHALHWINFO pHalHwInfo,
    U032    Head
)
{
    U008 data;

    HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, data, Head);
    switch (data)
    {
        case 0x03:
            data = 0x57;
            break;
        case 0x01:
            data = 0x75;
            break;
        case 0x00:
            data = 0x99;
            break;
    }
    return data;
}

//
// nvHalDacProgramMClk_NV04 - Program MCLK based on the value in pDev->Dac.HalInfo.MClk
//
// This routine uses the value in pDev->Dac.HalInfo.MClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramMClk_NV04(VOID *arg)
{
    PDACPROGRAMMCLKARG_000 pDacProgramMClkArg = (PDACPROGRAMMCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 temp;
    U032 oldMClk;
    U032 oldCyclesPerRefresh;
    U032 oldPeriod;
    U032 newCyclesPerRefresh;
    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramMClkArg->id != DAC_PROGRAMMCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramMClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;

    mNew = pDacHalInfo->MPllM;
    nNew = pDacHalInfo->MPllN;
    pNew = pDacHalInfo->MPllP;

    // Program the hardware

    // Retrieve original coefficients
    coeff = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
    mOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first
        REG_WR32
            (
                NV_PRAMDAC_MPLL_COEFF,
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _PDIV, pOld)
            );

        // Read the register to give the PLL enough time to adjust
        temp = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
    }

    // Now we can write the final value
    REG_WR32
        (
            NV_PRAMDAC_MPLL_COEFF,
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _PDIV, pNew)
        );

    // Update the number of clock cycles per memory refresh cycle

    // Determine original frequency from old M, N, P values
    oldMClk  = (nOld * pMcHalInfo->CrystalFreq / (1 << pOld) / mOld);

    // Determine original cycles per refresh
    oldCyclesPerRefresh = REG_RD_DRF( _PFB, _DEBUG_0, _REFRESH_COUNTX64 ) * 64;

    // Determine original refresh period
    oldPeriod = oldCyclesPerRefresh * 1024 / ( oldMClk / 1000 );
    
    // Now using the new MCLK, figure out the new cycles per refresh
    newCyclesPerRefresh = ( pDacHalInfo->MClk / 1000 ) * oldPeriod / 1024;

    // Store the new value
    FLD_WR_DRF_NUM( _PFB, _DEBUG_0, _REFRESH_COUNTX64, newCyclesPerRefresh / 64 );
    
    return status;
}

//
// nvHalDacProgramNVClk_NV04 - Program NVCLK based on the value in pDev->Dac.HalInfo.NVClk
//
// This routine uses the value in pDev->Dac.HalInfo.NVClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramNVClk_NV04(VOID *arg)
{
    PDACPROGRAMNVCLKARG_000 pDacProgramNVClkArg = (PDACPROGRAMNVCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 temp;
    U032 i;
    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramNVClkArg->id != DAC_PROGRAMNVCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramNVClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;

    mNew = pDacHalInfo->NVPllM;
    nNew = pDacHalInfo->NVPllN;
    pNew = pDacHalInfo->NVPllP;

    // Program the hardware

    // Retrieve original coefficients
    coeff = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
    mOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first
        REG_WR32
            (
                NV_PRAMDAC_NVPLL_COEFF,
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _PDIV, pOld)
            );

        // Read the register to give the PLL enough time to adjust
        temp = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
    }

    // Now we can write the final value
    REG_WR32
        (
            NV_PRAMDAC_NVPLL_COEFF,
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _PDIV, pNew)
        );

    // Update NV_PBUS_DEBUG_3 to control data throttling in AGP 4X mode
    i = 0;
    while ( ( pDacHalInfo->NVClk <= NV04_dacAGPClockTable[ i ].frequency ) &&
        ( i < sizeof( NV04_dacAGPClockTable ) / sizeof( NV04_dacAGPClockTable[ 0 ] ) - 1 ) )
    {
        i++;
    }

    FLD_WR_DRF_NUM( _PBUS, _DEBUG_3, _AGP_4X_NVCLK, NV04_dacAGPClockTable[ i ].setting );
    
    return status;
}

//
// nvHalDacProgramPClk_NV04 - Program PCLK based on the value in pDev->Dac.PClk
//
// This routine uses the value in pDev->Dac.PClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramPClk_NV04(VOID *arg)
{
    PDACPROGRAMPCLKARG_000 pDacProgramPClkArg = (PDACPROGRAMPCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032            CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo
    U032            Head;
    U032            PixelClock;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 Loops;
    U032 IsPllLocked;

    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramPClkArg->id != DAC_PROGRAMPCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramPClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacProgramPClkArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    mNew = pDacHalInfo->VPllM;
    nNew = pDacHalInfo->VPllN;
    pNew = pDacHalInfo->VPllP;

    Head = pDacHalObj->Head;
    PixelClock = pDacProgramPClkArg->PixelClock;

    // Program the hardware

    // Retrieve original coefficients
    // NV11 VPLL2 unfortunately is not at the "expected" offset, so we can't use the HAL macro (DAC_REG_RD32)
    if (Head == 0) 
    {
        coeff = REG_RD32( NV_PRAMDAC_VPLL_COEFF );
    }
    else
    {
        coeff = REG_RD32( NV_PRAMDAC_VPLL2_COEFF );
    }
    mOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first. 
        if (Head == 0) 
        {
            REG_WR32
            (
                NV_PRAMDAC_VPLL_COEFF,
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pOld)
            );
        }
        else
        {
            REG_WR32
            (
                NV_PRAMDAC_VPLL2_COEFF,
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pOld)
            );
        }

        // Wait until V PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                HAL_DAC_REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _VPLL_LOCK, CurDacAdr)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    HAL_DAC_REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _VPLL_LOCK, CurDacAdr)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: VPLL not locked\n");
        }
    }

    // Now we can write the final value
    if (Head == 0) 
    {
        REG_WR32
        (
            NV_PRAMDAC_VPLL_COEFF,
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pNew)
        );
    }
    else
    {
        REG_WR32
        (
            NV_PRAMDAC_VPLL2_COEFF,
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pNew)
        );
    }

    return status;
}

//
// nvHalDacProgramCursorImage_NV04
//
RM_STATUS
nvHalDacProgramCursorImage_NV04(VOID *arg)
{
    PDACPROGRAMCURSORARG_000 pDacProgramCursorImgArg = (PDACPROGRAMCURSORARG_000) arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032        CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo

    U008    cr31, cr2f;
    U008    lock;

    //
    // Verify interface revision.
    //
    if (pDacProgramCursorImgArg->id != DAC_PROGRAMCURSOR_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramCursorImgArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacProgramCursorImgArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    // Unlock CRTC extended regs
    lock = ReadCRTCLock_NV04(pHalHwInfo, pDacHalObj->Head);
    HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr);

    // On chips < NV10, the cursor image is always assumed to be a 32x32 image with a color
    // format LE_ROP1R5G5B5. So we ignore the width, height and colorFormat parameters.

    // Mark the Address Space Indicator (bit 7 in NV_CIO_CRE_HCUR_ADDR0_INDEX) 
    // to indicate where the cursor image is based on the param "asi".

    // If the address space indicator says it is in Instance Memory, the startAddr is in terms of 
    // paragraphs instead of bytes. Adjust it to bytes.
    if (pDacProgramCursorImgArg->asi == DAC_ASI_INSTMEM)
    {
        pDacProgramCursorImgArg->startAddr <<= 4;
    }

    // The startAddr is programmed into two config registers as follows:
    // cr2f<0>   = startAddr<24>
    // cr30<6:0> = startAddr<23:17>
    // cr31<7:2> = startAddr<16:11>
    // startAddr<10:0> is assumed to be 0.
    HAL_CRTC_RD(NV_CIO_CRE_HCUR_ADDR2_INDEX, cr2f, CurDacAdr);
    cr2f &= 0xFE;
    cr2f |= (U008)((pDacProgramCursorImgArg->startAddr >> 24) & 0x01);
    HAL_CRTC_WR(NV_CIO_CRE_HCUR_ADDR2_INDEX, cr2f, CurDacAdr);
    
    HAL_CRTC_WR(NV_CIO_CRE_HCUR_ADDR0_INDEX, 
               (U008) ( ((pDacProgramCursorImgArg->startAddr >> 17) & 0x7f) | (pDacProgramCursorImgArg->asi << DEVICE_BASE(NV_CIO_CRE_HCUR_ASI)) ),
               CurDacAdr);
            
    // store startAddr bits 16:11 in cr31 bits 7:2
    HAL_CRTC_RD(NV_CIO_CRE_HCUR_ADDR1_INDEX, cr31, CurDacAdr);
    cr31 &= 0x03; // Clear bits 7:2
    cr31 |= (U008)((pDacProgramCursorImgArg->startAddr >> 9) & 0xfc); // Set the new start address
    HAL_CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, cr31, CurDacAdr);

    // Restore original state of CRTC lock register
    HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, CurDacAdr);
    
    return RM_OK;
}

//
// nvHalDacGetRasterPosition_NV04
//
RM_STATUS
nvHalDacGetRasterPosition_NV04(VOID *arg)
{
    PDACRASTERPOSARG_000 pDacRasterPosArg = (PDACRASTERPOSARG_000) arg;
    PHALHWINFO pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pDacRasterPosArg->id != DAC_RASTERPOS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacRasterPosArg->pHalHwInfo;

    // TO DO: use head number

    // no RL0/RL1 index regs, so return NV_PCRTC_RASTER_POSITION
    pDacRasterPosArg->result = (U016) REG_RD_DRF(_PCRTC, _RASTER, _POSITION);

    return (RM_OK);
}


//         
// Called from display driver to confirm that sufficient bandwidth is available
// for the proposed configuration.
// For this chip, stubbed out to always return success...
//
RM_STATUS
nvHalDacValidateBandwidth_NV04(VOID *arg)
{
    return RM_OK;
}


//
// Attempt to validate the given parameters will work with the current configuration
//       
//  Return 0  if not capable
//  Return ~0 if valid  
//
RM_STATUS
nvHalDacValidateArbSettings_NV04(VOID *arg)
{
    PDACVALIDATEARBSETTINGSARG_000    pDacValidateArbSettingsArg = (PDACVALIDATEARBSETTINGSARG_000) arg;
    PHALHWINFO          pHalHwInfo;
    PDACHALINFO         pDacHalInfo;
    PFBHALINFO          pFbHalInfo;
    PMCHALINFO          pMcHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;

    fifo_info fifo_data;
    sim_state sim_data;
    U032 pclk_limit;

    //
    // Verify interface revision.
    //
    if (pDacValidateArbSettingsArg->id != DAC_VALIDATEARBSETTINGS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacValidateArbSettingsArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;

    //
    // First we must validate that the incoming vclk is within our DAC range.
    //
    switch (pDacValidateArbSettingsArg->bpp)
    {
        case 8:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp;
            break;
        case 15:
        case 16:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp;
            break;
        case 24:
        case 32:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp;
            break;
        default:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp;
            break;
    }            
    //
    // If incoming clock is greater than DAC range, return failure
    //        
    if (pDacValidateArbSettingsArg->vclk > pclk_limit)
    {
        pDacValidateArbSettingsArg->result = 0;
        return (RM_OK);
    }
        
    //
    // Although the memory arbiter may allow video accesses, we can't exceed
    // the video pipeline's circuit limits
    //
    // Hardcode NV4 to 163MHz.  32bpp video may fail due to arbiter failure
    // even under this rate, but that check comes next.
    //
    if (IsNV4_NV04(pMcHalInfo))
        if ((pDacValidateArbSettingsArg->video_enabled) &&
            (pDacValidateArbSettingsArg->vclk > 163000000))
        {
            pDacValidateArbSettingsArg->result = 0;
            return (RM_OK);
        }
    //
    // Hardcode NV5 to 235MHz.  32bpp video may fail due to arbiter failure
    // even under this rate, but that check comes next.
    //
    if (IsNV5_NV04(pMcHalInfo))
        if ((pDacValidateArbSettingsArg->video_enabled) &&
            (pDacValidateArbSettingsArg->vclk > 235000000))
        {
            pDacValidateArbSettingsArg->result = 0;
            return (RM_OK);
        }
    //
    // Hardcode NV0A 8/16bpp to a 206MHz limit, or in the UMA mode, based on memory speed
    //
    // NOTE This is just for Crush level integrated products
    //
    if (IsNV0A_NV04(pMcHalInfo))
    {
        //
        // Never let Crush enable video above 206MHz
        //
        if ((pDacValidateArbSettingsArg->video_enabled) &&
            (pDacValidateArbSettingsArg->bpp < 32) &&
            (pDacValidateArbSettingsArg->vclk > 206000000))
        {
            pDacValidateArbSettingsArg->result = 0;
            return (RM_OK);
        }

        //
        // Further restrictions for UMA configurations due to limited bandwidth
        //
        if (pFbHalInfo->RamType == BUFFER_CRUSH_UMA)
        {
            // Is this 133MHz memory?
            if (pProcessorHalInfo->SystemMemoryFreq == 133000000)
            {
                if ((pDacValidateArbSettingsArg->bpp == 32) &&
                    (pDacValidateArbSettingsArg->vclk > 70000000))
                {
                    pDacValidateArbSettingsArg->result = 0;
                    return (RM_OK);
                }
            }
            // or 100MHz memory?
            else if (pProcessorHalInfo->SystemMemoryFreq == 100000000)
            {
                if ((pDacValidateArbSettingsArg->bpp < 32) &&
                    (pDacValidateArbSettingsArg->vclk > 110000000))
                {
                    pDacValidateArbSettingsArg->result = 0;
                    return (RM_OK);
                }           

                if ((pDacValidateArbSettingsArg->bpp == 32) &&
                    (pDacValidateArbSettingsArg->vclk > 70000000))
                {
                    pDacValidateArbSettingsArg->result = 0;
                    return (RM_OK);
                }      
            }
            else // we must be using 66MHz memory or lower
            {
                if ((pDacValidateArbSettingsArg->bpp < 32) &&
                    (pDacValidateArbSettingsArg->vclk > 60000000))
                {
                    pDacValidateArbSettingsArg->result = 0;
                    return (RM_OK);
                }      

                if ((pDacValidateArbSettingsArg->bpp == 32) &&
                    (pDacValidateArbSettingsArg->vclk > 53000000))
                {
                    pDacValidateArbSettingsArg->result = 0;
                    return (RM_OK);
                }      
            }
        }
    }

    //
    // Current NV10 video has no limit in this range
    //            
            
    //
    // Build the sim table using current system settings
    //
    sim_data.pix_bpp        = (char) pDacValidateArbSettingsArg->bpp;
    sim_data.enable_video   = pDacValidateArbSettingsArg->video_enabled ? 1 : 0;
    sim_data.enable_mp      = pDacValidateArbSettingsArg->mport_enabled ? 1 : 0;
    sim_data.memory_width   = pDacHalInfo->InputWidth;
    sim_data.mem_latency    = (char)REG_RD_DRF(_PFB, _CONFIG_1, _CAS_LATENCY); //3
    sim_data.mem_aligned    = 1;
    sim_data.mem_page_miss  = (char)(REG_RD_DRF(_PFB, _CONFIG_1, _RAS_RAS) + REG_RD_DRF(_PFB, _CONFIG_1, _READ_TO_PCHG)); //10;
    sim_data.ram_config     = (int)REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_RAMCFG); 
    sim_data.gr_during_vid  = pVideoHalInfo->ColorKeyEnabled ? 1 : 0;
    sim_data.pclk_khz       = pDacValidateArbSettingsArg->vclk / 1000;  // in kHz, not MHz
    sim_data.mclk_khz       = pDacHalInfo->MClk / 1000;     // in kHz, not MHz
    sim_data.nvclk_khz      = pDacHalInfo->NVClk / 1000;    // in kHz, not MHz

    // 
    // Run the numbers through the ringer
    //
    if (pFbHalInfo->RamType == BUFFER_CRUSH_UMA)
        NV04_dacCalculateArbitration_SMA(pHalHwInfo, &fifo_data, &sim_data);
    else
        NV04_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);
    
    pDacValidateArbSettingsArg->result = (U032)fifo_data.valid;
    return (RM_OK);
}                
                                                      
RM_STATUS
nvHalDacUpdateArbSettings_NV04(VOID *arg)
{
    PDACUPDATEARBSETTINGSARG_000     pDacUpdateArbSettingsArg = (PDACUPDATEARBSETTINGSARG_000) arg;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    PHALHWINFO          pHalHwInfo;
    PDACHALINFO         pDacHalInfo;
    PFBHALINFO          pFbHalInfo;
    PMCHALINFO          pMcHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;
    PMPHALINFO          pMpHalInfo;
    U032                Head;
    U032                CurDacAdr;

    fifo_info   fifo_data;
    sim_state   sim_data;
    U008        lock;
    U032        M, N, O, P;

    //
    // Verify interface revision.
    //
    if (pDacUpdateArbSettingsArg->id != DAC_UPDATEARBSETTINGS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacUpdateArbSettingsArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;
    pMpHalInfo = pHalHwInfo->pMpHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacUpdateArbSettingsArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;
    Head = pDacHalObj->Head;

    //
    // Recalculate the current PCLK setting.  We might have changed modes
    // recently.
    //
    M = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _MDIV);
    N = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _NDIV);
    P = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _PDIV);
    O = 1;
    
    pDacHalInfo->VPllM = M;
    pDacHalInfo->VPllN = N;
    pDacHalInfo->VPllO = O;
    pDacHalInfo->VPllP = P;
    pDacHalInfo->VClk  = (N * pMcHalInfo->CrystalFreq / (1 << P) / M);
    
    //
    // Build the sim table using current system settings
    //
    sim_data.pix_bpp        = (char) pDacHalInfo->Depth;
    sim_data.enable_video   = pVideoHalInfo->Enabled ? 1 : 0;
    sim_data.enable_mp      = pMpHalInfo->Enabled ? 1 : 0;
    sim_data.memory_width   = pDacHalInfo->InputWidth;
    sim_data.mem_latency    = (char) REG_RD_DRF(_PFB, _CONFIG_1, _CAS_LATENCY); //3
    sim_data.mem_aligned    = 1;
    sim_data.mem_page_miss  = (char) (REG_RD_DRF(_PFB, _CONFIG_1, _RAS_RAS) + REG_RD_DRF(_PFB, _CONFIG_1, _READ_TO_PCHG)); //10;
    sim_data.ram_config     = (int) REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_RAMCFG); 
    sim_data.gr_during_vid  = pVideoHalInfo->ColorKeyEnabled ? 1 : 0;
    sim_data.pclk_khz       = pDacHalInfo->VClk / 1000;     // in kHz, not MHz
    sim_data.mclk_khz       = pDacHalInfo->MClk / 1000;     // in kHz, not MHz
    sim_data.nvclk_khz      = pDacHalInfo->NVClk / 1000;    // in kHz, not MHz

    // 
    // Get those new numbers
    //
    if (pFbHalInfo->RamType == BUFFER_CRUSH_UMA)
        NV04_dacCalculateArbitration_SMA(pHalHwInfo, &fifo_data, &sim_data);
    else
        NV04_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);
    
    //
    // If valid settings found, update the hardware
    //
    if (fifo_data.valid)
    {
        //
        // Set the DAC FIFO Thresholds and burst size
        //
        if (HAL_GETDISPLAYTYPE(Head) == DISPLAY_TYPE_TV)
        {
            REG_WR32(NV_PVIDEO_FIFO_BURST, 3);
            REG_WR32(NV_PVIDEO_FIFO_THRES, fifo_data.video_lwm >> 1);
        }
        else
        {
            // If we are upscaling video, we may not drain fast enough (fifo overflow), since
            // for every pixel from the framebuffer, we've got to send out more than one pixel. 
            // On 64 bit devices at high pixel clocks, the watermark will be set to maximum,
            // to solve the opposite problem (fifo underflow, draining faster than we fill),
            // This makes it more likely to overflow, so make sure we are not set to max 
            // low water mark. (At 16x12 > 60 Hz, we will get set to max lwm, causing us to
            // overflow when scaling the video to full screen.)
            if ((pDacHalInfo->InputWidth == 64) && pVideoHalInfo->Enabled)
            {
                if (fifo_data.video_lwm == 128*2)           // if set to max
                    fifo_data.video_lwm -= 8*2;             // drop down one notch
                // We must also prevent underflow. Letting the CRTC fifo use max bursts can starve video.
                if (fifo_data.crtc1_burst_size == 256)      // if set to max
                    fifo_data.crtc1_burst_size >>= 1;       // drop down on notch
            }

            REG_WR32(NV_PVIDEO_FIFO_THRES, fifo_data.video_lwm >> 1);
            switch (fifo_data.video_burst_size)
            {
                case 128:
                    REG_WR32(NV_PVIDEO_FIFO_BURST, 3);
                    break;

                case 64:
                    REG_WR32(NV_PVIDEO_FIFO_BURST, 2);
                    break;

                case 32:
                    REG_WR32(NV_PVIDEO_FIFO_BURST, 1);
                    break;
            }
        }

        //
        // If the video LWM is maxed out in a 64bit device, make sure to drop the graphics burst down
        // to provide additional bandwidth.
        //
        if ((pDacHalInfo->InputWidth == 64) && pVideoHalInfo->Enabled && ((fifo_data.video_lwm >> 1) == 0x80))
        {        
            // Make sure we've got room to drop
            if ((fifo_data.crtc1_burst_size > 128) && (pDacHalInfo->Depth==8)) 
                fifo_data.crtc1_burst_size >>= 2;
        }            
        
        //
        // Update the CRTC watermarks
        //
        // Unlock CRTC extended regs
        HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, CurDacAdr);
        HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr);

        //
        // Set the CRTC watermarks and burst size
        //
        if (HAL_GETDISPLAYTYPE(Head) != DISPLAY_TYPE_TV) // leave alone if TV
        {       
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, (U008) (fifo_data.crtc1_lwm >> 3), CurDacAdr);

            switch (fifo_data.crtc1_burst_size)
            {
                // If the DFP uses shortened blanking, we may run out of time.
                // Limiting burst to 64 prevents starving the fifo when running video.
                // This is not a problem on NV10 because of larger fifo size.
                // We're not checking for shortened blanking, instead we'll always limit burst
                // size for video + DFP. This may reduce performance, but we assume no one cares.
                case 256:
                    if ((HAL_GETDISPLAYTYPE(Head) == DISPLAY_TYPE_FLAT_PANEL) && (pVideoHalInfo->Enabled))
                    {
                        HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 2, CurDacAdr);
                    }
                    else
                        HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 4, CurDacAdr);
                    break;

                case 128:
                    if ((HAL_GETDISPLAYTYPE(Head) == DISPLAY_TYPE_FLAT_PANEL) && (pVideoHalInfo->Enabled))
                    {
                        HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 2, CurDacAdr);
                    }
                    else
                        HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 3, CurDacAdr);
                    break;

                case 64:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 2, CurDacAdr);
                    break;

                case 32:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 1, CurDacAdr);
                    break;

                case 16:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 0, CurDacAdr);
                    break;
            }
            //
            // Manual override of LWM and Burst, if necessary and possible
            //
            if (pDacHalInfo->Enable256Burst && !pVideoHalInfo->Enabled && (pDacHalInfo->InputWidth == 128))
            {
        
                if ((pFbHalInfo->HorizDisplayWidth == 1024)
                    && (pFbHalInfo->VertDisplayWidth == 768)
                    && (pDacHalInfo->Depth == 16)
                    && ((pFbHalInfo->RefreshRate == 75) || (pFbHalInfo->RefreshRate == 85)))
                {
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 4, CurDacAdr);
                    HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 0x0F, CurDacAdr);
                }            
        
                if ((pFbHalInfo->HorizDisplayWidth == 1024)
                    && (pFbHalInfo->VertDisplayWidth == 768)
                    && (pDacHalInfo->Depth >= 24)
                    && ((pFbHalInfo->RefreshRate == 75) || (pFbHalInfo->RefreshRate == 85)))
                {
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 4, CurDacAdr);
                }            

                if ((pFbHalInfo->HorizDisplayWidth == 1280)
                    && (pFbHalInfo->VertDisplayWidth == 1024)
                    && (pDacHalInfo->Depth >= 24)
                    && ((pFbHalInfo->RefreshRate == 75) || (pFbHalInfo->RefreshRate == 85)))
                {
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 4, CurDacAdr);
                }            
            
            }
        }        
        //
        // Relock if necessary
        //
        if (lock == 0)
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr);
        
        return (RM_OK);
    }
    else
        //
        // No valid setting was found!!!  Either we fail this configuration
        // or we live with the current default settings for this mode.
        //
        return (RM_ERROR);
}

RM_STATUS
nvHalDacHotPlugInterrupts_NV04(VOID * pArgs)
{
    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\grayclk.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Gray Code Support *****************************
 *                                                                           *
 * Module: grayclk.c                                                         *
 *                                                                           *
 *****************************************************************************/

#include <nvrm.h>
#include <nvhw.h>
#include <nvos.h>
#include <bios.h>            // need BIOS_ROM_CODE_SIZE
#include <nv10_ref.h>

#define __KERNEL__
#include <nv.h>
#include <Nvcm.h>

//doubled table length to avoid wasted effort of boundary checking for something so small
static const U032 GrayCodeLookupTable[16]={0,1,3,2,6,7,5,4,0,1,3,2,6,7,5,4};
static const U032 GrayCodeLookupTableLength=16;

static U032 GrayCodeLookup(U032 Value,U032 starting_position)
{
	U032 x;
	
	Value=Value&0x7;
	
	//looks up 3 bit value in lookup table and returns the position
	for(x=starting_position;x<GrayCodeLookupTableLength;x++)
	{
		if(GrayCodeLookupTable[x]==Value)
		{
			return x;
		}
	}
	
	return 0;
}

void RmProperClockPdivProgrammer(PHWINFO pDev,U032 ClockAddress,U032 NewValue)
{
	U032 OldValue;
	U032 OldPdiv;
	U032 NewPdiv;
	U032 PllValLessPdiv;
	U032 ListPosition;
	U032 TargetPosition;
	U032 CurrentPosition;
	
	//read old value
	OldValue=REG_RD32(ClockAddress);
	
	//obtain old pdiv (16 though 18)
	OldPdiv=(OldValue>>16)&0x7;
	
	//obtain the desired Pll value less the Pdiv
	PllValLessPdiv=NewValue&0xffff;
	
	//obtain the desired Pdiv
	NewPdiv=(NewValue>>16)&0x7;
	
	//lookup position of the items we have and want
	ListPosition=GrayCodeLookup(OldPdiv,0);
	TargetPosition=GrayCodeLookup(NewPdiv,ListPosition);
	
	//transition via gray code to desired setting
	for(CurrentPosition=ListPosition;CurrentPosition<=TargetPosition;CurrentPosition++)
	{
		REG_WR32(ClockAddress,(GrayCodeLookupTable[CurrentPosition]<<16)|PllValLessPdiv);
		
		//wait to allow settle before transitioning again
		osDelay(10);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dac\nv10\dacnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Arbitration **************************\
*                                                                           *
* Module: DACARB.C                                                          *
*   The DAC Arbitration management.                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvhw.h"
#include <vga.h>

//#include <nvd3dmac.h>

/* This file simulates the NV arbitor */
#include <arb_fifo.h>
#include "nvhalcpp.h"

//LPL - memo to myself
// - clean-up to do: may not need default settings when pVidLutCurDac ptrs NULL.
// - clean up bpp overrides
// - with new top-of-buffer lwm approach, can some of the math be simplified?
// - does setting lwm based on pre-clipped burst size cause discrepancies?

//#define NV11_DEBUG

#ifdef NV11_DEBUG
U032 nv11Aware = 1;    //debug toggle between nv10/nv11 arb fns
#endif  //#ifdef NV11_DEBUG

//////////////////////////////////////////
//
// NV 11 arbitration routines
//

static U032
adjust_scaler_burstsize(U032 raw, U032 min, U032 max)
{
  U032 adj;
  
  /* scaler burst sizes are a multiple of min bytes */
  adj = (raw + (min - 1)) / min * min;
  /* max burst size is 2048 bytes */
  if (adj > max)
    adj = max;  
  return adj;
}

//LPL Moved from init.c area.
static void
check_scaler_burstsize(scaler_t *scaler)
{
  U032 raw;

  if (!(scaler->enable)) 
    return;

  raw = adjust_scaler_burstsize(scaler->burst_size, scaler->min_burst_size, scaler->max_burst_size);

  if (raw != scaler->burst_size)
    scaler->burst_size = raw;
}


// Data structure init routines

static void
check_crtc_burstsizes(crtc_t *crtc)
{
  U032 raw = crtc->burst_size;
  
  if (!crtc->enable) return;
 
  /* crtc burst sizes are a multiple of 16 bytes */
  raw = (raw + 15) / 16 * 16;
  /* burst sizes step by 16 up to 2048 bytes*/
  if (raw > crtc->max_burst_size)
    raw = crtc->max_burst_size;
  if (raw != crtc->burst_size)
    crtc->burst_size = raw;
}

static void
init_crtc(crtc_t *crtc,
      U032 enable,
      U032 hres,
      U032 vres,
      U032 nativeVRes,
      U032 depth,
      U032 refresh,
      U032 request_delay_mclks,
      U032 request_delay_pclks,
      U032 burst_size,
      U032 min_burst_size,
      U032 max_burst_size,
      U032 cursor_burst_size,
      U032 pclk,
      U032 htotal,
      mem_t *mem
      )
{
  crtc->fifo.lwm = 0;
  crtc->enable = enable;
  crtc->hres = hres;
  crtc->vres = vres;
  crtc->nativeVRes = nativeVRes;
  crtc->depth = depth;
  crtc->drain_rate = depth*100 / 8;
  crtc->refresh = refresh;
  crtc->pclk = pclk;
  crtc->pclk_period = 1000000 / crtc->pclk; //now in ps, no longer ns
  crtc->request_delay = request_delay_mclks * mem->mclk_period + request_delay_pclks * crtc->pclk_period;
  crtc->burst_size = burst_size;
  crtc->min_burst_size = min_burst_size;
  crtc->max_burst_size = max_burst_size;
  crtc->cursor_burst_size = cursor_burst_size;
  /* make sure set burst sizes are legitimate */
  check_crtc_burstsizes(crtc);
  crtc->fifo.size = 0;
  crtc->hclk_period = crtc->pclk_period * htotal / 1000;
}

static void
init_scaler(scaler_t *scaler,
        crtc_t *crtc,
        crtc_t *crtc2,
        U032 nvclk,
        U032 enable,
        U032 source_hres,
        U032 source_vres,
        U032 h2_owns_vs,
        U032 depth,
        U032 hres,
        U032 vres,
        U032 burst_size,
        U032 min_burst_size,
        U032 max_burst_size,
        U032 request_delay_nvclks,
        U032 request_delay_pclks,
        U032 max_fifo_size
        )
{
  if (h2_owns_vs)
    scaler->pclk_period = crtc2->pclk_period;
  else
    scaler->pclk_period = crtc->pclk_period;

  scaler->h2_owns_vs    = h2_owns_vs;
  scaler->max_fifo_size = max_fifo_size;
 
  scaler->enable = enable;
  if (!enable) {
    scaler->burst_size = 0;
    return;
  }
  scaler->depth = depth;

  scaler->source_hres = source_hres;
  scaler->source_vres = source_vres;

  /* assume full screen scaling */
  scaler->window_hres = (h2_owns_vs) ? crtc2->hres : crtc->hres;
  scaler->window_vres = (h2_owns_vs) ? crtc2->vres : crtc->vres;

  /* This code does not allow for distorted scaling.
   * I.e., the horizontal and vertical scale factors are 
   * forced to be the same such that the video window is as
   * large as possible on the display without any geometric
   * distortion.
   */
  scaler->hscale = (1000*scaler->window_hres) / scaler->source_hres;
  scaler->vscale = (1000*scaler->window_vres) / scaler->source_vres;
  if (scaler->hscale > scaler->vscale)
    scaler->hscale = scaler->vscale;
  else
    scaler->vscale = scaler->hscale;

  //Normally, the bandwidth taken by the video scaler is:
  //  source_hres*source_vres*refresh rate*(2 bytes)
  //However, if the soruce width is greater than can be stored
  //in the video scaler's FIFOs, then two source lines are fetched
  //for each destination line.
  //Also, for large downscaling greater than or equal to 2x, two
  //source lines are fetched for each destination line.
  if (((scaler->source_hres*scaler->depth/8) > scaler->max_fifo_size) || (scaler->vscale <= 500))
    scaler->bwFactor = 2 * scaler->vscale;
  else
    scaler->bwFactor = 1;

  scaler->burst_size = burst_size;
  scaler->min_burst_size = min_burst_size;
  scaler->max_burst_size = max_burst_size;
  scaler->request_delay = request_delay_pclks * scaler->pclk_period + request_delay_nvclks * (1000000 / nvclk);
  /* note that we never read more than the source image,
     even if we're upscaling. that's why we take the MIN
     of 1 and hscale. */
  //scaler->drain_rate = ((scaler->depth / 8)*100000) / MIN(scaler->hscale, 1000);
  scaler->drain_rate = ((scaler->depth / 8)*100000) / ((scaler->hscale < 1000) ? scaler->hscale:1000);
  if ((scaler->vscale < 1000) || 
      ((max_fifo_size != 0) && 
       ((scaler->source_hres*(scaler->depth/8)) > max_fifo_size)
      ) 
     )
    /* we're going to decimate, so we may read 2 new lines for an output line */
    scaler->drain_rate *= 2;
  /* check for a legitimate burst size */
  check_scaler_burstsize(scaler);
  scaler->fifo.size = 0;
  scaler->fifo.lwm  = 0;
}

static void
init_mem(mem_t *mem,
     U032 mclk,
     U032 ddr,
     arb_type arbiter,
     U032 partitions,
     U032 partition_data_width,
     U032 page_fault_penalty,
     U032 page_fault_width,
     U032 refresh_penalty,
     U032 arbitration_latency,
     U032 pipeline_latency,
     U032 stall_cycles,
     U032 depth_cmd,
     U032 depth_rw,
     U032 interrupt_rate
     )
{
  mem->mclk = mclk;
  mem->mclk_period = 1000000 / mclk;
  mem->partitions = partitions;
  mem->ddr = ddr;
  mem->arbiter = arbiter;
  mem->data_rate = ((ddr) ? 2 : 1) * partitions * partition_data_width / 8;
  mem->page_fault_penalty = page_fault_penalty;
  mem->page_fault_width = page_fault_width;
  mem->refresh_penalty = refresh_penalty;
  mem->arbitration_latency = arbitration_latency;
  mem->pipeline_latency = pipeline_latency;
  mem->stall_cycles = stall_cycles;
  mem->cmdq_depth_cmd = depth_cmd;
  mem->cmdq_depth_rw = depth_rw;
  /* the first number is the amount of time taken to process all the read/write
     commands; the second is to allow for bus turnaround from read->write.
     the third and fourth allow for two page faults and a refresh in the
     command queue. */
//the command_latency is included in the pipeline_latency of the FBI.
//mem->command_latency = depth_rw * ((ddr) ? 2 : 4) + (depth_rw / 2) + (depth_cmd - 1) * page_fault_penalty + refresh_penalty;
  mem->command_latency = 0;
  mem->interrupt_rate = interrupt_rate;
}

static void
init_rtr(rtr_t *rtr,
     U032 burst_size,
     U032 request_delay_mclks,
     mem_t *mem
     )
{
  rtr->burst_size = burst_size;
  rtr->request_delay_mclks = request_delay_mclks;
  rtr->request_delay = request_delay_mclks * mem->mclk_period;
  rtr->latency = 0;
}


// Actual buffer size calculation routines


static void
guess_scaler_burstsize(scaler_t *scaler, crtc_t *crtc, crtc_t *crtc2)
{
  U032 raw, raw1, raw2;
  
  /* take a simplistic approach to guess this */

  raw1 = ((scaler->drain_rate*1000)/crtc->drain_rate )*crtc->burst_size;
  raw2 = ((scaler->drain_rate*1000)/crtc2->drain_rate)*crtc2->burst_size;
  raw  = (scaler->h2_owns_vs) ? raw2/1000 : raw1/1000;
 
  if (raw < scaler->min_burst_size) raw = scaler->min_burst_size;
  scaler->burst_size = adjust_scaler_burstsize(raw, scaler->min_burst_size, scaler->max_burst_size);
}

static U032
adjust_crtc2_burstsize(U032 raw, U032 min, U032 max)
{
  U032 adj;
  
  /* scaler burst sizes are a multiple of min bytes */
  adj = (raw + (min - 1)) / min * min;
  /* max burst size is 2048 bytes */
  if (adj > max)
    adj = max;  
  return adj;
}
    
static void
guess_crtc2_burstsize(crtc_t *crtc2, crtc_t *crtc)
{
  U032 raw;
  U032 period_factorx100, drain_factorx100;
  /* take a simplistic approach to guess this */
  period_factorx100 = (100*crtc->pclk_period)/crtc2->pclk_period;
  drain_factorx100  = (100*crtc2->drain_rate)/crtc->drain_rate;
  raw = (crtc->burst_size*period_factorx100*drain_factorx100)/10000;
  if (raw < crtc2->min_burst_size) raw = crtc2->min_burst_size;
  crtc2->burst_size = adjust_crtc2_burstsize(raw, crtc2->min_burst_size, crtc->max_burst_size);
}

/************************************************/
static U032
compute_fifo_size(fifo_params *fifo, U032 hres, U032 drain_rate, U032 burst_size, U032 request_delay, U032 dclk_period,
          U032 burst_latency, U032 bursts_during_active, mem_t *mem)
{
  U032 lwm, lwm_min;
  U032 fifo_size;
  U032 bursts_to_fill_lwm;
  
  /* figure out the low water mark in the fifo */
  if (((hres * drain_rate)/100) > (bursts_during_active * burst_size))
    lwm = (hres * drain_rate)/100 - bursts_during_active * burst_size;
  else
    lwm = 0;

  /* make sure we have enough data in the fifo to satisfy the
     initial wait in the active phase */
//LPL need:  NVASSERT((request_delay + mem->pipeline_latency + mem->command_latency + burst_latency - burst_size) >= 0);
  lwm_min = ((((request_delay + mem->pipeline_latency + mem->command_latency + burst_latency - burst_size)
      * mem->mclk_period) / mem->data_rate) * (drain_rate / dclk_period)
      +99)/100; //forces rounding up, needed because drain_rateis 100x

  //LPL: Eep!  How many loops are possible here?
  while (lwm < lwm_min) {
    lwm += burst_size;
    bursts_during_active--;
  }

  /*added because bursts during active could be more than necessary to fetch a line*/
  bursts_to_fill_lwm = lwm/burst_size;
  if (lwm%burst_size)
    bursts_to_fill_lwm++;

  while (((bursts_to_fill_lwm + bursts_during_active - 1)*burst_size) >= ((hres*drain_rate)/100)) {
    bursts_during_active--;
  }
  
  /* fifo_size is lwm + burst_size */
  fifo_size = lwm + burst_size;

  fifo->lwm_min = lwm_min;
  fifo->lwm     = lwm;
  fifo->size    = fifo_size;

  return bursts_during_active;
}




/************************************************/
/* check to see that we are consuming sufficient bandwidth. this
   is really just an approximation since it only really considers
   the bandwidth consumed by the crtc and scaler. */
static U032
not_consuming_sufficient_bandwidth(crtc_t *crtc, crtc_t *crtc2, scaler_t *scaler, mem_t *mem, U032 burst_latency, U032 cursor_latency)
{
  U032 reqd_crtc_bw, reqd_crtc2_bw, reqd_scaler_bw;
  U032 actual_bw;
  U032 error;

  //LPL is this if needed? What's the correct return in case of error?
  //LPL Range check.
  if ((crtc->hclk_period > cursor_latency/1000) && (crtc2->hclk_period > cursor_latency/1000)) {
      reqd_crtc_bw   = (100*crtc->enable)  *crtc->hres *(crtc->depth /8) / (crtc->hclk_period  - cursor_latency/1000);
      reqd_crtc2_bw  = (100*crtc2->enable) *crtc2->hres*(crtc2->depth/8) / (crtc2->hclk_period - cursor_latency/1000);
      reqd_scaler_bw = (100*scaler->enable)*scaler->source_hres * (scaler->depth / 8) * ((scaler->vscale <= 500) ? 2 : 1) / 
                       (crtc->hclk_period - cursor_latency/1000);
      actual_bw = (1000*100*(crtc->enable*crtc->burst_size + crtc2->enable*crtc2->burst_size + scaler->enable*scaler->burst_size))
                  / (burst_latency * mem->mclk_period); //x1000000 because other bw as bytes/ns, not bytes/ps
    error = (actual_bw < (reqd_crtc_bw + reqd_crtc2_bw + reqd_scaler_bw)) ? 1 : 0;
  } else {
      error = 0;    //LPL: proper failure?
  }
//  if (actual_bw < 0) error = 0;//overflow in weird cases
  return error;
}

/*makes sure fifo size isn't larger than the maximum*/
static U032 test_fifo_constraints(U032 fifo_size, crtc_t *crtc, crtc_t *crtc2, scaler_t *scaler) 
{
  /* If dm ("Display Matrix") isn't specified at the command line, dm
   * (fifo_size here) will be 0.  In this case, no error will be returned since
   * any fifo size is OK.
   */
  if (fifo_size == 0)
    return (0);

  /* Note that fifo.size is initialized to zero for the CRTCs and scaler.
   * So, this function will not return an error just because a fifo size has 
   * yet to be computed.
   */
  return (( crtc->enable  && (crtc->fifo.size   > fifo_size))             || 
          ( crtc2->enable && (crtc2->fifo.size  > fifo_size))             || 
          (scaler->enable && (scaler->fifo.size > scaler->max_fifo_size))   );
}

/* check that there is sufficient total bandwidth available to
   support this resolution. */
static U032
insufficient_total_bandwidth(crtc_t *crtc, crtc_t *crtc2, scaler_t *scaler, mem_t *mem)
{
  U032 error;
  U032 video_bandwidth;
  U032 available_bandwidth;

  //nativeVRes is used in place of VRes because, for flat panels, one line is read from memory for each
  //destination line, not each source line.  For non-flat panels (i.e., the FP scaler is not used),
  //nativeVRes should be the same as vres.
  video_bandwidth = (crtc->enable  *(crtc->hres  * crtc->nativeVRes  * crtc->depth  / 8 ) *  crtc->refresh / 10 + 
                     crtc2->enable *(crtc2->hres * crtc2->nativeVRes * crtc2->depth / 8 ) * crtc2->refresh / 10 + 
                     scaler->enable*(scaler->source_hres * scaler->source_vres * 2) * scaler->bwFactor *
                       ((scaler->h2_owns_vs)?crtc2->refresh : crtc->refresh) / 10           );

  //LPL: this overflowed before, but switch to /10 and U032 should
  // give us plenty of breathing room
  available_bandwidth = mem->data_rate * mem->mclk * 90000;
  error = (video_bandwidth > available_bandwidth) ? 1 : 0;
  return error;
}

/* check to see that we can read sufficient data during active time assuming LWM is already reached*/
/* ASSUMES that LWM can be filled during blank.  That is, this function should always be used with 
   cant_fill_to_lwm.  Also assumes that bursts_during_active actually fits in active. */
static U032
insufficient_data(U032 hres, U032 depth, U032 lwm, U032 bursts_during_active, U032 burst_size)
{
  U032 error;
  error = ((hres * depth / 8) > 
           ((lwm + burst_size - 1) / burst_size + bursts_during_active) * burst_size
          ) ? 1 : 0;
  return error;
}


/**************************************************/
/*use for NV11, NV20 and onward*/
/*should also be used for scaler NV10 onward*/
static U032
new_cant_fill_to_lwm(crtc_t *crtc, mem_t *mem, U032 burst_latency, U032 cursor_latency, U032 bursts_during_active)
{
    U032 error;
    U032 bursts_during_available;

#if 1//def TWINHEAD_OPTS
    U032 temp;
    temp = (bursts_during_active * burst_latency + cursor_latency + mem->pipeline_latency)
        * mem->mclk_period + crtc->request_delay;
    if ((crtc->hclk_period * 1000) >= temp) {
        bursts_during_available = (crtc->hclk_period * 1000 - temp)
            / (burst_latency * mem->mclk_period);
        error = (crtc->fifo.lwm > bursts_during_available * crtc->burst_size) ? 1 : 0;
    } else {
        error = 1;  //LPL: proper error?
    }
#else    //#ifdef TWINHEAD_OPTS
  bursts_during_available = ((crtc->hclk_period * 1000 -
                  bursts_during_active * burst_latency * mem.mclk_period -
                  cursor_latency                       * mem.mclk_period -
                  mem.pipeline_latency                 * mem.mclk_period -
                  crtc->request_delay
                 ) /
                 (burst_latency * mem.mclk_period)
                );
  error = (crtc->fifo.lwm > bursts_during_available * crtc->burst_size) ? 1 : 0;
#endif    //#ifdef TWINHEAD_OPTS

  return error;
}



static U032
scaler_cant_fill_to_lwm(scaler_t *scaler, crtc_t *crtc, crtc_t *crtc2, mem_t *mem, U032 burst_latency, U032 cursor_latency, U032 bursts_during_active)
{
    U032 error;
    U032 bursts_during_available;
    U032 hclk_period;

#if 1//def TWINHEAD_OPTS
    U032 temp;

    if (scaler->h2_owns_vs) hclk_period = crtc2->hclk_period;
    else hclk_period = crtc->hclk_period;

    temp = (bursts_during_active * burst_latency + cursor_latency + mem->pipeline_latency) * mem->mclk_period
        + scaler->request_delay;

    if ((hclk_period * 1000) >= temp) {
        bursts_during_available = (hclk_period * 1000 - temp)
            / (burst_latency * mem->mclk_period);
        error = (scaler->fifo.lwm > bursts_during_available * scaler->burst_size) ? 1 : 0;
    } else {
        error = 0;  //LPL proper error?
    }
#else    //#ifdef TWINHEAD_OPTS
  if (scaler->h2_owns_vs)
  {
    bursts_during_available = ((crtc2->hclk_period * 1000 -
                      bursts_during_active * burst_latency * mem.mclk_period -
                    cursor_latency                       * mem.mclk_period -
                    mem.pipeline_latency                 * mem.mclk_period -
                    scaler->request_delay
                   ) /
                   (burst_latency * mem.mclk_period)
                  );
  } else
  {
    bursts_during_available = ((crtc->hclk_period * 1000  -
                      bursts_during_active * burst_latency * mem.mclk_period -
                    cursor_latency                       * mem.mclk_period -
                    mem.pipeline_latency                 * mem.mclk_period -
                    crtc->request_delay
                   ) /
                   (burst_latency * mem.mclk_period)
                  );
  }
  error = (scaler->fifo.lwm > bursts_during_available * scaler->burst_size) ? 1 : 0;
#endif    //#ifdef TWINHEAD_OPTS

  return error;
}



/***********************************************/
/*Note: this function is analogous to test_scaler_constraints.  
  Any modifications here will often also need to be made to 
  test_scaler_constraints.
  "someday" the crtc_t and scaler_t data types should be unified so these
  two functions can also be unified.  OOP would have been nice here. . .
  */
static U032
test_crtc_constraints(crtc_t *crtc, crtc_t *crtc2, scaler_t *scaler, rtr_t *rtr, mem_t *mem)
{
  U032 errors = 0;
  U032 burst_latency;
  U032 cursor_latency;
  U032 bursts_during_active;
  U032 final_bursts_during_active;
  U032 num_rtrs, total_burst_size;
  U032 burst_temp, burst_temp2;

  if (!crtc->enable) return 0;
 
  num_rtrs         = crtc->enable + crtc2->enable + scaler->enable;
  total_burst_size =  crtc->enable*crtc->burst_size + crtc2->enable*crtc2->burst_size + scaler->enable*scaler->burst_size;

  burst_latency = num_rtrs         * mem->arbitration_latency + 
                  total_burst_size / mem->data_rate           +
                  num_rtrs         * mem->stall_cycles        +
                  (crtc->enable    * ((crtc->burst_size   + mem->page_fault_width - 1) / mem->page_fault_width) +
                   crtc2->enable   * ((crtc2->burst_size  + mem->page_fault_width - 1) / mem->page_fault_width) +
                   scaler->enable  * ((scaler->burst_size + mem->page_fault_width - 1) / mem->page_fault_width)
                  ) * mem->page_fault_penalty;

  
  /*note that cursor_latency is a on a per-CRTC basis, not total cusor_latency.*/
  /*note also that NV11 needs to treat cursor latency as taking a CRTC burst.  */
  cursor_latency = mem->arbitration_latency + (crtc->cursor_burst_size) / mem->data_rate + mem->stall_cycles;
  if (not_consuming_sufficient_bandwidth(crtc, crtc2, scaler, mem, burst_latency, cursor_latency * mem->mclk_period)) {
    errors++;
  }
  if (errors)
    return errors;

  /* optimistic case */
#if 1
  burst_temp = crtc->hres * crtc->pclk_period + crtc->burst_size * mem->mclk_period / mem->data_rate;
  burst_temp2 =  crtc->request_delay
      + (mem->pipeline_latency + mem->command_latency) * mem->mclk_period
      + 100 * crtc->burst_size * crtc->pclk_period / crtc->drain_rate;

  if (burst_temp >= burst_temp2) {
      bursts_during_active =  (burst_temp - burst_temp2) / (burst_latency * mem->mclk_period);
  } else {
      bursts_during_active = 0;
  }

#else
  bursts_during_active = (crtc->hres           * crtc->pclk_period -
                  crtc->request_delay                      -
                  mem->pipeline_latency * mem->mclk_period   -
                  mem->command_latency  * mem->mclk_period   -
                  100 * crtc->burst_size     * crtc->pclk_period / crtc->drain_rate +
                  crtc->burst_size     * mem->mclk_period   / mem->data_rate
                 ) /
                 (burst_latency * mem->mclk_period);
#endif

  final_bursts_during_active = compute_fifo_size(&crtc->fifo, crtc->hres, crtc->drain_rate, crtc->burst_size,
                         crtc->request_delay, crtc->pclk_period, burst_latency, bursts_during_active,
                         mem);

  /* can we fill to the LWM mark in the blanking period?
     note that we have to wait for the cursor burst to go first.
     for "new" mode operation, we can also start filling during
     the previous scan-out. */
  if (new_cant_fill_to_lwm(crtc, mem, burst_latency, (crtc->enable+crtc2->enable)*cursor_latency, final_bursts_during_active)) {
    errors++;
  }
  
  /* can we get enough data? */
  if (insufficient_data(crtc->hres, crtc->depth, crtc->fifo.lwm, final_bursts_during_active, crtc->burst_size)) {
    errors++;
  }

  if (errors) return errors;

  /* pessimistic case -- if this is the pessimistic case, why even try the previous case?*/
  //burst_latency += MAX(((100*crtc->burst_size * crtc->pclk_period / crtc->drain_rate / mem.mclk_period) - burst_latency, 0);
  burst_temp = 100 * crtc->burst_size * crtc->pclk_period / crtc->drain_rate / mem->mclk_period;
  if (burst_temp > burst_latency)
      burst_latency = burst_temp;

#if 1
    burst_temp = crtc->hres * crtc->pclk_period + crtc->burst_size * mem->mclk_period / mem->data_rate;
    burst_temp2 = crtc->request_delay
        + (mem->pipeline_latency + mem->command_latency) * mem->mclk_period
        + 100 * crtc->burst_size * crtc->pclk_period / crtc->drain_rate;

    if (burst_temp >= burst_temp2) {
        bursts_during_active = (burst_temp - burst_temp2) / (burst_latency * mem->mclk_period);
    } else {
      bursts_during_active = 0;
    }
#else
    bursts_during_active = (crtc->hres * crtc->pclk_period -
              crtc->request_delay -
              mem->pipeline_latency * mem->mclk_period -
              mem->command_latency * mem->mclk_period -
              100*crtc->burst_size * crtc->pclk_period / crtc->drain_rate +
              crtc->burst_size * mem->mclk_period / mem->data_rate
              ) /
             (burst_latency * mem->mclk_period);
#endif

  final_bursts_during_active = compute_fifo_size(&crtc->fifo, crtc->hres, crtc->drain_rate, crtc->burst_size,
                       crtc->request_delay, crtc->pclk_period, burst_latency, bursts_during_active,
                         mem);

  /* can we fill to the LWM mark in the blanking period? */
  if (new_cant_fill_to_lwm(crtc, mem, burst_latency, (crtc->enable+crtc2->enable)*cursor_latency, final_bursts_during_active)) {
    errors++;
  }
  
  /* can we get enough data? */
  if (insufficient_data(crtc->hres, crtc->depth, crtc->fifo.lwm, final_bursts_during_active, crtc->burst_size)) {
    errors++;
  }

  return errors;
}



/***********************************************/
static U032
test_scaler_constraints(scaler_t *scaler, crtc_t *crtc, crtc_t *crtc2, rtr_t *rtr, mem_t *mem)
{
  U032 errors = 0;
  U032 burst_latency;
  U032 bursts_during_active;
  U032 final_bursts_during_active;
  U032 num_rtrs, total_burst_size;
  U032 burst_temp, burst_temp2;
      
  if (!scaler->enable) return 0;

  /*intermediate values used to calculate burst_latency*/
  num_rtrs         = crtc->enable + crtc2->enable + scaler->enable;
  total_burst_size = crtc->enable*crtc->burst_size + crtc2->enable*crtc2->burst_size + scaler->enable*scaler->burst_size;

  burst_latency = num_rtrs         * mem->arbitration_latency + 
                  total_burst_size / mem->data_rate           +
                  num_rtrs         * mem->stall_cycles        +
                  (crtc->enable   * ((crtc->burst_size  +mem->page_fault_width-1) / mem->page_fault_width) +
                   crtc2->enable  * ((crtc2->burst_size +mem->page_fault_width-1) / mem->page_fault_width) +
                   scaler->enable * ((scaler->burst_size+mem->page_fault_width-1) / mem->page_fault_width)
                  ) * mem->page_fault_penalty;

  
  /* optimistic case */
#if 1
  burst_temp = scaler->window_hres * scaler->pclk_period + scaler->burst_size * mem->mclk_period / mem->data_rate;
  burst_temp2 = scaler->request_delay
      + (mem->pipeline_latency + mem->command_latency) * mem->mclk_period
      + 100 * scaler->burst_size * scaler->pclk_period / scaler->drain_rate;

    if (burst_temp >= burst_temp2) {
        bursts_during_active = (burst_temp - burst_temp2) / (burst_latency * mem->mclk_period);
    } else {
      bursts_during_active = 0;
    }
#else
  bursts_during_active = (scaler->window_hres  * scaler->pclk_period -
                 scaler->request_delay -
                 mem->pipeline_latency * mem->mclk_period -
                 mem->command_latency  * mem->mclk_period -
                 100*scaler->burst_size   * scaler->pclk_period / scaler->drain_rate +
                 scaler->burst_size   * mem->mclk_period / mem->data_rate
                 ) /
                (burst_latency * mem->mclk_period);
#endif

  final_bursts_during_active = compute_fifo_size(&scaler->fifo, scaler->window_hres, scaler->drain_rate, scaler->burst_size,
               scaler->request_delay, scaler->pclk_period, burst_latency, bursts_during_active,
               mem);

  if (scaler_cant_fill_to_lwm(scaler, crtc, crtc2, mem, burst_latency, 0, final_bursts_during_active)) {
    errors++;
  }
  
  /* can we get enough data? */
  if (insufficient_data(scaler->source_hres, scaler->depth, scaler->fifo.lwm, final_bursts_during_active, scaler->burst_size)) {
    errors++;
  }

  if (errors) return errors;

  /* pessimistic case */
  //burst_latency += MAX((100* scaler->burst_size * scaler->pclk_period / scaler->drain_rate / mem.mclk_period) - burst_latency, 0);
  burst_temp = 100* scaler->burst_size * scaler->pclk_period / scaler->drain_rate / mem->mclk_period;
  if (burst_temp > burst_latency)
      burst_latency = burst_temp;

#if 1
  burst_temp = scaler->window_hres * scaler->pclk_period + scaler->burst_size * mem->mclk_period / mem->data_rate;
  burst_temp2 = scaler->request_delay
      + (mem->pipeline_latency + mem->command_latency) * mem->mclk_period
      + 100 * scaler->burst_size * scaler->pclk_period / scaler->drain_rate;

    if (burst_temp >= burst_temp2) {
        bursts_during_active = (burst_temp - burst_temp2) / (burst_latency * mem->mclk_period);
    } else {
      bursts_during_active = 0;
    }
#else
  bursts_during_active = (scaler->window_hres  * scaler->pclk_period -
                 scaler->request_delay -
                 mem->pipeline_latency * mem->mclk_period -
                 mem->command_latency  * mem->mclk_period -
                 100* scaler->burst_size   * scaler->pclk_period / scaler->drain_rate +
                 scaler->burst_size   * mem->mclk_period / mem->data_rate
                 ) /
                (burst_latency * mem->mclk_period);
#endif

  final_bursts_during_active = compute_fifo_size(&scaler->fifo, scaler->window_hres, scaler->drain_rate, scaler->burst_size,
               scaler->request_delay, scaler->pclk_period, burst_latency, bursts_during_active,
               mem);

  /* can we fill to the LWM mark in the blanking period? */
  if (scaler_cant_fill_to_lwm(scaler, crtc, crtc2, mem, burst_latency, 0, final_bursts_during_active)) {
    errors++;
  }
  
  /* can we get enough data? */
  if (insufficient_data(scaler->source_hres, scaler->depth, scaler->fifo.lwm, final_bursts_during_active, scaler->burst_size)) {
    errors++;
  }

  return errors;
}



/******************************/
static U032
test_configuration(crtc_t *crtc, crtc_t *crtc2, scaler_t *scaler, rtr_t *rtr, U032 max_burst_size, mem_t *mem, U032 fifo_size)
{
  U032 error;

  error = insufficient_total_bandwidth(crtc, crtc2, scaler, mem);
  if (error) {
    return error;
  }

  for (crtc->burst_size = crtc->min_burst_size; crtc->burst_size <= max_burst_size; crtc->burst_size += 16) {

    error = 0;

    if (scaler->enable)
    guess_scaler_burstsize(scaler, crtc, crtc2);
    if (crtc2->enable)
    guess_crtc2_burstsize(crtc2, crtc);

    error = test_crtc_constraints(crtc, crtc2, scaler, rtr, mem);
    if (error)
      continue;
    if (crtc2->enable) {
      error = test_crtc_constraints(crtc2, crtc, scaler, rtr, mem);
      if (error)
        continue;
    }
    if (test_scaler_constraints(scaler, crtc, crtc2, rtr, mem))
      error++;
    if (scaler->burst_size > max_burst_size)
    error++;

    if (test_fifo_constraints(fifo_size, crtc, crtc2, scaler))
      error++;
    if (!error) 
      break;

     if (scaler->enable) {
    for (scaler->burst_size += scaler->min_burst_size; scaler->burst_size <= max_burst_size; scaler->burst_size += 16) {
        if (test_scaler_constraints(scaler, crtc, crtc2, rtr, mem))
          error = 1;
        if (test_fifo_constraints(fifo_size, crtc, crtc2, scaler))
          error++;
      if (!error) break;
    }
    if (!error) {
      if (test_crtc_constraints(crtc, crtc2, scaler, rtr, mem))
            error = 1;
      if (crtc2->enable && test_crtc_constraints(crtc2, crtc, scaler, rtr, mem))
            error++;
    }
    }
    if (test_fifo_constraints(fifo_size, crtc, crtc2, scaler))
      error++;
    if (!error) break;
  }

  return(error);
}

//
// Main NV11 arbitration routine
//
void NV11_dacCalculateArbitration(
    PHALHWINFO pHalHwInfo,
    fifo_info *fifo,
    sim_state *arb)
{
  crtc_t crtc;
  crtc_t crtc2;
  scaler_t scaler;
  rtr_t rtr;
  mem_t mem;
//  U032 i;
//  U032 maxd, maxr;
  U032 error;
  U032 data_in_line1, data_in_line2, data_in_lineS;
 
  /*NV11 default values*/
  U032 page_fault_penalty   = 2;
  U032 page_fault_width     = 256;
  U032 arbitration_latency  = 10;
  U032 pipeline_latency     = 28;
  U032 stall_cycles         = 3;

  U032 min_burst_size   =   16;
  U032 max_burst_size   = 2048;
  U032 crtc_fifo_size   = 2048; /*CRTC fifo size in bytes*/
  U032 scaler_fifo_size = 1856; /*video scaler's fifo size*/
 
  U032 partition_data_width;
  U032 ddr;
 
  /* set up some default values for the CRTC ... */
  U032 hres    ;
  U032 htotal  ;
  U032 hres2   ;
  U032 htotal2 ;
  U032 vres    ;
  U032 vres2   ;
  U032 nativeVRes;
  U032 nativeVRes2;
  U032 refresh ;
  U032 refresh2;
  U032 depth   ;
  U032 depth2  ;
  U032 crtc_request_delay_mclks = 6;
  U032 crtc_request_delay_pclks = 6;
  U032 crtc_burst_size = 0;
  U032 cursor_burst_size = 256;
  U032 crtc2_enable, crtc_enable;
  U032 video_source_hres;
  U032 video_source_vres;
  U032 h2_owns_vs  ;
  U032 mclk;
  U032 pclk, pclk2;
 
  /* ... the scaler ... */
  U032 scaler_disable;
  U032 scaler_depth = 16;
  U032 scaler_burst_size = 0;
  /*Same as FBI interface, in bytes*/
  U032 scaler_window_hres = 0;
  U032 scaler_window_vres = 0;
  U032 scaler_request_delay_mclks = 4;
  U032 scaler_request_delay_pclks = 6;
  
  /* ... the memory controller ... */
  U032 partitions = 1;
  U032 refresh_penalty = 9;
  arb_type arbiter = round_robin;
  U032 depth_cmd = 3;
  U032 depth_rw = 8;
  U032 rtr_interrupt_rate = 0;
  
  /* ... and the real-time requestor */
  /* to disable this, just leave the burst_size as 0 */
  U032 rtr_request_delay_mclks = 4;
  U032 rtr_burst_size = 0;

  U032 who_owns_scaler;

  crtc_enable       = arb->enable_h1;
  crtc2_enable      = arb->enable_h2;
  scaler_disable    = !(arb->enable_video);
  video_source_hres = arb->video_source_hres;
  video_source_vres = arb->video_source_vres;
  h2_owns_vs        = arb->h2_owns_vs;

  hres         = arb->hres;
  htotal       = arb->htotal;
  vres         = arb->vres;
  depth        = arb->pix_bpp;
  refresh      = arb->refresh;
  pclk         = arb->pclk_khz / 1000;
  nativeVRes   = arb->nativeVRes;

  hres2        = arb->hres2;
  htotal2      = arb->htotal2;
  vres2        = arb->vres2;
  depth2       = arb->pix_bpp_h2;
  refresh2     = arb->refresh2;
  pclk2        = arb->pclk2_khz / 1000;
  nativeVRes2  = arb->nativeVRes2;

  partition_data_width = arb->memory_width;
  ddr                  = arb->memory_type;
  mclk                 = arb->mclk_khz / 1000;

  init_mem(&mem, mclk, ddr, arbiter, partitions, partition_data_width, page_fault_penalty,
       page_fault_width, refresh_penalty, arbitration_latency, pipeline_latency, stall_cycles,
       depth_cmd, depth_rw, rtr_interrupt_rate);
  init_crtc(&crtc, crtc_enable,
            hres, vres, nativeVRes, depth, refresh,
            crtc_request_delay_mclks, crtc_request_delay_pclks,
         crtc_burst_size, min_burst_size, max_burst_size, cursor_burst_size,
        pclk, htotal, &mem);
  init_crtc(&crtc2, crtc2_enable,
            hres2, vres2, nativeVRes2, depth2, refresh2,
            crtc_request_delay_mclks, crtc_request_delay_pclks,
         crtc_burst_size, min_burst_size, max_burst_size, cursor_burst_size,
            pclk2, htotal2, &mem);
  init_scaler(&scaler, &crtc, &crtc2, mclk,
              (scaler_disable) ? 0 : 1, video_source_hres, video_source_vres, h2_owns_vs, scaler_depth,
              scaler_window_hres, scaler_window_vres,
           scaler_burst_size, min_burst_size, max_burst_size,
           scaler_request_delay_mclks, scaler_request_delay_pclks, scaler_fifo_size);
  init_rtr(&rtr, rtr_burst_size, rtr_request_delay_mclks, &mem);

//  if ((hres2*depth2*1000/crtc2.hclk_period) > (hres*depth*1000/crtc.hclk_period)) {
  //For the purposes of this calc, assign scaler to head with worst bandwidth constraints.
  who_owns_scaler = 0;
  if (crtc2.enable && crtc.enable) {
    if ((hres2*depth2*1000/crtc2.hclk_period) > (hres*depth*1000/crtc.hclk_period))
        who_owns_scaler = 1;
  } else {
      if (crtc2.enable)
        who_owns_scaler = 1;
  }

  if (!crtc.enable) {
    scaler.h2_owns_vs = !scaler.h2_owns_vs; /*swap which head scaler is owned by when swapping heads*/
    error = test_configuration(&crtc2, &crtc,  &scaler, &rtr, max_burst_size, &mem, crtc_fifo_size); 
    scaler.h2_owns_vs = !scaler.h2_owns_vs;
  } else if (!crtc2.enable) {
    error = test_configuration(&crtc,  &crtc2, &scaler, &rtr, max_burst_size, &mem, crtc_fifo_size); 
  } else if (who_owns_scaler) {
    scaler.h2_owns_vs = !scaler.h2_owns_vs; /*swap which head scaler is owned by when swapping heads*/
    error = test_configuration(&crtc2, &crtc,  &scaler, &rtr, max_burst_size, &mem, crtc_fifo_size); 
    scaler.h2_owns_vs = !scaler.h2_owns_vs;
  } else
    error = test_configuration(&crtc,  &crtc2, &scaler, &rtr, max_burst_size, &mem, crtc_fifo_size); 

  //Fall back to sensible defaults if this is an unsupported resolution
  if (error) {
      crtc.burst_size = 768;
      crtc2.burst_size = 768;
      scaler.burst_size = 768;
      crtc.fifo.lwm = 1280;
      crtc2.fifo.lwm = 1280;
      scaler.fifo.lwm = 1088;
  }

  //Compute the amount of data in a single horizontal line
  data_in_line1 = crtc.hres          * crtc.depth   / 8;
  data_in_line2 = crtc2.hres         * crtc2.depth  / 8; 
  data_in_lineS = scaler.source_hres * scaler.depth / 8;

  //It is really inefficent to have a burst size smaller than 256 bytes.
  if (crtc.burst_size   < 256)
    crtc.burst_size   = 256;
  if (crtc2.burst_size  < 256)
    crtc2.burst_size  = 256;
  if (scaler.burst_size < 256)
    scaler.burst_size = 256;

  //It is wasteful to have a burst size larger than the amount of data in a line
  if (crtc.burst_size   > data_in_line1)
    crtc.burst_size   = data_in_line1;
  if (crtc2.burst_size  > data_in_line2)
    crtc2.burst_size  = data_in_line2;
  if (scaler.burst_size > data_in_lineS)
    scaler.burst_size = data_in_lineS;


  //LPL: addition to set watermarks as high as possible instead
  // of as low as possible.  This presumably obviates the need
  // for some other calculation effort earler.

  //Get best performance for the real-time requestors by setting LWM
  //as high as possible without risking overflow.
  crtc.fifo.lwm   = crtc_fifo_size   - crtc.burst_size  ;
  crtc2.fifo.lwm  = crtc_fifo_size   - crtc2.burst_size ;
  scaler.fifo.lwm = scaler_fifo_size - scaler.burst_size;

  //LWM should not be larger than the amount of data in a line
  if (crtc.fifo.lwm > data_in_line1)
    crtc.fifo.lwm = data_in_line1;
  if (crtc2.fifo.lwm > data_in_line2)
    crtc2.fifo.lwm = data_in_line2;
  if (scaler.fifo.lwm > data_in_lineS)
    scaler.fifo.lwm = data_in_lineS;
 
  fifo->valid = !error;
  fifo->crtc1_lwm = crtc.fifo.lwm;
  fifo->crtc2_lwm = crtc2.fifo.lwm;
  fifo->video_lwm = scaler.fifo.lwm;
  fifo->crtc1_burst_size = crtc.burst_size;
  fifo->crtc2_burst_size = crtc2.burst_size;
  fifo->video_burst_size = scaler.burst_size;
}


//////////////////////////////////////////
//
// NV 10 arbitration routines
//
static
VOID NV10_dacCalculateArbitration
(
    PHALHWINFO pHalHwInfo,
    fifo_info *fifo,
    sim_state  *arb
)
{
  int data, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
  int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
  int nvclk_fill, us_extra;
  int found, mclk_extra, mclk_loop, cbs, m1;
  int mclk_freq, pclk_freq, nvclk_freq, mp_enable;
  int us_m, us_m_min, us_n, us_p, video_drain_rate, crtc_drain_rate;
  int vus_m, vus_n, vus_p;
  int vpm_us, us_video, vlwm, cpm_us, us_crt,clwm;
  int clwm_rnd_down;
  int craw, m2us, us_pipe, us_pipe_min, vus_pipe, p1clk, p2;
  int pclks_2_top_fifo, min_mclk_extra;
  int us_min_mclk_extra;

  fifo->valid = 1;
  pclk_freq = arb->pclk_khz; // freq in KHz
  mclk_freq = arb->mclk_khz;
  nvclk_freq = arb->nvclk_khz;
  pagemiss = arb->mem_page_miss;
  cas = arb->mem_latency;
  width = arb->memory_width/64;
  video_enable = arb->enable_video;
  color_key_enable = arb->gr_during_vid;
  bpp = arb->pix_bpp;
  align = arb->mem_aligned;
  mp_enable = arb->enable_mp;
  clwm = 0;
  vlwm = 1024;

  cbs = 512;
  vbs = 512;

  pclks = 4; // lwm detect.

  nvclks = 3; // lwm -> sync.
  nvclks += 2; // fbi bus cycles (1 req + 1 busy)

  mclks  = 1;   // 2 edge sync.  may be very close to edge so just put one.

  mclks += 1;   // arb_hp_req
  mclks += 5;   // ap_hp_req   tiling pipeline

  mclks += 2;    // tc_req     latency fifo
  mclks += 2;    // fb_cas_n_  memory request to fbio block
  mclks += 7;    // sm_d_rdv   data returned from fbio block

  // fb.rd.d.Put_gc   need to accumulate 256 bits for read
  if (arb->memory_type == 0)
  {
    if (arb->memory_width == 64) // 64 bit bus
      mclks += 4;
    else
      mclks += 2;
  }
  else
  {
    if (arb->memory_width == 64) // 64 bit bus
      mclks += 2;
    else
      mclks += 1;
  }

  if ((!video_enable) && (arb->memory_width == 128))
  {  
    mclk_extra = (bpp == 32) ? 31 : 42; // Margin of error
    min_mclk_extra = 17;
  }
  else
  {
    mclk_extra = (bpp == 32) ? 8 : 4; // Margin of error
    //mclk_extra = 4; // Margin of error
    min_mclk_extra = 18;
  }

  nvclks += 1; // 2 edge sync.  may be very close to edge so just put one.
  nvclks += 1; // fbi_d_rdv_n
  nvclks += 1; // Fbi_d_rdata
  nvclks += 1; // crtfifo load

  if(mp_enable)
    mclks+=4; // Mp can get in with a burst of 8.
  // Extra clocks determined by heuristics

  nvclks += 0;
  pclks += 0;
  found = 0;
  while(found != 1) {
    fifo->valid = 1;
    found = 1;
    mclk_loop = mclks+mclk_extra;
    us_m = mclk_loop *1000*1000 / mclk_freq; // Mclk latency in us
    us_m_min = mclks * 1000*1000 / mclk_freq; // Minimum Mclk latency in us
    us_min_mclk_extra = min_mclk_extra *1000*1000 / mclk_freq;
    us_n = nvclks*1000*1000 / nvclk_freq;// nvclk latency in us
    us_p = pclks*1000*1000 / pclk_freq;// nvclk latency in us
    us_pipe = us_m + us_n + us_p;
    us_pipe_min = us_m_min + us_n + us_p;
    us_extra = 0;

    vus_m = mclk_loop *1000*1000 / mclk_freq; // Mclk latency in us
    vus_n = (4)*1000*1000 / nvclk_freq;// nvclk latency in us
    vus_p = 0*1000*1000 / pclk_freq;// pclk latency in us
    vus_pipe = vus_m + vus_n + vus_p;

    if(video_enable) {
      video_drain_rate = pclk_freq * 4; // MB/s
      crtc_drain_rate = pclk_freq * bpp/8; // MB/s

      vpagemiss = 1; // self generating page miss
      vpagemiss += 1; // One higher priority before

      crtpagemiss = 2; // self generating page miss
      if(mp_enable)
          crtpagemiss += 1; // if MA0 conflict

      vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;

      us_video = vpm_us + vus_m; // Video has separate read return path

      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =
        us_video  // Wait for video
        +cpm_us // CRT Page miss
        +us_m + us_n +us_p // other latency
        ;

      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that
    } else {
      crtc_drain_rate = pclk_freq * bpp/8; // bpp * pclk/8

      crtpagemiss = 1; // self generating page miss
      crtpagemiss += 1; // MA0 page miss
      if(mp_enable)
          crtpagemiss += 1; // if MA0 conflict
      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =  cpm_us + us_m + us_n + us_p ;
      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that

/*
        //
        // Another concern, only for high pclks so don't do this
        // with video:
        // What happens if the latency to fetch the cbs is so large that
        // fifo empties.  In that case we need to have an alternate clwm value
        // based off the total burst fetch
        //
        us_crt = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
        us_crt = us_crt + us_m + us_n + us_p + (4 * 1000 * 1000)/mclk_freq;
        clwm_mt = us_crt * crtc_drain_rate/(1000*1000);
        clwm_mt ++;
        if(clwm_mt > clwm)
            clwm = clwm_mt;
*/
        // Finally, a heuristic check when width == 64 bits
        if(width == 1){
            nvclk_fill = nvclk_freq * 8;
            if(crtc_drain_rate * 100 >= nvclk_fill * 102)
                    clwm = 0xfff; //Large number to fail

            else if(crtc_drain_rate * 100  >= nvclk_fill * 98) {
                clwm = 1024;
                cbs = 512;
                us_extra = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
            }
        }
    }


    /*
      Overfill check:
    */

    clwm_rnd_down = ((int)clwm/8)*8;
    if (clwm_rnd_down < clwm)
        clwm += 8;
        
    m1 = clwm + cbs -  1024; /* Amount of overfill */
    m2us = us_pipe_min + us_min_mclk_extra;
    pclks_2_top_fifo = (1024-clwm)/(8*width);
    
    /* pclk cycles to drain */
    p1clk = m2us * pclk_freq/(1000*1000); 
    p2 = p1clk * bpp / 8; // bytes drained.
    
    if((p2 < m1) && (m1 > 0)) {
        fifo->valid = 0;
        found = 0;
        if(min_mclk_extra == 0)   {
          if(cbs <= 32) {
            found = 1; // Can't adjust anymore!
          } else {
            cbs = cbs/2;  // reduce the burst size
          }
        } else {
          min_mclk_extra--;
        }
    } else {
      if (clwm > 1023){ // Have some margin
        fifo->valid = 0;
        found = 0;
        if(min_mclk_extra == 0)   
            found = 1; // Can't adjust anymore!
        else 
            min_mclk_extra--;
      }
    }
    craw = clwm;
    
    if(clwm < (1024-cbs+8)) clwm = 1024-cbs+8;
    data = (int)(clwm);
    //  printf("CRT LWM: %f bytes, prog: 0x%x, bs: 256\n", clwm, data );
    fifo->crtc1_lwm = data;   fifo->crtc1_burst_size = cbs;

    //  printf("VID LWM: %f bytes, prog: 0x%x, bs: %d\n, ", vlwm, data, vbs );
    fifo->video_lwm = 1024;  fifo->video_burst_size = 512;
  }
}

/*
//
// Determine if the video overlay is usable in the current configuration.  This
// routine will also update the global variables in pDev which determine the 
// maximum downscaling allowed at various source image sizes.
//
//  Return 0 if not capable (at any upscale or downscale factor)
//  Return ~0 if capable (see pDev for downscale limits)
//
U032 NV10_dacCalculateVideoCaps
(
    PHWINFO pDev
)
{
    //
    // First look for a match of memory type, resolution, and clocks.
    //
    // NOTE: For now, until I can straighten out all of the hardware data,
    // assume a conservative limit.
    //
    switch (pDev->Chip.HalInfo.MaskRevision)
    {
        case 0xA1:
        case 0xA2:
        case 0xA6:
        
            pDev->Video.OverlayMaxDownscale_768  = 2;
            pDev->Video.OverlayMaxDownscale_1280 = 2;
            pDev->Video.OverlayMaxDownscale_1920 = 2;
            break;
            
        default:

            pDev->Video.OverlayMaxDownscale_768  = 8;
            pDev->Video.OverlayMaxDownscale_1280 = 4;
            pDev->Video.OverlayMaxDownscale_1920 = 2;
            break;
    }

    //
    // For now, always assume we can support some level of overlay
    // (although not to the same level of downscale ability)
    //
    return 1;

}
*/

typedef struct tagNV10_DacAGPClockEntry
{
    U032 frequency;
    U032 setting;
} NV10_DacAGPClockEntry;

NV10_DacAGPClockEntry NV10_dacAGPClockTable[] =
{
    { 133000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_133MHZ },
    { 126000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_126MHZ },
    { 120000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_120MHZ },
    { 113000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_113MHZ },
    { 106000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_106MHZ },
    { 100000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_100MHZ },
    { 94000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_94MHZ },
    { 87000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_87MHZ },
    { 80000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_80MHZ },
    { 73000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_73MHZ },
    { 66000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ },
    { 0, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ - 1 }
};

//
// HAL stuff
//

// forwards
RM_STATUS nvHalDacControl_NV10(VOID *);
RM_STATUS nvHalDacAlloc_NV10(VOID *);
RM_STATUS nvHalDacFree_NV10(VOID *);
RM_STATUS nvHalDacSetStartAddr_NV10(VOID *);
RM_STATUS nvHalDacProgramMClk_NV10(VOID *);
RM_STATUS nvHalDacProgramNVClk_NV10(VOID *);
RM_STATUS nvHalDacProgramPClk_NV10(VOID *);
RM_STATUS nvHalDacProgramCursorImage_NV10(VOID *);
RM_STATUS nvHalDacGetRasterPosition_NV10(VOID *);
RM_STATUS nvHalDacValidateArbSettings_NV10(VOID *arg);
RM_STATUS nvHalDacUpdateArbSettings_NV10(VOID *arg);

//
// nvHalDacControl
//
RM_STATUS
nvHalDacControl_NV10(VOID *arg)
{
    PDACCONTROLARG_000 pDacControlArg = (PDACCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEOHALINFO pVideoHalInfo;
    PDACHALINFO_NV10 pDacHalPvtInfo;

    //
    // Verify interface revision.
    //
    if (pDacControlArg->id != DAC_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacControlArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;
    pDacHalPvtInfo = (PDACHALINFO_NV10)pHalHwInfo->pDacHalInfo;

    switch (pDacControlArg->cmd)
    {
        case DAC_CONTROL_INIT:

            // set bus width
            if (REG_RD_DRF(_PFB, _CFG, _BUS) == NV_PFB_CFG_BUS_128)
                pDacHalInfo->InputWidth = 128;
            else
                pDacHalInfo->InputWidth = 64;

            // initialize default crtc parameters
            pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 350000000;
            pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 350000000;
            pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 300000000;
            pDacHalInfo->CrtcInfo[0].RegOffset = 0x00000000;

            //
            // Head 0 supports everything (?).
            //
            pDacHalInfo->CrtcInfo[0].DisplayTypesAllowed =
                DISPLAYTYPEBIT(DISPLAY_TYPE_MONITOR) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_TV) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_DUALSURFACE) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_FLAT_PANEL);

            // if we're an nv11, we need to setup a second crtc
            // The capabilities of the second head should be determined by the BIOS,
            // but for now we will hard code them. These capabilities are such things 
            // as the presence of an external DAC, and the frequency specification.

            // The values set here will be replaced in dacinit.c/initDac if it is able
            // to find the proper tables in the BIOS
            if (IsNV11_NV10(pHalHwInfo->pMcHalInfo))
            {
                U032 i, data32, crtcAddr;
                U008 lock;

                //NVASSERT(pDacHalInfo->NumCrtcs == 2);
                pDacHalInfo->CrtcInfo[1].PCLKLimit8bpp  = 150000000;
                pDacHalInfo->CrtcInfo[1].PCLKLimit16bpp = 150000000;
                pDacHalInfo->CrtcInfo[1].PCLKLimit32bpp = 150000000;
                pDacHalInfo->CrtcInfo[1].RegOffset = 0x00002000;

                //
                // Head 1 supports TV and flat panel, and CRT, if an external DAC is present
                //
                pDacHalInfo->CrtcInfo[1].DisplayTypesAllowed =
                    DISPLAYTYPEBIT(DISPLAY_TYPE_MONITOR) |      // assume external DAC
                    DISPLAYTYPEBIT(DISPLAY_TYPE_TV) |
                    DISPLAYTYPEBIT(DISPLAY_TYPE_FLAT_PANEL);

                // turn on CRTC big endian on 2nd head if we're setup for big endian mode
                if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
                {
                    U032 crtcOffset;
                    U032 config;
                    crtcOffset = pDacHalInfo->CrtcInfo[1].RegOffset;
                    config = REG_RD32(NV_PCRTC_CONFIG + crtcOffset);
                    config |= DRF_DEF(_PCRTC, _CONFIG, _ENDIAN, _BIG);
                    REG_WR32(NV_PCRTC_CONFIG + crtcOffset, config);
                }

                //
                // While we're here, increase TV out latency.
                //
                for (i = 0; i < pDacHalInfo->NumCrtcs; i++)
                {
                    crtcAddr = pDacHalInfo->CrtcInfo[i].RegOffset;

                    // Unlock CRTC extended regs
                    HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, crtcAddr);
                    HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, crtcAddr);

                    // Add 4 per Raj Rao...
                    HAL_CRTC_RD(NV_CIO_CRE_TVOUT_LATENCY, data32, crtcAddr);
                    data32 += 4;
                    HAL_CRTC_WR(NV_CIO_CRE_TVOUT_LATENCY, data32, crtcAddr);

                    // Relock if necessary...
                    if (lock == 0)
                        HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, crtcAddr);
                }
            }

            // turn on CRTC big endian if we're setup for big endian mode
            if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
            {
                FLD_WR_DRF_NUM(_PCRTC, _CONFIG, _ENDIAN, NV_PCRTC_CONFIG_ENDIAN_BIG);
            }

            //
            // Set default downscale values.
            // 
            pVideoHalInfo->OverlayMaxDownscale_768  = 8;
            pVideoHalInfo->OverlayMaxDownscale_1280 = 8;
            pVideoHalInfo->OverlayMaxDownscale_1920 = 8;

            break;
        case DAC_CONTROL_DITHER_DISABLE:
            // disable dithering
            FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_DITHER_2D, _DISABLED);
            FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_DITHER_2D, _DISABLED);
            break;
        case DAC_CONTROL_DITHER_ENABLE:
            // enable dithering
            FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_DITHER_2D, _ENABLED);
            FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_DITHER_2D, _ENABLED);
            break;
        case DAC_CONTROL_LOAD:
        case DAC_CONTROL_UNLOAD:
        case DAC_CONTROL_DESTROY:
        case DAC_CONTROL_UPDATE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

RM_STATUS
nvHalDacAlloc_NV10(VOID *arg)
{
    PDACALLOCARG_000 pDacAllocArg = (PDACALLOCARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDacAllocArg->id != DAC_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Verify that class and head parameters are legal for this chip.
    //

    return (RM_OK);
}

RM_STATUS
nvHalDacFree_NV10(VOID *arg)
{
    PDACFREEARG_000 pDacFreeArg = (PDACFREEARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDacFreeArg->id != DAC_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);    

    return (RM_OK);
}

RM_STATUS
nvHalDacSetStartAddr_NV10(VOID *arg)
{
    PDACSETSTARTADDRARG_000 pDacSetStartAddrArg = (PDACSETSTARTADDRARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    PDACHALINFO pDacHalInfo;
    U032    crtcOffset;
    //
    // Verify interface revision.
    //
    if (pDacSetStartAddrArg->id != DAC_SET_START_ADDR_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacSetStartAddrArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT)pDacSetStartAddrArg->pHalObjInfo;

    crtcOffset = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    REG_WR32(NV_PCRTC_START + crtcOffset, pDacSetStartAddrArg->startAddr);

    return (RM_OK);
}

//
// nvHalDacProgramMClk_NV10 - Program MCLK based on the value in pDacHalInfo->MClk
//
// This routine uses the value in pDacHalInfo->MClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramMClk_NV10(VOID *arg)
{
    PDACPROGRAMMCLKARG_000 pDacProgramMClkArg = (PDACPROGRAMMCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 oldMClkScaled;
    U032 newMClkScaled;
    U032 oldTiming2Refresh;
    U032 newTiming2Refresh;
    U032 Loops;
    U032 IsPllLocked;
    U032 CurDacAdr;
    U032 lockVal[2];
    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramMClkArg->id != DAC_PROGRAMMCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramMClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;

    mNew = pDacHalInfo->MPllM;
    nNew = pDacHalInfo->MPllN;
    pNew = pDacHalInfo->MPllP;

    // Program the hardware

    if (pDacProgramMClkArg->DisableDLLs) 
    {
        U032 i;
        U032 regword;
        U032 cursorConfig;

        for (i = 0; i < pHalHwInfo->pDacHalInfo->NumCrtcs; i++)
        {
            CurDacAdr = pDacHalInfo->CrtcInfo[i].RegOffset;

            // Save original lock value
            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lockVal[i], CurDacAdr);

            // Unlock the extended registers
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr);

            // Disable access to frame buffer by setting bit 6 of
            // Fifo reset to 1.
            HAL_CRTC_RD(NV_CIO_CRE_ENH_INDEX, regword, CurDacAdr);
            regword |= BIT(6);
            HAL_CRTC_WR(NV_CIO_CRE_ENH_INDEX, regword, CurDacAdr);

            // Disable the cursor so it doesnt access the frame buffer
            cursorConfig = HAL_DAC_REG_RD32(NV_PCRTC_CURSOR_CONFIG, CurDacAdr);
            // Clear the enable bit
            cursorConfig &= ~(1 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_ENABLE));
            HAL_DAC_REG_WR32(NV_PCRTC_CURSOR_CONFIG, cursorConfig, CurDacAdr);

        }

        // Disable DLLs before changing clocks.
        REG_WR32(NV_PFB_EMRS, 
                 DRF_NUM( _PFB, _EMRS, _DLL, NV_PFB_EMRS_DLL_DISABLE));
    }

    // Retrieve original coefficients
    coeff = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
    mOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first
        REG_WR32
            (
                NV_PRAMDAC_MPLL_COEFF,
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _PDIV, pOld)
            );

        // Wait until M PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _MPLL_LOCK)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _MPLL_LOCK)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: M PLL not locked\n");
        }
    }

    // Now we can write the final value
    REG_WR32
        (
            NV_PRAMDAC_MPLL_COEFF,
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _PDIV, pNew)
        );

    // Wait for M PLL to lock.
    osDelay(64 /* ms */);

    if (!pDacProgramMClkArg->DisableDLLs) 
    {
        // Reset (resync) the frame buffer DRAM DLL.
        FLD_WR_DRF_DEF( _PFB, _MRS, _DLL, _RESET );
    }
    else
    {
        U032 i;
        U032 regword;
        U032 cursorConfig;

        // Re-enable DLLs 
        REG_WR32(NV_PFB_EMRS, 
                 DRF_NUM( _PFB, _EMRS, _DLL, NV_PFB_EMRS_DLL_ENABLE));
        osDelay(1); // 1 ms

        // Reset (resync) the frame buffer DRAM DLL.
        FLD_WR_DRF_DEF( _PFB, _MRS, _DLL, _RESET );

        osDelay(1); // 1 ms

        // Reset again just to make sure.
        FLD_WR_DRF_DEF( _PFB, _MRS, _DLL, _RESET );

        // Re-enable access to FB.

        for (i = 0; i < pHalHwInfo->pDacHalInfo->NumCrtcs; i++)
        {
            CurDacAdr = pDacHalInfo->CrtcInfo[i].RegOffset;

            // Re-enable access to frame buffer by setting bit 6 of
            // Fifo reset to 0.
            HAL_CRTC_RD(NV_CIO_CRE_ENH_INDEX, regword, CurDacAdr);
            regword &= ~(BIT(6));
            HAL_CRTC_WR(NV_CIO_CRE_ENH_INDEX, regword, CurDacAdr);

            // Re-enable the cursor
            cursorConfig = HAL_DAC_REG_RD32(NV_PCRTC_CURSOR_CONFIG, CurDacAdr);
            // Set the enable bit
            cursorConfig |= (1 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_ENABLE));
            HAL_DAC_REG_WR32(NV_PCRTC_CURSOR_CONFIG, cursorConfig, CurDacAdr);

            // Restore original lock values 
            switch (lockVal[i])
            {
                case 0:
                    HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr);
                    break;
                case 1:
                    HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RO_VALUE, CurDacAdr);
                    break;
                case 3:
                    HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr);
                    break;
            }
        }
    }

    // Update the number of clock cycles per memory refresh cycle.
    
    // Determine original frequency from old M, N, P values, 
    // scale down both old and new to avoid 32-bit overflow later.  
    // NV_PFB_TIMING2_REFRESH is max 11 bits, mclk is max 30 bits.
    
    oldMClkScaled  = (nOld * pMcHalInfo->CrystalFreq / (1 << pOld) / mOld) >> (11 + 30 - 32);
    
    newMClkScaled  = pDacHalInfo->MClk >> (11 + 30 - 32);

    if (oldMClkScaled != newMClkScaled)
    {
        // Scale the refresh-delay by the ratio between new and old frequencies.
        // Be careful to round rather than truncate.
        //
        // NOTE: we are accumulating round-off errors in NV_PFB_TIMING2_REFRESH.
        //       Over many changes of mclk, the refresh interval may drift up or down.
        //       We really should be calculating from the initial bios refresh and
        //       mclk each time, but we don't have that data cached away anywhere.
        
        oldTiming2Refresh = REG_RD_DRF( _PFB, _TIMING2, _REFRESH );
    
        newTiming2Refresh = (oldTiming2Refresh * newMClkScaled + oldMClkScaled/2) / oldMClkScaled;
        
        DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "old cycles per refresh=", oldTiming2Refresh*32);
        DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "new cycles per refresh=", newTiming2Refresh*32);
        
        // Store the new value
        FLD_WR_DRF_NUM( _PFB, _TIMING2, _REFRESH, newTiming2Refresh );
    }     


    return status;
}

//
// nvHalDacProgramNVClk_NV10 - Program NVCLK based on the value in pDacHalInfo->NVClk
//
// This routine uses the value in pDacHalInfo->NVClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramNVClk_NV10(VOID *arg)
{
    PDACPROGRAMNVCLKARG_000 pDacProgramNVClkArg = (PDACPROGRAMNVCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 i;
    U032 Loops;
    U032 IsPllLocked;
    U032 IsPllSlowed = 0;
    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramNVClkArg->id != DAC_PROGRAMNVCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramNVClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;

    mNew = pDacHalInfo->NVPllM;
    nNew = pDacHalInfo->NVPllN;
    pNew = pDacHalInfo->NVPllP;

    // Program the hardware

    // Make sure to disable the clock slowdown circuit
    if (IsNV11_NV10(pMcHalInfo))
    {
        IsPllSlowed = REG_RD_DRF(_PBUS, _DEBUG_1, _CORE_SLOWDWN);
        FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _CORE_SLOWDWN, 0);
    }

    // Retrieve original coefficients
    coeff = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
    mOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _PDIV, coeff);

    // Restore the clock slowdown circuit
    if (IsNV11_NV10(pMcHalInfo))
    	FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _CORE_SLOWDWN, IsPllSlowed);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first
        REG_WR32
            (
                NV_PRAMDAC_NVPLL_COEFF,
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _PDIV, pOld)
            );

        // Wait until NV PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _NVPLL_LOCK)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_NVPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _NVPLL_LOCK)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_NVPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: NV PLL not locked\n");
        }
    }

    // Now we can write the final value
    REG_WR32
        (
            NV_PRAMDAC_NVPLL_COEFF,
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _PDIV, pNew)
        );

    // Update NV_PBUS_DEBUG_3 to control data throttling in AGP 4X mode
    i = 0;
    while ( ( pDacHalInfo->NVClk <= NV10_dacAGPClockTable[ i ].frequency ) &&
        ( i < sizeof( NV10_dacAGPClockTable ) / sizeof( NV10_dacAGPClockTable[ 0 ] ) - 1 ) )
    {
        i++;
    }

    FLD_WR_DRF_NUM( _PBUS, _DEBUG_3, _AGP_4X_NVCLK, NV10_dacAGPClockTable[ i ].setting );
    
    return status;
}

//
// nvHalDacProgramPClk_NV10
//
RM_STATUS
nvHalDacProgramPClk_NV10(VOID *arg)
{
    PDACPROGRAMPCLKARG_000 pDacProgramPClkArg = (PDACPROGRAMPCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032            CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo
    U032            Head;
    U032            PixelClock;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 Loops;
    U032 IsPllLocked;

    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramPClkArg->id != DAC_PROGRAMPCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramPClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacProgramPClkArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    mNew = pDacHalInfo->VPllM;
    nNew = pDacHalInfo->VPllN;
    pNew = pDacHalInfo->VPllP;

    Head = pDacHalObj->Head;
    PixelClock = pDacProgramPClkArg->PixelClock;

    // Program the hardware

    // Retrieve original coefficients
    // NV11 VPLL2 unfortunately is not at the "expected" offset, so we can't use the HAL macro (DAC_REG_RD32)
    if (Head == 0) 
    {
        coeff = REG_RD32( NV_PRAMDAC_VPLL_COEFF );
    }
    else
    {
        coeff = REG_RD32( NV_PRAMDAC_VPLL2_COEFF );
    }
    mOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first. 
        if (Head == 0) 
        {
            REG_WR32
            (
                NV_PRAMDAC_VPLL_COEFF,
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pOld)
            );
        }
        else
        {
            REG_WR32
            (
                NV_PRAMDAC_VPLL2_COEFF,
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pOld)
            );
        }

        // Wait until V PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                HAL_DAC_REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _VPLL_LOCK, CurDacAdr)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    HAL_DAC_REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _VPLL_LOCK, CurDacAdr)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: VPLL not locked\n");
        }
    }

    // Now we can write the final value
    if (Head == 0) 
    {
        REG_WR32
        (
            NV_PRAMDAC_VPLL_COEFF,
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pNew)
        );
    }
    else
    {
        REG_WR32
        (
            NV_PRAMDAC_VPLL2_COEFF,
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pNew)
        );
    }

    return status;
}

//
// nvHalDacProgramCursorImage_NV10
//
RM_STATUS
nvHalDacProgramCursorImage_NV10(VOID *arg)
{
    PDACPROGRAMCURSORARG_000 pDacProgramCursorImgArg = (PDACPROGRAMCURSORARG_000) arg;
    PHALHWINFO  pHalHwInfo;
    PMCHALINFO  pMcHalInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032        CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo
    U032        cursorConfig;

    //
    // Verify interface revision.
    //
    if (pDacProgramCursorImgArg->id != DAC_PROGRAMCURSOR_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramCursorImgArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacProgramCursorImgArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    // Read the cursorConfig register.
    cursorConfig = HAL_DAC_REG_RD32(NV_PCRTC_CURSOR_CONFIG, CurDacAdr);

    // Preserve the enable and scan_double bits. Clear the rest
    cursorConfig &= ((1 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_ENABLE)) |
                     (1 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_SCAN_DOUBLE)));

    // Mark the Address Space Indicator to indicate where the cursor image is, 
    // based on the param "asi".
    cursorConfig |= (pDacProgramCursorImgArg->asi << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_ADDRESS_SPACE));

    // The supported cursor image sizes are 32x32 or 64x64.
    if (pDacProgramCursorImgArg->width == 32)
    {
        // 32x32
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_PIXELS, NV_PCRTC_CURSOR_CONFIG_CUR_PIXELS_32);
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_LINES, NV_PCRTC_CURSOR_CONFIG_CUR_LINES_32);
    }
    else
    {
        //64x64
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_PIXELS, NV_PCRTC_CURSOR_CONFIG_CUR_PIXELS_64);
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_LINES, NV_PCRTC_CURSOR_CONFIG_CUR_LINES_64);
    }

    // The different color formats are implemented by two bits: The Blend bit and Bpp bit.
    //       Blend      Bpp        Format
    //       ----------------------------
    //         0         0     ->  ROP1R5G5B5
    //         0         1     ->  PM_A8R8G8B8  *** This format is only supported in NV15 or later.
    //         1         0     ->  A1R5G5B5
    //         1         1     ->  A8R8G8B8
    switch (pDacProgramCursorImgArg->colorFormat)
    {
        case NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A1R5G5B5:
            // Set blend = 0. Bpp is already 0
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BLEND_ALPHA << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BLEND));
            break;
        case NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A8R8G8B8:
            // set blend = 1, bpp = 1
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BLEND_ALPHA << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BLEND));
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BPP_32 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BPP));
            break;
        case NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8:
            if (IsNV15orBetter_NV10(pMcHalInfo))
            {
                // set bpp = 1, blend is already 0 (only supported in NV15 or later)
                cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BPP_32 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BPP));
            }
            // else fall through to default
        default:
            // Leave blend and bpp both 0 (ROP1R5G5B5)
            break;
    }

    // write the new cursor config register value.
    HAL_DAC_REG_WR32(NV_PCRTC_CURSOR_CONFIG, cursorConfig, CurDacAdr);

    //
    // Turn on LONG_PIPE to extend the cursor FIFO if we're on nv15 or
    // better.
    if (IsNV15orBetter_NV10(pMcHalInfo))
        HAL_DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIPE, _LONG, CurDacAdr); 

    // Program the start address.
    // If the address space indicator says it is in Instance Memory, the startAddr is in terms of 
    // paragraphs instead of bytes. Adjust it to bytes.
    if (pDacProgramCursorImgArg->asi == NV_PCRTC_CURSOR_CONFIG_ADDRESS_SPACE_PINST)
    {
        pDacProgramCursorImgArg->startAddr <<= 4;
    }

    HAL_DAC_REG_WR32(NV_PCRTC_CURSOR, pDacProgramCursorImgArg->startAddr, CurDacAdr);

    return RM_OK;
}

//
// nvHalDacGetRasterPosition_NV10
//
RM_STATUS
nvHalDacGetRasterPosition_NV10(VOID *arg)
{
    PDACRASTERPOSARG_000 pDacRasterPosArg = (PDACRASTERPOSARG_000) arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032        CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo

    //
    // Verify interface revision.
    //
    if (pDacRasterPosArg->id != DAC_RASTERPOS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacRasterPosArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacRasterPosArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    // no RL0/RL1 index regs, so return NV_PCRTC_RASTER_POSITION
    pDacRasterPosArg->result =  (U016) HAL_DAC_REG_RD_DRF(_PCRTC, _RASTER, _POSITION, CurDacAdr);
                                        
    return (RM_OK);
}

//
// Called from display driver to confirm that sufficient bandwidth is available
// for the proposed configuration.
// For this chip, stubbed out to always return success...
//
RM_STATUS
nvHalDacValidateBandwidth_NV10(VOID *arg)
{
    PDACVALIDATEBANDWIDTHARG_000    pDacValidateBandwidthArg = (PDACVALIDATEBANDWIDTHARG_000) arg;
    PHALHWINFO          pHalHwInfo;
    PDACHALINFO         pDacHalInfo;
    PFBHALINFO          pFbHalInfo;
    PMCHALINFO          pMcHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;

    fifo_info   fifo_data;
    sim_state   sim_data;
    U032        i, pclk_limit;

    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pVidLutCurDac0;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pVidLutCurDac1;

    //
    // Verify interface revision.
    //
    if (pDacValidateBandwidthArg->id != DAC_VALIDATEBANDWIDTH_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacValidateBandwidthArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;

    pVidLutCurDac0 = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHalInfo->CrtcInfo[0].pVidLutCurDac;
    pVidLutCurDac1 = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHalInfo->CrtcInfo[1].pVidLutCurDac;

//    head = pDacValidateArbSettingsArg->head;

    if (!IsNV11_NV10(pMcHalInfo))
        return RM_OK;

//    vclk = pDev->Dac.PixelClock * 10000;

    //
    // First we must validate that the incoming vclk is within our DAC range.
    //
    switch (pDacValidateBandwidthArg->head0->PixelDepth)
    {
        case 8:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp;
            break;
        case 15:
        case 16:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp;
            break;
        case 24:
        case 32:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp;
            break;
        default:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp;
            break;
    }

    //
    // If incoming clock is greater than DAC range, return failure
    //
    //if (vclk > pclk_limit)
    if (pDacValidateBandwidthArg->head0->Enable && (pDacValidateBandwidthArg->head0->PixelClock*10000 > pclk_limit))
        return RM_ERROR;

    switch (pDacValidateBandwidthArg->head1->PixelDepth)
    {
        case 8:
            pclk_limit = pDacHalInfo->CrtcInfo[1].PCLKLimit8bpp;
            break;
        case 15:
        case 16:
            pclk_limit = pDacHalInfo->CrtcInfo[1].PCLKLimit16bpp;
            break;
        case 24:
        case 32:
            pclk_limit = pDacHalInfo->CrtcInfo[1].PCLKLimit32bpp;
            break;
        default:
            pclk_limit = pDacHalInfo->CrtcInfo[1].PCLKLimit16bpp;
            break;
    }

    //
    // If incoming clock is greater than DAC range, return failure
    //
//    if (vclk > pclk_limit)
    if (pDacValidateBandwidthArg->head1->Enable && (pDacValidateBandwidthArg->head1->PixelClock*10000 > pclk_limit))
        return RM_ERROR;

    
    // Make sure any uninitialized sim data starts with 0's
    for (i = 0; i < sizeof(sim_data); i++)
        ((U008 *)&sim_data)[i] = 0x0;

    //
    // Build the sim table using current system settings
    //
    sim_data.enable_video    = 0;// LPL: preliminary - set to 0 (pDacValidateBandwidthArg->VidScalerHead != NV_CFGEX_VALIDATE_BANDWIDTH_SCALER_OFF) ? 1 : 0;
    sim_data.enable_mp        = 0;  //LPL: What's this?  mport_enabled ? 1 : 0;
    sim_data.memory_width   = pDacHalInfo->InputWidth;
    sim_data.mem_latency    = 3;
    sim_data.memory_type    = (pFbHalInfo->RamType == BUFFER_DDRAM) ? 1 : 0; //1=DD,0=SD
    sim_data.mem_aligned    = 1;
    sim_data.mem_page_miss  = 10;
    sim_data.gr_during_vid  = pVideoHalInfo->ColorKeyEnabled ? 1 : 0;
//    sim_data.pclk_khz       = pDacValidateArbSettingsArg->vclk / 1000;  // in kHz, not MHz
    sim_data.mclk_khz       = pDacHalInfo->MClk / 1000;     // in kHz, not MHz
    sim_data.nvclk_khz      = pDacHalInfo->NVClk / 1000;    // in kHz, not MHz

//NV11 params
    fifo_data.crtc1_lwm = 0;
    fifo_data.crtc2_lwm = 0;
    fifo_data.video_lwm = 0;
    fifo_data.crtc1_burst_size = 0;
    fifo_data.crtc2_burst_size = 0;
    fifo_data.video_burst_size = 0;
    fifo_data.valid = 0;

    sim_data.enable_h1    =    (pDacValidateBandwidthArg->head0->Enable)?1:0;    //1
    if (pDacValidateBandwidthArg->head0->Enable) {
        sim_data.pix_bpp      = pDacValidateBandwidthArg->head0->PixelDepth;  //May override below
        sim_data.hres         = pDacValidateBandwidthArg->head0->VisibleWidth;    //2048;
        sim_data.htotal       = pDacValidateBandwidthArg->head0->TotalWidth;            //2832;
        sim_data.vres         = pDacValidateBandwidthArg->head0->VisibleHeight;    //1536;
        sim_data.nativeVRes   = (HAL_GETDISPLAYTYPE(0) == DISPLAY_TYPE_FLAT_PANEL)?pDacHalInfo->fpVMax:sim_data.vres;

        //LPL: copied math below, but I don't get it... *10000?
        sim_data.refresh      = (pDacValidateBandwidthArg->head0->PixelClock*10000) /
                                (pDacValidateBandwidthArg->head0->TotalWidth * pDacValidateBandwidthArg->head0->TotalHeight);    //75;

        sim_data.pclk_khz     =  pDacValidateBandwidthArg->head0->PixelClock * 10;   //3404772;
    } else {
        sim_data.hres         = 640;
        sim_data.htotal       = 832;
        sim_data.vres         = 480;
        sim_data.nativeVRes   = sim_data.vres;
        sim_data.refresh      = 85;    //75;
        sim_data.pclk_khz     =  36000;   //3404772;
    }
    
    sim_data.enable_h2    = (pDacValidateBandwidthArg->head1->Enable)?1:0;       //0
    if (pDacValidateBandwidthArg->head1->Enable) {
        sim_data.pix_bpp_h2   = pDacValidateBandwidthArg->head1->PixelDepth;  //May override below
        sim_data.hres2        = pDacValidateBandwidthArg->head1->VisibleWidth;    //1024;
        sim_data.htotal2      = pDacValidateBandwidthArg->head1->TotalWidth;            //1344;
        sim_data.vres2        = pDacValidateBandwidthArg->head1->VisibleHeight;    // 768;
        sim_data.nativeVRes2  = (HAL_GETDISPLAYTYPE(0) == DISPLAY_TYPE_FLAT_PANEL)?pDacHalInfo->fpVMax:sim_data.vres2;

        //LPL: copied math below, but I don't get it... *10000?
        sim_data.refresh2     = (pDacValidateBandwidthArg->head1->PixelClock*10000) /
                                (pDacValidateBandwidthArg->head1->TotalWidth * pDacValidateBandwidthArg->head1->TotalHeight);    //60;

        sim_data.pclk2_khz    =   pDacValidateBandwidthArg->head1->PixelClock * 10;  //641088;
    } else {
        sim_data.hres2        = 640;
        sim_data.htotal2      = 832;
        sim_data.vres2        = 480;
        sim_data.nativeVRes2  = sim_data.vres2;
        sim_data.refresh2     = 85;    //75;
        sim_data.pclk2_khz    =  36000;   //3404772;
    }

    switch (pDacValidateBandwidthArg->VidScalerHead) {
    case NV_CFGEX_VALIDATE_BANDWIDTH_SCALER_ON_HEAD0:
        sim_data.h2_owns_vs = 0;
        break;
    case NV_CFGEX_VALIDATE_BANDWIDTH_SCALER_ON_HEAD1:
        sim_data.h2_owns_vs = 1;
        break;
    case NV_CFGEX_VALIDATE_BANDWIDTH_SCALER_OFF:
        break;
    case NV_CFGEX_VALIDATE_BANDWIDTH_SCALER_WORST_CASE:
    default:
        //Another way to find worst case would be to call this whole fn twice and
        //fail if either head returns a failure.  Jeff said this would get us a
        //decent estimate: pick the head with the highest drain rate.
        if ((pDacValidateBandwidthArg->head0->PixelClock * pDacValidateBandwidthArg->head0->PixelDepth)
            > (pDacValidateBandwidthArg->head1->PixelClock * pDacValidateBandwidthArg->head1->PixelDepth))
            sim_data.h2_owns_vs = 0;
        else
            sim_data.h2_owns_vs = 1;
        break;
    }
    sim_data.video_source_hres = 720;
    sim_data.video_source_vres = 480;
//end NV11

    sim_data.pix_bpp_h2   =   pDacValidateBandwidthArg->head1->PixelDepth;
    sim_data.pix_bpp      =   pDacValidateBandwidthArg->head0->PixelDepth;
    if (!sim_data.pix_bpp) sim_data.pix_bpp = 32;
    if (!sim_data.pix_bpp_h2) sim_data.pix_bpp_h2 = 32;

    //
    // Run the numbers through the wringer
    //
#ifdef NV11_DEBUG
    if (IsNV11_NV10(pMcHalInfo) && nv11Aware)
#else  //#ifdef NV11_DEBUG
    if (IsNV11_NV10(pMcHalInfo))
#endif  //#ifdef NV11_DEBUG
        NV11_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);
    else
        NV10_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);
    /*
    //
    // If the CRTC can do this, double check to make sure the overlay is able as well
    //
    if (fifo_data.valid)
        fifo_data.valid = NV10_dacCalculateVideoCaps(pDev);
    */

    if (fifo_data.valid) {
//        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Config is valid!\r\n");
        return RM_OK;
    } else {
//        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Config sucks!\r\n");
        return RM_ERROR;
    }
}

//
// Attempt to validate the given parameters will work with the current configuration
//
//  Return 0  if not capable
//  Return ~0 if valid
//
RM_STATUS
nvHalDacValidateArbSettings_NV10(VOID *arg)
{
    PDACVALIDATEARBSETTINGSARG_000    pDacValidateArbSettingsArg = (PDACVALIDATEARBSETTINGSARG_000) arg;
    PHALHWINFO          pHalHwInfo;
    PDACHALINFO         pDacHalInfo;
    PFBHALINFO          pFbHalInfo;
    PMCHALINFO          pMcHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;

    fifo_info   fifo_data;
    sim_state   sim_data;
    U032        i, pclk_limit;
    U032        head;

    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pVidLutCurDac0;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pVidLutCurDac1;

    //
    // Verify interface revision.
    //
    if (pDacValidateArbSettingsArg->id != DAC_VALIDATEARBSETTINGS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacValidateArbSettingsArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;

    pVidLutCurDac0 = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHalInfo->CrtcInfo[0].pVidLutCurDac;
    pVidLutCurDac1 = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHalInfo->CrtcInfo[1].pVidLutCurDac;

    head = pDacValidateArbSettingsArg->head;

    //
    // First we must validate that the incoming vclk is within our DAC range.
    //
    switch (pDacValidateArbSettingsArg->bpp)
    {
        case 8:
            pclk_limit = pDacHalInfo->CrtcInfo[head].PCLKLimit8bpp;
            break;
        case 15:
        case 16:
            pclk_limit = pDacHalInfo->CrtcInfo[head].PCLKLimit16bpp;
            break;
        case 24:
        case 32:
            pclk_limit = pDacHalInfo->CrtcInfo[head].PCLKLimit32bpp;
            break;
        default:
            pclk_limit = pDacHalInfo->CrtcInfo[head].PCLKLimit16bpp;
            break;
    }

    //
    // If incoming clock is greater than DAC range, return failure
    //
    if (pDacValidateArbSettingsArg->vclk > pclk_limit)
    {
        pDacValidateArbSettingsArg->result = 0;
        return (RM_OK);
    }
        
    // Make sure any uninitialized sim data starts with 0's
    for (i = 0; i < sizeof(sim_data); i++)
        ((U008 *)&sim_data)[i] = 0x0;

    //
    // Build the sim table using current system settings
    //
    sim_data.enable_video   = pDacValidateArbSettingsArg->video_enabled ? 1 : 0;
    sim_data.enable_mp      = pDacValidateArbSettingsArg->mport_enabled ? 1 : 0;
    sim_data.memory_width   = pDacHalInfo->InputWidth;
    sim_data.mem_latency    = 3;
    sim_data.memory_type    = (pFbHalInfo->RamType == BUFFER_DDRAM) ? 1 : 0; //1=DD,0=SD
    sim_data.mem_aligned    = 1;
    sim_data.mem_page_miss  = 10;
    sim_data.gr_during_vid  = pVideoHalInfo->ColorKeyEnabled ? 1 : 0;
    sim_data.pclk_khz       = pDacValidateArbSettingsArg->vclk / 1000;  // in kHz, not MHz
    sim_data.mclk_khz       = pDacHalInfo->MClk / 1000;     // in kHz, not MHz
    sim_data.nvclk_khz      = pDacHalInfo->NVClk / 1000;    // in kHz, not MHz

    // NV11 params
    fifo_data.crtc1_lwm = 0;
    fifo_data.crtc2_lwm = 0;
    fifo_data.video_lwm = 0;
    fifo_data.crtc1_burst_size = 0;
    fifo_data.crtc2_burst_size = 0;
    fifo_data.video_burst_size = 0;
    fifo_data.valid = 0;

    sim_data.enable_h1 = (pVidLutCurDac0) ? 1 : 0;    //1
    if (pVidLutCurDac0) {
        sim_data.pix_bpp      = pVidLutCurDac0->Dac[0].PixelDepth;          //May override below
        sim_data.hres         = pVidLutCurDac0->Dac[0].VisibleImageWidth;   //2048;
        sim_data.htotal       = pVidLutCurDac0->Dac[0].TotalWidth;          //2832;
        sim_data.vres         = pVidLutCurDac0->Dac[0].VisibleImageHeight;  //1536;
        sim_data.nativeVRes   = (HAL_GETDISPLAYTYPE(0) == DISPLAY_TYPE_FLAT_PANEL)?pDacHalInfo->fpVMax:sim_data.vres;

        //LPL: copied math below, but I don't get it... *10000?
        sim_data.refresh      = (pVidLutCurDac0->Dac[0].PixelClock*10000) /
                                (pVidLutCurDac0->Dac[0].TotalWidth * pVidLutCurDac0->Dac[0].TotalHeight);    //75;

    //    sim_data.pix_bpp    = 32;
        sim_data.pclk_khz     = pVidLutCurDac0->Dac[0].PixelClock * 10;   //3404772;
    } else {
        sim_data.hres         = 640;
        sim_data.htotal       = 832;
        sim_data.vres         = 480;
        sim_data.nativeVRes   = sim_data.vres;
        sim_data.refresh      = 85;     //75;
    //    sim_data.pix_bpp    = 32;
        sim_data.pclk_khz     = 36000;  //3404772;
    }
    
    sim_data.enable_h2        = (pVidLutCurDac1)?1:0;       //0
    if (pVidLutCurDac1) {
        sim_data.pix_bpp_h2   = pVidLutCurDac1->Dac[0].PixelDepth;          //May override below
        sim_data.hres2        = pVidLutCurDac1->Dac[0].VisibleImageWidth;   //1024;
        sim_data.htotal2      = pVidLutCurDac1->Dac[0].TotalWidth;          //1344;
        sim_data.vres2        = pVidLutCurDac1->Dac[0].VisibleImageHeight;  // 768;
        sim_data.nativeVRes2  = (HAL_GETDISPLAYTYPE(1) == DISPLAY_TYPE_FLAT_PANEL)?pDacHalInfo->fpVMax:sim_data.vres2;

        //LPL: copied math below, but I don't get it... *10000?
        sim_data.refresh2     = (pVidLutCurDac1->Dac[0].PixelClock*10000) /
                                (pVidLutCurDac1->Dac[0].TotalWidth * pVidLutCurDac1->Dac[0].TotalHeight);    //60;

        sim_data.pclk2_khz    =   pVidLutCurDac1->Dac[0].PixelClock * 10;   //641088;
    } else {
        sim_data.hres2        = 640;
        sim_data.htotal2      = 832;
        sim_data.vres2        = 480;
        sim_data.nativeVRes2  = sim_data.vres2;
        sim_data.refresh2     = 85;     //75;
    //    sim_data.pix_bpp    =   32;
        sim_data.pclk2_khz    =  36000; //3404772;
    }

//    sim_data.enable_video =    1;
//    sim_data.enable_mp    =    0;

//    sim_data.memory_width =  128;
//    sim_data.memory_type  =    0;
//    sim_data.mclk_mhz     =  166;

    //
    // If the overlay is active, use the head that owns the video scaler,
    // otherwise, for calculating if the overlay is allowed, assume this
    // head.
    //
	if (pVideoHalInfo->ActiveVideoOverlayObject)
        sim_data.h2_owns_vs = pVideoHalInfo->Head;
    else
        sim_data.h2_owns_vs = head;

    sim_data.video_source_hres = 720;
    sim_data.video_source_vres = 480;
// end NV11

    //Override the bit plane depth with passed parameter.
    if (head) {
        sim_data.pix_bpp_h2 = pDacValidateArbSettingsArg->bpp;   //32;
    } else {
        sim_data.pix_bpp    = pDacValidateArbSettingsArg->bpp;   //bpp;
    }

    //What if we're still not sure?  Well, for now let's pick the worst case...
    if (!sim_data.pix_bpp) sim_data.pix_bpp = 32;
    if (!sim_data.pix_bpp_h2) sim_data.pix_bpp_h2 = 32;

    //
    // Run the numbers through the ringer
    //
#ifdef NV11_DEBUG
    if (IsNV11_NV10(pMcHalInfo) && nv11Aware)
#else  //#ifdef NV11_DEBUG
    if (IsNV11_NV10(pMcHalInfo))
#endif  //#ifdef NV11_DEBUG
        NV11_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);
    else
        NV10_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);

    /*
    //
    // If the CRTC can do this, double check to make sure the overlay is able as well
    //
    if (fifo_data.valid && video_enabled)
        fifo_data.valid = NV10_dacCalculateVideoCaps(pDev);
    */
    
    pDacValidateArbSettingsArg->result = (U032)fifo_data.valid;
    return (RM_OK);
}

#ifdef IKOS
U032 do_pvideo = 0;
#endif

RM_STATUS
nvHalDacUpdateArbSettings_NV10(VOID *arg)
{ 
    PDACUPDATEARBSETTINGSARG_000     pDacUpdateArbSettingsArg = (PDACUPDATEARBSETTINGSARG_000) arg;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    PHALHWINFO          pHalHwInfo;
    PDACHALINFO         pDacHalInfo;
    PFBHALINFO          pFbHalInfo;
    PMCHALINFO          pMcHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;
    PMPHALINFO          pMpHalInfo;
    U032                Head;
    U032                CurDacAdr;
    DACVALIDATEARBSETTINGSARG_000   dacValidateArbSettingsArg;

    fifo_info   fifo_data;
    sim_state   sim_data;
    U008        lock0, lock1;
    U032        i;
    U032        M, N, O, P;

    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pVidLutCurDac0;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pVidLutCurDac1;

    //
    // Verify interface revision.
    //
    if (pDacUpdateArbSettingsArg->id != DAC_UPDATEARBSETTINGS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacUpdateArbSettingsArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;
    pMpHalInfo = pHalHwInfo->pMpHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacUpdateArbSettingsArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;
    Head = pDacHalObj->Head;

    pVidLutCurDac0 = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHalInfo->CrtcInfo[0].pVidLutCurDac;
    pVidLutCurDac1 = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHalInfo->CrtcInfo[1].pVidLutCurDac;

    //
    // Recalculate the current PCLK setting.  We might have changed modes
    // recently.
    //
    M = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _MDIV);
    N = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _NDIV);
    P = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _PDIV);
    O = 1;
    
    pDacHalInfo->VPllM = M;
    pDacHalInfo->VPllN = N;
    pDacHalInfo->VPllO = O;
    pDacHalInfo->VPllP = P;
    pDacHalInfo->VClk  = (N * pMcHalInfo->CrystalFreq / (1 << P) / M);
    
    // Make sure any uninitialized sim data starts with 0's
    for (i = 0; i < sizeof(sim_data); i++)
        ((U008 *)&sim_data)[i] = 0x0;

    RM_ASSERT(pDacHalInfo->CrtcInfo[Head].pVidLutCurDac);

    //
    // Check if we can support an overlay in this resolution.  If we can, set the default desktop timings
    // to assume we are running an overlay.
    //
    dacValidateArbSettingsArg.id = DAC_VALIDATEARBSETTINGS_000;
    dacValidateArbSettingsArg.pHalHwInfo = pHalHwInfo;
    dacValidateArbSettingsArg.bpp = (pDacHalInfo->CrtcInfo[Head].pVidLutCurDac)
                                  ? ((PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHalInfo->CrtcInfo[Head].pVidLutCurDac)->Dac[0].PixelDepth
                                  : 32;
    dacValidateArbSettingsArg.video_enabled = 1;
    dacValidateArbSettingsArg.mport_enabled = 0;
    dacValidateArbSettingsArg.vclk = pDacHalInfo->PixelClock * 10000;
    dacValidateArbSettingsArg.head = Head;

    // if (NV11_dacValidateArbitrationSettings(pHalHwInfo, pDacHalInfo->Depth, 1, 0, (pDacHalInfo->PixelClock * 10000), Head))
    nvHalDacValidateArbSettings_NV10(&dacValidateArbSettingsArg);
    if (dacValidateArbSettingsArg.result)
        sim_data.enable_video = 1;
    else
        sim_data.enable_video = 0;

    // Need to update the flag
    pVideoHalInfo->OverlayAllowed = sim_data.enable_video;
    
    //sim_data.pix_bpp      = (char)pDacHalInfo->Depth;
    //sim_data.enable_video = pDev->Video.Enabled ? 1 : 0;
    sim_data.enable_mp      = pMpHalInfo->Enabled ? 1 : 0;
    sim_data.memory_width   = pDacHalInfo->InputWidth;
    sim_data.mem_aligned    = 1;
    sim_data.memory_type    = (pFbHalInfo->RamType == BUFFER_DDRAM) ? 1 : 0; //1=DD,0=SD
    sim_data.mem_latency    = 3;
    sim_data.mem_page_miss  = 10;
    sim_data.gr_during_vid  = pVideoHalInfo->ColorKeyEnabled ? 1 : 0;
    sim_data.pclk_khz       = pDacHalInfo->VClk / 1000;     // in kHz, not MHz
    sim_data.mclk_khz       = pDacHalInfo->MClk / 1000;     // in kHz, not MHz
    sim_data.nvclk_khz      = pDacHalInfo->NVClk / 1000;    // in kHz, not MHz
 
    // 
    // Get those new numbers
    //
    fifo_data.crtc1_lwm = 0;
    fifo_data.crtc2_lwm = 0;
    fifo_data.video_lwm = 0;
    fifo_data.crtc1_burst_size = 0;
    fifo_data.crtc2_burst_size = 0;
    fifo_data.video_burst_size = 0;
    fifo_data.valid = 0;

    sim_data.enable_h1        = (pVidLutCurDac0)?1:0;    //1
    if (pVidLutCurDac0) {
        sim_data.pix_bpp      = pVidLutCurDac0->Dac[0].PixelDepth;          //May override below

        sim_data.hres         = pVidLutCurDac0->Dac[0].VisibleImageWidth;   //2048;
        sim_data.htotal       = pVidLutCurDac0->Dac[0].TotalWidth;          //2832;
        sim_data.vres         = pVidLutCurDac0->Dac[0].VisibleImageHeight;  //1536;
        sim_data.nativeVRes = (HAL_GETDISPLAYTYPE(0) == DISPLAY_TYPE_FLAT_PANEL)?pDacHalInfo->fpVMax:sim_data.vres;

        //LPL: copied math below, but I don't get it... *10000?
        sim_data.refresh      = (pVidLutCurDac0->Dac[0].PixelClock*10000) /
                                (pVidLutCurDac0->Dac[0].TotalWidth * pVidLutCurDac0->Dac[0].TotalHeight);    //75;

    //    sim_data.pix_bpp    =   32;
        sim_data.pclk_khz     =  pVidLutCurDac0->Dac[0].PixelClock * 10;    //3404772;
    } else {
        sim_data.hres         = 640;
        sim_data.htotal       = 832;
        sim_data.vres         = 480;
        sim_data.nativeVRes   = sim_data.vres;
        sim_data.refresh      = 85;     //75;
    //    sim_data.pix_bpp    = 32;
        sim_data.pclk_khz     = 36000;  //3404772;
    }
    
    sim_data.enable_h2    = (pVidLutCurDac1)?1:0;       //0
    if (pVidLutCurDac1) {
        sim_data.pix_bpp_h2   = pVidLutCurDac1->Dac[0].PixelDepth;          //May override below
        sim_data.hres2        = pVidLutCurDac1->Dac[0].VisibleImageWidth;   //1024;
        sim_data.htotal2      = pVidLutCurDac1->Dac[0].TotalWidth;          //1344;
        sim_data.vres2        = pVidLutCurDac1->Dac[0].VisibleImageHeight;  //768;
        sim_data.nativeVRes2  = (HAL_GETDISPLAYTYPE(1) == DISPLAY_TYPE_FLAT_PANEL)?pDacHalInfo->fpVMax:sim_data.vres2;

        //LPL: copied math below, but I don't get it... *10000?
        sim_data.refresh2     = (pVidLutCurDac1->Dac[0].PixelClock*10000) /
                                (pVidLutCurDac1->Dac[0].TotalWidth * pVidLutCurDac1->Dac[0].TotalHeight);    //60;

        sim_data.pclk2_khz    =   pVidLutCurDac1->Dac[0].PixelClock * 10;   //641088;
    } else {
        sim_data.hres2        = 640;
        sim_data.htotal2      = 832;
        sim_data.vres2        = 480;
        sim_data.nativeVRes2  = sim_data.vres2;
        sim_data.refresh2     = 85;     //75;
    //    sim_data.pix_bpp    = 32;
        sim_data.pclk2_khz    = 36000;  //3404772;
    }

    if (!sim_data.pix_bpp) sim_data.pix_bpp = 32;
    if (!sim_data.pix_bpp_h2) sim_data.pix_bpp_h2 = 32;

//    sim_data.enable_video =    1;
//    sim_data.enable_mp    =    0;

//    sim_data.memory_width =  128;
//    sim_data.memory_type  =    0;
//    sim_data.mclk_mhz     =  166;

    //
    // If the overlay is active, use the head that owns the video scaler,
    // otherwise, for calculating if the overlay is allowed, assume this
    // head.
    //
	if (pVideoHalInfo->ActiveVideoOverlayObject)
        sim_data.h2_owns_vs = pVideoHalInfo->Head;
    else
        sim_data.h2_owns_vs = Head;

    sim_data.video_source_hres = 720;
    sim_data.video_source_vres = 480;

    /*
    //Test purposes: call to bandwidth test fn.
    if (IsNV11_NV10(pMcHalInfo)) {
        BANDWIDTH_CALC_PARAMS head0, head1;
        DACVALIDATEBANDWIDTHARG_000   dacValidateBandwidthArg;
        RM_STATUS status;

        head0.Enable = (pVidLutCurDac0)?1:0;
        head0.TotalWidth = pVidLutCurDac0->Dac[0].TotalWidth;
        head0.VisibleWidth = pVidLutCurDac0->Dac[0].VisibleImageWidth;
        head0.TotalHeight = pVidLutCurDac0->Dac[0].TotalHeight;
        head0.VisibleHeight = pVidLutCurDac0->Dac[0].VisibleImageHeight;
        head0.PixelDepth = sim_data.pix_bpp;
        head0.PixelClock = sim_data.pclk_khz/10;
        head1.Enable = (pVidLutCurDac1)?1:0;
        head1.TotalWidth = pVidLutCurDac1->Dac[0].TotalWidth;
        head1.VisibleWidth = pVidLutCurDac1->Dac[0].VisibleImageWidth;
        head1.TotalHeight = pVidLutCurDac1->Dac[0].TotalHeight;
        head1.VisibleHeight = pVidLutCurDac1->Dac[0].VisibleImageHeight;
        head1.PixelDepth = sim_data.pix_bpp_h2;
        head1.PixelClock = sim_data.pclk2_khz/10;

        dacValidateBandwidthArg.id = DAC_VALIDATEBANDWIDTH_000;
        dacValidateBandwidthArg.pHalHwInfo = pHalHwInfo;
        dacValidateBandwidthArg.VidScalerHead = 0;
        dacValidateBandwidthArg.head0 = &head0;
        dacValidateBandwidthArg.head1 = &head1;

//        NV10_dacValidateBandwidth(pDev, 0, &head0, &head1);
        status = nvHalDacValidateBandwidth_NV10((VOID *)&dacValidateBandwidthArg);
    }
    */
#ifdef NV11_DEBUG
    if (IsNV11_NV10(pMcHalInfo) && nv11Aware)
#else  //#ifdef NV11_DEBUG
    if (IsNV11_NV10(pMcHalInfo))
#endif //#ifdef NV11_DEBUG
        NV11_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);
    else
        NV10_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);
    
    // for now, assume pass
    //fifo_data.valid = 1;
    
//    For TV, we should not change some of these. Gfx Fifo Low Water Mark in particular should
//        not be changed. 
//    if (pDev->Framebuffer.DisplayType != DISPLAY_TYPE_TV) // leave alone if TV

    //
    // If valid settings found, update the hardware
    //
    if (fifo_data.valid || IsNV11_NV10(pMcHalInfo))    //In the nv11 case, we return valid defaults
                                                       //from the arbitration function.
    {
        //
        // Set the DAC FIFO Thresholds and burst size

#ifdef IKOS
        if (do_pvideo)
        {
#endif
        /*
        //
        // Check overlay capabilities.
        //
        if (!NV10_dacCalculateVideoCaps(pDev))
            pDev->Video.HalInfo.OverlayAllowed = 0;
        */

        if (IsNV11_NV10(pMcHalInfo)) {

            // Eliminate delay between memory requests by the video scalar
            REG_WR32(NV_PVIDEO_DEBUG_1, 0);

            //Final clipping -- check with Jeff to see if the values are already 'safe'
            fifo_data.video_burst_size /= 32;
            if (!fifo_data.video_burst_size) fifo_data.video_burst_size = 1;
            if (fifo_data.video_burst_size > 16) fifo_data.video_burst_size = 16;
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST1, fifo_data.video_burst_size);
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST2, fifo_data.video_burst_size);

            fifo_data.video_lwm /= 16;
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK1, fifo_data.video_lwm);
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK2, fifo_data.video_lwm);
        } else {
            //
            // These are the PVIDEO burst/watermark hardcoded values
            // we've gotten from the HW engineers.
            //
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST1, 16);         // 512 bytes
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST2, 16);         // 512 bytes
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK1, 64);    // 1024 bytes
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK2, 64);    // 1024 bytes
        }

#ifdef IKOS
        }
#endif

        //
        // Update the CRTC watermarks
        // Note that for NV11 we've set the burst size registers to a different
        // operating mode -- therefore, the numbers written for NV11 and non-NV11
        // paths are not compatible.
        //
        if (IsNV11_NV10(pMcHalInfo)) {
            U032 CurDacAdr0, CurDacAdr1;

            CurDacAdr0 = pDacHalInfo->CrtcInfo[0].RegOffset;
            CurDacAdr1 = pDacHalInfo->CrtcInfo[1].RegOffset;

            // Unlock CRTC extended regs
            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock0, CurDacAdr0);
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr0);
            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock1, CurDacAdr1);
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr1);

            //
            // Set the CRTC watermarks and burst size
            //

            fifo_data.crtc1_lwm /= 8;
            if (fifo_data.crtc1_lwm > 255) fifo_data.crtc1_lwm = 255;
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, fifo_data.crtc1_lwm, CurDacAdr0);

            fifo_data.crtc1_burst_size /= 32;
            if (fifo_data.crtc1_burst_size) fifo_data.crtc1_burst_size--;
            if (!fifo_data.crtc1_burst_size) fifo_data.crtc1_burst_size++;
            if (fifo_data.crtc1_burst_size >= (2048/32)) fifo_data.crtc1_burst_size = 2048/32 - 1;
            HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, fifo_data.crtc1_burst_size, CurDacAdr0);

            fifo_data.crtc2_lwm /= 8;
            if (fifo_data.crtc2_lwm > 255) fifo_data.crtc2_lwm = 255;
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, fifo_data.crtc2_lwm, CurDacAdr1);

            fifo_data.crtc2_burst_size /= 32;
            if (fifo_data.crtc2_burst_size) fifo_data.crtc2_burst_size--;
            if (!fifo_data.crtc2_burst_size) fifo_data.crtc2_burst_size++;
            if (fifo_data.crtc2_burst_size >= (2048/32)) fifo_data.crtc2_burst_size = 2048/32 - 1;
            HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, fifo_data.crtc2_burst_size, CurDacAdr1);

            //
            // Relock if necessary
            //
            if (lock0 == 0)
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr0);
            if (lock1 == 0)
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr1);

        } else {    //if (IsNV11(pDev))
            // Unlock CRTC extended regs
            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock0, CurDacAdr);
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr);
       
            //
            // Set the CRTC watermarks and burst size
            //
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, (U008) (fifo_data.crtc1_lwm >> 3), CurDacAdr);
            switch (fifo_data.crtc1_burst_size)
            {
                case 512:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 5, CurDacAdr);
                    break;
                case 256:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 4, CurDacAdr);
                    break;
                case 128:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 3, CurDacAdr);
                    break;
                case 64:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 2, CurDacAdr);
                    break;
                case 32:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 1, CurDacAdr);
                    break;
                case 16:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 0, CurDacAdr);
                    break;
            }
            if (lock0 == 0)
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr);
        }

        //
        // Relock if necessary
        //
        return (RM_OK);
    }
    else    //if (fifo_data.valid || IsNV11_NV10(pMcHalInfo))
    {
        //
        // No valid setting was found!!!
        //
        //  Make a conservative guess and fail.
        //
        
        // Unlock CRTC extended regs
            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock0, CurDacAdr);
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr);
        
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 0x72, CurDacAdr);
            HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 5, CurDacAdr);
         
            //
            // Relock if necessary
            //
            if (lock0 == 0)
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr);
        
        return (RM_ERROR);
    }        
}

RM_STATUS
nvHalDacHotPlugInterrupts_NV10(VOID * pArgs)
{
    //this routine will enable the desired interrupts if this is write
    //or read the current status of the interrupts and reset them if requested
    U032 Head;
    U032 ReadWrite;
    U032 Reset;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObject;
    PDACHOTPLUGINTERRUPTS_000 pDacHotPlugInterrupts;
    PHALHWINFO pHalHwInfo;
    U032 safety_count;
    U032 count=0;
    U032 last_read=0;
    U032 reads_now;
    
    pDacHotPlugInterrupts=(PDACHOTPLUGINTERRUPTS_000)pArgs;
    
    if(DAC_HOTPLUGINTERRUPTS_000 != pDacHotPlugInterrupts->id)
    {
        DBG_PRINTF((DBG_MODULE_OS,DBG_LEVEL_ERRORS,"NVRM: Warning, incorrect parameter interface!\n"));
        return RM_ERROR;
    }
    
    pHalHwInfo = pDacHotPlugInterrupts->pHalHwInfo;
    
    //extract head
    pDacHalObject = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHotPlugInterrupts->pHalObjInfo;
    Head = pDacHalObject->Head;
    
    Reset = pDacHotPlugInterrupts->Reset;
    ReadWrite = pDacHotPlugInterrupts->ReadWrite;
    
    //determine mission
    switch(ReadWrite)
    {
        case FALSE:
            {
                //read values (currently, these are not head related, but it would be a good thing to plan for it)
                pDacHotPlugInterrupts->HotPlugStatus = HAL_DAC_REG_RD_DRF( _PBUS, _INTR_0, _HOTPLUG, 0);
                pDacHotPlugInterrupts->HotUnplugStatus = HAL_DAC_REG_RD_DRF( _PBUS, _INTR_0, _HOTUNPLUG, 0);
                
                if(!(pDacHotPlugInterrupts->HotPlugStatus^pDacHotPlugInterrupts->HotUnplugStatus))
                {
                    //no conclusion reached, debounce for actual value (did not do this in vblank because of timing
                    //issues and the hacks required to HWINFO structure)
                    for(safety_count=0;(safety_count<10)&&(count<3);safety_count++)
                    {
                        //this appears to be irq safe for everyone since it is used in PLL
                        //set routines.
                        osDelay(500);
                        
                        //read GPIO1 for its current value
                        reads_now=HAL_DAC_REG_RD_DRF(_PCRTC,_GPIO,_1_INPUT,0);
                        
                        if(reads_now==last_read)
                        {
                            count++;
                        }
                        else
                        {
                            count=0;
                        }
                        
                        last_read=reads_now;
                    }
                    
                    //take reads_now as the answer to the delimna 
                    if(reads_now)
                    {
                        //when gpio1 goes high, we have a unplug event
                        //(may actually map to a plug event in user land - depends on HW guys
                        // if it is incorrect, the display driver must resolve it as a policy issue)
                        pDacHotPlugInterrupts->HotPlugStatus=0;
                    }
                    else
                    {
                        pDacHotPlugInterrupts->HotUnplugStatus=0;
                    }
                }
            }
                        
            break;
            
        case TRUE:
            {
                //leave GPIO1 floating on the NV11 (input mode only)
                HAL_DAC_FLD_WR_DRF_DEF( _PCRTC, _GPIO, _0_ENABLE, _DISABLE, 0);
                
                //we are writing
                if(pDacHotPlugInterrupts->HotPlugStatus)
                {
                    HAL_DAC_FLD_WR_DRF_DEF( _PBUS, _INTR_EN_0, _HOTPLUG, _ENABLED, 0); 
                }
                else
                {
                    //or not, and this is a request to disable
                    HAL_DAC_FLD_WR_DRF_DEF( _PBUS, _INTR_EN_0, _HOTPLUG, _DISABLED, 0);
                }
                
                //we are writing
                if(pDacHotPlugInterrupts->HotUnplugStatus)
                {
                    HAL_DAC_FLD_WR_DRF_DEF( _PBUS, _INTR_EN_0, _HOTUNPLUG, _ENABLED, 0);
                }
                else
                {
                    //or not, and this is a request to disable
                    HAL_DAC_FLD_WR_DRF_DEF( _PBUS, _INTR_EN_0, _HOTUNPLUG, _DISABLED, 0);
                }
                
            }
            
            break;
            
        default:
            DBG_PRINTF((DBG_MODULE_DAC,DBG_LEVEL_INFO,"NVRM: Error setting hotpplug interrupt.\n"));
            return RM_ERROR;
    }
    
    //DO RESET if requested    
    if(Reset==TRUE)
    {
        HAL_DAC_FLD_WR_DRF_DEF( _PBUS, _INTR_0, _HOTPLUG, _RESET, 0);
        HAL_DAC_FLD_WR_DRF_DEF( _PBUS, _INTR_0, _HOTUNPLUG, _RESET, 0);
        DBG_PRINTF((DBG_MODULE_DAC,DBG_LEVEL_INFO,"NVRM: Resetting interrupt...\n"));
    }
    
    DBG_PRINTF((DBG_MODULE_DAC,DBG_LEVEL_INFO,"NVRM: Hotplug interrupt reg - 0x%x.\n",REG_RD32(NV_PBUS_INTR_0)));
    DBG_PRINTF((DBG_MODULE_DAC,DBG_LEVEL_INFO,"NVRM: Hotplug intenable reg - 0x%x.\n",REG_RD32(NV_PBUS_INTR_EN_0)));
    
    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\devinit\nv\nv04mtbl.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*****************************************************************************
*
*	Header: nv04mtbl.c
*
*	Description:
*		This file contains the initialization code used to POST an NV4 device.
*	The init code was taken from the BIOS source file, nvinit.inc.
*
*	Revision History:
*		Original -- 2/99 Jeff Westerinen
*
*
*	Steps to convert nvinit.inc to initcode.h
*
*		1.	enclose data in: U032 Nv04_bmp_GenInitTbl[] = { <data> }; 
*		2.	convert ; to //
*		3.  remove all db, dw, and dd, and add comma separaters
*		4.  convert IFDEF to #ifdef
*		5.	convert ELSE to #else
*		6.	convert ENDIF to #endif
*		7.	convert OR \ to |
*		8.	convert <num>h to 0x<num>
*		9 .	format -- at least line up data to left indent
*		10. comment out all table delimiters
*		11. remove bmp_ExtraInitTbl
*
******************************************************************************/

#include <nv4_ref.h>
#include <nvrm.h>
#include <bios.h>

U032 Nv04_bmp_GenInitTbl[] = 
{

	//IFNDEF NVIDIA_RESET
	//        // Reset engines
	//        INIT_ZM_REG
	//        NV_PMC_ENABLE      // NV 32 bit address.
	//        DRF_DEF(_PMC,_ENABLE,_PCRTC,_ENABLED) |
	//           DRF_DEF(_PMC,_ENABLE,_PPMI,_ENABLED) |
	//                DRF_DEF(_PMC,_ENABLE,_PFIFO,_ENABLED)
	//#endif // NVIDIA_RESET

	// Comment to fix assembler bug
	INIT_RESET,
	NV_PMC_ENABLE,      // NV 32 bit address.
	// Off state
	DRF_DEF(_PMC,_ENABLE,_PCRTC,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PPMI,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PFIFO,_ENABLED),
		DRF_DEF(_PMC,_ENABLE,_PFB,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PCRTC,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PPMI,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PFIFO,_ENABLED),

	//#ifdef NVIDIA_RESET
	//        INIT_RESET
	//#else // NVIDIA_RESET
	//        // Reset engines
	//        INIT_ZM_REG
	//        NV_PMC_ENABLE      // NV 32 bit address.
	////#endif // NVIDIA_RESET
	//        DRF_DEF(_PMC,_ENABLE,_PFB,_ENABLED) |
	//                DRF_DEF(_PMC,_ENABLE,_PCRTC,_ENABLED) |
	//                DRF_DEF(_PMC,_ENABLE,_PPMI,_ENABLED) |
	//                DRF_DEF(_PMC,_ENABLE,_PFIFO,_ENABLED)

	// Comment to fix assembler bug

#ifdef DISABLE_SIDEBAND

	INIT_NV_REG,                 // Write register with Mask
	NV_PEXTDEV_BOOT_0,               // Strap Register for Memory
	0xFFFFFBFF,                  // AND Mask
	0x00000C00,                  // OR Mask
#else 
	INIT_NV_REG,                 // Write register with Mask
	NV_PEXTDEV_BOOT_0,               // Strap Register for Memory
	0xFFFFFBFF,                  // AND Mask
	0x00000800,                  // OR Mask

#endif  // DISABLE_SIDEBAND

	// Barry's memory fix for AGP
	INIT_ZM_REG,
	NV_PBUS_DEBUG_0,

	////        0E0F0000h    
	////        04050000h   // 7/23/98

	0x20F0000,    // 11/13/98 - New value from Dave Reed for 110Mhz MCLK

	// Comment to fix assembler bug

	// 13,500,000 MHz - MCLK = M:11:0B, N:163:A3, P:4:04 LOG2P:2 50 MHz
	// 14,318,180 MHz - MCLK = M:14:0E, N:196:C4, P:4:04 LOG2P:2 50 MHz
	INIT_PLL,
	NV_PRAMDAC_NVPLL_COEFF,       // Actually, this is NVPLL (680500)
#ifdef INTEL 
	8500,        // 85Mhz
#else                      
	9000,        // 90Mhz
#endif 


	// Comment to fix assembler bug

	// 13,500,000 MHz - MCLK = M:11:0B, N:163:A3, P:4:04 LOG2P:2 50 MHz
	// 14,318,180 MHz - MCLK = M:14:0E, N:196:C4, P:4:04 LOG2P:2 50 MHz
	INIT_PLL,
	NV_PRAMDAC_MPLL_COEFF,

#ifdef INTEL 
	10000,   // 100Mhz
#else                  
	11000,   // 110Mhz
#endif 


	// Comment to fix assembler bug

	// NV_PFB_CONFIG_0
	INIT_ZM_REG,
	NV_PFB_CONFIG_0,      // NV 32 bit address.
	DRF_DEF(_PFB,_CONFIG_0,_RESOLUTION,_DEFAULT) |
		DRF_DEF(_PFB,_CONFIG_0,_PIXEL_DEPTH,_DEFAULT) |
		DRF_DEF(_PFB,_CONFIG_0,_TILING,_DISABLED) |
		DRF_DEF(_PFB,_CONFIG_0,_TILING_DEBUG,_DISABLED),

	// Comment to fix assembler bug

	// VCLK.
	// 13,500,000 MHz - VCLK = M:12:0C, N:064:40, P:2:02 LOG2P:1 36.00 MHz
	// 14,318,180 MHz - VCLK = M:14:0E, N:141:8D, P:4:04 LOG2P:2 36.05 MHz
	INIT_PLL,
	NV_PRAMDAC_VPLL_COEFF,        // NV 32 bit address.
	3600,
	//        00001400Ch
	//        000028D0Eh

	// Comment to fix assembler bug

	// NV_PFB_GREEN_0
	INIT_ZM_REG,
	NV_PFB_GREEN_0,   // NV 32 bit address.
	DRF_DEF(_PFB,_GREEN_0,_LEVEL,_VIDEO_ENABLED),   // NV 32 bit data.

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PFB_DEBUG_0,
#ifdef IKOS
	//        20005000h            // IKOS value - turns on slow clock
	0x20000100,          // Per RussM on 10/14
#else   // IKOS                   
	0x20001D00,            // 7/23
#endif 

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PFB_CONFIG_1,
	0xC1016293,          // This value works for about everything

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PFB_RTL,
	0,

	// Comment to fix assembler bug

	// Per Dave Reed
	// Setup more optimal PCI interface
	INIT_ZM_REG,
	NV_PBUS_DEBUG_1,
	DRF_DEF(_PBUS,_DEBUG_1,_PCIM_THROTTLE,_DISABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIM_CMD,_SIZE_BASED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_PCIM_AGP,_IS_AGP) |			// !!!!!!!!!!!
		DRF_DEF(_PBUS,_DEBUG_1,_AGPM_CMD,_LP_ONLY) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WRITE,_0_CYCLE) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_2_1,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RETRY,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RD_BURST,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WR_BURST,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_EARLY_RTY,_ENABLED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RMAIO,_DISABLED) |		// !!!!!!!!!!!
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_CPUQ,_ENABLED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_SPARE1,_ZERO) |
		DRF_DEF(_PBUS,_DEBUG_1,_FBI_DIFFERENTIAL,_DISABLED) |	// !!!!!!!!!!!
		DRF_DEF(_PBUS,_DEBUG_1,_SPARE2,_ONE),

	// Comment to fix assembler bug

	INIT_COMPUTE_MEM,             // Compute frame buffer size

	//=============================================================
	//       Memory Dependent Initialization Table.
	//=============================================================

#ifdef  NV5
	INIT_NV_REG,                 // Write register with Mask
	NV_PFB_BOOT_0,               // Strap Register for Memory
	0xFFFFFF00,                  // AND Mask
	0x00000024,                  // OR Mask - 32MB SDRAM
	//        00000001Fh                  // OR Mask - 16MB SDRAM
#else               
	INIT_NV_REG,                 // Write register with Mask
	NV_PFB_BOOT_0,               // Strap Register for Memory
	0xFFFFFFFF,                  // AND Mask
	0x00000000,                  // OR Mask
#endif     
	INIT_MEM_RESTRICT,
	0x18,                        // Strip to memory type (AND MASK)
	0x18,                        // Compare value = SDRAM

	INIT_ZM_REG,
	NV_PFB_CONFIG_1,

#ifdef INTEL 
	0xC1016293,          // This value works for about everything
#else 
	0x31012132,                  // Set DRAM value
#endif   

	INIT_RESUME,                 // No more SDRAM stuff
	     
	INIT_MEM_RESTRICT,
	0x18,                        // Strip to memory type (AND MASK)
	0x10,                        // Compare value = SDRAM

	INIT_ZM_REG,
	NV_PFB_CONFIG_1,

#ifdef  INTEL 
	0xC1016293,          // This value works for about everything
#else 
	0x31012132,                  // Set DRAM value
#endif 

	INIT_RESUME,                 // No more SDRAM stuff

	//------------------------------------------------------------
	//       Final Initialization Tables.
	//------------------------------------------------------------
	//
	//       Max allocated Final init space is
	//       INIT_ADDITION_REG_SPACE. This includes the FinalInit
	//       table and the FinalInit tables for all the FinalMem
	//       inits. OEM will utilize the BMP to maximize the
	//       utilization of addition table space.
	//

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PRAMDAC_PLL_COEFF_SELECT,   // NV 32 bit address.
	0x0000500,                   // PROG_MPLL & PROG_NVPLL

	// Comment to fix assembler bug

	// tbo
	INIT_ZM_REG,
	NV_PBUS_DEBUG_2,
	0x00011F0,               // Per Jill S. -  5/12

	INIT_ZM_REG,
	NV_PBUS_DEBUG_3,
	NV_PBUS_DEBUG_3_AGP_MAX_SIZE_32_BYTES,
	// tbo

	// Comment to fix assembler bug

	// Force real mode window default state to off
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	NV_CIO_CRE_RMA__INDEX,0x00,0x00,

	// Make sure hsync and vsync are on (we only set them in DPMS calls)
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x1A,0x00,0x3F,

	// Comment to fix assembler bug

	// Boot with TV off, and set for NTSC if it was on.
	// Also set horizontal pixel adjustment
	// Sets pixel format to VGA
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x28,0x00,0x00,

	// Comment to fix assembler bug
#ifdef NV5 
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x21,0x00,0xFA,         // Force Lock register to 0FAh
#endif  // NV5                        

	// Clear scratch to default state
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x2C,0x30,0x00,         // Use this line to use straps

	//        02Ch,000h,010h          // Use this line to force NTSC Boot
	//        02Ch,000h,020h          // Use this line to force PAL Boot
	//        02Ch,000h,000h         // Use this line to force NOTV Boot
	                   
	// Float DDC pins high (not touched during a mode set or save/restore state)
	//        INIT_INDEX_IO
	//        CRTC_INDEX_COLOR
	//        03Fh,000h,033h

	// Disable DDC
	//        INIT_INDEX_IO
	//        CRTC_INDEX_COLOR
	//        03Fh,000h,032h

	// Comment to fix assembler bug

	INIT_DONE
	//        EOL //END OF LIST

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\devinit\nv\nv04mem.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************************************************************************************************
*
*	Module: nv04mem.c
*
*	Description:
*		Device-specific memory sizing code, for NV4.
*
*	Revision History:
*		Original -- 5/99 Jeff Westerinen
*
**************************************************************************************************************/

#ifdef NV_PORTABLE

/* "portable" form for use outside resman and by external source customers */
/* look in devinit/portable/ for more details */
#include <nv_portable.h>
#include <nv_ref.h>
#include <nv4_ref.h>
#include <devinit.h>

#else	/* not NV_PORTABLE --> Nvidia internal */

#include <nvrm.h>
#include <nvhw.h>
#include <nv4_ref.h>
#include <os.h>
#include <devinit.h>

#endif

// TO DO: the actual memory detection and sizing is device dependent
extern char strDevNodeRM[];

RM_STATUS Nv04MemResizeMemory
(
	PHWINFO pDev
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 memoryType;
    U008 sgram_mem[] = "SGRAM";
    U008 sdram_mem[] = "SDRAM";
    U032 offset;

    // check for registry override of memory type
    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "VideoMemoryTypeOverride", &memoryType) == RM_OK)
    {
        switch(memoryType)
        {
            case DEVINIT_SDRAM:
                rmStatus = Nv04MemResizeSdram(pDev);
                break;
                
            case DEVINIT_SGRAM:
                rmStatus = Nv04MemResizeSgram(pDev);
                break;
                
            default:
                rmStatus = RM_ERROR;
                break;
        }
    } else {
        rmStatus = BiosFindString(pDev, sgram_mem, &offset, sizeof(sgram_mem));
        if (rmStatus == RM_OK)
        {
            rmStatus = Nv04MemResizeSgram(pDev);
            goto done;
        }
 
        rmStatus = BiosFindString(pDev, sdram_mem, &offset, sizeof(sdram_mem));
        if (rmStatus == RM_OK)
        {
            rmStatus = Nv04MemResizeSdram(pDev);
            goto done;
        } 

        rmStatus = RM_ERROR;
    }

done:
    return rmStatus;
                
} // end of DevinitResizeMemory()

RM_STATUS Nv04MemResizeSdram
(
	PHWINFO pDev
)
{
	RM_STATUS rmStatus = RM_OK;
	U032 i;

	// TO DO: is this necessary?
    // turn on full CPU access
	//...
        
	// turn on refresh
    FLD_WR_DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED);

    // assume 16MB, 128-bit, 1024K 2-bank
    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_16MB);
    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_WIDTH_128,_ON);
    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_TYPE,_1024K_2BANK);   
    Nv04MemLatchMemConfig(pDev);

    // write 128 bits of data for the test sequence
    for (i = 0; i < 4; i++)
    {
        FB_WR32(i * 4, 'NV4A');
    }    
                                                 
    // if the lower 16 bits of 128-bit word is invalid, change to 8M
    if (FB_RD16(0x0000000C) != '4A')
    {
        FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_8MB);
        FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_WIDTH_128,_OFF);
    }

    // insure the memory config gets set
    Nv04MemLatchMemConfig(pDev);

	// TO DO: is this necessary?
	// turn off full CPU access
	//...
    
    // output results
    switch (REG_RD_DRF(_PFB,_BOOT_0,_RAM_AMOUNT))
    {
        case NV_PFB_BOOT_0_RAM_AMOUNT_8MB:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM:   8MB SDRAM\n");
            break;
            
        case NV_PFB_BOOT_0_RAM_AMOUNT_16MB:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM:   16MB SDRAM\n");
            break;
            
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Unknown Size SDRAM\n");
            break;
    }

	return rmStatus;

} // end of DevinitResizeSdram()

RM_STATUS Nv04MemResizeSgram
(
	PHWINFO pDev
)
{
	RM_STATUS rmStatus = RM_OK;
	U032 i, memDevSize;

	// TO DO: is this necessary?
    // turn on full CPU access
	//...
        
    // disable refresh for the entire routine 
    FLD_WR_DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_DISABLED);

    // assume 16MB, 128-bit, 512K 2-bank
    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_16MB);
    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_WIDTH_128,_ON);
    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_TYPE,_512K_2BANK);    
    Nv04MemLatchMemConfig(pDev);

    // write 128-bit test data word at the beginning of FB
    for (i = 0; i < 4; i++)
    {
        FB_WR32(i * 4, 'NV4A');
    }    
    
    // determine the size of the memory devices, i.e. 8 or 16 Mbit
    memDevSize = (FB_RD32(0x00000000) == 'NV4A') ? 16 : 8;

    // determine the interface width
    if (FB_RD16(0x0e) == 'NV')
    {
        // 128-bit width detected
        
        // detect 8mbit or 16mbit @ 128-bits
        if (memDevSize == 16)
        {
            // 16mbit device, 128-bit width detected
            
            // detect 8MB or 16MB total RAM amount
            FB_WR32(0x00800000, 'A4VN');
            if (FB_RD32(0x00800000) != 'A4VN')
            {
                // 8MB detected, so change config
                FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_8MB);
            }
        }
        else
        {
            // 8mbit device, 128-bit width detected
            
            // detect 4MB or 8MB total RAM amount
            // Note: unclear about 4/8M test -- write at 4Meg or 8Meg??? -- !!!!! TEST THIS !!!!!
            FB_WR32(0x00800000, 'A4VN');
            if (FB_RD32(0x00800000) == 'A4VN')
            {
                // 8MB detected, so change config
                FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_8MB);
            }
            else
            {
                // 4MB detected, so change config
                FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_4MB);
            }
        }
    }
    else
    {
        // 64-bit width detected
        
        // since 8MBit device is not valid at 64-bit width, 4MB detected, so change config
        FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_WIDTH_128,_OFF);
        FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_4MB);
    }

    // insure the memory config gets set
    Nv04MemLatchMemConfig(pDev);

	// reenable refresh
    FLD_WR_DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED);

	// TO DO: is this necessary?
	// turn off full CPU access
	//...

    // output results
    switch (REG_RD_DRF(_PFB,_BOOT_0,_RAM_AMOUNT))
    {
        case NV_PFB_BOOT_0_RAM_AMOUNT_4MB:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM:   4MB SGRAM\n");
            break;
            
        case NV_PFB_BOOT_0_RAM_AMOUNT_8MB:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM:   8MB SGRAM\n");
            break;
            
        case NV_PFB_BOOT_0_RAM_AMOUNT_16MB:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM:   16MB SGRAM\n");
            break;
            
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Unknown Size SGRAM\n");
            break;
    }

	return rmStatus;

} // end of DevinitResizeSgram()

VOID Nv04MemLatchMemConfig
(
    PHWINFO pDev
)
{
    // save the original CAS latency
    U032 latency = REG_RD_DRF(_PFB,_CONFIG_1,_CAS_LATENCY);
    
    // toggle the LSB 1-0-1
    FLD_WR_DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3);
    FLD_WR_DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_2);
    FLD_WR_DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3);
    
    // restore original CAS latency
    FLD_WR_DRF_NUM(_PFB,_CONFIG_1,_CAS_LATENCY,latency);
    
} // end of Nv04MemLatchMemConfig()


// end of nv04mem.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\devinit\nv\devinit.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************************************************************************************************
*
*   Module: devinit.c
*
*   Description:
*       Device POST code.
*
*   Revision History:
*       Original -- 2/99 Jeff Westerinen
*
**************************************************************************************************************/


#ifdef NV_PORTABLE

/* "portable" form for use outside resman and by external source customers */
/* look in devinit/portable/ for more details */
#include <nv_portable.h>
#include <nv_ref.h>
#include <nv4_ref.h>
#include <devinit.h>

#else   /* not NV_PORTABLE --> Nvidia internal */

#include <nvrm.h>
#include <nvhw.h>
#include <nv4_ref.h>
#include <os.h>
#include <devinit.h>

#endif

// TO DO: this is a hack to avoid osallocmem() from an isr (the TMDS bip3 interpret is called during modeset)
#define USE_STATIC_BIP3_TABLES

#ifdef USE_STATIC_BIP3_TABLES
static BIOS_BIP3_TABLES bip3_static_tables;
#endif


// ***** MAIN ENTRY POINT FOR DEVICE INITIALIZATIONS *****

RM_STATUS DevinitInitializeDevice
(
    PHWINFO pDev,
    PHWREG  externalBiosImage,
    BOOL   *pBiosUsedToInit
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 offset;
    U008 lock;
    PHWREG tempBiosAddr;
    BMP_Control_Block bmpCtrlBlk;
    U032 Head = 0;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: initializing device...\n");

    // enable VGA subsystem
    FLD_WR_DRF_DEF(_PBUS,_PCI_NV_21,_VGA,_ENABLED);

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);

    // determine current strap crystal frequency (in Hz), if it has not already been set
    if (pDev->Chip.HalInfo.CrystalFreq == 0)
    {
        if (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_CRYSTAL) == NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K)
            pDev->Chip.HalInfo.CrystalFreq = 13500000;
        else if (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_CRYSTAL) == NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180)
            pDev->Chip.HalInfo.CrystalFreq = 14318180;
    }

    // be pessimistic
    *pBiosUsedToInit = FALSE;

    // use the external bios image, if present
    tempBiosAddr = biosAddr;
    if (externalBiosImage)
    {
        biosAddr = externalBiosImage;
    }

    // pull in the BMP control block
    rmStatus = DevinitGetBMPControlBlock(pDev, &bmpCtrlBlk, &offset);

    // process the initialization code
    if (rmStatus == RM_OK)
    {
        // use the BIOS image to init
        if ((bmpCtrlBlk.CTL_Version >= BMP_INIT_TABLE_VER_5) &&
            (bmpCtrlBlk.CTL_Flags >= BMP_INIT_TABLE_SUBVER_0x10))
        {
            // initialize the device using BIP/3 code
            rmStatus = DevinitProcessBip3(pDev);
            if (rmStatus == RM_OK)
                *pBiosUsedToInit = TRUE;
        }
        else
        {
            // initialize the device using BIP/2 code
            rmStatus = DevinitProcessBip2(pDev, offset, bmpCtrlBlk, pBiosUsedToInit);
        }
    }
    else
    {
        // use the static tables to init
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: cannot find BMP Control Block, using static tables...\n");
        rmStatus = DevinitProcessStaticTables(pDev);
    }

    // restore original biosAddr
    biosAddr = tempBiosAddr;

    RestoreLock(pDev, Head, lock);

    // enable shadowing of BIOS
    FLD_WR_DRF_DEF(_PBUS,_PCI_NV_20,_ROM_SHADOW,_ENABLED);

    if (rmStatus == RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: ...device initialization succeeded\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ...device initialization *** FAILED ***\n");
    }

    return rmStatus;

} // end of DevinitInitializeDevice()

RM_STATUS DevinitGetBMPControlBlock
(
    PHWINFO             pDev,
    BMP_Control_Block  *pControlBlock,
    U032               *offset
)
{
    RM_STATUS rmStatus = RM_ERROR;
    int i;

    // attempt to find the init info in the BIOS
    for (i = 0; i < MAX_BIOS_SCAN-3; i++)
        if (BIOS_RD32(i) == CTRL_BLK_ID)
            break;

    if (i < MAX_BIOS_SCAN-3)
    {
        int so;

        // going to recalc offset, so make sure it is zero now since the
        //   following read must happen at exactly 'i'
        pDev->biosOffset = 0;

        rmStatus = BiosReadStructure(pDev,
                                     (U008*) pControlBlock,
                                     i,
                                     (U032 *) 0,
                                     BMP_CONTROL_BLOCK_FMT);
        if (rmStatus != RM_OK)
            goto done;

        // The BMP tables have offsets with them relative to the beginning
        //   of the rom.  If the rom has been relocated, these offsets will
        //   be bogus.
        //
        //   This happens on Mac roms when the BMP tables are relocated
        //   from their normal location in the pc bios image to the end of the
        //   openforth image.
        //
        //   Calculate an 'extra offset' to compensate and save it in the pDev
        //

        for (so = i-2; so >= 0; so--)
            if ((BIOS_RD08(so) == 0x55) && (BIOS_RD08(so+1) == 0xAA))
                break;
        if (so >= 0)
            pDev->biosOffset = so;

        // where did we get the table from?
        *offset = i - pDev->biosOffset;
    }

 done:
    return rmStatus;
}


// ***** CORE 2 SCRIPT PROCESSING *****

RM_STATUS DevinitProcessBip2
(
    PHWINFO pDev,
    U032 offset,
    BMP_Control_Block bmpCtrlBlk,
    BOOL* pBiosUsedToInit
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 genInitTableOffset, extraInitTableOffset, sizeInitTable, memInitTableOffset, SDRSeqTableOffset, DDRSeqTableOffset;
    devinit_tables_t *dt = 0;

    rmStatus = DevinitGetInitTableInfo(pDev,
                                       offset,
                                       &bmpCtrlBlk,
                                       &genInitTableOffset,
                                       &extraInitTableOffset,
                                       &sizeInitTable,
                                       &memInitTableOffset,
                                       &SDRSeqTableOffset,
                                       &DDRSeqTableOffset);

    if (rmStatus != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: invalid BIOS init info version\n");
        goto fallback;
    }

    if (sizeInitTable > BMP_INIT_CODE_SIZE_MAX)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: genInitData too large\n");
        goto fallback;
    }

    // allocate space for init tables
    rmStatus = osAllocMem((VOID **) &dt, sizeof(*dt));
    if (rmStatus != RM_OK)
        goto done;
    dt->genInitData   = (U008 *) 0;      // allocate later based on actual size
    dt->genInitCode   = (U032 *) 0;      // allocate later based on actual size
    dt->extraInitData = (U008 *) 0;      // allocate later based on actual size
    dt->extraInitCode = (U032 *) 0;      // allocate later based on actual size

    // allocate room for the genInitData
    rmStatus = osAllocMem((VOID **) &dt->genInitData, sizeInitTable);
    if (rmStatus != RM_OK)
        goto done;
    rmStatus = osAllocMem((VOID **) &dt->genInitCode, sizeInitTable * sizeof(U032));
    if (rmStatus != RM_OK)
        goto done;
    if (extraInitTableOffset)
    {
        // assume any extra init table no bigger than 'sizeInitTable'
        rmStatus = osAllocMem((VOID **) &dt->extraInitData, sizeInitTable);
        if (rmStatus != RM_OK)
            goto done;
        rmStatus = osAllocMem((VOID **) &dt->extraInitCode, sizeInitTable * sizeof(U032));
        if (rmStatus != RM_OK)
            goto done;
    }

    // extract the memory init code from the BIOS into a buffer
    if (memInitTableOffset)
    {
        int   padded_size_each;
        char *fmt;

        // figure out if using NV10 or NV15 format
        DevinitMeminitFormat(pDev, &fmt, &padded_size_each);

        // extract the array of memory formats
        // trick is that this array has to look right to the NV10 or NV15
        // routines which are expecting their own slice typedef
        BiosReadArray(pDev,
                      (VOID *) dt->memInitTable,
                      memInitTableOffset,
                      MEM_INIT_STRAP_MAX + 1,
                      (U032 *) 0,
                      fmt);
        if (rmStatus != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS,
                             "NVRM: could not unpack meminit table data\n");
            goto fallback;
        }
    }

    // extract the SDR init sequence from the BIOS into a buffer
    if (SDRSeqTableOffset)
    {
        rmStatus = BiosReadStructure(pDev,
                                     (U008*) dt->SDRSeqTable,
                                     SDRSeqTableOffset,
                                     (U032 *) 0,
                                     MEM_SEQ_FMT);
        if (rmStatus != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: could not extract SDR data\n");
            goto fallback;
        }
    }

    // extract the DDR init sequence from the BIOS into a buffer
    if (DDRSeqTableOffset)
    {
        rmStatus = BiosReadStructure(pDev,
                                     (U008*)dt->DDRSeqTable,
                                     DDRSeqTableOffset,
                                     (U032 *) 0,
                                     MEM_SEQ_FMT);
        if (rmStatus != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: could not extract DDR data\n");
            goto fallback;
        }
    }

    // Make sure we don't overflow the init code buffer
    if (sizeInitTable > BMP_INIT_CODE_SIZE_MAX)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Init table too large\n");
        rmStatus = RM_ERROR;
        goto fallback;
    }

    rmStatus = BiosReadBytes(pDev, dt->genInitData, genInitTableOffset, sizeInitTable);
    if (rmStatus != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: invalid or incomplete general init data found in BIOS\n");
        goto fallback;
    }

    // convert byte-wise init data from the BIOS to dword-wise init code
    rmStatus = DevinitInitDataToCode(dt->genInitCode, dt->genInitData);
    if (rmStatus != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: old or unusable BIOS init data\n");
        goto fallback;
    }

    // initialize with the buffer of previously extracted code
    rmStatus = InitNV(pDev, dt->genInitCode, (VOID *) dt->memInitTable, dt->SDRSeqTable, dt->DDRSeqTable);
    if (rmStatus != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: cannot initialize device using BIOS\n");
        goto fallback;
    }

    if (extraInitTableOffset)
    {
        rmStatus = BiosReadBytes(pDev, dt->extraInitData, extraInitTableOffset, sizeInitTable);
        if (rmStatus != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: invalid or incomplete extra init data found in BIOS\n");
            goto fallback;
        }

        // TO DO: change the code to byte-wise structs to remove the need for this
        // convert byte-wise init data from the BIOS to dword-wise init code
        rmStatus = DevinitInitDataToCode(dt->extraInitCode, dt->extraInitData);
        if (rmStatus != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: old or unusable BIOS extra init data\n");
            goto fallback;
        }

        // initialize with the buffer of previously extracted code
        rmStatus = InitNV(pDev, dt->extraInitCode, (VOID *) 0, (VOID *) 0, (VOID *) 0);
        if (rmStatus != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: cannot perform 'extra init' using BIOS\n");
            goto fallback;
        }

    }

    // Whew!
    *pBiosUsedToInit = TRUE;


 fallback:
    // could not rely on the init code in the BIOS, so use a static init table
    if ( ! *pBiosUsedToInit)
    {
        rmStatus = DevinitProcessStaticTables(pDev);
    }

 done:
    if (dt)
    {
        if (dt->genInitData)
            osFreeMem(dt->genInitData);
        if (dt->genInitCode)
            osFreeMem(dt->genInitCode);
        if (dt->extraInitData)
            osFreeMem(dt->extraInitData);
        if (dt->extraInitCode)
            osFreeMem(dt->extraInitCode);
        osFreeMem(dt);
    }

    return rmStatus;

} // end of DevinitProcessBip2()

RM_STATUS InitNV
(
    PHWINFO pDev,
    U032 genInitCode[],
    VOID* memInitTable,
    U032 SDRSeqTable[],
    U032 DDRSeqTable[]
)
{
    RM_STATUS rmStatus = RM_OK;
    U008 opcode;
    char opcodeStr[] = "NVRM: \' \' BMP operation...\n";
    U032 ip = 0;
    BOOL conditionFlag = TRUE;

    // execute the microcode referenced by the instruction pointer
    while ((opcode = DevinitFetchByte(genInitCode, &ip)) != INIT_DONE)
    {
        // extract the operands from the table and perform the operation
        opcodeStr[7] = opcode;
#if !defined(UNIX) 
        // this debug printf to the VGA console messes up the init sequence
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, opcodeStr);
#endif
        switch (opcode)
        {
            case INIT_NV_REG:
            {
                U032 addr = DevinitFetchDword(genInitCode, &ip);
                U032 mask = DevinitFetchDword(genInitCode, &ip);
                U032 data = DevinitFetchDword(genInitCode, &ip);
                rmStatus = init_NV(pDev, addr, mask, data, conditionFlag);
                break;
            }

            case INIT_ZM_REG:
            {
                U032 addr = DevinitFetchDword(genInitCode, &ip);
                U032 data = DevinitFetchDword(genInitCode, &ip);
                rmStatus = init_NV(pDev, addr, 0, data, conditionFlag);
                break;
            }

            case INIT_ZM_WREG:
            {
                U032 addr = DevinitFetchDword(genInitCode, &ip);
                U016 data = DevinitFetchWord(genInitCode, &ip);
                rmStatus = init_NV(pDev, addr, 0, (U032)(data) & 0x0000ffff, conditionFlag);
                break;
            }

            case INIT_PLL:
            {
                // fetch the address
                U032 addr = DevinitFetchDword(genInitCode, &ip);
                U016 data = DevinitFetchWord(genInitCode, &ip);
                rmStatus = init_PLL_Values(pDev, addr, data, conditionFlag);
                break;
            }

            case INIT_TIME:
            {
                U032 ticks = DevinitFetchWord(genInitCode, &ip);
                rmStatus = init_TIME_Delay(pDev, ticks);
                break;
            }

            case INIT_INDEX_IO:
            {
                U016 addr = DevinitFetchWord(genInitCode, &ip);
                U008 index = DevinitFetchByte(genInitCode, &ip);
                U008 mask = DevinitFetchByte(genInitCode, &ip);
                U008 data = DevinitFetchByte(genInitCode, &ip);
                rmStatus = init_INDEX_IO_Write(pDev, addr, index, mask, data, conditionFlag);
                break;
            }

            case INIT_MEM_RESTRICT:
            {
                U032 mask = DevinitFetchByte(genInitCode, &ip);
                U032 value = DevinitFetchByte(genInitCode, &ip);
                rmStatus = init_MEM_RESTRICT_SCRIPT(pDev, mask, value, &conditionFlag);
                break;
            }

            case INIT_STRAP_RESTRICT:
            {
                U032 mask = DevinitFetchDword(genInitCode, &ip);
                U032 value = DevinitFetchDword(genInitCode, &ip);
                rmStatus = init_STRAP_RESTRICT_SCRIPT(pDev, mask, value, &conditionFlag);
                break;
            }

            case INIT_RESUME:
            {
                conditionFlag = TRUE;
                break;
            }

            case INIT_CONFIGURE_CLK:
            {
                rmStatus = init_CONFIGURE_Clocks(pDev, memInitTable);
                break;
            }

            case INIT_CONFIGURE_MEM:
            {
                rmStatus = init_CONFIGURE_Memory(pDev, memInitTable, SDRSeqTable, DDRSeqTable);
                break;
            }

            case INIT_CONFIGURE_PREINIT:
            {
                rmStatus = init_CONFIGURE_PreInit(pDev);
                break;
            }

            case INIT_COMPUTE_MEM:
            {
                rmStatus = init_COMPUTE_Memory(pDev);
                break;
            }

            case INIT_RESET:
            {
                U032 addr = DevinitFetchDword(genInitCode, &ip);
                U032 data1 = DevinitFetchDword(genInitCode, &ip);
                U032 data2 = DevinitFetchDword(genInitCode, &ip);
                rmStatus = init_Reset_Chip(pDev, addr, data1, data2);
                break;
            }

            default:
                rmStatus = RM_ERROR;
                break;
        }
        if (rmStatus != RM_OK)
        {
            break;
        }
    }

    return rmStatus;

} // end of InitNV()

// parse the little-endian init data to convert all opcodes and operands
// to big-endian 32-bit values
RM_STATUS DevinitInitDataToCode
(
    U032 *code,
    U008 *data
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 codeIndex = 0, dataIndex = 0;
    U032 fields;
    U032 unpacked_bytes;

    // parse all instructions
    while (data[dataIndex] != INIT_DONE) // Byte quantity, no swap needed
    {
        // convert instruction based on the opcode
        // copy byte/word/dword of data into a dword of code
        switch (data[dataIndex])     // Byte quantity, no swap needed
        {
            case INIT_NV_REG:
            case INIT_RESET:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT1_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }
            case INIT_ZM_REG:
            case INIT_STRAP_RESTRICT:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT2_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }

            case INIT_ZM_WREG:
            case INIT_PLL:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT3_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }

            case INIT_TIME:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT4_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }

            case INIT_INDEX_IO:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT5_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }

            case INIT_MEM_RESTRICT:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT6_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }

            case INIT_RESUME:
            case INIT_CONFIGURE_MEM:
            case INIT_CONFIGURE_CLK:
            case INIT_CONFIGURE_PREINIT:
            case INIT_COMPUTE_MEM:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT7_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }

            default:
                rmStatus = RM_ERROR;
                break;
        }

        if (rmStatus != RM_OK)
            break;

        dataIndex += unpacked_bytes;
        codeIndex += fields;
    }

    // append init code delimiter
    if (rmStatus == RM_OK)
        code[codeIndex] = (U032)INIT_DONE;

    return rmStatus;

} // end of DevinitInitDataToCode()


RM_STATUS DevinitProcessStaticTables
(
    PHWINFO pDev
)
{
    RM_STATUS rmStatus = RM_OK;

#ifndef MACOS // no fallback tables for MAC
    DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: using static tables for device init\n");

    // initialize with the proper device-specific initialization code table
    switch (REG_RD_DRF(_PBUS,_PCI_NV_0,_DEVICE_ID_CHIP))
    {
        case NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP_NV4:
            rmStatus = InitNV(pDev, Nv04_bmp_GenInitTbl, NULL, NULL, NULL);
            break;

        case NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP_NV5:
            switch (REG_RD_DRF(_PBUS,_PCI_NV_11,_SUBSYSTEM_ID))
            {
                case NV_PBUS_PCI_NV_11_SUBSYSTEM_ID_TNT2PRO:
                    rmStatus = InitNV(pDev, Nv05Pro_bmp_GenInitTbl, Nv05_bmp_MemInitTbl, NULL, NULL);
                    break;

                default:
                    rmStatus = InitNV(pDev, Nv05_bmp_GenInitTbl, Nv05_bmp_MemInitTbl, NULL, NULL);
                    break;
            }
            break;

        case NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP_NV10:
            rmStatus =
                InitNV
                (
                    pDev,
                    Nv10_bmp_GenInitTbl,
                    Nv10_bmp_MemInitTbl,
                    Nv10_SDR_Sequence_Table,
                    Nv10_DDR_Sequence_Table
                );
            break;

        default:
            rmStatus = RM_ERROR;
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: no static tables for device\n");
            break;
    }
#endif // MACOS

    return rmStatus;

} // end of DevinitProcessStaticTables()


// extract the relavant values from any arbitrary version of BMP structure
RM_STATUS DevinitGetInitTableInfo
(
    PHWINFO pDev,
    U032    offset,
    PBMP_Control_Block pBmpCtrlBlk,
    U032*   pGenInitTable,
    U032*   pExtraInitTable,
    U032*   pSizeInitTable,
    U032*   pMemInitTable,
    U032*   pSDRSequenceTable,
    U032*   pDDRSequenceTable
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (pBmpCtrlBlk->CTL_Version)
    {
        // BMP init table version 0 is for Nv3
        case BMP_INIT_TABLE_VER_0:
            rmStatus = RM_ERROR;
            break;

        // BMP init table version 1 and 2 use the version 1 base-level functionality
        case BMP_INIT_TABLE_VER_1:
        {
            BMP_Struc_Rev1 BMP_InitTableInfo;
            rmStatus = BiosReadStructure(pDev,
                                         (U008*) &BMP_InitTableInfo,
                                         offset,
                                         (U032 *) 0,
                                         BMP_INIT1_FMT);
            if (rmStatus != RM_OK)
                break;

            *pGenInitTable = BMP_InitTableInfo.BMP_GenInitTable;
            *pExtraInitTable = BMP_InitTableInfo.BMP_ExtraInitTable;
            *pSizeInitTable = BMP_InitTableInfo.BMP_SizeInitTable;
            *pMemInitTable = 0;
            *pSDRSequenceTable = 0;
            *pDDRSequenceTable = 0;
            break;
        }

        // BMP init table version 1 and 2 use the version 1 base-level functionality
        case BMP_INIT_TABLE_VER_2:
        {
            BMP_Struc_Rev2 BMP_InitTableInfo;
            rmStatus = BiosReadStructure(pDev,
                                         (U008*) &BMP_InitTableInfo,
                                         offset,
                                         (U032 *) 0,
                                         BMP_INIT2_FMT);
            if (rmStatus != RM_OK)
                break;

            *pGenInitTable = BMP_InitTableInfo.BMP_GenInitTable;
            *pExtraInitTable = BMP_InitTableInfo.BMP_ExtraInitTable;
            *pSizeInitTable = BMP_InitTableInfo.BMP_SizeInitTable;
            *pMemInitTable = 0;
            *pSDRSequenceTable = 0;
            *pDDRSequenceTable = 0;
            break;
        }

        // default is BMP init table version 3 base-level functionality
        default:
        {
            BMP_Struc_Rev3 BMP_InitTableInfo;
            BiosReadStructure(pDev,
                              (U008*) &BMP_InitTableInfo,
                              offset,
                              (U032 *) 0,
                              BMP_INIT3_FMT);

            *pGenInitTable = BMP_InitTableInfo.BMP_GenInitTable;
            *pExtraInitTable = BMP_InitTableInfo.BMP_ExtraInitTable;
            *pSizeInitTable = BMP_InitTableInfo.BMP_SizeInitTable;
            *pMemInitTable = BMP_InitTableInfo.BMP_MemInitTable;
            *pSDRSequenceTable = BMP_InitTableInfo.BMP_SDRSequenceTable;
            *pDDRSequenceTable = BMP_InitTableInfo.BMP_DDRSequenceTable;
            break;
        }
    }

    return rmStatus;

} // end of DevinitGetInitTableInfo()

U008 DevinitFetchByte(U032 code[], U032* pIp)
{
    return (U008)code[(*pIp)++];
}

U016 DevinitFetchWord(U032 code[], U032* pIp)
{
    return (U016)code[(*pIp)++];
}

U032 DevinitFetchDword(U032 code[], U032* pIp)
{
    return (U032)code[(*pIp)++];
}


// ***** CORE 3 SCRIPT PROCESSING *****

RM_STATUS DevinitProcessBip3
(
    PHWINFO pDev
)
{
    RM_STATUS rmStatus;
    EXECUTION_CONTEXT context;
    U032 scriptOffset;
    U032 scriptIndex = 0;

    // initialize execution context
    context.conditionFlag = TRUE;
    context.loopStack.sp = 0;
    context.tables = (VOID *) 0;


    // get all table offsets
    rmStatus = DevinitGetBIP3TableOffsets(pDev, &context);
    if (rmStatus != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: invalid BIOS init info version\n");
        return rmStatus;
    }

    // extract all tables from the BIOS image
    rmStatus = DevinitReadBIP3Tables(pDev, &context);
    if (rmStatus == RM_OK)
    {
        // interpret all scripts in the script table in order
        do
        {
            context.doJump = FALSE;
            scriptOffset = BiosRead16(pDev, context.scriptTableOffset + (scriptIndex * 2));
            if (scriptOffset != SCRIPT_TERMINATE)
            {
                // interpret the script at the script's offset into the BIP code
                DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: interpreting script...\n");
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   script table index: ", scriptIndex);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   script offset:      ", scriptOffset);
                rmStatus = DevinitInterpretBIP3Script(pDev, &context, scriptOffset);
                if (rmStatus == RM_OK)
                {
                    scriptIndex = (context.doJump) ? context.jumpIndex : scriptIndex + 1;
                }
                else
                {
                    DBG_PRINT_STRING      (DEBUGLEVEL_ERRORS, "NVRM: could not interpret script...\n");
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:   script table index: ", scriptIndex);
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:   script offset:      ", scriptOffset);
                    break;
                }
            }
        }
        while (scriptOffset != SCRIPT_TERMINATE);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: number of scripts interpreted = ", scriptIndex);
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: could not read BIP3 tables\n");
    }

    // release all local tables
    DevinitCleanupBIP3Tables(pDev, &context);

    return rmStatus;

} // end of DevinitProcessBip3()

RM_STATUS DevinitInterpretBIP3Script
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT pContext,
    U032               ip
)
{
    RM_STATUS rmStatus = RM_OK;
    U008 opcode;
    U008 opcodeStr[] = "NVRM: \' \' BMP operation...\n";
    BOOL done = FALSE;
    U032 packed_size, extra_packed_size;
    U008 instruction_buffer[BMP_MAX_PADDED_SIZE];
    VOID *instruction = instruction_buffer;

    // interpret the current script -- the instruction pointer, ip, always points to the next instruction
    do
    {
        // extract the operands from the current instruction and perform the operation
        opcode = 
            DevinitFetchInstruction
            (
                pDev,
                ip,
                instruction,
                &packed_size,
                &extra_packed_size
            );

        // go ahead and advance past the opcode proper.
        // After this we'll be pointing at the next instruction *or*
        //   any extra data as in BMP formats 12, 13, 14
        // At bottom we skip over any extra data associated with the opcode.
        ip += packed_size;

        if (opcode < ' ' || opcode > '~')
        {
            opcodeStr[7] = '?';
        }
        else
        {
            opcodeStr[7] = opcode;
        }

#if !defined(UNIX) 
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, opcodeStr);
#endif

#if 0
        GLOBAL_PRINTF(DEBUGLEVEL_TRACEINFO,
                      "NVRM: op: %c, 0x%x, from 0x%x, packed: %d, extra: %d\n",
                       opcode, opcode,
                       ip - packed_size,     // already added in
                       packed_size,
                       extra_packed_size);
#endif

                        
        switch (opcode)
        {
            case INIT_COMPUTE_MEM:
            {
                rmStatus = init_COMPUTE_Memory(pDev);
                break;
            }

            case INIT_RESET:
            {
                BMP_FORMAT_1 *bmp1 = instruction;
                init_Reset_Chip
                (
                    pDev, 
                    bmp1->operand1, 
                    bmp1->operand2, 
                    bmp1->operand3
                );
                break;
            }

            case INIT_IO:
            {
                BMP_FORMAT_9 *bmp9 = instruction;
                init_IO
                (
                    pDev,
                    bmp9->operand1,
                    bmp9->operand2,
                    bmp9->operand3,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_MEM_RESTRICT:
            {
                BMP_FORMAT_6 *bmp6 = instruction;
                init_MEM_RESTRICT_SCRIPT
                (
                    pDev,
                    bmp6->operand1,
                    bmp6->operand2,
                    &pContext->conditionFlag
                );
                break;
            }

            case INIT_NV_REG:
            {
                BMP_FORMAT_1 *bmp1 = instruction;
                init_NV
                (
                    pDev,
                    bmp1->operand1,
                    bmp1->operand2,
                    bmp1->operand3,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_RESUME:
            {
                pContext->conditionFlag = TRUE;
                break;
            }

            case INIT_TIME:
            {
                BMP_FORMAT_4 *bmp4 = instruction;
                init_TIME_Delay
                (
                    pDev, 
                    bmp4->operand1
                );
                break;
            }

            case INIT_INDEX_IO:
            {
                BMP_FORMAT_5 *bmp5 = instruction;
                init_INDEX_IO_Write
                (
                    pDev,
                    bmp5->operand1,
                    bmp5->operand2,
                    bmp5->operand3,
                    bmp5->operand4,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_PLL:
            {
                BMP_FORMAT_3 *bmp3 = instruction;
                init_PLL_Values
                (
                    pDev,
                    bmp3->operand1,
                    bmp3->operand2,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_ZM_REG:
            {
                BMP_FORMAT_2 *bmp2 = instruction;
                init_NV
                (
                    pDev,
                    bmp2->operand1,
                    0,
                    bmp2->operand2,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_SUB:
            {
                BMP_FORMAT_8* bmp8 = instruction;
                init_Sub
                (
                    pDev,
                    pContext,
                    bmp8->operand1,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_ZM_INDEX_IO:
            {
                BMP_FORMAT_9 *bmp9 = instruction;
                init_INDEX_IO_Write
                (
                    pDev,
                    bmp9->operand1,
                    bmp9->operand2,
                    0,
                    bmp9->operand3,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_ZM_IO:
            {
                BMP_FORMAT_10 *bmp10 = instruction;
                init_ZM_IO
                (
                    pDev,
                    bmp10->operand1,
                    bmp10->operand2,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_MACRO:
            {
                BMP_FORMAT_8 *bmp8 = instruction;
                init_Macro
                (
                    pDev,
                    pContext,
                    bmp8->operand1,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_CONDITION:
            {
                BMP_FORMAT_8 *bmp8 = instruction;
                init_Condition
                (
                    pDev,
                    pContext,
                    bmp8->operand1,
                    &pContext->conditionFlag
                );
                break;
            }

            case INIT_IO_CONDITION:
            {
                BMP_FORMAT_8 *bmp8 = instruction;
                init_IoCondition
                (
                    pDev,
                    pContext,
                    bmp8->operand1,
                    &pContext->conditionFlag
                );
                break;
            }

            case INIT_IO_FLAG_CONDITION:
            {
                BMP_FORMAT_8 *bmp8 = instruction;
                init_IoFlagCondition
                (
                    pDev,
                    pContext,
                    bmp8->operand1,
                    &pContext->conditionFlag
                );
                break;
            }

            case INIT_NOT:
            {
                pContext->conditionFlag = !pContext->conditionFlag;
                break;
            }

            case INIT_COPY:
            {
                BMP_FORMAT_11 *bmp11 = instruction;
                init_Copy
                (
                    pDev,
                    pContext,
                    bmp11->operand1,
                    (S008) bmp11->operand2,
                    bmp11->operand3,
                    bmp11->operand4,
                    bmp11->operand5,
                    bmp11->operand6,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_RESTRICT_PROG:
            {
                BMP_FORMAT_12 *bmp12 = instruction;
                init_RestrictProg
                (
                    pDev,
                    pContext,
                    bmp12->operand1,
                    bmp12->operand2,
                    bmp12->operand3,
                    bmp12->operand4,
                    bmp12->operand5,
                    ip,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_IO_RESTRICT_PROG:
            {
                BMP_FORMAT_13 *bmp13 = instruction;
                init_IoRestrictProg
                (
                    pDev,
                    pContext,
                    bmp13->operand1,
                    bmp13->operand2,
                    bmp13->operand3,
                    bmp13->operand4,
                    bmp13->operand5,
                    bmp13->operand6,
                    ip,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_IO_RESTRICT_PLL:
            {
                BMP_FORMAT_14 *bmp14 = instruction;
                init_IoRestrictPll
                (
                    pDev,
                    pContext,
                    bmp14->operand1,
                    bmp14->operand2,
                    bmp14->operand3,
                    bmp14->operand4,
                    bmp14->operand5,
                    bmp14->operand6,
                    bmp14->operand7,
                    ip,
                    pContext->conditionFlag
                );
                break;
            }
                
            case INIT_INDEX_ADDRESS_LATCHED:
            {
                BMP_FORMAT_15 *bmp15 = instruction;
                init_IndexAddressLatched
                (
                    pDev,
                    bmp15->operand1,
                    bmp15->operand2,
                    bmp15->operand3,
                    bmp15->operand4,
                    bmp15->operand5,
                    ip,
                    pContext->conditionFlag
                );
                break;
            }
                
            case INIT_REPEAT:
            {
                BMP_FORMAT_8 *bmp8 = instruction;
                init_Repeat
                (
                    pDev,
                    pContext,
                    ip,
                    bmp8->operand1
                );
                break;
            }

            case INIT_END_REPEAT:
            {
                init_EndRepeat
                (
                    pDev,
                    pContext,
                    &ip
                );
                break;
            }

            case INIT_FUNCTION:
            {
                BMP_FORMAT_8 *bmp8 = instruction;
                init_Function
                (
                    pDev,
                    pContext,
                    bmp8->operand1
                );
                break;
            }

            // all of these stop the processing of the current script
            case INIT_JUMP:
            {
                if (pContext->conditionFlag)
                {
                    // extract the destination script index and fall thru to end execution of the current script
                    BMP_FORMAT_8 *bmp8 = instruction;
                    pContext->doJump = TRUE;
                    pContext->jumpIndex = bmp8->operand1;
                    done = TRUE;
                }
                break;
            }

            case INIT_DONE:
            case INIT_EOS:
            case INIT_CONFIGURE_CLK:
            case INIT_CONFIGURE_MEM:
            case INIT_CONFIGURE_PREINIT:
                done = TRUE;
                break;

            default:
                if (opcode == 0x00)
                {
                    // screen out benign NULL opcodes
                    DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Benign opcode found in BIP3 table, skipping...\n");
                }
                else
                {    
                    // fail on undefined opcodes
                    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Bad opcode encountered\n");
                    rmStatus = RM_ERROR;
                }
                break;
        }
        if (rmStatus != RM_OK)
        {
            break;
        }

        // adjust the instruction pointer for those instruction with variable-sized operands
        ip += extra_packed_size;

    } while (!done);

    return rmStatus;

} // end of DevinitInterpretBIP3Script()

RM_STATUS DevinitProcessBip3InternalTMDS
(
    PHWINFO pDev,
    U032    fpPixClk,
    U032    interfaceType
)
{
    RM_STATUS rmStatus = RM_OK;
    EXECUTION_CONTEXT context;
    U032 TableOffset;
    
    // initialize execution context
    context.conditionFlag = TRUE;
    context.loopStack.sp = 0;

    // get all table offsets
    rmStatus = DevinitGetBIP3TableOffsets(pDev, &context);

    if (rmStatus != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: invalid BIOS init info version\n");
        return rmStatus;
    }
    
    switch ( interfaceType )
    {
        case TMDSIT_TMDS_SINGLE_A:
        {
            TableOffset = context.TMDSSingleAOffset;
            break;
        }
        case TMDSIT_TMDS_SINGLE_B:
        {
            TableOffset = context.TMDSSingleBOffset;
            break;
        }
        case TMDSIT_TMDS_DUAL:
        {
            TableOffset = context.TMDSDualOffset;
            break;
        }
        case TMDSIT_LVDS_SINGLE_A:
        {
            TableOffset = context.LVDSSingleAOffset;
            break;
        }
        case TMDSIT_LVDS_SINGLE_B:
        {
            TableOffset = context.LVDSSingleBOffset;
            break;
        }
        case TMDSIT_LVDS_DUAL:
        {
            TableOffset = context.LVDSDualOffset;
            break;
        }
        case TMDSIT_OFF_SINGLE_A:
        {
            TableOffset = context.OffSingleAOffset;
            break;
        }
        case TMDSIT_OFF_SINGLE_B:
        {
            TableOffset = context.OffSingleBOffset;
            break;
        }
        default:
        {
            return RM_ERROR;
        }
    }

    // Is this table present in the BIOS?
    if ( TableOffset == 0 )
    {
        return RM_ERROR;
    }

    // Find out which script index to use and process it
    rmStatus = DevinitProcessBip3InternalTMDSTable
        (
            pDev,
            &context,
            fpPixClk,
            TableOffset
        );

    return rmStatus;

} // end of DevinitProcessBip3InternalTMDS()


// Process an internal TMDS programming table
RM_STATUS DevinitProcessBip3InternalTMDSTable
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT context,
    U032               fpPixClk,
    U032               TableOffset
)
{
    RM_STATUS rmStatus = RM_OK;

    U032 scriptIndex = 0;

    U032 LastFreq;
    U032 Entries;
    BOOL Found = FALSE;

    U032 currentScriptOffset;
    TMDS_MODE_ENTRY tmdsModeEntry;
    U032            packed_size;

    LastFreq = 0;
    Entries = 0;

    // Scan for frequency
    do
    {
        // Because we don't know the size, extract one entry at a time
        rmStatus = BiosReadStructure(pDev,
                                     &tmdsModeEntry,
                                     TableOffset,
                                     &packed_size,
                                     TMDS_MODE_FORMAT);
        if (rmStatus != RM_OK)
        {
            return rmStatus;
        }
        // Is the pixel clock greater than or equal to this entries frequency
        if ( fpPixClk >= tmdsModeEntry.tmdsmFreq )
        {
            scriptIndex = tmdsModeEntry.tmdsmScript;
            Found = TRUE;
        }
        else if ( ( Entries > 0 ) && ( LastFreq <= tmdsModeEntry.tmdsmFreq ) )
        {
            // We didn't find a match yet, we saw at least two values,
            // and the frequencies are not decreasing
            return RM_ERROR;
        }
        else
        {
            LastFreq = tmdsModeEntry.tmdsmFreq;
            Entries++;
            TableOffset += packed_size;
        }
    } while ( ! Found);

    // interpret the script in the script table at the given index
    currentScriptOffset = BiosRead16(pDev, context->scriptTableOffset + (scriptIndex*2));
    return DevinitInterpretBIP3Script(pDev, context, currentScriptOffset);
}


// extract the relavant values from any arbitrary version of BIP/3 structure
RM_STATUS DevinitGetBIP3TableOffsets
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp
)
{
    RM_STATUS rmStatus = RM_OK;
    BMP_Control_Block bmpCtrlBlk;
    U032 offset;

    cp->TMDSSingleAOffset = 0;
    cp->TMDSSingleBOffset = 0;
    cp->TMDSDualOffset = 0;
    cp->LVDSSingleAOffset = 0;
    cp->LVDSSingleBOffset = 0;
    cp->LVDSDualOffset = 0;
    cp->OffSingleAOffset = 0;  
    cp->OffSingleBOffset = 0; 

    // get the offset of the BMP init table
    rmStatus = DevinitGetBMPControlBlock(pDev, &bmpCtrlBlk, &offset);
    if (rmStatus != RM_OK)
    {
        return rmStatus;
    }

    // get the BMP init table
    if (bmpCtrlBlk.CTL_Version == BMP_INIT_TABLE_VER_5)
    {
        // Core 3 type devinit tables should only be used with BMP 0x05.0x10 or greater.
        if ( bmpCtrlBlk.CTL_Flags < 0x10 )
        {
            return RM_ERROR;
        }
        switch (bmpCtrlBlk.CTL_Flags)
        {
            // Version 0x10 did not have TMDS tables
            case 0x10:
            {
                BMP_Struc_Rev5_0x10 bmpInitTable;
                BiosReadStructure(pDev,
                                  &bmpInitTable,
                                  offset,
                                  (U032 *) 0,
                                  BMP_INIT5_0x10_FMT);
                cp->scriptTableOffset          = bmpInitTable.BMP_InitScriptTablePtr;
                cp->macroIndexTableOffset      = bmpInitTable.BMP_MacroIndexTablePtr;
                cp->macroTableOffset           = bmpInitTable.BMP_MacroTablePtr;
                cp->conditionTableOffset       = bmpInitTable.BMP_ConditionTablePtr;
                cp->ioConditionTableOffset     = bmpInitTable.BMP_IOConditionTablePtr;
                cp->ioFlagConditionTableOffset = bmpInitTable.BMP_IOFlagConditionTablePtr;
                cp->functionTableOffset        = bmpInitTable.BMP_InitFunctionTablePtr;

                rmStatus = RM_OK;

                break;
            }


            // default is BIP/3 BMP init table version 5, subversion 0x11 base-level functionality or above
            default:
            {
                BMP_Struc_Rev5_0x11 bmpInitTable;
                BiosReadStructure(pDev,
                                  &bmpInitTable,
                                  offset,
                                  (U032 *) 0,
                                  BMP_INIT5_0x11_FMT);
                cp->scriptTableOffset          = bmpInitTable.BMP_InitScriptTablePtr;
                cp->macroIndexTableOffset      = bmpInitTable.BMP_MacroIndexTablePtr;
                cp->macroTableOffset           = bmpInitTable.BMP_MacroTablePtr;
                cp->conditionTableOffset       = bmpInitTable.BMP_ConditionTablePtr;
                cp->ioConditionTableOffset     = bmpInitTable.BMP_IOConditionTablePtr;
                cp->ioFlagConditionTableOffset = bmpInitTable.BMP_IOFlagConditionTablePtr;
                cp->functionTableOffset        = bmpInitTable.BMP_InitFunctionTablePtr;
                
                cp->TMDSSingleAOffset          = bmpInitTable.BMP_TMDSSingleAPtr;
                cp->TMDSSingleBOffset          = bmpInitTable.BMP_TMDSSingleBPtr;
                cp->TMDSDualOffset             = bmpInitTable.BMP_TMDSDualPtr;   
                cp->LVDSSingleAOffset          = bmpInitTable.BMP_LVDSSingleAPtr;
                cp->LVDSSingleBOffset          = bmpInitTable.BMP_LVDSSingleBPtr;
                cp->LVDSDualOffset             = bmpInitTable.BMP_LVDSDualPtr;   
                cp->OffSingleAOffset           = bmpInitTable.BMP_OffSingleAPtr; 
                cp->OffSingleBOffset           = bmpInitTable.BMP_OffSingleBPtr; 

                rmStatus = RM_OK;
                break;
            }
        }
    }
    else
    {
        rmStatus = RM_ERROR;
    }

    return rmStatus;

} // end of DevinitGetBIP3TableOffsets()

RM_STATUS DevinitReadBIP3Tables
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp    
)
{
    RM_STATUS rmStatus;

    // allocate space for the tables
    cp->tables = (VOID *) 0;

#ifdef USE_STATIC_BIP3_TABLES
    cp->tables = &bip3_static_tables;
#else
    rmStatus = osAllocMem((VOID *) &cp->tables, sizeof(*cp->tables));
    if (rmStatus != RM_OK)
        goto done;
#endif
        
    // go ahead and read entire macro index table into memory
    rmStatus = BiosReadArray(pDev,
                             cp->tables->macroIndexTable,
                             cp->macroIndexTableOffset,
                             256,
                             (U032 *) 0,        // packed size
                             MACRO_INDEX_ENTRY_FMT);
    if (rmStatus != RM_OK)
        goto done;

    // read macro table itself into memory
    rmStatus = BiosReadArray(pDev,
                             cp->tables->macroTable,
                             cp->macroTableOffset,
                             256,
                             (U032 *) 0,        // packed size
                             MACRO_ENTRY_FMT);
    if (rmStatus != RM_OK)
        goto done;
    
    // read condition table into memory
    rmStatus = BiosReadArray(pDev,
                             cp->tables->conditionTable,
                             cp->conditionTableOffset,
                             256,
                             (U032 *) 0,        // packed size
                             CONDITION_ENTRY_FMT);
    if (rmStatus != RM_OK)
        goto done;
    
    // read io condition table    
    rmStatus = BiosReadArray(pDev,
                             cp->tables->ioConditionTable,
                             cp->ioConditionTableOffset,
                             256,
                             (U032 *) 0,        // packed size
                             IO_CONDITION_ENTRY_FMT);
    if (rmStatus != RM_OK)
        goto done;

    // read io flag condition table    
    rmStatus = BiosReadArray(pDev,
                             cp->tables->ioFlagConditionTable,
                             cp->ioFlagConditionTableOffset,
                             256,
                             (U032 *) 0,        // packed size
                             IO_FLAG_CONDITION_ENTRY_FMT);
    if (rmStatus != RM_OK)
        goto done;

    // read function table
    rmStatus = BiosReadArray(pDev,
                             cp->tables->functionTable,
                             cp->functionTableOffset,
                             256,
                             (U032 *) 0,        // packed size
                             FUNCTION_ENTRY_FMT);
    if (rmStatus != RM_OK)
        goto done;

 done:
    return rmStatus;
    
} // end of DevinitReadBIP3Tables()

VOID DevinitCleanupBIP3Tables
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp    
)
{
#ifndef USE_STATIC_BIP3_TABLES
    if (cp->tables)
    {
        osFreeMem(cp->tables);
    }
#endif
    cp->tables = (VOID *) 0;
    
} // end of DevinitCleanupBIP3Tables()

U008 DevinitFetchInstruction
(
    PHWINFO pDev,
    U032    ip,
    VOID   *pInstruction,
    U032   *pPackedSize,
    U032   *pExtraPackedSize
)
{
    U032 padded_size;
    U008 opcode;
    U032 extra_packed_size = 0;
    U032 count;
    U032 elementSize;
    char *format;
    RM_STATUS rmStatus;

    // set current instruction
    opcode = BiosRead8(pDev, ip);

    // figure out what we are looking at here...
    switch (opcode)
    {
        case INIT_RESET:
        case INIT_NV_REG:
            padded_size = sizeof(BMP_FORMAT_1);
            format = INIT_FMT1_FMT;
            break;

        case INIT_ZM_REG:
            padded_size = sizeof(BMP_FORMAT_2);
            format = INIT_FMT2_FMT;
            break;

        case INIT_PLL:
            padded_size = sizeof(BMP_FORMAT_3);
            format = INIT_FMT3_FMT;
            break;

        case INIT_TIME:
            padded_size = sizeof(BMP_FORMAT_4);
            format = INIT_FMT4_FMT;
            break;

        case INIT_INDEX_IO:
            padded_size = sizeof(BMP_FORMAT_5);
            format = INIT_FMT5_FMT;
            break;

        case INIT_MEM_RESTRICT:
            padded_size = sizeof(BMP_FORMAT_6);
            format = INIT_FMT6_FMT;
            break;

        case INIT_COMPUTE_MEM:
        case INIT_CONFIGURE_MEM:
        case INIT_CONFIGURE_CLK:
        case INIT_CONFIGURE_PREINIT:
        case INIT_DONE:
        case INIT_RESUME:
        case INIT_EOS:
        case INIT_END_REPEAT:
        case INIT_NOT:
            padded_size = sizeof(BMP_FORMAT_7);
            format = INIT_FMT7_FMT;
            break;

        case INIT_SUB:
        case INIT_JUMP:
        case INIT_MACRO:
        case INIT_CONDITION:
        case INIT_IO_CONDITION:
        case INIT_IO_FLAG_CONDITION:
        case INIT_REPEAT:
        case INIT_FUNCTION:
            padded_size = sizeof(BMP_FORMAT_8);
            format = INIT_FMT8_FMT;
            break;

        case INIT_IO:
        case INIT_ZM_INDEX_IO:
            padded_size = sizeof(BMP_FORMAT_9);
            format = INIT_FMT9_FMT;
            break;

        case INIT_ZM_IO:
            padded_size = sizeof(BMP_FORMAT_10);
            format = INIT_FMT10_FMT;
            break;

        case INIT_COPY:
            padded_size = sizeof(BMP_FORMAT_11);
            format = INIT_FMT11_FMT;
            break;

        case INIT_RESTRICT_PROG:
            padded_size = sizeof(BMP_FORMAT_12);
            format = INIT_FMT12_FMT;
            break;

        case INIT_IO_RESTRICT_PROG:
            padded_size = sizeof(BMP_FORMAT_13);
            format = INIT_FMT13_FMT;
            break;

        case INIT_IO_RESTRICT_PLL:
            padded_size = sizeof(BMP_FORMAT_14);
            format = INIT_FMT14_FMT;
            break;

        case INIT_INDEX_ADDRESS_LATCHED:
            padded_size = sizeof(BMP_FORMAT_15);
            format = INIT_FMT15_FMT;
            break;
        
        default:
            // assume unknown opcodes are 1-byte instructions
            padded_size = sizeof(bios_U008);
            format = "b";
            break;
    }

    // now extract the instruction and convert it.
    rmStatus = BiosReadStructure(pDev,
                                 pInstruction,
                                 ip,
                                 pPackedSize,
                                 format);
    if (rmStatus != RM_OK)
        goto failed;

    // now find size of any 'extra' stuff that is part of this instruction...
    // we are not reading it in, just calculating its size

    switch (opcode)
    {
        case INIT_RESTRICT_PROG:
        {
            BMP_FORMAT_12 *bmp12 = pInstruction;
            count = bmp12->operand4;
            elementSize = 4;
            extra_packed_size = count * elementSize;
            break;
        }

        case INIT_IO_RESTRICT_PROG:
        {
            BMP_FORMAT_13 *bmp13 = pInstruction;
            count = bmp13->operand5;
            elementSize = 4;
            extra_packed_size = count * elementSize;
            break;
        }

        case INIT_IO_RESTRICT_PLL:
        {
            BMP_FORMAT_14 *bmp14 = pInstruction;
            count = bmp14->operand6;
            elementSize = 2;
            extra_packed_size = count * elementSize;
            break;
        }

        case INIT_INDEX_ADDRESS_LATCHED:
        {
            BMP_FORMAT_15 *bmp15 = pInstruction;
            count = bmp15->operand5;
            elementSize = 2;
            extra_packed_size = count * elementSize;
            break;
        }

        default:
            extra_packed_size = 0;
            break;
    }

    *pExtraPackedSize = extra_packed_size;

    // return actual opcode
    if (rmStatus == RM_OK)
        return opcode;

 failed:
    // Error path
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: error in DevinitFetchInstruction\n");
    return 0;             // bad opcode

} // end of DevinitFetchInstruction()


// ***** SCRIPT INSTRUCTION IMPLEMENTATION *****

// NV register initialization
RM_STATUS init_NV
(
    PHWINFO pDev,
    U032 reg,
    U032 mask,
    U032 data,
    BOOL conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 value;

    // read, modify, and rewrite the value
    if (conditionFlag)
    {
        value = REG_RD32(reg);
        value = (value & mask) | data;
        REG_WR32(reg, value);
    }

    return rmStatus;

} // end of init_NV()

// NV PLL initialization
RM_STATUS init_PLL_Values
(
    PHWINFO pDev,
    U032 reg,
    U032 MhzX100,
    BOOL conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;

    if (conditionFlag)
    {
        // program the proper clock using the RM kernel
        switch (reg)
        {
            case NV_PRAMDAC_NVPLL_COEFF:
                pDev->Dac.HalInfo.NVClk = MhzX100 * 10000;
                rmStatus = dacProgramNVClk(pDev);
                break;
            
            case NV_PRAMDAC_MPLL_COEFF:
                pDev->Dac.HalInfo.MClk = MhzX100 * 10000;
                rmStatus = dacProgramMClk(pDev, 0);
                break;
            
            case NV_PRAMDAC_VPLL_COEFF:
                rmStatus = dacProgramPClk(pDev, 0, MhzX100);
                break;
            
            default:
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Cannot program unknown clock\n");
                rmStatus = RM_ERROR;
                break;
        }
    }    

    return rmStatus;

} // end of init_PLL_Values()

// initialization time delay
RM_STATUS init_TIME_Delay
(
    PHWINFO pDev,
    U032 uSec
)
{
    return osDelayUs(uSec);

} // end of init_TIME_Delay()

// indexed I/O Register initialization
RM_STATUS init_INDEX_IO_Write
(
    PHWINFO pDev,
    U032 port,
    U032 index,
    U032 mask,
    U032 data,
    BOOL conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U008 value;

    if (conditionFlag)
    {
        // read, modify, and write the value
        rmStatus = DevinitReadPort(pDev, port, index, &value);
        if (rmStatus == RM_OK)
        {
            value = (value & (U008) mask) | (U008) data;
            rmStatus = DevinitWritePort(pDev, port, index, value);
        }
    }

    return rmStatus;

} // end of init_INDEX_IO_Write()

//  inhibit processing based on memory size
RM_STATUS init_MEM_RESTRICT_SCRIPT
(
    PHWINFO pDev,
    U032 mask,
    U032 value,
    BOOL* pConditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;

    if ((REG_RD32(NV_PFB_BOOT_0) & mask) != value)
    {
        *pConditionFlag = FALSE;
    }

    return rmStatus;

} // end of init_MEM_RESTRICT_SCRIPT()

//  inhibit processing based on strapping
RM_STATUS init_STRAP_RESTRICT_SCRIPT
(
    PHWINFO pDev,
    U032 mask,
    U032 value,
    BOOL* pConditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;

    if ((REG_RD32(NV_PEXTDEV_BOOT_0) & mask) != value)
    {
        *pConditionFlag = FALSE;
    }

    return rmStatus;

} // end of init_STRAP_RESTRICT_SCRIPT()

RM_STATUS init_CONFIGURE_Clocks
(
    PHWINFO pDev,
    VOID* memInitTable
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (REG_RD32(NV_PBUS_PCI_NV_0) >> 16 & 0x0000ffff)
    {
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID3:
            rmStatus = Nv10MemConfigureClocks(pDev, (MEM_INIT_VALS_NV10*)memInitTable);
            break;

        default:
            rmStatus = Nv15MemConfigureClocks(pDev, (MEM_INIT_VALS_NV15*)memInitTable);
            break;
    }

    return rmStatus;

} // end of init_CONFIGURE_Clocks()

// configure the device memory
RM_STATUS init_CONFIGURE_Memory
(
    PHWINFO pDev,
    VOID* memInitTable,
    U032 SDRSeqTable[],
    U032 DDRSeqTable[]
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (REG_RD32(NV_PBUS_PCI_NV_0) >> 16 & 0x0000ffff)
    {
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID3:
            rmStatus = Nv10MemConfigureMemory(pDev, (MEM_INIT_VALS_NV10*)memInitTable, SDRSeqTable, DDRSeqTable);
            break;

        default:
            rmStatus = Nv15MemConfigureMemory(pDev, (MEM_INIT_VALS_NV15*)memInitTable, SDRSeqTable, DDRSeqTable);
            break;
    }

    return rmStatus;

} // end of init_CONFIGURE_Memory()

// configure RAM type and specifiers
RM_STATUS init_CONFIGURE_PreInit
(
    PHWINFO pDev
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (REG_RD32(NV_PBUS_PCI_NV_0) >> 16 & 0x0000ffff)
    {
        default:
            rmStatus = Nv10MemChipPreInit(pDev);
            break;
    }

    return rmStatus;

} // end of init_CONFIGURE_PreInit()

// compute the memory size of the device
RM_STATUS init_COMPUTE_Memory
(
    PHWINFO pDev
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (REG_RD32(NV_PBUS_PCI_NV_0) >> 16 & 0x0000ffff)
    {
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV04:
            rmStatus = Nv04MemResizeMemory(pDev);
            break;

        // TO DO: modify NV5 memory resizing to use data from the BIOS instead of static data
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID3:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID3:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID3:
            rmStatus = Nv05MemResizeMemory(pDev);
            break;

        default:
            rmStatus = Nv10MemComputeMemory(pDev);
            break;
    }

    return rmStatus;

} // end of init_COMPUTE_Memory()

// reset the device
RM_STATUS init_Reset_Chip
(
    PHWINFO pDev,
    U032 reg,
    U032 enginesOff,
    U032 enginesOn
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 saveValue;

    // save and toggle the AGP command register (don't disturb the FW enable)
    saveValue = REG_RD32(NV_PBUS_PCI_NV_19);
    REG_WR32(NV_PBUS_PCI_NV_19,
             (saveValue & ~(DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _ON) |
                            DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_AGP_ENABLE, _ON))));

    // write out engines to turn off and on
    REG_WR32(reg, enginesOff);
    REG_WR32(reg, enginesOn);

    // restore AGP command register
    REG_WR32(NV_PBUS_PCI_NV_19, saveValue);

    // set access to the ROM thru instance mem
    FLD_WR_DRF_DEF(_PBUS,_PCI_NV_20,_ROM_SHADOW,_DISABLED);

    return rmStatus;

} // end of init_Reset_Chip()

RM_STATUS init_IO
(
    PHWINFO pDev,
    U032 port,
    U032 mask,
    U032 data,
    BOOL conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 reg, value;

    if (conditionFlag)
    {
        // convert the CRTC port into a priv register
        rmStatus = DevinitPortToPrivReg(port, &reg);
        if (rmStatus == RM_OK)
        {
            // read, modify, and rewrite the value
            value = REG_RD32(reg);
            value = (value & mask) | data;
            REG_WR32(reg, value);
        }
    }

    return rmStatus;

} // end of init_IO()

// set the condition flag based on the results of the given condition
RM_STATUS init_Condition
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               conditionId,
    BOOL              *pConditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 reg;
    U032 mask;
    U032 comparison;
    U032 value;
    CONDITION_ENTRY *pCondEntry;

    if (conditionId != NO_CONDITION)
    {
        // grab out our fields
        pCondEntry = &cp->tables->conditionTable[conditionId];
        reg         = pCondEntry->condAddress;
        mask        = pCondEntry->condMask;
        comparison  = pCondEntry->condCompare;

        // read, modify, reset condition flag on miscompare
        value = REG_RD32(reg);
        value = value & mask;
        if (value != comparison)
        {
            *pConditionFlag = FALSE;
        }
    }    

    return rmStatus;

} // end of init_Condition()

RM_STATUS init_IoCondition
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               conditionId,
    BOOL              *pConditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 port;
    U032 index, mask, comparison;
    U008 value;
    IO_CONDITION_ENTRY* pCondition;

    // modify the flag only if there is a valid condition
    if (conditionId != NO_CONDITION)
    {
        // grab out our fields
        pCondition = &cp->tables->ioConditionTable[conditionId];
        port        = pCondition->iocondPort;
        index       = pCondition->iocondIndex;
        mask        = pCondition->iocondMask;
        comparison  = pCondition->iocondCompare;

        // read, modify, reset condition flag on miscompare
        rmStatus = DevinitReadPort(pDev, port, index, &value);
        if (rmStatus == RM_OK)
        {
            value = value & (U008) mask;
            if (value != (U008) comparison)
            {
                *pConditionFlag = FALSE;
            }
        }
    }    

    return rmStatus;

} // end of init_IoCondition()

// set a flag based on the results of the given I/O flag condition
RM_STATUS init_IoFlagCondition
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               conditionId,
    BOOL              *pFlag
)
{
    U032 port;
    U032 index;
    U032 mask;
    U032 shift;
    U032 flagArrayOffset;
    U032 flag;
    U032 flagMask;
    U032 comparison;
    U008 flagIndex;
    IO_FLAG_CONDITION_ENTRY *pIoFlagCondEntry;
    RM_STATUS rmStatus = RM_OK;

    // set the flag if there is a valid condition
    if (conditionId != NO_CONDITION)
    {
        // init to TRUE
        *pFlag = TRUE;

        // grab our fields..
        pIoFlagCondEntry = &cp->tables->ioFlagConditionTable[conditionId];
        port            = pIoFlagCondEntry->iofcondPort;
        index           = pIoFlagCondEntry->iofcondIndex;
        mask            = pIoFlagCondEntry->iofcondMask;
        shift           = pIoFlagCondEntry->iofcondShift;
        flagArrayOffset = pIoFlagCondEntry->iofcondFlagArray;
        flagMask        = pIoFlagCondEntry->iofcondFlagMask;
        comparison      = pIoFlagCondEntry->iofcondFlagCompare;

        // read, modify, reset condition flag on miscompare
        rmStatus = DevinitReadPort(pDev, port, index, &flagIndex);
        if (rmStatus == RM_OK)
        {
            // set the flag based on the contents the flag array contents
            flagIndex = (flagIndex & (U008) mask) >> shift;
            flag = BiosRead8(pDev, flagArrayOffset + flagIndex);
            flag = flag & flagMask;
            if (flag != comparison)
            {
                *pFlag = FALSE;
            }
        }
    }

    return rmStatus;

} // end of init_IoFlagCondition()

RM_STATUS init_RestrictProg
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               indexReg,
    U032               mask,
    U032               shift,
    U032               dataTableSize,
    U032               reg,
    U032               dataTableOffset,
    BOOL               conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 dataIndex, data;

    // only perform the instruction if the condition flag is TRUE and the register is defined, i.e. not 0
    if (conditionFlag && reg)
    {
        // get the index of the data table
        dataIndex = REG_RD32(indexReg);

        // write the register from the data table
        dataIndex = (dataIndex & mask) >> shift;
        if (dataIndex >= dataTableSize)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: range check failure in init_IoRestrictProg\n");
            rmStatus = RM_ERROR;
        }
        else
        {
            data = BiosRead32(pDev, dataTableOffset + (dataIndex * sizeof(U032)));
            REG_WR32(reg, data);
        }
    }

    return rmStatus;

} // end of init_RestrictProg()

RM_STATUS init_IoRestrictProg
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               port,
    U032               index,
    U032               mask,
    U032               shift,
    U032               dataTableSize,
    U032               reg,
    U032               dataTableOffset,
    BOOL               conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U008 dataIndex;

    // only perform the instruction if the condition flag is TRUE and
    //   the register is defined, i.e. not 0
    if (conditionFlag && reg)
    {
        // get the index of the data table
        rmStatus = DevinitReadPort(pDev, port, index, &dataIndex);

        if (rmStatus == RM_OK)
        {
            U032 word32;

            // write the register from the data table
            dataIndex = (dataIndex & (U008) mask) >> shift;
            if (dataIndex >= dataTableSize)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: range check failure in init_IoRestrictProg\n");
                rmStatus = RM_ERROR;
            }
            else
            {
                word32 = BiosRead32(pDev, dataTableOffset + (dataIndex * sizeof(U032)));
                REG_WR32(reg, word32);
            }
        }
    }

    return rmStatus;

} // end of init_IoRestrictProg()

RM_STATUS init_IoRestrictPll
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               port,
    U032               index,
    U032               mask,
    U032               shift,
    U032               doubleFlagCondition,
    U032               freqTableSize,
    U032               pllReg,
    U032               freqTableOffset,
    BOOL               conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U008 freqIndex;
    BOOL doubleFlag = FALSE;
    U032 freq;

    // only perform the instruction if the condition flag is TRUE and the
    //   register is defined, i.e. not 0

    if (conditionFlag && pllReg)
    {
        // get the index of the frequency table
        rmStatus = DevinitReadPort(pDev, port, index, &freqIndex);
        if (rmStatus == RM_OK)
        {
            // program the PLL register from the frequency table
            freqIndex = (freqIndex & (U008) mask) >> shift;
            init_IoFlagCondition(pDev, cp, doubleFlagCondition, &doubleFlag);
            if (freqIndex >= freqTableSize)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: range check failure in init_IoRestrictPll\n");
                rmStatus = RM_ERROR;
            }
            else
            {
                freq = BiosRead16(pDev, freqTableOffset + (freqIndex * 2));
                freq = (doubleFlag) ? freq * 2 : freq;
                rmStatus = init_PLL_Values(pDev, pllReg, freq, conditionFlag);
            }
        }
    }

    return rmStatus;

} // end of init_IoRestrictPll()

RM_STATUS init_IndexAddressLatched
(
    PHWINFO pDev,
    U032    controlReg,
    U032    dataReg,
    U032    mask,
    U032    writeOr,
    U032    dataTableSize,
    U032    dataTableOffset,
    BOOL    conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;

    // only perform the instruction if the condition flag is TRUE and
    //  the register is defined, i.e. not 0
    if (conditionFlag && (dataReg != 0))
    {
        U032 i;

        for ( i = 0; i < dataTableSize; i++ )
        {
            U032 index;
            U032 dataValue;
            U032 controlValue;

            index = BiosRead8(pDev, dataTableOffset + (i * 2));
            dataValue = BiosRead8(pDev, dataTableOffset + (i * 2) + 1);

            REG_WR32( dataReg, dataValue );

            controlValue = REG_RD32( controlReg );
            controlValue &= mask;
            controlValue |= writeOr;
            controlValue |= index;

            REG_WR32( controlReg, controlValue );
        }
    }    
    
    return rmStatus;

} // end of init_IndexAddressLatched()


RM_STATUS init_Sub
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               scriptIndex,
    BOOL               conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 scriptOffset;
    
    if (conditionFlag)
    {
        scriptOffset = BiosRead16(pDev, cp->scriptTableOffset + (scriptIndex * 2));
        if (scriptOffset != SCRIPT_TERMINATE)
        {
            // interpret the script at the script's offset into the BIP code
            DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: interpreting sub script...\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   script table index: ", scriptIndex);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   script offset:      ", scriptOffset);
            rmStatus = DevinitInterpretBIP3Script(pDev, cp, scriptOffset);
            if (rmStatus != RM_OK)
            {
                DBG_PRINT_STRING      (DEBUGLEVEL_ERRORS, "NVRM: could not interpret sub script...\n");
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:   script table index: ", scriptIndex);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:   script offset:      ", scriptOffset);
            }
        }
    }    
    
    return rmStatus;

} // end of init_Sub()

RM_STATUS init_Macro
(
    PHWINFO            pDev,
    EXECUTION_CONTEXT *cp,
    U032               macroId,
    BOOL               conditionFlag
)
{
    RM_STATUS           rmStatus = RM_OK;
    MACRO_ENTRY        *pMacro;
    U032                macroCount;
    U032                i, reg, data;
    MACRO_INDEX_ENTRY  *pMacroIndexEntry;

    if (conditionFlag)
    {
        pMacroIndexEntry = &cp->tables->macroIndexTable[macroId];

        macroCount = pMacroIndexEntry->macroCount;
        pMacro = &cp->tables->macroTable[pMacroIndexEntry->macroIndex];

        // perform the set of register writes defined in the macro
        for (i = 0; i < macroCount; i++)
        {
            reg = pMacro[i].macroAddress;
            data = pMacro[i].macroValue;
            REG_WR32(reg, data);
        }
    }

    return rmStatus;

} // end of init_Macro()

RM_STATUS init_ZM_IO
(
    PHWINFO pDev,
    U032 port,
    U032 value,
    BOOL conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 reg;

    if (conditionFlag)
    {
        // convert the CRTC port into a priv register
        rmStatus = DevinitPortToPrivReg(port, &reg);
        if (rmStatus == RM_OK)
        {
            // write the value
            REG_WR32(reg, value);
        }
    }

    return rmStatus;

} // end of init_ZM_IO()

RM_STATUS init_Copy
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               srcReg,
    S008               srcShift,
    U032               srcMask,
    U032               port,
    U032               index,
    U032               destMask,
    BOOL               conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 srcValue;
    U032 value;
    U008 destValue;

    if (conditionFlag)
    {
        srcValue = REG_RD32(srcReg);
        if (srcShift >= 0)
        {
            srcValue >>= srcShift;
        }
        else
        {
            srcValue <<= -srcShift;
        }
        value = srcValue & srcMask;
        rmStatus = DevinitReadPort(pDev, port, index, &destValue);
        if (rmStatus == RM_OK)
        {
            destValue = (destValue & (U008) destMask) | (U008) value;
            rmStatus = DevinitWritePort(pDev, port, index, destValue);
        }
    }

    return rmStatus;

} // end of init_Copy()

RM_STATUS init_Repeat
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               ip,
    U032               loopCount
)
{
    RM_STATUS rmStatus = RM_OK;

    // setup the loop stack to contain the loop offset and the current loop count
    DevinitStackPush(&cp->loopStack, ip);
    DevinitStackPush(&cp->loopStack, loopCount);
    
    return rmStatus;

} // end of init_Repeat()

RM_STATUS init_EndRepeat
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032*              pip
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 count;

    // pop the current loop count from the loop stack and decrement it
    count = DevinitStackPop(&cp->loopStack);
    if (--count > 0)
    {
        // continue looping -- adjust offset to the top of the loop and push the counter back on
        *pip = DevinitStackTop(&cp->loopStack);
        DevinitStackPush(&cp->loopStack, count);
    }
    else
    {
        // terminate looping -- clear the rest of loop stack and go on to the next instruction
        (VOID)DevinitStackPop(&cp->loopStack);
    }
    
    return rmStatus;

} // end of init_EndRepeat()

RM_STATUS init_Function
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               functionIndex
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 functionId;

    // call the HAL to execute this "escape" function
    functionId = cp->tables->functionTable[functionIndex];
    // HalExecuteFunction(functionId);

    return rmStatus;

} // end of init_Function()

VOID DevinitMeminitFormat
(
    PHWINFO   pDev,
    char    **fmt,
    int      *padded_size
)
{
    U032 value;

    value = REG_RD32(NV_PBUS_PCI_NV_0);
    value >>= 16;
    value &= 0xffff;

    switch (value)
    {
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID3:
            *padded_size = sizeof(MEM_INIT_VALS_NV10);
            *fmt = MEM_INIT_VALS_NV10_FMT;
            break;

        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID3:

        default:

            *padded_size = sizeof(MEM_INIT_VALS_NV15);
            *fmt = MEM_INIT_VALS_NV15_FMT;
            break;
    }
}

RM_STATUS DevinitReadPort
(
    PHWINFO pDev,
    U032    port,
    U032    index,
    U008   *pValue
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 privReg;
    U008 prevIndex;

    // convert the CRTC port into a priv register
    rmStatus = DevinitPortToPrivReg(port, &privReg);
    if (rmStatus == RM_OK)
    {
        // save the old index
        prevIndex = REG_RD08(privReg);

        // read the value
        REG_WR08(privReg, index);
        *pValue = REG_RD08(privReg + 1);

        // restore the old index
        REG_WR08(privReg, prevIndex);
    }

    return rmStatus;

} // end of DevinitReadPort()

RM_STATUS DevinitWritePort
(
    PHWINFO pDev,
    U032 port,
    U032 index,
    U032 value
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 privReg;
    U008 prevIndex;

    // convert the CRTC port into a priv register
    rmStatus = DevinitPortToPrivReg(port, &privReg);
    if (rmStatus == RM_OK)
    {
        // save the old index
        prevIndex = REG_RD08(privReg);

        // write the value
        REG_WR08(privReg, index);
        REG_WR08(privReg + 1, value);

        // restore the old index
        REG_WR08(privReg, prevIndex);
    }

    return rmStatus;

} // end of DevinitWritePort()

RM_STATUS DevinitPortToPrivReg
(
    U032 crtcReg, 
    U032* pPrivReg
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (crtcReg)
    {
        case CRTC_INDEX_MONO:
        case CRTC_INDEX_COLOR:
        case ATC_INDEX:
        //...
            *pPrivReg = DEVICE_BASE(NV_PRMCIO) + crtcReg;
            break;

        case SEQ_INDEX:
        case GDC_INDEX:
        //...
            *pPrivReg = DEVICE_BASE(NV_PRMVIO) + crtcReg;
            break;

        default:
            rmStatus = RM_ERROR;
            break;
    }

    return rmStatus;

} // end of DevinitPortToPrivReg()

VOID DevinitStackPush
(
    PDEVINIT_STACK pStack,
    U032 value
)
{
    if (pStack->sp < DEVINIT_STACK_MAX)
    {
        (*pStack).body[++pStack->sp] = value;
#if defined(UNIX) && defined(IA64)
        __asm__ volatile("mf.a;;");
#endif
    }

} // end of DevinitStackPush()

U032 DevinitStackPop
(
    PDEVINIT_STACK pStack
)
{
    if (pStack->sp > 0)
    {
        return (*pStack).body[pStack->sp--];
    }

    // on stack underflow, return 0
    return 0;

} // end of DevinitStackPop()

U032 DevinitStackTop
(
    PDEVINIT_STACK pStack
)
{
    return (*pStack).body[pStack->sp];

} // end of DevinitStackTop()

RM_STATUS DevinitShadowBios
(
    PHWINFO pDev,
    PHWREG  externalBiosImage
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWREG tempBiosAddr;
    U032 i;

    if (externalBiosImage)
    {
        // setup for ROM reads
        tempBiosAddr = biosAddr;
        biosAddr = externalBiosImage;

        // copy the BIOS image into upper instance memory
        for (i = 0; i < BIOS_ROM_CODE_SIZE; i++)
        {
            REG_WR08(pDev->Pram.HalInfo.PraminOffset + i, BIOS_RD08(i));
        }

        // restore original biosAddr
        biosAddr = tempBiosAddr;
    }
    else
    {
        rmStatus = RM_ERROR;
    }

    return rmStatus;

} // end of DevinitShadowBios()

// extract the FminVCO/FmaxVCO values from the BIOS, if available
RM_STATUS DevinitGetMinMaxVCOValues
(
    PHWINFO    pDev,
    U032       *FminVCO,
    U032       *FmaxVCO
)
{
    RM_STATUS rmStatus = RM_OK;
    BMP_Control_Block bmpCtrlBlk;
    U032 offset;

    *FminVCO = *FmaxVCO = 0x0;

    // determine if we've got the correct BIOS rev
    rmStatus = DevinitGetBMPControlBlock(pDev, &bmpCtrlBlk, &offset);
    if (rmStatus != RM_OK)
        return rmStatus;

    if (bmpCtrlBlk.CTL_Version == BMP_INIT_TABLE_VER_5)
    {
        // FminVCO/FmaxVCO are only available in BMP 0x05.0x10 or greater
        if (bmpCtrlBlk.CTL_Flags < 0x10)
            return RM_ERROR;

        switch (bmpCtrlBlk.CTL_Flags)
        {
            // Version 0x10 did not have TMDS tables
            case 0x10:
            {
                BMP_Struc_Rev5_0x10 bmpInitTable;
                BiosReadStructure(pDev,
                                  &bmpInitTable,
                                  offset,
                                  (U032 *) 0,
                                  BMP_INIT5_0x10_FMT);

                *FminVCO = bmpInitTable.BMP_FminVco;
                *FmaxVCO = bmpInitTable.BMP_FmaxVco;
                rmStatus = RM_OK;
                break;
            }

            // default is BIP/3 BMP init table version 5, subversion 0x11 base-level functionality or above
            default:
            {
                BMP_Struc_Rev5_0x11 bmpInitTable;
                BiosReadStructure(pDev,
                                  &bmpInitTable,
                                  offset,
                                  (U032 *) 0,
                                  BMP_INIT5_0x11_FMT);

                *FminVCO = bmpInitTable.BMP_FminVco;
                *FmaxVCO = bmpInitTable.BMP_FmaxVco;
                rmStatus = RM_OK;
                break;
            }
        }
    }
    else
        rmStatus = RM_ERROR;

    return rmStatus;

} // end of DevinitGetGetMinMaxVCOValues()

// extract the flat panel flags byte for a given strap value
RM_STATUS DevinitGetFlatPanelFlags
(
    PHWINFO pDev,
    U032 panelStrap,
    U008* panelFlags
)
{
    RM_STATUS rmStatus = RM_OK;
    BMP_Control_Block bmpCtrlBlk;
    U032 offset;

    *panelFlags = 0;

    // Strap needs to be between 0 and 15
    if ( panelStrap >= MAX_FP_STRAPS )
    {
        return RM_ERROR;
    }

    // determine if we've got the correct BIOS rev
    rmStatus = DevinitGetBMPControlBlock(pDev, &bmpCtrlBlk, &offset);
    if (rmStatus != RM_OK)
        return rmStatus;

    if ( ( bmpCtrlBlk.CTL_Version == BMP_INIT_TABLE_VER_5 ) && ( bmpCtrlBlk.CTL_Flags >= 0x12 ) )
    {
        // default is BIP/3 BMP init table version 5, subversion 0x12 base-level functionality or above
        BMP_Struc_Rev5_0x12 bmpInitTable;
        rmStatus = BiosReadStructure
            (
                pDev,
                &bmpInitTable,
                offset,
                (U032 *) 0,
                BMP_INIT5_0x12_FMT
            );

        if ( rmStatus == RM_OK )
        {
            U008 panelFlagArray[ SIZE_FP_XLATE_FLAG_TABLE ];

            rmStatus = BiosReadBytes
            (
                pDev,
                panelFlagArray,
                bmpInitTable.BMP_FPXlateTablePtr + SIZE_FP_XLATE_TABLE,  // 16 is size of 
                sizeof( panelFlagArray ) // Size of FP_Xlate_Table and FP_Xlate_Flag_Table
            );

            if ( rmStatus == RM_OK )
            {
                *panelFlags = panelFlagArray[ panelStrap ];
            }
        }

    }
    else
    {
        rmStatus = RM_ERROR;
    }

    return rmStatus;

} // end of DevinitGetFlatPanelFlags()


// extract the flat panel flags byte for a given strap value
RM_STATUS DevinitGetManufacturerInfo
(
    PHWINFO pDev
)
{
  RM_STATUS rmStatus = RM_OK;
  BMP_Control_Block bmpCtrlBlk;
  U032 offset;
  U032 panelStrap = pDev->Dac.PanelStrap; // initialized in dacInitPanelStrap() 
                                          // called by initDac() or edidConstructMobileInfo()

  // If we've already tested this, and it doesn't work,
  // there's no need to test it again.
  if(pDev->Dac.ManufacturerProperties.Version == MANUFACTURER_NOT_CAPABLE)
    return RM_ERROR;

  // If we've already found the indexes, then return
  if(pDev->Dac.ManufacturerProperties.Version != MANUFACTURER_NOT_TESTED)
    return RM_OK;

  // Strap needs to be between 0 and 15
  if ( panelStrap >= MAX_FP_STRAPS )
  {
      return RM_ERROR;
  }

  // determine if we've got the correct BIOS rev
  rmStatus = DevinitGetBMPControlBlock(pDev, &bmpCtrlBlk, &offset);
  if (rmStatus != RM_OK)
      return rmStatus;

  // Manufacturer BIOSes only work with Control Blocks higher than or equal to 5.14
  if ( ( bmpCtrlBlk.CTL_Version == BMP_INIT_TABLE_VER_5 ) && ( bmpCtrlBlk.CTL_Flags >= 0x14 ) )
  {
      // default is BIP/3 BMP init table version 5, subversion 0x14 base-level functionality or above
      // Read the init table to get the pointers
      BMP_Struc_Rev5_0x14 bmpInitTable;
      rmStatus = BiosReadStructure(pDev, &bmpInitTable, offset, (U032 *) 0,BMP_INIT5_0x14_FMT);

      if ( rmStatus == RM_OK )
      {
          U008 panelManufacturerXlateArray[ SIZE_FP_XLATE_MANUFACTURER_TABLE ];

          // Read the Manufacturer Translation table - translates bootstrap to manufacturer entry index in table
          rmStatus = BiosReadBytes(pDev, panelManufacturerXlateArray, 
                                   bmpInitTable.BMP_FPXlateManufacturerTablePtr,
                                   sizeof( panelManufacturerXlateArray ) );

          if ( rmStatus == RM_OK )
          {
              PANEL_MANUFACTURER_TABLE_HEADER panelMTHeader;
              U032 panelMTHeaderPackedSize = 0;
              
              // We have a valid index into the Manufacturer's table
              // First let's get the header to determine the size of each entry.
              rmStatus = BiosReadStructure(pDev, &panelMTHeader, 
                                           bmpInitTable.BMP_LVDSManufacturerPtr,
                                           (U032 *) &panelMTHeaderPackedSize,
                                           INIT_MANUFACTURER_TABLE_HEADER_FORMAT);

              if( rmStatus == RM_OK)
              {
                  // Finally read the Manufacturer's Entry
                  switch(panelMTHeader.Version)
                  {
                  case 10:
                    {
                      PANEL_MANUFACTURER_TABLE_ENTRY_VER10 panelMTEntry;
    
                      rmStatus = BiosReadStructure(pDev, &panelMTEntry,
                                                   bmpInitTable.BMP_LVDSManufacturerPtr + 
                                                   panelMTHeaderPackedSize +
                                                   panelMTHeader.EntrySize * 
                                                   panelManufacturerXlateArray[ panelStrap ],
                                                   (U032 *) 0, 
                                                   INIT_MANUFACTURER_TABLE_ENTRY_VER10_FORMAT);
    
                      if(rmStatus == RM_OK)
                      {
                        // Save the information that we want.
                        pDev->Dac.ManufacturerProperties.Version            = panelMTHeader.Version;
                        pDev->Dac.ManufacturerProperties.Size               = panelMTHeader.EntrySize;
                        pDev->Dac.ManufacturerProperties.Flags              = panelMTEntry.Flags;
                        pDev->Dac.ManufacturerProperties.LVDSInitScript     = panelMTEntry.LVDSInitScript;
                        pDev->Dac.ManufacturerProperties.LVDSResetScript    = panelMTEntry.LVDSResetScript;
                        pDev->Dac.ManufacturerProperties.BackLightOnScript  = panelMTEntry.BackLightOnScript;
                        pDev->Dac.ManufacturerProperties.BackLightOffScript = panelMTEntry.BackLightOffScript;
                        pDev->Dac.ManufacturerProperties.PanelOnScript      = panelMTEntry.PanelOnScript;
                        pDev->Dac.ManufacturerProperties.PanelOffScript     = panelMTEntry.PanelOffScript;
                        pDev->Dac.ManufacturerProperties.PanelOffOnDelay    = panelMTEntry.PanelOffOnDelay;
    
                      }
                      break;
                    }
                  default:
                      // Unknown entry version!
                      pDev->Dac.ManufacturerProperties.Version = MANUFACTURER_NOT_CAPABLE;
                      return RM_ERROR;
                  }
              }
          }
      }

  }
  else
  {
      rmStatus = RM_ERROR;
  }

  if(rmStatus != RM_OK)
  {
      pDev->Dac.ManufacturerProperties.Version = MANUFACTURER_NOT_CAPABLE;
  }

  return rmStatus;

}


// extract the flat panel flags byte for a given strap value
RM_STATUS DevinitRunManufacturerScript
(
    PHWINFO pDev,
    U032 MScript
)
{
  RM_STATUS rmStatus = RM_OK;
  BMP_Control_Block bmpCtrlBlk;
  U032 offset;
  BMP_Struc_Rev5_0x14 bmpInitTable;
  U032 scriptIndex;
  U032 currentScriptOffset;
  EXECUTION_CONTEXT context;

  // If this BIOS is not capable of running these scripts, error out
  if(pDev->Dac.ManufacturerProperties.Version == MANUFACTURER_NOT_CAPABLE)
    return RM_ERROR;

  // If we've already found the indexes, then return error
  // You must call DevinitGetManufacturerInfo() before this function.
  if(pDev->Dac.ManufacturerProperties.Version == MANUFACTURER_NOT_TESTED)
  {
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Call DevinitGetManufacturerInfo() before DevinitRunManufacturerScript()\n");
    return RM_ERROR;
  }

  // Get the header block
  rmStatus = DevinitGetBMPControlBlock(pDev, &bmpCtrlBlk, &offset);
  if (rmStatus != RM_OK)
      return rmStatus;

  // default is BIP/3 BMP init table version 5, subversion 0x14 base-level functionality or above
  rmStatus = BiosReadStructure(pDev, &bmpInitTable, offset, (U032 *) 0, BMP_INIT5_0x14_FMT);
  if (rmStatus != RM_OK)
      return rmStatus;

  // Figure out which script we're running
  switch(MScript)
  {
  case MSCRIPT_LVDS_INIT_SCRIPT:
    scriptIndex = pDev->Dac.ManufacturerProperties.LVDSInitScript;
    break;
  case MSCRIPT_LVDS_RESET_SCRIPT:
    scriptIndex = pDev->Dac.ManufacturerProperties.LVDSResetScript;
    break;
  case MSCRIPT_BACKLIGHT_ON:
    scriptIndex = pDev->Dac.ManufacturerProperties.BackLightOnScript;
    break;
  case MSCRIPT_BACKLIGHT_OFF:
    scriptIndex = pDev->Dac.ManufacturerProperties.BackLightOffScript;
    break;
  case MSCRIPT_PANEL_ON:
    scriptIndex = pDev->Dac.ManufacturerProperties.PanelOnScript;
    break;
  case MSCRIPT_PANEL_OFF:
    scriptIndex = pDev->Dac.ManufacturerProperties.PanelOffScript;
    break;
  default:
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: DevinitRunManufacturerScript passed invalid MScript\n");
    return RM_ERROR;
    break;
  }

  // initialize execution context
  context.conditionFlag = TRUE;
  context.loopStack.sp = 0;

  // get all table offsets
  // rmStatus = DevinitGetBIP3TableOffsets(pDev, &context);
  context.scriptTableOffset          = bmpInitTable.BMP_InitScriptTablePtr;
  context.macroIndexTableOffset      = bmpInitTable.BMP_MacroIndexTablePtr;
  context.macroTableOffset           = bmpInitTable.BMP_MacroTablePtr;
  context.conditionTableOffset       = bmpInitTable.BMP_ConditionTablePtr;
  context.ioConditionTableOffset     = bmpInitTable.BMP_IOConditionTablePtr;
  context.ioFlagConditionTableOffset = bmpInitTable.BMP_IOFlagConditionTablePtr;
  context.functionTableOffset        = bmpInitTable.BMP_InitFunctionTablePtr;

  context.TMDSSingleAOffset          = bmpInitTable.BMP_TMDSSingleAPtr;
  context.TMDSSingleBOffset          = bmpInitTable.BMP_TMDSSingleBPtr;
  context.TMDSDualOffset             = bmpInitTable.BMP_TMDSDualPtr;   
  context.LVDSSingleAOffset          = bmpInitTable.BMP_LVDSSingleAPtr;
  context.LVDSSingleBOffset          = bmpInitTable.BMP_LVDSSingleBPtr;
  context.LVDSDualOffset             = bmpInitTable.BMP_LVDSDualPtr;   
  context.OffSingleAOffset           = bmpInitTable.BMP_OffSingleAPtr; 
  context.OffSingleBOffset           = bmpInitTable.BMP_OffSingleBPtr; 

  // interpret the script in the script table at the given index
  currentScriptOffset = BiosRead16(pDev, context.scriptTableOffset + (scriptIndex*2));

  // Don't run NULL pointers
  if(currentScriptOffset)
    rmStatus = DevinitInterpretBIP3Script(pDev, &context, currentScriptOffset);
  
  return rmStatus;
}



// end of devinit.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\devinit\nv\nv05mem.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************************************************************************************************
*
*	Module: nv05mem.c
*
*	Description:
*		Device-specific memory sizing code, for NV5.
*
*	Revision History:
*		Original -- 5/99 Jeff Westerinen
*
**************************************************************************************************************/

#ifdef NV_PORTABLE

/* "portable" form for use outside resman and by external source customers */
/* look in devinit/portable/ for more details */
#include <nv_portable.h>
#include <nv_ref.h>
#include <nv4_ref.h>
#include <devinit.h>

#else	/* not NV_PORTABLE --> Nvidia internal */

#include <nvrm.h>
#include <nvhw.h>
#include <nv4_ref.h>
#include <os.h>
#include <devinit.h>

#endif

extern bmpMemInitData Nv05_bmp_MemInitTbl[];
extern U032 Nv05_bmp_ScrambleTbl[];

RM_STATUS Nv05MemResizeMemory
(
    PHWINFO pDev
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 i, data;

	// TO DO: is this necessary?
    // turn on full CPU access
	//...
     
    /*
        ; For UMA mode, we don't configure the memory
        ;
        mov     esi,NV_PFB_BOOT_0
        NV_DOS_GET      esi             ; Get Memory Config register
        test    ah,01h                  ; Is bit 8 set?
        jnz     @Exit                   ; Yep - UMA is on! Nada to configure!
        ;
        ; For UMA mode above.
        ;
    */
    // only size memory if UMA is disabled
    if (REG_RD_DRF(_PFB,_BOOT_0,_UMA) == NV_PFB_BOOT_0_UMA_DISABLE)
    {
	    // enable refresh for memory sizing
        FLD_WR_DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED);

        // TO DO: remove this when KevinM says OK
        // scramble the RAM from the table
        for (i = 0; i < 8; i++)
        {
            REG_WR32(NV_PFB_SCRAMBLE(i), Nv05_bmp_ScrambleTbl[i]);
        }
    
        // configure memory type by way of straps as follows:
        //   1.  get the strapping value from NV_PEXTDEV_BOOT_0
        //   2.  use that value as an index into the memory init table
        //   3.  the first member of the selected table element configures NV_PFB_BOOT_0
        //   4.  the second member of the selected table element configures PFB_CONFIG_1
        i = REG_RD_DRF(_PEXTDEV,_BOOT_0,_STRAP_RAMCFG);
        data = (REG_RD32(NV_PFB_BOOT_0) & 0xFFFFFFC0) | Nv05_bmp_MemInitTbl[i].PFB_BOOT_0_value;
        REG_WR32(NV_PFB_BOOT_0, data);
    
        // scramble the RAM, if indicated
    /*    
            ; Here, look for need to scramble RAM
            test    cl,SCRAMBLE_RAM                 ; Bit says to scramble the RAM?
            jz      @no_scramble
    
            ; Scramble the RAM according to the RAM table defined
            ; earlier.
            ;
            mov     di, offset bmp_ScrambleTbl      ; Point at table of RAM values
            mov     esi,NV_PFB_SCRAMBLE_RAM_0       ; Get strapping bits
            mov     cx,8                            ; Do 8 locations
    @@: 
            mov     eax,cs:[di]                     ; Read value 1
            NV_DOS_PUT      esi                     ; Write it out
            add     di,4                            ; Next DWORD
            add     esi,4                           ; Next DWORD
            loop    @b        
                                  ; and loop again
            ; Enable the scramble
            mov     esi,NV_PFB_CONFIG_0             ; Access Scramble RAM
            NV_DOS_GET      esi        
            or      eax, NV_PFB_CONFIG_0_SCRAMBLE_ACTIVE
            NV_DOS_PUT      esi        
                   
    @no_scramble:
    */
        if (Nv05_bmp_MemInitTbl[i].PFB_CONFIG_1_value == SCRAMBLE_RAM)
        {
    // TO DO: enable this code when Kevin M says OK
    #if 0
            for (i = 0; i < 8; i++)
            {
                REG_WR32(NV_PFB_SCRAMBLE_RAM_0 + (i * 4), Nv05_bmp_ScrambleTbl[i]);
            }
    #endif    
            FLD_WR_DRF_DEF(_PFB,_CONFIG_0,_SCRAMBLE,_ACTIVE);
        }
      
        // toggle latency bit to latch in the config, as follows:
        //   1. Clear to CL=2 and the SPECIAL32 bit or default SPECIAL32 value
        //   2. Set back to CL=3 
    /*
            pop     ecx                             ; Get flags back
            and     cl,SPECIAL_32                   ; Keep only SPECIAL_32 bit
            shl     ecx,20                          ; put in proper bit location
        
            ; Toggle PFB_CONFIG_1 CAS latency bit to generate MRS cycle.
            mov     esi,NV_PFB_CONFIG_1             ; Get Config1 bits
            NV_DOS_GET      esi
        
            and     eax,0FF8FFFFEh                  ; Clear to CL=2 and the SPECIAL32 bit
            or      eax,ecx                         ; Or default SPECIAL32 value in.
            NV_DOS_PUT      esi                     ; Write it back out
        
            or      al,01h                          ; Set back to CL=3
            NV_DOS_PUT      esi                     ; Write it back out
    */
        data = (REG_RD32(NV_PFB_CONFIG_1) & 0xFF8FFFFE) | ((Nv05_bmp_MemInitTbl[i].PFB_CONFIG_1_value & SPECIAL_32) << 20);
        REG_WR32(NV_PFB_CONFIG_1, data);
        data |= 0x00000001;
        REG_WR32(NV_PFB_CONFIG_1, data);
    
        // check for RAM width as follows:
        //   1.  assume width is 128 bits
        //   2.  write out a 128 bit test data word
        //   3.  attempt to read lower word
        //   4.  if not successful, change bus width to 64 bits
        //   5.  otherwise, bus width remains at default of 128 bits
        for (i = 0; i < 4; i++)
        {
            FB_WR32(i * 4, 'NV5A');
        }    
        if (FB_RD16(0x0000000C) != '5A')
        {
            FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_WIDTH_128,_OFF);
        }
    
        // determine the memory size -- default amount is 32Meg
        if (REG_RD_DRF(_PFB,_BOOT_0,_RAM_AMOUNT) == NV_PFB_BOOT_0_RAM_AMOUNT_32MB)
        {
            // write at 16Meg+1 to determine 32 or 16 Meg
            FB_WR32(0x01000000, 'NV5B');
            if (FB_RD32(0x01000000) == 'NV5B')
            {
                // read at 0 to determine if it wrapped on VANTA
                FB_WR32(0x00000000, 'A5VN');
                if (FB_RD32(0x00000000) != 'A5VN')
                {
                    // 16MB detected, so change config
                    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_16MB);
                }
            }
            else
            {
                // 16MB detected, so change config
                FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_16MB);
            }
        }
        else
        {
            // test for 16 Meg
            if (REG_RD_DRF(_PFB,_BOOT_0,_RAM_AMOUNT) == NV_PFB_BOOT_0_RAM_AMOUNT_16MB)
            {
                // write at 8Meg+1 to determine 16Meg or less
                FB_WR32(0x00800000, 'NV5C');
                if (FB_RD32(0x00800000) != 'NV5C')
                {
                    // write at 4Meg+1 to determine 8 or 4 Meg
                    FB_WR32(0x00400000, 'NV5D');
                    if (FB_RD32(0x00400000) == 'NV5D')
                    {
                        // 8MB detected, so change config
                        FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_8MB);
                    }
                    else
                    {
                        // 4MB detected, so change config
                        FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_4MB);
                    }
                }
            }
            else
            {
                // write at 4Meg+1 to determine 8 or 4 Meg
                FB_WR32(0x00400000, 'NV5D');
                if (FB_RD32(0x00400000) == 'NV5D')
                {
                    // 8MB detected, so change config
                    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_8MB);
                }
                else
                {
                    // 4MB detected, so change config
                    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_4MB);
                }
            }
        }
    }    
    
	// TO DO: is this necessary?
	// turn off full CPU access
	//...

	return rmStatus;

} // end of DevinitResizeSgram()

VOID Nv05MemLatchMemConfig
(
    PHWINFO pDev
)
{
    // save the original CAS latency
    U032 latency = REG_RD_DRF(_PFB,_CONFIG_1,_CAS_LATENCY);
    
    // toggle the LSB 1-0-1
    FLD_WR_DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3);
    FLD_WR_DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_2);
    FLD_WR_DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3);
    
    // restore original CAS latency
    FLD_WR_DRF_NUM(_PFB,_CONFIG_1,_CAS_LATENCY,latency);
    
} // end of Nv04MemLatchMemConfig()


// end of nv04mem.c


// end of nv05mem.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\devinit\nv\bios.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************************************************************************************************
*
*   Module: bios.c
*
*   Description:
*       generic bios read/write routines
*
*   Revision History:
*       Original -- 2/99 Jeff Westerinen
*
**************************************************************************************************************/

#include <nvrm.h>
#include <nvhw.h>
#include <nv4_ref.h>
#include <os.h>

#include <bios.h>

RM_STATUS BiosReadBytes(
    PHWINFO pDev,
    U008    buffer[],
    U032    offset,
    U032    size
)
{
    U032 i;

    for (i = 0; i < size; i++)
    {
        buffer[i] = BIOS_RD08(pDev->biosOffset + offset + i);
    }

    return RM_OK;
}

RM_STATUS BiosCalculateSizes(
    const char *format,
    U032       *pPackedSize,
    U032       *pPaddedSize
)
{
    U032 packed_size = 0;
    U032 padded_size = 0;
    char fmt;

    while ((fmt = *format++))
    {
        U032 count;

        count = 0;
        while ((fmt >= '0') && (fmt <= '9'))
        {
            count *= 10;
            count += fmt - '0';
            fmt = *format++;
        }
        if (count == 0) count = 1;

        switch (fmt)
        {
            case 'b':
                packed_size += count * 1;
                padded_size += count * sizeof(bios_U008);
                break;
            case 'w':
                packed_size += count * 2;
                padded_size += count * sizeof(bios_U016);
                break;
            case 'd':
                packed_size += count * 4;
                padded_size += count * sizeof(bios_U032);
                break;
        }
    }

    if (pPackedSize) *pPackedSize = packed_size;
    if (pPaddedSize) *pPaddedSize = padded_size;

    return RM_OK;
}


/*
  Unpack little-endian byte stream data, and expand to an array of 32-bit values.
*/
RM_STATUS BiosUnpackLittleEndianStructure(
    U008 *packedLEData,
    U032 *unpackedData,
    const char *format,
    U032 *fields,
    U032 *unpacked_bytes
)
{
    U032 count;
    U032 unpacked;
    char fmt;

    *fields = 0;
    *unpacked_bytes = 0;

    for ( ; (fmt = *format++); )
    {
        count = 0;
        while ((fmt >= '0') && (fmt <= '9'))
        {
            count *= 10;
            count += fmt - '0';
            fmt = *format++;
        }
        if (count == 0) count = 1;

        while (count--)
        {
            switch (fmt)
            {
                case 'b':
                    unpacked = *packedLEData++;
                    *unpacked_bytes += 1;
                    break;

                case 'w':
                    unpacked =  *packedLEData++;
                    unpacked |= *packedLEData++ << 8;
                    *unpacked_bytes += 2;
                    break;

                case 'd':
                    unpacked =  *packedLEData++;
                    unpacked |= *packedLEData++ << 8;
                    unpacked |= *packedLEData++ << 16;
                    unpacked |= *packedLEData++ << 24;
                    *unpacked_bytes += 4;
                    break;

                default:
                    return RM_ERROR;
            }
            *unpackedData++ = unpacked;
            (*fields)++;
        }
    }

    return RM_OK;
}

RM_STATUS BiosReadStructure(
    PHWINFO     pDev,
    void       *structure,
    U032        offset,
    U032       *ppacked_size,
    const char *format
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 packed_size;
    void *packed_data = 0;
    U032 fields;
    U032 unpacked_bytes;
    U008 small_buffer[256];

    // calculate the size of the data as indicated by its packed format.
    BiosCalculateSizes(format, &packed_size, (U032 *) 0);
    if (ppacked_size)
        *ppacked_size = packed_size;

    if (packed_size <= sizeof(small_buffer))
        packed_data = small_buffer;
    else
    {
        rmStatus = osAllocMem((VOID **) &packed_data, packed_size);
        if (rmStatus != RM_OK)
            goto done;
    }

    rmStatus = BiosReadBytes(pDev, (U008*) packed_data, offset, packed_size);
    if (rmStatus != RM_OK)
        goto done;

    rmStatus = BiosUnpackLittleEndianStructure(packed_data, structure, format, &fields, &unpacked_bytes);

 done:
    if (packed_data && (packed_data != small_buffer))
        osFreeMem(packed_data);

    return rmStatus;
}

RM_STATUS BiosReadArray(
    PHWINFO     pDev,
    void       *buffer,
    U032        offset,
    U032        count,
    U032       *ppacked_size,
    const char *format
)
{
    U032 packed_size, padded_size;
    U032 i;
    
    BiosCalculateSizes(format, &packed_size, &padded_size);

    for (i=0; i<count; i++)
    {
        if (RM_OK != BiosReadStructure(pDev,
                                       (U008*)buffer + (i * padded_size),
                                       offset + (i * packed_size),
                                       (U032 *) 0,
                                       format))
            return RM_ERROR;
    }

    // packed_size will be size of 1 element, what is total?
    if (ppacked_size) *ppacked_size = count * packed_size;

    return RM_OK;
}

U008 BiosRead8(
    PHWINFO  pDev,
    U032     offset
)
{
    bios_U008 data;     // BiosReadStructure expects 'bios' types

    (void) BiosReadStructure(pDev, &data, offset, (U032 *) 0, "b");

    return (U008) data;
}


U016 BiosRead16(
    PHWINFO  pDev,
    U032     offset
)
{
    bios_U032 data;     // BiosReadStructure expects 'bios' types

    (void) BiosReadStructure(pDev, &data, offset, (U032 *) 0, "w");
    return (U016) data;
}

U032 BiosRead32(
    PHWINFO  pDev,
    U032     offset
)
{
    bios_U032 data;     // BiosReadStructure expects 'bios' types

    (void) BiosReadStructure(pDev, &data, offset, (U032 *) 0, "d");

    return (U032) data;
}


RM_STATUS BiosFindString(
    PHWINFO pDev,
    U008 string[],
    U032 *offset,
    U032 string_size
)
{
    int i, j;
    int bios_size;

    bios_size = BIOS_ROM_CODE_SIZE - string_size + 1;
    for (i = 0; i < bios_size; i++)   /* i is offset into bios */
    {
        j = 0;  /* j is offset into search string */

        /* while the bios substring matches the desired string.. */
        while (string[j] == BIOS_RD08(i + j)) j++;

        /* if we're on the null character, we found the string.. */
        if (string[j] == NULL)
        {
            *offset = i;
            return RM_OK;
        }
    }
    return RM_ERROR;
}


RM_STATUS BiosGetMaxExternalPCLKFreq
(
    PHWINFO pDev,
    U032 head,
    U032* freq
)
{
    // Try to find the frequency of an external DAC for the given head
    // The frequency return is in freq(Mz)*100
    RM_STATUS status = RM_OK;
    DEV_HEAD dev_head;
    U032 dev_offset = 0; 
    U032 offset = 0;
    U032 size = 0;

    // Display_Devices offset is found at offset 0x0036
    offset = BiosRead16( pDev, 0x0036 );

    if ( offset == 0 )
    {
        status = RM_ERROR;
    }
    else
    {
        // Read header to check version
        status = BiosReadStructure( pDev, &dev_head, offset, &size, DEV_HEAD_FMT );
        dev_offset = offset + size;

        if ( status == RM_OK )
        {
            if ( dev_head.version >= 0x13 )
            {
                // Start reading DEVICE structures 1 at a time until we hit the end
                BOOL bDone = FALSE;
                int i = 0;

                while ( !bDone )
                {
                    DEV_REC_STRUC dev_rec_struc;

                    status = BiosReadStructure( pDev, &dev_rec_struc, dev_offset, &size, DEV_REC_STRUC_FMT );
                    dev_offset = dev_offset + size;
                    i++;

                    // Check for end 
                    if ( dev_rec_struc.dev_type == DEV_REC_UNUSED_DEV )
                    {
                        status = RM_ERROR;
                        bDone = TRUE;
                    }
                    else if ( ( dev_rec_struc.dev_type & DEV_REC_CRT_DEV_MASK ) == 
                        ( DEV_REC_CRT_DEV_EXTERNAL_DAC | ( head << DEV_REC_HEAD_SHIFT ) ) )
                    {
                        // We found an external DAC
                        *freq = dev_rec_struc.data_rsvr;
                        status = RM_OK;
                        bDone = TRUE;
                    }
                    else if ( i > 128 )
                    {
                        // This is a safety check for a bad BIOS
                        // We should never ever hit this!
                        status = RM_ERROR;
                        bDone = TRUE;
                    }
                }
            }
            else
            {
                status = RM_ERROR;
            }
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\devinit\nv\nv10mem.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************************************************************************************************
*
*	Module: nv10mem.c
*
*	Description:
*		Device-specific memory sizing code, for Nv10.
*
*	Revision History:
*		Original -- 6/99 Jeff Westerinen
*
**************************************************************************************************************/

#ifdef NV_PORTABLE

/* "portable" form for use outside resman and by external source customers */
/* look in devinit/portable/ for more details */
#include <nv_portable.h>
#include <nv_ref.h>
#include <nv10_ref.h>
#include <devinit.h>
#include <i2c.h>

#else	/* not NV_PORTABLE --> Nvidia internal */

#include <nvrm.h>
#include <nvhw.h>
#include <nv10_ref.h>
#include <os.h>
#include <devinit.h>
#include <i2c.h>

#endif

RM_STATUS Nv10MemConfigureClocks
(
    PHWINFO pDev,
    MEM_INIT_TABLE_NV10 memInitTable
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 clk;
    U032 memInitTableIndex;
    U032 M,N,P;
    U032 Head = 0; // straps are on head 0; likewise NVPLL, MPLL
/*
        ; Get straps, and turn AL into an index to the table
        ;                       
        mov     al,NV_CIO_SCRATCH4_INDEX        ; CR3C
        call    ReadCRTCReg                     ; Read current value
        shr     ax,12                           ; bits 0:3
*/
    // get the index in the memory init table from scratch register 4
    CRTC_RD(NV_CIO_CRE_SCRATCH4__INDEX, memInitTableIndex, Head);
    memInitTableIndex >>= 4;
    
/*
        ; Size of config structure
        mov     cl, SIZEOF MEM_INIT_VALS        ; Get the size of the config struct
        mul     cl
        
        ; Now point at the right structure with CS:SI
        mov     di, offset bmp_MemInitTbl
        add     di,ax                           ; Add offset into init table

        ; Program NVCLK first, since we've always done it that way
        ;

        mov     ax, cs:[di].MEM_INIT_VALS._NVClk_PLL    ; Get MCLK value
        push    bx      ; BX returns data from this call that we won't use
        call    CalcMNP                         ; Get MNP parameters
        pop     bx
        
        ;       AL = M parameter
        ;       AH = N parameter
        ;       DL = P parameter
        mov     esi,NV_PRAMDAC_NVPLL_COEFF
        call    ProgPLL                         ; Program the PLL's
*/
    // program NVCLK
#ifdef FORCE_NVCLOCKMHZ
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_WARNINGS, "NVRM: Nv10MemConfigureClocks: forcing NVCLK Mhz to ", FORCE_NVCLOCKMHZ);
    clk = FORCE_NVCLOCKMHZ * 100;	// Clock MHz * 100
#else
    clk = memInitTable[memInitTableIndex].NVClk_PLL;
#endif
// Use dacCalcMFP instead of DevinitCalcMNP,
// since the devinit version seems to be returning wrong values.
//    REG_WR32(NV_PRAMDAC_NVPLL_COEFF, DevinitCalcMNP(pDev, &clk));
    dacCalcMNP(pDev, Head, clk, &M, &N, &P);
    REG_WR32(NV_PRAMDAC_NVPLL_COEFF, DRF_NUM(_PRAMDAC, _NVPLL_COEFF, _MDIV, M) |
             DRF_NUM(_PRAMDAC, _NVPLL_COEFF, _NDIV, N) |
             DRF_NUM(_PRAMDAC, _NVPLL_COEFF, _PDIV, P));
                                        
/*
        ; Now, get the sequence table and the MCLK value
        ;
        mov     ax, cs:[di].MEM_INIT_VALS._MClk_PLL     ; Get MCLK value
        test    cs:[di].MEM_INIT_VALS._Flags, 01h        ; SDR or DDR?
        jz      @got_sdr2
        shl     ax,1                            ; Double MCLK on DDR
@got_sdr2:
        
        ; Here, ax = the decimal MCLK value
                
        push    bx      ; BX returns data from this call that we won't use
        call    CalcMNP                         ; Get MNP parameters
        pop     bx
        
        ;       AL = M parameter
        ;       AH = N parameter
        ;       DL = P parameter
        mov     esi,NV_PRAMDAC_MPLL_COEFF
        call    ProgPLL                         ; Program the PLL's
*/
    // program MCLK -- double the clock if flags indicate DDR memory
#ifdef FORCE_MCLOCKMHZ
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_WARNINGS, "NVRM: Nv10MemConfigureClocks: forcing MCLK Mhz to ", FORCE_MCLOCKMHZ);
    clk = FORCE_MCLOCKMHZ * 100;	// Clock MHz * 100
#else
    clk = memInitTable[memInitTableIndex].MClk_PLL;
#endif

    if (memInitTable[memInitTableIndex].Flags == DDR)
    {
        clk *= 2;
    }
    
    // use the RM kernel (dacCalcMFP()) to calculate M, N, and P values
    dacCalcMNP(pDev, Head, clk, &M, &N, &P);
    REG_WR32(
        NV_PRAMDAC_MPLL_COEFF, 
        DRF_NUM(_PRAMDAC, _MPLL_COEFF, _MDIV, M) |
            DRF_NUM(_PRAMDAC, _MPLL_COEFF, _NDIV, N) |
            DRF_NUM(_PRAMDAC, _MPLL_COEFF, _PDIV, P)
    );
    return rmStatus;
    
} // end of Nv10MemConfigureClocks()

    
RM_STATUS Nv10MemConfigureMemory
(
	PHWINFO pDev,
    MEM_INIT_TABLE_NV10 memInitTable, 
    U032 SDRSeqTable[], 
    U032 DDRSeqTable[]
)
{
	RM_STATUS rmStatus = RM_OK;
    U032* seqTable;
    U032 memInitTableIndex, initValue;
    U032 memInitDataIndex = 0; 
    U032 seqTableIndex = 0;
    
    U032 Head = 0;    
    
/*
        call    FullCpuOn               ; Turn on full CPU access
        
        ; Configure memory type by way of straps
        ;
        
        ; Get straps, and turn AL into an index to the table
        ;                       
        mov     al,NV_CIO_SCRATCH4_INDEX        ; CR3C
        call    ReadCRTCReg                     ; Read current value
;        shr    ah,4                            ; Move bits to AH[3:0]
;        shr    ax,8                            ; Move AH->AL
        shr     ax,12                           ; bits 0:3
        
;        mov     esi,NV_PEXTDEV_BOOT_0           ; Get strapping bits
;        NV_DOS_GET      esi
;        and     ax, NV_PEXTDEV_BOOT_0_STRAP_RAMCFG      ; Keep RAMCFG bits
;        shr     ax, RAMCFG_SHIFT
*/
    // get the index in the memory init table from scratch register 4
    CRTC_RD(NV_CIO_CRE_SCRATCH4__INDEX, memInitTableIndex, Head);
    memInitTableIndex >>= 4;
    
/*
        ; Size of config structure
        mov     cl, SIZEOF MEM_INIT_VALS        ; Get the size of the config struct
        mul     cl
        
        ; Now point at the right structure with CS:SI
        mov     di, offset bmp_MemInitTbl
        add     di,ax                           ; Add offset into init table
        
        mov     bx, offset SDR_Sequence_Table
        test    cs:[di].MEM_INIT_VALS._Flags, 01h        ; SDR or DDR?
        jz      @got_sdr

        ; We have DDR memory - turn on FBI_DIFFERENTIAL
        ; 8/25/99
        ;
        mov     esi,NV_PBUS_DEBUG_1
        NV_DOS_GET      esi                     ; Read register
        and     eax,NOT (NV_PBUS_DEBUG_1_FBI_DIFFERENTIAL)
        or      eax, NV_PBUS_DEBUG_1_FBI_DIFFERENTIAL_ENABLED
        NV_DOS_PUT      esi                     ; Re-write register
        
        mov     bx, offset DDR_Sequence_Table
@got_sdr: 
*/
    // set proper sequence table
    switch (memInitTable[memInitTableIndex].Flags)
    {
        case SDR:
            seqTable = SDRSeqTable;
            break;
            
        case DDR:
            seqTable = DDRSeqTable;
            break;
            
        default:
            return RM_ERROR;
    }
    
/*
        add     di,6                            ; Skip Flags, MCLK, NVCLK values
        
        ; CS:BX = pointer to sequence list
        ; CS:DI = pointer to sequence data (MEM_INIT_VALS)
@next_sequence:
        mov     esi, cs:[bx]                    ; Get Sequence
        cmp     esi, 0FFFFFFFFh                 ; End of sequence?
        je      @end_sequence
        
        cmp     esi,NV_PFB_PRE                  ; Precharge command?
        jne     @f  
        
        mov     eax, NV_PFB_PRE_CMD_PRECHARGE   ; Issue precharge command
        jmp     @set_pfb_reg
@@:
        cmp     esi,NV_PFB_PAD
        jne     @f            
        
        mov     eax, NV_PFB_PAD_CKE_NORMAL      ; Enable
        jmp     @set_pfb_reg
@@:
        cmp     esi,NV_PFB_REF                  ; Recharge command?
        jne     @f  
        
        mov     eax, NV_PFB_REF_CMD_REFRESH     ; Issue Refresh command
        jmp     @set_pfb_reg
@@:
        cmp     esi,NV_PFB_EMRS                 ; EMRS command?
        jne     @f  
        
        mov     eax, cs:[di]                    ; Read data value
        cmp     eax, 0FFFFFFFFh                 ; Is it a -1? (SDR)
        jne     @f                              ; Nope - program value
        
        add     di, 4                           ; Skip data value
        jmp     @skip_val                       ; Yep - skip the data value
@@:      
        mov     eax, cs:[di]                    ; Read data value
        add     di, 4                           ; Next data value
        
@set_pfb_reg:   
        NV_DOS_PUT      esi     
@skip_val:
        add     bx, 4                           ; Next sequence value
        jmp     @next_sequence
                
@end_sequence:
*/

    // execute the memory init sequence
    while (seqTable[seqTableIndex] != MEM_INIT_END_OF_SEQUENCE)
    {
        switch (seqTable[seqTableIndex])
        {
            case NV_PFB_PRE:
	            FLD_WR_DRF_DEF(_PFB,_PRE,_CMD,_PRECHARGE);
                break;
                
            case NV_PFB_PAD:
	            FLD_WR_DRF_DEF(_PFB,_PAD,_CKE,_NORMAL);
                break;
                
            case NV_PFB_REF:
	            FLD_WR_DRF_DEF(_PFB,_REF,_CMD,_REFRESH);
                break;
                
            case NV_PFB_EMRS:
                initValue = memInitTable[memInitTableIndex].data[memInitDataIndex++];
                if (initValue != 0xffffffff)
                {
                    REG_WR32(NV_PFB_EMRS, initValue);
                }
                break;
                
            default:
                REG_WR32(seqTable[seqTableIndex], memInitTable[memInitTableIndex].data[memInitDataIndex++]);
                break;
        }
        seqTableIndex++;
    }
    
    return rmStatus;
    
} // end of Nv10MemConfigureMemory()

RM_STATUS Nv10MemChipPreInit
(
	PHWINFO pDev
)
{
	RM_STATUS rmStatus = RM_OK;
    U016 crystalVal, ramcfgVal, data;
    U032 Head = 0;
/*
        mov     esi,NV_PEXTDEV_BOOT_0           ; Get strapping bits
        NV_DOS_GET      esi
        
        test    eax, NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180
        jz      @freq_13
                 
        ; Bit set - we're on 14.318 reference frequency
        mov     ax,((NV_CIO_SCRATCH4_14MHZ SHL 8) OR (NV_CIO_SCRATCH4_INDEX))
        jmp     @f
        
@freq_13: 
        mov     ax,((NV_CIO_SCRATCH4_13MHZ SHL 8) OR (NV_CIO_SCRATCH4_INDEX))
@@:                                   
        call    WriteCRTCReg            ; Write the unlock   
        
        mov     esi,NV_PEXTDEV_BOOT_0           ; Get strapping bits
        NV_DOS_GET      esi
        and     ax, NV_PEXTDEV_BOOT_0_STRAP_RAMCFG ; Keep RAMCFG bits 5:2
        shl     ax, RAMCFG_SHIFT                ; Shift into bits 7:4
        mov     bh,al                           ; Put in BH a while
        mov     al,NV_CIO_SCRATCH4_INDEX        ; CR3C
        call    ReadCRTCReg                     ; Read current value
        or      ah,bh                           ; Or in new values
        call    WriteCRTCReg                    ; Write CR3C
*/
    // pack and save away the strapping values into scratch register 4
    crystalVal = (U016)REG_RD_DRF(_PEXTDEV,_BOOT_0,_STRAP_CRYSTAL);
    ramcfgVal = (U016)REG_RD_DRF(_PEXTDEV,_BOOT_0,_STRAP_RAMCFG);
    data = (U008)(ramcfgVal << 4 & 0x00f0) | (crystalVal & 0x000f);
    CRTC_WR(NV_CIO_CRE_SCRATCH4__INDEX, data, Head);

    return rmStatus;
    
    
} // end of Nv10MemChipPreInit()

RM_STATUS Nv10MemComputeMemory
(
        PHWINFO pDev
)
{
        RM_STATUS rmStatus = RM_OK;
        U032 tries, testAddress, testData;
                                          
    // ensure refresh is on               
        FLD_WR_DRF_DEF(_PFB,_REFCTRL,_VALID,_1);

    // check for RAM width as follows allow 4 tries:
    //   1.  fill the fifo with writes              
    //   2.  write non-zero test dword to 0x0000001c
    //   3.  write out a zero word to 0x0000003c to drive pads low
    //   4.  attempt to read the test dword at 0x0000001c         
    //   5.  if not successful after 4 tries, change bus width to 64 bits
    //   6.  otherwise, bus width remains at default of 128 bits         
    for (tries = 0; tries < 4; tries++)                         
    {                                  
        FB_WR32(0x0000001c, 0x00000000);
        FB_WR32(0x0000001c, 0x00000000);
        FB_WR32(0x0000001c, 0x00000000);
        FB_WR32(0x0000001c, 0x00000000);
        FB_WR32(0x0000001c, 'NV10');
        FlushWB();
        FB_WR32(0x0000003c, 0x00000000);
        FlushWB();
        if ((testData = FB_RD32(0x0000001c)) == 'NV10')
        {
            break;
        }
    }    
    if (testData != 'NV10')
    {                      
        FLD_WR_DRF_DEF(_PFB,_CFG,_BUS,_64);
    }
     
    // check for RAM length as follows:
    //   1.  get what the HW thinks is the largest memory size supported
    //   2.  write test data to first dword in last meg                 
    //   3.  write out a zero to first dword in FB, to drive pads low, then read it back 4 times
    //   4.  attempt to read the original test data
    //   5.  if not successful after 4 tries, change length to 32Meg
    //   6.  otherwise, the length remains at the largest size supported
    testAddress = REG_RD32(NV_PFB_CSTATUS) / 2;
    FB_WR32(testAddress, 'NVDA');
    FB_WR32(testAddress + 0x10, 0x00000000);
    if (FB_RD32(testAddress) != 'NVDA')
    {
        FLD_WR_DRF_DEF(_PFB,_CFG,_EXTBANK,_0);
    }

        return rmStatus;

} // end of Nv10MemComputeMemory()


// end of nv10mem.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\devinit\nv\nv05mtbl.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*****************************************************************************
*
*	Header: nv05mtbl.c
*
*	Description:
*		This file contains the initialization code used to POST an NV5 device.
*	The init code was taken from the BIOS source file, nvinit.inc.
*
*	Revision History:
*		Original -- 5/99 Jeff Westerinen
*
*
*	Steps to convert nvinit.inc to initcode.h
*
*		1.	enclose data in: U032 Nv04_bmp_GenInitTbl[] = { <data> }; 
*		2.	convert ; to //
*		3.  remove all db, dw, and dd, and add comma separaters
*		4.  convert IFDEF to #ifdef
*		5.	convert ELSE to #else
*		6.	convert ENDIF to #endif
*		7.	convert "OR \" and "OR " to |
*		8.	convert <num>h to 0x<num>
*		9 .	format -- at least line up data to left indent
*		10. comment out all table delimiters
*		11. remove bmp_ExtraInitTbl
*
******************************************************************************/

#include <nv4_ref.h>
#include <nvrm.h>
#include <bios.h>

bmpMemInitData Nv05_bmp_MemInitTbl[] = 
/*
{
	{
		0x24,
		0x00
	},

	{
		0x28,
		0x00
	},

	{
		0x24,
		0x01
	},

	{
		0x1F,
		0x00
	},

	{
		0x0F,
		0x00
	},

	{
		0x17,
		0x00
	},

	{
		0x06,
		0x00
	},

	{
		0x00,
		0x00
	}
};
*/
{
    {
        // 0000 - 2Mx32 64Mbit 16/32mb
        0x00000024,             // bits 0-2 vary
        0x00000000              // Special 32 field
    },
    
    {
        // 0001 - 4Mx16 64Mbit 32mb
        0x00000028,        
        0x00000000              // Special 32 field
    },

    {
        // 0010 - 1Mx32 32Mbit 32mb + special32
        0x00000024,
        SPECIAL_32              // Flag field
    },

    {
        // 0011 - 1Mx16 16Mbit 8/16mb
        0x0000001F,
        0x00000000              // Special 32 field
    },
    
    {
        // 0100 - 512Kx32 16Mbit (2 bank) 4/8/16mb 
        0x0000000F,  
        0x00000000              // Special 32 field
    },
    
    {
        // 0101 - 512Kx32 16Mbit (4 bank) 4/8/16mb
        0x00000017,
        0x00000000              // Special 32 field
    },
    
    {
        // 0110 - 4Mx16 64Mbit 16MB (looks like 32MB) - "hokey rams"
        0x00000028,               
        SCRAMBLE_RAM            // Flag field
    },
                
    {
        // 0111 - whatever 0110 used to be... some 8mbit 4/8mb type
        0x00000006,             // This looks like 8mbit - 4/8mb
        0x00000000              // Flag field          
    }
};
        
U032 Nv05_bmp_ScrambleTbl[] = 
{
    0x03020100,     // SCRAMBLE_RAM_0 value
    0x07060504,     // SCRAMBLE_RAM_1 value
    0x0B0A0908,     // SCRAMBLE_RAM_2 value
    0x0F0E0D0C,     // SCRAMBLE_RAM_3 value
    0x03020100,     // SCRAMBLE_RAM_4 value
    0x07060504,     // SCRAMBLE_RAM_5 value
    0x0B0A0908,     // SCRAMBLE_RAM_6 value
    0x0F0E0D0C      // SCRAMBLE_RAM_7 value
};
        
U032 Nv05_bmp_GenInitTbl[] = 
{

	INIT_RESET,
	NV_PMC_ENABLE,      // NV 32 bit address.
	// Off state
	DRF_DEF(_PMC,_ENABLE,_PCRTC,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PPMI,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PFIFO,_ENABLED),
	DRF_DEF(_PMC,_ENABLE,_PFB,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PCRTC,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PPMI,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PFIFO,_ENABLED),

	INIT_NV_REG,                          // Write register with Mask
	NV_PEXTDEV_BOOT_0,                    // Strap Register Update
	//
	//  +---------------------------------- OVERWRITE_ENABLED
	//  |++++++++++++++++------------------ UNUSED
	//  |||||||||||||||||+----------------- FB32MB
	//  ||||||||||||||||||++--------------- PCI_DEVID[1:0]
	//  ||||||||||||||||||||+-------------- RESERVED_11
	//  |||||||||||||||||||||+------------- AGP_SBA_DISABLED
	//  ||||||||||||||||||||||+------------ AGP_4X_DISABLED
	//  |||||||||||||||||||||||++---------- TVMODE[1:0]
	//  |||||||||||||||||||||||||+--------- CRYSTAL_14318180
	//  ||||||||||||||||||||||||||++++----- RAMCFG[3:0]
	//  ||||||||||||||||||||||||||||||+---- SUB_VENDOR_BIOS              
	//  |||||||||||||||||||||||||||||||+--- PCI_AD_NORMAL
	//  VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
	//  3322222222221111111111
	//  10987654321098765432109876543210
	//11111111111111111111111111111111b    // AND Mask  
	0xFFFFFFFF,    
	//10000000000000000000100000000000b    // OR  Mask      
	0x80000800,
	                               
	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PBUS_DEBUG_PRIV_ASRC,
	//        00000000h                  // 2/26/99 per Quang - fixes TV shimmer
#ifdef ULTRA
	0xF0F000F0,                  // 4/07/99 per Dave Reed
#else                                                 
	0x00000000,                   // 4/07/99 per Dave Reed
#endif  // ULTRA                                       
                                          
	// Barry's memory fix for AGP
	INIT_ZM_REG,
	NV_PBUS_DEBUG_0,
	//        01020101h    // 1/29/99 - Per Dave Reed
#ifdef ULTRA
	0x01000105,           // 4/07/99 - Per Dave Reed
#else              
	0x01020101,           // 4/07/99 - Per Dave Reed
#endif  // ULTRA     

	INIT_ZM_REG,                 // Write with mask
	NV_PBUS_DEBUG_CTRIM_0,
	//       0F00BBA7h                   // 8x6 & 10x7 panels (as of 3/22/99)
	0x0800BBA7,                   // 04/07/99

	INIT_ZM_REG,                 // Write with mask
	NV_PBUS_DEBUG_CTRIM_1,
	//       0h                          // as of 3/22/99
	0x0EFE00000,                   // 04/07/99
	                                 
	INIT_ZM_REG,                 // Write with mask
	NV_PBUS_DEBUG_CTRIM_2,
	//       0F8C98200h                  // 8x6 & 10x7 panels (as of 3/22/99)
	0x088C98200,                  // 04/07/99
	                                
	INIT_ZM_REG,                 // Write with mask
	NV_PBUS_DEBUG_CTRIM_3,
	//       0FF988AA9h                  // prior to 3/22/99
#ifdef ULTRA
	0x0FF988DDC,                  // 4/07/99
#else                                    
	0x0FF988AA9,                  // 4/07/99
#endif  // ULTRA                          
                           
	// Comment to fix assembler bug

	// 13,500,000 MHz - MCLK = M:11:0B, N:163:A3, P:4:04 LOG2P:2 50 MHz
	// 14,318,180 MHz - MCLK = M:14:0E, N:196:C4, P:4:04 LOG2P:2 50 MHz
	INIT_PLL,
	NV_PRAMDAC_NVPLL_COEFF,       // Actually, this is NVPLL (680500)
#ifdef VANTA
	10000,       // 100Mhz
#else   // VANTA
#ifdef  ULTRA
	15000,       // 150Mhz
#else   // ULTRA
	12500,       // 125Mhz
#endif  // ULTRA           
#endif  // VANTA

	// In all of these cases, Model64 (/DM64) will use the TNT2 settings

	// Comment to fix assembler bug

	// 13,500,000 MHz - MCLK = M:11:0B, N:163:A3, P:4:04 LOG2P:2 50 MHz
	// 14,318,180 MHz - MCLK = M:14:0E, N:196:C4, P:4:04 LOG2P:2 50 MHz
	INIT_PLL,
	NV_PRAMDAC_MPLL_COEFF,
#ifdef VANTA
	12500,   // 125Mhz
#else   // VANTA
#ifdef ULTRA
	18300,   // 183Mhz
#else   // ULTRA
	15000,   // 150Mhz
#endif  // ULTRA
#endif  // VANTA

	// Comment to fix assembler bug

	// NV_PFB_CONFIG_0
	INIT_ZM_REG,
	NV_PFB_CONFIG_0,      // NV 32 bit address.
	DRF_DEF(_PFB,_CONFIG_0,_RESOLUTION,_DEFAULT) |
		DRF_DEF(_PFB,_CONFIG_0,_PIXEL_DEPTH,_DEFAULT) |
		DRF_DEF(_PFB,_CONFIG_0,_TILING,_DISABLED) |
		DRF_DEF(_PFB,_CONFIG_0,_TILING_DEBUG,_DISABLED),

	// Comment to fix assembler bug

	// VCLK.
	// 13,500,000 MHz - VCLK = M:12:0C, N:064:40, P:2:02 LOG2P:1 36.00 MHz
	// 14,318,180 MHz - VCLK = M:14:0E, N:141:8D, P:4:04 LOG2P:2 36.05 MHz
	INIT_PLL,
	NV_PRAMDAC_VPLL_COEFF,        // NV 32 bit address.
	3600,
	//        00001400Ch
	//        000028D0Eh

	// Comment to fix assembler bug

	// NV_PFB_GREEN_0
	INIT_ZM_REG,
	NV_PFB_GREEN_0,   // NV 32 bit address.
	DRF_DEF(_PFB,_GREEN_0,_LEVEL,_VIDEO_ENABLED),   // NV 32 bit data.

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PFB_DEBUG_0,
#ifdef IKOS
	0x20000100,          // Per RussM on 10/14
#else   // IKOS                   
	//      20001D00h            // 7/23
#ifdef ULTRA
	0x20002D00,            // Per Dave R on 4/7/99
#else
	0x20002500,            // Per Dave R on 4/7/99
#endif  // ULTRA 
#endif 

	// Comment to fix assembler bug

	// Default Value - pre-memory config
	INIT_ZM_REG,
	NV_PFB_CONFIG_1,
	0x41016293,          // This value works for about everything

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PFB_RTL,
	0x00000000,

	// Comment to fix assembler bug

	// Per Dave Reed
	// Setup more optimal PCI interface
	INIT_ZM_REG,
	NV_PBUS_DEBUG_1,
	DRF_DEF(_PBUS,_DEBUG_1,_PCIM_THROTTLE,_DISABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIM_CMD,_SIZE_BASED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_PCIM_AGP,_IS_AGP) |			// !! undefined for NV5
		DRF_DEF(_PBUS,_DEBUG_1,_AGPM_CMD,_LP_ONLY) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WRITE,_0_CYCLE) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_2_1,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RETRY,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RD_BURST,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WR_BURST,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_EARLY_RTY,_ENABLED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RMAIO,_DISABLED) |		// !! undefined for NV5
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_CPUQ,_ENABLED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_SPARE1,_ZERO) |				// !! exactly wrong
		DRF_DEF(_PBUS,_DEBUG_1,_FBI_DIFFERENTIAL,_DISABLED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_SPARE2,_ONE),					// !! exactly wrong
		DRF_DEF(_PBUS,_DEBUG_1,_SPARE2,_ZERO),

	// Comment to fix assembler bug

                               
	INIT_COMPUTE_MEM,             // Compute frame buffer size
          
	//=============================================================
	//       Memory Dependent Initialization Table.
	//=============================================================

	INIT_NV_REG,                 // Write register with Mask
	NV_PFB_BOOT_0,               // Strap Register for Memory
	0xFFFFFFFF,                  // AND Mask
	0x00000000,                  // OR Mask

	// Final value for running after sizing
	INIT_NV_REG,                 // Write register with Mask
	NV_PFB_CONFIG_1,
	0x00F00000,                  // AND Mask
	0x41016293,          // This value works for about everything
        
	//        INIT_MEM_RESTRICT
	//        018h                        // Strip to memory type (AND MASK)
	//        018h                        // Compare value = SDRAM
	//        
	//        INIT_RESUME                 // No more SDRAM stuff
	//                                         
	//        INIT_MEM_RESTRICT
	//        018h                        // Strip to memory type (AND MASK)
	//        010h                        // Compare value = SDRAM
	//             
	//        INIT_RESUME                 // No more SDRAM stuff
	        
	//------------------------------------------------------------
	//       Final Initialization Tables.
	//------------------------------------------------------------
	//
	//       Max allocated Final init space is
	//       INIT_ADDITION_REG_SPACE. This includes the FinalInit
	//       table and the FinalInit tables for all the FinalMem
	//       inits. OEM will utilize the BMP to maximize the
	//       utilization of addition table space.
	//

	// Comment to fix assembler bug

	//public  bmp_FinalInit
	//bmp_FinalInit:
	INIT_ZM_REG,
	NV_PRAMDAC_PLL_COEFF_SELECT,   // NV 32 bit address.
	0x00000500,                   // PROG_MPLL & PROG_NVPLL

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PBUS_DEBUG_2,
	0x000001F0,                // Per K^2 -  4/09/99
	//#ifdef OLD_BOARDS                                  
	//       000011F0h               // Per Jill S. -  5/12/98
	//#else   // OLD_BOARDS
	//       000001F1h               // Per Dave R. -  3/24/99
	//#endif  // OLD_BOARDS
                                               
	INIT_ZM_REG,
	NV_PBUS_DEBUG_3,
#ifdef VANTA
	NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_94MHZ | NV_PBUS_DEBUG_3_AGP_MAX_SIZE_32_BYTES,
#else   // VANTA
#ifdef  ULTRA
	NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_133MHZ | NV_PBUS_DEBUG_3_AGP_MAX_SIZE_32_BYTES,
#else   // ULTRA
	NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_120MHZ | NV_PBUS_DEBUG_3_AGP_MAX_SIZE_32_BYTES,
#endif  // ULTRA
#endif  // VANTA

	// Comment to fix assembler bug

	// Force real mode window default state to off
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	//NVRM_ACCESS,0x000,0x000,				// !! undefined
	NV_CIO_CRE_RMA__INDEX,0x000,0x000,

	// Make sure hsync and vsync are on (we only set them in DPMS calls)
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x01A,0x000,0x03F,
                       
	// Comment to fix assembler bug

	// Boot with TV off, and set for NTSC if it was on.
	// Also set horizontal pixel adjustment
	// Sets pixel format to VGA
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x028,0x000,0x000,

	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x033,0x000,0x000,         // Clear slave registers

	// Comment to fix assembler bug
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x021,0x000,0x0FA,         // Force Lock register to 0FAh
        
   // Clear TV device selection
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	//        02Bh,000h,000h        // 
	0x02B,0x007,0x000,         // Amask to retain Strap or override
        
        // Replace the above line with one of the following
        // to override the default settings for TV
	//       02Bh,000h,000h         // Force NTSC_M (Std)
	//       02Bh,000h,001h         // Force NTSC_J (BT869 Only)
	//       02Bh,000h,002h         // Force PAL-M (NTSC w/PAL encoding) (BT869 Only)
	//       02Bh,000h,003h         // Force PAL_BDGHI (Std)
	//       02Bh,000h,004h         // Force PAL-N (BT869 Only)
	//       02Bh,000h,005h         // Force PAL-NC (BT869 Only)
                                                           
	// Clear scratch to default state
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x02C,0x000,0x000,         // Clear all scratch bits for default
        
        // Old values for TV override selection
	//        02Ch,030h,000h         // Use this line to use straps
	//        02Ch,000h,010h          // Use this line to force NTSC Boot
	//        02Ch,000h,020h          // Use this line to force PAL Boot
	//        02Ch,000h,000h         // Use this line to force NOTV Boot
                                                       
        // Float DDC pins high (not touched during a mode set or save/restore state)
	//        INIT_INDEX_IO
	//        CRTC_INDEX_COLOR
	//        03Fh,000h,033h

        // Disable DDC
	//        INIT_INDEX_IO
	//        CRTC_INDEX_COLOR
	//        03Fh,000h,032h

	 // Comment to fix assembler bug

	INIT_DONE
	//        EOL //END OF LIST
};

// raw BMP table for TNT2 Pro 
U032 Nv05Pro_bmp_GenInitTbl[] = 
{
    0x00000065, 0x00000200, 0x01010100, 0x01110100,
    0x0000006e, 0x00101000, 0xffff4c43, 0x8000018c,
    0x0000007a, 0x000010e0, 0xf0f000f0, 0x0000007a,
    0x00001080, 0x04040000, 0x0000007a, 0x000010b0,
    0x0800bba7, 0x0000007a, 0x000010b4, 0xefe00000,
    0x0000007a, 0x000010b8, 0x88c98200, 0x0000007a,
    0x000010bc, 0xff988aa9, 0x00000079, 0x00680500,
    0x00003778, 0x00000079, 0x00680504, 0x00003fac,

    0x0000007a, 0x00100200, 0x00001114, 0x00000079,
    0x00680508, 0x00000e10, 0x0000007a, 0x001000c0,
    0x00000000, 0x0000007a, 0x00100080, 0x20002800,
    0x0000007a, 0x00100204, 0x41016293, 0x0000007a,
    0x00100300, 0x00000000, 0x0000007a, 0x00001084,
    0x000057c8, 0x00000063, 0x0000006e, 0x00100000,
    0xffffffff, 0x00000000, 0x0000006e, 0x00100204,
    0x00f00000, 0x42216293, 0x0000007a, 0x0068050c,

    0x00000500, 0x0000007a, 0x00001088, 0x000011f0,
    0x0000007a, 0x0000108c, 0x000000e1, 0x00000078,
    0x000003d4, 0x00000038, 0x00000000, 0x00000000,
    0x00000078, 0x000003d4, 0x0000001a, 0x00000000,
    0x0000003f, 0x00000078, 0x000003d4, 0x00000028,
    0x00000000, 0x00000000, 0x00000078, 0x000003d4,
    0x00000033, 0x00000000, 0x00000000, 0x00000078,
    0x000003d4, 0x00000021, 0x00000000, 0x000000fa,

    0x00000078, 0x000003d4, 0x0000002b, 0x00000007,
    0x00000000, 0x00000078, 0x000003d4, 0x0000002c,
    0x00000000, 0x00000000, 0x00000071
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\devinit\nv\nv10mtbl.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*****************************************************************************
*
*	Header: nv10mtbl.c
*
*	Description:
*		This file contains the initialization code tables used to POST an NV10 device.
*   The init code was taken from the BIOS source file, nvinit.inc.
*
*	Revision History:
*		Original -- 6/99 Jeff Westerinen
*
*   Steps to convert all tables
*
*		1.	convert ; to //
*		2.  remove all db, dw, and dd, and add comma separaters
*		3.  convert IFDEF to #ifdef
*		4.	convert ELSE to #else
*		5.	convert ENDIF to #endif
*		6.	convert "OR \" and "OR " to "| "
*		7.	convert asm hex numbers to C hex numbers: ([0-9A-Fa-f]+)h\, to 0x\1\,
*       8.  convert asm binary numbers to C hex numbers
*		9.	format -- at least line up data to left indent
*		10. comment out all table delimiters
*
*   Steps to convert sequence tables from memcfg.asm
*
*		1.	convert SDR_Sequence_Table data to: U032 Nv10_SDR_Sequence_Table[] = { <data> }; 
*		2.	convert DDR_Sequence_Table data to: U032 Nv10_DDR_Sequence_Table[] = { <data> }; 
*
*   Steps to convert mem init table from memcfg.asm
*
*		1.	convert bmp_MemInitTbl data to: MEM_INIT_VALS Nv10_bmp_MemInitTbl[] = { <data> }; 
*       2.  remove MEM_INIT_VALS for each entry
*       3.  add defaults to elements 4, 10, and 14
*       4.  separate records with commas
*
*	Steps to convert bmp_GenInitTbl in nvinit.inc
*
*		1.	convert bmp_GenInitTbl data to: U032 Nv04_bmp_GenInitTbl[] = { <data> }; 
*		2.  remove bmp_ExtraInitTbl
*
******************************************************************************/

#include <nv10_ref.h>
#include <nvrm.h>
#include <bios.h>

U032 Nv10_SDR_Sequence_Table[] = 
{
    NV_PFB_REFCTRL,
    NV_PFB_CFG,
    NV_PFB_TIMING0,
    NV_PFB_TIMING1,
    NV_PFB_TIMING2,
    NV_PBUS_DEBUG_CTRIM_4,
    NV_PFB_PRE,
    NV_PFB_PIN,
    NV_PFB_PAD,
    NV_PFB_EMRS,
    NV_PFB_MRS,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_PRE,
    NV_PFB_PRE,
    NV_PFB_PRE,
    NV_PFB_MRS,
    NV_PFB_REFCTRL,
    0xFFFFFFFF,
    0xFFFFFFFF,
    0xFFFFFFFF,
    0xFFFFFFFF      // List terminator
};
        
U032 Nv10_DDR_Sequence_Table[] = 
{
    NV_PFB_REFCTRL,
    NV_PFB_CFG,
    NV_PFB_TIMING0,
    NV_PFB_TIMING1,
    NV_PFB_TIMING2,
    NV_PBUS_DEBUG_CTRIM_4,
    NV_PFB_PIN,
    NV_PFB_PAD,
    NV_PFB_PRE,
    NV_PFB_EMRS,
    NV_PFB_MRS,
    NV_PFB_PRE,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_MRS,
    NV_PFB_REFCTRL,
    0xFFFFFFFF,
    0xFFFFFFFF,
    0xFFFFFFFF,
    0xFFFFFFFF      // List terminator
};
   
MEM_INIT_TABLE_NV10 Nv10_bmp_MemInitTbl = 
{
    // Note - PFB_TIMING2: 61A = 100Mhz
    //                     91F = 150Mhz
    //                     **A2C = 166Mhz** old value
    //                     9FF = 166Mhz
    //                     B1F = 183Mhz
    //                       
    // 0000 = 64MBit x 32 SDR 166Mhz
    // Strap 0000 - 2M x 32 SDR @ 166Mhz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08B11110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL,0xFFFFFFFF, 
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0000
    // 0001 =                                 
    // Strap 0001 - 4Mx16 SDR @ 166MHz 
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08C11110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,    
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0001
    // 0010 =                                                       
    // Strap 0010 - 1Mx32 SDR @ 166MHz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08B01110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0010
    // 0011 = 16MBit x 16 SDR 200Mhz
    // Strap 0011 - 16MBit x 16 SDR @ 166Mhz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08B01110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0011
    // 0100 =            
    // Strap 0100 - 512Kx32(2-bank) SDR SGRAM @ 166Mhz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08A01110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0100
    // 0101 =            
    // Strap 0101 - 512Kx32(2-bank) SDR SGRAM @ 166Mhz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08911110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0101
    // 0110 =            
    // Strap 0110 - 8Mx16 SDR @ 100 Mhz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x09C11110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0110
    // 0111 =            
    // Strap 0111 - 8M x 8 SDR SDRAM @ 166MHz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x09C11110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0111
                     
    // 1000 = 64MBit x 32 SDR 150Mhz
    // Strap 0000 - 2M x 32 SDR @ 150Mhz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08B11110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL,0xFFFFFFFF, 
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0000
    // 1001 =                                 
    // Strap 0001 - 4Mx16 SDR @ 150MHz 
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08C11110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,    
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0001
    // 1010 =                                                       
    // Strap 0010 - 1Mx32 SDR @ 150MHz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08B01110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0010
    // 1011 = 16MBit x 16 SDR 200Mhz
    // Strap 0011 - 16MBit x 16 SDR @ 150Mhz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08B01110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0011
    // 1100 =            
    // Strap 0100 - 512Kx32(2-bank) SDR SGRAM @ 150Mhz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08A01110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0100
    // 1101 =            
    // Strap 0101 - 512Kx32(2-bank) SDR SGRAM @ 150Mhz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08911110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0101
    // 1110 =            
    // Strap 0110 - 8Mx16 SDR @ 150 Mhz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x09C11110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0110
    // 1111 =            
    // Strap 0111 - 8M x 8 SDR SDRAM @ 150MHz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x09C11110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}}   // 0111
};
                         
U032 Nv10_bmp_GenInitTbl[] = 
{
#if 0
    //-----------------------------------------------------
    // Do a software reset here
    //-----------------------------------------------------
    INIT_RESET,                          // Sequence ID byte
    NV_PMC_ENABLE,                       // NV 32 bit address.
    // 
    // Off state
    NV_PMC_ENABLE_BUF_RESET_DISABLE | 
       NV_PMC_ENABLE_PMEDIA_DISABLED   | 
       NV_PMC_ENABLE_PFIFO_DISABLED    | 
       NV_PMC_ENABLE_PGRAPH_DISABLED   | 
       NV_PMC_ENABLE_PPMI_DISABLED     | 
       NV_PMC_ENABLE_PFB_DISABLED      | 
       NV_PMC_ENABLE_PCRTC_ENABLED     | 
       NV_PMC_ENABLE_PVIDEO_DISABLED,
                                  
    //
    // On state
    NV_PMC_ENABLE_BUF_RESET_DISABLE  | 
       NV_PMC_ENABLE_PMEDIA_ENABLED     | 
       NV_PMC_ENABLE_PFIFO_ENABLED      | 
       NV_PMC_ENABLE_PGRAPH_DISABLED    | 
       NV_PMC_ENABLE_PPMI_ENABLED       | 
       NV_PMC_ENABLE_PFB_ENABLED        | 
       NV_PMC_ENABLE_PCRTC_ENABLED      | 
       NV_PMC_ENABLE_PVIDEO_DISABLED,
       
    //-----------------------------------------------------
    // Configure the strap fields here
    //-----------------------------------------------------
    INIT_NV_REG,                          // Write with Mask
    NV_PEXTDEV_BOOT_0,                    // Strap Register Update
    // 
    //   +---------------------------------- OVERWRITE_ENABLED
    //   |++++++++++++++++------------------ UNUSED
    //   |||||||||||||||||+----------------- FB32MB
    //   ||||||||||||||||||++--------------- PCI_DEVID[1:0]
    //   ||||||||||||||||||||+-------------- RESERVED_11 (NV5)/AGP_FASTWR (NV10)
    //   |||||||||||||||||||||+------------- AGP_SBA_DISABLED
    //   ||||||||||||||||||||||+------------ AGP_4X_DISABLED
    //   |||||||||||||||||||||||++---------- TVMODE[1:0]
    //   |||||||||||||||||||||||||+--------- CRYSTAL_14318180
    //   ||||||||||||||||||||||||||++++----- RAMCFG[3:0]
    //   ||||||||||||||||||||||||||||||+---- SUB_VENDOR_BIOS              
    //   |||||||||||||||||||||||||||||||+--- PCI_AD_NORMAL
    //   VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
    //   3322222222221111111111
    //   10987654321098765432109876543210
    //11111111111111111111011111111111b    // AND Mask      
    0xfffff7ff,    // AND Mask      
    //10000000000000000000000000000000b    // |  Mask - force write
    0x80000000,    // |  Mask - force write

    INIT_CONFIGURE_PREINIT,               // Read RAM type and Ref Freq
                                           // This also inits CR3C

    //-----------------------------------------------------
    // Make sure the NV10 fan is running
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x035,0x0FE,0x001,
                   
    //-----------------------------------------------------
    // Set Scratch4 to let the VESA interface know the fan is on
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x03C,0x0F7,0x008,
                                              
    // Disable Framebuffer
    INIT_ZM_REG,                         // Write register
    NV_PMC_ENABLE,                       // NV 32 bit address.
    NV_PMC_ENABLE_BUF_RESET_ENABLE   | 
       NV_PMC_ENABLE_PMEDIA_ENABLED     | 
       NV_PMC_ENABLE_PFIFO_ENABLED      | 
       NV_PMC_ENABLE_PGRAPH_DISABLED    | 
       NV_PMC_ENABLE_PPMI_ENABLED       | 
       NV_PMC_ENABLE_PFB_DISABLED       | 
       NV_PMC_ENABLE_PCRTC_ENABLED      | 
       NV_PMC_ENABLE_PVIDEO_DISABLED,
       
    INIT_INDEX_IO,
    SEQ_INDEX,
    0x001,0x0FF,0x020,           // FullCPU Access On/CRTC Refresh off

    // Note: CRTC Refresh and the Framebuffer need to be disabled
    //       while programming NVCLK and MCLK
       
    INIT_PLL,
    NV_PRAMDAC_NVPLL_COEFF,              // Program default NVCLOCK
    10000,                               // 100Mhz   
                                              
    INIT_PLL,
    NV_PRAMDAC_MPLL_COEFF,               // Program default MCLOCK
    8300,                                // 83Mhz        
                                              
    //-----------------------------------------------------
    // Set per MK on 5/26/99
    //-----------------------------------------------------
    INIT_ZM_REG,                         // Write register
    NV_PBUS_DEBUG_CTRIM_0,                       
    0x03115223,                           // 05/26/99

    //-----------------------------------------------------
    //-----------------------------------------------------
    INIT_NV_REG,                         // Write with Mask
    NV_PBUS_DEBUG_CTRIM_1,                       
    0x0FFFFFFFF,                          // AND Mask
    0x000000000,                          // | Mask

    //-----------------------------------------------------
    //-----------------------------------------------------
    INIT_ZM_REG,                         // Write register
    NV_PBUS_DEBUG_CTRIM_2,                       
    0x000000000,
           
    //-----------------------------------------------------
    //-----------------------------------------------------
    INIT_ZM_REG,                         // Write register
    NV_PBUS_DEBUG_CTRIM_3,                       
    0x0FF223003,

    //-----------------------------------------------------
    // Set per MK on 5/26/99
    //-----------------------------------------------------
    // INIT_ZM_REG                         // Write register
    // NV_PBUS_DEBUG_CTRIM_4               
    // 9CAB1433h                           // 05/26/99
    //
    // above now done in memcfg.asm
    //

    //-----------------------------------------------------
    //-----------------------------------------------------
    INIT_NV_REG,                         // Write with Mask
    NV_PBUS_DEBUG_CTRIM_5,                       
    0x0FFFFFFFF,                          // AND Mask
    0x000000000,                          // | Mask

    //-----------------------------------------------------
    //-----------------------------------------------------
    INIT_NV_REG,                         // Write with Mask
    NV_PBUS_DEBUG_CTRIM_6,                       
    0x0FFFFFFFF,                          // AND Mask
    0x000000000,                          // | Mask

    INIT_ZM_REG,                         // Write register
    NV_PRAMDAC_PLL_COEFF_SELECT,         // NV 32 bit address.
    0x00000500,                           // PROG_MPLL & PROG_NVPLL

    INIT_CONFIGURE_CLK,                  // Set MCLK/NVCLK

    // Enable Framebuffer
    INIT_ZM_REG,                         // Write register
    NV_PMC_ENABLE,                       // NV 32 bit address.
    NV_PMC_ENABLE_BUF_RESET_ENABLE   | 
       NV_PMC_ENABLE_PMEDIA_ENABLED     | 
       NV_PMC_ENABLE_PFIFO_ENABLED      | 
       NV_PMC_ENABLE_PGRAPH_DISABLED    | 
       NV_PMC_ENABLE_PPMI_ENABLED       | 
       NV_PMC_ENABLE_PFB_ENABLED        | 
       NV_PMC_ENABLE_PCRTC_ENABLED      | 
       NV_PMC_ENABLE_PVIDEO_DISABLED,

    //-----------------------------------------------------
    // Set the drive strengh register. The default AND/OR
    // mask causes the BIOS to initialize with the power
    // on default value.
    //-----------------------------------------------------
    INIT_NV_REG,                         // Write with Mask
    NV_PBUS_DEBUG_PRIV_ASRC,                      
    0x0FFFFFFFF,                          // AND Mask
    0x000000000,                          // | Mask
       
    //-----------------------------------------------------
    //-----------------------------------------------------

    // 8/25/99
    // Bit 7 (PCIS_RETRY is SPARE0, and has changed from 1 to 0 here)
    //
    INIT_ZM_REG,                         // Write register
    NV_PBUS_DEBUG_1,
    // 
    //   ++++++++++++++++------------------- SPARES
    //   ||||||||||||||||+------------------ AGPFW_DWOD_DISABLED
    //   |||||||||||||||||+----------------- FBI_DIFFERENTIAL_DISABLED
    //   ||||||||||||||||||+---------------- DPSH_DECODE_NV4
    //   |||||||||||||||||||+--------------- PCIS_CPUQ_ENABLED
    //   ||||||||||||||||||||+-------------- UNDEFINED
    //   |||||||||||||||||||||+------------- PCIS_EARLY_RTY_ENABLED
    //   ||||||||||||||||||||||+------------ PCIS_WR_BURST_ENABLED
    //   |||||||||||||||||||||||+----------- PCIS_RD_BURST_ENABLED
    //   ||||||||||||||||||||||||+---------- SPARE0_ZERO
    //   |||||||||||||||||||||||||+--------- PCIS_2_1_ENABLED
    //   ||||||||||||||||||||||||||+-------- PCIS_WRITE_0_CYCLE
    //   |||||||||||||||||||||||||||++------ AGPM_CMD_LP_ONLY
    //   |||||||||||||||||||||||||||||+----- HASH_DECODE_1FF
    //   ||||||||||||||||||||||||||||||+---- PCIM_CMD_SIZE_BASED
    //   |||||||||||||||||||||||||||||||+--- PCIM_THROTTLE_DISABLED
    //   VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV    
    //   3322222222221111111111
    //   10987654321098765432109876543210
    //00000000000000000101011101001000b,   // Write Value
    0x00005748,   // Write Value
                                   
    INIT_ZM_REG,                         // Write register
    NV_PFB_DEBUG_0,
    0,

    // New "Configure Memory" token
    INIT_CONFIGURE_MEM,                  // Configure the memory type

    INIT_COMPUTE_MEM,                    // Size the memory

    INIT_INDEX_IO,
    SEQ_INDEX,
    0x001,0x0DF,0x000,           // FullCPU Access Off

    //-----------------------------------------------------
    // Program VCLOCK
    //         
    // 13,500,000 MHz - VCLK = M:12:0C, N:064:40, P:2:02 LOG2P:1 36.00 MHz
    // 14,318,180 MHz - VCLK = M:14:0E, N:141:8D, P:4:04 LOG2P:2 36.05 MHz
    //-----------------------------------------------------
    INIT_PLL,
    NV_PRAMDAC_VPLL_COEFF,               // Program default VCLOCK
    3600,                                // 36Mhz   

    //-----------------------------------------------------
    // Set to NV5 values f| now
    //-----------------------------------------------------
    INIT_ZM_REG,
    NV_PBUS_DEBUG_2,
    0x000011F0,

    //-----------------------------------------------------
    // Set to NV5 values f| now
    //-----------------------------------------------------
    INIT_ZM_REG,
    NV_PBUS_DEBUG_3,
    NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_120MHZ | NV_PBUS_DEBUG_3_AGP_MAX_SIZE_32_BYTES,

    //-----------------------------------------------------
    // Do CRTC IO default programming
    //-----------------------------------------------------
    //
    //-----------------------------------------------------
    // Force real mode window default state to off
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
	//NVRM_ACCESS,0x000,0x000,				// !! undefined
	NV_CIO_CRE_RMA__INDEX,0x000,0x000,

    //-----------------------------------------------------
    // Make sure hsync and vsync are on (we only set them in DPMS calls)
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x01A,0x000,0x03F,
                   
    //-----------------------------------------------------
    // Boot with TV off, and set f| NTSC if it was on.
    // Also set horizontal pixel adjustment
    // Sets pixel format to VGA
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x028,0x000,0x000,

    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x033,0x000,0x000,         // Clear slave registers

    //-----------------------------------------------------
    // Force Lock register to default state
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x021,0x000,0x0FA,         // Force Lock register to 0FAh

    //-----------------------------------------------------
    // Clear scratch registers - TV Selection
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x02B,0x000,0x000,         // Clear all scratch bits f| default
                                        
    //-----------------------------------------------------
    // Clear scratch registers to default state
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x02C,0x000,0x000,         // Clear all scratch bits f| default

    //-----------------------------------------------------
    // Clear scratch registers to default state
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x03A,0x000,0x000,         // Clear all scratch bits f| default
    
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x03B,0x000,0x000,         // Clear all scratch bits f| default

    //-----------------------------------------------------
    // End of the list
    //-----------------------------------------------------
    INIT_DONE
    
#else

    // This data was extracted directly from a GeForce reference card.
    // It differs from the translated source code above and is the only
    // version between the two that actually works.  If necessary, we
    // must either create a development path from the actual BIOS source
    // code or create a tool that extracts the tables from a BIOS binary.
    0x00000065, 0x00000200, 0x01000000, 0x01110110,
    0x0000006e, 0x00101000, 0xfffff7ff, 0x80000000,
    0x00000068, 0x00000078, 0x000003d4, 0x00000035,
    0x000000fe, 0x00000001, 0x00000078, 0x000003d4,
    0x0000003a, 0x00000000, 0x00000001, 0x0000007a,
    0x00000200, 0x01010111, 0x00000078, 0x000003c4,
    0x00000001, 0x000000ff, 0x00000020, 0x00000079,
    0x00680500, 0x00002710, 0x00000079, 0x00680504,

    0x0000206c, 0x0000007a, 0x000010b0, 0x03115223,
    0x0000006e, 0x000010b4, 0xffffffff, 0x00000000,
    0x0000007a, 0x000010b8, 0x00000000, 0x0000007a,
    0x000010bc, 0xff223003, 0x0000006e, 0x000010c8,
    0xffffffff, 0x00000000, 0x0000006e, 0x000010cc,
    0xffffffff, 0x00000000, 0x0000007a, 0x0068050c,
    0x00000500, 0x00000067, 0x0000007a, 0x00000200,
    0x01110111, 0x0000006e, 0x000010e0, 0xffffffff,

    0x00000000, 0x0000007a, 0x00001084, 0x00005748,
    0x0000007a, 0x00100080, 0x00000000, 0x00000066,
    0x00000063, 0x00000078, 0x000003c4, 0x00000001,
    0x000000df, 0x00000000, 0x00000079, 0x00680508,
    0x00000e10, 0x0000007a, 0x00001088, 0x000011f0,
    0x0000007a, 0x0000108c, 0x000000d1, 0x00000078,
    0x000003d4, 0x00000038, 0x00000000, 0x00000000,
    0x00000078, 0x000003d4, 0x0000001a, 0x00000000,

    0x0000003f, 0x00000078, 0x000003d4, 0x00000028,
    0x00000000, 0x00000000, 0x00000078, 0x000003d4,
    0x00000033, 0x00000000, 0x00000000, 0x00000078,
    0x000003d4, 0x00000021, 0x00000000, 0x000000fa,
    0x00000078, 0x000003d4, 0x0000002b, 0x00000000,
    0x00000000, 0x00000078, 0x000003d4, 0x0000002c,
    0x00000000, 0x00000000, 0x00000078, 0x000003d4,
    0x0000003b, 0x00000000, 0x00000000, 0x00000071

#endif

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\devinit\portable\nv_local.h ===
/*
 * nv_local.h
 *     placeholder for customer/OEM definitions for required
 *     macros for devinit() code.  It is hoped that all customer
 *     changes can be confined to this file.
 */

/*
 * read/write memory
 */

#define REG_WR32(a,d)   
#define REG_RD32(a)       0
#define REG_WR08(a,d)   
#define REG_RD08(a)       0

#define PRMCIO_REG_WR32(b,o,d)   
#define PRMCIO_REG_RD32(b,o)     0

#define CRTC_WR(i,d)    
#define CRTC_RD(i,d)       0


#ifdef DEBUG
#include <stdout.h>
#define DBG_PRINT_STR(s)  fprintf(stderr, (s))
#else
#define DBG_PRINT_STR(s)  
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dma\nv\dma.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************************* DMA Manager *****************************\
*                                                                           *
* Module: DMA.C                                                             *
*   The DMA engine is managed in this module.  All priviledged state and    *
*   object interaction is handled here.                                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <fifo.h>
#include <dma.h>
#include <gr.h>   
#include <fb.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "smp.h"

RM_STATUS dmaCreate
(
    VOID*               pDevHandle,
    PCLASSOBJECT        ClassObject,
    U032                UserName,
    POBJECT             *NewObject,
    VOID*               pCreateParms
)
{
    PHWINFO     pDev = (PHWINFO) pDevHandle;
    RM_STATUS   status = RM_OK;
    PDMAOBJECT  DmaObject;

    status = osAllocMem((VOID **)&DmaObject, sizeof(DMAOBJECT));
    if (status)
        return (status);
    DmaObject->State      = 0;
    DmaObject->Valid      = FALSE;
    DmaObject->LockHandle = 0;

    //
    // Initialize HAL info data.
    //
    DmaObject->HalInfo.PteArray     = NULL;
    DmaObject->HalInfo.Instance     = NULL;
    DmaObject->HalInfo.classNum     = ClassObject->Base.ThisClass->Type;
    DmaObject->HalInfo.MemoryClass  = 0;
    DmaObject->HalInfo.Flags        = 0;

    //
    // Add to dma context table.
    //
    DmaObject->Next       = pDev->DBDmaList;
    pDev->DBDmaList       = DmaObject;
    *NewObject            = (POBJECT)DmaObject;
    
#ifdef RM20
    //
    // Initialize the DMA object's client handle
    //
    CliGetClientHandle(&DmaObject->ClientHandle);
#endif    
    //
    // Get the address space associated with this DMA object
    //
    // Assume this is a system memory context first.  We may
    // reassign it later when we're looking at the physical
    // page locations.
    //
    DmaObject->HalInfo.AddressSpace = ADDR_SYSMEM;
    
#ifdef LEGACY_ARCH    
    //
    // Since we're about to put this new (unallocated) dma context
    // in the hash table, we need to point it at some PTE.  Point it
    // at an empty one so if anyone attempts to use this context
    // before its allocated, we'll get an error.  The PTE will be
    // exchanged with a valid entry once the dma context gets
    // allocated (locked).
    //
    // This step will disappear once we have the all-in-one
    // NvAllocDma() routine.
    //
    switch (ClassObject->Base.ThisClass->Type)  //KJK
    {
        case NV1_CONTEXT_DMA_TO_MEMORY:     
        case NV_CONTEXT_DMA_TO_MEMORY:
            DmaObject->HalInfo.Instance = pDev->Dma.DmaToMemEmptyInstance;
            break;
        case NV1_CONTEXT_DMA_FROM_MEMORY:     
        case NV_CONTEXT_DMA_FROM_MEMORY:
            DmaObject->HalInfo.Instance = pDev->Dma.DmaFromMemEmptyInstance;
            break;
        case NV1_CONTEXT_DMA_IN_MEMORY:     
        case NV_CONTEXT_DMA_IN_MEMORY:
            DmaObject->HalInfo.Instance = pDev->Dma.DmaInMemEmptyInstance;
            break;
    }            
#endif // LEGACY_ARCH
        
    DmaObject->Base.Name  = UserName;
    DmaObject->Base.ChID  = ClassObject->Base.ChID;
    
#ifdef LEGACY_ARCH    
    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &DmaObject->Base, 
                                      DmaObject->Base.ChID, 
                                      DmaObject->HalInfo.Instance);

    if (status)
        return (status);                               
#endif
    
    return (status);
    
}
//
// Delete NV_CONTEXT_DMA_??_MEMORY object.
//
RM_STATUS dmaDelete
(
    VOID*   pDevHandle,
    POBJECT DelObject
)
{
    PHWINFO     pDev = (PHWINFO) pDevHandle;
    RM_STATUS   status;
    PDMAOBJECT  DmaObject;
    PDMAOBJECT  DmaDelete;
    
    DmaObject = (PDMAOBJECT)DelObject;
    status = RM_OK;
    
#ifdef LEGACY_ARCH
    //
    // If there are objects that are currently using this context, we are not allowed
    // to remove the dma context from the chip (hash).  We can unlock it (leaving it 
    // at a NULL PTE), but we can't just yank the whole thing.
    //
    // We probably need to scan all of instance memory and all on-chip context caches
    // and clear out any usage of this object.
    //
    // KJK How do we handle this correctly????  For now, just yank it.
    //
    status = fifoDeleteObjectInstance(pDev, DelObject, DelObject->ChID);
    if (status)
        return (status);
#endif        
    //
    // NOTE: In the new architecture, it is assumed that this object has 
    //       been removed from the hash table (if necessary).
    
    //
    // Are we locked somewhere?
    //
    if (DmaObject->Valid)
    {
        //
        // Free all memory allocated to this object.
        //
        if (DmaObject->HalInfo.PteArray)
        {
            //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: DMA buffer resoures still allocated at delete time!\n\r");
            //DBG_BREAKPOINT();
            dmaFreeInstance(pDev, DmaObject);
            osUnlockUserMem(
						    pDev,
						    DmaObject->Base.ChID,
                            (VOID*)DmaObject->HalInfo.BufferBase,
                            DmaObject->DescAddr,
                            DmaObject->HalInfo.AddressSpace,
                            DmaObject->DescLimit,
                            DmaObject->HalInfo.PteCount,
                            DmaObject->LockHandle,
                            (DmaObject->Base.Class->Type == NV1_CONTEXT_DMA_TO_MEMORY) ||
                            (DmaObject->Base.Class->Type == NV_CONTEXT_DMA_TO_MEMORY) ? TRUE : FALSE);
            osFreeMem(DmaObject->HalInfo.PteArray);
            DmaObject->HalInfo.PteArray = NULL;
        }
        if (pDev->DBDmaList == NULL)        
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: DMA list NULL in DMADELETE!\n\n");
            DBG_BREAKPOINT();
        }

        //
        // Detach from DMA list.
        //
        if (pDev->DBDmaList == DmaObject)
            pDev->DBDmaList = DmaObject->Next;
        else
        {
            DmaDelete = pDev->DBDmaList;
            while (DmaDelete->Next && DmaDelete->Next != DmaObject)
            {
                DBG_VAL_PTR(DmaDelete);
                DmaDelete = DmaDelete->Next;
            }
            if (DmaDelete->Next)
                DmaDelete->Next = DmaObject->Next;
        }    
        status = osFreeMem(DmaObject);
    }
    
    return (status);
}

//
// Find a specific DMA object based upon its instance
//
RM_STATUS dmaContextInstanceToObject
(
    PHWINFO  pDev,
    U032     ChID,
    U032     Instance,
    PDMAOBJECT *DmaObject
)
{
    PDMAOBJECT TempDmaList;
    U032 hClient;
    RM_STATUS status;
    
    //
    // Are there any dma objects available?
    //
    if (!pDev->DBDmaList)
    {    
        *DmaObject = NULL;    
        return (RM_ERR_BAD_OBJECT);
    }        
        
#ifdef RM20  
    // First we must establish a client via the Channel ID.
    status = CliGetClientHandleFromChID(pDev, ChID, &hClient);
    if (status)
    {
        *DmaObject = NULL;    
        return (status);
    }
      
    //
    // Walk the list looking for this object by matching the client and the instance
    //
    TempDmaList = pDev->DBDmaList;
    while (TempDmaList)        
    {
        if ((TempDmaList->ClientHandle == hClient) && (TempDmaList->HalInfo.Instance == Instance))
        {
            //
            // Found it!
            //
            *DmaObject = TempDmaList;
            return (RM_OK);
        }
        TempDmaList = TempDmaList->Next;
    }
#else
    //
    // Walk the list looking for this object by matching the channel and the instance
    //
    TempDmaList = pDev->DBDmaList;
    while (TempDmaList)        
    {
        if ((TempDmaList->Base.ChID == ChID) && (TempDmaList->HalInfo.Instance == Instance))
        {
            //
            // Found it!
            //
            *DmaObject = TempDmaList;
            return (RM_OK);
        }
        TempDmaList = TempDmaList->Next;
    }
#endif
    *DmaObject = NULL;    
    return (RM_ERR_BAD_OBJECT);        
}

//
// Validate DMA object name.
//
RM_STATUS dmaValidateObjectName
(
    PHWINFO     pDev,
    V032        ObjectName,
    U032        ChID,
    PDMAOBJECT *DmaObject
)
{
    U032 hClient;
    RM_STATUS status;

    //
    // Check for NULL object.
    //
    if (ObjectName == NV1_NULL_OBJECT)
    {
        *DmaObject = NULL;
        return (RM_WARN_NULL_OBJECT);
    }
    status = fifoSearchObject(pDev, ObjectName, ChID, (POBJECT *)DmaObject);
    if (status)
    {
#ifdef RM20
        // attempt to find the object in the global DMA list
        // the client handle is also needed for this lookup
        status = CliGetClientHandleFromChID(pDev, ChID, &hClient);
        if (status)
        {
            *DmaObject = NULL;
            return (status);
        }
        status = dmaFindContext(pDev, ObjectName, hClient, DmaObject);
        if (status)
        {
            *DmaObject = NULL;
            return (status);
        }
        
#ifdef LEGACY_ARCH
        // CWJ: DMA objects don't exist in the FIFO tree with the new arch.
        // add the DMA context to the FIFO's object tree if it is unused
        if ((*DmaObject)->Base.ChID == INVALID_CHID)
        {
            (*DmaObject)->Base.ChID = ChID;
            status = fifoAddObject(pDev, (POBJECT)*DmaObject);
            if (status)
            {
                return (status);
            }
        }
        else
        {
            // return RM_ERR_BAD_DMA_SPECIFIER;
        }
#endif
#else
        // not finding the object in the tree is an error
        *DmaObject = NULL;
        return (status);
#endif // RM20
    }
    if (((*DmaObject)->Base.Class->Type != NV1_CONTEXT_DMA_FROM_MEMORY)
    &&  ((*DmaObject)->Base.Class->Type != NV1_CONTEXT_DMA_TO_MEMORY)
    &&  ((*DmaObject)->Base.Class->Type != NV1_CONTEXT_DMA_IN_MEMORY)
    &&  ((*DmaObject)->Base.Class->Type != NV_CONTEXT_DMA_FROM_MEMORY)
    &&  ((*DmaObject)->Base.Class->Type != NV_CONTEXT_DMA_TO_MEMORY)
    &&  ((*DmaObject)->Base.Class->Type != NV_CONTEXT_DMA_IN_MEMORY))
        return (RM_ERR_OBJECT_TYPE_MISMATCH);
    return (RM_OK);
}

#ifdef RM20
// find a DMA context in the list
RM_STATUS dmaFindContext(PHWINFO pDev, U032 id, U032 hClient, PDMAOBJECT *ppDmaObject)
{
    for (*ppDmaObject = pDev->DBDmaList; *ppDmaObject; *ppDmaObject = (*ppDmaObject)->Next)
        if (((*ppDmaObject)->Base.Name == id) &&
                ((*ppDmaObject)->ClientHandle == hClient))
            break;

    return (*ppDmaObject) ? RM_OK : 1;

} // end of dmaFindContext()
#endif // RM20

RM_STATUS dmaValidateXlate
(
    PDMAOBJECT DmaObject,
    U032       Start,
    U032       Length
)
{
    if (DmaObject == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid DMA context in dmaValidateXlate\n\r");
        DBG_BREAKPOINT();
        return (RM_ERR_INVALID_XLATE);
    }
    DBG_VAL_PTR(DmaObject);
#if DEBUG
    if ((DmaObject->Base.Class->Type != NV1_CONTEXT_DMA_TO_MEMORY)
    &&  (DmaObject->Base.Class->Type != NV1_CONTEXT_DMA_FROM_MEMORY)
    &&  (DmaObject->Base.Class->Type != NV1_CONTEXT_DMA_IN_MEMORY)
    &&  (DmaObject->Base.Class->Type != NV_CONTEXT_DMA_TO_MEMORY)
    &&  (DmaObject->Base.Class->Type != NV_CONTEXT_DMA_FROM_MEMORY)
    &&  (DmaObject->Base.Class->Type != NV_CONTEXT_DMA_IN_MEMORY))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Bad type in dmaValidateXlate\n\r");
        DBG_BREAKPOINT();
        return (RM_ERROR);
    }
#endif // DEBUG
    if (!DmaObject->Valid)
        return (RM_ERR_INVALID_XLATE);
    if ((Start + Length - 1) > DmaObject->DescLimit)
        return (RM_ERR_INVALID_START_LENGTH);
    return (RM_OK);
}

//
// Allocate and lock memory associated with this DMA object
//
RM_STATUS dmaAllocate
(
    PHWINFO    pDev,
    PDMAOBJECT DmaObject
)
{
    RM_STATUS status;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: DMA Allocate\n\r");

    DBG_VAL_PTR(DmaObject);
    //
    // Make sure its valid.
    //
    if (!DmaObject->Valid)
        return (RM_ERR_INVALID_XLATE);
    //
    // Get memory translation.
    //
    if (!DmaObject->HalInfo.PteArray)
    {
        //
        // Save off class of this dma context object.
        //
        DmaObject->HalInfo.classNum      = DmaObject->Base.ThisClass->Type;

        //
        // These members are for future use to make sure we pass
        // any hardware error checking involving new context dma
        // class parameters.
        // 
        DmaObject->HalInfo.Flags      = 0;
        DmaObject->HalInfo.MemoryClass = 0;

        //
        // Calculate page table values.
        //    
        DmaObject->HalInfo.BufferSize = DmaObject->DescLimit  + 1;
        osCalculatePteAdjust(pDev, DmaObject->HalInfo.AddressSpace, DmaObject->DescAddr, &DmaObject->HalInfo.PteAdjust);
        DmaObject->HalInfo.PteLimit   = DmaObject->DescLimit; //DmaObject->BufferSize + DmaObject->PteAdjust;
        DmaObject->HalInfo.PteCount   =
            (DmaObject->HalInfo.PteLimit + DmaObject->HalInfo.PteAdjust + RM_PAGE_SIZE - 1) >> RM_PAGE_SHIFT;
        status = osAllocMem((VOID **)&(DmaObject->HalInfo.PteArray), DmaObject->HalInfo.PteCount * 4);
        if (status)
        {
            DmaObject->HalInfo.BufferBase = NULL;
            DmaObject->HalInfo.PteArray   = NULL;
            return (RM_ERR_NO_FREE_MEM);
        }

        //
        // Lock and map DMA buffer.
        //    
        if (osLockUserMem(
						  pDev,
						  DmaObject->Base.ChID,
                          DmaObject->DescSelector,
                          DmaObject->DescOffset,
                          DmaObject->DescAddr,
                          &(DmaObject->HalInfo.AddressSpace),
                          DmaObject->DescLimit,
                          DmaObject->HalInfo.PteCount,
                          DmaObject->HalInfo.PteArray,
                          (VOID**)&(DmaObject->HalInfo.BufferBase),
                          &(DmaObject->LockHandle)) != RM_OK)
        {
            osFreeMem(DmaObject->HalInfo.PteArray);
            DmaObject->HalInfo.BufferBase = NULL;
            DmaObject->HalInfo.PteArray   = NULL;
            return (RM_ERR_DMA_MEM_NOT_LOCKED);
        }
        //
        // Get DMA instance for page table mapping.
        //
        status = dmaAllocInstance(pDev, DmaObject);
        if (status)
        {
            DmaObject->Valid = FALSE;
            osUnlockUserMem(
							pDev,
							DmaObject->Base.ChID,
                            (VOID*)DmaObject->HalInfo.BufferBase,
                            DmaObject->DescAddr,
                            DmaObject->HalInfo.AddressSpace,
                            DmaObject->DescLimit,
                            DmaObject->HalInfo.PteCount,
                            DmaObject->LockHandle,
                            (DmaObject->Base.Class->Type == NV1_CONTEXT_DMA_TO_MEMORY) ||
                            (DmaObject->Base.Class->Type == NV_CONTEXT_DMA_TO_MEMORY) ? TRUE : FALSE);
            osFreeMem(DmaObject->HalInfo.PteArray);
            DmaObject->HalInfo.BufferBase = NULL;
            DmaObject->HalInfo.PteArray   = NULL;
            return (status);
        }

        //
        // Call into HAL to handle h/w-dependent initialization.
        //
        status = nvHalDmaAlloc(pDev, &DmaObject->HalInfo);
        if (status)
        {
            DmaObject->Valid = FALSE;
            osUnlockUserMem(
							pDev,
							DmaObject->Base.ChID,
                            (VOID*)DmaObject->HalInfo.BufferBase,
                            DmaObject->DescAddr,
                            DmaObject->HalInfo.AddressSpace,
                            DmaObject->DescLimit,
                            DmaObject->HalInfo.PteCount,
                            DmaObject->LockHandle,
                            (DmaObject->Base.Class->Type == NV1_CONTEXT_DMA_TO_MEMORY) ||
                            (DmaObject->Base.Class->Type == NV_CONTEXT_DMA_TO_MEMORY) ? TRUE : FALSE);
            osFreeMem(DmaObject->HalInfo.PteArray);
            DmaObject->HalInfo.BufferBase = NULL;
            DmaObject->HalInfo.PteArray   = NULL;
            return (RM_ERR_BAD_DMA_SPECIFIER);      // ???
        }
    }

    return (RM_OK);
}

RM_STATUS dmaDeallocate
(
    PHWINFO    pDev,
    PDMAOBJECT DmaObject
)
{
    PNODE             node;
    U032              ChID;
    U032              Instance;
    U032              EngTag;

    //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Dma Dealloc\n\r");

    DBG_VAL_PTR(DmaObject);
    //
    // Check for resources to free up.
    //
    if (DmaObject->HalInfo.PteArray)
    {
        //
        // If there are objects that are currently using this context, we cannot allow any
        // modifications!!
        //
        for (ChID = 0 ; ChID < NUM_FIFOS ; ChID++)
        {
            if (pDev->DBfifoTable[ChID].InUse)
            {

                // 
                // Go find the minimum value (>0) and start there.  That way we're
                // sure to visit every node.
                //
                btreeEnumStart(0, &node, pDev->DBfifoTable[ChID].ObjectTree);

                while (node != NULL)
                {
                    //
                    // If this is a hardware object
                    //
                    EngTag = ENGDECL_FIELD(*((POBJECT)(node->Data))->Class->EngineDecl, _TAG);
                    if (EngTag == GR_ENGINE_TAG)
                    {
                        //
                        // Find the dma context field in this object's context instance
                        //
                        Instance = ((PCOMMONOBJECT)(node->Data))->Instance;
                        
                        //
                        // If it is currently being used by any object, don't allow
                        // any adjustments
                        //
                        if (Instance)
                        {
                            if (RAM_RD_ISF(Instance, _PRAMIN_CTX_1, _NOTIFY_INSTANCE) == DmaObject->HalInfo.Instance)
                                return(NVFFE_NOTIFICATION_STATUS_ERROR_STATE_IN_USE);
                            if (RAM_RD_ISF(Instance, _PRAMIN_CTX_2, _DMA_0_INSTANCE) == DmaObject->HalInfo.Instance)
                                return(NVFFE_NOTIFICATION_STATUS_ERROR_STATE_IN_USE);
                            if (RAM_RD_ISF(Instance, _PRAMIN_CTX_2, _DMA_1_INSTANCE) == DmaObject->HalInfo.Instance)
                                return(NVFFE_NOTIFICATION_STATUS_ERROR_STATE_IN_USE);
                        }                            

                    }

                    btreeEnumNext(&node, pDev->DBfifoTable[ChID].ObjectTree);
                }
            }
        }

        //
        // Now free the DMA object
        //
        dmaFreeInstance(pDev, DmaObject);
        osUnlockUserMem(
						pDev,
						DmaObject->Base.ChID,
                        (VOID*)DmaObject->HalInfo.BufferBase,
                        DmaObject->DescAddr,
                        DmaObject->HalInfo.AddressSpace,
                        DmaObject->DescLimit,
                        DmaObject->HalInfo.PteCount,
                        DmaObject->LockHandle,
                        (DmaObject->Base.Class->Type == NV1_CONTEXT_DMA_TO_MEMORY) ||
                        (DmaObject->Base.Class->Type == NV_CONTEXT_DMA_TO_MEMORY) ? TRUE : FALSE);
        osFreeMem(DmaObject->HalInfo.PteArray);
        DmaObject->HalInfo.BufferBase = NULL;
        DmaObject->HalInfo.PteArray   = NULL;
    }
    
#ifdef LEGACY_ARCH
    //
    // Point back to the NULL PTE
    //
    switch (DmaObject->Base.Class->Type)
    {
        case NV1_CONTEXT_DMA_TO_MEMORY:     
        case NV_CONTEXT_DMA_TO_MEMORY:
            DmaObject->HalInfo.Instance = pDev->Dma.DmaToMemEmptyInstance;
            break;
        case NV1_CONTEXT_DMA_FROM_MEMORY:     
        case NV_CONTEXT_DMA_FROM_MEMORY:
            DmaObject->HalInfo.Instance = pDev->Dma.DmaFromMemEmptyInstance;
            break;
        case NV1_CONTEXT_DMA_IN_MEMORY:     
        case NV_CONTEXT_DMA_IN_MEMORY:
            DmaObject->HalInfo.Instance = pDev->Dma.DmaInMemEmptyInstance;
            break;
    }            
#endif LEGACY_ARCH
    

    return (RM_OK);
}

//
// Return the mapped address of a DMA buffer.
// We need to special case an ADDR_FBMEM mapping, since RmAllocContextDma converted
// the BufferBase field to an FB offset. So to return the correct mapping, we use our
// RM mapping to the FB memory.
//
RM_STATUS dmaGetMappedAddress
(
    PHWINFO    pDev,
    PDMAOBJECT DmaObject,
    U032       Start,
    U032       Length,
    VOID     **Address
)
{
    RM_STATUS status;

    if ((DmaObject == NULL) || (!DmaObject->Valid))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid DMA context in dmaGetMappedAddress\n\r");
        DBG_BREAKPOINT();
        return (RM_ERR_INVALID_XLATE);
    }
    DBG_VAL_PTR(DmaObject);
    status = dmaValidateXlate(DmaObject, Start, Length);
    if (status)
        return (status);
    if (!DmaObject->HalInfo.PteArray ||
        (!DmaObject->HalInfo.BufferBase && DmaObject->HalInfo.AddressSpace != ADDR_FBMEM))
        return (RM_ERR_DMA_MEM_NOT_LOCKED);
	if (DmaObject->HalInfo.AddressSpace == ADDR_FBMEM)
        *Address = (U008*)fbAddr + (SIZE_PTR)DmaObject->HalInfo.BufferBase + Start;      // BufferBase is an FB offset
    else
	    *Address = (U008*)DmaObject->HalInfo.BufferBase + Start;
    return (RM_OK);
}

//
// Allocate a DMA instance in offscreen memory.  This involves locking
// the physical pages in memory, getting the translation table, and
// adding the object to the instance list.
//
RM_STATUS dmaAllocInstance
(
    PHWINFO pDev,
    PDMAOBJECT DmaObject
)
{
    RM_STATUS    status;

    DBG_VAL_PTR(DmaObject);
    //
    // Only alloc valid buffers.
    //    
    if ((DmaObject == NULL) || (!DmaObject->Valid))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid DMA context in dmaAllocInstance\n\r");
        DBG_BREAKPOINT();
        return (RM_ERR_INVALID_XLATE);
    }
    //
    // Allocate some instance memory.  Allocate an extra PTE so when the 
    // DMA engine prefetches, it won't fault on a last access to a page.
    //
    //
    status = nvHalDmaGetInstSize(pDev, &DmaObject->HalInfo);
    if (status)
        return (RM_ERR_BAD_DMA_SPECIFIER);      // ???
    status = fbAllocInstMem(pDev, &(DmaObject->HalInfo.Instance), DmaObject->HalInfo.NumUnits);
    if (status)
        return (status);
    
    //
    // Is this supposed to be a real AGP context?  We need to verify the addresses
    // fall within the GART space that DirectDraw has already told us about.  If not,
    // we must assume this is normal PCI memory and treat it as such.
    //
    // This check is not for the NV-specific AGP implementation.  That approach
    // uses our own GART.
    //
    // NOTE: This isn't needed anymore now that osGetAddressInfo does its own internal
    // scan for AGP memory.  But keep it around in case we need it back in the future.
    //
    /*
    if ((DmaObject->AddressSpace == ADDR_AGPMEM) && !pDev->Chip.NVAGPEnabled)
    {
        if (!((DmaObject->DescOffset >= pDev->Mapping.AGPLinearStart) 
            && (DmaObject->DescOffset <= (pDev->Mapping.AGPLinearStart + pDev->Mapping.AGPLimit))))
                // not really AGP memory
                DmaObject->AddressSpace = ADDR_SYSMEM;
    }
    */

    return (RM_OK);
}
//
// Free DAM instance memory associated with a DMA context and unlock the pages.
//
RM_STATUS dmaFreeInstance
(
    PHWINFO    pDev,
    PDMAOBJECT DmaObject
)
{
    DBG_VAL_PTR(DmaObject);
    if (DmaObject == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NULL object in dmaFreeInstance!\n\r");
        return (RM_OK);
    }
    //
    // Free instance page table plus guard page.
    //
    fbFreeInstMem(pDev, DmaObject->HalInfo.Instance, DmaObject->HalInfo.NumUnits);
    DmaObject->HalInfo.Instance   = 0;

    return (RM_OK);    
}

RM_STATUS dmaRegisterToDevice
(
    PHWINFO pDev, 
    PCLI_DMA_INFO pDmaInfo, 
    PDMAOBJECT *ppDmaObject
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLASS      DmaClass;
    CLASSOBJECT DmaClassObject;
    PDMAOBJECT  pDmaObject;

    rmStatus = classGetClass(&pDev->classDB, pDmaInfo->Access, &DmaClass);
    if (rmStatus)
        return rmStatus;

    // initialize parts of DmaClassObject for use in dmaCreate
    DmaClassObject.Base.ChID = INVALID_CHID;
    DmaClassObject.Base.ThisClass = DmaClass;
    rmStatus = dmaCreate((VOID*)pDev, &DmaClassObject, 0, (POBJECT *)&pDmaObject, NULL);

    if (rmStatus)
        return rmStatus;
    pDmaObject->Base.Name               = pDmaInfo->Handle;
    pDmaObject->Base.ChID               = INVALID_CHID;
    pDmaObject->Base.Class              = DmaClass;
    pDmaObject->Base.Subchannel         = 0;
    pDmaObject->Base.Next               = 0;
    pDmaObject->Base.NotifyXlate        = 0;
    pDmaObject->Base.NotifyAction       = 0;
    pDmaObject->Base.NotifyTrigger      = 0;
    pDmaObject->DescSelector            = pDmaInfo->DescSelector;
    pDmaObject->DescOffset              = pDmaInfo->DescOffset;
    pDmaObject->DescLimit               = pDmaInfo->DescLimit;
    pDmaObject->DescAddr                = pDmaInfo->DescAddr;
    pDmaObject->LockCount               = 0;
    pDmaObject->LockHandle              = pDmaInfo->LockHandle;
    pDmaObject->Valid                   = TRUE;
    pDmaObject->NotifyActionHandle      = 0;
    pDmaObject->HalInfo.BufferBase      = (VOID_PTR)pDmaInfo->BufferBase;
    pDmaObject->HalInfo.BufferSize      = pDmaInfo->BufferSize;
    pDmaObject->HalInfo.PteCount        = pDmaInfo->PteCount;

    pDmaObject->HalInfo.PteAdjust       = pDmaInfo->PteAdjust;
    pDmaObject->HalInfo.PteLimit        = pDmaInfo->PteLimit;
    pDmaObject->HalInfo.PteArray        = pDmaInfo->PteArray;
    pDmaObject->HalInfo.AddressSpace    = pDmaInfo->AddressSpace;

    // get DMA instance for page table mapping in the given device
    rmStatus = dmaAllocInstance(pDev, pDmaObject);
    if (rmStatus != RM_OK)
    {
        dmaDelete((VOID*)pDev, (POBJECT)pDmaObject);
        return rmStatus;
    }

    //
    // Call into HAL to handle h/w-dependent initialization.
    //
    if (nvHalDmaAlloc(pDev, &pDmaObject->HalInfo) != RM_OK)
    {
        return (RM_ERR_BAD_DMA_SPECIFIER);      // ???
    }

    // Success.
    *ppDmaObject = pDmaObject;
    return RM_OK;
}

RM_STATUS dmaUnregisterFromDevice
(
   PHWINFO     pDev,
   PDMAOBJECT  pDmaObject
)
{
    RM_STATUS rmStatus;

    //
    // Call into HAL to release h/w-dependent resources.
    //
    if (nvHalDmaFree(pDev, &pDmaObject->HalInfo) != RM_OK)
    {
        return (RM_ERR_BAD_DMA_SPECIFIER);      // ???
    }
    
    rmStatus = dmaFreeInstance(pDev, pDmaObject);
    if (rmStatus)
    {
        return rmStatus;
    }

    // delete DMA object for the device in the context of the device
    rmStatus = dmaDelete((VOID*)pDev, (POBJECT)pDmaObject);
    return rmStatus;
}

RM_STATUS dmaBindToChannel
(
    PHWINFO    pDev, 
    PDMAOBJECT pDmaObject, 
    U032       ChID
)
{
    RM_STATUS rmStatus = RM_OK;
    
    //
    // CWJ: don't add the DMA object to the pDev->DBfifoTable[ChID] in NV4. We don't
    // use the pDev->DBfifoTable[] for look-ups in NV4 and since there's a single
    // Node field it's unable to exist on more than a one fifoTable, just
    // skip it.
    //
    // rmStatus = fifoAddDmaObject(pDev, (POBJECT)pDmaObject, pFifoInfo->ChID);
    // if (rmStatus != RM_OK)
    // {
    //  return rmStatus;
    // }

    // update the hash table
    rmStatus = fifoUpdateObjectInstance(pDev,
                                        &pDmaObject->Base,
                                        ChID,
                                        pDmaObject->HalInfo.Instance);

    return rmStatus;
}

RM_STATUS dmaUnbindFromChannel
(
   PHWINFO    pDev,
   PDMAOBJECT pDmaObject,
   U032       ChID
)
{
    RM_STATUS rmStatus;
    
    // Delete this dma context object for this ChID from the hash table.
    rmStatus = fifoDeleteObjectInstance(pDev, (POBJECT)pDmaObject, ChID);
    return rmStatus;
}

//---------------------------------------------------------------------------
//
//  DMA object methods.
//
//---------------------------------------------------------------------------

//
// Validate and calculate new specifier parameters.
//
RM_STATUS mthdSetDmaSpecifier
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PDMAOBJECT DmaObject;
    PCLASS pClass;
    RM_STATUS  status;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: mthdDmaSpecifier\n\r");

    DmaObject = (PDMAOBJECT)Object;
    pClass = Object->Class;

    //
    // Make sure the graphics engine is idle before we steal the DMA context
    //
    GR_IDLE();

    //
    // If already in use...
    //
    if (DmaObject->Valid)
    {
        //
        // Unallocate the previous lock
        //
        status = dmaDeallocate(pDev, DmaObject);
        if (status)
            return (status);
        //
        // And update the instance
        //
        status = fifoUpdateObjectInstance(pDev, 
                                          &DmaObject->Base, 
                                          DmaObject->Base.ChID, 
                                          DmaObject->HalInfo.Instance);
        if (status)
            return (status);                               
            
    }    
    //
    // Validate specifier.
    //
    DmaObject->Valid = FALSE;
    switch (Offset)
    {
        case 0x0300:
            DmaObject->State        = DMA_SET_DESC_0;
            DmaObject->DescOffset   = (VOID*)((NV_UINTPTR_T)Data);
            break;
        case 0x0304:
            if (DmaObject->State != DMA_SET_DESC_0)
                return (RM_ERR_METHOD_COUNT);
            DmaObject->State        = DMA_SET_DESC_1;
            DmaObject->DescSelector = Data;
            break;
        case 0x0308:
            if (DmaObject->State != DMA_SET_DESC_1)
                return (RM_ERR_METHOD_COUNT);
            DmaObject->State     = DMA_SET_DESC_2;
            DmaObject->DescLimit = Data;

            //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetDesc1 = ", Data);
            //
            // If the user sets a 0 limit on the DMA object, then
            // he is not using the buffer. Don't return an error
            // but also don't validate the buffer.
            //
            if (DmaObject->DescLimit != 0)
            {
               //
               // Validate DMA buffer address.
               //
               if (osGetAddressInfo(pDev,
                                    DmaObject->Base.ChID, 
                                    DmaObject->DescSelector,
                                    &(DmaObject->DescOffset),
                                    DmaObject->DescLimit,
                                    &(DmaObject->DescAddr), 
                                    &(DmaObject->HalInfo.AddressSpace)) != RM_OK)
                   return (RM_ERR_BAD_DMA_SPECIFIER);
                //
                // Now attempt to lock the context
                //                   
                DmaObject->Valid = TRUE;
                status = dmaAllocate(pDev, DmaObject);
                if (status)
                    return (status);
                //
                // And update the instance
                //
                status = fifoUpdateObjectInstance(pDev, 
                                                  &DmaObject->Base, 
                                                  DmaObject->Base.ChID, 
                                                  DmaObject->HalInfo.Instance);
                if (status)
                    return (status);                               
                                    
            }
    }
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  DMA buffer object methods.
//
//---------------------------------------------------------------------------

RM_STATUS mthdSetBufferCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PBUFFEROBJECT BuffObject;
    U032          BuffNum;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum    = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    return(dmaSetBufferCtxDma(pDev, BuffObject, &BuffObject->Buffer[BuffNum], Offset, Data));
}

RM_STATUS dmaSetBufferCtxDma
(
    PHWINFO       pDev, 
    PBUFFEROBJECT BuffObject,
    PBUFFER       pBuffer,
    U032          Offset,
    V032          Data
)
{
    RM_STATUS     status;

    //
    // Check for busy buffer.
    //
/*    
    if (pBuffer->State != BUFFER_IDLE)
    {
        osError(&BuffObject->Base, Offset, Data, status);
        return (RM_ERR_DMA_IN_USE);
    }
*/    
    //
    // Check for a previous translation.
    //
    //if (pBuffer->Xlate)
    //    dmaDetach(pBuffer->Xlate);
    //
    // Check for NULL object.
    //
    if (Data == NV1_NULL_OBJECT)
    {
        pBuffer->Xlate = NULL;
        return (RM_OK);
    }
    //
    // Validate dma buffer.
    //
    status = dmaValidateObjectName(pDev, Data,
                                   BuffObject->Base.ChID,
                                   &pBuffer->Xlate);
    if (status)
    {
        osError(&BuffObject->Base, Offset, Data, status);
        return (status);
    }
    //
    // Set the method to be used for notification on this buffer
    //
    pBuffer->NotifyMethod = Offset;
    return (status);
}

RM_STATUS mthdSetBufferStart
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    U032          BuffNum;
    PBUFFEROBJECT BuffObject;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    return(dmaSetBufferStart(BuffObject, &BuffObject->Buffer[BuffNum], Offset, Data));
}

RM_STATUS dmaSetBufferStart
(
    PBUFFEROBJECT BuffObject,
    PBUFFER       pBuffer,
    U032          Offset,
    V032          Data
)
{
    //
    // Check for busy buffer.
    //
/*    
    if (pBuffer->State != BUFFER_IDLE)
    {
        osError(&BuffObject->Base, Offset, Data, RM_ERR_DMA_IN_USE);
        return (RM_ERR_DMA_IN_USE);
    }
*/    
    pBuffer->Start = Data;
    return (RM_OK);
}

RM_STATUS mthdSetBufferLength
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    U032 BuffNum;
    PBUFFEROBJECT BuffObject;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    return(dmaSetBufferLength(BuffObject, &BuffObject->Buffer[BuffNum], Offset, Data));
}

RM_STATUS dmaSetBufferLength
(
    PBUFFEROBJECT BuffObject,
    PBUFFER       pBuffer,
    U032          Offset,
    V032          Data
)
{
    //
    // Check for busy buffer.
    //
/*    
    if (pBuffer->State != BUFFER_IDLE)
    {
        osError(&BuffObject->Base, Offset, Data, RM_ERR_DMA_IN_USE);
        return (RM_ERR_DMA_IN_USE);
    }
*/    
    pBuffer->Length = Data;
    return (RM_OK);
}

RM_STATUS mthdSetBufferPitch
(
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    U032 BuffNum;
    PBUFFEROBJECT BuffObject;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    return(dmaSetBufferPitch(BuffObject, &BuffObject->Buffer[BuffNum], Offset, Data));
}

RM_STATUS dmaSetBufferPitch
(
    PBUFFEROBJECT BuffObject,
    PBUFFER       pBuffer,
    U032          Offset,
    V032          Data
)
{
    //
    // Check for busy buffer.
    //
/*    
    if (pBuffer->State != BUFFER_IDLE)
    {
        osError(&BuffObject->Base, Offset, Data, RM_ERR_DMA_IN_USE);
        return (RM_ERR_DMA_IN_USE);
    }
*/    
    pBuffer->Pitch = Data;
    return (RM_OK);
}

RM_STATUS mthdSetSampleRate
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    ((PBUFFEROBJECT)Object)->Sample.Rate = Data;
    ((PBUFFEROBJECT)Object)->Sample.RateUpdate((PBUFFEROBJECT)Object);
    return (RM_OK);
}
RM_STATUS mthdSetSampleRateAdjust
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    ((PBUFFEROBJECT)Object)->Sample.RateAdjust = Data;
    ((PBUFFEROBJECT)Object)->Sample.RateUpdate((PBUFFEROBJECT)Object);
    return (RM_OK);
}
RM_STATUS mthdSetNumberChannels
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    ((PBUFFEROBJECT)Object)->Sample.NumChannels = Data;
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  DMA service routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dma\nv\dmastate.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/
/******************************* DMA Manager *******************************\
*                                                                           *
* Module: DMASTATE.C                                                        *
*   The DMA state is managed in this module.                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"


//
// Initialize DMA hardware.
//
RM_STATUS stateDma
(
    PHWINFO pDev,
    U032    msg
)
{
#ifdef KJK
    PDMAOBJECT DmaObject;
#endif
#ifdef LEGACY_ARCH
    RM_STATUS  status;
#endif
    
    switch (msg)
    {
        case STATE_UPDATE:
            break;
        case STATE_LOAD:

#ifdef LEGACY_ARCH
            //
            // Fill class-specific NULL DMA instances with something invalid
            //
            if (!pDev->Dma.DmaInMemEmptyInstance)
            {            
                status = fbAllocInstMem(pDev, &(pDev->Dma.DmaInMemEmptyInstance), 1);
                if (status == RM_OK)
                {
//                    INST_WR32(pDev->Dma.DmaInMemEmptyInstance, SF_OFFSET(NV_DMA_CLASS), NV1_CONTEXT_DMA_IN_MEMORY);
//                    INST_WR32(pDev->Dma.DmaInMemEmptyInstance, SF_OFFSET(NV_DMA_LIMIT),  0);
                    INST_WR32(pDev->Dma.DmaInMemEmptyInstance, SF_OFFSET(NV_DMA_CLASS), NV01_NULL);
                    INST_WR32(pDev->Dma.DmaInMemEmptyInstance, SF_OFFSET(NV_DMA_LIMIT), 0xFFFFFFFF);
                }
            }                
            if (!pDev->Dma.DmaToMemEmptyInstance)
            {            
                status = fbAllocInstMem(pDev, &(pDev->Dma.DmaToMemEmptyInstance), 1);
                if (status == RM_OK)
                {
//                    INST_WR32(pDev->Dma.DmaToMemEmptyInstance, SF_OFFSET(NV_DMA_CLASS), NV1_CONTEXT_DMA_TO_MEMORY);
//                    INST_WR32(pDev->Dma.DmaToMemEmptyInstance, SF_OFFSET(NV_DMA_LIMIT),  0);
                    INST_WR32(pDev->Dma.DmaToMemEmptyInstance, SF_OFFSET(NV_DMA_CLASS), NV01_NULL);
                    INST_WR32(pDev->Dma.DmaToMemEmptyInstance, SF_OFFSET(NV_DMA_LIMIT), 0xFFFFFFFF);
                }
            }                
            if (!pDev->Dma.DmaFromMemEmptyInstance)
            {            
                status = fbAllocInstMem(pDev, &(pDev->Dma.DmaFromMemEmptyInstance), 1);
                if (status == RM_OK)
                {
//                    INST_WR32(pDev->Dma.DmaFromMemEmptyInstance, SF_OFFSET(NV_DMA_CLASS), NV1_CONTEXT_DMA_FROM_MEMORY);
//                    INST_WR32(pDev->Dma.DmaFromMemEmptyInstance, SF_OFFSET(NV_DMA_LIMIT),  0);
                    INST_WR32(pDev->Dma.DmaFromMemEmptyInstance, SF_OFFSET(NV_DMA_CLASS), NV01_NULL);
                    INST_WR32(pDev->Dma.DmaFromMemEmptyInstance, SF_OFFSET(NV_DMA_LIMIT), 0xFFFFFFFF);
                }
            }                
#endif // LEGACY_ARCH

#ifdef KJK            
            //
            // Reload any DMA instances.
            //
            DmaObject = pDev->DBDmaList;
            while (DmaObject)
            {
                DBG_VAL_PTR(DmaObject);
                //
                // Load instance.
                //    
                if (DmaObject->State & DMA_RELOAD)
                {
                    //
                    // Get DMA instance for page table mapping.
                    //
                    if (dmaAllocInstance(DmaObject))
                    {
                        DmaObject->Valid = FALSE;
                        osUnlockUserMem(DmaObject->Base.ChID,
                                        DmaObject->BufferBase,
                                        DmaObject->DescAddr,
                                        DmaObject->AddressSpace,
                                        DmaObject->DescLimit,
                                        DmaObject->PteCount,
                                        DmaObject->LockHandle,
                                        DmaObject->Base.Class->Type == NV1_CONTEXT_DMA_TO_MEMORY ? TRUE : FALSE);
                        osFreeMem(DmaObject->PteArray);
                        DmaObject->PteArray = NULL;
                    }
                    DmaObject->State &= ~DMA_RELOAD;
                }
                DmaObject = DmaObject->Next;
            }
#endif //KJK
            break;
        case STATE_UNLOAD:
            //
            // Unload all DMA instances.
            //
#ifdef KJK            
            DmaObject = pDev->DBDmaList;
            while (DmaObject)
            {
                //
                // Unload instance.
                //    
                DBG_VAL_PTR(DmaObject);
                if (DmaObject->PteArray)
                {
                    dmaFreeInstance(pDev, DmaObject);
                    DmaObject->State |= DMA_RELOAD;
                }
                DmaObject = DmaObject->Next;
            }

            pDev->Dma.DmaInMemEmptyInstance = 0;
            pDev->Dma.DmaToMemEmptyInstance = 0;
            pDev->Dma.DmaFromMemEmptyInstance = 0;
#endif //KJK
            break;
        case STATE_INIT:
            pDev->DBDmaList = NULL;

#ifdef LEGACY_ARCH    
            pDev->Dma.DmaInMemEmptyInstance = 0;
            pDev->Dma.DmaToMemEmptyInstance = 0;
            pDev->Dma.DmaFromMemEmptyInstance = 0;
#endif // LEGACY_ARCH
            
            break;
        case STATE_DESTROY:
            break;
    }    
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dma\nv\event.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************************* DMA Manager *****************************\
*                                                                           *
* Module: EVENT.C                                                           *
*   Event notifications are handled in this module.  DMA report and OS      *
*   action are dealt with on a per-object basis.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <fifo.h>
#include <dma.h>   
#include <os.h>
#include <nv32.h>
#include "nvhw.h"


//---------------------------------------------------------------------------
//
//  Event Notification structure.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Event Object support.
//
//---------------------------------------------------------------------------

// Given the Parent Object, add the notify event.
RM_STATUS eventSetObjectEventNotify
(
   POBJECT ParentObject,
   U032    hObject,
   U032    NotifyIndex,
   U032    NotifyType,
   U064    Data
)
{
    PEVENTNOTIFICATION EventNotify;
    RM_STATUS          status;
    
    //
    // Create the event notification object
    //
    status = osAllocMem((VOID **)&EventNotify, sizeof(EVENTNOTIFICATION));
    if (status)
        return (status);

    //
    // Fill in the fields
    //
    EventNotify->Handle      = hObject;
    EventNotify->NotifyIndex = NotifyIndex;
    EventNotify->NotifyType  = NotifyType;
    EventNotify->Data        = Data;

    //
    // Now insert the event into the event chain of this object.  
    // Order doesn't really matter.
    //
    EventNotify->Next = ParentObject->NotifyEvent;
    ParentObject->NotifyEvent = EventNotify;
    
    return (RM_OK);        
}

//---------------------------------------------------------------------------
//
//  Event Notification support.
//
//---------------------------------------------------------------------------

//
// Given an object's name and fifo, insert a new event notifier into this object.
//
RM_STATUS eventSetEventNotify
(
    PHWINFO     pDev, 
    U032        ObjectName,
    U032        ChID,
    U032        NotifyIndex,
    U032        NotifyType,
    U064        Data
)
{
#ifdef LEGACY_ARCH
    POBJECT            Object;
    RM_STATUS          status;
    
    //
    // Find the parent object
    //
    if (fifoSearchObject(pDev, ObjectName, ChID, &Object) == RM_OK)
    {
        // Found the parent.
		status = eventSetObjectEventNotify(Object, 0/* object handle*/, 
		                                   NotifyIndex, NotifyType, Data);
    }
    else
		// Did not find the parent
        status = RM_ERROR;
        
    return status;        
#else
	// For the new architecture, this proc is not called.
    return RM_ERROR;
#endif
}    

RM_STATUS eventRemoveObjectEventNotify
(
   POBJECT ParentObject,
   U032    hObject
)
{
    PEVENTNOTIFICATION nextEvent, lastEvent;
    BOOL found = FALSE;
    
    // check for null list
    nextEvent = (void *) 0;
    if (ParentObject->NotifyEvent != NULL)
    {
        // check for head of list
        nextEvent = lastEvent = ParentObject->NotifyEvent;
        if ((nextEvent->Handle = hObject))
        {
            ParentObject->NotifyEvent = nextEvent->Next;
            found = TRUE;
        }
        else
        {
            // check for internal nodes
            nextEvent = nextEvent->Next;
            while (nextEvent)
            {
                if ((nextEvent->Handle = hObject))
                {
                    lastEvent->Next = nextEvent->Next;
                    found = TRUE;
                    break;
                }
                lastEvent = nextEvent;
                nextEvent = nextEvent->Next;
            }
        }
    }
    
    // delete the event if it was found
    if (found)
    {
        osFreeMem(nextEvent);
    }
    
    return (found) ? RM_OK : RM_ERROR;
        
} // end of eventRemoveObjectEventNotify()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\devinit\nv\nv15mem.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************************************************************************************************
*
*	Module: nv15mem.c
*
*	Description:
*		Device-specific memory sizing code, for Nv15 and NV11.
*
*	Revision History:
*		Original -- 1/00 Jeff Westerinen
*
**************************************************************************************************************/

#ifdef NV_PORTABLE

/* "portable" form for use outside resman and by external source customers */
/* look in devinit/portable/ for more details */
#include <nv_portable.h>
#include <nv_ref.h>
#include <nv10_ref.h>
#include <devinit.h>

#else	/* not NV_PORTABLE --> Nvidia internal */

#include <nvrm.h>
#include <nvhw.h>
#include <nv10_ref.h>
#include <os.h>
#include <devinit.h>

#endif

RM_STATUS Nv15MemConfigureClocks
(
    PHWINFO pDev,
    MEM_INIT_TABLE_NV15 memInitTable
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 clk;
    U032 memInitTableIndex;
    U032 M,N,P;
    U032 Head = 0;  // MPLL & NVPLL are on Head 0

    // get the index in the memory init table from scratch register 4
    CRTC_RD(NV_CIO_CRE_SCRATCH4__INDEX, memInitTableIndex, 0);
    memInitTableIndex >>= 4;
    
    // program NVCLK
    clk = memInitTable[memInitTableIndex].NVClk_PLL;
    dacCalcMNP(pDev, Head, clk, &M, &N, &P);
    REG_WR32(
        NV_PRAMDAC_NVPLL_COEFF, 
        DRF_NUM(_PRAMDAC, _NVPLL_COEFF, _MDIV, M) |
            DRF_NUM(_PRAMDAC, _NVPLL_COEFF, _NDIV, N) |
            DRF_NUM(_PRAMDAC, _NVPLL_COEFF, _PDIV, P)
    );
                                        
    // program MCLK -- double the clock if flags indicate DDR memory
    clk = memInitTable[memInitTableIndex].MClk_PLL;
    if (memInitTable[memInitTableIndex].Flags == DDR)
    {
        clk *= 2;
    }
    dacCalcMNP(pDev, Head, clk, &M, &N, &P);
    REG_WR32(
        NV_PRAMDAC_MPLL_COEFF, 
        DRF_NUM(_PRAMDAC, _MPLL_COEFF, _MDIV, M) |
            DRF_NUM(_PRAMDAC, _MPLL_COEFF, _NDIV, N) |
            DRF_NUM(_PRAMDAC, _MPLL_COEFF, _PDIV, P));
            
    return rmStatus;
    
} // end of Nv15MemConfigureClocks()

    
RM_STATUS Nv15MemConfigureMemory
(
    PHWINFO pDev,
    MEM_INIT_TABLE_NV15 memInitTable, 
    U032 SDRSeqTable[], 
    U032 DDRSeqTable[]
)
{
    RM_STATUS rmStatus = RM_OK;
    U032* seqTable;
    U032 memInitTableIndex, initValue;
    U032 memInitDataIndex = 0; 
    U032 seqTableIndex = 0;
    
    
    
    // get the index in the memory init table from scratch register 4
    CRTC_RD(NV_CIO_CRE_SCRATCH4__INDEX, memInitTableIndex, 0);
    memInitTableIndex >>= 4;
    
    // set proper sequence table
    switch (memInitTable[memInitTableIndex].Flags)
    {
        case SDR:
            seqTable = SDRSeqTable;
            break;
            
        case DDR:
            seqTable = DDRSeqTable;
            break;
            
        default:
            return RM_ERROR;
    }
    
    // execute the memory init sequence
    while (seqTable[seqTableIndex] != MEM_INIT_END_OF_SEQUENCE)
    {
        switch (seqTable[seqTableIndex])
        {
            case NV_PFB_PRE:
	            FLD_WR_DRF_DEF(_PFB,_PRE,_CMD,_PRECHARGE);
                break;
                
            case NV_PFB_PAD:
	            FLD_WR_DRF_DEF(_PFB,_PAD,_CKE,_NORMAL);
                break;
                
            case NV_PFB_REF:
	            FLD_WR_DRF_DEF(_PFB,_REF,_CMD,_REFRESH);
                break;
                
            case NV_PFB_EMRS:
                if ((initValue = memInitTable[memInitTableIndex].data[memInitDataIndex++]) != 0xffffffff)
                {
                    REG_WR32(NV_PFB_EMRS, initValue);
                }
                break;
                
            default:
                REG_WR32(seqTable[seqTableIndex], memInitTable[memInitTableIndex].data[memInitDataIndex++]);
                break;
        }
        seqTableIndex++;
    }
    
    return rmStatus;
    
} // end of Nv15MemConfigureMemory()



// end of nv15mem.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\devinit\portable\nv_portable.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

 /***************************************************************************\
|*                                 Typedefs                                  *|
 \***************************************************************************/

typedef unsigned char      NvV8;  /* "void": enumerated or multiple fields   */
typedef unsigned short     NvV16; /* "void": enumerated or multiple fields   */
typedef unsigned long      NvV32; /* "void": enumerated or multiple fields   */
typedef unsigned char      NvU8;  /* 0 to 255                                */
typedef unsigned short     NvU16; /* 0 to 65535                              */
typedef unsigned long      NvU32; /* 0 to 4294967295                         */
typedef signed char        NvS8;  /* -128 to 127                             */
typedef signed short       NvS16; /* -32768 to 32767                         */
typedef signed long        NvS32; /* -2147483648 to 2147483647               */
typedef float              NvF32; /* IEEE Single Precision (S1E8M23)         */
typedef double             NvF64; /* IEEE Double Precision (S1E11M52)        */


typedef unsigned char   U008;
typedef unsigned short  U016;
typedef unsigned long   U032;

typedef unsigned char   V008;
typedef unsigned short  V016;
typedef unsigned long   V032;

typedef unsigned long   BOOL;
typedef long            S032;



#define NULL 0

#define FALSE 0
#define TRUE  1


//
// Internal codes.
//

typedef U032 RM_STATUS;
#define NUM_RM_ERRORS                   22
#define RM_OK                           0x00000000
#define RM_ERROR                        0xFFFFFFFF
#define RM_WARN_NULL_OBJECT             (0x10000000|RM_OK)
#define RM_WARN_AUDIO_DISABLED          (0x20000000|RM_OK)
#define RM_WARN_GRAPHICS_DISABLED       (0x30000000|RM_OK)
#define RM_ERR_NO_FREE_MEM              (0x01000000|NV_OUT_OF_RESOURCES)
#define RM_ERR_MEM_NOT_FREED            (0x01010000|NV_OUT_OF_RESOURCES)
#define RM_ERR_PAGE_TABLE_NOT_AVAIL     (0x01020000|NV_OUT_OF_RESOURCES)
#define RM_ERR_NO_FREE_FIFOS            (0x02000000|NV_OUT_OF_RESOURCES)
#define RM_ERR_CANT_CREATE_CLASS_OBJS   (0x02010000|NV_OUT_OF_RESOURCES)
#define RM_ERR_BAD_OBJECT               (0x03000000|NV_NO_SUCH_OBJECT)
#define RM_ERR_INSERT_DUPLICATE_NAME    (0x03010000|NV_NAME_IN_USE)
#define RM_ERR_OBJECT_NOT_FOUND         (0x03020000|NV_NO_SUCH_OBJECT)
#define RM_ERR_CREATE_BAD_CLASS         (0x04000000|NV_NO_SUCH_OBJECT)
#define RM_ERR_DELETE_BAD_CLASS         (0x04010000|NV_NO_SUCH_OBJECT)
#define RM_ERR_FIFO_RUNOUT_OVERFLOW     (0x05000000|NV_FIFO_OVERFLOW)
#define RM_ERR_FIFO_BAD_ACCESS          (0x05010000|NV_RESERVED_ADDRESS)
#define RM_ERR_FIFO_OVERFLOW            (0x05020000|NV_FIFO_OVERFLOW)
#define RM_ERR_METHOD_ORDER             (0x06000000|NV_INCOMPLETE_METHOD)
#define RM_ERR_METHOD_COUNT             (0x06010000|NV_INCOMPLETE_METHOD)
#define RM_ERR_ILLEGAL_OBJECT           (0x06020000|NV_TYPE_CONFLICT)
#define RM_ERR_DMA_IN_USE               (0x07000000|NV_BUFFER_BUSY)
#define RM_ERR_BAD_DMA_SPECIFIER        (0x07010000|NV_TRANSLATION_VIOLATION)
#define RM_ERR_INVALID_XLATE            (0x07020000|NV_TRANSLATION_VIOLATION)
#define RM_ERR_INVALID_START_LENGTH     (0x07030000|NV_PROTECTION_VIOLATION)
#define RM_ERR_DMA_MEM_NOT_LOCKED       (0x07040000|NV_OUT_OF_RESOURCES)
#define RM_ERR_DMA_MEM_NOT_UNLOCKED     (0x07050000|NV_OUT_OF_RESOURCES)
#define RM_ERR_NOTIFY_IN_USE            (0x07060000|NV_BUFFER_BUSY)
#define RM_ERR_ILLEGAL_ADDRESS          (0x08000000|NV_ILLEGAL_ACCESS)
#define RM_ERR_BAD_ADDRESS              (0x08010000|NV_PROTECTION_VIOLATION)
#define RM_ERR_INVALID_COLOR_FORMAT     (0x09000000|NV_BAD_COLOR_FORMAT)
#define RM_ERR_INVALID_MONO_FORMAT      (0x09010000|NV_BAD_MONOCHROME_FORMAT)
#define RM_ERR_INVALID_AUDIO_FORMAT     (0x09020000|NV_BAD_AUDIO_FORMAT)
#define RM_ERR_INVALID_GAMEPORT_FORMAT  (0x09030000|NV_BAD_AUDIO_FORMAT)
#define RM_ERR_OBJECT_TYPE_MISMATCH     (0x0A000000|NV_TYPE_CONFLICT)
#define RM_ERR_NO_FREE_AUDIO_INSTANCES  (0x0B000000|NV_OUT_OF_RESOURCES)
#define RM_ERR_CODEC_INPUT_IN_USE       (0x0B010000|NV_OUT_OF_RESOURCES)
#define RM_ERR_AUDIO_DISABLED           (0x0B020000|NV_OUT_OF_RESOURCES)
#define RM_ERR_INCOMPLETE_PATCH         (0x0C000000|NV_INCOMPLETE_PATCH)
#define RM_ERR_INVALID_PATCH            (0x0C010000|NV_UNIMPLEMENTED_PATCH)
#define RM_ERR_PATCH_TOO_COMPLEX        (0x0C020000|NV_UNIMPLEMENTED_PATCH)
#define RM_ERR_MAX_PATCH_FANOUT         (0x0C030000|NV_UNIMPLEMENTED_PATCH)
#define RM_ERR_DEVICE_DISCONNECTED      (0x0C040000|NV_NO_CONNECTION)
#define RM_ERR_BUFFER_GAP               (0x0D000000|NV_BUFFER_GAP)
#define RM_ERR_INVALID_OS_NAME          (0x0E000000|NV_OS_NAME_ERROR)
#define RM_ERR_ILLEGAL_ACTION           (0x0E010000|NV_OS_NAME_ERROR)
// The DMA direction specified for the DMA object is not allowed in the
// specified address space.
#define RM_ERR_ILLEGAL_DIRECTION        (0x0E020000|NV_OS_NAME_ERROR)
#define RM_ERR_OUT_OF_TIMER_CALLBACKS   (0x0F000000|NV_OUT_OF_RESOURCES)

// Errors returned from the arch calls.
#define NV_ERROR_2                      0x0200
#define RM_ERR_OPERATING_SYSTEM         (0x00000001|NV_ERROR_2)
#define RM_ERR_BAD_OBJECT_PARENT        (0x00000002|NV_ERROR_2)
#define RM_ERR_BAD_OBJECT_HANDLE       	(0x00000003|NV_ERROR_2)
#define RM_ERR_OBJECT_IN_USE            (0x00000004|NV_ERROR_2)
#define RM_ERR_OBJECT_HAS_CHILDERN      (0x00000005|NV_ERROR_2)
#define RM_ERR_BAD_CLASS                (0x00000006|NV_ERROR_2)
#define RM_ERR_INSUFFICIENT_RESOURCES   (0x00000007|NV_ERROR_2)
#define RM_ERR_BAD_FLAGS                (0x00000008|NV_ERROR_2)
#define RM_ERR_BAD_BASE                 (0x00000009|NV_ERROR_2)
#define RM_ERR_BAD_LIMIT                (0x0000000A|NV_ERROR_2)
#define RM_ERR_PROTECTION_FAULT         (0x0000000B|NV_ERROR_2)
#define RM_ERR_MULTIPLE_MEMORY_TYPES    (0x0000000C|NV_ERROR_2)
#define RM_ERR_BAD_OBJECT_ERROR         (0x0000000D|NV_ERROR_2)
#define RM_ERR_BAD_OBJECT_BUFFER        (0x0000000E|NV_ERROR_2)
#define RM_ERR_BAD_OFFSET               (0x0000000F|NV_ERROR_2)


#define BIT(b)                  (1<<(b))
#define DEVICE_BASE(d)          (0?d)
#define DEVICE_EXTENT(d)        (1?d) - DEVICE_BASE(d) + 1
#define DRF_SHIFT(drf)          ((0?drf) % 32)
#define DRF_MASK(drf)           (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define DRF_DEF(d,r,f,c)        ((NV ## d ## r ## f ## c)<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_NUM(d,r,f,n)        (((n)&DRF_MASK(NV ## d ## r ## f))<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_VAL(d,r,f,v)        (((v)>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
#define REG_WR_DRF_NUM(d,r,f,n) REG_WR32(NV ## d ## r, DRF_NUM(d,r,f,n))
#define REG_WR_DRF_DEF(d,r,f,c) REG_WR32(NV ## d ## r, DRF_DEF(d,r,f,c))
#define FLD_WR_DRF_NUM(d,r,f,n) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define FLD_WR_DRF_DEF(d,r,f,c) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define REG_RD_DRF(d,r,f)       (((REG_RD32(NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))


// #include <nv_local.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dma\nv\notify.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************************* DMA Manager *****************************\
*                                                                           *
* Module: NOTIFY.C                                                          *
*   Method notifications are handled in this module.  DMA report and OS     *
*   action are dealt with on a per-object basis.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <fifo.h>
#include <dma.h>   
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
//
// Method notifications.
//
RM_STATUS mthdSetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS status;
    
    if (Object->NotifyTrigger)
        return (RM_ERR_DMA_IN_USE);
    //
    // Check for previous dma buffer.
    //
	/* KJK
    if (Object->NotifyXlate)
    {
        dmaEndXfer(Object->NotifyXlate, NULL);
        dmaDetach(Object->NotifyXlate);
    }
	*/

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(Object->NotifyXlate));
    if (status)
    {
        osError(Object, Offset, Data, status);
        return (status);
    }
	/* KJK
    status = dmaAttach(Object->NotifyXlate);
    if (status)
    {
        osError(Object, Offset, Data, status);
        Object->NotifyXlate   = NULL;
        return (status);
    }
	*/
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(Object->NotifyXlate, 0, 0x000F);
    if (status)
    {
        Object->NotifyXlate   = NULL;
        osError(Object, Offset, Data, status);
        return (status);
    }
	/* KJK
    status = dmaBeginXfer(Object->NotifyXlate, NULL);
    if (status)
    {
        Object->NotifyXlate   = NULL;
        osError(Object, Offset, Data, status);
    }
	*/
    return (status);
}
RM_STATUS mthdSetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    Object->NotifyAction  = Data;
    Object->NotifyTrigger = TRUE;
    return (RM_OK);
}
//
// Dual buffer notifications.
//
RM_STATUS mthdSetBufferNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PBUFFEROBJECT BuffObject;
    U032          BuffNum;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum    = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    return(notifySetBufferNotifyCtxDma(pDev, BuffObject, &BuffObject->Buffer[BuffNum], Offset, Data));
}
RM_STATUS notifySetBufferNotifyCtxDma
(
	PHWINFO       pDev,
    PBUFFEROBJECT BuffObject,
    PBUFFER       pBuffer,
    U032          Offset,
    U032          Data
)
{
    RM_STATUS status;

    //
    // Check for busy buffer.
    //
    if (pBuffer->State == BUFFER_BUSY)
    {
        osError(&BuffObject->Base, Offset, Data, RM_ERR_DMA_IN_USE);
        return (RM_ERR_DMA_IN_USE);
    }
    //
    // Check for previous dma buffer.
    //
	/* KJK
    if (pBuffer->NotifyXlate)
        dmaDetach(pBuffer->NotifyXlate);
	*/

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   BuffObject->Base.ChID,
                                   &(pBuffer->NotifyXlate));
    if (status)
    {
        pBuffer->NotifyXlate = NULL;
        return (status);
    }
	/* KJK
    status = dmaAttach(pBuffer->NotifyXlate);
    if (status)
    {
        pBuffer->NotifyXlate = NULL;
        return (status);
    }
	*/
    return (status);
}
RM_STATUS mthdSetBufferNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PBUFFEROBJECT BuffObject;
    U032          BuffNum;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum    = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    return(notifySetBufferNotify(pDev, BuffObject, BuffNum, Offset, Data));
}
RM_STATUS notifySetBufferNotify
(
	PHWINFO       pDev,
    PBUFFEROBJECT BuffObject,
    U032          BuffNum,
    U032          Offset,
    U032          Data
)
{
    RM_STATUS status;
    PBUFFER   pBuffer = &BuffObject->Buffer[BuffNum];

    //
    // Check for busy buffer.
    //
    if (pBuffer->State == BUFFER_BUSY)
    {
        osError(&BuffObject->Base, Offset, Data, RM_ERR_DMA_IN_USE);
        return (RM_ERR_DMA_IN_USE);
    }
    pBuffer->NotifyAction = Data;
    //
    // Validate notification parameters.
    //    
    status = dmaValidateXlate(pBuffer->NotifyXlate, 0, 0x000F);
    if (status)
    {
        osError(&BuffObject->Base, Offset, Data, status);
        return (status);
    }
	/* KJK
    status = dmaBeginXfer(pBuffer->NotifyXlate, NULL);
    if (status)
    {
        osError(&BuffObject->Base, Offset, Data, status);
        return (status);
    }
	*/
    //
    // Validate buffer parameters.
    //    
    status = dmaValidateXlate(pBuffer->Xlate,
                              pBuffer->Start,
                              pBuffer->Length);
    if (status)
    {
        notifyFillNotifier(pDev, pBuffer->NotifyXlate, 0, 0, status);
        //KJK dmaEndXfer(pBuffer->NotifyXlate, NULL);
        if (pBuffer->NotifyAction)
        {
            osNotifyEvent(pDev,
                          (POBJECT)BuffObject,
            			  0,
                          Offset,
                          BuffObject->Base.Name,
                          status,
                          pBuffer->NotifyAction);
        }
        return (status);
    }
	/* KJK
    status = dmaBeginXfer(pBuffer->Xlate, NULL);
    if (status)
    {
        notifyFillNotifier(pDev, pBuffer->NotifyXlate, 0, 0, status);
        dmaEndXfer(pBuffer->NotifyXlate, NULL);
        if (pBuffer->NotifyAction)
        {
            osNotifyEvent((POBJECT)BuffObject,
            			  0,
                          Offset,
                          BuffObject->Base.Name,
                          status,
                          pBuffer->NotifyAction);
        }
        return (status);
    }
	*/
    //
    // Call the object specific routine to begin the transfer.
    //
    BuffObject->BufferComplete                     = notifyBufferComplete;
    pBuffer->State                                 = BUFFER_BUSY;
    pBuffer->NotifyCurrentCount                    = pBuffer->NotifyCount;
    if (pBuffer->Length == 0)
    {
        pBuffer->NotifyCurrentCount = 0;
        notifyBufferComplete(pDev, BuffObject, BuffNum, BuffObject->Base.Name, RM_OK);
    }
    else
    {
        status = BuffObject->BufferXfer(pDev, BuffObject, BuffNum);
        if (status)
            notifyBufferComplete(pDev, BuffObject, BuffNum, BuffObject->Base.Name, status);
    }
    return (status);
}
RM_STATUS mthdSetBufferNotifyCount
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PBUFFEROBJECT BuffObject;
    U032          BuffNum;

    //
    // Update the count even if buffer is busy.
    //
    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum    = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    BuffObject->Buffer[BuffNum].NotifyCount        = Data;
    BuffObject->Buffer[BuffNum].NotifyCurrentCount = Data;
    return (RM_OK);
}
RM_STATUS mthdSetBufferPosNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    RM_STATUS     status;
    PBUFFEROBJECT BuffObject;
    U032          BuffNum;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum    = (Offset - Method->Low) >> 2;
    //
    // Check for previous dma buffer.
    //
	/* KJK
    if (BuffObject->Buffer[BuffNum].PosXlate)
    {
        dmaEndXfer(BuffObject->Buffer[BuffNum].PosXlate, NULL);
        dmaDetach(BuffObject->Buffer[BuffNum].PosXlate);
    }
	*/

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(BuffObject->Buffer[BuffNum].PosXlate));
    if (status)
    {
        BuffObject->Buffer[BuffNum].PosXlate = NULL;
        return (status);
    }
	/* KJK
    status = dmaAttach(BuffObject->Buffer[BuffNum].PosXlate);
    if (status)
    {
        BuffObject->Buffer[BuffNum].PosXlate = NULL;
        return (status);
    }
	*/
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(BuffObject->Buffer[BuffNum].PosXlate, 0, 0x000F);
    if (status)
    {
        BuffObject->Buffer[BuffNum].PosXlate = NULL;
        osError(Object, Offset, Data, status);
        return (status);
    }
	/* KJK
    status = dmaBeginXfer(BuffObject->Buffer[BuffNum].PosXlate, NULL);
    if (status)
    {
        BuffObject->Buffer[BuffNum].PosXlate = NULL;
        osError(Object, Offset, Data, status);
    }
	*/
    return (status);
}
RM_STATUS mthdSetBufferPosNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS     status;
    PBUFFEROBJECT BuffObject;
    U032          BuffNum;
    U032          Position;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum    = (Offset - Method->Low) >> 2;
    status     = BuffObject->BufferPos(pDev, BuffObject, BuffNum, &Position);
    if (status)
        return (status);
    notifyFillNotifier(pDev, BuffObject->Buffer[BuffNum].PosXlate, Position, 0, 0);
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Notification completion.
//
//---------------------------------------------------------------------------

RM_STATUS notifyDefaultError
(
	PHWINFO   pDev,
    POBJECT   Object,
    U032      Offset,
    V032      Data,
    U032      ChID,
    RM_STATUS CompletionStatus
)
{
    V032       ObjectName;
    PDMAOBJECT ErrNotifier;
    
    //
    // Check for error.
    //
    if (CompletionStatus & 0xFFFF)
    {
        //
        // Fill NV_ERROR_NOTIFIER if defined.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: method error ", CompletionStatus);
        if (Object)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "            object ", (U032)Object->Name);
            ObjectName = Object->Name;
        }
        else    
        {
            DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "            object NULL");
            ObjectName = 0;
        }
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "            offset ", Offset);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "              data ", Data);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "              chID ", ChID);
        if (fifoSearchObject(pDev, NV_CONTEXT_ERROR_TO_MEMORY, ChID, (POBJECT *)&ErrNotifier) == RM_OK)
        {
            if (ErrNotifier->Valid)
            {
                if (!dmaValidateXlate(ErrNotifier, 0, 0x000F))
                {
                    //KJK dmaAttach(ErrNotifier);
                    //KJK dmaBeginXfer(ErrNotifier, NULL);
                    notifyFillNotifier(pDev, ErrNotifier, ObjectName, (V016)Offset, CompletionStatus);
					/* KJK
                    dmaEndXfer(ErrNotifier, NULL);
                    dmaDetach(ErrNotifier);
					*/
                }
            }
        }
        //
        // Do any OS specific action.
        //
        if (Object)
            osError(Object, Offset, Data, CompletionStatus);
        else    
            osError(Object, Offset, ChID, CompletionStatus);
    }
    return (RM_OK);
}
RM_STATUS notifyMethodComplete
(
	PHWINFO	  pDev,
    POBJECT   Object,
    U032      Offset,
    V032      Data,
    RM_STATUS CompletionStatus
)
{

    if ((Offset == 0x104) || (Offset == 0x0180))
        return (RM_OK);    // no notification for these methods

    if (Object->NotifyTrigger)
    {
        Object->NotifyTrigger = FALSE;
        if (Object->NotifyXlate)
            notifyFillNotifier(pDev, Object->NotifyXlate, Object->Name, (V016)Offset, CompletionStatus);
        //
        // Do any OS specified action related to this notification.
        //
        if (Object->NotifyAction)
            osNotifyEvent(pDev, Object, 0, Offset, Data, CompletionStatus, Object->NotifyAction);
    }

    return (RM_OK);
}
RM_STATUS notifyBufferHWComplete
(
	PHWINFO	  pDev, 
    POBJECT   Object,
    U032      Offset,
    V032      Data,
    U032      Buffer,    
    RM_STATUS CompletionStatus
)
{
    if (Offset >= 0x0200)
    {
        if (Object->NotifyTrigger)
        {
            Object->NotifyTrigger = FALSE;
            if (Object->NotifyXlate)
                notifyFillNotifierArray(pDev, Object->NotifyXlate, Object->Name, (V016)Offset, CompletionStatus, Buffer);
            //
            // Do any OS specified action related to this notification.
            //
            if (Object->NotifyAction)
                osNotifyEvent(pDev, Object, Buffer, Offset, Data, CompletionStatus, Object->NotifyAction);
        }
    }
    return (RM_OK);
}
RM_STATUS notifyBufferComplete
(
	PHWINFO       pDev,
    PBUFFEROBJECT BuffObject,
    U032          BuffNum,
    V032          OtherInfo,
    RM_STATUS     CompletionStatus
)
{
    RM_STATUS status;
    PBUFFER   pBuffer = &BuffObject->Buffer[BuffNum];

    if ((OtherInfo == NOTIFY_INFO16_BUFFER_YANK)
    ||  (pBuffer->NotifyCurrentCount == 0))
    {
        //
        // Complete buffer with any notify action requested.
        //
        if (pBuffer->NotifyXlate)
            notifyFillNotifier(pDev, pBuffer->NotifyXlate, 0, (V016)OtherInfo, CompletionStatus);
        pBuffer->State = BUFFER_IDLE;
        //
        // Do any OS specified action related to this notification.
        //
        if (pBuffer->NotifyAction)
        {
            osNotifyEvent(pDev,
                          (POBJECT)BuffObject,
            			  0,
                          pBuffer->NotifyMethod,
                          BuffObject->Base.Name,
                          CompletionStatus,
                          pBuffer->NotifyAction);
        }
    }
    else
    {
        //
        // Auto notify buffer again.
        //
        if (pBuffer->NotifyXlate)
            notifyFillNotifier(pDev, pBuffer->NotifyXlate,
                               pBuffer->NotifyCurrentCount,
                               NOTIFY_INFO16_BUFFER_LOOP,
                               CompletionStatus);
        if (pBuffer->NotifyCount != 0xFFFFFFFF)
            pBuffer->NotifyCurrentCount--;
        status = BuffObject->BufferXfer(pDev, BuffObject, BuffNum);
        if (status)
        {
            //
            // Stop looping and return error.
            //
            pBuffer->NotifyCurrentCount = 0;
            notifyBufferComplete(pDev, BuffObject, BuffNum, OtherInfo, status);
        }
    }
    return (RM_OK);
}
RM_STATUS notifyFillNotifier
(
	PHWINFO	   pDev,
    PDMAOBJECT NotifyXlate,
    V032       Info32,
    V016       Info16,
    RM_STATUS  CompletionStatus
)
{
    RM_STATUS     status;
    PNOTIFICATION NotifyBuffer;

    //
    // Fill in the notification structure.
    //
    status = dmaGetMappedAddress(pDev, NotifyXlate, 0, 0x000F, (VOID **)&(NotifyBuffer));
    if (status)
        return (status);
    NotifyBuffer->OtherInfo32 = Info32;
    NotifyBuffer->OtherInfo16 = Info16;
    tmrGetCurrentTime(pDev, &NotifyBuffer->TimeHi, &NotifyBuffer->TimeLo);
    NotifyBuffer->Status = (V016)CompletionStatus;
    return (RM_OK);
}

RM_STATUS notifyFillNotifierArray
(
	PHWINFO	   pDev,
    PDMAOBJECT NotifyXlate,
    V032       Info32,
    V016       Info16,
    RM_STATUS  CompletionStatus,
    U032       Index
)
{
    RM_STATUS     status;
    PNOTIFICATION NotifyBuffer;

    //
    // Fill in the notification structure.
    //
    status = dmaGetMappedAddress(pDev, NotifyXlate, (Index*0x10), 0x000F, (VOID **)&(NotifyBuffer));
    if (status)
        return (status);
    NotifyBuffer->OtherInfo32 = Info32;
    NotifyBuffer->OtherInfo16 = Info16;
    tmrGetCurrentTime(pDev, &NotifyBuffer->TimeHi, &NotifyBuffer->TimeLo);
    NotifyBuffer->Status = (V016)CompletionStatus;
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dma\nv10\dmanv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** DMA Manager ********************************\
*                                                                           *
* Module: dmanv10.c                                                         *
*   The NV10 HAL DMA engine implementation is provided in this module.      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalDmaControl_NV10(VOID *);
RM_STATUS nvHalDmaAlloc_NV10(VOID *);
RM_STATUS nvHalDmaFree_NV10(VOID *);
RM_STATUS nvHalDmaGetInstSize_NV10(VOID *);

//
// nvHalDmaControl
//
// Nothing to do here.
//
RM_STATUS
nvHalDmaControl_NV10(VOID *arg)
{
    PDMACONTROLARG_000 pDmaControlArg = (PDMACONTROLARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDmaControlArg->id != DMA_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    switch (pDmaControlArg->cmd)
    {
        case DMA_CONTROL_UPDATE:
        case DMA_CONTROL_LOAD:
        case DMA_CONTROL_UNLOAD:
        case DMA_CONTROL_DESTROY:
        case DMA_CONTROL_INIT:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalDmaAlloc
//
// Initialize dma instance.
//
RM_STATUS
nvHalDmaAlloc_NV10(VOID *arg)
{
    PDMAALLOCARG_000 pDmaAllocArg = (PDMAALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALOBJINFO pDmaHalObjInfo;
    PDMAHALINFO pDmaHalInfo;
    U032 adjust, i;

    //
    // Verify interface revision.
    //
    if (pDmaAllocArg->id != DMA_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pDmaHalObjInfo = pDmaAllocArg->pHalObjInfo;
    pHalHwInfo = pDmaAllocArg->pHalHwInfo;
    pDmaHalInfo = pHalHwInfo->pDmaHalInfo;

    adjust = 0;
    switch (pDmaHalObjInfo->classNum)
    {
        case NV1_CONTEXT_DMA_TO_MEMORY:     
        case NV_CONTEXT_DMA_TO_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_TO_MEMORY);
            break;
        case NV1_CONTEXT_DMA_FROM_MEMORY:     
        case NV_CONTEXT_DMA_FROM_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_FROM_MEMORY);
            break;
        case NV1_CONTEXT_DMA_IN_MEMORY:     
        case NV_CONTEXT_DMA_IN_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_IN_MEMORY);
            break;
    }
    adjust |= SF_NUM(_DMA, _ADJUST, pDmaHalObjInfo->PteAdjust);
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || (pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM))
        adjust |= SF_DEF(_DMA, _PAGE_ENTRY, _LINEAR);
    adjust |= SF_DEF(_DMA, _PAGE_TABLE, _PRESENT);
    switch (pDmaHalObjInfo->AddressSpace)
    {
        case ADDR_SYSMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _PCI);
            break;
        case ADDR_AGPMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _AGP);
            break;
        case ADDR_FBMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _NVM);
            break;
        default:
#ifdef DEBUG
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Invalid address space type\n\r");
            DBG_BREAKPOINT();
#endif
            return (RM_ERR_BAD_ARGUMENT);
    }
    //
    // Fill the page translation array.
    //
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || (pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM))
    {    
        INST_WR32(pDmaHalObjInfo->Instance, 8, pDmaHalObjInfo->PteArray[0]);
        INST_WR32(pDmaHalObjInfo->Instance, 12, pDmaHalObjInfo->PteArray[0]); // better guard
    }        
    else 
    {   
        for (i = 0; i < pDmaHalObjInfo->PteCount; i++)
        {
            INST_WR32(pDmaHalObjInfo->Instance, 8 + i*4, pDmaHalObjInfo->PteArray[i]);
        }
        //
        // Fill in the guard page with bogus data.  Only accessed by DMA engine,
        // not used in any transfer to system memory.
        //
        INST_WR32(pDmaHalObjInfo->Instance, 8 + i*4, pDmaHalObjInfo->PteArray[0]);
    }
    //
    // Fill in rest of page table values.
    //
    INST_WR32(pDmaHalObjInfo->Instance, SF_OFFSET(NV_DMA_CLASS), adjust);
    INST_WR32(pDmaHalObjInfo->Instance, SF_OFFSET(NV_DMA_LIMIT), pDmaHalObjInfo->PteLimit);

    //
    // Add this dma context to the HAL table.
    //
    pDmaHalObjInfo->Next = (PDMAHALOBJINFO)pDmaHalInfo->pDmaHalObjInfos;
    pDmaHalInfo->pDmaHalObjInfos = (VOID_PTR)pDmaHalObjInfo;

    return (RM_OK);
}

//
// nvHalDmaFree
//
RM_STATUS
nvHalDmaFree_NV10(VOID *arg)
{
    PDMAFREEARG_000 pDmaFreeArg = (PDMAFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALINFO pDmaHalInfo;
    PDMAHALOBJINFO pDmaHalObjInfo, pDmaHalObjInfoDelete;

    //
    // Verify interface revision.
    //
    if (pDmaFreeArg->id != DMA_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaFreeArg->pHalHwInfo;
    pDmaHalInfo = pHalHwInfo->pDmaHalInfo;
    pDmaHalObjInfo = pDmaFreeArg->pHalObjInfo;

    //
    // Detach from DMA list.
    //
    if (pDmaHalInfo->pDmaHalObjInfos == (VOID_PTR)pDmaHalObjInfo)
        pDmaHalInfo->pDmaHalObjInfos = (VOID_PTR)pDmaHalObjInfo->Next;
    else
    {
        pDmaHalObjInfoDelete = (PDMAHALOBJINFO)pDmaHalInfo->pDmaHalObjInfos;
        while (pDmaHalObjInfoDelete->Next && pDmaHalObjInfoDelete->Next != pDmaHalObjInfo)
        {
            pDmaHalObjInfoDelete = pDmaHalObjInfoDelete->Next;
        }
        if (pDmaHalObjInfoDelete->Next)
            pDmaHalObjInfoDelete->Next = pDmaHalObjInfo->Next;
    }

    return (RM_OK);
}

//
// nvHalDmaGetInstSize
//
// Return number of *paragraphs* required for dma context in
// instance memory.
//
RM_STATUS
nvHalDmaGetInstSize_NV10(VOID *arg)
{
    PDMAGETINSTSIZEARG_000 pDmaGetInstSizeArg = (PDMAGETINSTSIZEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALOBJINFO pDmaHalObjInfo;

    //
    // Verify interface revision.
    //
    if (pDmaGetInstSizeArg->id != DMA_GET_INSTSIZE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaGetInstSizeArg->pHalHwInfo;
    pDmaHalObjInfo = pDmaGetInstSizeArg->pHalObjInfo;

    //
    // Factor in an extra PTE so when the DMA engine prefetches, it
    // won't fault on a last access to a page.
    //
    
    //
    // Local memory contexts require only 1 paragraph (they're linear).
    // So do single page contexts in other address spaces (i.e. system memory).
    //
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || ((pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM)))
        pDmaHalObjInfo->NumUnits = 1;
    else
    {
        if (pDmaHalObjInfo->PteCount == 1)
            pDmaHalObjInfo->NumUnits = 1;
        else
            pDmaHalObjInfo->NumUnits = 2 + (pDmaHalObjInfo->PteCount - 1) / 4;
    }
    
    return (RM_OK);
}

//
// dmaHalInstanceToHalInfo
//
RM_STATUS
dmaHalInstanceToHalInfo_NV10(U032 chid, U032 instance, PDMAHALOBJINFO *ppDmaHalObjInfo, PHALHWINFO pHalHwInfo)
{
    PDMAHALOBJINFO pDmaHalObjInfo;

    pDmaHalObjInfo = (PDMAHALOBJINFO)pHalHwInfo->pDmaHalInfo->pDmaHalObjInfos;
    while (pDmaHalObjInfo)
    {
        if (pDmaHalObjInfo->Instance == instance)
        {
            //
            // Found it!
            //
    	    *ppDmaHalObjInfo = pDmaHalObjInfo;
            return RM_OK;
        }
        pDmaHalObjInfo = pDmaHalObjInfo->Next;
    }

    *ppDmaHalObjInfo = NULL;  
    return RM_ERR_BAD_ARGUMENT;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dma\nv20\dmanv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** DMA Manager ********************************\
*                                                                           *
* Module: dmanv20.c                                                         *
*   The NV20 HAL DMA engine implementation is provided in this module.      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalDmaControl_NV20(VOID *);
RM_STATUS nvHalDmaAlloc_NV20(VOID *);
RM_STATUS nvHalDmaFree_NV20(VOID *);
RM_STATUS nvHalDmaGetInstSize_NV20(VOID *);

//
// nvHalDmaControl
//
// Nothing to do here.
//
RM_STATUS
nvHalDmaControl_NV20(VOID *arg)
{
    PDMACONTROLARG_000 pDmaControlArg = (PDMACONTROLARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDmaControlArg->id != DMA_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    switch (pDmaControlArg->cmd)
    {
        case DMA_CONTROL_UPDATE:
        case DMA_CONTROL_LOAD:
        case DMA_CONTROL_UNLOAD:
        case DMA_CONTROL_DESTROY:
        case DMA_CONTROL_INIT:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalDmaAlloc
//
// Initialize dma instance.
//
// For nv20, we have to workaround a bug in the scaled_image hw:
//
//  [a] The hw generates a limit violation exception if
//      the programmed transfer size is within 64bytes of
//      the surface context dma limit; in practice, this happens
//      with system memory contexts in ddraw where the context dma
//      maps the underlying image buffer byte for byte (as opposed
//      to vidmem and agp context dmas that span the entire memory
//      range).
//
//  [b] The hw reads an extra 64bytes beyond the programmed
//      transfer size.
//
// To workaround this bug, we'll do two things here:
//
//  [1] Pad the specified context dma limit to prevent [a]
//      for _all_ context dmas.
//
//  [2] Make sure there's a guard page for the system memory
//      context dma's so that there's real memory behind
//      the 64byte prefetch done by the hw (helps with [b]).
//
// For [2], we can handle the PCI context dmas in the RM by
// putting the pte for the first page of the memory at the
// end of pte table.  For NVM context dmas, we know that
// there will always be valid memory in place because instance
// memory will protect us should the prefetch cross the last byte of
// allocatable video memory.  For AGP context dmas, we are
// relying on the driver to always pad the allocations THEMSELVES!!!!
//
RM_STATUS
nvHalDmaAlloc_NV20(VOID *arg)
{
    PDMAALLOCARG_000 pDmaAllocArg = (PDMAALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALOBJINFO pDmaHalObjInfo;
    PDMAHALINFO pDmaHalInfo;
    U032 adjust, i;

    //
    // Verify interface revision.
    //
    if (pDmaAllocArg->id != DMA_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaAllocArg->pHalHwInfo;
    pDmaHalObjInfo = pDmaAllocArg->pHalObjInfo;
    pDmaHalInfo = pHalHwInfo->pDmaHalInfo;

    adjust = 0;
    switch (pDmaHalObjInfo->classNum)
    {
        case NV1_CONTEXT_DMA_TO_MEMORY:     
        case NV_CONTEXT_DMA_TO_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_TO_MEMORY);
            break;
        case NV1_CONTEXT_DMA_FROM_MEMORY:     
        case NV_CONTEXT_DMA_FROM_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_FROM_MEMORY);
            break;
        case NV1_CONTEXT_DMA_IN_MEMORY:     
        case NV_CONTEXT_DMA_IN_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_IN_MEMORY);
            break;
    }
    adjust |= SF_NUM(_DMA, _ADJUST, pDmaHalObjInfo->PteAdjust);
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || (pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM))
        adjust |= SF_DEF(_DMA, _PAGE_ENTRY, _LINEAR);
    adjust |= SF_DEF(_DMA, _PAGE_TABLE, _PRESENT);
    switch (pDmaHalObjInfo->AddressSpace)
    {
        case ADDR_SYSMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _PCI);
            break;
        case ADDR_AGPMEM:
#ifdef IKOS
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: AGP on IKOS!!!!\n");
            DBG_BREAKPOINT();
#endif
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _AGP);
            break;
        case ADDR_FBMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _NVM);
            break;
        default:
#ifdef DEBUG
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Invalid address space type\n\r");
            DBG_BREAKPOINT();
#endif
            return (RM_ERR_BAD_ARGUMENT);
    }

    //
    // Workaround a bug in the HOST's semaphore context dma checks.
    // It only accepts the SetContextDmaSemaphore method if the
    // ctxdma is marked COHERENCY_CACHED (even though the underlying
    // memory is NODE_NVM).  Since no other engine checks the
    // coherency flags (yet), this should be OK for now.
    //
    adjust |= SF_DEF(_DMA, _FLAGS_MAPPING_COHERENCY, _CACHED);

    //
    // Fill the page translation array.
    //
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || (pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM))
    {    
        INST_WR32(pDmaHalObjInfo->Instance, 8, pDmaHalObjInfo->PteArray[0]);
        INST_WR32(pDmaHalObjInfo->Instance, 12, pDmaHalObjInfo->PteArray[0]); // better guard
    }        
    else 
    {   
        for (i = 0; i < pDmaHalObjInfo->PteCount; i++)
        {
            INST_WR32(pDmaHalObjInfo->Instance, 8 + i*4, pDmaHalObjInfo->PteArray[i]);
        }

        //
        // Load in guard page pte.  Needed especially for scaled_image war.
        //
        INST_WR32(pDmaHalObjInfo->Instance, 8 + i*4, pDmaHalObjInfo->PteArray[0]);
    }
    //
    // Fill in rest of page table values.
    // Bump offset by 256bytes to cover scaled_image bug (we really only
    // need 64bytes of additional NV_DMA_LIMIT, but we need to make
    // sure that we align things for any possible use.
    //
    INST_WR32(pDmaHalObjInfo->Instance, SF_OFFSET(NV_DMA_CLASS), adjust);
    INST_WR32(pDmaHalObjInfo->Instance, SF_OFFSET(NV_DMA_LIMIT), (pDmaHalObjInfo->PteLimit + NV20_SCALED_IMAGE_WAR_OFFSET));

    //
    // Add this dma context to the HAL table.
    //
    pDmaHalObjInfo->Next = (PDMAHALOBJINFO)pDmaHalInfo->pDmaHalObjInfos;
    pDmaHalInfo->pDmaHalObjInfos = (VOID_PTR)pDmaHalObjInfo;

    return (RM_OK);
}

//
// nvHalDmaFree
//
RM_STATUS
nvHalDmaFree_NV20(VOID *arg)
{
    PDMAFREEARG_000 pDmaFreeArg = (PDMAFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALINFO pDmaHalInfo;
    PDMAHALOBJINFO pDmaHalObjInfo, pDmaHalObjInfoDelete;

    //
    // Verify interface revision.
    //
    if (pDmaFreeArg->id != DMA_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaFreeArg->pHalHwInfo;
    pDmaHalInfo = pHalHwInfo->pDmaHalInfo;
    pDmaHalObjInfo = pDmaFreeArg->pHalObjInfo;

    //
    // Detach from DMA list.
    //
    if (pDmaHalInfo->pDmaHalObjInfos == (VOID_PTR)pDmaHalObjInfo)
        pDmaHalInfo->pDmaHalObjInfos = (VOID_PTR)pDmaHalObjInfo->Next;
    else
    {
        pDmaHalObjInfoDelete = (PDMAHALOBJINFO)pDmaHalInfo->pDmaHalObjInfos;
        while (pDmaHalObjInfoDelete->Next && pDmaHalObjInfoDelete->Next != pDmaHalObjInfo)
        {
            pDmaHalObjInfoDelete = pDmaHalObjInfoDelete->Next;
        }
        if (pDmaHalObjInfoDelete->Next)
            pDmaHalObjInfoDelete->Next = pDmaHalObjInfo->Next;
    }

    return (RM_OK);
}

//
// nvHalDmaGetInstSize
//
// Return number of *paragraphs* required for dma context in
// instance memory.
//
RM_STATUS
nvHalDmaGetInstSize_NV20(VOID *arg)
{
    PDMAGETINSTSIZEARG_000 pDmaGetInstSizeArg = (PDMAGETINSTSIZEARG_000)arg;
    PDMAHALOBJINFO pDmaHalObjInfo;
    PHALHWINFO pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pDmaGetInstSizeArg->id != DMA_GET_INSTSIZE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaGetInstSizeArg->pHalHwInfo;
    pDmaHalObjInfo = pDmaGetInstSizeArg->pHalObjInfo;

    //
    // Factor in an extra PTE so when the DMA engine prefetches, it
    // won't fault on a last access to a page.
    //
    
    //
    // Local memory contexts require only 1 paragraph (they're linear).
    // So do single page contexts in other address spaces (i.e. system memory).
    //
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || ((pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM)))
        pDmaHalObjInfo->NumUnits = 1;
    else
    {
        if (pDmaHalObjInfo->PteCount == 1)
            pDmaHalObjInfo->NumUnits = 1;
        else
            pDmaHalObjInfo->NumUnits = 2 + (pDmaHalObjInfo->PteCount - 1) / 4;
    }
    
    return (RM_OK);
}

//
// dmaHalInstanceToHalInfo
//
RM_STATUS
dmaHalInstanceToHalInfo_NV20(U032 chid, U032 instance, PDMAHALOBJINFO *ppDmaHalObjInfo, PHALHWINFO pHalHwInfo)
{
    PDMAHALOBJINFO pDmaHalObjInfo;

    pDmaHalObjInfo = (PDMAHALOBJINFO)pHalHwInfo->pDmaHalInfo->pDmaHalObjInfos;
    while (pDmaHalObjInfo)
    {
        if (pDmaHalObjInfo->Instance == instance)
        {
            //
            // Found it!
            //
    	    *ppDmaHalObjInfo = pDmaHalObjInfo;
            return RM_OK;
        }
        pDmaHalObjInfo = pDmaHalObjInfo->Next;
    }

    *ppDmaHalObjInfo = NULL;  
    return RM_ERR_BAD_ARGUMENT;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dma\nv4\dmanv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** DMA Manager ********************************\
*                                                                           *
* Module: dmanv04.c                                                         *
*   The NV04 HAL DMA engine implementation is provided in this module.      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalDmaControl_NV04(VOID *);
RM_STATUS nvHalDmaAlloc_NV04(VOID *);
RM_STATUS nvHalDmaFree_NV04(VOID *);
RM_STATUS nvHalDmaGetInstSize_NV04(VOID *);

//
// nvHalDmaControl
//
// Nothing to do here.
//
RM_STATUS
nvHalDmaControl_NV04(VOID *arg)
{
    PDMACONTROLARG_000 pDmaControlArg = (PDMACONTROLARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDmaControlArg->id != DMA_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    switch (pDmaControlArg->cmd)
    {
        case DMA_CONTROL_UPDATE:
        case DMA_CONTROL_LOAD:
        case DMA_CONTROL_UNLOAD:
        case DMA_CONTROL_DESTROY:
        case DMA_CONTROL_INIT:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalDmaAlloc
//
// Initialize dma instance.
//
RM_STATUS
nvHalDmaAlloc_NV04(VOID *arg)
{
    PDMAALLOCARG_000 pDmaAllocArg = (PDMAALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALOBJINFO pDmaHalObjInfo;
    PDMAHALINFO pDmaHalInfo;
    U032 adjust, i;

    //
    // Verify interface revision.
    //
    if (pDmaAllocArg->id != DMA_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaAllocArg->pHalHwInfo;
    pDmaHalObjInfo = pDmaAllocArg->pHalObjInfo;
    pDmaHalInfo = pHalHwInfo->pDmaHalInfo;

    adjust = 0;
    switch (pDmaHalObjInfo->classNum)
    {
        case NV1_CONTEXT_DMA_TO_MEMORY:     
        case NV_CONTEXT_DMA_TO_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_TO_MEMORY);
            break;
        case NV1_CONTEXT_DMA_FROM_MEMORY:     
        case NV_CONTEXT_DMA_FROM_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_FROM_MEMORY);
            break;
        case NV1_CONTEXT_DMA_IN_MEMORY:     
        case NV_CONTEXT_DMA_IN_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_IN_MEMORY);
            break;
    }
    adjust |= SF_NUM(_DMA, _ADJUST, pDmaHalObjInfo->PteAdjust);
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || (pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM))
        adjust |= SF_DEF(_DMA, _PAGE_ENTRY, _LINEAR);
    adjust |= SF_DEF(_DMA, _PAGE_TABLE, _PRESENT);
    switch (pDmaHalObjInfo->AddressSpace)
    {
        case ADDR_SYSMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _PCI);
            break;
        case ADDR_AGPMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _AGP);
            break;
        case ADDR_FBMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _NVM);
            break;
        default:
#ifdef DEBUG
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Invalid address space type\n\r");
            DBG_BREAKPOINT();
#endif
            return (RM_ERR_BAD_ARGUMENT);
    }
    //
    // Fill the page translation array.
    //
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || (pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM))
    {    
        INST_WR32(pDmaHalObjInfo->Instance, 8, pDmaHalObjInfo->PteArray[0]);
        INST_WR32(pDmaHalObjInfo->Instance, 12, pDmaHalObjInfo->PteArray[0]); // better guard
    }        
    else 
    {   
        for (i = 0; i < pDmaHalObjInfo->PteCount; i++)
        {
            INST_WR32(pDmaHalObjInfo->Instance, 8 + i*4, pDmaHalObjInfo->PteArray[i]);
        }
        //
        // Fill in the guard page with bogus data.  Only accessed by DMA engine,
        // not used in any transfer to system memory.
        //
        INST_WR32(pDmaHalObjInfo->Instance, 8 + i*4, pDmaHalObjInfo->PteArray[0]);
    }
    //
    // Fill in rest of page table values.
    //
    INST_WR32(pDmaHalObjInfo->Instance, SF_OFFSET(NV_DMA_CLASS), adjust);
    INST_WR32(pDmaHalObjInfo->Instance, SF_OFFSET(NV_DMA_LIMIT), pDmaHalObjInfo->PteLimit);
    
    //
    // Add this dma context to the HAL table.
    //
    pDmaHalObjInfo->Next = (PDMAHALOBJINFO)pDmaHalInfo->pDmaHalObjInfos;
    pDmaHalInfo->pDmaHalObjInfos = (VOID_PTR)pDmaHalObjInfo;

    return (RM_OK);
}

//
// nvHalDmaFree
//
RM_STATUS
nvHalDmaFree_NV04(VOID *arg)
{
    PDMAFREEARG_000 pDmaFreeArg = (PDMAFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALINFO pDmaHalInfo;
    PDMAHALOBJINFO pDmaHalObjInfo, pDmaHalObjInfoDelete;

    //
    // Verify interface revision.
    //
    if (pDmaFreeArg->id != DMA_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaFreeArg->pHalHwInfo;
    pDmaHalObjInfo = pDmaFreeArg->pHalObjInfo;
    pDmaHalInfo = pHalHwInfo->pDmaHalInfo;

    //
    // Detach from DMA list.
    //
    if (pDmaHalInfo->pDmaHalObjInfos == (VOID_PTR)pDmaHalObjInfo)
        pDmaHalInfo->pDmaHalObjInfos = (VOID_PTR)pDmaHalObjInfo->Next;
    else
    {
        pDmaHalObjInfoDelete = (PDMAHALOBJINFO)pDmaHalInfo->pDmaHalObjInfos;
        while (pDmaHalObjInfoDelete->Next && pDmaHalObjInfoDelete->Next != pDmaHalObjInfo)
        {
            pDmaHalObjInfoDelete = pDmaHalObjInfoDelete->Next;
        }
        if (pDmaHalObjInfoDelete->Next)
            pDmaHalObjInfoDelete->Next = pDmaHalObjInfo->Next;
    }

    return (RM_OK);
}

//
// nvHalDmaGetInstSize
//
// Return number of *paragraphs* required for dma context in
// instance memory.
//
RM_STATUS
nvHalDmaGetInstSize_NV04(VOID *arg)
{
    PDMAGETINSTSIZEARG_000 pDmaGetInstSizeArg = (PDMAGETINSTSIZEARG_000)arg;
    PDMAHALOBJINFO pDmaHalObjInfo;
    PHALHWINFO pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pDmaGetInstSizeArg->id != DMA_GET_INSTSIZE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaGetInstSizeArg->pHalHwInfo;
    pDmaHalObjInfo = pDmaGetInstSizeArg->pHalObjInfo;

    //
    // Factor in an extra PTE so when the DMA engine prefetches, it
    // won't fault on a last access to a page.
    //
    
    //
    // Local memory contexts require only 1 paragraph (they're linear).
    // So do single page contexts in other address spaces (i.e. system memory).
    //
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || ((pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM)))
        pDmaHalObjInfo->NumUnits = 1;
    else
    {
        if (pDmaHalObjInfo->PteCount == 1)
            pDmaHalObjInfo->NumUnits = 1;
        else
            pDmaHalObjInfo->NumUnits = 2 + (pDmaHalObjInfo->PteCount - 1) / 4;
    }
    
    return (RM_OK);
}

//
// dmaHalInstanceToHalInfo
//
RM_STATUS
dmaHalInstanceToHalInfo_NV04(U032 chid, U032 instance, PDMAHALOBJINFO *ppDmaHalObjInfo, PHALHWINFO pHalHwInfo)
{
    PDMAHALOBJINFO pDmaHalObjInfo;

    pDmaHalObjInfo = (PDMAHALOBJINFO)pHalHwInfo->pDmaHalInfo->pDmaHalObjInfos;
    while (pDmaHalObjInfo)
    {
        if (pDmaHalObjInfo->Instance == instance)
        {
            //
            // Found it!
            //
    	    *ppDmaHalObjInfo = pDmaHalObjInfo;
            return RM_OK;
        }
        pDmaHalObjInfo = pDmaHalObjInfo->Next;
    }

    *ppDmaHalObjInfo = NULL;  
    return RM_ERR_BAD_ARGUMENT;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\fb\nv\fb.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** FB Manager *********************************\
*                                                                           *
* Module: FB.C                                                              *
*   The FB is managed in this module.                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <bios.h>
#include <fifo.h>
#include <dma.h>
#include <gr.h>
#include <fb.h>
#include <os.h>
#include <vga.h>
#include "nvhw.h"



//KDA buffer summary
// Synopsys: The KDA buffer is a data area in instance memory shared between
// the driver and the VBIOS.  First created March, 2001.
// The VBIOS is already mirrored in the lower 64K The buffer is set up by the VBIOS


//---------------------------------------------------------------------------
//
//  Instance allocation bitmap.
//
//---------------------------------------------------------------------------


//Attempt to take control of the entire KDA buffer via a signalling bit.
// Returns success if there is no buffer present, or if we successfully
// set our bit (which first entails checking that the VBIOS has not currently
// set its own access bit).
//We should not hold this semaphore for long -- there are separate cell-specific
// semaphores that can be taken and held indefinitely.
RM_STATUS fbKDATakeBufferSemaphore
(
    PHWINFO pDev,
    U032    timeout
)
{
#if defined(WIN32) && defined (KDA_BUFFER_ENABLED)
    U032 biosFlags, driverFlags, curLoc;

    if (!pDev->DBfbKDASharedMem) return RM_OK;

    curLoc = (INST_RD32(0, KDA_HARDWIRED_PTR_LOC)) >> 4;
    if (!curLoc) return RM_OK;

    do {
        biosFlags = INST_RD32(curLoc, KDA_HEADER_VBIOS_FLAGS_LOC);
        if (biosFlags & KDA_BUFFER_BUSY_MASK) {
            U032 stepdelay = (timeout < 100000)?timeout:100000;
            tmrDelay(pDev, stepdelay);
            timeout -= stepdelay;
        } else {
            driverFlags = INST_RD32(curLoc, KDA_HEADER_DRIVER_FLAGS_LOC);
            INST_WR32(curLoc, KDA_HEADER_DRIVER_FLAGS_LOC, driverFlags | KDA_BUFFER_BUSY_MASK);
            //Verify the VBIOS didn't sneak in during the window between our
            // last check and the set above.
            biosFlags = INST_RD32(curLoc, KDA_HEADER_VBIOS_FLAGS_LOC);
            if (biosFlags & KDA_BUFFER_BUSY_MASK)   //If it did, drop our own attempt to take the semaphore.
                INST_WR32(curLoc, KDA_HEADER_DRIVER_FLAGS_LOC, driverFlags);
            else                            //Otherwise we're all set, so clear the remaining time.
                timeout = 0;
        }
    } while (timeout);

    if (!((INST_RD32(curLoc, KDA_HEADER_DRIVER_FLAGS_LOC)) & KDA_BUFFER_BUSY_MASK))
        return RM_ERROR;
#endif  //if defined(WIN32) && defined (KDA_BUFFER_ENABLED)
    return RM_OK;
}

//Release our lock on the KDA buffer
RM_STATUS fbKDAReleaseBufferSemaphore
(
    PHWINFO pDev
)
{
#if defined(WIN32) && defined (KDA_BUFFER_ENABLED)
    U032 driverFlags, curLoc;

    if (!pDev->DBfbKDASharedMem) return RM_OK;

    curLoc = (INST_RD32(0, KDA_HARDWIRED_PTR_LOC)) >> 4;
    if (!curLoc) return RM_OK;

    driverFlags = INST_RD32(curLoc, KDA_HEADER_DRIVER_FLAGS_LOC);
    INST_WR32(curLoc, KDA_HEADER_DRIVER_FLAGS_LOC, driverFlags & ~KDA_BUFFER_BUSY_MASK);
#endif  //if defined(WIN32) && defined (KDA_BUFFER_ENABLED)
    return RM_OK;
}

//Look-up function to search for the next occurence of a specified cell type
// within the KDA buffer.
//The prevMatch parameter is set to 0 to find the first occurence,
// and to the offset of the last found cell to find the next.
#if defined(WIN32) && defined (KDA_BUFFER_ENABLED)
RM_STATUS fbKDAFindNextCellOffset
(
    PHWINFO pDev,
    U032 cellType,
    U032 *prevMatch
)
{
    U032 curLoc, bufferSize, nextCellLoc;
    curLoc = (INST_RD32(0, KDA_HARDWIRED_PTR_LOC)) >> 4;
    bufferSize = INST_RD32(curLoc, KDA_HEADER_BUFFER_SIZE_LOC) >> 4;

    nextCellLoc = KDA_BUFFER_CELL_START;
    while (INST_RD32(curLoc, nextCellLoc + KDA_CELL_SIZE_LOC) && (nextCellLoc < bufferSize)) {
        if (nextCellLoc > *prevMatch) {
            if (INST_RD32(curLoc, nextCellLoc + KDA_CELL_TYPE_LOC) == cellType) {
                *prevMatch = nextCellLoc;
                return RM_OK;
            }
        }
        nextCellLoc += INST_RD32(curLoc, nextCellLoc + KDA_CELL_SIZE_LOC);
    }

    return RM_ERROR;
}

//Find the next occurence within the KDA buffer of a cursor cell.
//The prevMatch parameter is set to 0 to find the first occurence,
// and to the offset of the last found cell to find the next.
RM_STATUS fbKDAFindCursorCellOffset
(
    PHWINFO pDev,
    U032 head,
    U032 *prevMatch
)
{
    RM_STATUS rmStatus;
    U032 curLoc;

    curLoc = (INST_RD32(0, KDA_HARDWIRED_PTR_LOC)) >> 4;

    //Find the cell we are interested in.
    while ((rmStatus = fbKDAFindNextCellOffset(pDev, KDA_CELL_TYPE_HW_ICON, prevMatch)) == RM_OK) {
        if (INST_RD32(curLoc, *prevMatch + KDA_CELL_HWICON_HEAD_LOC) == head)
            break;
    }

    if (rmStatus == RM_ERROR) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "    NVRM (fbKDAFindCursorCellOffset): Unable to find cell match.\r\n");
    }

    return rmStatus;
}
#endif  //if defined(WIN32) && defined (KDA_BUFFER_ENABLED)


//Take the semaphore for a cursor cell
// Returns success if we successfully set our bit (which first entails
// checking that the VBIOS has not currently set its own access bit).
// During HW icon emulation on NV11, the VBIOS may hold this semaphore
// indefinitely.
RM_STATUS fbKDATakeCursorCellSemaphore
(
    PHWINFO pDev,
    U032    cellOffset,
    U032    timeout
)
{
#if defined(WIN32) && defined (KDA_BUFFER_ENABLED)
    U032 curLoc;
    U032 biosFlags, driverFlags;

    curLoc = (INST_RD32(0, KDA_HARDWIRED_PTR_LOC)) >> 4;

    //Take the semaphore for this cell
    do {
        biosFlags = INST_RD32(curLoc, cellOffset + KDA_CELL_HWICON_VBIOS_FLAGS_LOC);  //LPL: need to adjust by cell type!
        if (biosFlags & KDA_CELL_HWICON_BUSY_MASK) {
            U032 stepdelay = (timeout < 100000)?timeout:100000;
            tmrDelay(pDev, stepdelay);
            timeout -= stepdelay;
        } else {
            driverFlags = INST_RD32(curLoc, cellOffset + KDA_CELL_HWICON_DRIVER_FLAGS_LOC);
            INST_WR32(curLoc, cellOffset + KDA_CELL_HWICON_DRIVER_FLAGS_LOC, driverFlags | KDA_CELL_HWICON_BUSY_MASK);
            //Verify the VBIOS didn't sneak in during the window between our
            // last check and the set above.
            biosFlags = INST_RD32(curLoc, cellOffset + KDA_CELL_HWICON_VBIOS_FLAGS_LOC);
            if (biosFlags & KDA_CELL_HWICON_BUSY_MASK)   //If it did, drop our own attempt to take the semaphore.
                INST_WR32(curLoc, cellOffset + KDA_CELL_HWICON_DRIVER_FLAGS_LOC, driverFlags);
            else                            //Otherwise we're all set, so clear the remaining time.
                timeout = 0;
        }
    } while (timeout);

    if (!((INST_RD32(curLoc, KDA_CELL_HWICON_DRIVER_FLAGS_LOC)) & KDA_CELL_HWICON_BUSY_MASK)) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "    NVRM: Unable to take cell semaphore.\r\n");
        return RM_ERROR;
    }
#endif  //if defined(WIN32) && defined (KDA_BUFFER_ENABLED)
    return RM_OK;
}


//Release the semaphore for a cursor cell
RM_STATUS fbKDAReleaseCursorCellSemaphore
(
    PHWINFO pDev,
    U032    cellOffset
)
{
#if defined(WIN32) && defined (KDA_BUFFER_ENABLED)
    U032 curLoc;
    U032 driverFlags;

    curLoc = (INST_RD32(0, KDA_HARDWIRED_PTR_LOC)) >> 4;

    driverFlags = INST_RD32(curLoc, cellOffset + KDA_CELL_HWICON_DRIVER_FLAGS_LOC);
    INST_WR32(curLoc, cellOffset + KDA_CELL_HWICON_DRIVER_FLAGS_LOC, driverFlags & KDA_CELL_HWICON_BUSY_MASK);

    return RM_OK;
#else  //if defined(WIN32) && defined (KDA_BUFFER_ENABLED)
    return RM_OK;
#endif  //if defined(WIN32) && defined (KDA_BUFFER_ENABLED)
}

RM_STATUS fbInitializeInstMemBitMap
(
    PHWINFO pDev
)
{
    RM_STATUS status;
    U008      *pbyte;
    U032      size;
#if defined(WIN32) && defined (KDA_BUFFER_ENABLED)
    U032      rEAX, rEBX, rECX, rEDX;
    U032      KDASizeBytes;
#else  //if defined(WIN32) && defined (KDA_BUFFER_ENABLED)
    U032      entry;
#endif  //if defined(WIN32) && defined (KDA_BUFFER_ENABLED)

    //
    // Initialize instance memory usage bitmap.  Each bit equals 1 paragraph (16 bytes)
    // of instance memory.
    //
    pDev->Pram.FreeInstMax = (pDev->Pram.FreeInstSize  / 16) & ~0x07;
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FB Free Size       = ", pDev->Pram.FreeInstSize);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FB Free Inst Base  = ", pDev->Pram.FreeInstBase);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FB Free Inst Max   = ", pDev->Pram.FreeInstMax + pDev->Pram.FreeInstBase);

    size = (pDev->Pram.FreeInstMax / 8 + 4);
    status = osAllocMem((VOID **)&pbyte, size);
    if (status)
        return (status);

    pDev->DBfbInstBitmap = pbyte;

    //
    // Reserve instance 0 as the NULL instance.
    //    
    *pbyte++ = 0xFE;    
    while (--size)
        *pbyte++ = 0xFF;

#if defined(WIN32) && defined (KDA_BUFFER_ENABLED)
    //Allocate space for the KDA buffer and copy the buffer the VBIOS was using
    // to the new location.
    //LPL to add: make sure the new buffer is not > old but overlapping -- the copy
    // couldn't be done non-destructively if so...
    //Verify that BIOS supports use of an instance memory buffer.
    rEAX = 0x4F14;
    rEBX = 0x0006;
    rECX = 0;
    rEDX = 0;
    status = osCallVideoBIOS(pDev, &rEAX, &rEBX, &rECX, &rEDX, NULL);

    pDev->DBfbKDASharedMem = 0; //Special 'it's not there' value.
    pDev->DBfbKDACursorOverride = FALSE;

    if ((status == RM_OK) && (INST_RD32(0, KDA_HARDWIRED_PTR_LOC) >> 4)) {   //If the BIOS supports this
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: BIOS supports hardware icons in instance memory.\r\n");
        //Allocate space for the new buffer
        status = fbAllocInstMemAlign(pDev, &pDev->DBfbKDASharedMem, KDA_MEM_SIZE >> 4, 0x800 >> 4);
        if (status == RM_OK) {
            //Take ownership of the old buffer
            status = fbKDATakeBufferSemaphore(pDev, 10000000);
            if (status == RM_OK) {
                U032 origBufLoc, temp;
                S032 i;
                origBufLoc = (INST_RD32(0, KDA_HARDWIRED_PTR_LOC)) >> 4;
                KDASizeBytes = INST_RD32(origBufLoc, KDA_HEADER_BUFFER_SIZE_LOC);
                if (KDASizeBytes == 0) {
                    return RM_ERROR;
                }

                // Copy the whole buffer.  Since there is no guarantee the buffer the BIOS
                // was using originally and the one we allocate won't overlap, we have to
                // be careful not to accidentally overwrite information during the copy.
                // We copy up or down as needed, and the copy is broken up into two parts:
                // up to and including the location holding the semaphore flag (after which
                // the buffer pointer is overwritten to point to the new location) and
                // everything else.
                if (origBufLoc > pDev->DBfbKDASharedMem) {
                    for (i = 0; i <= KDA_HEADER_DRIVER_FLAGS_LOC; i+=sizeof(U032)) {
                        temp = INST_RD32(origBufLoc, i);
                        INST_WR32(pDev->DBfbKDASharedMem, i, temp);
                    }
                    //Reassign buffer pointer to point to newly allocated region (stored as offset in bytes)
                    INST_WR32(0, KDA_HARDWIRED_PTR_LOC, pDev->DBfbKDASharedMem<<4);
                    for (i = KDA_HEADER_DRIVER_FLAGS_LOC; i < (S032) KDASizeBytes; i+=sizeof(U032)) {
                        temp = INST_RD32(origBufLoc, i);
                        INST_WR32(pDev->DBfbKDASharedMem, i, temp);
                    }
                } else {
                    for (i = (S032) KDASizeBytes - sizeof(U032); i >= KDA_HEADER_DRIVER_FLAGS_LOC; i-=sizeof(U032)) {
                        temp = INST_RD32(origBufLoc, i);
                        INST_WR32(pDev->DBfbKDASharedMem, i, temp);
                    }
                    //Reassign buffer pointer to point to newly allocated region (stored as offset in bytes)
                    INST_WR32(0, KDA_HARDWIRED_PTR_LOC, pDev->DBfbKDASharedMem<<4);
                    for (i = KDA_HEADER_DRIVER_FLAGS_LOC; i >= 0; i-=sizeof(U032)) {
                        temp = INST_RD32(origBufLoc, i);
                        INST_WR32(pDev->DBfbKDASharedMem, i, temp);
                    }
                }

                /*
                //1. Copy over the driver flags so the new location also indicates we
                // own the semaphore.
                temp = INST_RD32(origBufLoc, KDA_HEADER_DRIVER_FLAGS_LOC);
                INST_WR32(pDev->DBfbKDASharedMem, KDA_HEADER_DRIVER_FLAGS_LOC, temp);
                //2. Overwrite buffer pointer to point to newly allocated region (stored as offset in bytes)
                INST_WR32(0, KDA_HARDWIRED_PTR_LOC, pDev->DBfbKDASharedMem<<4);
                //3. Copy the whole buffer.
                for (i = 0; i < KDA_MEM_SIZE; i+=sizeof(U032)) {
                    temp = INST_RD32(origBufLoc, i);
                     INST_WR32(pDev->DBfbKDASharedMem, i, temp);
                }
                */
                fbKDAReleaseBufferSemaphore(pDev);
            } else {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "    NVRM: FB KDA allocation error!\r\n");
                fbFreeInstMem(pDev, pDev->DBfbKDASharedMem, KDA_MEM_SIZE>>4);
                INST_WR32(0, KDA_HARDWIRED_PTR_LOC, 0); //Note we only write this if the BIOS supports the hw icon feature
                pDev->DBfbKDASharedMem = 0; //Special 'it's not there' value.
            }
        }
    } else {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: BIOS does not support hardware icons in instance memory.\r\n");
    }
#else  //if defined(WIN32) && defined (KDA_BUFFER_ENABLED)
    //LPL: Legacy allocs, not used anymore.
    //
    // Allocate Instance memory for the cursor image - must be aligned to 2k.
    //
    // KJK This should be removed once the new cursor interface is enabled in the display
    // driver.
    //
    status = fbAllocInstMemAlign(pDev, &pDev->Dac.CursorImageInstance, 0x800 / 16, 0x800 / 16);
    if (status)
    {
        osFreeMem((void *)pDev->DBfbInstBitmap);
        pDev->DBfbInstBitmap = 0;
        return (status);
    }


    //
    // Allocate the cached cursors and clear all current state
    // 
    for (entry=0; entry < MAX_CACHED_CURSORS; entry++)
    {   
        status = fbAllocInstMemAlign(pDev, &pDev->Dac.CursorImageCacheInstance[entry], 0x800 / 16, 0x800 / 16);
        if (status)
        {
            osFreeMem((void *)pDev->DBfbInstBitmap);
            pDev->DBfbInstBitmap = 0;
            return (status);
        }
        //
        // Since we're no longer maintaining the cache across mode changes, just
        // wipe the cache clean.
        //
        pDev->Dac.CursorMaskCRC[entry] = 0;                    
    }                    
#endif  //if defined(WIN32) && defined (KDA_BUFFER_ENABLED)

    return RM_OK;
} // end of fbInitializeInstMemBitMap 

RM_STATUS fbClearInstMem
(
    PHWINFO pDev
)
{
    U032 fb;
#if defined(KDA_BUFFER_ENABLED)

    if (pDev->DBfbKDASharedMem)
    {
        U032 KDAStart, KDASizeBytes, KDAEnd;
        // If a KDA exists, make sure not to clear it.

        KDAStart     = pDev->DBfbKDASharedMem << 4;
        KDASizeBytes = INST_RD32(pDev->DBfbKDASharedMem, KDA_HEADER_BUFFER_SIZE_LOC);
        KDAEnd       = KDAStart + KDASizeBytes;

        if (KDASizeBytes == 0)
        {
            return RM_ERROR;
        }

        for (fb = 0; fb < ((KDAStart - BIOS_IMAGE_PAD) / 4); fb++)
        {
            REG_WR32(NV_PRAMIN_DATA032(fb) + BIOS_IMAGE_PAD, 0);
        }

        for (fb = ((KDAEnd - BIOS_IMAGE_PAD) / 4); fb < ((pDev->Pram.HalInfo.TotalInstSize - BIOS_IMAGE_PAD) / 4); fb++)
        {
            REG_WR32(NV_PRAMIN_DATA032(fb) + BIOS_IMAGE_PAD, 0);
        }
    }
    else
#endif // defined(KDA_BUFFER_ENABLED)
    {
        for (fb = 0; fb < ((pDev->Pram.HalInfo.TotalInstSize - BIOS_IMAGE_PAD) / 4); fb++)
            REG_WR32(NV_PRAMIN_DATA032(fb) + BIOS_IMAGE_PAD, 0);
    }

    return RM_OK;
} // end of fbClearInstMem

//---------------------------------------------------------------------------
//
//  PRAM allocation and de-allocation.
//
//---------------------------------------------------------------------------

/*	alloc instance mem with specified alignment
*/
RM_STATUS fbAllocInstMemAlign
(
    PHWINFO pDev,
    U032   *Instance,
    U032    Size,
    U032    Align		
)
{
    U032 i;
    U032 j;
	U032 mask;

    if (pDev->Power.State != 0)
    {
        return (RM_ERR_NO_FREE_MEM);
    }

    DBG_VAL_PTR(pDev->DBfbInstBitmap);
#if DEBUG
    if (Size == 0)    
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Zero size in fbAllocInstMem!\n\r");
        DBG_BREAKPOINT();
    }
#endif
    *Instance = 0;

    osEnterCriticalCode(pDev);

	i = pDev->Pram.FreeInstBase;		// get base of inst memory
	mask = Align - 1;
	while (mask & i)		 			// align i
		i += 0x1;						// try next page
	i -= pDev->Pram.FreeInstBase;		// offset from base
    for ( ; i < pDev->Pram.FreeInstMax; i += Align)
    {
		U032 k = i;

        if (pDev->DBfbInstBitmap[k >> 3] & BIT(k & 7))		// available?
        {
            //
            // Search for string of 1's the length of the block.
            //
            j = 0;
            do
            {
                if ((++k >= pDev->Pram.FreeInstMax) || (++j >= Size))
                    break;
            }
            while (pDev->DBfbInstBitmap[k >> 3] & BIT(k & 7));
            if (j == Size)
            {
                //
                // Score, a block was found.
                //
                *Instance = k - j + pDev->Pram.FreeInstBase;
                while (j--)
                {
                    //
                    // Mark instance memory as allocated.
                    //
                    k--;
                    pDev->DBfbInstBitmap[k >> 3] &= ~BIT(k & 7);
                }
                osExitCriticalCode(pDev);
#if defined(NTRM) && defined(DBG)
                osLogInstMemAlloc(*Instance, Size, Align);
#endif
                return (RM_OK);
            }
        }
    }
    osExitCriticalCode(pDev);
    return (RM_ERR_NO_FREE_MEM);
}

RM_STATUS fbAllocInstMem
(
    PHWINFO pDev,
    U032   *Instance,
    U032    Size
)
{
    U032 i;
    U032 j;

    switch(pDev->Power.State)
    {
        case MC_POWER_LEVEL_0:
        case MC_POWER_LEVEL_5:
        case MC_POWER_LEVEL_6:
            break;
        default:
            return (RM_ERR_NO_FREE_MEM);
    }

    DBG_VAL_PTR(pDev->DBfbInstBitmap);
#if DEBUG
    if (Size == 0)    
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Zero size in fbAllocInstMem!\n\r");
        DBG_BREAKPOINT();
    }
#endif
    *Instance = 0;

    osEnterCriticalCode(pDev);

    for (i = 0; i < pDev->Pram.FreeInstMax; i++)
    {
        if (!pDev->DBfbInstBitmap[i >> 3])
        {
            i += 7;
        }
        else if (pDev->DBfbInstBitmap[i >> 3] & BIT(i & 7))
        {
            //
            // Search for string of 1's the length of the block.
            //
            j = 0;
            do
            {
                if ((++i >= pDev->Pram.FreeInstMax) || (++j >= Size))
                    break;
            }
            while (pDev->DBfbInstBitmap[i >> 3] & BIT(i & 7));
            if (j == Size)
            {
                //
                // Score, a block was found.
                //
                *Instance = i - j + pDev->Pram.FreeInstBase;
                while (j--)
                {
                    //
                    // Mark instance memory as allocated.
                    //
                    i--;
                    pDev->DBfbInstBitmap[i >> 3] &= ~BIT(i & 7);
                }
                osExitCriticalCode(pDev);
#if defined(NTRM) && defined(DBG)
                osLogInstMemAlloc(*Instance, Size, 0);
#endif
                return (RM_OK);
            }
        }
    }
    osExitCriticalCode(pDev);
    return (RM_ERR_NO_FREE_MEM);
}
RM_STATUS fbFreeInstMem
(
    PHWINFO pDev,
    U032    Instance,
    U032    Size
)
{
#if defined(NTRM) && defined(DBG)
	U032 actualInstance = Instance;
	U032 actualSize = Size;
#endif // DEBUG && NTRM

    //
    // If instance is already set to 0, then it has already been freed.  This can
    // happen in some cases when a mode switch is happening while MIDI is playing
    // using the timer alarm notifies.  Ignoring this case can potentially cause a
    // protection fault, so be careful.
    //
    if (!Instance)
        return (RM_OK);
    if (!pDev->DBfbInstBitmap)
        return (RM_OK);

    osEnterCriticalCode(pDev);

    Instance -= pDev->Pram.FreeInstBase;
#if DEBUG
    if (Instance > pDev->Pram.FreeInstMax)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ERROR - Freed instance out of range!\n\r");
        DBG_BREAKPOINT();
    }
#endif // DEBUG
    while (Size--)
    {
        //
        // Mark instance memory as free.
        //
        pDev->DBfbInstBitmap[Instance >> 3] |= BIT(Instance & 7);
        Instance++;
    }
    osExitCriticalCode(pDev);

#if defined(NTRM) && defined(DBG)
    osUnlogInstMemAlloc(actualInstance, actualSize);
#endif // DEBUG

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\fb\nv4\fbnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ Chip Specific HAL FB Routines ********************\
*                                                                           *
* Module: fbnv04.c                                                          *
*   The NV4 specific HAL FB routines reside in this file.                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include <heap.h>
#include "nvhw.h"
#include "os.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalFbControl_NV04(VOID *);
RM_STATUS nvHalFbSetAllocParameters_NV04(VOID *);
RM_STATUS nvHalFbAlloc_NV04(VOID *);
RM_STATUS nvHalFbFree_NV04(VOID *);
RM_STATUS nvHalFbGetSurfacePitch_NV04(VOID *);
RM_STATUS nvHalFbGetSurfaceDimensions_NV04(VOID *);
RM_STATUS nvHalFbLoadOverride_NV04(VOID *);
static U032 nvHalFbRealMemSize(U032, PHWREG);
static U032 calcChkSum(PHWREG, U032);
static void restoreFbSave(U032 *, PHWREG, U032);

// NV4 expects a 512byte alignment
#define FC_MIN_ALIGN_SHIFT      9

/*****************************************************************************
 * tetris tiling
 *****************************************************************************/
char tetris_tile_table_signature[] = "_TETRIS_TILE_TABLE_";
static U032 NvChipTetrisTileTable[] =
{
// width  depth input_width  shift                               mode
//   |    |     |            |                                   |
     320, 16 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/0, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     640, 16 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/1, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     800, 16 | (128 << 16),  0, 0,
    1024, 16 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/1, /*NV_PFB_CONFIG_0_TETRIS_MODE*/3,
    1280, 16 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,

     320, 32 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/1, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     640, 32 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     800, 32 | (128 << 16),  0, 0,
    1024, 32 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/3,
    1280, 32 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,

     320, 16 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/0, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     640, 16 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/1, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     800, 16 | ( 64 << 16),  0, 0,
    1024, 16 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/1, /*NV_PFB_CONFIG_0_TETRIS_MODE*/2,
    1280, 16 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,

     320, 32 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/1, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     640, 32 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     800, 32 | ( 64 << 16),  0, 0,
    1024, 32 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/2,
    1280, 32 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,

    /* all others are disabled */
};

static RM_STATUS
nvHalTetrisTileWrite_NV04(PHALHWINFO pHalHwInfo, U032 NewConfig0Value)
{
    PFBHALINFO pFbHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    PPRAMHALINFO pPramHalInfo;
    U032 OldConfig0Value;

    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    pPramHalInfo = pHalHwInfo->pPramHalInfo;

    /*
     * check if we need to reprogram tiling
     */
    OldConfig0Value = REG_RD32(NV_PFB_CONFIG_0);
    NewConfig0Value = (NewConfig0Value & 0x000fffff) | (OldConfig0Value & 0xfff00000);
    if (NewConfig0Value != OldConfig0Value)
    {
        U032      reg0140;
        U032      reg2500;
        U032      reg3200;
        U032      reg3250;
        U032      size    = pPramHalInfo->TotalInstSize;
        VOID*     fbBase  = pHalHwInfo->fbBaseAddr;
        U032      fbSize  = pFbHalInfo->RamSize;
        U032      i;
        U008      *src, *dest;
        U032      sizeMinusU032;
        PMCHALINFO          pMcHalInfo;
        pMcHalInfo = pHalHwInfo->pMcHalInfo;
        /*
         * save instance and driver memory
         */
        src = (U008 *)fbBase + fbSize - size;
        dest = (U008 *)pFbHalPvtInfo->bufferBase;

        DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalTetrisTileWrite_NV04: src ", src);
        DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalTetrisTileWrite_NV04: dest ", dest);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalTetrisTileWrite_NV04: count ", size);
        sizeMinusU032 = size - sizeof(U032);
        for (i = 0; i < sizeMinusU032; i++)
        {
            dest[i] = src[i];
        }

        if (IsNV0A_NV04(pMcHalInfo))
        {
            dest[i]   = 0x77;
            dest[i+1] = 0xcc;
            dest[i+2] = 0x56;
            dest[i+3] = 0x49;
        }
        else
        {
            for(i=sizeMinusU032; i<size; i++)
            {
                dest[i] = src[i]; 
            }
        }
        /*
         * disable chip
         */
        HAL_GR_IDLE(pHalHwInfo);
        WriteIndexed(NV_PRMVIO_SRX, 0x0000);  // _outp (0x3c4,0); _outp (0x3c5,0);
        reg2500 = REG_RD32(NV_PFIFO_CACHES);       REG_WR32(NV_PFIFO_CACHES, 0);
        reg3200 = REG_RD32(NV_PFIFO_CACHE1_PUSH0); REG_WR32(NV_PFIFO_CACHE1_PUSH0, 0);
        reg3250 = REG_RD32(NV_PFIFO_CACHE1_PULL0); REG_WR32(NV_PFIFO_CACHE1_PULL0, 0);
        reg0140 = REG_RD32(NV_PMC_INTR_EN_0);      REG_WR32(NV_PMC_INTR_EN_0, 0);

        /*
         * program tiling
         */
        REG_WR32(NV_PFB_CONFIG_0, NewConfig0Value);

        /*
         * restore instance and driver memory
         */
        for (i = 0; i < size; i++)
        {
            src[i] = dest[i];
        }

        /*
         * re-enable chip
         */
        REG_WR32(NV_PMC_INTR_EN_0, reg0140);
        REG_WR32(NV_PFIFO_CACHE1_PULL0, reg3250);
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, reg3200);
        REG_WR32(NV_PFIFO_CACHES, reg2500);
        WriteIndexed(NV_PRMVIO_SRX, 0x0300); // _outp (0x3c4,0); _outp (0x3c5,3);
    }

    /*
     * done
     */
    return RM_OK;
}


static RM_STATUS
nvHalTetrisTile_NV04(PHALHWINFO pHalHwInfo)
{   
    PFBHALINFO pFbHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    PDACHALINFO pDacHalInfo;
    U032 width, depth;
    U032 i;

    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalTetrisTile_NV04: tiling mode ", pFbHalPvtInfo->tilingDisabled);

    if (!pFbHalPvtInfo->tilingDisabled)
    {
        /*
         * determine if we should setup special tiling for this mode
         */
        width = pFbHalInfo->HorizDisplayWidth;
        depth = pDacHalInfo->Depth | (pDacHalInfo->InputWidth << 16);

#if 0
        /* DO NOT REMOVE - used for tiling tests */
        *((U032*)0xb0050) = (U032)NvChipTetrisTileTable;
#endif

        for (i = 0; i < sizeof(NvChipTetrisTileTable) / sizeof(U032); i += 4)
        {
            if ((NvChipTetrisTileTable[i + 0] == width)
             && (NvChipTetrisTileTable[i + 1] == depth)
             &&  NvChipTetrisTileTable[i + 2]
             &&  NvChipTetrisTileTable[i + 3])
            {
                U032 NewConfig0Value;

                /*
                 * calculate new tiling info
                 */
                NewConfig0Value = NV_PFB_CONFIG_0_TYPE_TETRIS
                                | (NvChipTetrisTileTable[i + 2] << 18)
                                | (NvChipTetrisTileTable[i + 3] << 15);

                /*
                 * program the tiling
                 */
                nvHalTetrisTileWrite_NV04(pHalHwInfo, NewConfig0Value);

                /*
                 * done
                 */
                return RM_OK;
            }
        }
    }  // Tiling is not disabled

    /*
     * disable tiling
     */
    nvHalTetrisTileWrite_NV04(pHalHwInfo, NV_PFB_CONFIG_0_TYPE_NOTILING);

    /*
     * done
     */
    return RM_OK;
}

//
// nvHalFbControl
//
//
RM_STATUS
nvHalFbControl_NV04(VOID *arg)
{
    PFBCONTROLARG_000 pFbControlArg = (PFBCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO pFbHalInfo;
    PPRAMHALINFO pPramHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    U032 test_mem;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbControlArg->id != FB_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbControlArg->pHalHwInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pPramHalInfo = pHalHwInfo->pPramHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;

    switch (pFbControlArg->cmd)
    {
        case FB_CONTROL_INIT:
            //
            // Save off chip-dependent fb state.
            //
            pFbHalPvtInfo->fbSave[0] = REG_RD32(NV_PFB_CONFIG_0);
            pFbHalPvtInfo->fbSave[1] = REG_RD32(NV_PFB_CONFIG_1);

            //
            // Since this is only called from initFb(), we'll do this here
            // KJK Verify a valid RTL setting
            //
            REG_WR32(NV_PFB_RTL, 0);

            //
            // Setup pointer to our tiling save area.  It's immediately
            // after the FBHALINFO_NV04 structure in our engine
            // private data area setup by the RM.
            //
            pFbHalPvtInfo->bufferBase = (U008*)pFbHalPvtInfo + sizeof (FBHALINFO_NV04);

            //
            //  Set RamType
            //
            switch (REG_RD_DRF(_PFB, _BOOT_0, _RAM_TYPE)) {
                //case NV_PFB_BOOT_0_RAM_TYPE_1024K_2BANK:
                case NV_PFB_BOOT_0_RAM_TYPE_SDRAM_16MBIT:
                case NV_PFB_BOOT_0_RAM_TYPE_SDRAM_64MBIT:
                case NV_PFB_BOOT_0_RAM_TYPE_SDRAM_64MBITX16:
                    pFbHalInfo->RamType = BUFFER_SDRAM;
                    break;
                default:
                    // Everything else is SGRAM
                    pFbHalInfo->RamType = BUFFER_SGRAM;
                    break;
            }

            if (REG_RD_DRF(_PFB, _BOOT_0, _UMA)){
                pFbHalInfo->RamType = BUFFER_CRUSH_UMA;
            }

            //
            // Set RamSize (in bytes)
            // 
            // Note: we should have a better way of determining the number of
            // banks (should check the encoded value in the _RAM_TYPE field).
            // In order to avoid possible fragmentation, especially with the
            // smaller mem configs, we'll only use a BankCount of 2.
            //
            switch (REG_RD_DRF(_PFB, _BOOT_0, _RAM_AMOUNT)) {
                case NV_PFB_BOOT_0_RAM_AMOUNT_16MB:
                    pFbHalInfo->RamSizeMb = 16;
                    pFbHalInfo->RamSize   = 0x01000000;
                    pFbHalInfo->BankCount = 2;
                    break;
                case NV_PFB_BOOT_0_RAM_AMOUNT_8MB:
                    pFbHalInfo->RamSizeMb = 8;
                    pFbHalInfo->RamSize   = 0x00800000;
                    pFbHalInfo->BankCount = 2;
                    break;
                case NV_PFB_BOOT_0_RAM_AMOUNT_4MB:
                    pFbHalInfo->RamSizeMb = 4;
                    pFbHalInfo->RamSize   = 0x00400000;
                    pFbHalInfo->BankCount = 2;
                    break;
                case NV_PFB_BOOT_0_RAM_AMOUNT_2MB:
                    //
                    // This is overloaded in NV4.5 to denote 32meg.  We'll never see a 2meg NV4.
                    //
                    pFbHalInfo->RamSizeMb = 32;
                    pFbHalInfo->RamSize = 0x02000000;
                    pFbHalInfo->BankCount = 2;
                    break;
                default:
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Illegal RAM size in NV_PFB_BOOT_0\n\r");
                    DBG_BREAKPOINT();
                    pFbHalInfo->RamSizeMb = 8;
                    pFbHalInfo->RamSize = 0x00800000;
                    pFbHalInfo->BankCount = 2;
                    break;
            }

            //
            // Load config 0 value.
            //
            if (pFbHalInfo->RamSize == 0x00200000)
                FLD_WR_DRF_DEF(_PFB, _CONFIG_0, _BANK_SWAP, _2M);
            else
                FLD_WR_DRF_DEF(_PFB, _CONFIG_0, _BANK_SWAP, _4M);
            
            //
            // Check for UMA usage
            //
            // Note that this is only valid for NV0A, but the other NV4 variants hardwire these
            // bit fields to zero.
            //
            if (REG_RD_DRF(_PFB, _BOOT_0, _UMA) == NV_PFB_BOOT_0_UMA_ENABLE)
                switch (REG_RD_DRF(_PFB, _BOOT_0, _UMA_SIZE)) {
                    case NV_PFB_BOOT_0_UMA_SIZE_2M:
                        pFbHalInfo->RamSizeMb = 2;
                        pFbHalInfo->RamSize   = 0x00200000;
                        break;                 
                    case NV_PFB_BOOT_0_UMA_SIZE_4M:
                        pFbHalInfo->RamSizeMb = 4;
                        pFbHalInfo->RamSize   = 0x00400000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_6M:
                        pFbHalInfo->RamSizeMb = 6;
                        pFbHalInfo->RamSize   = 0x00600000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_8M:
                        pFbHalInfo->RamSizeMb = 8;
                        pFbHalInfo->RamSize   = 0x00800000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_10M:
                        pFbHalInfo->RamSizeMb = 10;
                        pFbHalInfo->RamSize   = 0x00A00000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_12M:
                        pFbHalInfo->RamSizeMb = 12;
                        pFbHalInfo->RamSize   = 0x00C00000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_14M:
                        pFbHalInfo->RamSizeMb = 14;
                        pFbHalInfo->RamSize   = 0x00E00000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_16M:
                        pFbHalInfo->RamSizeMb = 16;
                        pFbHalInfo->RamSize   = 0x01000000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_18M:
                        pFbHalInfo->RamSizeMb = 18;
                        pFbHalInfo->RamSize   = 0x01200000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_20M:
                        pFbHalInfo->RamSizeMb = 20;
                        pFbHalInfo->RamSize   = 0x01400000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_22M:
                        pFbHalInfo->RamSizeMb = 22;
                        pFbHalInfo->RamSize   = 0x01600000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_24M:
                        pFbHalInfo->RamSizeMb = 24;
                        pFbHalInfo->RamSize   = 0x01800000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_26M:
                        pFbHalInfo->RamSizeMb = 26;
                        pFbHalInfo->RamSize   = 0x01A00000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_28M:
                        pFbHalInfo->RamSizeMb = 28;
                        pFbHalInfo->RamSize   = 0x01C00000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_30M:
                        pFbHalInfo->RamSizeMb = 30;
                        pFbHalInfo->RamSize   = 0x01E00000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_32M:
                        pFbHalInfo->RamSizeMb = 32;
                        pFbHalInfo->RamSize   = 0x02000000;
                        break;
                    default:
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Illegal UMA size in NV_PFB_BOOT_0\n\r");
                        DBG_BREAKPOINT();
                        pFbHalInfo->RamSizeMb = 8;
                        pFbHalInfo->RamSize   = 0x00800000;
                        break;
                }

            //CAH:Actually step through memory to verify we have as much there as the BIOS is 
            //telling us. On some "gray" market boards they may be strapped to report 
            //double the actual physical memory.This test will step through the framebuffer
            //to determine if it's actually there.
            test_mem = nvHalFbRealMemSize(pFbHalInfo->RamSizeMb, pHalHwInfo->fbBaseAddr);

            if (pFbHalInfo->RamSizeMb != test_mem) 
            {

                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: RamSize incorrectly read from BIOS\n\r");
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Resetting RamSize from Memory Test\n\r");
                return (RM_ERROR);
            }

            //
            // Set instance space size.  Add in whatever os-dependent
            // (i.e. BIOS) space is needed as well.
            //
            // For NV4, this is 128K allocatable.
            //
            pPramHalInfo->TotalInstSize = 0x20000 + pPramHalInfo->InstPadSize;

            //
            // Configure hash table.
            //
            pFbHalPvtInfo->hashTableSize = 0x4000;
            pPramHalInfo->HashDepth = pFbHalPvtInfo->hashTableSize / sizeof (HASH_TABLE_ENTRY);
            pPramHalInfo->HashSearch = 128;
            pFbHalPvtInfo->hashTableAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize;
            REG_WR32(NV_PFIFO_RAMHT, (DRF_DEF(_PFIFO, _RAMHT, _SIZE, _16K) |
                                      DRF_NUM(_PFIFO, _RAMHT, _BASE_ADDRESS, (pFbHalPvtInfo->hashTableAddr - DEVICE_BASE(NV_PRAMIN)) >> 12) |
                                      DRF_DEF(_PFIFO, _RAMHT, _SEARCH, _128)));

            //
            // Configure fifo context area.
            //
            pFbHalPvtInfo->fifoContextSize = NUM_FIFOS_NV04 * FC_SIZE_NV04;
            pFbHalPvtInfo->fifoContextAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize + pFbHalPvtInfo->hashTableSize;
            REG_WR_DRF_NUM(_PFIFO, _RAMFC, _BASE_ADDRESS, ((pFbHalPvtInfo->fifoContextAddr - DEVICE_BASE(NV_PRAMIN)) >> FC_MIN_ALIGN_SHIFT));

            //
            // Configure runout area.
            //
            pFbHalPvtInfo->fifoRunoutSize = 512;
            pFbHalPvtInfo->fifoRunoutAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize +
                pFbHalPvtInfo->hashTableSize + pFbHalPvtInfo->fifoContextSize;
            pFbHalPvtInfo->fifoRunoutMask = pFbHalPvtInfo->fifoRunoutSize - 1;
            REG_WR32(NV_PFIFO_RAMRO, (DRF_DEF(_PFIFO, _RAMRO, _SIZE, _512) |
                                      DRF_NUM(_PFIFO, _RAMRO, _BASE_ADDRESS, (pFbHalPvtInfo->fifoRunoutAddr - DEVICE_BASE(NV_PRAMIN)) >> 9)));

            //
            // Sum of all allocations plus a little slop
            //
            pPramHalInfo->CurrentSize  = pFbHalPvtInfo->hashTableSize + pFbHalPvtInfo->fifoContextSize + pFbHalPvtInfo->fifoRunoutSize + 512;

            break;
        case FB_CONTROL_LOAD:
            break;
        case FB_CONTROL_UNLOAD:
            break;
        case FB_CONTROL_UPDATE:
            break;
        case FB_CONTROL_DESTROY:
            // We now do everything tiled (mode switches and fullscreen DOS boxes), so reverting
            // to a boot time non-tiled PFB_CONFIG_0 will corrupt the shutdown splash screen since
            // it was written to a tiled FB. If we're tiled at this point, we'll just stay tiled.
            if (pFbHalPvtInfo->tilingDisabled == TRUE) {
                REG_WR32(NV_PFB_CONFIG_0, pFbHalPvtInfo->fbSave[0]);
                REG_WR32(NV_PFB_CONFIG_1, pFbHalPvtInfo->fbSave[1]);
            }            
            break;
        case FB_CONTROL_INSTWR_DISABLE:
#if 0
            // We have a bug in NV4 hardware which makes the write protection also a read protection.
            // We'll depend on the save above to protect instance memory. If we turn on write protect, it may
            // cause problems on a restart, because either the BIOS image won't be found or can't be copied.
            // 
            //
            // Disable access to instance memory while a full-screen DOS VGA session is active, as they
            // may accidently (intentionally?) clear the entire framebuffer through VGA.
            //
            FLD_WR_DRF_DEF(_PFB, _CONFIG_0, _PRAMIN_WR, _DISABLED);
            FLD_WR_DRF_NUM(_PFB, _CONFIG_0, _PRAMIN_WR_MASK, 0x0001);
#endif
            break;
        case FB_CONTROL_INSTWR_ENABLE:
            FLD_WR_DRF_DEF(_PFB, _CONFIG_0, _PRAMIN_WR, _INIT);
            break;
        case FB_CONTROL_TILING_DISABLE:
            pFbHalPvtInfo->tilingDisabled = TRUE;
            break;
        case FB_CONTROL_TILING_ENABLE:
            pFbHalPvtInfo->tilingDisabled = FALSE;
            break;
        case FB_CONTROL_TILING_CONFIGURE:
            nvHalTetrisTile_NV04(pFbControlArg->pHalHwInfo);
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}


//
// nvHalFbGetSurfacePitch
//
// Given a width and bits per pixel, return the surface pitch
//

// I don't like this #ifdef ... this is just for the nightly build
#ifdef NTRM
#define NV4_PITCHALIGN  0x1F
#else
#define NV4_PITCHALIGN  0x3F
#endif

RM_STATUS
nvHalFbGetSurfacePitch_NV04(VOID *arg)
{
    PFBGETSURFACEPITCHARG_000 pFbGetSurfacePitchArg = (PFBGETSURFACEPITCHARG_000)arg;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbGetSurfacePitchArg->id != FB_GET_SURFACE_PITCH_000)
        return (RM_ERR_VERSION_MISMATCH);

    // surfaces are (depending on who you talk to) 32byte/64byte aligned
    // Watch out for bpp==15: add 1 here to force 15 to 16 for the shift
    pFbGetSurfacePitchArg->pitch = ((pFbGetSurfacePitchArg->width * ((pFbGetSurfacePitchArg->bpp+1) >> 3)) + NV4_PITCHALIGN) & ~NV4_PITCHALIGN;

    return RM_OK;
}

//
// nvHalFbGetSurfaceDimensions
//
// Given a width, height and bits per pixel, return the surface pitch and size
//
RM_STATUS
nvHalFbGetSurfaceDimensions_NV04(VOID *arg)
{
    PFBGETSURFACEDIMENSIONSARG_000 pFbGetSurfaceDimensionsArg = (PFBGETSURFACEDIMENSIONSARG_000)arg;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbGetSurfaceDimensionsArg->id != FB_GET_SURFACE_DIMENSIONS_000)
        return (RM_ERR_VERSION_MISMATCH);

    // surfaces are (depending on who you talk to) 32byte/64byte aligned
    // Watch out for bpp==15: add 1 here to force 15 to 16 for the shift
    pFbGetSurfaceDimensionsArg->pitch = ((pFbGetSurfaceDimensionsArg->width * ((pFbGetSurfaceDimensionsArg->bpp+1) >> 3)) + NV4_PITCHALIGN) & ~NV4_PITCHALIGN;
    pFbGetSurfaceDimensionsArg->size  = pFbGetSurfaceDimensionsArg->pitch * pFbGetSurfaceDimensionsArg->height;

    return RM_OK;
}

//
// nvHalFbAlloc
//
// Reserve a tile if one is available.
//
RM_STATUS
nvHalFbSetAllocParameters_NV04(VOID *arg)
{
    PFBSETALLOCPARAMSARG_000 pFbSetAllocParamsArg = (PFBSETALLOCPARAMSARG_000)arg;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbSetAllocParamsArg->id != FB_SET_ALLOC_PARAMS_000)
        return (RM_ERR_VERSION_MISMATCH);

    return (RM_OK);
}

//
// nvHalFbAlloc
//
RM_STATUS
nvHalFbAlloc_NV04(VOID *arg)
{
    PFBALLOCARG_000 pFbAllocArg = (PFBALLOCARG_000)arg;
    PFBALLOCINFO pFbAllocInfo;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbAllocArg->id != FB_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pFbAllocInfo = pFbAllocArg->pAllocInfo;

    //
    // Set default alignment based on type.
    //
    switch (pFbAllocInfo->type) {
    case MEM_TYPE_IMAGE:
    case MEM_TYPE_OVERLAY:      
        pFbAllocInfo->align = 0x3f;     // 64 byte alignment
        break;
    case MEM_TYPE_TEXTURE:
        pFbAllocInfo->align = 0xff;     // 256 byte alignment
        break;
    case MEM_TYPE_FONT:
        pFbAllocInfo->align = 0x1f;     // 32 byte alignment
        break;
    case MEM_TYPE_CURSOR:
        pFbAllocInfo->align = 0x7ff;    // 2048 byte alignment
        break;
    case MEM_TYPE_DMA:
        pFbAllocInfo->align = 0x3;      // 4 byte alignment
        break;
    case MEM_TYPE_INSTANCE:
        pFbAllocInfo->align = 0xf;      // 16 byte alignment
        break;
    case MEM_TYPE_DEPTH:
    case MEM_TYPE_DEPTH_COMPR16:
    case MEM_TYPE_DEPTH_COMPR32:
    case MEM_TYPE_PRIMARY:
    case MEM_TYPE_IMAGE_TILED:
        pFbAllocInfo->align = 0xfff;    // 4096 byte alignment
        break;
    default:
        pFbAllocInfo->align = pFbAllocInfo->alignPerf = 0;
        return (RM_ERR_BAD_ARGUMENT);
    }

    pFbAllocInfo->alignPerf = pFbAllocInfo->align;

    return (RM_OK);
}

//
// nvHalFbFree
//
RM_STATUS
nvHalFbFree_NV04(VOID *arg)
{
    PFBFREEARG_000 pFbFreeArg = (PFBFREEARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pFbFreeArg->id != FB_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    return (RM_OK);
}

RM_STATUS
nvHalFbLoadOverride_NV04(VOID *arg)
{
    PFBLOADOVERRIDEARG_000 pFbLoadOverrideArg = (PFBLOADOVERRIDEARG_000)arg;
    PHALHWINFO pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pFbLoadOverrideArg->id != FB_LOAD_OVERRIDE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbLoadOverrideArg->pHalHwInfo;

    switch (pFbLoadOverrideArg->cmd)
    {
        case FB_LOAD_OVERRIDE_MEMORY:
            REG_WR32(NV_PFB_CONFIG_1, pFbLoadOverrideArg->value);
            break;
        case FB_LOAD_OVERRIDE_RTL:
            REG_WR32(NV_PFB_RTL, pFbLoadOverrideArg->value);
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//CAH: Setup to detect possible alliasing of memory to tell us we have double
//the memory that we actually do. This algorithm will detect the case where
//memory addresses lay on top of eachother so as to make it appear that there
//is twice the memory available than is physically present. 
static U032 nvHalFbRealMemSize(U032 RamSizeMb, PHWREG base)
{
    U032 i, wp = 0;
    U032 checksum1 = 0, checksum2 = 0;
    U032 fb_save[128]; 

    //Write 0,1,2,3,...N on each 1mb boundry in the FB
    for (i = 0, wp = 0; i < RamSizeMb; i++, wp += 0x00100000) 
    {
        fb_save[i] = base->Reg032[wp/4];
        base->Reg032[wp/4] = i;
        checksum1 += i;
        checksum2 = calcChkSum(base, i);
        if (checksum1 != checksum2)
        {
            restoreFbSave(fb_save, base, i);
            return i; 
        }
    }

    restoreFbSave(fb_save, base, --i);
    return RamSizeMb; //This means we made it all the way through memory.
}

static void restoreFbSave(U032 *save, PHWREG base, U032 index)
{
    U032 i, wp;

    for (i = 0, wp = 0; i <= index; i++, wp += 0x00100000)
    {
        base->Reg032[wp/4] = save[i];
    }
}

static U032 calcChkSum(PHWREG base, U032 index)
{
    U032 i, wp, checksum = 0;

    for (i = 0, wp = 0; i <= index; i++, wp += 0x00100000)
    {
        checksum += base->Reg032[wp/4];
    }

    return checksum;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\fb\nv\fbinit.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** FB Manager *********************************\
*                                                                           *
* Module: FBINIT.C                                                          *
*   The FrameBuffer is initialized in this module.  This is a one time      *
* occurance and then the module is unloaded.                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include "nvhw.h"
#include <state.h>
#include <class.h>
#include <fb.h>
#include <vga.h>
#include <os.h>
#include <tv.h>
#include <devinit.h>

// Registry access
extern char strDevNodeRM[];

// forwards
RM_STATUS initFbBiosData(PHWINFO, PBIOSDRVSLWPARMS);

//
// One time framebuffer initialization.
//
RM_STATUS initFb
(
    PHWINFO pDev
)
{
    BIOSDRVSLWPARMS biosDrvSlwParms;
    U032 status;
    U032 RmRamSizeMB;
    U032 AdjustDriveSlew;

    //
    // Hook up any bios BIP3 table data.
    //
    pDev->Framebuffer.HalInfo.pBiosDrvSlwParms = NULL;
    if (initFbBiosData(pDev, &biosDrvSlwParms) == RM_OK)
        pDev->Framebuffer.HalInfo.pBiosDrvSlwParms = (VOID_PTR)&biosDrvSlwParms;

    //
    // Account for BIOS_IMAGE_PAD.  This could be made os-indepedendent
    // so we don't waste 64K on platforms that don't need the bios.
    //
    pDev->Pram.HalInfo.InstPadSize = BIOS_IMAGE_PAD;

    //
    // By default adjust the drive slew parameters.
    // Check the registry for drive slew override.
    //
    pDev->Framebuffer.HalInfo.AdjustDriveSlew = 1;
    if (RM_OK == OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "AdjustDriveSlew", &AdjustDriveSlew))
        pDev->Framebuffer.HalInfo.AdjustDriveSlew = AdjustDriveSlew;

    //
    // Let HAL establish FB parameters:
    //   - dram sizes/bank counts
    //   - fifo context/hash table/run out sizes
    //
    status = nvHalFbControl(pDev, FB_CONTROL_INIT);

    //
    // Clear the bip3 table data pointer.
    //
    pDev->Framebuffer.HalInfo.pBiosDrvSlwParms = (VOID_PTR)NULL;

    //Did we config the frame buffer correctly? 
    if (status != RM_OK)
    {
        return (RM_ERROR);
    }

    // Make sure the values are valid
    if (pDev->Framebuffer.HalInfo.RamSize == 0 ||
        pDev->Framebuffer.HalInfo.RamSizeMb == 0)
    {
        return (RM_ERROR);
    }

    //
    // We may want to override the ram size with our own values from the registry
    //
    status = osReadRegistryDword(pDev, strDevNodeRM, "RmRamSizeMB", &RmRamSizeMB);
    if (status == RM_OK)
    {
        if (RmRamSizeMB < pDev->Framebuffer.HalInfo.RamSizeMb)
        {
            pDev->Framebuffer.HalInfo.RamSizeMb = RmRamSizeMB;
            pDev->Framebuffer.HalInfo.RamSize = RmRamSizeMB * 1024 * 1024;
        }
        else
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: RmRamSizeMB was set greater than actual physical ram size\n");             
            DBG_BREAKPOINT(); 
        }
    }

    fbLoadOverrides(pDev);

    //
    // Locate and size the free instance area. This is the base where
    // allocations should start and size of the allocatable inst mem.
    //
    pDev->Pram.FreeInstSize = pDev->Pram.HalInfo.TotalInstSize - BIOS_IMAGE_PAD - pDev->Pram.HalInfo.CurrentSize;
    pDev->Pram.FreeInstBase = (pDev->Pram.HalInfo.CurrentSize + BIOS_IMAGE_PAD) >> 4;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FreeInstSize ", pDev->Pram.FreeInstSize);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FreeInstBase ", pDev->Pram.FreeInstBase);

    //
    // Default to 640X480X16X1 framebuffer w/ VGA timing.
    //
    pDev->Framebuffer.DpmLevel          = 0;
    pDev->Framebuffer.HalInfo.HorizDisplayWidth = 640;
    pDev->Framebuffer.HalInfo.VertDisplayWidth  = 480;
    pDev->Dac.HalInfo.Depth     = 16;
    pDev->Framebuffer.HalInfo.RefreshRate       = 60;
    pDev->Framebuffer.Count             = 1;
    pDev->Framebuffer.Current           = 0;
    pDev->Framebuffer.FlipUsageCount    = 0;
    pDev->Framebuffer.FlipTo            = 0;
    pDev->Framebuffer.FlipFrom          = 0;
    pDev->Framebuffer.UpdateFlags       = 0;
    pDev->Framebuffer.HorizFrontPorch   = 0;
    pDev->Framebuffer.HorizSyncWidth    = 0;
    pDev->Framebuffer.HorizBackPorch    = 0;
    pDev->Framebuffer.VertFrontPorch    = 0;
    pDev->Framebuffer.VertSyncWidth     = 0;
    pDev->Framebuffer.VertBackPorch     = 0;
    pDev->Framebuffer.HSyncPolarity     = 0;
    pDev->Framebuffer.VSyncPolarity     = 0;
    pDev->Framebuffer.CSync             = 0;

    pDev->Framebuffer.HalInfo.Start[0] = 0x00000000;
    pDev->Framebuffer.HalInfo.Limit[0] = pDev->Framebuffer.HalInfo.RamSize - pDev->Pram.HalInfo.TotalInstSize - 1;
    pDev->Framebuffer.HalInfo.Start[1] = 0x00000000;
    pDev->Framebuffer.HalInfo.Limit[1] = 0x00000000;

    //
    // Check for os-specific mode overrides.
    //
    initFbEx(pDev);

    //
    // Make sure our write protection is disabled for now
    //
    nvHalFbControl(pDev, FB_CONTROL_INSTWR_ENABLE);

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RamSize ", pDev->Framebuffer.HalInfo.RamSize);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: TotalInstSize ", pDev->Pram.HalInfo.TotalInstSize);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Limit[0] ", pDev->Framebuffer.HalInfo.Limit[0]);

    return (fbCheckConfig(pDev));
}

//
// Get BIOS bip3 table data if it exists.
//
RM_STATUS initFbBiosData
(
    PHWINFO pDev,
    PBIOSDRVSLWPARMS pDrvSlwParms
)
{
    BMP_Control_Block bmpCtrlBlk;
    U032 offset;
    RM_STATUS rmStatus = RM_OK;

    //
    // Attempt to find the Drive/Slew parms in the BIOS' BMP tables.
    //
    rmStatus = DevinitGetBMPControlBlock(pDev, &bmpCtrlBlk, &offset);
    if (rmStatus != RM_OK)
        return rmStatus;

    //
    // Only available in rev 5/ver 0x13 tables.
    //
    if ((bmpCtrlBlk.CTL_Version == BMP_INIT_TABLE_VER_5) && (bmpCtrlBlk.CTL_Flags >= 0x13))
    {
        BMP_Struc_Rev5_0x13 bmpInitTable;
        rmStatus = BiosReadStructure(pDev, &bmpInitTable, offset,
                                     (U032 *)0, BMP_INIT5_0x13_FMT);
        if (rmStatus == RM_OK)
        {
            rmStatus = BiosReadStructure(pDev, pDrvSlwParms,
                                         bmpInitTable.BMP_DrvSlwParms_Block,
                                         (U032 *)0, BMP_DRVSLW_PARMS);
        }
    }
    else
    {
        rmStatus = RM_ERROR;
    }

    return rmStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\fifo\nv\fifo.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** FIFO Manager *******************************\
*                                                                           *
* Module: FIFO.C                                                            *
*   The FIFO is managed in this module.  Allocating and controlling the     *
*   FIFO hardware and servicing FIFO exceptions belong here.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <gr.h>
#include <os.h>
#include "control.h"
#include "nvhw.h"
#include "smp.h"

#ifdef WIN32
#include "nvwin32.h"   // XXX this shouldn't be needed
#else
#define NV_OS_WRITE_THEN_AWAKEN	   0x00000001
#endif


#ifdef DEBUG
U032 findex = 0;
U032 fifolog[MAX_FIFOLOG_LENGTH];
#endif

//---------------------------------------------------------------------------
//
//  FIFO assignment and deassignment to a client.
//
//---------------------------------------------------------------------------

//
// Allocate a User FIFO and return its channel ID.
//
RM_STATUS fifoAlloc
(
    PHWINFO pDev,
    U032    ClassNum,
    U032   *ChannelID
)
{
    U032       i;
    U032       ChID;
    PCLASS     pClass;
    U032       instSize, instAlign, instance;
    RM_STATUS  status;

    //
    // Make sure this channel class is supported on this chip.
    //
    if (classGetClass(&pDev->classDB, ClassNum, &pClass) == RM_ERROR)
        return RM_ERR_BAD_CLASS;

    //
    // If this class requires additional instance memory, get it now.
    //
    if (pClass->ClassInstMalloc)
    {
        instSize = CLASSINSTMALLOC_FIELD(*pClass->ClassInstMalloc, _SIZE);
        instAlign = CLASSINSTMALLOC_FIELD(*pClass->ClassInstMalloc, _ALIGN);

        if (instAlign)
            status = fbAllocInstMemAlign(pDev, &instance, instSize, instAlign);
        else
            status = fbAllocInstMem(pDev, &instance, instSize);
        if (status)
            return (status);
    }
    else
    {
        instance = 0; instSize = 0;
    }

    //
    // Look for unused FIFO.
    //
    for (ChID = 0; ChID < NUM_FIFOS; ChID++)
    {
        if (!pDev->DBfifoTable[ChID].InUse)
        {
            pDev->DBfifoTable[ChID].ObjectCount             = 0;
            pDev->DBfifoTable[ChID].ObjectTree              = NULL;
            pDev->DBfifoTable[ChID].InUse                   = TRUE;
            pDev->DBfifoTable[ChID].IsStalledPendingVblank  = FALSE;
            pDev->DBfifoTable[ChID].StallNotifier           = NULL;
            pDev->DBfifoTable[ChID].Put                     = 0;
            pDev->DBfifoTable[ChID].LastIllegalMthdObject   = NULL;
            pDev->DBfifoTable[ChID].Instance                = instance;
            pDev->DBfifoTable[ChID].InstanceSize            = instSize;
            for (i=0; i<NUM_SUBCHANNELS; i++)
                pDev->DBfifoTable[ChID].SubchannelContext[i] = NULL;

            break;
        }
    }
    if (ChID == NUM_FIFOS)
    {
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: No allocatable FIFO available.\n\r"));
        if (instance) fbFreeInstMem(pDev, instance, instSize);
        return (RM_ERR_NO_FREE_FIFOS);
    }
    FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: Allocate FIFO #: 0x%x\n", ChID));
    //
    // Install CLASS objects into object tree.
    //
    // KJK This goes away once NvAllocObject() is implemented.
    //
    if (classCreateWellKnownObjects(pDev, ChID) != RM_OK)
    {
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Unable to create well-known names!\n"));
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].InUse = FALSE;
        if (instance) fbFreeInstMem(pDev, instance, instSize);
        return (RM_ERR_CANT_CREATE_CLASS_OBJS);
    }

    osEnterCriticalCode(pDev);
    nvHalFifoAllocPio(pDev, ChID, instance);
    osExitCriticalCode(pDev);

    FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: fifoAllocate - CACHE1 currently mapped to ChID: 0x%x\n", REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID)));

    *ChannelID = ChID;
    return (RM_OK);
}
//
// Allocate a User DMA FIFO and return its channel ID.
//
RM_STATUS fifoAllocDma
(
    PHWINFO pDev,
    U032    ClassNum,
    U032   *ChannelID,
    PDMAOBJECT pDmaObject
)
{
    U032       i;
    U032       ChID;
    U032       fetchTrigger, fetchSize, fetchRequests;
    U032       instSize, instAlign, instance;
    PCLASS     pClass;
    RM_STATUS  status;

    //
    // Make sure this channel class is supported on this chip.
    //
    if (classGetClass(&pDev->classDB, ClassNum, &pClass) == RM_ERROR)
        return RM_ERR_BAD_CLASS;

    //
    // If this class requires additional instance memory, get it now.
    //
    if (pClass->ClassInstMalloc)
    {
        instSize = CLASSINSTMALLOC_FIELD(*pClass->ClassInstMalloc, _SIZE);
        instAlign = CLASSINSTMALLOC_FIELD(*pClass->ClassInstMalloc, _ALIGN);

        if (instAlign)
            status = fbAllocInstMemAlign(pDev, &instance, instSize, instAlign);
        else
            status = fbAllocInstMem(pDev, &instance, instSize);
        if (status)
            return (status);
    }
    else
    {
        instance = 0; instSize = 0;
    }

    //
    // Get default fetch parameters.
    //
    if (osSetFifoDmaParams(pDev, &fetchTrigger, &fetchSize, &fetchRequests))
        return RM_ERR_OPERATING_SYSTEM;

    //
    // Look for unused FIFO.
    //
    for (ChID = 0; ChID < NUM_FIFOS; ChID++)
    {
        if (!pDev->DBfifoTable[ChID].InUse)
        {
            pDev->DBfifoTable[ChID].ObjectCount             = 0;
            pDev->DBfifoTable[ChID].ObjectTree              = NULL;
            pDev->DBfifoTable[ChID].InUse                   = TRUE;
            pDev->DBfifoTable[ChID].IsStalledPendingVblank  = FALSE;
            pDev->DBfifoTable[ChID].StallNotifier           = NULL;
            pDev->DBfifoTable[ChID].Put                     = 0;
            pDev->DBfifoTable[ChID].LastIllegalMthdObject   = NULL;
            for (i=0; i<NUM_SUBCHANNELS; i++)
                pDev->DBfifoTable[ChID].SubchannelContext[i] = NULL;
            pDev->DBfifoTable[ChID].Instance                = instance;
            pDev->DBfifoTable[ChID].InstanceSize            = instSize;
            break;
        }
    }
    if (ChID == NUM_FIFOS)
    {
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: No allocatable FIFO available.\n\r"));
        if (instance) fbFreeInstMem(pDev, instance, instSize);
        return (RM_ERR_NO_FREE_FIFOS);
    }
    FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: Allocate FIFO #: 0x%x\n", ChID));
    //
    // Install CLASS objects into object tree.
    //
    // KJK This goes away once NvAllocObject() is implemented.
    //
    if (classCreateWellKnownObjects(pDev, ChID) != RM_OK)
    {
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Unable to create well-known names!\n"));
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].InUse = FALSE;
        if (instance) fbFreeInstMem(pDev, instance, instSize);
        return (RM_ERR_CANT_CREATE_CLASS_OBJS);
    }

    osEnterCriticalCode(pDev);
    status = nvHalFifoAllocDma(pDev, ChID, instance, pDmaObject->HalInfo.Instance, fetchTrigger, fetchSize, fetchRequests);
    osExitCriticalCode(pDev);
    if (status != RM_OK)
    {
        pDev->DBfifoTable[ChID].InUse = FALSE;
        if (instance) fbFreeInstMem(pDev, instance, instSize);
        return (status);
    }

    FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: fifoAllocateDma - CACHE1 currently mapped to ChID: 0x%x\n", REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID)));

    *ChannelID = ChID;
    return (RM_OK);
}

//
// Free up a User FIFO to the available pool.
//
RM_STATUS fifoFree
(
    PHWINFO pDev,
    U032    ChID
)
{
    POBJECT           DeadObject;

    FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: Freeing FIFO on ChID: 0x%x\n", ChID));

    //
    // Reset the channel, so it's in an idle state and clear the hashTable
    // for this ChID.
    //
    fifoResetChannelState(pDev, ChID);

    //
    // Remove objects from object database.
    //
    while (pDev->DBfifoTable[ChID].ObjectTree)
    {
        //
        // Free up all remaining objects.
        //
        DeadObject = (POBJECT)pDev->DBfifoTable[ChID].ObjectTree->Data;
        fifoDelObject(pDev, DeadObject);
        //
        // Class specific delete procedure.
        //
        //DeadObject->Name = NV_ZOMBIE_OBJECT;
        classDestroy((VOID*)pDev, DeadObject);
    }

#ifdef DEBUG
    if (pDev->DBfifoTable[ChID].ObjectCount != 0)
    {
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Object count not zero after deleting object tree!\n\r"));
        DBG_BREAKPOINT();
    }
#endif // DEBUG

    pDev->DBfifoTable[ChID].InUse = FALSE;

    //
    // Release any instance memory.  State in fifo object is
    // cleared when it's reallocated.
    //
    if (pDev->DBfifoTable[ChID].Instance != 0)
    {
        fbFreeInstMem(pDev, pDev->DBfifoTable[ChID].Instance, pDev->DBfifoTable[ChID].InstanceSize);
    }

    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  HASH table management.
//
//---------------------------------------------------------------------------

//
// Add entry into Hash Table.
//
RM_STATUS fifoAddHashEntry
(
    PHWINFO pDev,
    POBJECT Object,
    U032    ChID,
    U032    Instance
)
{
    U032 Hash, Entry, Limit;

    //
    // Query HAL for starting entry for this <handle,chid> pair.
    //
    nvHalFifoHashFunc(pDev, Object->Name, ChID, &Hash);

    //
    // Search table for free slot.
    //
    // We can't exceed the hardware's search limit and we also can't wrap
    // since there's a bug in current chips that prevents the hardware from
    // wrapping on a search.
    //
    Limit = Hash + pDev->Pram.HalInfo.HashSearch;
    if (Limit > pDev->Pram.HalInfo.HashDepth)
        Limit = pDev->Pram.HalInfo.HashDepth;
    for (Entry = Hash; Entry < Limit; Entry++)
    {
        //
        // Find first empty entry.
        //
        if (pDev->DBhashTable[Entry].Object == NULL)
            break;
    }

    if (pDev->DBhashTable[Entry].Object != NULL)
    {
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: FIFO Hash table is FULL!!\n\r"));
        return (RM_ERROR);
    }

    //
    // Add object to the Hash Table.
    //
    pDev->DBhashTable[Entry].Object = Object;
    pDev->DBhashTable[Entry].ChID   = ChID;

    nvHalFifoHashAdd(pDev, Entry, Object->Name, ChID, Instance,
                     ENGDECL_FIELD(*Object->Class->EngineDecl, _OBJRAMHT));

    return (RM_OK);
}
//
// Remove entry from Hash Table.
//
RM_STATUS fifoDelHashEntry
(
    PHWINFO pDev,
    POBJECT Object,
    U032    ChID
)
{
    U032              Entry;

    //
    // Skip hashing since we scan the whole table.
    //
    for (Entry = 0; Entry < pDev->Pram.HalInfo.HashDepth; Entry++)
    {
        if (pDev->DBhashTable[Entry].Object == Object && pDev->DBhashTable[Entry].ChID == ChID)
        {
            pDev->DBhashTable[Entry].Object = NULL;
            nvHalFifoHashDelete(pDev, Entry);
            return (RM_OK);
        }
    }
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  FIFO exception handling.
//
//---------------------------------------------------------------------------

#define BENSWORK

V032 fifoService
(
    PHWINFO pDev
)
{
    RM_STATUS status;
    V032      intr;
    POBJECT   Object;
    FIFOEXCEPTIONDATA FifoExceptionData;
    U032 i;
    static U032 fifoIsrCounter;

#ifdef BENSWORK
    U032      isDebuggerPresent;
    U032      mustNotifyDebugger;

    isDebuggerPresent  = ((PRMINFO)pDev->pRmInfo)->Debugger.object != NULL;
    mustNotifyDebugger = 0;
#endif

    NVRM_TRACE1('FISR');
    // count fifo isrs as part of fifo fixup heuristic below
    fifoIsrCounter++;

    status = RM_OK;
    intr   = REG_RD32(NV_PFIFO_INTR_0);

    //
    // Turn off reassign for the duration.
    //
    FLD_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);

    //
    // Get exception data from HAL.
    //
    nvHalFifoGetExceptionData(pDev, &FifoExceptionData);

    //
    // Here's where we'd bypass HAL fifo exception handling if needed.
    //

    //
    // Give HAL chance to service selected exceptions.
    //
    nvHalFifoService(pDev, intr, &FifoExceptionData);

    //
    // Refresh interrupt status value in case HAL cleared any exceptions.
    //
    intr = REG_RD32(NV_PFIFO_INTR_0);

    if (intr & DRF_DEF(_PFIFO, _INTR_0, _CACHE_ERROR, _PENDING))
    {
        //
        // Cache error handler.  We got here due to one of two issues.
        //
        // 1) The current object that was just hashed/routed is configured
        //    as a SW_ENGINE object
        // 2) There is no hash entry available for the current object
        //

        //
        // Disable the fifo
        //
        // Don't explicitly disable the puller -- it should already
        // be off by the time we get here.  Verify with an assert().
        //
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);

        FIFOLOG(1, 0, 0);

        //
        // Clear condition.
        //
        REG_WR_DRF_DEF(_PFIFO, _INTR_0, _CACHE_ERROR,  _RESET);

        FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: FIFO Cache miss Channel: 0x%x\n", FifoExceptionData.ChID));
        FIFO_PRINTF((DBG_LEVEL_INFO, "                  sub channel: 0x%x\n", FifoExceptionData.SubChannel));
        FIFO_PRINTF((DBG_LEVEL_INFO, "                       method: 0x%x\n", FifoExceptionData.Method));
        FIFO_PRINTF((DBG_LEVEL_INFO, "                         data: 0x%x\n", FifoExceptionData.Data));
        FIFO_PRINTF((DBG_LEVEL_INFO, "                       reason: 0x%x\n", FifoExceptionData.Reason));

        //
        // Timeout
        //
        i = 0xFFFF;
        while (i && (FifoExceptionData.Reason & DRF_DEF(_PFIFO, _CACHE1_PULL0, _HASH_STATE, _BUSY)))
        {
            i--;
            FifoExceptionData.Reason     = REG_RD32(NV_PFIFO_CACHE1_PULL0);
        }

        if (FifoExceptionData.Reason & DRF_DEF(_PFIFO, _CACHE1_PULL0, _HASH, _FAILED))
        {
            U032 result;
            //
            // On IKOS, we sometimes see spurious hash errors (where looking manually we
            // find the hash entry). If so, clear FifoExceptionData.Reason and allow the HW
            // to retry.
            //
            nvHalFifoHashSearch(pDev, FifoExceptionData.Data, FifoExceptionData.ChID, &result);
            if (result) {
                FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: HW missed valid hash entry: 0x%x\n", FifoExceptionData.Data));
                FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: CACHE1 get ptr: 0x%x\n", FifoExceptionData.GetPtr));
                FifoExceptionData.Reason = 0x0;
            } else {
                //
                // Hash failure.  This had better be a master class.
                //
                FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: FIFO Cache Error due to hash failure\n"));
                FIFO_PRINTF((DBG_LEVEL_ERRORS, "                     channel: 0x%x\n", FifoExceptionData.ChID));
                FIFO_PRINTF((DBG_LEVEL_ERRORS, "                 sub channel: 0x%x\n", FifoExceptionData.SubChannel));
                FIFO_PRINTF((DBG_LEVEL_ERRORS, "                      offset: 0x%x\n", FifoExceptionData.Method));
                FIFO_PRINTF((DBG_LEVEL_ERRORS, "                        data: 0x%x\n", FifoExceptionData.Data));
            }
        }

        //
        // This captures any unexpected strangeness on IKOS. In particular make
        // sure the engine bits for objects in subchannels agree and that we are
        // not just experiencing a transient hash failure.
        //

        if (FifoExceptionData.Reason & DRF_DEF(_PFIFO, _CACHE1_PULL0, _DEVICE, _SOFTWARE))
        {
            U032 pull1, engine1;

            // If we find a disagreement in the register engine bits, clear the reason and retry
            pull1   = REG_RD_DRF(_PFIFO, _CACHE1_PULL1, _ENGINE);
            engine1 = (REG_RD32(NV_PFIFO_CACHE1_ENGINE) >> (FifoExceptionData.SubChannel * 4)) & 0xF;

            if (pull1 ^ engine1)
            {
                FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: CACHE1 PULL1/ENGINE differ in engine bits\n\r"));
                FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: CACHE1 get ptr: 0x%x\n", FifoExceptionData.GetPtr));
                DBG_BREAKPOINT();
                FifoExceptionData.Reason = 0x0;
            }
            else
            {
                // On nv11 (at least) and IKOS sometimes we get a transient hash failure.
                // Until this is understood just retry the item.  As a cheap trick to avoid looping
                // on this for whatever reason, make sure we take a few fifo interrupts between
                // successive invocations of the hack.

                // Have the chip retry if its really a hw class and we see the item in hash table.
                Object = pDev->DBfifoTable[FifoExceptionData.ChID].SubchannelContext[FifoExceptionData.SubChannel];
                if ((FifoExceptionData.Method >= 0x0100) && ! Object)
                {
                    static U032 lastHackedFifoIsrCounter;
                    U032 delta;

                    if (fifoIsrCounter > lastHackedFifoIsrCounter) delta = fifoIsrCounter - lastHackedFifoIsrCounter;
                    else delta = lastHackedFifoIsrCounter - fifoIsrCounter;
                    lastHackedFifoIsrCounter = fifoIsrCounter;

                    if (delta > 10)  // require a few calls to fifoService() between these retries
                    {
                        FIFO_PRINTF((DEBUGLEVEL_ERRORS, "NVRM: Should have been a HW method: 0x%x\n", FifoExceptionData.Method));
                        FIFO_PRINTF((DEBUGLEVEL_ERRORS, "NVRM: CACHE1 get ptr: 0x%x\n", FifoExceptionData.GetPtr));
                        FIFO_PRINTF((DEBUGLEVEL_ERRORS, "             channel: %d\n", FifoExceptionData.ChID));
                        FIFO_PRINTF((DEBUGLEVEL_ERRORS, "         sub channel: %d\n", FifoExceptionData.SubChannel));
                        FIFO_PRINTF((DEBUGLEVEL_ERRORS, "                data: 0x%x\n", FifoExceptionData.Data));
                        DBG_BREAKPOINT();
                        FifoExceptionData.Reason = 0x0;
                    }
                    else
                    {
                        FIFO_PRINTF((DEBUGLEVEL_ERRORS, "NVRM: was not transient hash failure: 0x%x\n", FifoExceptionData.Method));
                        FIFO_PRINTF((DEBUGLEVEL_ERRORS, "NVRM: CACHE1 get ptr: 0x%x\n", FifoExceptionData.GetPtr));
                        FIFO_PRINTF((DEBUGLEVEL_ERRORS, "             channel: %d\n", FifoExceptionData.ChID));
                        FIFO_PRINTF((DEBUGLEVEL_ERRORS, "         sub channel: %d\n", FifoExceptionData.SubChannel));
                        FIFO_PRINTF((DEBUGLEVEL_ERRORS, "                data: 0x%x\n", FifoExceptionData.Data));
                    }
                }
            }
        }

        if ((FifoExceptionData.Reason & DRF_DEF(_PFIFO, _CACHE1_PULL0, _DEVICE, _SOFTWARE))
            || (FifoExceptionData.Reason & DRF_DEF(_PFIFO, _CACHE1_PULL0, _HASH, _FAILED)))
        {
            //
            // Software method
            //
            FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: FIFO Cache miss due to software object\n\r"));

            if ((FifoExceptionData.ChID < NUM_FIFOS) && pDev->DBfifoTable[FifoExceptionData.ChID].InUse)
            {
                if (FifoExceptionData.Method < 0x0100)
                {
                    status = fifoSoftwareMethod(pDev, &FifoExceptionData);
                }
                else
                {
                    //
                    // First we need to find the object to send this method.
                    //
                    // Do this brute force.  Search the whole fifo tree for the object.
                    //
                    // Go find the minimum value (>0) and start there.  That way we're
                    // sure to visit every node.
                    //
                    Object = pDev->DBfifoTable[FifoExceptionData.ChID].SubchannelContext[FifoExceptionData.SubChannel];

                    //
                    // If we found a valid object, route the method
                    //
                    if (Object)
                    {
                        status = classSoftwareMethod(pDev, Object, FifoExceptionData.Method, FifoExceptionData.Data);

                        //if (status != RM_OK)
                        //    notifyDefaultError(pDev, Object, Method, Data, ChID, status);
                    }
                    else
                    {
                        FIFO_PRINTF((DEBUGLEVEL_ERRORS, "NVRM: No valid object in subchannel: %d\n", FifoExceptionData.SubChannel));
                        FIFO_PRINTF((DEBUGLEVEL_ERRORS, "NVRM:                       channel: %d\n", FifoExceptionData.ChID));
                        FIFO_PRINTF((DEBUGLEVEL_ERRORS, "                             offset: 0x%x\n", FifoExceptionData.Method));
                        FIFO_PRINTF((DEBUGLEVEL_ERRORS, "                               data: 0x%x\n", FifoExceptionData.Data));
                        DBG_BREAKPOINT();
                    }
                }

            }
            else
            {
                FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: Access to free channel: 0x%x\n", FifoExceptionData.ChID));
                FIFO_PRINTF((DBG_LEVEL_INFO, "                 sub channel: 0x%x\n", FifoExceptionData.SubChannel));
                FIFO_PRINTF((DBG_LEVEL_INFO, "                      offset: 0x%x\n", FifoExceptionData.Method));
                FIFO_PRINTF((DBG_LEVEL_INFO, "                        data: 0x%x\n", FifoExceptionData.Data));
            }

            //
            // Advance the FIFO get pointer.
            //
            FifoExceptionData.GetPtr++;
            REG_WR_DRF_NUM(_PFIFO, _CACHE1_GET, _ADDRESS, FifoExceptionData.GetPtr);    // no more gray coding
        }

        //
        // Clear the fifo's hash result
        //
        REG_WR32(NV_PFIFO_CACHE1_HASH, 0);

        //
        // Re-enable cache draining.
        //
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
    }

    if (intr & DRF_DEF(_PFIFO, _INTR_0, _RUNOUT_OVERFLOW, _PENDING))
    {
        //
        // Clear condition.
        //
        REG_WR_DRF_DEF(_PFIFO, _INTR_0, _RUNOUT_OVERFLOW, _RESET);
        //
        // RunOut overflow.  Bad news.
        //
        // KJK: Do we wish to attempt to recover from this error?  Maybe close this channel
        // and attempt to recover to other valid channels?
        //
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: ERROR = FIFO runout overflow! Bad News!!!\n\r 0x%x\n", intr));
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        status = RM_ERR_FIFO_RUNOUT_OVERFLOW;
    }

    if (intr & DRF_DEF(_PFIFO, _INTR_0, _DMA_PUSHER, _PENDING))
    {
        // create a write cycle to the FB (used as an analyzer trigger).
        fbAddr->Reg032[0] = 0xDEADCAFE;

        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: DMA Pusher encountered a parse error.\n\r"));
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM:     Push Error: 0x%x\n", REG_RD32(NV_PFIFO_CACHE1_DMA_STATE)));
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM:        Get Ptr: 0x%x\n", REG_RD32(NV_PFIFO_CACHE1_DMA_GET)));
        if (IsNV5orBetter(pDev)) {
            FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM:  Dwords Xfered: 0x%x\n", REG_RD32(NV_PFIFO_CACHE1_DMA_DCOUNT)));
            FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM:    Last jmp at: 0x%x\n", REG_RD32(NV_PFIFO_CACHE1_DMA_GET_JMP_SHADOW)));
            FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM:       Last cmd: 0x%x\n", REG_RD32(NV_PFIFO_CACHE1_DMA_RSVD_SHADOW)));
            FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM:      Last data: 0x%x\n", REG_RD32(NV_PFIFO_CACHE1_DMA_DATA_SHADOW)));
        }
#ifdef BENSWORK // case 4
        // external debugger registered?
        if (isDebuggerPresent)
        {
            NvdeAppendEventForDebugger ((PNVDEOBJECT)(PNVDEOBJECT)((PRMINFO)pDev->pRmInfo)->Debugger.object,4,4,0,0,0,0,0,0);
            mustNotifyDebugger = 1;
        }
        else
        {
            DBG_BREAKPOINT();
        }
#else
        DBG_BREAKPOINT();
#endif

        //
        // Clear condition.
        //
        REG_WR_DRF_DEF(_PFIFO, _INTR_0, _DMA_PUSHER, _RESET);
        REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);

        //
        // The dma pusher has faulted while processing the push buffer stream.  This is
        // probably due to an invalid jump or bad opcode.
        //
        // Move the get pointer forward if necessary to skip this bad data
        //
        if (REG_RD32(NV_PFIFO_CACHE1_DMA_PUT) != REG_RD32(NV_PFIFO_CACHE1_DMA_GET))
        {
            U032 GetPtr;

            GetPtr = REG_RD32(NV_PFIFO_CACHE1_DMA_GET);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, GetPtr+4);
            //
            // This somehow needs to account for rollover, but without parsing the data, I don't
            // know where to roll to.
            //
        }
    }

    if (intr & DRF_DEF(_PFIFO, _INTR_0, _DMA_PT, _PENDING))
    {
#ifdef TRAP_HOST_FIFO_SWITCHES
        //
        // We're now expect this intr as a way to know what
        // the host FIFO is doing.
        //
        extern U032 dma_inst[32];
        static U032 prev_chid;
        U032 FifoCtxtPtr, fc_data;

        FIFO_PRINTF((DBG_LEVEL_ERRORS,      "Prev ChID: 0x%x\n", FifoExceptionData.ChID));

        // First, clear out prev_chid FIFO context inst addr, so he faults again
        FifoCtxtPtr = pDev->halHwInfo.pPramHalInfo->FifoContextAddr + (prev_chid * 32);
        fc_data = REG_RD32((U032)(FifoCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_INST)));
        fc_data &= 0xFFFF0000;    // mask off the inst addr
        REG_WR32((U032)(FifoCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_INST)), fc_data);

        FIFO_PRINTF((DBG_LEVEL_ERRORS,      "New  ChID: 0x%x\n", FifoExceptionData.ChID));

        // load into HW the inst addr
        REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, dma_inst[FifoExceptionData.ChID]);

        // Force a reread of the DMA pusher address
        REG_WR32(NV_PFIFO_CACHE1_DMA_CTL, 0);
        prev_chid = FifoExceptionData.ChID;
#endif

        //
        // Bad news if we get this -- the fifo engine must have attempted to fetch an invalid
        // dma page.  We could attempt to reconstruct what was meant to happen, or we can
        // just barf for now.  I vote for barfing...
        //
        REG_WR_DRF_DEF(_PFIFO, _INTR_0, _DMA_PT, _RESET);
        FIFO_PRINTF((DEBUGLEVEL_USERERRORS, "NVRM: Invalid DMA pusher PTE fetch.\n\r"));
#ifdef BENSWORK // case 5
        // external debugger registered?
        if (isDebuggerPresent)
        {
            NvdeAppendEventForDebugger ((PNVDEOBJECT)((PRMINFO)pDev->pRmInfo)->Debugger.object,5,4,0,0,0,0,0,0);
            mustNotifyDebugger = 1;
        }
        else
        {
            DBG_BREAKPOINT();
        }
#else
        DBG_BREAKPOINT();
#endif
    }

    //
    // If the dma pusher is currently suspended, wait until the CACHE1 is empty
    // and then set it running again.
    //
    if (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATUS) == NV_PFIFO_CACHE1_DMA_PUSH_STATUS_SUSPENDED)
    {
        while (REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) != NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
        {
            // If there's a pending FIFO intr, make this check after servicing it
            if (REG_RD32(NV_PFIFO_INTR_0))
                break;

            // Check if GE needs servicing
            if (REG_RD32(NV_PGRAPH_INTR))
                grService(pDev);

            // Check if vblank needs servicing (for NV15 HW flip)
            if (REG_RD32(NV_PMC_INTR_0) & (DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING) | DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING)))
                VBlank(pDev);
        }
        if (REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) == NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
        {
            while (REG_RD_DRF(_PFIFO, _CACHES, _DMA_SUSPEND) == NV_PFIFO_CACHES_DMA_SUSPEND_BUSY)
			    ;

            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
                ;

            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _STATUS, _RUNNING);
        }
    }

#if 0
    //
    // Re-enable the dma pusher if this was a pusher channel
    //
    if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
    {
        //
        // Wait til idle
        //
        while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY);

        //
        // Turn it back on (in the process will also clear DMA_PUSH_STATUS_SUSPENDED)
        //
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);
    }
#endif

    //
    // Re-enable FIFO CACHE1 if all conditions cleared.
    //
    if (REG_RD32(NV_PFIFO_INTR_0) == 0x00000000)
    {
#ifdef BENSWORK
        if (mustNotifyDebugger)
        {
            osNotifyEvent(pDev, ((PRMINFO)pDev->pRmInfo)->Debugger.object, 0, 0, 0, RM_OK, NV_OS_WRITE_THEN_AWAKEN);
        }
        else
        {
#endif
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _ENABLED);
        FLD_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _ENABLED);
#ifdef BENSWORK
        }
#endif
    }

    intr = REG_RD32(NV_PFIFO_INTR_0);
    //
    // See if there is yet another FIFO exception to be handled.
    // Just need to make sure that "intr" is non-zero in order to
    // get more servicing done.
    //
    intr |= REG_RD_DRF(_PFIFO, _DEBUG_0, _CACHE_ERROR0);
    NVRM_TRACE2('fisr', intr);
    return intr;
}

//
// Emulate the device access in software.
//
RM_STATUS fifoSoftwareMethod
(
    PHWINFO pDev,
    PFIFOEXCEPTIONDATA pFifoExceptionData
)
{
    U032 i;

    // Dispatch the requested software method
    for (i = 0; i < NvControlClass.MethodMax; i++)
        {
            if ((pFifoExceptionData->Method >= NvControlClass.Method[i].Low)
            &&  (pFifoExceptionData->Method <  NvControlClass.Method[i].High))
            {

                return(NvControlClass.Method[i].Proc(pDev,
                                                     pFifoExceptionData->ChID,
                                                     pFifoExceptionData->SubChannel,
                                                     &(NvControlClass.Method[i]),
                                                     pFifoExceptionData->Method,
                                                     pFifoExceptionData->Data));
            }
        }
    //
    // Method not found
    //
    FIFO_PRINTF((DEBUGLEVEL_USERERRORS, "NVRM: invalid control access "));
    FIFO_PRINTF((DEBUGLEVEL_USERERRORS, "              offset: 0x%x\n", pFifoExceptionData->Method));
    FIFO_PRINTF((DEBUGLEVEL_USERERRORS, "                data: 0x%x\n", pFifoExceptionData->Data));
    return (RM_ERR_FIFO_BAD_ACCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\fb\nv\fbstate.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* Framebuffer Module ******************************\
*                                                                           *
* Module: FBSTATE.C                                                         *
*   The Framebuffer state is changed in this module.                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <os.h>
#include <nvhw.h>
#include <fb.h>
#include <heap.h>
#include <vga.h>


//
// Save registers for framebuffer.
//
// U032 fbSave[2];

//
// New routine to point to location of cursor in instance memory and enable it.
VOID fbEnableCursor(VOID);

// This should already be setup somewhere else
#define RM_GLOBAL_BASE_PATH    "SOFTWARE\\NVIDIA Corporation\\Global\\System"

//
// Here's a definition of how these globals are being used:
//
//        FreeInstSize  - size in bytes of allocatable inst memory.
//                        Based on BIOS_IMAGE_PAD and the allocations for RAMHT, RAMFC and RAMRO.
//
//
//        FreeInstMax   - size in paragraphs of allocatable inst memory.
//                        fbInstBitmap is sized from this value and scanning for free
//                        instance memory uses this as the max available. This value
//                        is FreeInstBase + FreeInstSize in paragraphs.
//
//        FreeInstBase  - base where instance memory allocations begin.
//                        The base has already skipped beyond the BIOS_IMAGE_PAD
//                        and the allocations for RAMHT, RAMFC and RAMRO.
//
//        TotalInstSize - size in bytes of all of instance memory.
//                        This includes:
//                              allocatable instance memory
//                              RAMHT + RAMFC + RAMRO
//                              BIOS_PAD_IMAGE
//

//
// Change Frambuffer hardware state.
//
RM_STATUS stateFb
(
    PHWINFO pDev,
    U032    msg
)
{
    RM_STATUS status;
    U032      entry;
    int       i;

    status = RM_OK;

    //
    // Deal with state change.
    //
    switch (msg)
    {
        case STATE_UPDATE:
            if (pDev->Framebuffer.UpdateFlags & UPDATE_HWINFO_BUFFER_PARAMS)
            {
                //
                // Validate and calculate new framebuffer memory requirements.
                //
                fbCheckConfig(pDev);
            }
            if (pDev->Framebuffer.UpdateFlags & UPDATE_HWINFO_DISPLAY_PARAMS)
            {
                //
                // Validate and calculate new framebuffer memory requirements.
                //
                fbCheckConfig(pDev);

                //
                // This usage flag will be cleared by the dac state routine
                // after the display is updated
                //
                // pDev->Framebuffer.UpdateFlags &= ~UPDATE_HWINFO_DISPLAY_PARAMS;
            }
            break;
        case STATE_LOAD:

            //
            // Check for any os-specific fb overrides.  These overrides must be known now in case
            // we need to adjust how our framebuffer is aligned or tiled.
            //
			osStateFbEx(pDev);			// check for override on FilterEnable

            //
            // Verify framebuffer configuration.
            //
            fbCheckConfig(pDev);

            //
            // Call into HAL to finish setup of FB state.
            //
            nvHalFbControl(pDev, FB_CONTROL_LOAD);

            // Check if we need to create the heap
            if (pDev->Framebuffer.HeapHandle == NULL)
            {
                //
                // Allocate framebuffer heap.  All memory must be allocated from here to keep the world
                // consistent (N.B. the heap size has been reduced by the amount of instance memory).
                //
                if ((status = heapCreate(pDev,
                                         (U008 *)fbAddr,
                                         pDev->Framebuffer.HalInfo.RamSize - pDev->Pram.HalInfo.TotalInstSize,
                                         pDev->Framebuffer.HalInfo.BankCount,
                                         (PHEAP *)&(pDev->Framebuffer.HeapHandle))) != RM_OK)
                    return (status);
            }

#ifdef MACOS
// At this point in the boot process, the Mac is already in a hires, tiled mode
//   with the primary at a non-zero offset.
//   All of this was setup without using resman, so it is not reflected in resman
//   data structures (resman thinks all of fbmem is avail, all tiling regs avail, etc)
//
// The display driver will allocate the primary surface at the correct offset.
// The primary allocate below is harmless except that it will cause a screen flash
//   as the tiling registers are edited.
//   Screen flashes are a big deal on the mac.
#else
            // Check if we need to allocate the primary surface
            // We don't need to if we are in 4 bpp (VGA.DRV is running).
            if (!pDev->Framebuffer.PrimarySurfaceAlloced && (pDev->Dac.HalInfo.Depth != 4))
            {
                U032 offset;
                U032 width, height, depth;
                S032 size;

                //
                // Validate that the default resolution is correct.  This code was originally implemented
                // to workaround the case where the drivers would not allocate a primary surface before
                // attempting to use it.  But there are cases where our Display parameters in 
                // Framebuffer.HalInfo are not valid.
                //
                // To be safe, if the values are cleared out, assume a default surface size
                //
                if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 0) || (pDev->Framebuffer.HalInfo.VertDisplayWidth == 0)
                    || (pDev->Dac.HalInfo.Depth == 0))
                {
                    width = 640;
                    height = 480;
                    depth = 16;
                }
                else
                {
                    width = pDev->Framebuffer.HalInfo.HorizDisplayWidth;
                    height = pDev->Framebuffer.HalInfo.VertDisplayWidth;
                    depth = pDev->Dac.HalInfo.Depth;
                }

                // Allocate the primary surface
                nvHalFbGetSurfacePitch(pDev, width, depth, &pDev->Dac.DisplayPitch);
                size = pDev->Dac.DisplayPitch * height;

                // heapAlloc fills in pDev->Framebuffer.HalInfo.Start for MEM_TYPE_PRIMARY
                // XXX shouldn't this 'or' in the initial boot head??
                if ((status = heapAlloc(pDev,
                                        (PHEAP)pDev->Framebuffer.HeapHandle,
                                        'NVRM',
                                        (U032 *) &size,
                                        MEM_TYPE_PRIMARY,
                                        height,
                                        &pDev->Dac.DisplayPitch,
                                        &offset)) != RM_OK)
                    return (status);
            }
#endif
            
            // 
            // For a tiled primary surface, we delay setting the tiled bit in the hardware
            // until after we've modeswitched out of VGA to prevent a garbled splash screen.
            // Just in case we haven't set it yet, do it now.
            //
            for (i=0; i<MAX_CRTCS; i++) {
                if (pDev->Framebuffer.HalInfo.PrimaryFbAllocInfo[i].hwResId != 0) {
                    heapFbSetAllocParameters(pDev, &pDev->Framebuffer.HalInfo.PrimaryFbAllocInfo[i]);
                }
            }

            //
            // Since we're no longer maintaining the cache across mode changes, just
            // wipe the cache clean.
            //
            for (entry=0; entry < MAX_CACHED_CURSORS; entry++)
            {
                pDev->Dac.CursorMaskCRC[entry] = 0;
            }
            pDev->Dac.CursorCached = 0;

            pDev->Framebuffer.UpdateFlags &= ~(UPDATE_HWINFO_BUFFER_PARAMS | UPDATE_HWINFO_DISPLAY_PARAMS);

            break;
        case STATE_UNLOAD:

            //
            // Turn off video.
            //
            // MUST BLANK MONITOR ... setting PFB_GREEN_0_VIDEO_DISABLED doesn't work.
            // The underlying routines (e.g. osSetVideoMode) need to do this before a
            // mode change.
            //
            // REG_WR_DRF_DEF(_PFB, _GREEN_0, _LEVEL, _VIDEO_DISABLED);
#if 0
            //
            // We're not calling heapDestroy as part of an state unload anymore.
            //           

#ifndef NTRM
            // Completely destroy the heap on mode switches. However, we don't want to destroy
            // the heap if we are going into or coming out of a full screen DOS box.
            if (!pDev->Vga.DOSBox)
#endif
            {
                // Free heap.
                heapDestroy(pDev, (PHEAP)pDev->Framebuffer.HeapHandle);
            }
#endif

            break;
        case STATE_INIT:
        {
            U032 data32;

            //
            // Check the registry to see if we're not allowing pitch values to be rounded
            // up to what NV10 tiling requires (pitch must equal width for some old apps).
            // If so, we'll only tile a surface if the pitch is already aligned.
            //
            // We only want to not tile the lower resolutions with this flag, which means
            // just the 6x4 and 8x6 modes. But, we don't have width/height at all times
            // and checking against pitch has overlap with the other modes. So, we'll use
            // what we have at the time; width <= 800 or height <= 600 will be checked.
            //
            if (OS_READ_REGISTRY_DWORD(pDev, RM_GLOBAL_BASE_PATH, "NoAdjustedPitch", &data32) == RM_OK)
                pDev->Framebuffer.NoAdjustedPitch = 0x1;    // surface height check
            else
                pDev->Framebuffer.NoAdjustedPitch = 0x0;

            status = initFb(pDev);
            if (status != RM_OK)
            {
                return (RM_ERROR);
            }

            //
            // Setup bitmap.
            //
            status = fbInitializeInstMemBitMap(pDev);
            if (status)
                return (status);

            //
            // Reserve high block of fb mem as instance space.
            //
            status = fbClearInstMem(pDev);
            if (status)
                return (status);

            //
            // Now that the instance bitmap is setup, we can safely
            // claim any instance memory required by the chip's engines.
            //
            status = allocHalEngineInstMem(pDev);
            if (status)
                return (status);
            break;
        }
        case STATE_DESTROY:
            //
            // Free up allocated memory.
            //
            osFreeMem(pDev->DBfbInstBitmap);
            pDev->DBfbInstBitmap = NULL;

            // destroy the heap entirely, and all associated structures
            heapDestroy(pDev, (PHEAP)pDev->Framebuffer.HeapHandle, HEAP_DESTROY_INTERNAL);

            //
            // Restore framebuffer registers.
            //
            nvHalFbControl(pDev, FB_CONTROL_DESTROY);
            break;
    }
    return (status);
}

//
// Verify that we have enough fbmem to support the requested
// video mode.
//
RM_STATUS fbCheckConfig
(
    PHWINFO pDev
)
{
    S032 size;
	U032 normalized_depth;

    //
    // Normalize our framebuffer depth
    //
    switch (pDev->Dac.HalInfo.Depth)
    {
        case 32:
        case 30:
        case 24:
            normalized_depth = 32;
            break;
        case 16:
        case 15:
            normalized_depth = 16;
            break;
        case 8:
        default:
            normalized_depth = 8;
            break;
    }

    //
    // Force video parameters to proper values.
    //
    // Calculate PRAM, Hash Table, and Instance memory sizes.
    //
    size = normalized_depth / 8
         * pDev->Framebuffer.HalInfo.HorizDisplayWidth * pDev->Framebuffer.HalInfo.VertDisplayWidth
         * pDev->Framebuffer.Count;

    //
    // Now calculate the available offscreen memory
    //
    if (size > (S032)pDev->Framebuffer.HalInfo.RamSize)
        size = 0;
    else
        size = pDev->Framebuffer.HalInfo.RamSize - size;

    if (size < (S032)pDev->Pram.HalInfo.TotalInstSize)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Error - not enough PRAM!!!!!\n\r");
        DBG_BREAKPOINT();
        return (RM_ERROR);
    }

    return (RM_OK);
}

//
// fbLoadOverrides
//
// This routine is a hack.  It's really doing stuff that
// is nv20-specific.
RM_STATUS
fbLoadOverrides(PHWINFO pDev)
{
    U032 size, data32 = 0x1;
    VOID_PTR pBuffer = NULL;
    RM_STATUS status;

    //
    // Configure the remapper if requested.
    //
    if (OS_READ_REGISTRY_DWORD(pDev, RM_GLOBAL_BASE_PATH, "Remap", &data32) == RM_OK)
    {        
        //
        // Since the remapper will scramble memory, we need to fetch
        // the size of the save area from the HAL engine data tables.
        //
        // Note that anything displayed at the time we do this will
        // get munged.
        //
        size = engineGetBufferSize(&pDev->engineDB, FB_ENGINE_TAG, ENGMALLOC_TYPE_LOAD);
        if (size != 0)
        {
            status = osAllocMem((VOID **)&pBuffer, size+4);
            if (status != RM_OK)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: fbCheckOverrides: malloc failure: size ", size);
                return RM_ERROR;
            }
            pDev->halHwInfo.pFbMallocBuffer = pBuffer;
        }

        nvHalFbLoadOverride(pDev, FB_LOAD_OVERRIDE_REMAP, data32);

        if (pBuffer)
            osFreeMem((VOID *)pBuffer);
    }

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\fb\nv20\fbnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ Chip Specific HAL FB Routines ********************\
*                                                                           *
* Module: FBNV20.c                                                          *
*   The NV20 specific HAL FB routines reside in this file.                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include <heap.h>
#include "nvhw.h"
#include "nvhalcpp.h"
#include "bios.h"

// forwards
RM_STATUS nvHalFbControl_NV20(VOID *);
RM_STATUS nvHalFbAlloc_NV20(VOID *);
RM_STATUS nvHalFbFree_NV20(VOID *);
RM_STATUS nvHalFbSetAllocParameters_NV20(VOID *);
RM_STATUS nvHalFbGetSurfacePitch_NV20(VOID *);
RM_STATUS nvHalFbGetSurfaceDimensions_NV20(VOID *);
RM_STATUS nvHalFbLoadOverride_NV20(VOID *);

// statics
static VOID _nvHalFbRoundTiledPitchSize(U032 *, U032, U032 *);
static RM_STATUS _nvHalFbAllocZtags(PHALHWINFO, U032 *, U032 *);
static RM_STATUS _nvHalFbFreeZtags(PHALHWINFO, U032, U032);
static VOID _nvHalFbInitDrvSlwParms(PHALHWINFO);
VOID nvHalFbCalcDrvSlw_NV20(PHALHWINFO);

// extern -- remove this when we no longer have to update mclk ourselves
extern RM_STATUS nvHalDacProgramMClk_NV20(VOID *);

// NV20 expects a 1024byte alignment
#define FC_MIN_ALIGN_SHIFT      10

//
// nvHalFbControl
//
RM_STATUS
nvHalFbControl_NV20(VOID *arg)
{
    PFBCONTROLARG_000 pFbControlArg = (PFBCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO pFbHalInfo;
    PPRAMHALINFO pPramHalInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbControlArg->id != FB_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbControlArg->pHalHwInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pPramHalInfo = pHalHwInfo->pPramHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;

    switch (pFbControlArg->cmd)
    {
        case FB_CONTROL_INIT:
        {
#if 0
            U032 cfg0, cfg1;
#endif
            U032 tmpAddr;

            if (pFbHalInfo->AdjustDriveSlew)
            {
                //
                // Adjust drive/slew values if the timer is running.
                //
                if (REG_RD32(NV_PTIMER_NUMERATOR) != 0 && REG_RD32(NV_PTIMER_DENOMINATOR) != 0)
                {
                    //
                    // Init params structure.   
                    //
                    _nvHalFbInitDrvSlwParms(pHalHwInfo);
    
                    //
                    // Update the hardware.
                    //
                    nvHalFbCalcDrvSlw_NV20(pHalHwInfo);
                }
            }

            //
            // Save off chip-dependent fb state.
            //
            pFbHalPvtInfo->fbSave[0] = REG_RD32(NV_PFB_CFG0);
            pFbHalPvtInfo->fbSave[1] = REG_RD32(NV_PFB_CFG1);

            //
            // Setup "bank" count.
            //
            if (DRF_VAL(_PFB, _CFG0, _EXTBANK, pFbHalPvtInfo->fbSave[0]) == NV_PFB_CFG0_EXTBANK_1)
                pFbHalInfo->BankCount = 4;
            else
                pFbHalInfo->BankCount = 2;

            //
            // Set lines-per-tile.
            //
            switch (DRF_VAL(_PFB, _CFG1, _COL, pFbHalPvtInfo->fbSave[1]))
            {
                case NV_PFB_CFG1_COL_9:
                    pFbHalPvtInfo->linesPerTileShift = 5;   // 32
                    break;
                case NV_PFB_CFG1_COL_10:
                    pFbHalPvtInfo->linesPerTileShift = 6;   // 64
                    break;
                case NV_PFB_CFG1_COL_7:
                case NV_PFB_CFG1_COL_8:
                default:
                    pFbHalPvtInfo->linesPerTileShift = 4;   // 16
                    break;
            }

            //
            // Set ram type.
            //
            if (REG_RD_DRF(_PBUS, _FBIO_RAM, _TYPE) == NV_PBUS_FBIO_RAM_TYPE_SDR)
                pFbHalInfo->RamType = BUFFER_SDRAM;
            else
                pFbHalInfo->RamType = BUFFER_DDRAM;

            //
            // Set ram size.  Beginning with nv20, we need to
            // support external banks of possibly differing sizes.
            // Start by calculating size of primary bank and then
            // adding size of secondary bank if it exists.
            //
            // The formula (from James Van Dyke):
            //
            //  mem_in_bytes = (1 << (R + B + C + P)) * 4bytes, P=0,1,2
            //      R = row bits
            //      B = bank bits
            //      C = column bits
            //      P = partition count
            //

#if 0
            //
            // Set external bank count.
            //
            cfg0 = REG_RD32(NV_PFB_CFG0);
            cfg1 = REG_RD32(NV_PFB_CFG1);

            if (DRF_VAL(_PFB, _CFG0, _EXTBANK, cfg0) == NV_PFB_CFG0_EXTBANK_1)
                pFbHalInfo->ExtBankCount = 2;
            else
                pFbHalInfo->ExtBankCount = 1;

            //
            // Calculate primary external bank size.
            //
            size = (1 << (DRF_VAL(_PFB, _CFG1, _COL, cfg0) +
                          DRF_VAL(_PFB, _CFG1, _ROWA, cfg0) +
                          DRF_VAL(_PFB, _CFG1, _BANKA, cfg0) +
                          DRF_VAL(_PFB, _CFG0, _PART, cfg0))) * 4;
            pFbHalInfo->ExtBanks[0].size = size;
            pFbHalInfo->ExtBanks[0].intBanks = DRF_VAL(_PFB, _CFG1, _BANKA, cfg0) + 1;

            //
            // Check for secondary external bank.
            //
            if (DRF_VAL(_PFB, _CFG0, _EXTBANK, cfg0) == NV_PFB_CFG0_EXTBANK_1)
            {
                size = (1 << (DRF_DEF(_PFB, _CFG1, _COL, cfg1) +
                              DRF_DEF(_PFB, _CFG1, _ROWB, cfg1) +
                              DRF_DEF(_PFB, _CFG1, _BANKB, cfg1) +
                              DRF_DEF(_PFB, _CFG0, _PART, cfg0))) * 4;
                pFbHalInfo->ExtBanks[1].size = size;
                pFbHalInfo->ExtBanks[1].intBanks = DRF_VAL(_PFB, _CFG1, _BANKB, cfg0) + 1;
            }
#ifdef DEBUG
            //
            // Debug calculated size vs hard-wired value.
            //
            if (size != REG_RD_DRF(_PFB, _CSTATUS, _RAMAMOUNT_LS))
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: framebuffer size miscalculation ", size);
                DBG_BREAKPOINT();
            }

            //
            // Generate a debug message if the MS bit is actually set.
            //
            if (REG_RD_DRF(_PFB, _CSTATUS, _RAMAMOUNT_MS))
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: > 4G of framebuffer indicated!!");
                DBG_BREAKPOINT();
            }
#endif
#endif

            pFbHalInfo->RamSizeMb = REG_RD_DRF(_PFB, _CSTATUS, _RAMAMOUNT_LS);
            pFbHalInfo->RamSize = pFbHalInfo->RamSizeMb * 0x100000;

            //
            // Initialize ZTAG bitmap (0=allocated, 1=free).
            //
            for (i = 0; i < MAX_ZTAG_BITS/8; i++)
                pFbHalPvtInfo->zTagPool[i] = 0xff;

            for (i = 0; i < NV_PFB_ZCOMP__SIZE_1; i++)
            {
                pFbHalPvtInfo->zCompState[i].offset = MAX_ZTAG_BITS;
                pFbHalPvtInfo->zCompState[i].size = 0;
            }

            //
            // Fb arbitration settings from /hw/nv20/doc/perf_settings.doc.
            //
            // The ARB_XFER_SZ value we use needs to workaround a zcull/zcomp
            // bug in the hw.
            //
            //REG_WR32(NV_PFB_ARB_XFER_SZ, 0x84848880);
            REG_WR32(NV_PFB_ARB_XFER_SZ, 0x84f48880);
            REG_WR32(NV_PFB_ARB_TIMEOUT, 0xffffcff0);
            REG_WR32(NV_PFB_ARB_PREDIVIDER, 0x1);

            //
            // Set partition count.
            // 0=1partition, 1=2partitions, 3=4partitions (default).
            //
            pFbHalPvtInfo->partitions = REG_RD_DRF(_PFB, _CFG0, _PART) + 1;

            //
            // Set instance space size.  Add in whatever os-dependent
            // (i.e. BIOS) space is needed as well.
            //
            // For NV20, this is 576K allocatable.
            //
            pPramHalInfo->TotalInstSize = 0x90000 + pPramHalInfo->InstPadSize;

            //
            // The start of all of these space is after the BIOS
            // (denoted by InstPadSize).
            //
            tmpAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize;

            //
            // Configure hash table.
            //
            pFbHalPvtInfo->hashTableSize = 0x4000;
            pPramHalInfo->HashDepth = pFbHalPvtInfo->hashTableSize / sizeof (HASH_TABLE_ENTRY);
            pPramHalInfo->HashSearch = 128;

            pFbHalPvtInfo->hashTableAddr = tmpAddr;
            tmpAddr += pFbHalPvtInfo->hashTableSize;

            REG_WR32(NV_PFIFO_RAMHT, (DRF_DEF(_PFIFO, _RAMHT, _SIZE, _16K) |
                                      DRF_NUM(_PFIFO, _RAMHT, _BASE_ADDRESS, (pFbHalPvtInfo->hashTableAddr - DEVICE_BASE(NV_PRAMIN)) >> 12) |
                                      DRF_DEF(_PFIFO, _RAMHT, _SEARCH, _128)));
            
            //
            // Configure fifo context areas.
            // NV20 has two distinct context areas.
            //
            pFbHalPvtInfo->fifoContextSize1 = NUM_FIFOS_NV20 * FC1_SIZE_NV20;
            pFbHalPvtInfo->fifoContextSize2 = NUM_FIFOS_NV20 * FC2_SIZE_NV20;

            pFbHalPvtInfo->fifoContextAddr1 = tmpAddr;
            tmpAddr += pFbHalPvtInfo->fifoContextSize1;
            pFbHalPvtInfo->fifoContextAddr2 = tmpAddr;
            tmpAddr += pFbHalPvtInfo->fifoContextSize2;

            REG_WR32(NV_PFIFO_RAMFC,
                     (DRF_NUM(_PFIFO, _RAMFC, _BASE_ADDRESS, ((pFbHalPvtInfo->fifoContextAddr1 - DEVICE_BASE(NV_PRAMIN)) >> FC_MIN_ALIGN_SHIFT))) |
                     DRF_DEF(_PFIFO, _RAMFC, _SIZE, _2K) |
                     (DRF_NUM(_PFIFO, _RAMFC, _BASE_ADDRESS2, ((pFbHalPvtInfo->fifoContextAddr2 - DEVICE_BASE(NV_PRAMIN)) >> FC_MIN_ALIGN_SHIFT))));

            //
            // Configure runout area.
            //
            pFbHalPvtInfo->fifoRunoutSize = 512;
            pFbHalPvtInfo->fifoRunoutAddr = tmpAddr;
            tmpAddr += pFbHalPvtInfo->fifoRunoutSize;
            pFbHalPvtInfo->fifoRunoutMask = pFbHalPvtInfo->fifoRunoutSize - 1;
            REG_WR32(NV_PFIFO_RAMRO, (DRF_DEF(_PFIFO, _RAMRO, _SIZE, _512) |
                                      DRF_NUM(_PFIFO, _RAMRO, _BASE_ADDRESS, (pFbHalPvtInfo->fifoRunoutAddr - DEVICE_BASE(NV_PRAMIN)) >> 9)));

            //
            // Sum of all allocations plus a little slop
            //
            pPramHalInfo->CurrentSize  = (tmpAddr + 512) - (DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize);

            break;
        }
        case FB_CONTROL_LOAD:
            break;
        case FB_CONTROL_UNLOAD:
            break;
        case FB_CONTROL_UPDATE:
            break;
        case FB_CONTROL_DESTROY:
            REG_WR32(NV_PFB_CFG0, pFbHalPvtInfo->fbSave[0]);
            REG_WR32(NV_PFB_CFG1, pFbHalPvtInfo->fbSave[1]);
            break;
        case FB_CONTROL_INSTWR_DISABLE:
            // disable writes by enabling  protection
            switch (pPramHalInfo->TotalInstSize)
            {
                case 0xA0000:
                    FLD_WR_DRF_DEF(_PFB, _NVM, _LIMIT, _640K);
                    break;
                case 0x30000:
                    FLD_WR_DRF_DEF(_PFB, _NVM, _LIMIT, _192K);
                    break;
                case 0x20000:
                default:
                    FLD_WR_DRF_DEF(_PFB, _NVM, _LIMIT, _128K);
                    break;
            }
            FLD_WR_DRF_DEF(_PFB, _NVM, _MODE, _ENABLE);
            break;
        case FB_CONTROL_INSTWR_ENABLE:
            // enable writes by disabling write protection
            FLD_WR_DRF_DEF(_PFB, _NVM, _MODE, _DISABLE);
            break;
        case FB_CONTROL_TILING_DISABLE:
            HAL_GR_IDLE(pHalHwInfo);

            // TILE region registers
            for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
            {
                REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
                REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);
                RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                             NV_IGRAPH_TC_MINTFCDEBUG_TILE_ADDRESS(i),
                             NV_PFB_TILE_REGION_INVALID);
            }

            // ZCOMP_OFFSET register
            REG_WR32(NV_PGRAPH_ZCOMP_OFFSET, NV_PFB_ZCOMP_OFFSET_EN_FALSE);
            RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                         NV_IGRAPH_TC_MINTFCDEBUG_ZOFFSET_ADDRESS,
                         NV_PFB_ZCOMP_OFFSET_EN_FALSE);

            // ZCOMP region registers
            for (i = 0; i < NV_PFB_ZCOMP__SIZE_1; i++)
            {
                REG_WR32(NV_PFB_ZCOMP(i), NV_PFB_ZCOMP_EN_FALSE);
                REG_WR32(NV_PGRAPH_ZCOMP(i), NV_PFB_ZCOMP_EN_FALSE);
                RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                             NV_IGRAPH_TC_MINTFCDEBUG_ZCOMP_ADDRESS(i),
                             NV_PFB_ZCOMP_EN_FALSE);
            }
            break;
        case FB_CONTROL_TILING_ENABLE:
            // this is treated as an error on nv10 (???)
            return (RM_ERR_BAD_ARGUMENT);
        case FB_CONTROL_TILING_CONFIGURE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalFbGetSurfacePitch
//
// Given a width and bits per pixel, return the surface pitch
//
RM_STATUS
nvHalFbGetSurfacePitch_NV20(VOID *arg)
{
    PFBGETSURFACEPITCHARG_000 pGetSurfacePitchArg = (PFBGETSURFACEPITCHARG_000)arg;
    
    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pGetSurfacePitchArg->id != FB_GET_SURFACE_PITCH_000)
        return (RM_ERR_VERSION_MISMATCH);

    // surfaces are (at least) 64byte aligned
    // Watch out for bpp==15: add 1 here to force 15 to 16 for the shift
    pGetSurfacePitchArg->pitch = ((pGetSurfacePitchArg->width * ((pGetSurfacePitchArg->bpp+1) >> 3)) + 0x3F) & ~0x3F;

    if (!(pGetSurfacePitchArg->flags & FB_GET_SURFACE_PITCH_NO_ADJUST))
    {
        _nvHalFbRoundTiledPitchSize(&pGetSurfacePitchArg->pitch, NULL, NULL);
    }
    return RM_OK;
}

//
// nvHalFbGetSurfaceDimensions
//
// Given a width/height and bits per pixel, return the surface pitch and size
//
RM_STATUS
nvHalFbGetSurfaceDimensions_NV20(VOID *arg)
{
    PFBGETSURFACEDIMENSIONSARG_000 pGetSurfaceDimensionsArg = (PFBGETSURFACEDIMENSIONSARG_000)arg;
    
    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pGetSurfaceDimensionsArg->id != FB_GET_SURFACE_DIMENSIONS_000)
        return (RM_ERR_VERSION_MISMATCH);

    // surfaces are (at least) 64byte aligned
    // Watch out for bpp==15: add 1 here to force 15 to 16 for the shift
    pGetSurfaceDimensionsArg->pitch = ((pGetSurfaceDimensionsArg->width * ((pGetSurfaceDimensionsArg->bpp+1) >> 3)) + 0x3F) & ~0x3F;
    pGetSurfaceDimensionsArg->size  = pGetSurfaceDimensionsArg->pitch * pGetSurfaceDimensionsArg->height;
        
    if (!(pGetSurfaceDimensionsArg->flags & FB_GET_SURFACE_PITCH_NO_ADJUST))
    {
        _nvHalFbRoundTiledPitchSize(&pGetSurfaceDimensionsArg->pitch,
                                        pGetSurfaceDimensionsArg->height,
                                        &pGetSurfaceDimensionsArg->size);
    }

    return RM_OK;
}

static VOID
_nvHalFbRoundTiledPitchSize(U032 *pitch, U032 height, U032 *size)
{

    // adjust the pitch, if necessary
    if (*pitch <= 0x200)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0200);
    else if (*pitch <= 0x400)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0400);
    else if (*pitch <= 0x600)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0600);
    else if (*pitch <= 0x800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0800);
    else if (*pitch <= 0xA00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0A00);
    else if (*pitch <= 0xC00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0C00);
    else if (*pitch <= 0xE00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0E00);
    else if (*pitch <= 0x1000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1000);
    else if (*pitch <= 0x1400)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1400);
    else if (*pitch <= 0x1800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1800);
    else if (*pitch <= 0x1C00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1C00);
    else if (*pitch <= 0x2000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _2000);
    else if (*pitch <= 0x2800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _2800);
    else if (*pitch <= 0x3000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _3000);
    else if (*pitch <= 0x3800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _3800);
    else if (*pitch <= 0x4000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _4000);
    else if (*pitch <= 0x5000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _5000);
    else if (*pitch <= 0x6000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _6000);
    else if (*pitch <= 0x7000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _7000);
    else if (*pitch <= 0x8000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _8000);
    else if (*pitch <= 0xA000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _A000);
    else if (*pitch <= 0xC000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _C000);
    else
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _E000);

    if (size) {
        U032 hzmult;

        // set size given possibly adjusted pitch
        *size = *pitch * height;

        //
        // Round size to an even multiple of horizontal tiles. Remapping occurs
        // within addresses of length (pitch * tile_height * 2) in the vertical
        // direction (where the max TILE_HEIGHT is 16 lines).
        //
        hzmult = *pitch * (16 * 2);
        *size = ((*size + (hzmult - 1)) / hzmult) * hzmult;
    }
}

//
// Before updating the tiling registers (in particular, the PGRAPH version),
// idle graphics as best as possible.
//
// If we're not GR_IDLE during these writes to the PGRAPH registers, these
// writes can be dropped leaving the PFB and PGRAPH regs inconsistent. The
// idle/resume routines are called during FreeTiledRange/ProgramTiledRange.
//
static VOID
nvHalTilingUpdateIdle_NV20
(
    PHALHWINFO pHalHwInfo,
    U032       *pDmaCaches,
    U032       *pDmaPush
)
{
    *pDmaCaches = REG_RD32(NV_PFIFO_CACHES);
    FLD_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);

    // Empty FIFO and runout.
    while ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) != NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
        || (REG_RD_DRF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK) != NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY)
        || (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY))
    {
        // Make sure we process any fifo interrupts
        HALRMSERVICEINTR(pHalHwInfo, FIFO_ENGINE_TAG);

        // Check if GE needs servicing.
        if (REG_RD32(NV_PGRAPH_INTR))
            HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);

        // Check if vblank needs servicing.
        if (REG_RD32(NV_PMC_INTR_0) & (DRF_DEF(_PMC, _INTR_0, _PCRTC,  _PENDING) |
                                       DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING)))
            HALRMSERVICEINTR(pHalHwInfo, DAC_ENGINE_TAG);
    }

    // Disable the dma pusher
    *pDmaPush = REG_RD32(NV_PFIFO_CACHE1_DMA_PUSH);
    FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);

    // Wait until the DMA pusher is idle
    while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
	    ;
}

static VOID
nvHalTilingUpdateResume_NV20
(
    PHALHWINFO pHalHwInfo,
    U032       DmaCaches,
    U032       DmaPush
)
{
    // Restore the dma pusher state
    REG_WR32(NV_PFIFO_CACHE1_DMA_PUSH, DmaPush);

    // Restore the reassign state
    REG_WR32(NV_PFIFO_CACHES, DmaCaches);
}

//
// nvHalFbAlloc
//
// Update user alloc request parameter according to memory
// type and (possibly) reserve hw resources.
//
RM_STATUS
nvHalFbAlloc_NV20(VOID *arg)
{
    PFBALLOCARG_000 pFbAllocArg = (PFBALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PFBALLOCINFO pFbAllocInfo;
    U032 i, pitch, size;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbAllocArg->id != FB_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbAllocArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pFbAllocInfo = pFbAllocArg->pAllocInfo;
    
    // Set default alignment based on type.
    switch (pFbAllocInfo->type) {
    case MEM_TYPE_IMAGE:
    case MEM_TYPE_OVERLAY:
        //
        // These are used for texturing by mocomp, so we're forced
        // to align them above the 64byte requirement the overlay
        // hw requires.
        //
        pFbAllocInfo->align = 0xff;         // 256 byte alignment
        break;
    case MEM_TYPE_TEXTURE:
        pFbAllocInfo->align = 0xff;         // 256 byte alignment
        break;
    case MEM_TYPE_FONT:
        pFbAllocInfo->align = 0x1f;         // 32 byte alignment
        break;
    case MEM_TYPE_CURSOR:
        pFbAllocInfo->align = 0x7ff;        // 2048 byte alignment
        break;
    case MEM_TYPE_DMA:
        pFbAllocInfo->align = 0x3;          // 4 byte alignment
        break;
    case MEM_TYPE_INSTANCE:
        pFbAllocInfo->align = 0xf;          // 16 byte alignment
        break;
    case MEM_TYPE_DEPTH:
    case MEM_TYPE_DEPTH_COMPR16:
    case MEM_TYPE_DEPTH_COMPR32:
    case MEM_TYPE_PRIMARY:
    case MEM_TYPE_IMAGE_TILED:
        pFbAllocInfo->align = 0xfff;        // 4096 byte alignment
        break;
    default:
        // should this be 0xffffffff
        pFbAllocInfo->align = pFbAllocInfo->alignPerf = 0;
        return (RM_ERR_BAD_ARGUMENT);
    }

    //
    // A non-zero pitch value indicates the user wants tiled memory
    // (if available).  If the pitch is 0, we're done.
    //
    if (pFbAllocInfo->pitch == 0)
    {
        pFbAllocInfo->alignPerf = pFbAllocInfo->align;
        return (RM_OK);
    }

    // Now allocate a TILE_RANGE
    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
    {
        if ((pFbHalPvtInfo->usedTiles & MEM_TYPE_TILE_RANGE_SHIFT(i)) == 0)
        {
            pFbHalPvtInfo->usedTiles |= MEM_TYPE_TILE_RANGE_SHIFT(i);
            break;
        }
    }
    if (i == NV_PFB_TILE__SIZE_1)
    {
        return (RM_ERR_INSUFFICIENT_RESOURCES);
    }

    pitch = pFbAllocInfo->pitch;

    _nvHalFbRoundTiledPitchSize(&pitch, pFbAllocInfo->height, &size);

    //
    // If we're not allowing the pitch to be adjusted, we can only tile the surface
    // if the pitch is already HW aligned.
    // 
    if ((pFbAllocArg->flags & FB_ALLOC_NO_PITCH_ADJUST) && (pitch != pFbAllocInfo->pitch))
    {
        // requires rounding, so give back the range and fail the alloc
        pFbHalPvtInfo->usedTiles &= ~MEM_TYPE_TILE_RANGE_SHIFT(i);
        pFbAllocInfo->hwResId = 0;
        return (RM_OK);
    }

    //
    // Both the required and optimal aligment are 16K.
    //
    pFbAllocInfo->align = pFbAllocInfo->alignPerf = 0x3fff;

    // return adjusted pitch and size
    pFbAllocInfo->pitch = pitch;
    pFbAllocInfo->size  = size;

    pFbAllocInfo->hwResId = MEM_TYPE_TILE_RANGE_SHIFT(i);
    return (RM_OK);
}

//
// nvHalFbFree
//
// Release tile back to the free pool.
//
RM_STATUS
nvHalFbFree_NV20(VOID *arg)
{
    PFBFREEARG_000 pFbFreeArg = (PFBFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    U032 i, dmapush, dmacaches;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbFreeArg->id != FB_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbFreeArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;

    //
    // Bail out now if there's no resource id.
    if (!pFbFreeArg->hwResId)
        return (RM_OK);

    // convert range bits to a TILE index
    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
        if (pFbFreeArg->hwResId & MEM_TYPE_TILE_RANGE_SHIFT(i))
                break;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Freeing TILE Range:   ", i);

    //
    // It's possible for us to be freeing a tiled region after we've
    // disable PCI accesses to our chip while handling certain
    // power mgmt calls.  We do this explicitly in some power levels
    // but the os can also do this (e.g. win9x).
    // 
    // Before touching the hw, make sure the device is enabled.
    // If it isn't, don't bother modifying the hw, but clear the
    // sw enable bit so we know that this region is to be marked invalid
    // when we resume.
    //
    if (REG_RD32(NV_PMC_BOOT_0) == 0xffffffff)
    {
        // mark it free
        pFbHalPvtInfo->usedTiles &= ~pFbFreeArg->hwResId;
        return (RM_OK);
    }

    // idle graphics, so we can update the PGRAPH registers
    nvHalTilingUpdateIdle_NV20(pFbFreeArg->pHalHwInfo, &dmacaches, &dmapush);

    do {
        // Now, wait until graphics is idle
        HAL_GR_IDLE(pFbFreeArg->pHalHwInfo);

        // invalidate the range
        REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
        REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);    
        RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                     NV_IGRAPH_TC_MINTFCDEBUG_TILE_ADDRESS(i),
                     NV_PFB_TILE_REGION_INVALID);
    } while (REG_RD32(NV_PFB_TILE(i)) != REG_RD32(NV_PGRAPH_TILE(i)));

    //
    // Free any z compression resources.
    //
    if (pFbHalPvtInfo->zCompState[i].offset != MAX_ZTAG_BITS && pFbHalPvtInfo->zCompState[i].size != 0)
    {
        do {

            // Now, wait until graphics is idle
            HAL_GR_IDLE(pFbFreeArg->pHalHwInfo);

            REG_WR32(NV_PFB_ZCOMP(i), NV_PFB_ZCOMP_EN_FALSE);
            REG_WR32(NV_PGRAPH_ZCOMP(i), NV_PFB_ZCOMP_EN_FALSE);
            RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                         NV_IGRAPH_TC_MINTFCDEBUG_ZCOMP_ADDRESS(i),
                         NV_PFB_ZCOMP_EN_FALSE);
        } while (REG_RD32(NV_PFB_ZCOMP(i)) != REG_RD32(NV_PGRAPH_ZCOMP(i)));

        _nvHalFbFreeZtags(pHalHwInfo, pFbHalPvtInfo->zCompState[i].offset, pFbHalPvtInfo->zCompState[i].size);
        pFbHalPvtInfo->zCompState[i].offset = MAX_ZTAG_BITS;
        pFbHalPvtInfo->zCompState[i].size = 0;
    }

    // resume graphics, now that PFB/PGRAPH are consistent
    nvHalTilingUpdateResume_NV20(pHalHwInfo, dmacaches, dmapush);

    // mark it free
    pFbHalPvtInfo->usedTiles &= ~pFbFreeArg->hwResId;

    return (RM_OK);
}

//
// nvHalFbSetAllocParameters
//
// Associate memory block (base/limit) with hardware resources.
//
RM_STATUS
nvHalFbSetAllocParameters_NV20(VOID *arg)
{
    PFBSETALLOCPARAMSARG_000 pFbSetAllocParamsArg = (PFBSETALLOCPARAMSARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PFBALLOCINFO pFbAllocInfo;
    U032 i, dmapush, dmacaches, data32;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbSetAllocParamsArg->id != FB_SET_ALLOC_PARAMS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbSetAllocParamsArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pFbAllocInfo = pFbSetAllocParamsArg->pAllocInfo;

    //
    // Bail out if this allocation didn't reserve any tiling regs.
    //
    if (pFbAllocInfo->hwResId == 0)
        return (RM_OK);

    //
    // Convert range bits to a TILE index.
    //
    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
        if (pFbAllocInfo->hwResId == (U032)MEM_TYPE_TILE_RANGE_SHIFT(i))
            break;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Programming TILE Range:   ", i);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:          Base =   ", pFbAllocInfo->offset);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:         Limit =   ", pFbAllocInfo->offset + (pFbAllocInfo->size - 1));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:         Pitch =   ", pFbAllocInfo->pitch);

    if (pFbAllocInfo->offset & 0x3fff)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Error: unaligned Base\n");
        // mark it free
        pFbHalPvtInfo->usedTiles &= ~pFbAllocInfo->hwResId;
        // invalidate the range
        REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
        REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);    
        return (RM_OK);
    }
    if (pFbAllocInfo->size & 0x3fff)
    {
        // mark it free
        pFbHalPvtInfo->usedTiles &= ~pFbAllocInfo->hwResId;
        // invalidate the range
        REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
        REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);    
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Error: unaligned Limit\n");
        return (RM_OK);
    }

    // idle graphics, so we can update the PGRAPH registers
    nvHalTilingUpdateIdle_NV20(pFbSetAllocParamsArg->pHalHwInfo, &dmacaches, &dmapush);

    //
    // Note: due to a PFB_TLIMIT readback bug, only compare the upper bits
    // when checking for PFB_TLIMIT/PGRAPH_TLIMIT consistency.
    // 
    do {
        // Now, wait until graphics is idle
        HAL_GR_IDLE(pHalHwInfo);

        REG_WR32(NV_PFB_TLIMIT(i), pFbAllocInfo->offset + pFbAllocInfo->size - 1);
        REG_WR32(NV_PFB_TSIZE(i), pFbAllocInfo->pitch);
        REG_WR32(NV_PGRAPH_TLIMIT(i), pFbAllocInfo->offset + pFbAllocInfo->size - 1);
        REG_WR32(NV_PGRAPH_TSIZE(i), pFbAllocInfo->pitch);

        //
        // Flip BANK0_SENSE on for depth buffers, but leave it off
        // for color and anything else.
        //
        data32 = pFbAllocInfo->offset | DRF_DEF(_PFB, _TILE, _REGION, _VALID);
        if (pFbAllocInfo->type == MEM_TYPE_DEPTH ||
            pFbAllocInfo->type == MEM_TYPE_DEPTH_COMPR16 ||
            pFbAllocInfo->type == MEM_TYPE_DEPTH_COMPR32)
        {
            data32 |= DRF_DEF(_PFB, _TILE, _BANK0_SENSE, _1);
        }

        REG_WR32(NV_PGRAPH_TILE(i), data32);
        REG_WR32(NV_PFB_TILE(i), data32);
        RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                     NV_IGRAPH_TC_MINTFCDEBUG_TLIMIT_ADDRESS(i),
                     pFbAllocInfo->offset + pFbAllocInfo->size - 1);
        RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                     NV_IGRAPH_TC_MINTFCDEBUG_TPITCH_ADDRESS(i),
                     pFbAllocInfo->pitch);
        RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                     NV_IGRAPH_TC_MINTFCDEBUG_TILE_ADDRESS(i),
                     data32);

    } while ((REG_RD32(NV_PFB_TILE(i)) != REG_RD32(NV_PGRAPH_TILE(i))) ||
             (REG_RD32(NV_PFB_TSIZE(i)) != REG_RD32(NV_PGRAPH_TSIZE(i))) ||
             ((REG_RD32(NV_PFB_TLIMIT(i)) & ~0x3FFF) != (REG_RD32(NV_PGRAPH_TLIMIT(i)) & ~0x3FFF)));

    //
    // Handle Z compression.
    //
    if (pFbAllocInfo->type == MEM_TYPE_DEPTH_COMPR16 || pFbAllocInfo->type == MEM_TYPE_DEPTH_COMPR32)
    {
        U032 offset, size;
       
        //
        // Find offset into ZTag table of range we'll associate with
        // this block of memory.
        //
        // Each Ztag maps to a single 64byte tile per partition.
        //
        size = pFbAllocInfo->size / (pFbHalPvtInfo->partitions * 64);
        if (_nvHalFbAllocZtags(pHalHwInfo, &size, &offset) == RM_OK)
        {
            // save off ztag region state
            pFbHalPvtInfo->zCompState[i].offset = offset;
            pFbHalPvtInfo->zCompState[i].size = size;

            // initialize offset into ztag pool
            data32 = offset | DRF_DEF(_PFB, _ZCOMP, _EN, _TRUE);

            // mode (16 or 32bit)
            if (pFbAllocInfo->type == MEM_TYPE_DEPTH_COMPR32)
                data32 |= DRF_DEF(_PFB, _ZCOMP, _MODE, _32);

            // enable big endian mode if applicable
            if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
                data32 |= DRF_DEF(_PFB, _ZCOMP, _ENDIAN, _BIG);

            //
            // TODO: enable antialiasing...
            //

            do {
                // Now, wait until graphics is idle
                HAL_GR_IDLE(pHalHwInfo);

                REG_WR32(NV_PFB_ZCOMP(i), data32);
                REG_WR32(NV_PGRAPH_ZCOMP(i), data32);
                RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                             NV_IGRAPH_TC_MINTFCDEBUG_ZCOMP_ADDRESS(i),
                             data32);
            } while (REG_RD32(NV_PFB_ZCOMP(i)) != REG_RD32(NV_PGRAPH_ZCOMP(i)));
        }
    }
    else
    {
        //
        // Set ENDIAN-ness in zcomp register; required even if
        // compression isn't enabled.  If we don't set this correctly,
        // we can incur TILEVIOL exceptions.
        //
        data32 = REG_RD32(NV_PFB_ZCOMP(i));
        data32 &= ~(DRF_DEF(_PFB, _ZCOMP, _ENDIAN, _BIG));
        if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
            data32 |= DRF_DEF(_PFB, _ZCOMP, _ENDIAN, _BIG);
        REG_WR32(NV_PFB_ZCOMP(i), data32);
        REG_WR32(NV_PGRAPH_ZCOMP(i), data32);
        RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                     NV_IGRAPH_TC_MINTFCDEBUG_ZCOMP_ADDRESS(i),
                     data32);
    }


    // resume graphics, now that PFB/PGRAPH are consistent
    nvHalTilingUpdateResume_NV20(pHalHwInfo, dmacaches, dmapush);

    return (RM_OK);
}

RM_STATUS
nvHalFbLoadOverride_NV20(VOID *arg)
{
    PFBLOADOVERRIDEARG_000 pFbLoadOverrideArg = (PFBLOADOVERRIDEARG_000)arg;
    PHALHWINFO pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pFbLoadOverrideArg->id != FB_LOAD_OVERRIDE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbLoadOverrideArg->pHalHwInfo;

    switch (pFbLoadOverrideArg->cmd)
    {
        case FB_LOAD_OVERRIDE_MEMORY:
            REG_WR32(NV_PFB_CFG0, pFbLoadOverrideArg->value);
            break;
        case FB_LOAD_OVERRIDE_REMAP:
        {
            U032 i, *fb_sv;

            //
            // We're going to be restting the remapper register.
            // Before doing that, we need to save off the bios
            // image.
            //
            // We're ASSUMING that nothing else in the fb needs
            // to be saved here.
            //
            fb_sv = (U032 *)pHalHwInfo->pFbMallocBuffer;
            for(i=0; i < 0xA0000/4; i++)
                *fb_sv++ = REG_RD32(NV_PRAMIN_DATA032(i));

            REG_WR32(NV_PFB_REMAP, pFbLoadOverrideArg->value);

            fb_sv = (U032 *)pHalHwInfo->pFbMallocBuffer;
            for(i=0; i < 0xA0000/4; i++)
                REG_WR32(NV_PRAMIN_DATA032(i), *fb_sv++);

            break;
        }   
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// Z Compression management.
//
// Here's some details from the _HOW_TO_MAP_Z_COMPRESS_TAG_BITS_
// document in the NV20 Architecture database:
//
// (1) Z tag bits only live in compressed regions.
// (2) Only tiled regions can be compressed.
// (3) There is one Z tag bit per (64byte) packet.
// (4) One packet maps to one partition.
// (5) A ZCOMP_BASE_TAG_ADR exists for each region.  They define the tag
//     bit offset into each partition's tag RAM.  All RAMs in each partition
//     get the same address.
// (6) A region uses RAM tag bits starting at the ZCOMP_BASE_TAG_ADR.
//     RAM tag bits are allocated until the end of the memory region, or
//     until they run out, whichever is first.
// (7) ZCOMP_MAX_TAG_ADR specifies how many bits exist in each
//     partition tag RAM.
//
// There are two new memory types that the drivers can use to request
// compressed depth buffers:
//
//  MEM_TYPE_DEPTH_COMPR16 - 16bit compression
//  MEM_TYPE_DEPTH_COMPR32 - 32bit compression
//
// When the tiling parameters are programmed up for one of these
// memory types, we scan the Z tag pool (a bitmap) for any free
// bits.  Because of (6), we can partially compress a region, which
// we will do as a last resort.
//
static RM_STATUS
_nvHalFbAllocZtags(PHALHWINFO pHalHwInfo, U032 *size, U032 *offset)
{
    PFBHALINFO_NV20 pFbHalPvtInfo;
    U032 bestSize, bestOffset;
    U032 i, j;

    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;

    //
    // Error check incoming size parameter.
    //
    if (*size == 0)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: zero size to ztag allocator\n");
        *offset = MAX_ZTAG_BITS;                // out of range value
        DBG_BREAKPOINT();
    }

    bestSize = 0;
    bestOffset = MAX_ZTAG_BITS;
    for (i = 0; i < MAX_ZTAG_BITS; i++)
    {
        if (!pFbHalPvtInfo->zTagPool[i >> 3])
        {
            i += 7;
        }
        else if (pFbHalPvtInfo->zTagPool[i >> 3] & BIT(i & 7))
        {
            //
            // Search for string of 1's the length of the block.
            //
            j = 0;

            do
            {
                if ((++i >= MAX_ZTAG_BITS) || (++j >= *size))
                    break;
            }
            while (pFbHalPvtInfo->zTagPool[i >> 3] & BIT(i & 7));


            if (j == *size)
            {
                *offset = i - j;
                while (j--)
                {
                    i--;
                    pFbHalPvtInfo->zTagPool[i >> 3] &= ~BIT(i & 7);
                }
                return (RM_OK);
            }

            //
            // If this is the best range so far, save it off.
            //
            if (j != 0 && j > bestSize)
            {
                bestSize = j;
                bestOffset = i - j;
            }
        }
    }

    //
    // If we found _any_ ranges, use the biggest one...
    //
    if (bestSize != 0)
    {
        *offset = bestOffset;
        *size = bestSize;
        return (RM_OK);
    }

    *offset = MAX_ZTAG_BITS;
    *size = 0;

    return (RM_ERR_NO_FREE_MEM);
}


static RM_STATUS
_nvHalFbFreeZtags(PHALHWINFO pHalHwInfo, U032 offset, U032 size)
{
    PFBHALINFO_NV20 pFbHalPvtInfo;

    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;

    //
    // Validate range.
    //
    if (offset + size > MAX_ZTAG_BITS)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad ZTag pool parameters: offset ", offset);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: size ", size);
        DBG_BREAKPOINT();
        return (RM_ERROR);
    }

    //
    // Mark range free.
    //
    while (size--)
    {
        pFbHalPvtInfo->zTagPool[offset >> 3] |= BIT(offset & 7);
        offset++;
    }

    return (RM_OK);
}


static RM_STATUS fbDelay_NV20(
    PHALHWINFO pHalHwInfo,
    U032 nsec
)
{
    U032 TimeHi;
    U032 TimeLo;
    U032 TimeCheck;
    
    //
    // For small delays which can only wrap PTIMER_TIME_0 once, doing 2's
    // comp math on TIME_0 is enough and means we don't have to sync TIME_1
    //
#define MAX_SMALLNS_TMRDELAY (0xFFFFFFFF >> 2)

    if (nsec < MAX_SMALLNS_TMRDELAY)
    {
        U032 TimeStart = REG_RD32(NV_PTIMER_TIME_0);
        while (nsec > ((volatile U032)REG_RD32(NV_PTIMER_TIME_0) - TimeStart))
		    ;
        return (RM_OK);
    }

    //
    // Get current time.
    //
    do
    {
        TimeCheck = REG_RD32(NV_PTIMER_TIME_1);
        TimeLo    = REG_RD32(NV_PTIMER_TIME_0);
        TimeHi    = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != TimeHi);

    //
    // Add nanosecond delay.
    //
    TimeLo += nsec;
    if (TimeLo < nsec)
        TimeHi++;
    //
    // Wait until time catches up.
    //
    while (TimeHi > (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_1)))
        ;
    //
    // Try to avoid infinite delay.
    //
    while ((TimeLo > (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_0))) &&
           (TimeHi == (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_1))))
        ;

    return (RM_OK);
}

//
// The following is from Luke Chang.
//

// we use 12.20 fixed point for these calculations
// the -from- function also rounds and masks to 4 bits
#define TOFIXEDPOINT(d)         ((d) << 20)
#define FROMFIXEDPOINT(d)       ((((d) + (0x1 << 19)) >> 20) & 0xf)

//
// Initialize drive/slew parameters.
//
static VOID
_nvHalFbInitDrvSlwParms(PHALHWINFO pHalHwInfo)
{
    PBIOSDRVSLWPARMS pBiosDrvSlwParms;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PDRVSLWPARMS pDrvSlwParms;

    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pDrvSlwParms = &pFbHalPvtInfo->drvSlwParms;

    //
    // Initialize static (extreme) values first.
    //
    pDrvSlwParms->SlowCountExt = SLOW_COUNT_EXT;
    pDrvSlwParms->FastCountExt = FAST_COUNT_EXT;

    pDrvSlwParms->SlowCountBExt = SLOW_COUNTB_EXT;
    pDrvSlwParms->FastCountBExt = FAST_COUNTB_EXT;

    // ********** EXTREME FAST Case Values
    pDrvSlwParms->AdrDrvFallFastExt = ADR_DRV_FALL_FAST_EXT;
    pDrvSlwParms->AdrDrvRiseFastExt = ADR_DRV_RISE_FAST_EXT;
    pDrvSlwParms->AdrSlwFallFastExt = ADR_SLW_FALL_FAST_EXT;
    pDrvSlwParms->AdrSlwRiseFastExt = ADR_SLW_RISE_FAST_EXT;

    pDrvSlwParms->ClkDrvFallFastExt = CLK_DRV_FALL_FAST_EXT;
    pDrvSlwParms->ClkDrvRiseFastExt = CLK_DRV_RISE_FAST_EXT;
    pDrvSlwParms->ClkSlwFallFastExt = CLK_SLW_FALL_FAST_EXT;
    pDrvSlwParms->ClkSlwRiseFastExt = CLK_SLW_RISE_FAST_EXT;

    pDrvSlwParms->DatDrvFallFastExt = DAT_DRV_FALL_FAST_EXT;
    pDrvSlwParms->DatDrvRiseFastExt = DAT_DRV_RISE_FAST_EXT;
    pDrvSlwParms->DatSlwFallFastExt = DAT_SLW_FALL_FAST_EXT;
    pDrvSlwParms->DatSlwRiseFastExt = DAT_SLW_RISE_FAST_EXT;

    pDrvSlwParms->DqsDrvFallFastExt = DQS_DRV_FALL_FAST_EXT;
    pDrvSlwParms->DqsDrvRiseFastExt = DQS_DRV_RISE_FAST_EXT;
    pDrvSlwParms->DqsSlwFallFastExt = DQS_SLW_FALL_FAST_EXT;
    pDrvSlwParms->DqsSlwRiseFastExt = DQS_SLW_RISE_FAST_EXT;

    pDrvSlwParms->DqsInbDelyFastExt = DQS_INB_DELY_FAST_EXT;

    // ********** EXTREME SLOW Case Values
    pDrvSlwParms->AdrDrvFallSlowExt = ADR_DRV_FALL_SLOW_EXT;
    pDrvSlwParms->AdrDrvRiseSlowExt = ADR_DRV_RISE_SLOW_EXT;
    pDrvSlwParms->AdrSlwFallSlowExt = ADR_SLW_FALL_SLOW_EXT;
    pDrvSlwParms->AdrSlwRiseSlowExt = ADR_SLW_RISE_SLOW_EXT;

    pDrvSlwParms->ClkDrvFallSlowExt = CLK_DRV_FALL_SLOW_EXT;
    pDrvSlwParms->ClkDrvRiseSlowExt = CLK_DRV_RISE_SLOW_EXT;
    pDrvSlwParms->ClkSlwFallSlowExt = CLK_SLW_FALL_SLOW_EXT;
    pDrvSlwParms->ClkSlwRiseSlowExt = CLK_SLW_RISE_SLOW_EXT;

    pDrvSlwParms->DatDrvFallSlowExt = DAT_DRV_FALL_SLOW_EXT;
    pDrvSlwParms->DatDrvRiseSlowExt = DAT_DRV_RISE_SLOW_EXT;
    pDrvSlwParms->DatSlwFallSlowExt = DAT_SLW_FALL_SLOW_EXT;
    pDrvSlwParms->DatSlwRiseSlowExt = DAT_SLW_RISE_SLOW_EXT;

    pDrvSlwParms->DqsDrvFallSlowExt = DQS_DRV_FALL_SLOW_EXT;
    pDrvSlwParms->DqsDrvRiseSlowExt = DQS_DRV_RISE_SLOW_EXT;
    pDrvSlwParms->DqsSlwFallSlowExt = DQS_SLW_FALL_SLOW_EXT;
    pDrvSlwParms->DqsSlwRiseSlowExt = DQS_SLW_RISE_SLOW_EXT;

    pDrvSlwParms->DqsInbDelySlowExt = DQS_INB_DELY_SLOW_EXT;

    //
    // Now initialize average and typical values.
    //
    // If we've got BIOS bip3 data that we're familiar with, use it.
    // Otherwise, fall back to static data.
    //
    // We also check the silicon rev (at least temporarily) to make
    // sure we don't use the drvslwparms table on an A02.  This could
    // happen if a newer bios was mis-flashed on the part.
    //
    pBiosDrvSlwParms = (PBIOSDRVSLWPARMS)pHalHwInfo->pFbHalInfo->pBiosDrvSlwParms;
    if (!IsNV20MaskRevA02_NV20(pHalHwInfo->pMcHalInfo) &&
        (pBiosDrvSlwParms != NULL && pBiosDrvSlwParms->Version >= 0x11))
    {
        //
        // Cool...pull it from the bios.
        //
        pDrvSlwParms->MaxMClk = (U016)pBiosDrvSlwParms->MaxMClk;
        pDrvSlwParms->SlowCountAvg = (U008)pBiosDrvSlwParms->SlowCountAvg;
        pDrvSlwParms->SlowCountBAvg = (U008)pBiosDrvSlwParms->SlowCountBAvg;
        pDrvSlwParms->TypiCount = (U008)pBiosDrvSlwParms->TypiCount;
        pDrvSlwParms->TypiCountB = (U008)pBiosDrvSlwParms->TypiCountB;
        pDrvSlwParms->FastCountAvg = (U008)pBiosDrvSlwParms->FastCountAvg;
        pDrvSlwParms->FastCountBAvg = (U008)pBiosDrvSlwParms->FastCountBAvg;
        pDrvSlwParms->FbioInterpMode = (U008)pBiosDrvSlwParms->FbioInterpMode;

        // ********** Average FAST Case Values
        pDrvSlwParms->AdrDrvFallFastAvg = (U008)pBiosDrvSlwParms->AdrDrvFallFastAvg;
        pDrvSlwParms->AdrDrvRiseFastAvg = (U008)pBiosDrvSlwParms->AdrDrvRiseFastAvg;
        pDrvSlwParms->AdrSlwFallFastAvg = (U008)pBiosDrvSlwParms->AdrSlwFallFastAvg;
        pDrvSlwParms->AdrSlwRiseFastAvg = (U008)pBiosDrvSlwParms->AdrSlwRiseFastAvg;

        pDrvSlwParms->ClkDrvFallFastAvg = (U008)pBiosDrvSlwParms->ClkDrvFallFastAvg;
        pDrvSlwParms->ClkDrvRiseFastAvg = (U008)pBiosDrvSlwParms->ClkDrvRiseFastAvg;
        pDrvSlwParms->ClkSlwFallFastAvg = (U008)pBiosDrvSlwParms->ClkSlwFallFastAvg;
        pDrvSlwParms->ClkSlwRiseFastAvg = (U008)pBiosDrvSlwParms->ClkSlwRiseFastAvg;

        pDrvSlwParms->DatDrvFallFastAvg = (U008)pBiosDrvSlwParms->DatDrvFallFastAvg;
        pDrvSlwParms->DatDrvRiseFastAvg = (U008)pBiosDrvSlwParms->DatDrvRiseFastAvg;
        pDrvSlwParms->DatSlwFallFastAvg = (U008)pBiosDrvSlwParms->DatSlwFallFastAvg;
        pDrvSlwParms->DatSlwRiseFastAvg = (U008)pBiosDrvSlwParms->DatSlwRiseFastAvg;

        pDrvSlwParms->DqsDrvFallFastAvg = (U008)pBiosDrvSlwParms->DqsDrvFallFastAvg;
        pDrvSlwParms->DqsDrvRiseFastAvg = (U008)pBiosDrvSlwParms->DqsDrvRiseFastAvg;
        pDrvSlwParms->DqsSlwFallFastAvg = (U008)pBiosDrvSlwParms->DqsSlwFallFastAvg;
        pDrvSlwParms->DqsSlwRiseFastAvg = (U008)pBiosDrvSlwParms->DqsSlwRiseFastAvg;

        pDrvSlwParms->DqsInbDelyFastAvg = (U008)pBiosDrvSlwParms->DqsInbDelyFastAvg;

        // ********** TYPICAL Case Values
        pDrvSlwParms->AdrDrvFallTypi = (U008)pBiosDrvSlwParms->AdrDrvFallTypi;
        pDrvSlwParms->AdrDrvRiseTypi = (U008)pBiosDrvSlwParms->AdrDrvRiseTypi;
        pDrvSlwParms->AdrSlwFallTypi = (U008)pBiosDrvSlwParms->AdrSlwFallTypi;
        pDrvSlwParms->AdrSlwRiseTypi = (U008)pBiosDrvSlwParms->AdrSlwRiseTypi;

        pDrvSlwParms->ClkDrvFallTypi = (U008)pBiosDrvSlwParms->ClkDrvFallTypi;
        pDrvSlwParms->ClkDrvRiseTypi = (U008)pBiosDrvSlwParms->ClkDrvRiseTypi;
        pDrvSlwParms->ClkSlwFallTypi = (U008)pBiosDrvSlwParms->ClkSlwFallTypi;
        pDrvSlwParms->ClkSlwRiseTypi = (U008)pBiosDrvSlwParms->ClkSlwRiseTypi;

        pDrvSlwParms->DatDrvFallTypi = (U008)pBiosDrvSlwParms->DatDrvFallTypi;
        pDrvSlwParms->DatDrvRiseTypi = (U008)pBiosDrvSlwParms->DatDrvRiseTypi;
        pDrvSlwParms->DatSlwFallTypi = (U008)pBiosDrvSlwParms->DatSlwFallTypi;
        pDrvSlwParms->DatSlwRiseTypi = (U008)pBiosDrvSlwParms->DatSlwRiseTypi;

        pDrvSlwParms->DqsDrvFallTypi = (U008)pBiosDrvSlwParms->DqsDrvFallTypi;
        pDrvSlwParms->DqsDrvRiseTypi = (U008)pBiosDrvSlwParms->DqsDrvRiseTypi;
        pDrvSlwParms->DqsSlwFallTypi = (U008)pBiosDrvSlwParms->DqsSlwFallTypi;
        pDrvSlwParms->DqsSlwRiseTypi = (U008)pBiosDrvSlwParms->DqsSlwRiseTypi;

        pDrvSlwParms->DqsInbDelyTypi = (U008)pBiosDrvSlwParms->DqsInbDelyTypi;

        // ********** Average SLOW Case Values
        pDrvSlwParms->AdrDrvFallSlowAvg = (U008)pBiosDrvSlwParms->AdrDrvFallSlowAvg;
        pDrvSlwParms->AdrDrvRiseSlowAvg = (U008)pBiosDrvSlwParms->AdrDrvRiseSlowAvg;
        pDrvSlwParms->AdrSlwFallSlowAvg = (U008)pBiosDrvSlwParms->AdrSlwFallSlowAvg;
        pDrvSlwParms->AdrSlwRiseSlowAvg = (U008)pBiosDrvSlwParms->AdrSlwRiseSlowAvg;

        pDrvSlwParms->ClkDrvFallSlowAvg = (U008)pBiosDrvSlwParms->ClkDrvFallSlowAvg;
        pDrvSlwParms->ClkDrvRiseSlowAvg = (U008)pBiosDrvSlwParms->ClkDrvRiseSlowAvg;
        pDrvSlwParms->ClkSlwFallSlowAvg = (U008)pBiosDrvSlwParms->ClkSlwFallSlowAvg;
        pDrvSlwParms->ClkSlwRiseSlowAvg = (U008)pBiosDrvSlwParms->ClkSlwRiseSlowAvg;

        pDrvSlwParms->DatDrvFallSlowAvg = (U008)pBiosDrvSlwParms->DatDrvFallSlowAvg;
        pDrvSlwParms->DatDrvRiseSlowAvg = (U008)pBiosDrvSlwParms->DatDrvRiseSlowAvg;
        pDrvSlwParms->DatSlwFallSlowAvg = (U008)pBiosDrvSlwParms->DatSlwFallSlowAvg;
        pDrvSlwParms->DatSlwRiseSlowAvg = (U008)pBiosDrvSlwParms->DatSlwRiseSlowAvg;

        pDrvSlwParms->DqsDrvFallSlowAvg = (U008)pBiosDrvSlwParms->DqsDrvFallSlowAvg;
        pDrvSlwParms->DqsDrvRiseSlowAvg = (U008)pBiosDrvSlwParms->DqsDrvRiseSlowAvg;
        pDrvSlwParms->DqsSlwFallSlowAvg = (U008)pBiosDrvSlwParms->DqsSlwFallSlowAvg;
        pDrvSlwParms->DqsSlwRiseSlowAvg = (U008)pBiosDrvSlwParms->DqsSlwRiseSlowAvg;

        pDrvSlwParms->DqsInbDelySlowAvg = (U008)pBiosDrvSlwParms->DqsInbDelySlowAvg;
    }
    else
    {
        //
        // Go with static table data.
        //
        pDrvSlwParms->MaxMClk = 20000;

        pDrvSlwParms->SlowCountAvg = SLOW_COUNT_AVG;
        pDrvSlwParms->SlowCountBAvg = SLOW_COUNTB_AVG;
        pDrvSlwParms->TypiCount = TYPI_COUNT;
        pDrvSlwParms->TypiCountB = TYPI_COUNTB;
        pDrvSlwParms->FastCountAvg = FAST_COUNT_AVG;
        pDrvSlwParms->FastCountBAvg = FAST_COUNTB_AVG;

        pDrvSlwParms->FbioInterpMode = FBIO_INTERP_MODE;

        // ********** Average FAST Case Values
        pDrvSlwParms->AdrDrvFallFastAvg = ADR_DRV_FALL_FAST_AVG;
        pDrvSlwParms->AdrDrvRiseFastAvg = ADR_DRV_RISE_FAST_AVG;
        pDrvSlwParms->AdrSlwFallFastAvg = ADR_SLW_FALL_FAST_AVG;
        pDrvSlwParms->AdrSlwRiseFastAvg = ADR_SLW_RISE_FAST_AVG;

        pDrvSlwParms->ClkDrvFallFastAvg = CLK_DRV_FALL_FAST_AVG;
        pDrvSlwParms->ClkDrvRiseFastAvg = CLK_DRV_RISE_FAST_AVG;
        pDrvSlwParms->ClkSlwFallFastAvg = CLK_SLW_FALL_FAST_AVG;
        pDrvSlwParms->ClkSlwRiseFastAvg = CLK_SLW_RISE_FAST_AVG;

        pDrvSlwParms->DatDrvFallFastAvg = DAT_DRV_FALL_FAST_AVG;
        pDrvSlwParms->DatDrvRiseFastAvg = DAT_DRV_RISE_FAST_AVG;
        pDrvSlwParms->DatSlwFallFastAvg = DAT_SLW_FALL_FAST_AVG;
        pDrvSlwParms->DatSlwRiseFastAvg = DAT_SLW_RISE_FAST_AVG;

        pDrvSlwParms->DqsDrvFallFastAvg = DQS_DRV_FALL_FAST_AVG;
        pDrvSlwParms->DqsDrvRiseFastAvg = DQS_DRV_RISE_FAST_AVG;
        pDrvSlwParms->DqsSlwFallFastAvg = DQS_SLW_FALL_FAST_AVG;
        pDrvSlwParms->DqsSlwRiseFastAvg = DQS_SLW_RISE_FAST_AVG;

        pDrvSlwParms->DqsInbDelyFastAvg = DQS_INB_DELY_FAST_AVG;

        // ********** TYPICAL Case Values
        pDrvSlwParms->AdrDrvFallTypi = ADR_DRV_FALL_TYPI;
        pDrvSlwParms->AdrDrvRiseTypi = ADR_DRV_RISE_TYPI;
        pDrvSlwParms->AdrSlwFallTypi = ADR_SLW_FALL_TYPI;
        pDrvSlwParms->AdrSlwRiseTypi = ADR_SLW_RISE_TYPI;

        pDrvSlwParms->ClkDrvFallTypi = CLK_DRV_FALL_TYPI;
        pDrvSlwParms->ClkDrvRiseTypi = CLK_DRV_RISE_TYPI;
        pDrvSlwParms->ClkSlwFallTypi = CLK_SLW_FALL_TYPI;
        pDrvSlwParms->ClkSlwRiseTypi = CLK_SLW_RISE_TYPI;

        pDrvSlwParms->DatDrvFallTypi = DAT_DRV_FALL_TYPI;
        pDrvSlwParms->DatDrvRiseTypi = DAT_DRV_RISE_TYPI;
        pDrvSlwParms->DatSlwFallTypi = DAT_SLW_FALL_TYPI;
        pDrvSlwParms->DatSlwRiseTypi = DAT_SLW_RISE_TYPI;

        pDrvSlwParms->DqsDrvFallTypi = DQS_DRV_FALL_TYPI;
        pDrvSlwParms->DqsDrvRiseTypi = DQS_DRV_RISE_TYPI;
        pDrvSlwParms->DqsSlwFallTypi = DQS_SLW_FALL_TYPI;
        pDrvSlwParms->DqsSlwRiseTypi = DQS_SLW_RISE_TYPI;

        pDrvSlwParms->DqsInbDelyTypi = DQS_INB_DELY_TYPI;

        // ********** Average SLOW Case Values
        pDrvSlwParms->AdrDrvFallSlowAvg = ADR_DRV_FALL_SLOW_AVG;
        pDrvSlwParms->AdrDrvRiseSlowAvg = ADR_DRV_RISE_SLOW_AVG;
        pDrvSlwParms->AdrSlwFallSlowAvg = ADR_SLW_FALL_SLOW_AVG;
        pDrvSlwParms->AdrSlwRiseSlowAvg = ADR_SLW_RISE_SLOW_AVG;

        pDrvSlwParms->ClkDrvFallSlowAvg = CLK_DRV_FALL_SLOW_AVG;
        pDrvSlwParms->ClkDrvRiseSlowAvg = CLK_DRV_RISE_SLOW_AVG;
        pDrvSlwParms->ClkSlwFallSlowAvg = CLK_SLW_FALL_SLOW_AVG;
        pDrvSlwParms->ClkSlwRiseSlowAvg = CLK_SLW_RISE_SLOW_AVG;

        pDrvSlwParms->DatDrvFallSlowAvg = DAT_DRV_FALL_SLOW_AVG;
        pDrvSlwParms->DatDrvRiseSlowAvg = DAT_DRV_RISE_SLOW_AVG;
        pDrvSlwParms->DatSlwFallSlowAvg = DAT_SLW_FALL_SLOW_AVG;
        pDrvSlwParms->DatSlwRiseSlowAvg = DAT_SLW_RISE_SLOW_AVG;

        pDrvSlwParms->DqsDrvFallSlowAvg = DQS_DRV_FALL_SLOW_AVG;
        pDrvSlwParms->DqsDrvRiseSlowAvg = DQS_DRV_RISE_SLOW_AVG;
        pDrvSlwParms->DqsSlwFallSlowAvg = DQS_SLW_FALL_SLOW_AVG;
        pDrvSlwParms->DqsSlwRiseSlowAvg = DQS_SLW_RISE_SLOW_AVG;

        pDrvSlwParms->DqsInbDelySlowAvg = DQS_INB_DELY_SLOW_AVG;
    }
}

// **** Setup optimal drive and slew based on operating condition
// **** For oeprating conditions outside slow and fast border, just use the
// **** slow and fast settings. For values in between, use linear 
// **** interpolation between the settings.
//
VOID
nvHalFbCalcDrvSlw_NV20(PHALHWINFO pHalHwInfo)
{
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PDRVSLWPARMS pDrvSlwParms;
    U032 count0, count1, count2, count3, acount, bcount;
    U032 adr_drv_fall_lo=0, adr_drv_rise_lo=0,
        clk_drv_fall_lo=0, clk_drv_rise_lo=0,
        dat_drv_fall_lo=0, dat_drv_rise_lo=0,
        dqs_drv_fall_lo=0, dqs_drv_rise_lo=0;

    U032 adr_drv_fall_hi=0, adr_drv_rise_hi=0,
        clk_drv_fall_hi=0, clk_drv_rise_hi=0,
        dat_drv_fall_hi=0, dat_drv_rise_hi=0,
        dqs_drv_fall_hi=0, dqs_drv_rise_hi=0;
 
    U032 adr_drv_fall=0, adr_drv_rise=0,
        clk_drv_fall=0, clk_drv_rise=0,
        dat_drv_fall=0, dat_drv_rise=0,
        dqs_drv_fall=0, dqs_drv_rise=0;

    U032 adr_drv, clk_drv, dat_drv, dqs_drv;

    U032 adr_slw_fall_lo=0, adr_slw_rise_lo=0,
        clk_slw_fall_lo=0, clk_slw_rise_lo=0,
        dat_slw_fall_lo=0, dat_slw_rise_lo=0,
        dqs_slw_fall_lo=0, dqs_slw_rise_lo=0;

    U032 adr_slw_fall_hi=0, adr_slw_rise_hi=0,
        clk_slw_fall_hi=0, clk_slw_rise_hi=0,
        dat_slw_fall_hi=0, dat_slw_rise_hi=0,
        dqs_slw_fall_hi=0, dqs_slw_rise_hi=0;

    U032 adr_slw_fall=0, adr_slw_rise=0,
        clk_slw_fall=0, clk_slw_rise=0,
        dat_slw_fall=0, dat_slw_rise=0,
        dqs_slw_fall=0, dqs_slw_rise=0;

    U032 adr_slw, clk_slw, dat_slw, dqs_slw;

    U032 dqs_ib_del_lo=0, dqs_ib_del_hi=0, dqs_ib_del=0;
    U032 dqs_ib;

    U032 ratio_a, ratio_b;
    U032 ratio2_a, ratio2_b;

    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pDrvSlwParms = &pFbHalPvtInfo->drvSlwParms;

#define NV_PBUS_FBIO_CALEN_VAL          0x000f0f0f
#define NV_PBUS_FBIO_CALSEL_VAL         0x00040004
#define NV_PBUS_FBIO_CALSELB_VAL        0x00040000

    //******* Figure out which operating condition we are in  
    REG_WR32(NV_PBUS_FBIO_CALEN, NV_PBUS_FBIO_CALEN_VAL);

    REG_WR32(NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSEL_VAL);
    fbDelay_NV20(pHalHwInfo, 10*1000);
    count0 = REG_RD32(NV_PBUS_FBIO_CALCNT);

    REG_WR32(NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSEL_VAL+1);
    // ****** need some delay here (~10 us ms) here
    fbDelay_NV20(pHalHwInfo, 10*1000);
    count1 = REG_RD32(NV_PBUS_FBIO_CALCNT);

    REG_WR32(NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSEL_VAL+2);
    // ****** need some delay here (~10 us ms)
    fbDelay_NV20(pHalHwInfo, 10*1000);
    count2 = REG_RD32(NV_PBUS_FBIO_CALCNT);

    REG_WR32(NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSEL_VAL+3);
    // ****** need some delay here (~10 us ms)
    fbDelay_NV20(pHalHwInfo, 10*1000);
    count3 = REG_RD32(NV_PBUS_FBIO_CALCNT);

    acount = (count0 + count1 + count2 + count3) / 4;
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "drvslw_nv20: acount ", acount);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "             count0 ", count0);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "             count1 ", count1);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "             count2 ", count2);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "             count3 ", count3);

    // ******* New Code - 2/16/01 **********
    // ******* Get VDD speedometers for FBIO_DLY calibration
    REG_WR32(NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSELB_VAL);
    fbDelay_NV20(pHalHwInfo, 10*1000);
    count0 = REG_RD32(NV_PBUS_FBIO_CALCNT);

    REG_WR32(NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSELB_VAL+1);
    fbDelay_NV20(pHalHwInfo, 10*1000);
    count1 = REG_RD32(NV_PBUS_FBIO_CALCNT);

    REG_WR32(NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSELB_VAL+2);
    fbDelay_NV20(pHalHwInfo, 10*1000);
    count2 = REG_RD32(NV_PBUS_FBIO_CALCNT);

    REG_WR32(NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSELB_VAL+3);
    fbDelay_NV20(pHalHwInfo, 10*1000);
    count3 = REG_RD32(NV_PBUS_FBIO_CALCNT);

    bcount = (count0 + count1 + count2 + count3) / 4;
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "drvslw_nv20: bcount ", bcount);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "             count0 ", count0);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "             count1 ", count1);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "             count2 ", count2);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "             count3 ", count3);

    //******** Shut off oscillators to reduce power and noise
    REG_WR32(NV_PBUS_FBIO_CALEN, 0);

    //
    // If these remain 0, then we'll assume that no interpolation
    // is required.
    //
    ratio_a = ratio_b = 0;
    ratio2_a = ratio2_b = 0;

    if ((acount <= pDrvSlwParms->SlowCountAvg) && (pDrvSlwParms->FbioInterpMode == 0))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, " slow case - clamp to extremes\n");

        adr_drv_fall = pDrvSlwParms->AdrDrvFallSlowExt;			
        adr_drv_rise = pDrvSlwParms->AdrDrvRiseSlowExt;
        adr_slw_fall = pDrvSlwParms->AdrSlwFallSlowExt;			
        adr_slw_rise = pDrvSlwParms->AdrSlwRiseSlowExt;

        clk_drv_fall = pDrvSlwParms->ClkDrvFallSlowExt;			
        clk_drv_rise = pDrvSlwParms->ClkDrvRiseSlowExt;
        clk_slw_fall = pDrvSlwParms->ClkSlwFallSlowExt;			
        clk_slw_rise = pDrvSlwParms->ClkSlwRiseSlowExt;
				
        dat_drv_fall = pDrvSlwParms->DatDrvFallSlowExt;			
        dat_drv_rise = pDrvSlwParms->DatDrvRiseSlowExt;
        dat_slw_fall = pDrvSlwParms->DatSlwFallSlowExt;			
        dat_slw_rise = pDrvSlwParms->DatSlwRiseSlowExt;

        dqs_drv_fall = pDrvSlwParms->DqsDrvFallSlowExt;			
        dqs_drv_rise = pDrvSlwParms->DqsDrvRiseSlowExt;
        dqs_slw_fall = pDrvSlwParms->DqsSlwFallSlowExt;			
        dqs_slw_rise = pDrvSlwParms->DqsSlwRiseSlowExt;
    }
    else if ((acount <= pDrvSlwParms->SlowCountAvg) && (pDrvSlwParms->FbioInterpMode == 1))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, " slow case - clamp to averages\n");
        adr_drv_fall = pDrvSlwParms->AdrDrvFallSlowAvg;			
        adr_drv_rise = pDrvSlwParms->AdrDrvRiseSlowAvg;
        adr_slw_fall = pDrvSlwParms->AdrSlwFallSlowAvg;			
        adr_slw_rise = pDrvSlwParms->AdrSlwRiseSlowAvg;

        clk_drv_fall = pDrvSlwParms->ClkDrvFallSlowAvg;			
        clk_drv_rise = pDrvSlwParms->ClkDrvRiseSlowAvg;
        clk_slw_fall = pDrvSlwParms->ClkSlwFallSlowAvg;			
        clk_slw_rise = pDrvSlwParms->ClkSlwRiseSlowAvg;
				
        dat_drv_fall = pDrvSlwParms->DatDrvFallSlowAvg;			
        dat_drv_rise = pDrvSlwParms->DatDrvRiseSlowAvg;
        dat_slw_fall = pDrvSlwParms->DatSlwFallSlowAvg;			
        dat_slw_rise = pDrvSlwParms->DatSlwRiseSlowAvg;

        dqs_drv_fall = pDrvSlwParms->DqsDrvFallSlowAvg;			
        dqs_drv_rise = pDrvSlwParms->DqsDrvRiseSlowAvg;
        dqs_slw_fall = pDrvSlwParms->DqsSlwFallSlowAvg;			
        dqs_slw_rise = pDrvSlwParms->DqsSlwRiseSlowAvg;
    }
    else if ((acount <= pDrvSlwParms->SlowCountAvg) && (pDrvSlwParms->FbioInterpMode == 2))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, " slow case - interp avg and extreme\n");

        adr_drv_fall_lo = pDrvSlwParms->AdrDrvFallSlowExt;			
        adr_drv_rise_lo = pDrvSlwParms->AdrDrvRiseSlowExt;
        adr_slw_fall_lo = pDrvSlwParms->AdrSlwFallSlowExt;			
        adr_slw_rise_lo = pDrvSlwParms->AdrSlwRiseSlowExt;

        clk_drv_fall_lo = pDrvSlwParms->ClkDrvFallSlowExt;			
        clk_drv_rise_lo = pDrvSlwParms->ClkDrvRiseSlowExt;
        clk_slw_fall_lo = pDrvSlwParms->ClkSlwFallSlowExt;			
        clk_slw_rise_lo = pDrvSlwParms->ClkSlwRiseSlowExt;
				
        dat_drv_fall_lo = pDrvSlwParms->DatDrvFallSlowExt;			
        dat_drv_rise_lo = pDrvSlwParms->DatDrvRiseSlowExt;
        dat_slw_fall_lo = pDrvSlwParms->DatSlwFallSlowExt;			
        dat_slw_rise_lo = pDrvSlwParms->DatSlwRiseSlowExt;

        dqs_drv_fall_lo = pDrvSlwParms->DqsDrvFallSlowExt;			
        dqs_drv_rise_lo = pDrvSlwParms->DqsDrvRiseSlowExt;
        dqs_slw_fall_lo = pDrvSlwParms->DqsSlwFallSlowExt;			
        dqs_slw_rise_lo = pDrvSlwParms->DqsSlwRiseSlowExt;

        adr_drv_fall_hi = pDrvSlwParms->AdrDrvFallSlowAvg;
        adr_drv_rise_hi = pDrvSlwParms->AdrDrvRiseSlowAvg;
        adr_slw_fall_hi = pDrvSlwParms->AdrSlwFallSlowAvg;
        adr_slw_rise_hi = pDrvSlwParms->AdrSlwRiseSlowAvg;

        clk_drv_fall_hi = pDrvSlwParms->ClkDrvFallSlowAvg;
        clk_drv_rise_hi = pDrvSlwParms->ClkDrvRiseSlowAvg;
        clk_slw_fall_hi = pDrvSlwParms->ClkSlwFallSlowAvg;
        clk_slw_rise_hi = pDrvSlwParms->ClkSlwRiseSlowAvg;
				
        dat_drv_fall_hi = pDrvSlwParms->DatDrvFallSlowAvg;
        dat_drv_rise_hi = pDrvSlwParms->DatDrvRiseSlowAvg;
        dat_slw_fall_hi = pDrvSlwParms->DatSlwFallSlowAvg;
        dat_slw_rise_hi = pDrvSlwParms->DatSlwRiseSlowAvg;

        dqs_drv_fall_hi = pDrvSlwParms->DqsDrvFallSlowAvg;
        dqs_drv_rise_hi = pDrvSlwParms->DqsDrvRiseSlowAvg;
        dqs_slw_fall_hi = pDrvSlwParms->DqsSlwFallSlowAvg;			
        dqs_slw_rise_hi = pDrvSlwParms->DqsSlwRiseSlowAvg;

        //ratio_a = (acount - SLOW_COUNT_EXT) / (SLOW_COUNT_AVG - SLOW_COUNT_EXT);
        //if (ratio_a < 0)
        //    ratio_a = 0;
        //ratio_b = 1.0 - ratio_a;
        ratio_a = TOFIXEDPOINT(acount - pDrvSlwParms->SlowCountExt) / (pDrvSlwParms->SlowCountAvg - pDrvSlwParms->SlowCountExt);
        if (ratio_a & 0x80000000)       // good test for < 0?!?
            ratio_a = 0;
        ratio_b = TOFIXEDPOINT(1) - ratio_a;
    }
    else if ((acount >= pDrvSlwParms->FastCountAvg) && (pDrvSlwParms->FbioInterpMode == 0))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, " fast case - clamp to extremes\n");

        adr_drv_fall = pDrvSlwParms->AdrDrvFallFastExt;
        adr_drv_rise = pDrvSlwParms->AdrDrvRiseFastExt;
        adr_slw_fall = pDrvSlwParms->AdrSlwFallFastExt;
        adr_slw_rise = pDrvSlwParms->AdrSlwRiseFastExt;

        clk_drv_fall = pDrvSlwParms->ClkDrvFallFastExt;
        clk_drv_rise = pDrvSlwParms->ClkDrvRiseFastExt;
        clk_slw_fall = pDrvSlwParms->ClkSlwFallFastExt;
        clk_slw_rise = pDrvSlwParms->ClkSlwRiseFastExt;
				
        dat_drv_fall = pDrvSlwParms->DatDrvFallFastExt;
        dat_drv_rise = pDrvSlwParms->DatDrvRiseFastExt;
        dat_slw_fall = pDrvSlwParms->DatSlwFallFastExt;
        dat_slw_rise = pDrvSlwParms->DatSlwRiseFastExt;

        dqs_drv_fall = pDrvSlwParms->DqsDrvFallFastExt;
        dqs_drv_rise = pDrvSlwParms->DqsDrvRiseFastExt;
        dqs_slw_fall = pDrvSlwParms->DqsSlwFallFastExt;
        dqs_slw_rise = pDrvSlwParms->DqsSlwRiseFastExt;
    }
    else if ((acount >= pDrvSlwParms->FastCountAvg) && (pDrvSlwParms->FbioInterpMode == 1))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, " fast case - clamp to averages\n");

        adr_drv_fall = pDrvSlwParms->AdrDrvFallFastAvg;
        adr_drv_rise = pDrvSlwParms->AdrDrvRiseFastAvg;
        adr_slw_fall = pDrvSlwParms->AdrSlwFallFastAvg;
        adr_slw_rise = pDrvSlwParms->AdrSlwRiseFastAvg;

        clk_drv_fall = pDrvSlwParms->ClkDrvFallFastAvg;
        clk_drv_rise = pDrvSlwParms->ClkDrvRiseFastAvg;
        clk_slw_fall = pDrvSlwParms->ClkSlwFallFastAvg;
        clk_slw_rise = pDrvSlwParms->ClkSlwRiseFastAvg;
				
        dat_drv_fall = pDrvSlwParms->DatDrvFallFastAvg;
        dat_drv_rise = pDrvSlwParms->DatDrvRiseFastAvg;
        dat_slw_fall = pDrvSlwParms->DatSlwFallFastAvg;
        dat_slw_rise = pDrvSlwParms->DatSlwRiseFastAvg;

        dqs_drv_fall = pDrvSlwParms->DqsDrvFallFastAvg;
        dqs_drv_rise = pDrvSlwParms->DqsDrvRiseFastAvg;
        dqs_slw_fall = pDrvSlwParms->DqsSlwFallFastAvg;
        dqs_slw_rise = pDrvSlwParms->DqsSlwRiseFastAvg;
    }
    else if ((acount >= pDrvSlwParms->FastCountAvg) && (pDrvSlwParms->FbioInterpMode == 2))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, " fast case - interp avg and extreme\n");

        adr_drv_fall_lo = pDrvSlwParms->AdrDrvFallFastAvg;			
        adr_drv_rise_lo = pDrvSlwParms->AdrDrvRiseFastAvg;
        adr_slw_fall_lo = pDrvSlwParms->AdrSlwFallFastAvg;			
        adr_slw_rise_lo = pDrvSlwParms->AdrSlwRiseFastAvg;

        clk_drv_fall_lo = pDrvSlwParms->ClkDrvFallFastAvg;			
        clk_drv_rise_lo = pDrvSlwParms->ClkDrvRiseFastAvg;
        clk_slw_fall_lo = pDrvSlwParms->ClkSlwFallFastAvg;			
        clk_slw_rise_lo = pDrvSlwParms->ClkSlwRiseFastAvg;
				
        dat_drv_fall_lo = pDrvSlwParms->DatDrvFallFastAvg;			
        dat_drv_rise_lo = pDrvSlwParms->DatDrvRiseFastAvg;
        dat_slw_fall_lo = pDrvSlwParms->DatSlwFallFastAvg;			
        dat_slw_rise_lo = pDrvSlwParms->DatSlwRiseFastAvg;

        dqs_drv_fall_lo = pDrvSlwParms->DqsDrvFallFastAvg;			
        dqs_drv_rise_lo = pDrvSlwParms->DqsDrvRiseFastAvg;
        dqs_slw_fall_lo = pDrvSlwParms->DqsSlwFallFastAvg;			
        dqs_slw_rise_lo = pDrvSlwParms->DqsSlwRiseFastAvg;

        adr_drv_fall_hi = pDrvSlwParms->AdrDrvFallFastExt;
        adr_drv_rise_hi = pDrvSlwParms->AdrDrvRiseFastExt;
        adr_slw_fall_hi = pDrvSlwParms->AdrSlwFallFastExt;
        adr_slw_rise_hi = pDrvSlwParms->AdrSlwRiseFastExt;

        clk_drv_fall_hi = pDrvSlwParms->ClkDrvFallFastExt;
        clk_drv_rise_hi = pDrvSlwParms->ClkDrvRiseFastExt;
        clk_slw_fall_hi = pDrvSlwParms->ClkSlwFallFastExt;
        clk_slw_rise_hi = pDrvSlwParms->ClkSlwRiseFastExt;
				
        dat_drv_fall_hi = pDrvSlwParms->DatDrvFallFastExt;
        dat_drv_rise_hi = pDrvSlwParms->DatDrvRiseFastExt;
        dat_slw_fall_hi = pDrvSlwParms->DatSlwFallFastExt;
        dat_slw_rise_hi = pDrvSlwParms->DatSlwRiseFastExt;

        dqs_drv_fall_hi = pDrvSlwParms->DqsDrvFallFastExt;
        dqs_drv_rise_hi = pDrvSlwParms->DqsDrvRiseFastExt;
        dqs_slw_fall_hi = pDrvSlwParms->DqsSlwFallFastExt;			
        dqs_slw_rise_hi = pDrvSlwParms->DqsSlwRiseFastExt;

        //ratio_a = (acount - SLOW_COUNT_EXT) / (SLOW_COUNT_AVG - SLOW_COUNT_EXT);
        //if (ratio_a < 0)
        //    ratio_a = 0;
        //ratio_b = 1.0 - ratio_a;
        ratio_a = TOFIXEDPOINT(acount - pDrvSlwParms->FastCountAvg) / (pDrvSlwParms->FastCountExt - pDrvSlwParms->FastCountAvg);
        if (ratio_a > TOFIXEDPOINT(1))
            ratio_a = TOFIXEDPOINT(1);
        ratio_b = TOFIXEDPOINT(1) - ratio_a;
    }
    else if (acount < pDrvSlwParms->TypiCount)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, " between slow and typi cases\n");

        adr_drv_fall_lo = pDrvSlwParms->AdrDrvFallSlowAvg;
        adr_drv_rise_lo = pDrvSlwParms->AdrDrvRiseSlowAvg;
        adr_slw_fall_lo = pDrvSlwParms->AdrSlwFallSlowAvg;
        adr_slw_rise_lo = pDrvSlwParms->AdrSlwRiseSlowAvg;

        clk_drv_fall_lo = pDrvSlwParms->ClkDrvFallSlowAvg;
        clk_drv_rise_lo = pDrvSlwParms->ClkDrvRiseSlowAvg;
        clk_slw_fall_lo = pDrvSlwParms->ClkSlwFallSlowAvg;
        clk_slw_rise_lo = pDrvSlwParms->ClkSlwRiseSlowAvg;
				
        dat_drv_fall_lo = pDrvSlwParms->DatDrvFallSlowAvg;
        dat_drv_rise_lo = pDrvSlwParms->DatDrvRiseSlowAvg;
        dat_slw_fall_lo = pDrvSlwParms->DatSlwFallSlowAvg;
        dat_slw_rise_lo = pDrvSlwParms->DatSlwRiseSlowAvg;

        dqs_drv_fall_lo = pDrvSlwParms->DqsDrvFallSlowAvg;
        dqs_drv_rise_lo = pDrvSlwParms->DqsDrvRiseSlowAvg;
        dqs_slw_fall_lo = pDrvSlwParms->DqsSlwFallSlowAvg;
        dqs_slw_rise_lo = pDrvSlwParms->DqsSlwRiseSlowAvg;

        adr_drv_fall_hi = pDrvSlwParms->AdrDrvFallTypi;
        adr_drv_rise_hi = pDrvSlwParms->AdrDrvRiseTypi;
        adr_slw_fall_hi = pDrvSlwParms->AdrSlwFallTypi;
        adr_slw_rise_hi = pDrvSlwParms->AdrSlwRiseTypi;

        clk_drv_fall_hi = pDrvSlwParms->ClkDrvFallTypi;
        clk_drv_rise_hi = pDrvSlwParms->ClkDrvRiseTypi;
        clk_slw_fall_hi = pDrvSlwParms->ClkSlwFallTypi;
        clk_slw_rise_hi = pDrvSlwParms->ClkSlwRiseTypi;
				
        dat_drv_fall_hi = pDrvSlwParms->DatDrvFallTypi;
        dat_drv_rise_hi = pDrvSlwParms->DatDrvRiseTypi;
        dat_slw_fall_hi = pDrvSlwParms->DatSlwFallTypi;
        dat_slw_rise_hi = pDrvSlwParms->DatSlwRiseTypi;

        dqs_drv_fall_hi = pDrvSlwParms->DqsDrvFallTypi;
        dqs_drv_rise_hi = pDrvSlwParms->DqsDrvRiseTypi;
        dqs_slw_fall_hi = pDrvSlwParms->DqsSlwFallTypi;
        dqs_slw_rise_hi = pDrvSlwParms->DqsSlwRiseTypi;

        //ratio_a = (acount - SLOW_COUNT_AVG) / (TYPI_COUNT - SLOW_COUNT_AVG);
        //ratio_b = 1.0 - ratio_a;
        ratio_a = TOFIXEDPOINT(acount - pDrvSlwParms->SlowCountAvg) / (pDrvSlwParms->TypiCount - pDrvSlwParms->SlowCountAvg);
        ratio_b = TOFIXEDPOINT(1) - ratio_a;
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, " between typi and fast cases\n");

        adr_drv_fall_lo = pDrvSlwParms->AdrDrvFallTypi;
        adr_drv_rise_lo = pDrvSlwParms->AdrDrvRiseTypi;
        adr_slw_fall_lo = pDrvSlwParms->AdrSlwFallTypi;
        adr_slw_rise_lo = pDrvSlwParms->AdrSlwRiseTypi;

        clk_drv_fall_lo = pDrvSlwParms->ClkDrvFallTypi;
        clk_drv_rise_lo = pDrvSlwParms->ClkDrvRiseTypi;
        clk_slw_fall_lo = pDrvSlwParms->ClkSlwFallTypi;
        clk_slw_rise_lo = pDrvSlwParms->ClkSlwRiseTypi;
				
        dat_drv_fall_lo = pDrvSlwParms->DatDrvFallTypi;
        dat_drv_rise_lo = pDrvSlwParms->DatDrvRiseTypi;
        dat_slw_fall_lo = pDrvSlwParms->DatSlwFallTypi;
        dat_slw_rise_lo = pDrvSlwParms->DatSlwRiseTypi;

        dqs_drv_fall_lo = pDrvSlwParms->DqsDrvFallTypi;
        dqs_drv_rise_lo = pDrvSlwParms->DqsDrvRiseTypi;
        dqs_slw_fall_lo = pDrvSlwParms->DqsSlwFallTypi;
        dqs_slw_rise_lo = pDrvSlwParms->DqsSlwRiseTypi;

        adr_drv_fall_hi = pDrvSlwParms->AdrDrvFallFastAvg;
        adr_drv_rise_hi = pDrvSlwParms->AdrDrvRiseFastAvg;
        adr_slw_fall_hi = pDrvSlwParms->AdrSlwFallFastAvg;
        adr_slw_rise_hi = pDrvSlwParms->AdrSlwRiseFastAvg;

        clk_drv_fall_hi = pDrvSlwParms->ClkDrvFallFastAvg;
        clk_drv_rise_hi = pDrvSlwParms->ClkDrvRiseFastAvg;
        clk_slw_fall_hi = pDrvSlwParms->ClkSlwFallFastAvg;
        clk_slw_rise_hi = pDrvSlwParms->ClkSlwRiseFastAvg;
				
        dat_drv_fall_hi = pDrvSlwParms->DatDrvFallFastAvg;
        dat_drv_rise_hi = pDrvSlwParms->DatDrvRiseFastAvg;
        dat_slw_fall_hi = pDrvSlwParms->DatSlwFallFastAvg;
        dat_slw_rise_hi = pDrvSlwParms->DatSlwRiseFastAvg;

        dqs_drv_fall_hi = pDrvSlwParms->DqsDrvFallFastAvg;
        dqs_drv_rise_hi = pDrvSlwParms->DqsDrvRiseFastAvg;
        dqs_slw_fall_hi = pDrvSlwParms->DqsSlwFallFastAvg;
        dqs_slw_rise_hi = pDrvSlwParms->DqsSlwRiseFastAvg;

        //ratio_a = (acount - TYPI_COUNT) / (FAST_COUNT_AVG - TYPI_COUNT);
        //ratio_b = 1.0 - ratio_a;
        ratio_a = TOFIXEDPOINT(acount - pDrvSlwParms->TypiCount) / (pDrvSlwParms->FastCountAvg - pDrvSlwParms->TypiCount);
        ratio_b = TOFIXEDPOINT(1) - ratio_a;
    }

    // ******* New Code - 2/16/01 **********
    //********** Set DQS_IB delay based on VDD speedometer
    if ((bcount <= pDrvSlwParms->SlowCountBAvg) && (pDrvSlwParms->FbioInterpMode == 0))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "Slow case - Clamp to extremes\n");
        dqs_ib_del = pDrvSlwParms->DqsInbDelySlowExt;
    }
    else if ((bcount <= pDrvSlwParms->SlowCountBAvg) && (pDrvSlwParms->FbioInterpMode == 1))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "Slow case - Clamp to Average\n");
        dqs_ib_del = pDrvSlwParms->DqsInbDelySlowAvg;
    }
    else if ((bcount <= pDrvSlwParms->SlowCountBAvg) && (pDrvSlwParms->FbioInterpMode == 2))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, " slow case - interp avg and extreme\n");

        dqs_ib_del_lo = pDrvSlwParms->DqsInbDelySlowExt;
        dqs_ib_del_hi = pDrvSlwParms->DqsInbDelySlowAvg;

        //ratio_a = (acount - SLOW_COUNT_EXT) / (SLOW_COUNT_AVG - SLOW_COUNT_EXT);
        //if (ratio_a < 0)
        //    ratio_a = 0;
        //ratio_b = 1.0 - ratio_a;
        ratio2_a = TOFIXEDPOINT(bcount - pDrvSlwParms->SlowCountBExt) / (pDrvSlwParms->SlowCountBAvg - pDrvSlwParms->SlowCountBExt);
        if (ratio2_a & 0x80000000)       // good test for < 0?!?
            ratio2_a = 0;
        ratio2_b = TOFIXEDPOINT(1) - ratio2_a;
    }
    else if ((bcount >= pDrvSlwParms->FastCountBAvg) && (pDrvSlwParms->FbioInterpMode == 0))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "Fast case - Clamp to Extremes\n");
        dqs_ib_del = pDrvSlwParms->DqsInbDelyFastExt;
    }
    else if ((bcount >= pDrvSlwParms->FastCountBAvg) && (pDrvSlwParms->FbioInterpMode == 1))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "Fast case - Clamp to Averages\n");
        dqs_ib_del = pDrvSlwParms->DqsInbDelyFastAvg;
    }
    else if ((bcount >= pDrvSlwParms->FastCountBAvg) && (pDrvSlwParms->FbioInterpMode == 2))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, " fast case - interp avg and extreme\n");

        dqs_ib_del_lo = pDrvSlwParms->DqsInbDelyFastAvg;
        dqs_ib_del_hi = pDrvSlwParms->DqsInbDelyFastExt;

        //ratio_a = (ucount - SLOW_COUNT_EXT) / (SLOW_COUNT_AVG - SLOW_COUNT_EXT);
        //if (ratio_a < 0)
        //    ratio_a = 0;
        //ratio_b = 1.0 - ratio_a;
        ratio2_a = TOFIXEDPOINT(bcount - pDrvSlwParms->FastCountBAvg) / (pDrvSlwParms->FastCountBExt - pDrvSlwParms->FastCountBAvg);
        if (ratio2_a > TOFIXEDPOINT(1))
            ratio2_a = TOFIXEDPOINT(1);
        ratio2_b = TOFIXEDPOINT(1) - ratio2_a;
    }
    else if (bcount < pDrvSlwParms->TypiCountB)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, " between slow and typi cases\n");

        dqs_ib_del_lo = pDrvSlwParms->DqsInbDelySlowAvg;
        dqs_ib_del_hi = pDrvSlwParms->DqsInbDelyTypi;

        //ratio_a = (acount - SLOW_COUNT_AVG) / (TYPI_COUNT - SLOW_COUNT_AVG);
        //ratio_b = 1.0 - ratio_a;
        ratio2_a = TOFIXEDPOINT(bcount - pDrvSlwParms->SlowCountBAvg) / (pDrvSlwParms->TypiCountB - pDrvSlwParms->SlowCountBAvg);
        ratio2_b = TOFIXEDPOINT(1) - ratio2_a;
    }
    else 
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, " between typi and fast cases\n");

        dqs_ib_del_lo = pDrvSlwParms->DqsInbDelyTypi;
        dqs_ib_del_hi = pDrvSlwParms->DqsInbDelyFastAvg;

        //ratio_a = (acount - TYPI_COUNT) / (FAST_COUNT_AVG - TYPI_COUNT);
        //ratio_b = 1.0 - ratio_a;
        ratio2_a = TOFIXEDPOINT(bcount - pDrvSlwParms->TypiCountB) / (pDrvSlwParms->FastCountBAvg - pDrvSlwParms->TypiCountB);
        ratio2_b = TOFIXEDPOINT(1) - ratio2_a;
    }

    //
    // Interpolation required...
    //
    if (ratio_a != 0 || ratio_b != 0)
    {
        //adr_drv_fall = Math.round((adr_drv_fall_lo * ratio_b) +
        //                          (adr_drv_fall_hi * ratio_a));
        adr_drv_fall = FROMFIXEDPOINT((adr_drv_fall_lo * ratio_b) +
                                      (adr_drv_fall_hi * ratio_a)); 
        adr_drv_rise = FROMFIXEDPOINT((adr_drv_rise_lo * ratio_b) +
                                      (adr_drv_rise_hi * ratio_a));
        adr_slw_fall = FROMFIXEDPOINT((adr_slw_fall_lo * ratio_b) +
                                      (adr_slw_fall_hi * ratio_a));
        adr_slw_rise = FROMFIXEDPOINT((adr_slw_rise_lo * ratio_b) +
                                      (adr_slw_rise_hi * ratio_a));

        clk_drv_fall = FROMFIXEDPOINT((clk_drv_fall_lo * ratio_b) +
                                      (clk_drv_fall_hi * ratio_a));
        clk_drv_rise = FROMFIXEDPOINT((clk_drv_rise_lo * ratio_b) +
                                      (clk_drv_rise_hi * ratio_a));
        clk_slw_fall = FROMFIXEDPOINT((clk_slw_fall_lo * ratio_b) +
                                      (clk_slw_fall_hi * ratio_a));
        clk_slw_rise = FROMFIXEDPOINT((clk_slw_rise_lo * ratio_b) +
                                      (clk_slw_rise_hi * ratio_a));

        dat_drv_fall = FROMFIXEDPOINT((dat_drv_fall_lo * ratio_b) +
                                      (dat_drv_fall_hi * ratio_a));
        dat_drv_rise = FROMFIXEDPOINT((dat_drv_rise_lo * ratio_b) +
                                      (dat_drv_rise_hi * ratio_a));
        dat_slw_fall = FROMFIXEDPOINT((dat_slw_fall_lo * ratio_b) +
                                      (dat_slw_fall_hi * ratio_a));
        dat_slw_rise = FROMFIXEDPOINT((dat_slw_rise_lo * ratio_b) +
                                      (dat_slw_rise_hi * ratio_a));

        dqs_drv_fall = FROMFIXEDPOINT((dqs_drv_fall_lo * ratio_b) +
                                      (dqs_drv_fall_hi * ratio_a));
        dqs_drv_rise = FROMFIXEDPOINT((dqs_drv_rise_lo * ratio_b) +
                                      (dqs_drv_rise_hi * ratio_a));
        dqs_slw_fall = FROMFIXEDPOINT((dqs_slw_fall_lo * ratio_b) +
                                      (dqs_slw_fall_hi * ratio_a));
        dqs_slw_rise = FROMFIXEDPOINT((dqs_slw_rise_lo * ratio_b) +
                                      (dqs_slw_rise_hi * ratio_a));
    }
    //
    // Interpolation required...
    //
    if (ratio2_a != 0 || ratio2_b != 0)
    {
        dqs_ib_del = FROMFIXEDPOINT((dqs_ib_del_lo * ratio2_b) +
                                    (dqs_ib_del_hi * ratio2_a));
    }

    //
    // Program up the results...
    //
#define SLW_VALUE(r,f) \
    ((r << 28) | (f << 24) | (r << 20) | (f << 16) | \
     (r << 12) | (f << 8)  | (r <<  4) |  f)

    // ADR
    adr_drv = SLW_VALUE(adr_drv_rise, adr_drv_fall);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "  adr_drv: ", adr_drv);
    REG_WR32(NV_PBUS_FBIO_ADRDRV, adr_drv);  
    
    adr_slw = SLW_VALUE(adr_slw_rise, adr_slw_fall);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "  adr_slw: ", adr_slw);
    REG_WR32(NV_PBUS_FBIO_ADRSLW, adr_slw);  

    // CLK
    clk_drv = SLW_VALUE(clk_drv_rise, clk_drv_fall);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "  clk_drv: ", clk_drv);
    REG_WR32(NV_PBUS_FBIO_CLKDRV, clk_drv);  
    
    clk_slw = SLW_VALUE(clk_slw_rise, clk_slw_fall);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "  clk_slw: ", clk_slw);
    REG_WR32(NV_PBUS_FBIO_CLKSLW, clk_slw);  

    // DAT
    dat_drv = SLW_VALUE(dat_drv_rise, dat_drv_fall);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "  dat_drv: ", dat_drv);
    REG_WR32(NV_PBUS_FBIO_DATDRV, dat_drv);  
    
    dat_slw = SLW_VALUE(dat_slw_rise, dat_slw_fall);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "  dat_slw: ", dat_slw);
    REG_WR32(NV_PBUS_FBIO_DATSLW, dat_slw);  

    // DQS
    dqs_drv = SLW_VALUE(dqs_drv_rise, dqs_drv_fall);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "  dqs_drv: ", dqs_drv);
    REG_WR32(NV_PBUS_FBIO_DQSDRV, dqs_drv);  
    
    dqs_slw = SLW_VALUE(dqs_slw_rise, dqs_slw_fall);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "  dqs_slw: ", dqs_slw);
    REG_WR32(NV_PBUS_FBIO_DQSSLW, dqs_slw);  

    dqs_ib = (dqs_ib_del << 29) |(dqs_ib_del << 21) | (dqs_ib_del << 13) | (dqs_ib_del << 5) | 0x18181818;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "  dqs_ib: ", dqs_ib);
    REG_WR32(NV_PBUS_FBIO_DLY, dqs_ib);

    //
    // For A02/A03 chips (XBOX), we're going to up mclk.
    // Note that the we store the clock doubled value in the pHalDev.
    //
    if (IsNV20MaskRevA02_NV20(pHalHwInfo->pMcHalInfo))
    {
        // pDrvSlwParms are in units of MHz/10000
        pHalHwInfo->pDacHalInfo->MClk = 2*pDrvSlwParms->MaxMClk*10000;
        pHalHwInfo->pDacHalInfo->UpdateFlags |= NV_HAL_DAC_UPDATE_MPLL;
    }
    if (IsNV20MaskRevA03_NV20(pHalHwInfo->pMcHalInfo))
    {
        // pDrvSlwParms are in units of MHz/10000
        pHalHwInfo->pDacHalInfo->MClk = 2*pDrvSlwParms->MaxMClk*10000;
        pHalHwInfo->pDacHalInfo->UpdateFlags |= NV_HAL_DAC_UPDATE_MPLL;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\fb\nv10\fbnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ Chip Specific HAL FB Routines ********************\
*                                                                           *
* Module: FBNV10.c                                                          *
*   The NV10 specific HAL FB routines reside in this file.                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include <heap.h>
#include "nvhw.h"
#include "nvhalcpp.h"
#include <bios.h>
#include "cr11help.h"

// forwards
RM_STATUS nvHalFbControl_NV10(VOID *);
RM_STATUS nvHalFbAlloc_NV10(VOID *);
RM_STATUS nvHalFbFree_NV10(VOID *);
RM_STATUS nvHalFbSetAllocParameters_NV10(VOID *);
RM_STATUS nvHalFbGetSurfacePitch_NV10(VOID *);
RM_STATUS nvHalFbGetSurfaceDimensions_NV10(VOID *);
RM_STATUS nvHalFbLoadOverride_NV10(VOID *);

// statics
static VOID nvHalFbRoundTiledPitchSize_NV10(U032 *, U032, U032 *);
static U032 nvHalFbRealMemSize(U032, PHWREG);
static U032 calcChkSum(PHWREG, U032);
static void restoreFbSave(U032 *, PHWREG, U032);

// NV10 expects a 1024 byte alignment
#define FC_MIN_ALIGN_SHIFT      10

//
// nvHalFbControl
//
RM_STATUS
nvHalFbControl_NV10(VOID *arg)
{
    PFBCONTROLARG_000 pFbControlArg = (PFBCONTROLARG_000)arg;
    PMCHALINFO pMcHalInfo;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO pFbHalInfo;
    PPRAMHALINFO pPramHalInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    U032 i;
    U032 test_mem;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbControlArg->id != FB_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbControlArg->pHalHwInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pPramHalInfo = pHalHwInfo->pPramHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;

    switch (pFbControlArg->cmd)
    {
        case FB_CONTROL_INIT:
        {
            U032 extbank, intbank;

            // set ram size
            pFbHalInfo->RamSize = REG_RD32(NV_PFB_CSTATUS);
            pFbHalInfo->RamSizeMb = pFbHalInfo->RamSize / 0x100000;

            //Setup integrated graphics frame buffer
            if ( IsNV1A_NV10(pHalHwInfo->pMcHalInfo) )
            {
                U032    uLastTLBEntry;
                U032    uLastTag;
                U032    uLastAddr;

                U016    wNBVendorID;
                U016    wNBDeviceID;
                VOID    *uNBHandle;
                PHWREG  fbTestFBBase;
                U032    uTestFBRamSize;
                U032    uDIMMConfig;
                U032    uMinDIMMColumnBits;

                uNBHandle = osPciInitHandle(0, 0, 2, &wNBVendorID, &wNBDeviceID);
                if( !uNBHandle )
                {
                    DBG_PRINTF(( DBG_MODULE_GLOBAL, DEBUGLEVEL_ERRORS, "NVRM: Unable to touch integrated graphics\n"));
                    DBG_BREAKPOINT();
                    return (RM_ERROR);
                }

                DBG_PRINTF(( DBG_MODULE_GLOBAL, DEBUGLEVEL_TRACEINFO, "NVRM: North Bridge Vendor=%04x\n", wNBVendorID));
                DBG_PRINTF(( DBG_MODULE_GLOBAL, DEBUGLEVEL_TRACEINFO, "      North Bridge Device=%04x\n", wNBDeviceID));

                //Determine the size of the current frame buffer pre-allocated by the system BIOS
                //Crush11 is a little bit odd in that the instance memory is hard wired to the 31st meg,
                //regardless of the actual frame buffer size.

                //Walk the frame buffer in 1M hops, looking for non-existant memory.
                fbTestFBBase = pHalHwInfo->fbBaseAddr;
                uTestFBRamSize = 32;                    //Look through the whole 32M region
                pFbHalInfo->RamSizeMb = 0;              //The first contiguous chunk is the frame buffer

                while(uTestFBRamSize)
                {
                    test_mem = nvHalFbRealMemSize(uTestFBRamSize, fbTestFBBase);
                    if( test_mem )
                    {
                        DBG_PRINTF(( DBG_MODULE_GLOBAL, DEBUGLEVEL_TRACEINFO, "NVRM: Crush11 FB block@%08x (%dM)\n", fbTestFBBase, test_mem));
                        uTestFBRamSize -= test_mem;
                        if( pFbHalInfo->RamSizeMb==0 )
                        {
                            pFbHalInfo->RamSizeMb = test_mem;
                        }
                        fbTestFBBase += test_mem*1024*1024/sizeof(HWREG);
                    }
                    else
                    {
                        //Bump to the next boundary and try again -- we may be sparsely allocated
                        uTestFBRamSize -= 1;
                        fbTestFBBase += 1*1024*1024/sizeof(HWREG);
                    }
                }

                //Now we know the size of the current frame buffer
                //Try reading CR_XL_FB_TLB_AD to find the last value written.  This should tell us the how many TLB
                //entries have been loaded as well as give us a hint of the starting physical address.
                //Caveat: This only works if no one has been mucking around with the page translation.
                uLastTLBEntry = osPciReadDword(uNBHandle, CR_XL_FB_TLB_AD & 0xFF);
                uLastTag  = CR_DRF_VAL( _XL, _FB_TLB_AD, _TAG, uLastTLBEntry);
                uLastAddr = CR_DRF_VAL( _XL, _FB_TLB_AD, _ADDR, uLastTLBEntry);

                DBG_PRINTF(( DBG_MODULE_GLOBAL, DEBUGLEVEL_TRACEINFO, "NVRM: CR_XL_FB_TLB_AD  =%08x\n", uLastTLBEntry));
                DBG_PRINTF(( DBG_MODULE_GLOBAL, DEBUGLEVEL_TRACEINFO, "                  _TAG =%03x\n", uLastTag));
                DBG_PRINTF(( DBG_MODULE_GLOBAL, DEBUGLEVEL_TRACEINFO, "                  _ADDR=%05x\n", uLastTLBEntry));

                pFbHalInfo->RamSize = pFbHalInfo->RamSizeMb*1024*1024;
                pFbHalInfo->ExtBankCount = 1;
                pFbHalInfo->BankCount = 1;
                pFbHalInfo->RamType = BUFFER_SDRAM;

                // set minimum alignment for tiled surfaces

                // For integrated graphics, we need to check the DIMM configuration to calculate the 
                // tile alignment restriction based on the number of column bits
                uMinDIMMColumnBits = 0xffffffff;
                for( i=0; i<CR_XL_DIMM_CFG__SIZE_1; i++ )
                {
                    uDIMMConfig = osPciReadDword(uNBHandle, CR_XL_DIMM_CFG(i) & 0xFF);
                    DBG_PRINTF(( DBG_MODULE_GLOBAL, DEBUGLEVEL_TRACEINFO, "NVRM: _DIMM_CFG(%d)=%08x\n", i, uDIMMConfig));

                    // Check if the DIMM is present
                    if( uDIMMConfig & CR_DRF_DEF( _XL, _DIMM_CFG, _PRESENT, _TRUE ) )
                    {
                        DBG_PRINTF(( DBG_MODULE_GLOBAL, DEBUGLEVEL_TRACEINFO, "      _PRESENT     =%x\n", CR_DRF_VAL( _XL, _DIMM_CFG, _PRESENT, uDIMMConfig)));
                        DBG_PRINTF(( DBG_MODULE_GLOBAL, DEBUGLEVEL_TRACEINFO, "      _SIZE        =%dM\n", 16*CR_DRF_VAL( _XL, _DIMM_CFG, _SIZE, uDIMMConfig)));
                        DBG_PRINTF(( DBG_MODULE_GLOBAL, DEBUGLEVEL_TRACEINFO, "      _NUM_ROW_BITS=%d\n", 11+CR_DRF_VAL( _XL, _DIMM_CFG, _NUM_ROW_BITS, uDIMMConfig)));
                        DBG_PRINTF(( DBG_MODULE_GLOBAL, DEBUGLEVEL_TRACEINFO, "      _NUM_COL_BITS=%d\n", 8+CR_DRF_VAL( _XL, _DIMM_CFG, _NUM_COL_BITS, uDIMMConfig)));
                        DBG_PRINTF(( DBG_MODULE_GLOBAL, DEBUGLEVEL_TRACEINFO, "      _NUM_EXT_BANKS=%d\n", 1+CR_DRF_VAL( _XL, _DIMM_CFG, _NUM_EXT_BANKS, uDIMMConfig)));

                        //Find the smallest column configuration -- that's the case we need to account for
                        uMinDIMMColumnBits = min( CR_DRF_VAL(  _XL, _DIMM_CFG, _NUM_COL_BITS, uDIMMConfig ), uMinDIMMColumnBits );
                    }
                }

                // Now figure out the alignment.  The tiling registers have a minimum granularity of 16K.
                // But the column bits might require 32K (10 bits) or 64K (11 bits).
                pFbHalPvtInfo->uTileAlign = max( DRF_NUM( _PGRAPH, _TILE, _ADR,1 ), 32 << (8+uMinDIMMColumnBits))-1;

            }
            else
            {

                // set bank count
                extbank = REG_RD_DRF(_PFB, _CFG, _EXTBANK);
                intbank = REG_RD_DRF(_PFB, _CFG, _BANK);

                // record number of external banks
                if (extbank == NV_PFB_CFG_EXTBANK_1)
                    pFbHalInfo->ExtBankCount = 2;
                else
                    pFbHalInfo->ExtBankCount = 1;

                // set heap manager bank count
                if (extbank && intbank)
                    pFbHalInfo->BankCount = 4;
                else if ((extbank && !intbank) || (!extbank && intbank))
                    pFbHalInfo->BankCount = 2;
                else
                    pFbHalInfo->BankCount = 1;

                // save off chip-dependent fb state
                pFbHalPvtInfo->fbSave[0] = REG_RD32(NV_PFB_CFG);

                // set ram type
                if (REG_RD_DRF(_PFB, _CFG, _TYPE) == NV_PFB_CFG_TYPE_SDR)
                    pFbHalInfo->RamType = BUFFER_SDRAM;
                else
                    pFbHalInfo->RamType = BUFFER_DDRAM;

                // set minimum alignment for tiled surfaces
                pFbHalPvtInfo->uTileAlign = DRF_NUM( _PGRAPH, _TILE, _ADR,1 )-1;
            }


            //CAH:Actually step through memory to verify we have as much there as the BIOS is 
            //telling us. On some "gray" market boards they may be strapped to report 
            //double the actual physical memory.This test will step through the framebuffer
            //to determine if it's actually there.
            test_mem = nvHalFbRealMemSize(pFbHalInfo->RamSizeMb, pHalHwInfo->fbBaseAddr);

            //
            // Make sure the NV11 and NV15 are not specifying more than 64MB of memory
            //
            if ( IsNV11_NV10(pMcHalInfo) || IsNV15_NV10(pMcHalInfo) )
            {
                if (test_mem > 64) 
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NV11 or NV15 with more than 64MB detected\n\r");
                    return (RM_ERROR);
                }
            }

            if (pFbHalInfo->RamSizeMb != test_mem) 
            {

                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: RamSize incorrectly read from BIOS\n\r");
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Resetting RamSize from Memory Test\n\r");
                return (RM_ERROR);
            }

            //
            // Set instance space size.  Add in whatever os-dependent
            // (i.e. BIOS) space is needed as well.
            //
            // For NV10, this is 128K allocatable.
            //
#ifdef KDA_BUFFER_ENABLED
            // LPL: test purposes, bump to 256K (back to 128 now)
            pPramHalInfo->TotalInstSize = 0x20000 + pPramHalInfo->InstPadSize;
#else
            pPramHalInfo->TotalInstSize = 0x20000 + pPramHalInfo->InstPadSize;
#endif
            //
            // Configure hash table.
            //
            pFbHalPvtInfo->hashTableSize = 0x4000;
            pPramHalInfo->HashDepth = pFbHalPvtInfo->hashTableSize / sizeof (HASH_TABLE_ENTRY);
            pPramHalInfo->HashSearch = 128;
            pFbHalPvtInfo->hashTableAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize;
            REG_WR32(NV_PFIFO_RAMHT, (DRF_DEF(_PFIFO, _RAMHT, _SIZE, _16K) |
                                      DRF_NUM(_PFIFO, _RAMHT, _BASE_ADDRESS, (pFbHalPvtInfo->hashTableAddr - DEVICE_BASE(NV_PRAMIN)) >> 12) |
                                      DRF_DEF(_PFIFO, _RAMHT, _SEARCH, _128)));

            //
            // Configure fifo context area.
            //
            pFbHalPvtInfo->fifoContextSize = NUM_FIFOS_NV10 * FC_SIZE_NV10;
            pFbHalPvtInfo->fifoContextAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize + pFbHalPvtInfo->hashTableSize;
            REG_WR_DRF_NUM(_PFIFO, _RAMFC, _BASE_ADDRESS, ((pFbHalPvtInfo->fifoContextAddr - DEVICE_BASE(NV_PRAMIN)) >> FC_MIN_ALIGN_SHIFT));

            //
            // Configure runout area.
            //
            pFbHalPvtInfo->fifoRunoutSize = 512;
            pFbHalPvtInfo->fifoRunoutAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize +
                pFbHalPvtInfo->hashTableSize + pFbHalPvtInfo->fifoContextSize;
            pFbHalPvtInfo->fifoRunoutMask = pFbHalPvtInfo->fifoRunoutSize - 1;
            REG_WR32(NV_PFIFO_RAMRO, (DRF_DEF(_PFIFO, _RAMRO, _SIZE, _512) |
                                      DRF_NUM(_PFIFO, _RAMRO, _BASE_ADDRESS, (pFbHalPvtInfo->fifoRunoutAddr - DEVICE_BASE(NV_PRAMIN)) >> 9)));

            //
            // Sum of all allocations plus a little slop
            //
            pPramHalInfo->CurrentSize  = pFbHalPvtInfo->hashTableSize + pFbHalPvtInfo->fifoContextSize + pFbHalPvtInfo->fifoRunoutSize + 512;

            break;
        }
        case FB_CONTROL_LOAD:
            break;
        case FB_CONTROL_UNLOAD:
            break;
        case FB_CONTROL_UPDATE:
            break;
        case FB_CONTROL_DESTROY:
            REG_WR32(NV_PFB_CFG, pFbHalPvtInfo->fbSave[0]);
            break;
        case FB_CONTROL_INSTWR_DISABLE:
            // disable writes by enabling  protection
            switch (pPramHalInfo->TotalInstSize)
            {
                case 0x30000:
                    FLD_WR_DRF_DEF(_PFB, _NVM, _LIMIT, _192K);
                    break;
                case 0x20000:
                default:
                    FLD_WR_DRF_DEF(_PFB, _NVM, _LIMIT, _128K);
                    break;
            }
            FLD_WR_DRF_DEF(_PFB, _NVM, _MODE, _ENABLE);
            break;
        case FB_CONTROL_INSTWR_ENABLE:
            // enable writes by disabling write protection
            FLD_WR_DRF_DEF(_PFB, _NVM, _MODE, _DISABLE);
            break;
        case FB_CONTROL_TILING_DISABLE:
            //
            // Check for integrated graphics -- we need to setup tiling through the north bridge
            //
            if( IsNV1A_NV10(pHalHwInfo->pMcHalInfo) )
            {
                Nv1AInvalidateTile( pHalHwInfo, 0, 8 );
            }
            else
            {
                HAL_GR_IDLE(pHalHwInfo);
                for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
                {
                    REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
                    REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);
                }
            }
            break;
        case FB_CONTROL_TILING_ENABLE:
            // this is treated as an error on nv10 (???)
            return (RM_ERR_BAD_ARGUMENT);
        case FB_CONTROL_TILING_CONFIGURE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalFbGetSurfacePitch
//
// Given a width and bits per pixel, return the surface pitch
//
RM_STATUS
nvHalFbGetSurfacePitch_NV10(VOID *arg)
{
    PFBGETSURFACEPITCHARG_000 pGetSurfacePitchArg = (PFBGETSURFACEPITCHARG_000)arg;
    
    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pGetSurfacePitchArg->id != FB_GET_SURFACE_PITCH_000)
        return (RM_ERR_VERSION_MISMATCH);

    // surfaces are (at least) 64byte aligned
    // Watch out for bpp==15: add 1 here to force 15 to 16 for the shift
    pGetSurfacePitchArg->pitch = ((pGetSurfacePitchArg->width * ((pGetSurfacePitchArg->bpp+1) >> 3)) + 0x3F) & ~0x3F;

    if (pGetSurfacePitchArg->flags & FB_GET_SURFACE_PITCH_NO_ADJUST)
        return RM_OK;

    if (!(pGetSurfacePitchArg->flags & FB_GET_SURFACE_PITCH_NO_ADJUST))
    {
        nvHalFbRoundTiledPitchSize_NV10(&pGetSurfacePitchArg->pitch, NULL, NULL);
    }
    return RM_OK;
}

//
// nvHalFbGetSurfaceDimensions
//
// Given a width/height and bits per pixel, return the surface pitch and size
//
RM_STATUS
nvHalFbGetSurfaceDimensions_NV10(VOID *arg)
{
    PFBGETSURFACEDIMENSIONSARG_000 pGetSurfaceDimensionsArg = (PFBGETSURFACEDIMENSIONSARG_000)arg;
    
    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pGetSurfaceDimensionsArg->id != FB_GET_SURFACE_DIMENSIONS_000)
        return (RM_ERR_VERSION_MISMATCH);

    // surfaces are (at least) 64byte aligned
    // Watch out for bpp==15: add 1 here to force 15 to 16 for the shift
    pGetSurfaceDimensionsArg->pitch = ((pGetSurfaceDimensionsArg->width * ((pGetSurfaceDimensionsArg->bpp+1) >> 3)) + 0x3F) & ~0x3F;
    pGetSurfaceDimensionsArg->size  = pGetSurfaceDimensionsArg->pitch * pGetSurfaceDimensionsArg->height;
        
    if (!(pGetSurfaceDimensionsArg->flags & FB_GET_SURFACE_PITCH_NO_ADJUST))
    {
        nvHalFbRoundTiledPitchSize_NV10(&pGetSurfaceDimensionsArg->pitch,
                                        pGetSurfaceDimensionsArg->height,
                                        &pGetSurfaceDimensionsArg->size);
    }
    return RM_OK;
}

static VOID
nvHalFbRoundTiledPitchSize_NV10(U032 *pitch, U032 height, U032 *size)
{
    // adjust the pitch, if necessary
    if (*pitch <= 0x200)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0200);
    else if (*pitch <= 0x400)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0400);
    else if (*pitch <= 0x600)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0600);
    else if (*pitch <= 0x800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0800);
    else if (*pitch <= 0xA00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0A00);
    else if (*pitch <= 0xC00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0C00);
    else if (*pitch <= 0xE00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0E00);
    else if (*pitch <= 0x1000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1000);
    else if (*pitch <= 0x1400)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1400);
    else if (*pitch <= 0x1800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1800);
    else if (*pitch <= 0x1C00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1C00);
    else if (*pitch <= 0x2000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _2000);
    else if (*pitch <= 0x2800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _2800);
    else if (*pitch <= 0x3000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _3000);
    else if (*pitch <= 0x3800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _3800);
    else if (*pitch <= 0x4000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _4000);
    else if (*pitch <= 0x5000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _5000);
    else if (*pitch <= 0x6000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _6000);
    else if (*pitch <= 0x7000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _7000);
    else if (*pitch <= 0x8000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _8000);
    else if (*pitch <= 0xA000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _A000);
    else if (*pitch <= 0xC000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _C000);
    else
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _E000);

    if (size) {
        U032 hzmult;

        // set size given possibly adjusted pitch
        *size = *pitch * height;

        //
        // Round size to an even multiple of horizontal tiles. Remapping occurs
        // within addresses of length (pitch * tile_height * 2) in the vertical
        // direction (where the max TILE_HEIGHT is 16 lines).
        //
        hzmult = *pitch * (16 * 2);
        *size = ((*size + (hzmult - 1)) / hzmult) * hzmult;
    }
}

//
// Before updating the tiling registers (in particular, the PGRAPH version),
// idle graphics as best as possible.
//
// If we're not GR_IDLE during these writes to the PGRAPH registers, these
// writes can be dropped leaving the PFB and PGRAPH regs inconsistent. The
// idle/resume routines are called during FreeTiledRange/ProgramTiledRange.
//
static VOID
nvHalTilingUpdateIdle_NV10
(
    PHALHWINFO pHalHwInfo,
    U032       *pDmaCaches,
    U032       *pDmaPush
)
{
    *pDmaCaches = REG_RD32(NV_PFIFO_CACHES);
    FLD_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
    
    // Empty FIFO and runout.
    while ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) != NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
        || (REG_RD_DRF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK) != NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY)
        || (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY))
    {
        // Make sure we process any fifo interrupts
        HALRMSERVICEINTR(pHalHwInfo, FIFO_ENGINE_TAG);

        // Check if GE needs servicing.
        if (REG_RD32(NV_PGRAPH_INTR))
            HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);

        // Check if vblank needs servicing.
        if (REG_RD32(NV_PMC_INTR_0) & (DRF_DEF(_PMC, _INTR_0, _PCRTC,  _PENDING) |
                                       DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING)))
            HALRMSERVICEINTR(pHalHwInfo, DAC_ENGINE_TAG);
    }

    // Disable the dma pusher
    *pDmaPush = REG_RD32(NV_PFIFO_CACHE1_DMA_PUSH);
    FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);

    // Wait until the DMA pusher is idle
    while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
        ;
}

static VOID
nvHalTilingUpdateResume_NV10
(
    PHALHWINFO pHalHwInfo,
    U032       DmaCaches,
    U032       DmaPush
)
{
    // Restore the dma pusher state
    REG_WR32(NV_PFIFO_CACHE1_DMA_PUSH, DmaPush);

    // Restore the reassign state
    REG_WR32(NV_PFIFO_CACHES, DmaCaches);
}

//
// nvHalFbAlloc
//
// Update user alloc request parameter according to memory
// type and (possibly) reserve hw resources.
//
RM_STATUS
nvHalFbAlloc_NV10(VOID *arg)
{
    PFBALLOCARG_000 pFbAllocArg = (PFBALLOCARG_000)arg;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    PFBALLOCINFO pFbAllocInfo;
    U032 i, pitch, size;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbAllocArg->id != FB_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pFbHalPvtInfo = (PFBHALINFO_NV10)pFbAllocArg->pHalHwInfo->pFbHalPvtInfo;
    pFbAllocInfo = pFbAllocArg->pAllocInfo;
    
    // Set default alignment based on type.
    switch (pFbAllocInfo->type) {
    case MEM_TYPE_IMAGE:
    case MEM_TYPE_OVERLAY:
        pFbAllocInfo->align = 0x3f;         // 64 byte alignment
        break;
    case MEM_TYPE_TEXTURE:
        pFbAllocInfo->align = 0xff;         // 256 byte alignment
        break;
    case MEM_TYPE_FONT:
        pFbAllocInfo->align = 0x1f;         // 32 byte alignment
        break;
    case MEM_TYPE_CURSOR:
        pFbAllocInfo->align = 0x7ff;        // 2048 byte alignment
        break;
    case MEM_TYPE_DMA:
        pFbAllocInfo->align = 0x3;          // 4 byte alignment
        break;
    case MEM_TYPE_INSTANCE:
        pFbAllocInfo->align = 0xf;          // 16 byte alignment
        break;
    case MEM_TYPE_DEPTH:
    case MEM_TYPE_DEPTH_COMPR16:
    case MEM_TYPE_DEPTH_COMPR32:
    case MEM_TYPE_PRIMARY:
    case MEM_TYPE_IMAGE_TILED:
        pFbAllocInfo->align = 0xfff;        // 4096 byte alignment
        break;
    default:
        // should this be 0xffffffff
        pFbAllocInfo->align = pFbAllocInfo->alignPerf = 0;
        return (RM_ERR_BAD_ARGUMENT);
    }


    //
    // A non-zero pitch value indicates the user wants tiled memory
    // (if available).  If the pitch is 0, we're done.
    //
    if (pFbAllocInfo->pitch == 0)
    {
        pFbAllocInfo->alignPerf = pFbAllocInfo->align;
        return (RM_OK);
    }
        
    // Now allocate a TILE_RANGE
    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
    {
        if ((pFbHalPvtInfo->usedTiles & MEM_TYPE_TILE_RANGE_SHIFT(i)) == 0)
        {
            pFbHalPvtInfo->usedTiles |= MEM_TYPE_TILE_RANGE_SHIFT(i);
            break;
        }
    }
    if (i == NV_PFB_TILE__SIZE_1)
    {
        return (RM_ERR_INSUFFICIENT_RESOURCES);
    }

    pitch = pFbAllocInfo->pitch;
    nvHalFbRoundTiledPitchSize_NV10(&pitch,
                                    pFbAllocInfo->height,
                                    &size);

    //
    // If we're not allowing the pitch to be adjusted, we can only tile the surface
    // if the pitch is already HW aligned.
    // 
    if ((pFbAllocArg->flags & FB_ALLOC_NO_PITCH_ADJUST) && (pitch != pFbAllocInfo->pitch))
    {
        // requires rounding, so give back the range and fail the alloc
        pFbHalPvtInfo->usedTiles &= ~MEM_TYPE_TILE_RANGE_SHIFT(i);
        pFbAllocInfo->hwResId = 0;
        return (RM_OK);
    }

    // tiles are _typically_ 16K aligned.
    pFbAllocInfo->align = pFbAllocInfo->alignPerf = pFbHalPvtInfo->uTileAlign;

    // return adjusted pitch and size
    pFbAllocInfo->pitch = pitch;
    pFbAllocInfo->size  = size;

    pFbAllocInfo->hwResId = MEM_TYPE_TILE_RANGE_SHIFT(i);
    return (RM_OK);
}

//
// nvHalFbFree
//
// Release tile back to the free pool.
//
RM_STATUS
nvHalFbFree_NV10(VOID *arg)
{
    PFBFREEARG_000 pFbFreeArg = (PFBFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    U032 i, dmapush, dmacaches;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbFreeArg->id != FB_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbFreeArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pFbFreeArg->pHalHwInfo->pFbHalPvtInfo;

    //
    // Bail out now if there's no resource id.
    if (!pFbFreeArg->hwResId)
        return (RM_OK);

    // convert range bits to a TILE index
    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
        if (pFbFreeArg->hwResId & MEM_TYPE_TILE_RANGE_SHIFT(i))
                break;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Freeing TILE Range:   ", i);

    //
    // It's possible for us to be freeing a tiled region after we've
    // disable PCI accesses to our chip (i.e. we get here after
    // we've gone through MC_POWER_LEVEL_2).
    // 
    // Before touching the hw, make sure the device is enabled.
    //
    if (REG_RD32(NV_PMC_BOOT_0) == 0xffffffff)
    {
        // mark it free
        pFbHalPvtInfo->usedTiles &= ~pFbFreeArg->hwResId;
        return (RM_OK);
    }

    // idle graphics, so we can update the PGRAPH registers
    nvHalTilingUpdateIdle_NV10(pFbFreeArg->pHalHwInfo, &dmacaches, &dmapush);

    //
    // Check for integrated graphics -- we need to setup tiling through the north bridge
    //
    if( IsNV1A_NV10(pHalHwInfo->pMcHalInfo) )
    {
        Nv1AInvalidateTile( pHalHwInfo, i, 1 );
    }
    else
    {
        do {
            // Now, wait until graphics is idle
            HAL_GR_IDLE(pFbFreeArg->pHalHwInfo);

            // invalidate the range
            REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
            REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);    

        } while (REG_RD32(NV_PFB_TILE(i)) != REG_RD32(NV_PGRAPH_TILE(i)));
    }

    // resume graphics, now that PFB/PGRAPH are consistent
    nvHalTilingUpdateResume_NV10(pHalHwInfo, dmacaches, dmapush);

    // mark it free
    pFbHalPvtInfo->usedTiles &= ~pFbFreeArg->hwResId;

    return (RM_OK);
}

//
// nvHalFbSetAllocParameters
//
// Associate memory block (base/limit) with hardware resources.
//
RM_STATUS
nvHalFbSetAllocParameters_NV10(VOID *arg)
{
    PFBSETALLOCPARAMSARG_000 pFbSetAllocParamsArg = (PFBSETALLOCPARAMSARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    PFBALLOCINFO pFbAllocInfo;
    U032 i, dmapush, dmacaches;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbSetAllocParamsArg->id != FB_SET_ALLOC_PARAMS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbSetAllocParamsArg->pHalHwInfo;
    pFbAllocInfo = pFbSetAllocParamsArg->pAllocInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pFbSetAllocParamsArg->pHalHwInfo->pFbHalPvtInfo;

    //
    // Bail out if this allocation didn't reserve any tiling regs.
    //
    if (pFbAllocInfo->hwResId == 0)
        return (RM_OK);

    //
    // Convert range bits to a TILE index.
    //
    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
        if (pFbAllocInfo->hwResId == (U032)MEM_TYPE_TILE_RANGE_SHIFT(i))
            break;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Programming TILE Range:   ", i);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:          Base =   ", pFbAllocInfo->offset);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:         Limit =   ", pFbAllocInfo->offset + (pFbAllocInfo->size - 1));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:         Pitch =   ", pFbAllocInfo->pitch);

    if (pFbAllocInfo->offset & 0x3fff)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Error: unaligned Base\n");
        // mark it free
        pFbHalPvtInfo->usedTiles &= ~pFbAllocInfo->hwResId;
        // invalidate the range
        //
        // Check for integrated graphics -- we need to setup tiling through the north bridge
        //
        if( IsNV1A_NV10(pHalHwInfo->pMcHalInfo) )
        {
            Nv1AInvalidateTile( pHalHwInfo, i, 1 );
        }
        else
        {
            REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
            REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);    
        }
        return (RM_OK);
    }
    if (pFbAllocInfo->size & 0x3fff)
    {
        // mark it free
        pFbHalPvtInfo->usedTiles &= ~pFbAllocInfo->hwResId;
        // invalidate the range
        //
        // Check for integrated graphics -- we need to setup tiling through the north bridge
        //
        if( IsNV1A_NV10(pHalHwInfo->pMcHalInfo) )
        {
            Nv1AInvalidateTile( pHalHwInfo, i, 1 );
        }
        else
        {
            REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
            REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);    
        }
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Error: unaligned Limit\n");
        return (RM_OK);
    }

    // idle graphics, so we can update the PGRAPH registers
    nvHalTilingUpdateIdle_NV10(pFbSetAllocParamsArg->pHalHwInfo, &dmacaches, &dmapush);

    //
    // Note: due to a PFB_TLIMIT readback bug, only compare the upper bits
    // when checking for PFB_TLIMIT/PGRAPH_TLIMIT consistency.
    // 

    //
    // Check for integrated graphics -- we need to setup tiling through the north bridge
    //
    if( IsNV1A_NV10(pHalHwInfo->pMcHalInfo) )
    {
        //North bridge integrated graphics has a different tile setup
        U016    wNBVendorID;
        U016    wNBDeviceID;
        VOID    *uNBHandle = 0;
        U032    uNBFakeTLIMIT;
        U032    uNBFakeTSIZE;
        U032    uNBFakeTILE;

        uNBHandle = osPciInitHandle(0, 0, 2, &wNBVendorID, &wNBDeviceID);
        if( !uNBHandle )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Unable to touch integrated graphics tiling\n");
            DBG_BREAKPOINT();
            return (RM_ERROR);
        }

        do {
            U032    uNBTBASE  = WriteNBTBASE(pFbAllocInfo->pitch, pFbAllocInfo->offset, pFbAllocInfo->size, 1);
            U032    uNBTLIMIT = WriteNBTLIMIT(pFbAllocInfo->pitch, pFbAllocInfo->offset, pFbAllocInfo->size, 1);

            // Now, wait until graphics is idle
            HAL_GR_IDLE(pHalHwInfo);

            osPciWriteDword(uNBHandle, CR_XL_TBASE(i)  & 0xFF, uNBTBASE );
            osPciWriteDword(uNBHandle, CR_XL_TLIMIT(i) & 0xFF, uNBTLIMIT );

            REG_WR32(NV_PGRAPH_TLIMIT(i), pFbAllocInfo->offset + pFbAllocInfo->size - 1);
            REG_WR32(NV_PGRAPH_TSIZE(i), pFbAllocInfo->pitch);
            REG_WR32(NV_PGRAPH_TILE(i), pFbAllocInfo->offset | DRF_DEF(_PFB, _TILE, _REGION, _VALID));

            uNBTBASE  = osPciReadDword(uNBHandle, CR_XL_TBASE(i)  & 0xFF );
            uNBTLIMIT = osPciReadDword(uNBHandle, CR_XL_TLIMIT(i) & 0xFF );

            uNBFakeTLIMIT = FormatPFBTLimit( ReadNBPitch( uNBTBASE, uNBTLIMIT ), ReadNBOffset( uNBTBASE, uNBTLIMIT ), ReadNBSize( uNBTBASE, uNBTLIMIT ), ReadNBValid( uNBTBASE, uNBTLIMIT ) );
            uNBFakeTSIZE  = FormatPFBTSize ( ReadNBPitch( uNBTBASE, uNBTLIMIT ), ReadNBOffset( uNBTBASE, uNBTLIMIT ), ReadNBSize( uNBTBASE, uNBTLIMIT ), ReadNBValid( uNBTBASE, uNBTLIMIT ) );
            uNBFakeTILE   = FormatPFBTile  ( ReadNBPitch( uNBTBASE, uNBTLIMIT ), ReadNBOffset( uNBTBASE, uNBTLIMIT ), ReadNBSize( uNBTBASE, uNBTLIMIT ), ReadNBValid( uNBTBASE, uNBTLIMIT ) );

        } while ((uNBFakeTILE != REG_RD32(NV_PGRAPH_TILE(i))) ||
                 (uNBFakeTSIZE != REG_RD32(NV_PGRAPH_TSIZE(i))) ||
                 ((uNBFakeTLIMIT & ~0x3FFF) != (REG_RD32(NV_PGRAPH_TLIMIT(i)) & ~0x3FFF)));
    }
    else
    {
        do {
            // Now, wait until graphics is idle
            HAL_GR_IDLE(pHalHwInfo);

            REG_WR32(NV_PFB_TLIMIT(i), pFbAllocInfo->offset + pFbAllocInfo->size - 1);
            REG_WR32(NV_PFB_TSIZE(i), pFbAllocInfo->pitch);
            REG_WR32(NV_PFB_TILE(i), pFbAllocInfo->offset | DRF_DEF(_PFB, _TILE, _REGION, _VALID));

            REG_WR32(NV_PGRAPH_TLIMIT(i), pFbAllocInfo->offset + pFbAllocInfo->size - 1);
            REG_WR32(NV_PGRAPH_TSIZE(i), pFbAllocInfo->pitch);
            REG_WR32(NV_PGRAPH_TILE(i), pFbAllocInfo->offset | DRF_DEF(_PFB, _TILE, _REGION, _VALID));

        } while ((REG_RD32(NV_PFB_TILE(i)) != REG_RD32(NV_PGRAPH_TILE(i))) ||
                 (REG_RD32(NV_PFB_TSIZE(i)) != REG_RD32(NV_PGRAPH_TSIZE(i))) ||
                 ((REG_RD32(NV_PFB_TLIMIT(i)) & ~0x3FFF) != (REG_RD32(NV_PGRAPH_TLIMIT(i)) & ~0x3FFF)));
    }

    // resume graphics, now that PFB/PGRAPH are consistent
    nvHalTilingUpdateResume_NV10(pHalHwInfo, dmacaches, dmapush);

    return (RM_OK);
}

RM_STATUS
nvHalFbLoadOverride_NV10(VOID *arg)
{
    PFBLOADOVERRIDEARG_000 pFbLoadOverrideArg = (PFBLOADOVERRIDEARG_000)arg;
    PHALHWINFO pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pFbLoadOverrideArg->id != FB_LOAD_OVERRIDE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbLoadOverrideArg->pHalHwInfo;

    switch (pFbLoadOverrideArg->cmd)
    {
        case FB_LOAD_OVERRIDE_MEMORY:
            REG_WR32(NV_PFB_CFG, pFbLoadOverrideArg->value);
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}


//CAH: Setup to detect possible alliasing of memory to tell us we have double
//the memory that we actually do. This algorithm will detect the case where
//memory addresses lay on top of eachother so as to make it appear that there
//is twice the memory available than is physically present. 
static U032 nvHalFbRealMemSize(U032 RamSizeMb, PHWREG base)
{
    U032 i, wp = 0;
    U032 checksum1 = 0, checksum2 = 0;
    U032 fb_save[128]; 
    U032 uTag;

    //Write 0,1,2,3,...N on each 1mb boundry in the FB
    for (i = 0, wp = 0; i < RamSizeMb; i++, wp += 0x00100000) 
    {
        fb_save[i] = base->Reg032[wp/4];
        uTag = 0x01010101*(i+1);  //Write a more interesting pattern - 0 is too easy to mistake
        base->Reg032[wp/4] = uTag;
        checksum1 += uTag;
        checksum2 = calcChkSum(base, i);
        if (checksum1 != checksum2)
        {
            restoreFbSave(fb_save, base, i);
            return i; 
        }
    }

    restoreFbSave(fb_save, base, --i);
    return RamSizeMb; //This means we made it all the way through memory.
}

static void restoreFbSave(U032 *save, PHWREG base, U032 index)
{
    U032 i, wp;

    for (i = 0, wp = 0; i <= index; i++, wp += 0x00100000)
    {
        base->Reg032[wp/4] = save[i];
    }
}

static U032 calcChkSum(PHWREG base, U032 index)
{
    U032 i, wp, checksum = 0;

    for (i = 0, wp = 0; i <= index; i++, wp += 0x00100000)
    {
        checksum += base->Reg032[wp/4];
    }

    return checksum;
}

//
// For North bridge integrated graphics, part of the tiling control is in the north bridge
// We need to clear it via PCI config space
//

VOID Nv1AInvalidateTile( PHALHWINFO pHalHwInfo, U032 uStart, U032 uCount )

{
    //North bridge integrated graphics has a different tile setup
    U016    wNBVendorID;
    U016    wNBDeviceID;
    VOID    *uNBHandle = 0;
    U032    i;

    uNBHandle = osPciInitHandle(0, 0, 2, &wNBVendorID, &wNBDeviceID);
    if( !uNBHandle )
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Unable to touch integrated graphics tiling\n");
        DBG_BREAKPOINT();
        return;
    }

    for( i=uStart; uCount>0; uCount--, i++ )
    {
        do {
            // Now, wait until graphics is idle
            HAL_GR_IDLE(pHalHwInfo);

            REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);    
            osPciWriteDword(uNBHandle, CR_XL_TBASE(i) & 0xFF, CR_XL_TBASE_REGION_INVALID );

        } while (osPciReadDword(uNBHandle, CR_XL_TBASE(i)  & 0xFF ) != REG_RD32(NV_PGRAPH_TILE(i)));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\fifo\nv\fifoinit.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** FIFO Manager *******************************\
*                                                                           *
* Module: FIFOINIT.C                                                        *
*   The FIFO is initialized in this module.  This is a one time occurance   *
*   and then the module is unloaded.                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <fifo.h>
#include <os.h>
#include "nvhw.h"


//
// Initialize FIFO data structures and hardware.
//
RM_STATUS initFifo
(
    PHWINFO pDev
)
{
    U032 i;
    
    //
    // Initilialize all global FIFO variables.
    //
    pDev->Fifo.HalInfo.AllocateCount    = 0;
    pDev->Fifo.UpdateFlags              = 0;

    //
    // Allocate FIFO table.
    //
    if (osAllocMem((VOID **)&pDev->DBfifoTable, sizeof(FIFO) * NUM_FIFOS) != RM_OK)
        return (RM_ERR_NO_FREE_MEM);
    for (i = 0; i < NUM_FIFOS; i++)
    {
        pDev->DBfifoTable[i].InUse = FALSE;
        pDev->DBfifoTable[i].ChID  = i;
        pDev->DBfifoTable[i].CacheDepth = 512;
    }

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\fifo\nv10\fifonv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************* Chip Specific HAL FIFO Routines *********************\
*                                                                           *
* Module: FIFONV10.C                                                        *
*   The NV10 specific HAL FIFO routines reside in this file.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalFifoControl_NV10(VOID *);
RM_STATUS nvHalFifoAllocPio_NV10(VOID *);
RM_STATUS nvHalFifoAllocDma_NV10(VOID *);
RM_STATUS nvHalFifoFree_NV10(VOID *);
RM_STATUS nvHalFifoGetExceptionData_NV10(VOID *);
RM_STATUS nvHalFifoService_NV10(VOID *);
RM_STATUS nvHalFifoAccess_NV10(VOID *);
RM_STATUS nvHalFifoHashAdd_NV10(VOID *);
RM_STATUS nvHalFifoHashDelete_NV10(VOID *);
RM_STATUS nvHalFifoHashFunc_NV10(VOID *);

// The context switch interface is only used internally, but perhaps
// should be made available to the resource manager anyway.
static RM_STATUS nvHalFifoContextSwitch_NV10(PHALHWINFO, U032);

static U032 nvHalFifoCalcDmaFetch_NV10(U032, U032, U032);

#ifdef TRAP_HOST_FIFO_SWITCHES
U032 do_fifo_switch = 0;
U032 dma_inst[NUM_FIFOS_NV10];
#endif

RM_STATUS
nvHalFifoControl_NV10(VOID *arg)
{
    PFIFOCONTROLARG_000 pFifoControlArg = (PFIFOCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV10 pFifoHalPvtInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoControlArg->id != FIFO_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoControlArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV10)pHalHwInfo->pFifoHalPvtInfo;

    switch (pFifoControlArg->cmd) {
        case FIFO_CONTROL_INIT:
            //
            // Setup default parameters. 
            //
            pFifoHalInfo->RetryCount = 255;
            pFifoHalInfo->UserBase = DEVICE_BASE(NV_USER);
            pFifoHalPvtInfo->Mode = 0;
            pFifoHalPvtInfo->InUse = 0;

            //
            // Setup interrupt enable mask.
            //
            pFifoHalInfo->IntrEn0 =
                DRF_DEF(_PFIFO, _INTR_EN_0, _CACHE_ERROR, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _RUNOUT, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _RUNOUT_OVERFLOW, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _DMA_PUSHER, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _DMA_PT, _ENABLED);

            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);
            //
            // Zero DMA FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, 0);
            //
            // Zero FIFO hash valid.
            //
            REG_WR32(NV_PFIFO_CACHE0_HASH, 0);
            REG_WR32(NV_PFIFO_CACHE1_HASH, 0);
            //
            // Zero engine assignments
            //
            //REG_WR32(NV_PFIFO_CACHE0_ENGINE, 0);
            //REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
            //
            // Make all FIFO's default
            //
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
            REG_WR32(NV_PFIFO_DMA, 0);
            REG_WR32(NV_PFIFO_SIZE, 0);
            //
            // Clear all pusher state
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
            //
            // Zero run-out pointers.
            //
            REG_WR_DRF_NUM(_PFIFO, _RUNOUT_PUT, _ADDRESS, 0);
            REG_WR_DRF_NUM(_PFIFO, _RUNOUT_GET, _ADDRESS, 0);
            break;
        case FIFO_CONTROL_LOAD:
            //
            // Update the dma fetch numbers using reasonable defaults.
            // We don't need to worry about the endianness bit here
            // because we're going to swap this channel out asap
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, _128_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, _32_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, _15));

            //
            // Enable default timeslicing
            //    
            REG_WR32(NV_PFIFO_DMA_TIMESLICE, 
                     DRF_DEF(_PFIFO, _DMA_TIMESLICE, _TIMEOUT, _ENABLED)
                     | DRF_DEF(_PFIFO, _DMA_TIMESLICE, _SELECT, _128K));
            
            //
            // Set retry delay to match common hardware latency.
            //
            REG_WR_DRF_NUM(_PFIFO, _DELAY_0, _WAIT_RETRY, pFifoHalInfo->RetryCount);
            //
            // Disable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            //
            // Disable pusher and puller access to cache0.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PULL0, _ACCESS, _DISABLED);
            //
            // Disable pusher and puller access to cache1.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(3, 0, 0);
            //
            // Disable the pusher, if active
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);
            
            //
            // Force a context switch to PRAMIN.
            //
            // KJK This should be replaced with a full software-based context switch
            //
            nvHalFifoContextSwitch_NV10(pHalHwInfo, (NUM_FIFOS_NV10 - 1));
            
            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);

            //
            // Enable pusher and puller access to cache1.
            //
            FIFOLOG(3, 1, 0);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _ENABLED);
            //
            // Delay for slow CACHE1_PULL.
            //
            //temp = REG_RD32(NV_PFIFO_CACHE1_PULL0);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _ENABLED);
            //
            // Enable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _ENABLED);
            break;
        case FIFO_CONTROL_UNLOAD:
            //
            // Disable dma timeslicing
            //    
            REG_WR32(NV_PFIFO_DMA_TIMESLICE, DRF_DEF(_PFIFO, _DMA_TIMESLICE, _TIMEOUT, _DISABLED));

            //
            // Empty FIFO and runout.
            //
            while ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) != NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
                   || (REG_RD_DRF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK) != NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY)
                   || (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY))
            {
                //
                // Make sure we process any fifo interrupts
                //
                HALRMSERVICEINTR(pFifoControlArg->pHalHwInfo, FIFO_ENGINE_TAG);
                
                //
                // Check if GE needs servicing.
                //
                if (REG_RD32(NV_PGRAPH_INTR))
                    HALRMSERVICEINTR(pFifoControlArg->pHalHwInfo, GR_ENGINE_TAG);

                // Check if vblank needs servicing.
                if (REG_RD32(NV_PMC_INTR_0) & (DRF_DEF(_PMC, _INTR_0, _PCRTC,  _PENDING) |
                                               DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING)))
                    HALRMSERVICEINTR(pFifoControlArg->pHalHwInfo, DAC_ENGINE_TAG);
            }

            //
            // Disable the dma pusher, if active
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);

            //
            // Wait til idle
            //
            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
			    ;
            
            //
            // Disable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            //
            // Disable pusher and puller access to cache0.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PULL0, _ACCESS, _DISABLED);
            //
            // Disable pusher and puller access to cache1.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(3, 0, 0);
            //
            // Force a context switch to PRAMIN.
            //
            // KJK This should be replaced with a full software-based context switch
            //
            nvHalFifoContextSwitch_NV10(pHalHwInfo, (NUM_FIFOS_NV10 - 1));
            
            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);
            
            //
            // Flush all FIFOs.
            //
            FifoReassign = REG_RD32(NV_PFIFO_CACHES);
            FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
            FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(1, 0, 0);

            //
            // Update the FIFO context and its dirty bits.  By moving the get pointer to the current
            // put value, we are flushing any pending push data that hasn't been fetched yet.
            //
            for (i = 0; i < NUM_FIFOS_NV10; i++)
            {
                if (pFifoHalPvtInfo->InUse & (1 << i))
                {
                    REG_WR32((U032)(pFbHalPvtInfo->fifoContextAddr + (i * 32) + SF_OFFSET(NV_RAMFC_DMA_GET)), 
                             REG_RD32((U032)(pFbHalPvtInfo->fifoContextAddr + (i * 32) + SF_OFFSET(NV_RAMFC_DMA_PUT))));

                    //
                    // Also, when setting the channels get pointer equal to its put, ensure the next
                    // DWORD is interpreted as a command (and not data) by clearing RAMFC_DMA_METHOD.
                    //
                    REG_WR32((U032)(pFbHalPvtInfo->fifoContextAddr + (i * 32) + SF_OFFSET(NV_RAMFC_DMA_METHOD)), 0x0);
                }
            }

            //
            // Restore CACHE1 state.
            //
            FIFOLOG(1, FifoPull, FifoReassign);
            REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
            REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
            REG_WR32(NV_PFIFO_CACHES, FifoReassign);

            //
            // Flush all pending
            //
            REG_WR32(NV_PFIFO_DMA, 0);
            
            //
            // Disable all FIFO interrupts.
            //
            REG_WR32(NV_PFIFO_INTR_EN_0, 0);
            break;
        case FIFO_CONTROL_DESTROY:
            break;
        case FIFO_CONTROL_UPDATE:
            //
            // Update the dma fetch numbers using reasonable defaults.
            // Use FLD_WR_DRF_DEF so that we don't kill the endianness bit
			//
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, _128_BYTES);
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, _32_BYTES);
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, _15);
            break;

        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalFifoAllocPio
//
// Allocate PIO channel.
//
RM_STATUS
nvHalFifoAllocPio_NV10(VOID *arg)
{
    PFIFOALLOCPIOARG_000 pFifoAllocPioArg = (PFIFOALLOCPIOARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV10 pFifoHalPvtInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    U032 CacheData, InitCtxtPtr;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoAllocPioArg->id != FIFO_ALLOC_PIO_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
    pHalHwInfo = pFifoAllocPioArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV10)pHalHwInfo->pFifoHalPvtInfo;

    //
    // Disable cache reassignment.
    //
    CacheData = REG_RD32(NV_PFIFO_CACHES);
    REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _DISABLED);

    //
    // Initialize freshly allocated FIFO context.
    //
    InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr + (pFifoAllocPioArg->chid * 32);
    for (i = 0; i < 8; i++)
    {
        REG_WR32(InitCtxtPtr+(i*4), 0);
    }

    //
    // Set MODE to pio.
    //
    pFifoHalPvtInfo->Mode &= ~(1 << pFifoAllocPioArg->chid);
    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

    //
    // Is this channel in use?
    //
    if ((pFifoHalInfo->AllocateCount++ == 0)
     || (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoAllocPioArg->chid))
    {
        //
        // Disable cache1.
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        //
        // Set initial cache parameters.
        //
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID,    pFifoAllocPioArg->chid);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT,   _ADDRESS, 0);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_GET,   _ADDRESS, 0);
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        //
        // Enable cache1.
        //
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS,   _ENABLED);
        CacheData = DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _ENABLED);
    }

    //
    // Restore previous cache reassignability.
    //
    REG_WR32(NV_PFIFO_CACHES, CacheData);

    //
    // Mark channel as allocated.
    //
    pFifoHalPvtInfo->InUse |= (1 << pFifoAllocPioArg->chid);

    return (RM_OK);
}

//
// nvHalFifoCalcDmaFetch
//
// Derive chip-dependent DMA fetch parameter register value
// from values specified at channel allocation time.
//
U032
nvHalFifoCalcDmaFetch_NV10(U032 fetchTrigger, U032 fetchSize, U032 fetchRequests)
{
    U032 dmaFetch;

    //
    // Input trigger value is in bytes.
    // Hardware value must be specified in increments of 8 between
    // 8 - 256 bytes.
    //
    if (fetchTrigger < 8) fetchTrigger = 8;
    if (fetchTrigger > 256) fetchTrigger = 256;
    fetchTrigger = (fetchTrigger / 8) - 1;

    //
    // Input size value is in bytes.
    // Hardware value must be specified in increments of 32
    // between 32 - 256 bytes.
    //
    if (fetchSize < 32) fetchSize = 32;
    if (fetchSize > 256) fetchSize = 256;
    fetchSize = (fetchSize / 32) - 1;

    //
    // Requests must be between 0 and 15.
    //
    if (fetchRequests > 15) fetchRequests = 15;

    //
    // Put it all together.
    //

    dmaFetch = DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, fetchTrigger) |
        DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, fetchSize) |
        DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, fetchRequests);

    return dmaFetch;
}

//
//
// nvHalFifoAllocDma
//
// Allocate DMA channel.
//
RM_STATUS
nvHalFifoAllocDma_NV10(VOID *arg)
{
    PFIFOALLOCDMAARG_000 pFifoAllocDmaArg = (PFIFOALLOCDMAARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV10 pFifoHalPvtInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    U032 CacheData, InitCtxtPtr;
    U032 DefaultFetch;
    U032 i;

    //
    // Verify interface revision.
    //
    if (pFifoAllocDmaArg->id != FIFO_ALLOC_DMA_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
    pHalHwInfo = pFifoAllocDmaArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV10)pHalHwInfo->pFifoHalPvtInfo;

    //
    // Disable cache reassignment.
    //
    CacheData = REG_RD32(NV_PFIFO_CACHES);
    REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _DISABLED);
    
    //
    // Initialize freshly allocated FIFO context.
    //
    InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr + (pFifoAllocDmaArg->chid * 32);
    for (i = 0 ; i < 8 ; i++ )
    {
        REG_WR32(InitCtxtPtr+(i*4), 0);
    }

    //
    // Insert the instance (note that the rest of the context can start as zero)
    //
#ifdef TRAP_HOST_FIFO_SWITCHES
    if (do_fifo_switch)
        dma_inst[pFifoAllocDmaArg->chid] = pFifoAllocDmaArg->dmaInstance;
    else
#endif
    REG_WR32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_INST)), pFifoAllocDmaArg->dmaInstance);
    
    //
    // Calculate the endianness for the channel
    // Each channel can have its own endian-ness, but the api does not
    // yet support that.  So for now the channel endianness follows
    // from the rest of the system
    //
    if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
        DefaultFetch = DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _ENDIAN, _BIG);
    else
        DefaultFetch = DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _ENDIAN, _LITTLE);

    //
    // Adjust fetch max request (exception to the "all start as zero" rule)
    //
    DefaultFetch |= nvHalFifoCalcDmaFetch_NV10(pFifoAllocDmaArg->fetchTrigger, pFifoAllocDmaArg->fetchSize, pFifoAllocDmaArg->fetchRequests);

    REG_WR32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG)), DefaultFetch);
    
    //
    // Set channel mode to dma
    //
    pFifoHalPvtInfo->Mode |= (1 << pFifoAllocDmaArg->chid);
    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

    //
    // Is this channel in use?
    //
    if ((pFifoHalInfo->AllocateCount++ == 0)
     || (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoAllocDmaArg->chid))
    {
        //
        // KJK Warning!!  We're getting in here if this is the first (0)
        // channel allocated in the system due to the checks above.
        // We really shouldn't be...
        //
        
        //
        // Disable cache1.
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        //
        // Set initial cache parameters.
        //
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID,   pFifoAllocDmaArg->chid);
        
        if (pFifoHalPvtInfo->Mode & (1 << pFifoAllocDmaArg->chid))
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA); 
        
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_DMA_PUT, _OFFSET, 0);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_DMA_GET, _OFFSET, 0);
        
#ifdef TRAP_HOST_FIFO_SWITCHES
        if (!do_fifo_switch)
#endif
        REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, pFifoAllocDmaArg->dmaInstance);

        //
        // Force a reload of the PTE's
        //
        REG_WR32(NV_PFIFO_CACHE1_DMA_CTL, 0);
        
        //
        // Clear all pusher state
        //
        REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        
        //
        // Set default watermarks
        //
        //REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 0x000F6068);
        REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, DefaultFetch);
        
        //
        // Enable cache1.
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoAllocDmaArg->chid))
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);
        
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS,   _ENABLED);
        CacheData = DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _ENABLED);
    }

    //
    // Restore previous cache reassignability.
    //
    REG_WR32(NV_PFIFO_CACHES, CacheData);

    //
    // Mark channel as allocated.
    //
    pFifoHalPvtInfo->InUse |= (1 << pFifoAllocDmaArg->chid);

    return (RM_OK);
}

//
// nvHalFifoFree
//
// Free fifo resources.
//
RM_STATUS
nvHalFifoFree_NV10(VOID *arg)
{
    PFIFOFREEARG_000 pFifoFreeArg = (PFIFOFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    PFIFOHALINFO_NV10 pFifoHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 InitCtxtPtr;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoFreeArg->id != FIFO_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
    pHalHwInfo = pFifoFreeArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV10)pHalHwInfo->pFifoHalPvtInfo;

    //
    // Save CACHE1 state.
    //
    FifoReassign = REG_RD32(NV_PFIFO_CACHES);
    FifoPush     = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    FifoPull     = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    REG_WR_DRF_DEF(_PFIFO, _CACHES,       _REASSIGN, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
    FIFOLOG(4, 0, 0);

    //
    // Update the FIFO context and its dirty bits.
    //    
    if (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoFreeArg->chid)
    {
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        
        //
        // If this is a dma channel, we need to shut him down and clear out
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoFreeArg->chid))
        {
            //
            // Disable dma pusher activity
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUSH, 0);
            
            //
            // Wait til idle
            //
            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
                ;
            
            //
            // Now zero everything out
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_TLB_PTE, 0);
            
            //
            // Move this channel back to PIO.  This way any inadvertant writes will go to runout.
            //
            pFifoHalPvtInfo->Mode &= ~(1 << pFifoFreeArg->chid);
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
        }        
    }
    else
    {
        //
        // Flush the context into the FIFO context RAM.
        //
        InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr + (pFifoFreeArg->chid * 32);
        for (i = 0; i < 8; i++)
        {
            REG_WR32(InitCtxtPtr+(4*i), 0);
        }
        
        //
        // If this is a dma channel, make sure we clear any pending pushing
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoFreeArg->chid))
        {
            //
            // Clear any pending transfers
            //
            REG_WR32(NV_PFIFO_DMA, REG_RD32(NV_PFIFO_DMA) & (~(1 << pFifoFreeArg->chid)));
            
            //
            // Move this channel back to PIO.  This way any inadvertant writes will go to runout.
            //
            pFifoHalPvtInfo->Mode &= ~(1 << pFifoFreeArg->chid);
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
        }
    }

    //
    // Restore CACHE1 state.
    //
    FIFOLOG(4, FifoPull, FifoReassign);
    REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
    REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    REG_WR32(NV_PFIFO_CACHES, FifoReassign);

    //
    // Free up channel.
    //
    pFifoHalPvtInfo->InUse &= ~(1 << pFifoFreeArg->chid);

    pFifoHalInfo->AllocateCount--;

    return (RM_OK);
}

//
// nvHalFifoContextSwitch
//
// Context switch the fifo.
//
static RM_STATUS
nvHalFifoContextSwitch_NV10(PHALHWINFO pHalHwInfo, U032 ChID)
{
    PFIFOHALINFO_NV10 pFifoHalPvtInfo = (PFIFOHALINFO_NV10)pHalHwInfo->pFifoHalPvtInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 CurrentChID;
    U032 PushPending;
    U032 CtxtPtr = (U032)pFbHalPvtInfo->fifoContextAddr;

    //
    // Save CACHE1 state.
    //
    FifoReassign = REG_RD32(NV_PFIFO_CACHES);
    FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
    FIFOLOG(1, 0, 0);
    
    //
    // Make sure our local (rm) contexts are up to date for the outgoing channel
    //
    CurrentChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID); 

    FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: Manually saving the FIFO context on ChID: 0x%x\n", CurrentChID));

    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_PUT)), REG_RD32(NV_PFIFO_CACHE1_DMA_PUT));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_GET)), REG_RD32(NV_PFIFO_CACHE1_DMA_GET));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_REF_CNT)), REG_RD32(NV_PFIFO_CACHE1_REF));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_INST)), REG_RD32(NV_PFIFO_CACHE1_DMA_INSTANCE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_METHOD)), REG_RD32(NV_PFIFO_CACHE1_DMA_STATE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG)), REG_RD32(NV_PFIFO_CACHE1_DMA_FETCH));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_ENGINE_SUB_0)), REG_RD32(NV_PFIFO_CACHE1_ENGINE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_PULL1_ENGINE)), REG_RD32(NV_PFIFO_CACHE1_PULL1));
    
    //
    // If this is a push channel and put != get, make sure to set the push pending flag
    //
    if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
    {    
        PushPending = REG_RD32(NV_PFIFO_DMA) & ~(1 << CurrentChID);
        if (REG_RD32(NV_PFIFO_CACHE1_DMA_PUT) != REG_RD32(NV_PFIFO_CACHE1_DMA_GET))
            PushPending |= (1 << CurrentChID);
        REG_WR32(NV_PFIFO_DMA, PushPending);
    }                    
    
    //
    // Bring in the context for the new channel from the fifo context ram.
    //
    FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: Manually restoring the FIFO context on ChID: 0x%x\n", ChID));

    //
    // Update the channel and if it's DMA, set the mode
    //
    REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID, ChID);
    if ((pFifoHalPvtInfo->Mode & (1 << ChID)) && (ChID != (NUM_FIFOS_NV10 - 1)))
        FLD_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA); 
    
    REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_PUT))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_GET, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_GET))));
    REG_WR32(NV_PFIFO_CACHE1_REF,REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_REF_CNT))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_INST))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_METHOD))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG))));
    REG_WR32(NV_PFIFO_CACHE1_ENGINE, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_ENGINE_SUB_0))));
    REG_WR32(NV_PFIFO_CACHE1_PULL1, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_PULL1_ENGINE))));
         
    //
    // If DMA, enable the DMA Pusher
    //
    if ((pFifoHalPvtInfo->Mode & (1 << ChID)) && (ChID != (NUM_FIFOS_NV10 - 1)))
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);

    //
    // In case there are dma pusher channels still pending, give this
    // new channel enough time to do something useful before it gets
    // yanked back out again.
    //
    REG_WR32(NV_PFIFO_TIMESLICE, 0x1fffff);     
           
    //
    // Restore CACHE1 state.
    //
    FIFOLOG(1, FifoPull, FifoReassign);
    REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
    REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    REG_WR32(NV_PFIFO_CACHES, FifoReassign);

    return (RM_OK);
}

//
// nvHalFifoGetExceptionData
//
RM_STATUS
nvHalFifoGetExceptionData_NV10(VOID *arg)
{
    PFIFOGETEXCEPTIONDATAARG_000 pFifoGetExceptionDataArg = (PFIFOGETEXCEPTIONDATAARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOEXCEPTIONDATA pFifoExceptionData;
    U032 GetPtr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoGetExceptionDataArg->id != FIFO_GET_EXCEPTION_DATA_000)
        return (RM_ERR_VERSION_MISMATCH);
    
    pHalHwInfo = pFifoGetExceptionDataArg->pHalHwInfo;
    pFifoExceptionData = pFifoGetExceptionDataArg->pExceptionData;

    //
    // Fill in exception data.
    //
    pFifoExceptionData->Reason = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    pFifoExceptionData->ChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID);
    GetPtr = REG_RD32(NV_PFIFO_CACHE1_GET) >> 2;
    pFifoExceptionData->GetPtr = GetPtr;
    pFifoExceptionData->SubChannel =
        (((REG_RD32(NV_PFIFO_CACHE1_METHOD(GetPtr))) >> DRF_SHIFT(NV_PFIFO_CACHE1_METHOD_SUBCHANNEL)) & 
         DRF_MASK(NV_PFIFO_CACHE1_METHOD_SUBCHANNEL));
    pFifoExceptionData->Method = REG_RD32(NV_PFIFO_CACHE1_METHOD(GetPtr)) & 0x1FFC;
    pFifoExceptionData->Data = REG_RD32(NV_PFIFO_CACHE1_DATA(GetPtr));

    return (RM_OK);
}

//
// nvHalFifoService
//
RM_STATUS
nvHalFifoService_NV10(VOID *arg)
{
    PFIFOSERVICEARG_000 pFifoServiceArg = (PFIFOSERVICEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOEXCEPTIONDATA pFifoExceptionData;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV10 pFifoHalPvtInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoServiceArg->id != FIFO_SERVICE_000)
        return (RM_ERR_VERSION_MISMATCH);
    
    pHalHwInfo = pFifoServiceArg->pHalHwInfo;
    pFifoExceptionData = pFifoServiceArg->pExceptionData;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV10)pHalHwInfo->pFifoHalPvtInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;

    //
    // Handle Runout.
    //
    if (pFifoServiceArg->intr & DRF_DEF(_PFIFO, _INTR_0, _RUNOUT, _PENDING))
    {
        U032 ChID;
        U032 SubChannel;
        U032 Type;
        U032 Method;
        U032 Data;
        U032 GetPtr = 0;  // some compilers think its uninitialized otherwise
        U032 Reason;
        U032 FifoPush, wasDmaChannel = 0;
        U032 noValidRunoutData = 1;     // assume it's all junk

        //
        // Deal with data in runout.
        //
        FIFO_PRINTF((DBG_LEVEL_USERERRORS, "NVRM: Cache ranout.  Waiting for cache to drain.\n\r"));
        FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM:         CACHE1 ChID = 0x%x\n", REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID)));

        //
        // Don't allow another channel to switch in
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHES,       _REASSIGN, _DISABLED);

        //
        // Disable CACHE1_PUSH0, so we're able to safely resubmit the runout method/data
        // back into the CACHE1 below.
        // 
        FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
        
        //
        // If this is a DMA channel, start to shut down the current pushing
        //
        if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
        {
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);
            wasDmaChannel = 1;      // started this interrupt as a DMA channel
        }
            
        //
        // First wait for cache to drain and the dma pusher to be idle
        //
        if ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) == NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY) &&
            (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_IDLE))
        {            
            //
            // Cache is empty.  Deal with data in runout.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
            FIFOLOG(1, 0, 0);

            //
            // Since the CACHE1 has been idled, let's move its PUT/GET to the top
            // of the FIFO avoiding any overflow issues during the resubmit.
            //
#ifdef DEBUG
            if (REG_RD32(NV_PFIFO_CACHE1_PUT) != REG_RD32(NV_PFIFO_CACHE1_GET))
                DBG_BREAKPOINT();
#endif // DEBUG

            REG_WR32(NV_PFIFO_CACHE1_PUT, 0x0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0x0);

            //
            // Because we've taken the trouble to idle everything, rather than dump
            // a single method/data into the CACHE1 and wait, we'll resubmit all the
            // outstanding runout method/data back into the CACHE1.
            //
            FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: RunOut_PUT        = 0x%x\n", REG_RD32(NV_PFIFO_RUNOUT_PUT)));
            FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: RunOut_GET        = 0x%x\n", REG_RD32(NV_PFIFO_RUNOUT_GET)));

            while (REG_RD32(NV_PFIFO_RUNOUT_PUT) != REG_RD32(NV_PFIFO_RUNOUT_GET))
            {
                //
                // Read FIFO state.
                //
                GetPtr     = REG_RD32(NV_PFIFO_RUNOUT_GET);
                Data       = REG_RD32(pFbHalPvtInfo->fifoRunoutAddr + GetPtr);
                FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM:       RunOut Method = 0x%x\n", Data));

                ChID       = SF_VAL(_RAMRO, _CHID, Data);
                Type       = SF_VAL(_RAMRO, _TYPE, Data);
                Reason     = SF_VAL(_RAMRO, _REASON, Data);
                Method     = SF_VAL(_RAMRO, _METHOD, Data) & 0x1FFF;
                SubChannel = SF_VAL(_RAMRO, _SUBCHANNEL, Data) & 0x7;

                Data       = REG_RD32(pFbHalPvtInfo->fifoRunoutAddr + GetPtr + 4);
                FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM:       RunOut Data   = 0x%x\n", Data));

                //
                // Set user cache state to look just as if the runout came
                // from the bottom on the FIFO.  This keeps the OBJECT_CHANGED
                // bits in order.
                //
                if ((Type == NV_RAMRO_TYPE_WRITE)
                    && (Reason != NV_RAMRO_REASON_ILLEGAL_ACCESS)
                    && (Reason != NV_RAMRO_REASON_RESERVED_ACCESS))
                {
                    if ((ChID < NUM_FIFOS_NV10) && (pFifoHalPvtInfo->InUse & (1 << ChID)))
                    {
                        U032 Cache1Put;

                        //
                        // We've got valid runout, so we'll be resubmitting
                        // something during this loop.
                        //
                        noValidRunoutData = 0;

                        //
                        // Since the fifo engine/resmgr no longer tracks object context on a per-subchannel
                        // basis, the only thing we can do with runout methods is to send them back down
                        // the main user fifo.
                        //
                        // Do we need to force a channel change?
                        //
                        if (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) != ChID)
                        {
                            nvHalFifoContextSwitch_NV10(pHalHwInfo, ChID);

                            //
                            // If we started out the interrupt as a DMA channel and have switched into
                            // a PIO channel, make sure to clear the SUSPEND bit (but don't reenable). 
                            // The HW likes to see this bit cleared after an intr and since we now look
                            // like a PIO channel, we'll just clear it here.
                            // 
                            if (wasDmaChannel && (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _MODE) == 0))
                                FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _STATUS, _RUNNING);
                        }

                        //
                        // Resubmit
                        //
                        Cache1Put = REG_RD_DRF(_PFIFO, _CACHE1_PUT, _ADDRESS);
                        FIFO_PRINTF((DBG_LEVEL_INFO,
                                                   "NVRM: Cache runout resubmit to CACHE1 addr: 0x%x\n", Cache1Put << 2));

                        REG_WR32(NV_PFIFO_CACHE1_METHOD(Cache1Put), 
                            Method | DRF_NUM(_PFIFO, _CACHE0_METHOD, _SUBCHANNEL, SubChannel));
                        REG_WR32(NV_PFIFO_CACHE1_DATA(Cache1Put), Data);

                        //
                        // Update the CACHE1 Put ptr.
                        // There are no overflow worries, since we started at the top of the CACHE1
                        //
                        Cache1Put++;
                        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT, _ADDRESS, Cache1Put);
                    }
                    else
                    {
                        FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: Access to free channel: 0x%x\n", ChID));
                        FIFO_PRINTF((DBG_LEVEL_INFO, "                 sub channel: 0x%x\n", SubChannel));
                        FIFO_PRINTF((DBG_LEVEL_INFO, "                      offset: 0x%x\n", Method));
                        FIFO_PRINTF((DBG_LEVEL_INFO, "                        data: 0x%x\n", Data));
                        DBG_BREAKPOINT();
                    }
                }
            
                //
                // Advance the RunOut get pointer.
                //
                GetPtr = (GetPtr + 8) & pFbHalPvtInfo->fifoRunoutMask;
                REG_WR32(NV_PFIFO_RUNOUT_GET, GetPtr);
                GetPtr = REG_RD32(NV_PFIFO_RUNOUT_GET);      // flush delay to update runout_status
            }

            //
            // Clear condition if no more data in runout.
            //
            if (REG_RD32(NV_PFIFO_RUNOUT_STATUS) & DRF_DEF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK, _EMPTY))
            {
                FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: RunOut has CAUGHT UP:0x%x\n", GetPtr));
                REG_WR_DRF_DEF(_PFIFO, _INTR_0, _RUNOUT, _RESET);
            } else {
                FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: RunOut should be CAUGHT UP:0x%x\n", GetPtr));
                DBG_BREAKPOINT();
            }

            //
            // If we interrupted a dma channel and didn't do anything,
            // then be sure we leave the DMA push access enabled.
            //
            if (wasDmaChannel && noValidRunoutData)
                REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);
        }
        else
        {
            //
            // Enable the puller to empty the cache.
            //
            FIFOLOG(1, 1, 0);
            REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _ENABLED);
        }

        // restore CACHE1_PUSH0 state
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    }

    if (pFifoServiceArg->intr & DRF_DEF(_PFIFO, _INTR_0, _DMA_PUSHER, _PENDING))
    {
        if ((REG_RD_DRF(_PFIFO, _CACHE1_DMA_STATE, _ERROR) == NV_PFIFO_CACHE1_DMA_STATE_ERROR_NON_CACHE) &&
            ((DRF_VAL(_FIFO, _DMA_METHOD, _ADDRESS, REG_RD32(NV_PFIFO_CACHE1_DMA_RSVD_SHADOW)) << 2) == NV06E_SWAP_EXTENSION))
        {
            U032 ChID, Put;

            // nv_printf("Got Swap Extension method!\n");

            // get our channel
            ChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID);

            // save the current put, and set put back to get to stall the
            // channel
            Put = REG_RD32(NV_PFIFO_CACHE1_DMA_PUT);

            REG_WR32(NV_PFIFO_CACHE1_DMA_PUT,
                REG_RD32(NV_PFIFO_CACHE1_DMA_GET));

            // let the swap extension take care of it from here..
#ifdef LINUX
            RmSwapClient((PHWINFO) pHalHwInfo->pDeviceId, ChID, Put);
#endif

            // does this need to happen before the SwapClient?
            REG_WR_DRF_DEF(_PFIFO, _INTR_0, _DMA_PUSHER, _RESET);
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
        }
    }

    return (RM_OK);
}

//
// nvHalFifoAccess
//
RM_STATUS
nvHalFifoAccess_NV10(VOID *arg)
{
    PFIFOACCESSARG_000 pFifoAccessArg = (PFIFOACCESSARG_000)arg;
    PFIFOACCESSINFO pFifoAccessInfo;
    PHALHWINFO pHalHwInfo;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoAccessArg->id != FIFO_ACCESS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoAccessArg->pHalHwInfo;
    pFifoAccessInfo = pFifoAccessArg->pAccessInfo;

    switch (pFifoAccessArg->cmd) {
    case FIFO_ACCESS_DISABLE:
        //
        // This is the HW approved way of idling the FIFO, before changing its
        // context. After disabling reassign, wait for any pending channel changes
        // to complete. Also wait for the hash engine to idle then invalidate the
        // last lookup to avoid any miscompares (cleans up errors seen on IKOS).
        //
        pFifoAccessInfo->FifoReassign = REG_RD32(NV_PFIFO_CACHES);
        pFifoAccessInfo->FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
        pFifoAccessInfo->FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);

        // disable reassign and wait for DMA_SUSPEND to go idle
        REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
        while (REG_RD_DRF(_PFIFO, _CACHES, _DMA_SUSPEND) == NV_PFIFO_CACHES_DMA_SUSPEND_BUSY)
			;

        // disable cache1 push access and the cache1 puller
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);

        // wait for the hash engine to idle and invalidate its previous lookup
        while (REG_RD_DRF(_PFIFO, _CACHE1_PULL0, _HASH_STATE) == NV_PFIFO_CACHE1_PULL0_HASH_STATE_BUSY)
			;
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_HASH, _VALID, 0x0);
        break;
    case FIFO_ACCESS_ENABLE:
        REG_WR32(NV_PFIFO_CACHE1_PULL0, pFifoAccessInfo->FifoPull);
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, pFifoAccessInfo->FifoPush);
        REG_WR32(NV_PFIFO_CACHES, pFifoAccessInfo->FifoReassign);
        break;
    default:
        // invalid cmd
        return (RM_ERR_BAD_ARGUMENT);
    }
    return (RM_OK);
}

//
// nvHalFifoHashAdd
//
RM_STATUS
nvHalFifoHashAdd_NV10(VOID *arg)
{
    PFIFOHASHADDARG_000 pFifoHashAddArg = (PFIFOHASHADDARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;
    U032 ht_Context;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashAddArg->id != FIFO_HASH_ADD_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoHashAddArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(0) + pFbHalPvtInfo->hashTableAddr);

    // set hash entry's object handle
    REG_WR32(&hwHashTable[pFifoHashAddArg->entry].ht_ObjectHandle, pFifoHashAddArg->handle);

    ht_Context = (pFifoHashAddArg->instance & SF_MASK(NV_RAMHT_INSTANCE)) |
                                            (pFifoHashAddArg->engine << SF_SHIFT(NV_RAMHT_ENGINE)) |
                                            (pFifoHashAddArg->chid << SF_SHIFT(NV_RAMHT_CHID)) |
                                            (NV_RAMHT_STATUS_VALID << SF_SHIFT(NV_RAMHT_STATUS));

    // set hash entry's inst addr and valid bit
    REG_WR32(&hwHashTable[pFifoHashAddArg->entry].ht_Context, ht_Context);
             
    while ((REG_RD32(&hwHashTable[pFifoHashAddArg->entry].ht_ObjectHandle) != pFifoHashAddArg->handle) ||
           (REG_RD32(&hwHashTable[pFifoHashAddArg->entry].ht_Context) != ht_Context))
        ;
    return (RM_OK);
}

//
// nvHalHashDelete
//
RM_STATUS
nvHalFifoHashDelete_NV10(VOID *arg)
{
    PFIFOHASHDELETEARG_000 pFifoHashDeleteArg = (PFIFOHASHDELETEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashDeleteArg->id != FIFO_HASH_DELETE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoHashDeleteArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(0) + pFbHalPvtInfo->hashTableAddr);

    REG_WR32(&hwHashTable[pFifoHashDeleteArg->entry].ht_Context, 0);
    REG_WR32(&hwHashTable[pFifoHashDeleteArg->entry].ht_ObjectHandle, 0);

    return (RM_OK);
}

RM_STATUS
nvHalFifoHashFunc_NV10(VOID *arg)
{
    PFIFOHASHFUNCARG_000 pFifoHashFuncArg = (PFIFOHASHFUNCARG_000)arg;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashFuncArg->id != FIFO_HASH_FUNC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pFifoHashFuncArg->result = FIFO_HASH(pFifoHashFuncArg->handle, pFifoHashFuncArg->chid);

    return (RM_OK);    
}

RM_STATUS
nvHalFifoHashSearch_NV10(VOID *arg)
{
    PFIFOHASHSEARCHARG_000 pFifoHashSearchArg = (PFIFOHASHSEARCHARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PPRAMHALINFO pPramHalInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;
    U032 Entry;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashSearchArg->id != FIFO_HASH_SEARCH_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoHashSearchArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    pPramHalInfo = pHalHwInfo->pPramHalInfo;
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(0) + pFbHalPvtInfo->hashTableAddr);

    pFifoHashSearchArg->result = 0x0;

    // Attempt to find a valid entry in the Hash (checking Name and ChID)
    for (Entry = 0; Entry < pPramHalInfo->HashDepth; Entry++)
    {
        if (REG_RD32(&hwHashTable[Entry].ht_ObjectHandle) == pFifoHashSearchArg->handle)
        {
            U032 chid, valid;
            U032 context = REG_RD32(&hwHashTable[Entry].ht_Context);
             
            chid  = context >> SF_SHIFT(NV_RAMHT_CHID) & SF_MASK(NV_RAMHT_CHID);
            valid = context >> SF_SHIFT(NV_RAMHT_STATUS) & SF_MASK(NV_RAMHT_STATUS);

            if ((valid == NV_RAMHT_STATUS_VALID) && (chid == pFifoHashSearchArg->chid))
            {
                pFifoHashSearchArg->result = context;
                break;
            }
        }
    }

    return (RM_OK);    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\fifo\nv\fifoobj.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** FIFO Manager *******************************\
*                                                                           *
* Module: FIFOOBJ.C                                                         *
*   The FIFO objects are managed in this module.  All modifications to the  *
*   object tree are handled here.  The object tree is a balanced tree       *
*   implementation.                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <btree.h>
#include <class.h>
#include <fifo.h>
#include <os.h>
#include "nvhw.h"

//
// Fifo object routines.
//

RM_STATUS fifoAddObject
(
	PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS status;
    PNODE     node;

    DBG_VAL_PTR(Object);
    status = btreeSearch(Object->Name, &node, pDev->DBfifoTable[Object->ChID].ObjectTree);
    if (status == RM_OK)
        return (RM_ERR_INSERT_DUPLICATE_NAME);
    Object->Node.Value = Object->Name;
    Object->Node.Data  = Object;
    status = btreeInsert(&(Object->Node), &(pDev->DBfifoTable[Object->ChID].ObjectTree));
    if (status == RM_OK)
    {
        //
        // Balance tree after every 16th object addition.
        //
        if ((++pDev->DBfifoTable[Object->ChID].ObjectCount & 0x0F) == 0x00)
            btreeBalance(&(pDev->DBfifoTable[Object->ChID].ObjectTree));
    }
    return (status);    
}

// jsw...
// 
// cwj: we don't add the DMA context object to the fifoTable
// in NV4 (not called from RmBindDmaContext).
//
//RM_STATUS fifoAddDmaObject
//(
//	PHWINFO pDev,
//    POBJECT Object,
//	U032 ChID
//)
//{
//    RM_STATUS status;
//    PNODE     node;
//
//    DBG_VAL_PTR(Object);
//    //status = btreeSearch(Object->Name, &node, pDev->DBfifoTable[Object->ChID].ObjectTree);
//    status = btreeSearch(Object->Name, &node, pDev->DBfifoTable[ChID].ObjectTree);
//    if (status == RM_OK)
//        return (RM_ERR_INSERT_DUPLICATE_NAME);
//    Object->Node.Value = Object->Name;
//    Object->Node.Data  = Object;
//    //status = btreeInsert(&(Object->Node), &(pDev->DBfifoTable[Object->ChID].ObjectTree));
//    status = btreeInsert(&(Object->Node), &(pDev->DBfifoTable[ChID].ObjectTree));
//    if (status == RM_OK)
//    {
//        //
//        // Balance tree after every 16th object addition.
//        //
//        //if ((++pDev->DBfifoTable[Object->ChID].ObjectCount & 0x0F) == 0x00)
//        if ((++pDev->DBfifoTable[ChID].ObjectCount & 0x0F) == 0x00)
//            //btreeBalance(&(pDev->DBfifoTable[Object->ChID].ObjectTree));
//            btreeBalance(&(pDev->DBfifoTable[ChID].ObjectTree));
//    }
//    return (status);    
//}

RM_STATUS fifoDelObject
(
	PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS status;

    DBG_VAL_PTR(Object);
    status = btreeDelete(Object->Node.Value, &(pDev->DBfifoTable[Object->ChID].ObjectTree));
    if (status == RM_OK)
        pDev->DBfifoTable[Object->ChID].ObjectCount--;

    if (pDev->DBfifoTable[Object->ChID].LastIllegalMthdObject == Object)
    {
        pDev->DBfifoTable[Object->ChID].LastIllegalMthdObject = NULL;
    }
    return (status);    
}

// jsw...
//
// cwj: wasn't added above, so no need to delete it.
//
//RM_STATUS fifoDelDmaObject
//(
//	PHWINFO pDev,
//    POBJECT Object,
//	U032 ChID
//)
//{
//    RM_STATUS status;
//
//    DBG_VAL_PTR(Object);
//    //status = btreeDelete(Object->Node.Value, &(pDev->DBfifoTable[Object->ChID].ObjectTree));
//    status = btreeDelete(Object->Node.Value, &(pDev->DBfifoTable[ChID].ObjectTree));
//    if (status == RM_OK)
//        //pDev->DBfifoTable[Object->ChID].ObjectCount--;
//        pDev->DBfifoTable[ChID].ObjectCount--;
//    return (status);    
//}

RM_STATUS fifoSearchObject
(
	PHWINFO  pDev,
    U032     Name,
    U032     ChID,
    POBJECT *Object
)
{
    RM_STATUS status;
    PNODE     node;
    
    status = btreeSearch(Name, &node, pDev->DBfifoTable[ChID].ObjectTree);
    if (status == RM_OK)
    {
        *Object = node->Data;
        DBG_VAL_PTR(*Object);
    }
    return (status);    
}

//
// Update an objects' context
//
RM_STATUS fifoUpdateObjectInstance
(
	PHWINFO     pDev,
    POBJECT     Object,
    U032        ChID,
    U032        Instance
)
{
    RM_STATUS status;

    FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: Updating FIFO context on object: 0x%x\n", Object->Name));
    FIFO_PRINTF((DBG_LEVEL_INFO, "                                 ChID: 0x%x\n", ChID));
    FIFO_PRINTF((DBG_LEVEL_INFO, "                             instance: 0x%x\n", Instance));

    osEnterCriticalCode(pDev);
    //
    // Remove the object from the hash table.
    //
    fifoDelHashEntry(pDev, Object, ChID);
    //
    // Add it back.
    //
    status = fifoAddHashEntry(pDev, Object, ChID, Instance);
    osExitCriticalCode(pDev);
    return (status);
}

RM_STATUS fifoDeleteObjectInstance
(
	PHWINFO pDev,
	POBJECT Object,
	U032    ChID    
)
{
    FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: Deleting FIFO context on object: 0x%x\n", Object->Name));
    FIFO_PRINTF((DBG_LEVEL_INFO, "                                 ChID: 0x%x\n", ChID));

    osEnterCriticalCode(pDev);
    //
    // Remove the object from the hash table.
    //
    fifoDelHashEntry(pDev, Object, ChID);
    osExitCriticalCode(pDev);
    return (RM_OK);
}

//
// Reset the channel, so it's in an idle state and clear the hash.
// This is called as part of fifoFree.
//
RM_STATUS fifoResetChannelState
(
    PHWINFO pDev,
    U032    ChID
)
{
    U032 Entry;

    //
    // Reset the channel, so it's in an idle state.
    //
    osEnterCriticalCode(pDev);
    nvHalFifoFree(pDev, ChID, pDev->DBfifoTable[ChID].Instance);

    //
    // Clear the hash table for this ChID.
    //
    for (Entry = 0; Entry < pDev->Pram.HalInfo.HashDepth; Entry++)
    {
        if (pDev->DBhashTable[Entry].Object && pDev->DBhashTable[Entry].ChID == ChID)
        {
            // clear software entry
            pDev->DBhashTable[Entry].Object = NULL;
            // clear hardware entry
            nvHalFifoHashDelete(pDev, Entry);
        }
    }
    osExitCriticalCode(pDev);

    return (RM_OK);
}

//
// Clear out the SubchannelContext
//
RM_STATUS fifoDeleteSubchannelContextEntry
(
    PHWINFO pDev,
    POBJECT Object
)
{
    U032 i;
    U032 ChID = Object->ChID;

    for (i = 0; i < NUM_SUBCHANNELS; i++)
    {
        if (pDev->DBfifoTable[ChID].SubchannelContext[i] == Object)
        {
            pDev->DBfifoTable[ChID].SubchannelContext[i] = NULL;
        }
    }

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\fifo\nv\fifostat.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** FIFO Manager *******************************\
*                                                                           *
* Module: FIFOSTATE.C                                                       *
*   The FIFO state is changed in this module.                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <dac.h>
#include <gr.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"


//
// Change FIFO state in hardware.
//
RM_STATUS stateFifo
(
    PHWINFO pDev,
    U032    msg
)
{
    U032 i;

    switch (msg)
    {
        case STATE_UPDATE:
            nvHalFifoControl(pDev, FIFO_CONTROL_UPDATE);
            break;
        case STATE_LOAD:
            nvHalFifoControl(pDev, FIFO_CONTROL_LOAD);

            //
            // Re-disable cache reassignment if we're in a full-screen DOS session.  In case
            // some driver goes crazy and starts writing its dma pointers before
            // we're back into hires, we don't want to render on the DOS screen.
            // By disabling the reassign, we lock the fifo at the unused channel
            // until we're ready to process more data.  They're welcome to fill their
            // buffer up -- it just won't go anywhere.
            //
            if (pDev->Vga.Enabled)
            {
                FIFOLOG(3, 1, 1);
                REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            }

            //
            // Enable all PFIFO interrupt conditions using value
            // setup by HAL (see FIFO_CONTROL_INIT code for each chip).
            //
            REG_WR32(NV_PFIFO_INTR_0,     0xFFFFFFFF);
            REG_WR32(NV_PFIFO_INTR_EN_0,  pDev->Fifo.HalInfo.IntrEn0);

            break;
        case STATE_UNLOAD:
            nvHalFifoControl(pDev, FIFO_CONTROL_UNLOAD);
            break;
        case STATE_INIT:
            initFifo(pDev);
            initFifoEx(pDev);
            
            //
            // Allocate Hash Table structure.
            //
            if (osAllocMem((VOID **)&pDev->DBhashTable, HASH_DEPTH * sizeof(SW_HASH_TABLE_ENTRY)) != RM_OK)
                return (RM_ERR_NO_FREE_MEM);

            //
            // Initialize Hash Table.
            //    
            for (i = 0; i < HASH_DEPTH; i++)
            {
                pDev->DBhashTable[i].Object = NULL;
            }

            nvHalFifoControl(pDev, FIFO_CONTROL_INIT);
            break;
        case STATE_DESTROY:
            //
            // Free up allocated memory.
            //
            osFreeMem(pDev->DBfifoTable);
            osFreeMem(pDev->DBhashTable);
            break;
    }    
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\gr\nv\grmethd.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRMETHD.C                                                         *
*   The graphics engine is managed in this module.  All priviledged state   *
*   relating to the canvas and datapath is managed here.  Context switching *
*   is also contained here.                                                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <dac.h>
#include <gr.h>
#include <modular.h>   
#include <os.h>
#include <nv32.h>
#include "nvhw.h"


// extern PGRAPHICSCHANNEL grTable;


//---------------------------------------------------------------------------
//
//  Graphics video patchcord methods
//
//---------------------------------------------------------------------------

RM_STATUS mthdSetVideoInput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    return (RM_OK);

#ifdef KJK
    RM_STATUS       status;
    U032            InputIndex;
    U032            i;
    PVIDEOPATCHCORD *VideoInput;
    PVIDEOPATCHCORD VideoOutput;
    PVIDEOPATCHCORD VideoPatchcord;
    
    InputIndex = (Offset - Method->Low) / 4;

    /*
    KJK This is probably useless, since we wouldn't
        have been called if the method itself was
        out of range for this object.

    switch (Object->Class->Type)
    {
        case NV_VIDEO_SWITCH:
            if (InputIndex >= 2)
                return (RM_ERR_INVALID_PATCH);
            break;
        default:
            if (InputIndex >= MAX_GRPATCH_INPUT)
                return (RM_ERR_INVALID_PATCH);
            break;
    }
    */

    switch (Object->Class->Type)
    {
        case NV_VIDEO_SINK:
            VideoInput  = &(((PVIDEOSINKOBJECT)Object)->VideoInput[InputIndex]);
            VideoOutput = NULL;
            break;
        case NV_VIDEO_COLORMAP:
            VideoInput  = &(((PVIDEOCOLORMAPOBJECT)Object)->VideoInput);
            VideoOutput =   ((PVIDEOCOLORMAPOBJECT)Object)->VideoOutput;
            break;
        case NV_VIDEO_SCALER:
            VideoInput  = &(((PVIDEOSCALEROBJECT)Object)->VideoInput);
            VideoOutput =   ((PVIDEOSCALEROBJECT)Object)->VideoOutput;
            break;
        /*            
        case NV_VIDEO_CAPTURE_TO_MEMORY:
            VideoInput  = &(((PVIDEOTOMEMOBJECT)Object)->VideoInput);
            VideoOutput = NULL;
            break;
        */            
        default:
            VideoInput  = &(((PVIDEOOBJECT)Object)->VideoInput[InputIndex]);
            VideoOutput =   ((PVIDEOOBJECT)Object)->VideoOutput;
            break;
    }

    //
    // Disconnect old patchcord.  Break apart all patch information.
    //
    if (*VideoInput)
    {
        DBG_VAL_PTR(*VideoInput);
        for (i = 0; (*VideoInput)->Destination[i] != (PVIDEOOBJECT)Object; i++);
        (*VideoInput)->FanOut--;
        (*VideoInput)->Destination[i] = NULL;
        *VideoInput                   = NULL;
    }

    if (Data)
    {
        //
        // Validate patchcord and connect.
        //
        status = fifoSearchObject(pDev, Data, Object->ChID, (POBJECT *)&VideoPatchcord);
        if (status)
            return (status);
        if (VideoPatchcord->Base.Class->Type != NV_PATCHCORD_VIDEO)
            return (RM_ERR_OBJECT_TYPE_MISMATCH);
        if (VideoPatchcord->FanOut == MAX_GRPATCH_FANOUT)
            return (RM_ERR_MAX_PATCH_FANOUT);
        for (i = 0; (i < MAX_GRPATCH_FANOUT) && (VideoPatchcord->Destination[i] != (PVIDEOOBJECT)Object); i++);
        if (i == MAX_GRPATCH_FANOUT)
        {
            //
            // Insert this connection into the first available slot.
            //
            for (i = 0; VideoPatchcord->Destination[i]; i++);
            VideoPatchcord->FanOut++;
            VideoPatchcord->Destination[i] = (PVIDEOOBJECT)Object;
            *VideoInput                    = VideoPatchcord;
        }
    }

    return (RM_OK);
#endif // KJK    
}

RM_STATUS mthdSetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    return (RM_OK);

#ifdef KJK
    RM_STATUS        status;
    PVIDEOPATCHCORD *VideoOutput;
    PVIDEOPATCHCORD  VideoPatchcord;
    
    switch (Object->Class->Type)
    {
        /*
        case NV_IMAGE_TO_VIDEO:
            VideoOutput = &(((PIMAGEVIDEOOBJECT)Object)->VideoOutput);
            break;
        */            
        case NV_VIDEO_FROM_MEMORY:
            VideoOutput = &(((PVIDEOFROMMEMOBJECT)Object)->VideoOutput);
            break;
        /*            
        case NV_VIDEO_SOURCE:
            VideoOutput = &(((PVIDEOSOURCEOBJECT)Object)->VideoOutput);
            break;
        */            
        default:
            VideoOutput = &(((PVIDEOOBJECT)Object)->VideoOutput);
            break;
    }
    //
    // Disconnect old patchcord.  Break apart all patch information.
    //
    if (*VideoOutput)
    {
        DBG_VAL_PTR(*VideoOutput);
        grInvalidateVideoPatchcord(*VideoOutput);
        (*VideoOutput)->Source = NULL;
        *VideoOutput           = NULL;
    }
    if (Data)
    {
        //
        // Validate patchcord and connect.
        //
        status = fifoSearchObject(pDev, Data, Object->ChID, (POBJECT *)&VideoPatchcord);
        if (status)
            return (status);
        if (VideoPatchcord->Base.Class->Type != NV_PATCHCORD_VIDEO)
            return (RM_ERR_OBJECT_TYPE_MISMATCH);
        //
        // Unplug patchcord if already in use.
        //    
        if (VideoPatchcord->Source)
        {
            DBG_VAL_PTR(VideoPatchcord->Source);
            grInvalidateVideoPatchcord(VideoPatchcord);
            switch (VideoPatchcord->Source->Base.Class->Type)
            {
                /*
                case NV_IMAGE_TO_VIDEO:
                    ((PIMAGEVIDEOOBJECT)VideoPatchcord->Source)->VideoOutput = NULL;
                    break;
                */                    
                case NV_VIDEO_FROM_MEMORY:
                    ((PVIDEOFROMMEMOBJECT)VideoPatchcord->Source)->VideoOutput = NULL;
                    break;
                /*                    
                case NV_VIDEO_SOURCE:
                    ((PVIDEOSOURCEOBJECT)VideoPatchcord->Source)->VideoOutput = NULL;
                    break;
                */                    
                default:
                    VideoPatchcord->Source->VideoOutput = NULL;
                    break;
            }
        }
        //
        // Insert this connection into the first available slot.
        //
        VideoPatchcord->Source = (PVIDEOOBJECT)Object;
        *VideoOutput = VideoPatchcord;
    }
    return (RM_OK);
#endif // KJK
}

//---------------------------------------------------------------------------
//
//  Graphics class methods that map directly to hardware.
//
//---------------------------------------------------------------------------



//---------------------------------------------------------------------------
//
//  Colormap methods.
//
//---------------------------------------------------------------------------

RM_STATUS mthdSetColormapCtxDma
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    RM_STATUS            status;
    PVIDEOCOLORMAPOBJECT ColormapObject;
    
    ColormapObject = (PVIDEOCOLORMAPOBJECT)Object;
    //
    // Check for a previous translation.  Free its resource before overwriting.
    //
    if (Data == NV1_NULL_OBJECT)
    {
        ColormapObject->Xlate = NULL;
        return (RM_OK);
    }
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(ColormapObject->Xlate));
    if (status)
    {
        osError(Object, Offset, Data, status);
        return (status);
    }
    return (RM_OK);
}
RM_STATUS mthdSetColormapFormat
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    ((PVIDEOCOLORMAPOBJECT)Object)->ColorFormat = Data;
    return (RM_OK);
}
RM_STATUS mthdSetColormapStart
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    ((PVIDEOCOLORMAPOBJECT)Object)->Start = Data;
    return (RM_OK);
}
RM_STATUS mthdSetColormapLength
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    ((PVIDEOCOLORMAPOBJECT)Object)->Length = Data;
    return (RM_OK);
}
RM_STATUS mthdColormapDirtyStart
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    ((PVIDEOCOLORMAPOBJECT)Object)->DirtyStart = Data + ((PVIDEOCOLORMAPOBJECT)Object)->Start;
    return (RM_OK);
}
RM_STATUS mthdColormapDirtyLength
(
    PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    RM_STATUS       status;
    PVIDEOCOLORMAPOBJECT ColormapObject;
    U032           *ColormapBuffer, *ColormapBufferBase;
    U032            StartIndex;
    U032            StopIndex;
    
    ColormapObject = (PVIDEOCOLORMAPOBJECT)Object;
    //
    // Validate length.
    //
    if ((ColormapObject->DirtyStart + Data) > (ColormapObject->Start + ColormapObject->Length))
        return (RM_ERR_INVALID_START_LENGTH);
    ColormapObject->DirtyLength = Data;
    //
    // Validate enumeration parameters.
    //
    if (!ColormapObject->Xlate)
        return (RM_ERR_INVALID_XLATE);
	/* KJK
    status = dmaAttach(ColormapObject->Xlate);
    if (status)
        return (status);
	*/
    status = dmaValidateXlate(ColormapObject->Xlate,
                              ColormapObject->Start,
                              ColormapObject->Length);
    if (status)
        return (status);
	/* KJK
    status = dmaBeginXfer(ColormapObject->Xlate, NULL);
    if (status)
        return (status);
	*/
    //
    // Get buffer translation.
    //
    status = dmaGetMappedAddress(pDev, ColormapObject->Xlate,
                                 ColormapObject->DirtyStart,
                                 ColormapObject->DirtyLength,
                                 (VOID **)&ColormapBuffer);
    if (status)
        return (status);
        
    // save original ptr value    
	ColormapBufferBase = ColormapBuffer;
    
    //
    // Load new colormap into palette copy.
    //
    if (pDev->Dac.UpdateFlags & UPDATE_HWINFO_DAC_COLORMAP)
        pDev->Dac.UpdateFlags &= ~UPDATE_HWINFO_DAC_COLORMAP;
    StartIndex = (ColormapObject->DirtyStart - ColormapObject->Start) >> 2;
    StopIndex  = StartIndex + ((ColormapObject->DirtyLength) >> 2);
    if (StopIndex > 255)
        StopIndex = 255;
    while (StartIndex <= StopIndex)
    {
        ColormapObject->ColorMap[StartIndex] = *ColormapBuffer;
        if (pDev->Dac.HalInfo.Depth == 8)
            pDev->Dac.Palette[StartIndex++]     = *ColormapBuffer++;
        else    
            pDev->Dac.Gamma[StartIndex++]       = *ColormapBuffer++;
    }
    pDev->colormapObjectToNotify = ColormapObject;
    pDev->Dac.UpdateFlags |= UPDATE_HWINFO_DAC_COLORMAP;
    //KJK dmaEndXfer(ColormapObject->Xlate, NULL);
    //dmaDetach(ColormapObject->Xlate);    
    return (RM_OK);
}

RM_STATUS mthdColormapDirtyNotify
(
    PHWINFO   pDev,
    RM_STATUS status
)
{
    RM_STATUS rmStatus;
    PVIDEOCOLORMAPOBJECT pColormapObj;
    
    pColormapObj = pDev->colormapObjectToNotify;
    
    if (pColormapObj == NULL)
        return RM_OK;
        
    rmStatus = notifyFillNotifierArray(pDev, pColormapObj->CBase.NotifyXlate,
                                       0 /* info32 */, 0 /* info16 */, 
                                       status,
                                       NVFF9_NOTIFIERS_COLORMAP_DIRTY_NOTIFY);
    //
    // Do any OS specified action related to this notification.
    //
    if (pColormapObj->CBase.NotifyAction)
    {
        osNotifyEvent(pDev,
                      (POBJECT)pColormapObj, 
                      NVFF9_NOTIFIERS_COLORMAP_DIRTY_NOTIFY,
                      0 /* Method */, 
                      0 /* Data */, 
                      status, 
                      pColormapObj->CBase.NotifyAction);
    }
                                       
    pDev->colormapObjectToNotify = NULL;
    return rmStatus;
}

//---------------------------------------------------------------------------
//
//  Graphics notification on completion of VBlank.
//
//---------------------------------------------------------------------------

RM_STATUS grVideoSwitchComplete
(
	PHWINFO   pDev,
    POBJECT   Object,
    U032      Method,
    V032      Data,
    RM_STATUS Status
)
{
    notifyFillNotifier(pDev, ((PVIDEOSWITCHOBJECT)Object)->VBlankNotify[Data].Xlate, 0, 0, Status);
    //KJK dmaEndXfer(((PVIDEOSWITCHOBJECT)Object)->VBlankNotify[Data].Xlate, NULL);
    //
    // Do any OS specified action related to this notification.
    //
    if (((PVIDEOSWITCHOBJECT)Object)->VBlankNotify[Data].Action)
    {
        osNotifyEvent(pDev,
                      Object,
        			  0,
                      0x0400 + (Data << 2),
                      Object->Name,
                      Status,
                      ((PVIDEOSWITCHOBJECT)Object)->VBlankNotify[Data].Action);
    }
    ((PVIDEOSWITCHOBJECT)Object)->VBlankNotify[Data].Pending = FALSE;
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Default HW method handler for graphics engine classes.
//
//---------------------------------------------------------------------------

RM_STATUS grHWMethod
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: grHWMethod class:    0x%x\n", Object->Class->Type));
    GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM:            chid:     0x%x\n", Object->ChID));
    GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM:            handle:   0x%x\n", Object->Name));
    GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM:            offset:   0x%x\n", Offset));
    GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM:            data:     0x%x\n", Data));
    GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM:            instance: 0x%x\n", ((PCOMMONOBJECT)Object)->Instance));
    DBG_BREAKPOINT();

    //
    // THIS IS A HARDWARE METHOD...
    //
    // We'll only be here if we get an ILLEGAL_MTHD exception
    // from graphics.  We don't attempt any recovery, just drop
    // it on the floor and continue...
    //
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\fifo\nv20\fifonv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************* Chip Specific HAL FIFO Routines *********************\
*                                                                           *
* Module: FIFONV20.C                                                        *
*   The NV20 specific HAL FIFO routines reside in this file.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalFifoControl_NV20(VOID *);
RM_STATUS nvHalFifoAllocPio_NV20(VOID *);
RM_STATUS nvHalFifoAllocDma_NV20(VOID *);
RM_STATUS nvHalFifoFree_NV20(VOID *);
RM_STATUS nvHalFifoGetExceptionData_NV20(VOID *);
RM_STATUS nvHalFifoService_NV20(VOID *);
RM_STATUS nvHalFifoAccess_NV20(VOID *);
RM_STATUS nvHalFifoHashAdd_NV20(VOID *);
RM_STATUS nvHalFifoHashDelete_NV20(VOID *);
RM_STATUS nvHalFifoHashFunc_NV20(VOID *);

// The context switch interface is only used internally, but perhaps
// should be made available to the resource manager anyway.
static RM_STATUS nvHalFifoContextSwitch_NV20(PHALHWINFO, U032);

static U032 nvHalFifoCalcDmaFetch_NV20(U032, U032, U032);

RM_STATUS
nvHalFifoControl_NV20(VOID *arg)
{
    PFIFOCONTROLARG_000 pFifoControlArg = (PFIFOCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV20 pFifoHalPvtInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoControlArg->id != FIFO_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoControlArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV20)pHalHwInfo->pFifoHalPvtInfo;

    switch (pFifoControlArg->cmd) {
        case FIFO_CONTROL_INIT:
            //
            // Setup default parameters. 
            //
            pFifoHalInfo->RetryCount = 255;
            pFifoHalInfo->UserBase = DEVICE_BASE(NV_USER);
            pFifoHalPvtInfo->Mode = 0;
            pFifoHalPvtInfo->InUse = 0;

            //
            // Setup interrupt enable mask.
            //
            pFifoHalInfo->IntrEn0 =
                DRF_DEF(_PFIFO, _INTR_EN_0, _CACHE_ERROR, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _RUNOUT, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _RUNOUT_OVERFLOW, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _DMA_PUSHER, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _DMA_PT, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _SEMAPHORE, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _ACQUIRE_TIMEOUT, _ENABLED);

            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);
            //
            // Zero DMA FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, 0);
            //
            // Zero FIFO hash valid.
            //
            REG_WR32(NV_PFIFO_CACHE0_HASH, 0);
            REG_WR32(NV_PFIFO_CACHE1_HASH, 0);
            //
            // Zero engine assignments
            //
            //REG_WR32(NV_PFIFO_CACHE0_ENGINE, 0);
            //REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
            //
            // Make all FIFO's default
            //
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
            REG_WR32(NV_PFIFO_DMA, 0);
            REG_WR32(NV_PFIFO_SIZE, 0);
            //
            // Clear all pusher state
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
            //
            // Zero run-out pointers.
            //
            REG_WR_DRF_NUM(_PFIFO, _RUNOUT_PUT, _ADDRESS, 0);
            REG_WR_DRF_NUM(_PFIFO, _RUNOUT_GET, _ADDRESS, 0);
            break;
        case FIFO_CONTROL_LOAD:
            //
            // Update the dma fetch numbers using reasonable defaults.
            // We don't need to worry about the endianness bit here
            // because we're going to swap this channel out asap
            //
            
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, _128_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, _32_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, _15));
            
            //
            // Enable default timeslicing
            //    
            REG_WR32(NV_PFIFO_DMA_TIMESLICE, 
                     DRF_DEF(_PFIFO, _DMA_TIMESLICE, _TIMEOUT, _ENABLED)
                     | DRF_DEF(_PFIFO, _DMA_TIMESLICE, _SELECT, _128K));
            
            //
            // Set retry delay to match common hardware latency.
            //
            REG_WR_DRF_NUM(_PFIFO, _DELAY_0, _WAIT_RETRY, pFifoHalInfo->RetryCount);
            //
            // Disable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            //
            // Disable pusher and puller access to cache0.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PULL0, _ACCESS, _DISABLED);
            //
            // Disable pusher and puller access to cache1.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(3, 0, 0);
            //
            // Disable the pusher, if active
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);
            
            //
            // Force a context switch to PRAMIN.
            //
            // KJK This should be replaced with a full software-based context switch
            //
            nvHalFifoContextSwitch_NV20(pHalHwInfo, (NUM_FIFOS_NV20 - 1));
            
            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);

            //
            // Enable pusher and puller access to cache1.
            //
            FIFOLOG(3, 1, 0);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _ENABLED);
            //
            // Delay for slow CACHE1_PULL.
            //
            //temp = REG_RD32(NV_PFIFO_CACHE1_PULL0);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _ENABLED);
            //
            // Enable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _ENABLED);
            break;
        case FIFO_CONTROL_UNLOAD:
            //
            // Disable dma timeslicing
            //    
            REG_WR32(NV_PFIFO_DMA_TIMESLICE, DRF_DEF(_PFIFO, _DMA_TIMESLICE, _TIMEOUT, _DISABLED));

            //
            // Empty FIFO and runout.
            //
            while ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) != NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
                   || (REG_RD_DRF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK) != NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY)
                   || (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY))
            {
                //
                // Make sure we process any fifo interrupts
                //
                HALRMSERVICEINTR(pHalHwInfo, FIFO_ENGINE_TAG);
                
                //
                // Check if GE needs servicing.
                //
                if (REG_RD32(NV_PGRAPH_INTR))
                    HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);

                // Check if vblank needs servicing.
                if (REG_RD32(NV_PMC_INTR_0) & (DRF_DEF(_PMC, _INTR_0, _PCRTC,  _PENDING) |
                                               DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING)))
                    HALRMSERVICEINTR(pHalHwInfo, DAC_ENGINE_TAG);
            }

            //
            // Disable the dma pusher, if active
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);

            //
            // Wait til idle
            //
            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
                ;
            
            //
            // Disable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            //
            // Disable pusher and puller access to cache0.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PULL0, _ACCESS, _DISABLED);
            //
            // Disable pusher and puller access to cache1.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(3, 0, 0);
            //
            // Force a context switch to PRAMIN.
            //
            // KJK This should be replaced with a full software-based context switch
            //
            nvHalFifoContextSwitch_NV20(pHalHwInfo, (NUM_FIFOS_NV20 - 1));
            
            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);
            
            //
            // Flush all FIFOs.
            //
            FifoReassign = REG_RD32(NV_PFIFO_CACHES);
            FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
            FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(1, 0, 0);

            //
            // Update the FIFO context and its dirty bits.  By moving the get pointer to the current
            // put value, we are flushing any pending push data that hasn't been fetched yet.
            //
            for (i = 0; i < NUM_FIFOS_NV20; i++)
            {
                if (pFifoHalPvtInfo->InUse & (1 << i))
                {
                    REG_WR32((U032)(pFbHalPvtInfo->fifoContextAddr1 + (i * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_GET)), 
                             REG_RD32((U032)(pFbHalPvtInfo->fifoContextAddr1 + (i * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_PUT))));

                    //
                    // Also, when setting the channels get pointer equal to its put, ensure the next
                    // DWORD is interpreted as a command (and not data) by clearing RAMFC_DMA_METHOD.
                    //
                    REG_WR32((U032)(pFbHalPvtInfo->fifoContextAddr1 + (i * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_METHOD)), 0x0);
                }
            }

            //
            // Restore CACHE1 state.
            //
            FIFOLOG(1, FifoPull, FifoReassign);
            REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
            REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
            REG_WR32(NV_PFIFO_CACHES, FifoReassign);

            //
            // Flush all pending
            //
            REG_WR32(NV_PFIFO_DMA, 0);
            
            //
            // Disable all FIFO interrupts.
            //
            REG_WR32(NV_PFIFO_INTR_EN_0, 0);
            break;
        case FIFO_CONTROL_DESTROY:
            break;
        case FIFO_CONTROL_UPDATE:
            //
            // Update the dma fetch numbers using reasonable defaults.
            // Use FLD_WR_DRF_DEF so that we don't kill the endianness bit
			//
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, _128_BYTES);
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, _32_BYTES);
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, _15);
            break;

        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalFifoAllocPio
//
// Allocate PIO channel.
//
RM_STATUS
nvHalFifoAllocPio_NV20(VOID *arg)
{
    PFIFOALLOCPIOARG_000 pFifoAllocPioArg = (PFIFOALLOCPIOARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV20 pFifoHalPvtInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PGRHALINFO_NV20 pGrHalPvtInfo;
    U032 CacheData, InitCtxtPtr, grCtxTable;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoAllocPioArg->id != FIFO_ALLOC_PIO_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
    pHalHwInfo = pFifoAllocPioArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV20)pHalHwInfo->pFifoHalPvtInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;

    //
    // Disable cache reassignment.
    //
    CacheData = REG_RD32(NV_PFIFO_CACHES);
    REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _DISABLED);

    //
    // Clear graphics context buffer.
    //
    for (i = 0; i < NV20_GR_CONTEXT_SIZE/4; i++)
        INST_WR32(pFifoAllocPioArg->instance, i*4, 0);

    //
    // Now load graphics channel context buffer address into both
    // the hardware table and our shadow copy.
    //
    grCtxTable = pGrHalPvtInfo->CtxTableBase;

#ifdef DEBUG
    if (INST_RD32(grCtxTable, pFifoAllocPioArg->chid * 4) != 0)
    {
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: pio channel has non-null context instance: 0x%x\n", pFifoAllocPioArg->chid));
        DBG_BREAKPOINT();
    }
    if (pGrHalPvtInfo->CtxTable[pFifoAllocPioArg->chid] != 0)
    {
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: pio channel has non-null shadow context instance: 0x%x\n", pFifoAllocPioArg->chid));
        DBG_BREAKPOINT();
    }
#endif

    INST_WR32(grCtxTable, pFifoAllocPioArg->chid * 4, pFifoAllocPioArg->instance);
    pGrHalPvtInfo->CtxTable[pFifoAllocPioArg->chid] = pFifoAllocPioArg->instance;

    //
    // Initialize freshly allocated FIFO context.
    //
    InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr1 + (pFifoAllocPioArg->chid * FC1_SIZE_NV20);
    for (i = 0; i < FC1_SIZE_NV20/4; i++)
    {
        REG_WR32(InitCtxtPtr+(i*4), 0);
    }

    //
    // Set MODE to pio.
    //
    pFifoHalPvtInfo->Mode &= ~(1 << pFifoAllocPioArg->chid);
    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

    //
    // Is this channel in use?
    //
    if ((pFifoHalInfo->AllocateCount++ == 0)
     || (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoAllocPioArg->chid))
    {
        //
        // Disable cache1.
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        //
        // Set initial cache parameters.
        //
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID,    pFifoAllocPioArg->chid);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT,   _ADDRESS, 0);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_GET,   _ADDRESS, 0);
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        //
        // Enable cache1.
        //
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS,   _ENABLED);
        CacheData = DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _ENABLED);
    }

    //
    // Restore previous cache reassignability.
    //
    REG_WR32(NV_PFIFO_CACHES, CacheData);

    //
    // Mark channel as allocated.
    //
    pFifoHalPvtInfo->InUse |= (1 << pFifoAllocPioArg->chid);

    return (RM_OK);
}

//
// nvHalFifoCalcDmaFetch
//
// Derive chip-dependent DMA fetch parameter register value
// from values specified at channel allocation time.
//
U032
nvHalFifoCalcDmaFetch_NV20(U032 fetchTrigger, U032 fetchSize, U032 fetchRequests)
{
    U032 dmaFetch;

    //
    // Input trigger value is in bytes.
    // Hardware value must be specified in increments of 8 between
    // 8 - 256 bytes.
    //
    if (fetchTrigger < 8) fetchTrigger = 8;
    if (fetchTrigger > 256) fetchTrigger = 256;
    fetchTrigger = (fetchTrigger / 8) - 1;

    //
    // Input size value is in bytes.
    // Hardware value must be specified in increments of 32
    // between 32 - 256 bytes.
    //
    if (fetchSize < 32) fetchSize = 32;
    if (fetchSize > 256) fetchSize = 256;
    fetchSize = (fetchSize / 32) - 1;

    //
    // Requests must be between 0 and 15.
    //
    if (fetchRequests > 15) fetchRequests = 15;

    //
    // Put it all together.
    //
    dmaFetch = DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, fetchTrigger) |
        DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, fetchSize) |
        DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, fetchRequests);

    return dmaFetch;
}

//
//
// nvHalFifoAllocDma
//
// Allocate DMA channel.
//
RM_STATUS
nvHalFifoAllocDma_NV20(VOID *arg)
{
    PFIFOALLOCDMAARG_000 pFifoAllocDmaArg = (PFIFOALLOCDMAARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV20 pFifoHalPvtInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PGRHALINFO_NV20 pGrHalPvtInfo;
    U032 CacheData, InitCtxtPtr, grCtxTable;
    U032 DefaultFetch;
    U032 i;

    //
    // Verify interface revision.
    //
    if (pFifoAllocDmaArg->id != FIFO_ALLOC_DMA_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
    pHalHwInfo = pFifoAllocDmaArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV20)pHalHwInfo->pFifoHalPvtInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;

    //
    // Disable cache reassignment.
    //
    CacheData = REG_RD32(NV_PFIFO_CACHES);
    REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _DISABLED);

    //
    // Clear graphics context buffer.
    //
    for (i = 0; i < NV20_GR_CONTEXT_SIZE/4; i++)
        INST_WR32(pFifoAllocDmaArg->instance, i*4, 0);

    //
    // Load graphics channel context pointer.
    //
    grCtxTable = pGrHalPvtInfo->CtxTableBase;

#ifdef DEBUG
    //
    // ASSERT that the entry for this channel is currently null.
    //
    if (INST_RD32(grCtxTable, pFifoAllocDmaArg->chid * 4) != 0)
    {
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: dma channel has non-null context instance: 0x%x\n", pFifoAllocDmaArg->chid));
        DBG_BREAKPOINT();
    }
    if (pGrHalPvtInfo->CtxTable[pFifoAllocDmaArg->chid] != 0)
    {
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: pio channel has non-null shadow context instance: 0x%x\n", pFifoAllocDmaArg->chid));
        DBG_BREAKPOINT();
    }
#endif

    INST_WR32(grCtxTable, pFifoAllocDmaArg->chid * 4, pFifoAllocDmaArg->instance);
    pGrHalPvtInfo->CtxTable[pFifoAllocDmaArg->chid] = pFifoAllocDmaArg->instance;
    
    //
    // Initialize freshly allocated FIFO context.
    //
    InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr1 + (pFifoAllocDmaArg->chid * FC1_SIZE_NV20);
    for (i = 0 ; i < FC1_SIZE_NV20/4; i++ )
    {
        REG_WR32(InitCtxtPtr+(i*4), 0);
    }

    //
    // Insert the instance (note that the rest of the context can start as zero)
    //
    REG_WR32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_INST)), pFifoAllocDmaArg->dmaInstance);
    
    //
    // Calculate the endianness for the channel
    // Each channel can have its own endian-ness, but the api does not
    // yet support that.  So for now the channel endianness follows
    // from the rest of the system
    //
    if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
        DefaultFetch = DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _ENDIAN, _BIG);
    else
        DefaultFetch = DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _ENDIAN, _LITTLE);

    //
    // Adjust fetch max request (exception to the "all start as zero" rule)
    //
    DefaultFetch |= nvHalFifoCalcDmaFetch_NV20(pFifoAllocDmaArg->fetchTrigger, pFifoAllocDmaArg->fetchSize, pFifoAllocDmaArg->fetchRequests);

    REG_WR32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG)), DefaultFetch);
    
    //
    // Set channel mode to dma
    //
    pFifoHalPvtInfo->Mode |= (1 << pFifoAllocDmaArg->chid);
    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

    //
    // Is this channel in use?
    //
    if ((pFifoHalInfo->AllocateCount++ == 0)
     || (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoAllocDmaArg->chid))
    {
        //
        // KJK Warning!!  We're getting in here if this is the first (0)
        // channel allocated in the system due to the checks above.
        // We really shouldn't be...
        //
        
        //
        // Disable cache1.
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        //
        // Set initial cache parameters.
        //
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID,   pFifoAllocDmaArg->chid);
        
        if (pFifoHalPvtInfo->Mode & (1 << pFifoAllocDmaArg->chid))
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA); 
        
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_DMA_PUT, _OFFSET, 0);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_DMA_GET, _OFFSET, 0);
        
        REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, pFifoAllocDmaArg->dmaInstance);

        //
        // Force a reload of the PTE's
        //
        REG_WR32(NV_PFIFO_CACHE1_DMA_CTL, 0);
        
        //
        // Clear all pusher state
        //
        REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        
        //
        // Set default watermarks
        //
        //REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 0x000F6068);
        REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, DefaultFetch);
        
        //
        // Enable cache1.
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoAllocDmaArg->chid))
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);
        
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS,   _ENABLED);
        CacheData = DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _ENABLED);
    }

    //
    // Restore previous cache reassignability.
    //
    REG_WR32(NV_PFIFO_CACHES, CacheData);

    //
    // Mark channel as allocated.
    //
    pFifoHalPvtInfo->InUse |= (1 << pFifoAllocDmaArg->chid);

    return (RM_OK);
}

//
// nvHalFifoFree
//
// Free fifo resources.
//
RM_STATUS
nvHalFifoFree_NV20(VOID *arg)
{
    PFIFOFREEARG_000 pFifoFreeArg = (PFIFOFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV20 pFifoHalPvtInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PGRHALINFO_NV20 pGrHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 InitCtxtPtr, grCtxTable;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoFreeArg->id != FIFO_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
    pHalHwInfo = pFifoFreeArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV20)pHalHwInfo->pFifoHalPvtInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;

    //
    // Save CACHE1 state.
    //
    FifoReassign = REG_RD32(NV_PFIFO_CACHES);
    FifoPush     = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    FifoPull     = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    REG_WR_DRF_DEF(_PFIFO, _CACHES,       _REASSIGN, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
    FIFOLOG(4, 0, 0);

    //
    // Update the FIFO context and its dirty bits.
    //    
    if (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoFreeArg->chid)
    {
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        
        //
        // If this is a dma channel, we need to shut him down and clear out
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoFreeArg->chid))
        {
            //
            // Disable dma pusher activity
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUSH, 0);
            
            //
            // Wait til idle
            //
            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
			    ;
            
            //
            // Now zero everything out
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_TLB_PTE, 0);
            
            //
            // Move this channel back to PIO.  This way any inadvertant writes will go to runout.
            //
            pFifoHalPvtInfo->Mode &= ~(1 << pFifoFreeArg->chid);
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
        }        
    }
    else
    {
        //
        // Flush the context into the FIFO context RAM.
        //
        InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr1 + (pFifoFreeArg->chid * FC1_SIZE_NV20);
        for (i = 0; i < FC1_SIZE_NV20/4; i++)
        {
            REG_WR32(InitCtxtPtr+(4*i), 0);
        }
        
        //
        // If this is a dma channel, make sure we clear any pending pushing
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoFreeArg->chid))
        {
            //
            // Clear any pending transfers
            //
            REG_WR32(NV_PFIFO_DMA, REG_RD32(NV_PFIFO_DMA) & (~(1 << pFifoFreeArg->chid)));
            
            //
            // Move this channel back to PIO.  This way any inadvertant writes will go to runout.
            //
            pFifoHalPvtInfo->Mode &= ~(1 << pFifoFreeArg->chid);
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
        }
    }

    //
    // Clear graphics channel context pointer.
    //
    grCtxTable = pGrHalPvtInfo->CtxTableBase;
#ifdef DEBUG
    //
    // ASSERT that the entry for this channel is currently non-null.
    //
    if (INST_RD32(grCtxTable, pFifoFreeArg->chid * 4) == 0)
    {
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: freed channel has null context instance: 0x%x\n", pFifoFreeArg->chid));
        DBG_BREAKPOINT();
    }
    if (pGrHalPvtInfo->CtxTable[pFifoFreeArg->chid] == 0)
    {
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: pio channel has null shadow context instance: 0x%x\n", pFifoFreeArg->chid));
        DBG_BREAKPOINT();
    }
#endif

    //
    // If we're freeing the current channel, set the invalid chid value.
    //
    if (pFifoFreeArg->chid == pGrHalPvtInfo->currentChID)
    {
        U032 access;

        pGrHalPvtInfo->currentChID = NUM_FIFOS_NV20;

        access = REG_RD32(NV_PGRAPH_FIFO);
        REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);
        GR_DONE();

        //
        // Invalidate graphics engines notion of current chid too.
        //
        if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) == pFifoFreeArg->chid)
        {
            REG_WR32(NV_PGRAPH_CTX_CONTROL,
                     DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US) |
                     DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME, _NOT_EXPIRED) |
                     DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID, _INVALID) |
                     DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING, _IDLE) |
                     DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE, _ENABLED));
        }

        REG_WR32(NV_PGRAPH_FIFO, access);
    }

    //
    // Now clear context buffer pointer.
    //
    INST_WR32(grCtxTable, pFifoFreeArg->chid * 4, 0);
    pGrHalPvtInfo->CtxTable[pFifoFreeArg->chid] = 0;

    //
    // Restore CACHE1 state.
    //
    FIFOLOG(4, FifoPull, FifoReassign);
    REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
    REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    REG_WR32(NV_PFIFO_CACHES, FifoReassign);

    //
    // Free up channel.
    //
    pFifoHalPvtInfo->InUse &= ~(1 << pFifoFreeArg->chid);

    pFifoHalInfo->AllocateCount--;

    return (RM_OK);
}

//
// nvHalFifoContextSwitch
//
// Context switch the fifo.
//
static RM_STATUS
nvHalFifoContextSwitch_NV20(PHALHWINFO pHalHwInfo, U032 ChID)
{
    PFIFOHALINFO_NV20 pFifoHalPvtInfo = (PFIFOHALINFO_NV20)pHalHwInfo->pFifoHalPvtInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 CurrentChID;
    U032 PushPending;
    U032 CtxtPtr = (U032)pFbHalPvtInfo->fifoContextAddr1;

    //
    // Save CACHE1 state.
    //
    FifoReassign = REG_RD32(NV_PFIFO_CACHES);
    FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
    FIFOLOG(1, 0, 0);
    
    //
    // Make sure our local (rm) contexts are up to date for the outgoing channel
    //
    CurrentChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID); 

    FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: Manually saving the FIFO context on ChID: 0x%x\n", CurrentChID));

    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_PUT)), REG_RD32(NV_PFIFO_CACHE1_DMA_PUT));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_GET)), REG_RD32(NV_PFIFO_CACHE1_DMA_GET));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_REF_CNT)), REG_RD32(NV_PFIFO_CACHE1_REF));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_INST)), REG_RD32(NV_PFIFO_CACHE1_DMA_INSTANCE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_METHOD)), REG_RD32(NV_PFIFO_CACHE1_DMA_STATE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG)), REG_RD32(NV_PFIFO_CACHE1_DMA_FETCH));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ENGINE_SUB_0)), REG_RD32(NV_PFIFO_CACHE1_ENGINE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_PULL1_ENGINE)), REG_RD32(NV_PFIFO_CACHE1_PULL1));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ACQUIRE_VALUE)), REG_RD32(NV_PFIFO_CACHE1_ACQUIRE_2));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ACQUIRE_TIMESTAMP)), REG_RD32(NV_PFIFO_CACHE1_ACQUIRE_1));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ACQUIRE_TIMEOUT)), REG_RD32(NV_PFIFO_CACHE1_ACQUIRE_0));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_SEMAPHORE_CTXDMA)), REG_RD32(NV_PFIFO_CACHE1_SEMAPHORE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_SUBROUTINE_STATE)), REG_RD32(NV_PFIFO_CACHE1_DMA_SUBROUTINE));
    
    //
    // If this is a push channel and put != get, make sure to set the push pending flag
    //
    if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
    {    
        PushPending = REG_RD32(NV_PFIFO_DMA) & ~(1 << CurrentChID);
        if (REG_RD32(NV_PFIFO_CACHE1_DMA_PUT) != REG_RD32(NV_PFIFO_CACHE1_DMA_GET))
            PushPending |= (1 << CurrentChID);
        REG_WR32(NV_PFIFO_DMA, PushPending);
    }                    
    
    //
    // Bring in the context for the new channel from the fifo context ram.
    //
    FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: Manually restoring the FIFO context on ChID: 0x%x\n", ChID));

    //
    // Update the channel and if it's DMA, set the mode
    //
    REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID, ChID);
    if ((pFifoHalPvtInfo->Mode & (1 << ChID)) && (ChID != (NUM_FIFOS_NV20 - 1)))
        FLD_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA); 
    
    REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_PUT))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_GET, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_GET))));
    REG_WR32(NV_PFIFO_CACHE1_REF,REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_REF_CNT))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_INST))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_METHOD))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG))));
    REG_WR32(NV_PFIFO_CACHE1_ENGINE, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ENGINE_SUB_0))));
    REG_WR32(NV_PFIFO_CACHE1_PULL1, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_PULL1_ENGINE))));
    REG_WR32(NV_PFIFO_CACHE1_ACQUIRE_2, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ACQUIRE_VALUE))));
    REG_WR32(NV_PFIFO_CACHE1_ACQUIRE_1, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ACQUIRE_TIMESTAMP))));
    REG_WR32(NV_PFIFO_CACHE1_ACQUIRE_0, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ACQUIRE_TIMEOUT))));
    REG_WR32(NV_PFIFO_CACHE1_SEMAPHORE, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_SEMAPHORE_CTXDMA))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_SUBROUTINE, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_SUBROUTINE_STATE))));

         
    //
    // If DMA, enable the DMA Pusher
    //
    if ((pFifoHalPvtInfo->Mode & (1 << ChID)) && (ChID != (NUM_FIFOS_NV20 - 1)))
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);

    //
    // In case there are dma pusher channels still pending, give this
    // new channel enough time to do something useful before it gets
    // yanked back out again.
    //
    REG_WR32(NV_PFIFO_TIMESLICE, 0x1fffff);     
           
    //
    // Restore CACHE1 state.
    //
    FIFOLOG(1, FifoPull, FifoReassign);
    REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
    REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    REG_WR32(NV_PFIFO_CACHES, FifoReassign);

    return (RM_OK);
}

//
// nvHalFifoGetExceptionData
//
RM_STATUS
nvHalFifoGetExceptionData_NV20(VOID *arg)
{
    PFIFOGETEXCEPTIONDATAARG_000 pFifoGetExceptionDataArg = (PFIFOGETEXCEPTIONDATAARG_000)arg;
    PFIFOEXCEPTIONDATA pFifoExceptionData;
    PHALHWINFO pHalHwInfo;
    U032 GetPtr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoGetExceptionDataArg->id != FIFO_GET_EXCEPTION_DATA_000)
        return (RM_ERR_VERSION_MISMATCH);
    
    pHalHwInfo = pFifoGetExceptionDataArg->pHalHwInfo;
    pFifoExceptionData = pFifoGetExceptionDataArg->pExceptionData;

    //
    // Fill in exception data.
    //
    pFifoExceptionData->Reason = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    pFifoExceptionData->ChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID);
    GetPtr = REG_RD32(NV_PFIFO_CACHE1_GET) >> 2;
    pFifoExceptionData->GetPtr = GetPtr;
    pFifoExceptionData->SubChannel =
        (((REG_RD32(NV_PFIFO_CACHE1_METHOD(GetPtr))) >> DRF_SHIFT(NV_PFIFO_CACHE1_METHOD_SUBCHANNEL)) & 
         DRF_MASK(NV_PFIFO_CACHE1_METHOD_SUBCHANNEL));
    pFifoExceptionData->Method = REG_RD32(NV_PFIFO_CACHE1_METHOD(GetPtr)) & 0x1FFC;
    pFifoExceptionData->Data = REG_RD32(NV_PFIFO_CACHE1_DATA(GetPtr));

    return (RM_OK);
}

//
// nvHalFifoService
//
RM_STATUS
nvHalFifoService_NV20(VOID *arg)
{
    PFIFOSERVICEARG_000 pFifoServiceArg = (PFIFOSERVICEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOEXCEPTIONDATA pFifoExceptionData;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV20 pFifoHalPvtInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoServiceArg->id != FIFO_SERVICE_000)
        return (RM_ERR_VERSION_MISMATCH);
    
    pHalHwInfo = pFifoServiceArg->pHalHwInfo;
    pFifoExceptionData = pFifoServiceArg->pExceptionData;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV20)pHalHwInfo->pFifoHalPvtInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;

    //
    // Handle RM-implemented RETURN command.
    //
    if (pFifoServiceArg->intr & DRF_DEF(_PFIFO, _INTR_0, _CACHE_ERROR, _PENDING))
    {
        if (pFifoExceptionData->Reason & DRF_DEF(_PFIFO, _CACHE1_PULL0, _DEVICE, _SOFTWARE))
        {
            if (pFifoExceptionData->Method == NV206E_SUBROUTINE_RETURN_SW)
            {
                U032 data32, caches, cache1_pull0;

                //
                // Turn everything off...
                //
                caches = REG_RD32(NV_PFIFO_CACHES);
                cache1_pull0 = REG_RD32(NV_PFIFO_CACHE1_PULL0);
                REG_WR_DRF_DEF(_PFIFO, _CACHES,       _REASSIGN, _DISABLED);
                REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);

                //
                // Clear condition.
                // 
                REG_WR_DRF_DEF(_PFIFO, _INTR_0, _CACHE_ERROR,  _RESET);
                pFifoServiceArg->intr &= ~(DRF_DEF(_PFIFO, _INTR_0, _CACHE_ERROR, _PENDING));
                pFifoExceptionData->Reason &= ~(DRF_DEF(_PFIFO, _CACHE1_PULL0, _DEVICE, _SOFTWARE));

                //
                // Error check.
                //
                data32 = REG_RD32(NV_PFIFO_CACHE1_DMA_SUBROUTINE);
                if (DRF_VAL(_PFIFO, _CACHE1_DMA_SUBROUTINE, _STATE, data32) == NV_PFIFO_CACHE1_DMA_SUBROUTINE_STATE_INACTIVE)
                {
                    // Error: INVALID_STATE; no pending call instruction
                }

                //
                // Implement RETURN (load DMA_GET).
                //
                data32 &= ~DRF_MASK(NV_PFIFO_CACHE1_DMA_SUBROUTINE_STATE);
                REG_WR32(NV_PFIFO_CACHE1_DMA_GET, data32);

                //
                // Set call/return state back to inactive.
                //
                REG_WR32(NV_PFIFO_CACHE1_DMA_SUBROUTINE, data32);

                //
                // Advance the FIFO get pointer.
                //
                pFifoExceptionData->GetPtr++;
                REG_WR_DRF_NUM(_PFIFO, _CACHE1_GET, _ADDRESS, pFifoExceptionData->GetPtr);

                REG_WR32(NV_PFIFO_CACHE1_PULL0, cache1_pull0);
                REG_WR32(NV_PFIFO_CACHES, caches);
            } 
        }
    }

    //
    // Handle Runout.
    //
    if (pFifoServiceArg->intr & DRF_DEF(_PFIFO, _INTR_0, _RUNOUT, _PENDING))
    {
        U032 ChID;
        U032 SubChannel;
        U032 Type;
        U032 Method;
        U032 Data;
        U032 GetPtr = 0;  // some compilers think its uninitialized otherwise
        U032 Reason;
        U032 FifoPush, wasDmaChannel = 0;
        U032 noValidRunoutData = 1;     // assume it's all junk

        //
        // Deal with data in runout.
        //
        FIFO_PRINTF((DBG_LEVEL_USERERRORS, "NVRM: Cache ranout.  Waiting for cache to drain.\n\r"));
        FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM:         CACHE1 ChID = 0x%x\n", REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID)));

        //
        // Don't allow another channel to switch in
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHES,       _REASSIGN, _DISABLED);

        //
        // Disable CACHE1_PUSH0, so we're able to safely resubmit the runout method/data
        // back into the CACHE1 below.
        // 
        FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
        
        //
        // If this is a DMA channel, start to shut down the current pushing
        //
        if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
        {
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);
            wasDmaChannel = 1;      // started this interrupt as a DMA channel
        }
            
        //
        // First wait for cache to drain and the dma pusher to be idle
        //
        if ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) == NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY) &&
            (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_IDLE))
        {            
            //
            // Cache is empty.  Deal with data in runout.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
            FIFOLOG(1, 0, 0);

            //
            // Since the CACHE1 has been idled, let's move its PUT/GET to the top
            // of the FIFO avoiding any overflow issues during the resubmit.
            //
#ifdef DEBUG
            if (REG_RD32(NV_PFIFO_CACHE1_PUT) != REG_RD32(NV_PFIFO_CACHE1_GET))
                DBG_BREAKPOINT();
#endif // DEBUG

            REG_WR32(NV_PFIFO_CACHE1_PUT, 0x0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0x0);

            //
            // Because we've taken the trouble to idle everything, rather than dump
            // a single method/data into the CACHE1 and wait, we'll resubmit all the
            // outstanding runout method/data back into the CACHE1.
            //
            FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: RunOut_PUT        = 0x%x\n", REG_RD32(NV_PFIFO_RUNOUT_PUT)));
            FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: RunOut_GET        = 0x%x\n", REG_RD32(NV_PFIFO_RUNOUT_GET)));

            while (REG_RD32(NV_PFIFO_RUNOUT_PUT) != REG_RD32(NV_PFIFO_RUNOUT_GET))
            {
                //
                // Read FIFO state.
                //
                GetPtr     = REG_RD32(NV_PFIFO_RUNOUT_GET);
                Data       = REG_RD32(pFbHalPvtInfo->fifoRunoutAddr + GetPtr);
                FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM:       RunOut Method = 0x%x\n", Data));

                ChID       = SF_VAL(_RAMRO, _CHID, Data);
                Type       = SF_VAL(_RAMRO, _TYPE, Data);
                Reason     = SF_VAL(_RAMRO, _REASON, Data);
                Method     = SF_VAL(_RAMRO, _METHOD, Data) & 0x1FFF;
                SubChannel = SF_VAL(_RAMRO, _SUBCHANNEL, Data) & 0x7;

                Data       = REG_RD32(pFbHalPvtInfo->fifoRunoutAddr + GetPtr + 4);
                FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM:       RunOut Data   = 0x%x\n", Data));

                //
                // Set user cache state to look just as if the runout came
                // from the bottom on the FIFO.  This keeps the OBJECT_CHANGED
                // bits in order.
                //
                if ((Type == NV_RAMRO_TYPE_WRITE)
                    && (Reason != NV_RAMRO_REASON_ILLEGAL_ACCESS)
                    && (Reason != NV_RAMRO_REASON_RESERVED_ACCESS))
                {
                    if ((ChID < NUM_FIFOS_NV20) && (pFifoHalPvtInfo->InUse & (1 << ChID)))
                    {
                        U032 Cache1Put;

                        //
                        // We've got valid runout, so we'll be resubmitting
                        // something during this loop.
                        //
                        noValidRunoutData = 0;

                        //
                        // Since the fifo engine/resmgr no longer tracks object context on a per-subchannel
                        // basis, the only thing we can do with runout methods is to send them back down
                        // the main user fifo.
                        //
                        // Do we need to force a channel change?
                        //
                    
                        if (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) != ChID)
                        {
                            nvHalFifoContextSwitch_NV20(pHalHwInfo, ChID);

                            //
                            // If we started out the interrupt as a DMA channel and have switched into
                            // a PIO channel, make sure to clear the SUSPEND bit (but don't reenable). 
                            // The HW likes to see this bit cleared after an intr and since we now look
                            // like a PIO channel, we'll just clear it here.
                            // 
                            if (wasDmaChannel && (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _MODE) == 0))
                                FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _STATUS, _RUNNING);
                        }

                        //
                        // Resubmit
                        //
                        Cache1Put = REG_RD_DRF(_PFIFO, _CACHE1_PUT, _ADDRESS);
                        FIFO_PRINTF((DBG_LEVEL_INFO,
                                                   "NVRM: Cache runout resubmit to CACHE1 addr:0x%x\n", Cache1Put << 2));

                        REG_WR32(NV_PFIFO_CACHE1_METHOD(Cache1Put), 
                            Method | DRF_NUM(_PFIFO, _CACHE0_METHOD, _SUBCHANNEL, SubChannel));
                        REG_WR32(NV_PFIFO_CACHE1_DATA(Cache1Put), Data);

                        //
                        // Update the CACHE1 Put ptr.
                        // There are no overflow worries, since we started at the top of the CACHE1
                        //
                        Cache1Put++;
                        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT, _ADDRESS, Cache1Put);
                    }
                    else
                    {
                        FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: Access to free channel: 0x%x\n", ChID));
                        FIFO_PRINTF((DBG_LEVEL_INFO, "                 sub channel: 0x%x\n", SubChannel));
                        FIFO_PRINTF((DBG_LEVEL_INFO, "                      offset: 0x%x\n", Method));
                        FIFO_PRINTF((DBG_LEVEL_INFO, "                        data: 0x%x\n", Data));
                        DBG_BREAKPOINT();
                    }
                }
            
                //
                // Advance the RunOut get pointer.
                //
                GetPtr = (GetPtr + 8) & pFbHalPvtInfo->fifoRunoutMask;
                REG_WR32(NV_PFIFO_RUNOUT_GET, GetPtr);
                GetPtr = REG_RD32(NV_PFIFO_RUNOUT_GET);      // flush delay to update runout_status
            }

            //
            // Clear condition if no more data in runout.
            //
            if (REG_RD32(NV_PFIFO_RUNOUT_STATUS) & DRF_DEF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK, _EMPTY))
            {
                FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: RunOut has CAUGHT UP: 0x%x\n", GetPtr));
                REG_WR_DRF_DEF(_PFIFO, _INTR_0, _RUNOUT, _RESET);
            } else {
                FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: RunOut should be CAUGHT UP: 0x%x\n", GetPtr));
                DBG_BREAKPOINT();
            }

            //
            // If we interrupted a dma channel and didn't do anything,
            // then be sure we leave the DMA push access enabled.
            //
            if (wasDmaChannel && noValidRunoutData)
                REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);
        }
        else
        {
            //
            // Enable the puller to empty the cache.
            //
            FIFOLOG(1, 1, 0);
            REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _ENABLED);
        }

        // restore CACHE1_PUSH0 state
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    }

    //
    // Handle semaphore errors...
    //
    if (pFifoServiceArg->intr & DRF_DEF(_PFIFO, _INTR_0, _SEMAPHORE, _PENDING))
    {
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: DMA semaphore pending\n"));
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: CACHE1_SEMAPHORE: 0x%x\n", REG_RD32(NV_PFIFO_CACHE1_SEMAPHORE)));
        DBG_BREAKPOINT();
        REG_WR_DRF_DEF(_PFIFO, _INTR_0, _SEMAPHORE, _RESET);
    }
    if (pFifoServiceArg->intr & DRF_DEF(_PFIFO, _INTR_0, _ACQUIRE_TIMEOUT, _PENDING))
    {
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: DMA acquire timeout pending\n"));
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: CACHE1_ACQUIRE_0: 0x%x\n", REG_RD32(NV_PFIFO_CACHE1_ACQUIRE_0)));
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: CACHE1_ACQUIRE_1: 0x%x\n", REG_RD32(NV_PFIFO_CACHE1_ACQUIRE_1)));
        FIFO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: CACHE1_ACQUIRE_2: 0x%x\n", REG_RD32(NV_PFIFO_CACHE1_ACQUIRE_2)));
        DBG_BREAKPOINT();
        REG_WR_DRF_DEF(_PFIFO, _INTR_0, _ACQUIRE_TIMEOUT, _RESET);

    }

    if (pFifoServiceArg->intr & DRF_DEF(_PFIFO, _INTR_0, _DMA_PUSHER, _PENDING))
    {
        if ((REG_RD_DRF(_PFIFO, _CACHE1_DMA_STATE, _ERROR) == NV_PFIFO_CACHE1_DMA_STATE_ERROR_NON_CACHE) &&
            ((DRF_VAL(_FIFO, _DMA_METHOD, _ADDRESS, REG_RD32(NV_PFIFO_CACHE1_DMA_RSVD_SHADOW)) << 2) == NV206E_SWAP_EXTENSION))
        {
            U032 ChID, Put;

            // nv_printf("Got Swap Extension method!\n");

            // get our channel
            ChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID);

            // save the current put, and set put back to get to stall the
            // channel
            Put = REG_RD32(NV_PFIFO_CACHE1_DMA_PUT);

            REG_WR32(NV_PFIFO_CACHE1_DMA_PUT,
                REG_RD32(NV_PFIFO_CACHE1_DMA_GET));

            // let the swap extension take care of it from here..
#ifdef LINUX
            RmSwapClient((PHWINFO) pHalHwInfo->pDeviceId, ChID, Put);
#endif

            // does this need to happen before the SwapClient?
            REG_WR_DRF_DEF(_PFIFO, _INTR_0, _DMA_PUSHER, _RESET);
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
        }
    }


    return (RM_OK);
}

//
// nvHalFifoAccess
//
RM_STATUS
nvHalFifoAccess_NV20(VOID *arg)
{
    PFIFOACCESSARG_000 pFifoAccessArg = (PFIFOACCESSARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOACCESSINFO pFifoAccessInfo;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoAccessArg->id != FIFO_ACCESS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoAccessArg->pHalHwInfo;
    pFifoAccessInfo = pFifoAccessArg->pAccessInfo;

    switch (pFifoAccessArg->cmd) {
    case FIFO_ACCESS_DISABLE:
        //
        // This is the HW approved way of idling the FIFO, before changing its
        // context. After disabling reassign, wait for any pending channel changes
        // to complete. Also wait for the hash engine to idle then invalidate the
        // last lookup to avoid any miscompares (cleans up errors seen on IKOS).
        //
        pFifoAccessInfo->FifoReassign = REG_RD32(NV_PFIFO_CACHES);
        pFifoAccessInfo->FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
        pFifoAccessInfo->FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);

        // disable reassign and wait for DMA_SUSPEND to go idle
        REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
        while (REG_RD_DRF(_PFIFO, _CACHES, _DMA_SUSPEND) == NV_PFIFO_CACHES_DMA_SUSPEND_BUSY)
            ;

        // disable cache1 push access and the cache1 puller
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);

        // wait for the hash engine to idle and invalidate its previous lookup
        while (REG_RD_DRF(_PFIFO, _CACHE1_PULL0, _HASH_STATE) == NV_PFIFO_CACHE1_PULL0_HASH_STATE_BUSY)
		    ;
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_HASH, _VALID, 0x0);
        break;
    case FIFO_ACCESS_ENABLE:
        REG_WR32(NV_PFIFO_CACHE1_PULL0, pFifoAccessInfo->FifoPull);
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, pFifoAccessInfo->FifoPush);
        REG_WR32(NV_PFIFO_CACHES, pFifoAccessInfo->FifoReassign);
        break;
    default:
        // invalid cmd
        return (RM_ERR_BAD_ARGUMENT);
    }
    return (RM_OK);
}

//
// nvHalFifoHashAdd
//
RM_STATUS
nvHalFifoHashAdd_NV20(VOID *arg)
{
    PFIFOHASHADDARG_000 pFifoHashAddArg = (PFIFOHASHADDARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashAddArg->id != FIFO_HASH_ADD_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoHashAddArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(0) + pFbHalPvtInfo->hashTableAddr);

    REG_WR32(&hwHashTable[pFifoHashAddArg->entry].ht_ObjectHandle, pFifoHashAddArg->handle);
    REG_WR32(&hwHashTable[pFifoHashAddArg->entry].ht_Context, (pFifoHashAddArg->instance & SF_MASK(NV_RAMHT_INSTANCE)) |
                                                   (pFifoHashAddArg->engine << SF_SHIFT(NV_RAMHT_ENGINE)) |
                                                   (pFifoHashAddArg->chid << SF_SHIFT(NV_RAMHT_CHID)) |
                                                   (NV_RAMHT_STATUS_VALID << SF_SHIFT(NV_RAMHT_STATUS)));
    
    return (RM_OK);
}

//
// nvHalHashDelete
//
RM_STATUS
nvHalFifoHashDelete_NV20(VOID *arg)
{
    PFIFOHASHDELETEARG_000 pFifoHashDeleteArg = (PFIFOHASHDELETEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashDeleteArg->id != FIFO_HASH_DELETE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoHashDeleteArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(0) + pFbHalPvtInfo->hashTableAddr);

    REG_WR32(&hwHashTable[pFifoHashDeleteArg->entry].ht_ObjectHandle, 0);
    REG_WR32(&hwHashTable[pFifoHashDeleteArg->entry].ht_Context, 0);

    return (RM_OK);
}

RM_STATUS
nvHalFifoHashFunc_NV20(VOID *arg)
{
    PFIFOHASHFUNCARG_000 pFifoHashFuncArg = (PFIFOHASHFUNCARG_000)arg;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashFuncArg->id != FIFO_HASH_FUNC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pFifoHashFuncArg->result = FIFO_HASH(pFifoHashFuncArg->handle, pFifoHashFuncArg->chid);

    return (RM_OK);    
}

RM_STATUS
nvHalFifoHashSearch_NV20(VOID *arg)
{
    PFIFOHASHSEARCHARG_000 pFifoHashSearchArg = (PFIFOHASHSEARCHARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PPRAMHALINFO pPramHalInfo;
    HASH_TABLE_ENTRY *hwHashTable;
    U032 Entry;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashSearchArg->id != FIFO_HASH_SEARCH_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoHashSearchArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pPramHalInfo = pHalHwInfo->pPramHalInfo; 
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(0) + pFbHalPvtInfo->hashTableAddr);

    pFifoHashSearchArg->result = 0x0;

    // Attempt to find a valid entry in the Hash (checking Name and ChID)
    for (Entry = 0; Entry < pPramHalInfo->HashDepth; Entry++)
    {
        if (REG_RD32(&hwHashTable[Entry].ht_ObjectHandle) == pFifoHashSearchArg->handle)
        {
            U032 chid, valid;
            U032 context = REG_RD32(&hwHashTable[Entry].ht_Context);
             
            chid  = context >> SF_SHIFT(NV_RAMHT_CHID) & SF_MASK(NV_RAMHT_CHID);
            valid = context >> SF_SHIFT(NV_RAMHT_STATUS) & SF_MASK(NV_RAMHT_STATUS);

            if ((valid == NV_RAMHT_STATUS_VALID) && (chid == pFifoHashSearchArg->chid))
            {
                pFifoHashSearchArg->result = context;
                break;
            }
        }
    }

    return (RM_OK);    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\gr\nv\grobj.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GROBJ.C                                                           *
*   The graphics engine is managed in this module.  Graphics objects are    *
*   created and deleted here.  Graphics object methods are implemented      *
*   also contained here.                                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <btree.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <dac.h>
#include <gr.h>
#include <modular.h>   
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "smp.h"

//
// Degubbing macros.
//
#ifdef DEBUG
#define VALIDATE_GROBJ(go)  \
if (((POBJECT)go)->Name < 4096) \
{                           \
    GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Invalid graphics object name!\n\r")); \
    DBG_BREAKPOINT();       \
}
#else
#define VALIDATE_GROBJ(go)
#endif //  DEBUG
//
// Externs.
//
// extern PGRAPHICSCHANNEL grTable;
//
// The canvas tree.
//
// PNODE grCanvasTree;

//
// Class lock macros.
//

#define GRCLASSLOCK_ISSET(pdev,chid,bit)    (((U032 *)(pDev->Graphics.ClassLocks))[chid] & (1 << bit))
#define GRCLASSLOCK_SET(pdev,chid,bit)      (((U032 *)(pDev->Graphics.ClassLocks))[chid] |= (1 << bit))
#define GRCLASSLOCK_CLEAR(pdev,chid,bit)    (((U032 *)(pDev->Graphics.ClassLocks))[chid] &= ~(1 << bit))

//---------------------------------------------------------------------------
//
//  Create/Delete graphics objects.
//
//---------------------------------------------------------------------------

//
// Ordinal to video switch.
//
RM_STATUS grCreateOrdinal
(
    PHWINFO      pDev,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *GrObject
)
{
    RM_STATUS status;
    U032      i;
    
    status = osAllocMem((VOID **)GrObject, sizeof(ORDINALOBJECT));
    if (status)
        return (status);
    ((PORDINALOBJECT)*GrObject)->Value               = 0;
    ((PORDINALOBJECT)*GrObject)->FanOut              = 0;
    for (i = 0; i < MAX_GRPATCH_FANOUT; i++)
        ((PORDINALOBJECT)*GrObject)->Switch[i]       = 0;
    //
    // Increment the number of ordinals (and thus double buffered apps) in
    // the system.
    //
    pDev->Framebuffer.FlipUsageCount &= 0x7FFFFFFF;
    pDev->Framebuffer.FlipUsageCount++;
    return (RM_OK);
}
RM_STATUS grDeleteOrdinal
(
    POBJECT GrObject
)
{
    return osFreeMem(GrObject);
}

//---------------------------------------------------------------------------
//
//  Canvas routines.
//
//---------------------------------------------------------------------------

VOID grInitCommon(
    PCOMMONOBJECT pCommon,
	U032 Device
)
{
    //
    // Load up the default settings for a new common hardware object
    //
    pCommon->Valid         = FALSE;    
    pCommon->NotifyPending = FALSE;
    pCommon->Instance      = 0;
    pCommon->NotifyObject  = NULL;
    pCommon->Dma0Object    = NULL;
    pCommon->Dma1Object    = NULL;
    pCommon->Next          = NULL;
}

VOID grInitRenderCommon(
    PRENDERCOMMON pRenderCommon
)
{
    //
    // Load up the default settings for a new common render object
    //
    pRenderCommon->Xlate        = NULL;

    //
    // Default out the full patch context
    //
    pRenderCommon->PatchContext.ColorKey    = NULL;
    pRenderCommon->PatchContext.Pattern     = NULL;
    pRenderCommon->PatchContext.Clip        = NULL;
    pRenderCommon->PatchContext.Rop         = NULL;
    pRenderCommon->PatchContext.Beta1       = NULL;
    pRenderCommon->PatchContext.Beta4       = NULL;
    pRenderCommon->PatchContext.Surface     = NULL;
    pRenderCommon->PatchContext.SurfaceSource = NULL;
    pRenderCommon->PatchContext.Operation   = NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_SRCCOPY_AND;
    
}

//
// grIsRenderObject
//
// This routine returns TRUE if the given class is a rendering
// object, FALSE otherwise.
//
static BOOL
grIsRenderObject(U032 class)
{
    switch (class)
    {
        case NV1_BETA_SOLID:
        case NV1_IMAGE_SOLID:
        case NV1_IMAGE_PATTERN:
        case NV1_IMAGE_BLACK_RECTANGLE:
        case NV3_CONTEXT_ROP:
        case NV3_CONTEXT_SURFACE_0:
        case NV3_CONTEXT_SURFACE_1:
        case NV3_CONTEXT_SURFACE_2:
        case NV3_CONTEXT_SURFACE_3:
        case NV4_CONTEXT_SURFACES_2D:
        case NV4_CONTEXT_PATTERN:
        case NV4_CONTEXT_SURFACE_SWIZZLED:
        case NV4_CONTEXT_SURFACES_ARGB_ZS:
        case NV4_CONTEXT_BETA:
        case NV10_CONTEXT_SURFACES_2D:
        case NV10_CONTEXT_SURFACES_3D:
            return FALSE;
        //default:
            // default action is to fall thru
    }
    return TRUE;
}

//
// grCreateObj
//
// Generic graphics engine object creation routine.
//
RM_STATUS
grCreateObj(VOID* pDevHandle, PCLASSOBJECT ClassObject, U032 Name, POBJECT *Object, VOID* pCreateParms)
{
    PHWINFO pDev = (PHWINFO) pDevHandle;
    RM_STATUS status = RM_OK;
    PCOMMONOBJECT pCommonObject;
    PCLASS pClass = ClassObject->Base.ThisClass;
    U032 lockBit;
    U032 instSize, instAlign, size;
    U032 allocFlags;
    BOOL isRenderObj;

    GR_PRINTF((DBG_LEVEL_INFO, "NVRM: grCreateObj class: 0x%x\n", pClass->Type));

    //
    // copy in any allocation parameters from user space
    //

    allocFlags = 0;
    if (pCreateParms)
    {
        NV_GR_ALLOCATION_PARAMETERS grParams;
        status = osCopyIn(pCreateParms, (U008*) &grParams, sizeof(grParams));
        if (status != RM_OK)
            return status;
        allocFlags = grParams.flags;
    }

    //
    // Check per-channel allocation restrictions if applicable.
    //
    lockBit = CLASSDECL_FIELD(*pClass->ClassDecl, _LOCK);
    if (lockBit != NO_LOCK) {
        if (GRCLASSLOCK_ISSET(pDev, ClassObject->Base.ChID, lockBit))
        {
            GR_PRINTF((DBG_LEVEL_INFO, "NVRM: class already exists in channel: 0x%x\n", ClassObject->Base.ChID));
            return (RM_ERR_ILLEGAL_OBJECT);
        }
        GRCLASSLOCK_SET(pDev, ClassObject->Base.ChID, lockBit);
    }

    //
    // Determine if this class is a rendering class (and therefore
    // represented by a RENDERCOMMONOBJECT structure).
    //
    isRenderObj = grIsRenderObject(pClass->Type);

    //
    // Allocate space for object.
    //
    size = (isRenderObj) ? sizeof (RENDERCOMMONOBJECT) : sizeof (COMMONOBJECT);
    status = osAllocMem((VOID **)Object, size);
    if (status)
    {
        GRCLASSLOCK_CLEAR(pDev, ClassObject->Base.ChID, lockBit);
        return (status);
    }

    //
    // A nice cast to make the code more readable.
    //
    pCommonObject = (PCOMMONOBJECT)*Object;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    //
    // Init render object data.
    //
    if (isRenderObj)
        grInitRenderCommon(&((PRENDERCOMMONOBJECT)pCommonObject)->RenderCommon);

    //
    // Allocate instance memory.  The amount allocated is based
    // on two values:  the default size from the engine declaration
    // entry plus any additional space that might be specified via
    // the class instance memory alloc entry.
    //
    // Note that graphics objects currently only use the default, but
    // on NV20 the Kelvin class is going to require more than a
    // single paragraph of instance memory.
    //
    // Also factor in any alignment requirements if necessary.
    //
    instSize = ENGDECL_FIELD(*pClass->EngineDecl, _OBJINSTSZ);
    instAlign = 0;
    if (pClass->ClassInstMalloc) {
        instSize += CLASSINSTMALLOC_FIELD(*pClass->ClassInstMalloc, _SIZE);
        instAlign = CLASSINSTMALLOC_FIELD(*pClass->ClassInstMalloc, _ALIGN);
    }

    if (instAlign)
        status = fbAllocInstMemAlign(pDev, &(pCommonObject->Instance), instSize, instAlign);
    else
        status = fbAllocInstMem(pDev, &(pCommonObject->Instance), instSize);

    if (status)
    {
        if (lockBit != NO_LOCK)
            GRCLASSLOCK_CLEAR(pDev, ClassObject->Base.ChID, lockBit);
        osFreeMem(*Object);
        return (status);
    }

    //
    // Let the HAL setup instance memory for the object.
    //
    status = nvHalGrAlloc(pDev, pCommonObject->Base.ChID, pCommonObject->Instance, pClass->Type, allocFlags);
    if (status == RM_OK)
    {
        //
        // Override any HAL initialization here.
        //

        //
        // Build a FIFO/Hash context for this object
        //
        status = fifoUpdateObjectInstance(pDev,
                                          &pCommonObject->Base, 
                                          pCommonObject->Base.ChID, 
                                          pCommonObject->Instance);
    }

    if (status != RM_OK)
    {
        fbFreeInstMem(pDev, pCommonObject->Instance, instSize);
        osFreeMem(*Object);
        GRCLASSLOCK_CLEAR(pDev, ClassObject->Base.ChID, lockBit);
        return (status);
    }
    
    //
    // Object allocation is a possible power mgmt trigger.  Let's go check.
    //
    status = mcPowerStateTrigger(pDev);     // no error recover required

    return (RM_OK);
}

RM_STATUS
grDestroyObj(VOID* pDevHandle, POBJECT Object)
{
    PHWINFO pDev = (PHWINFO) pDevHandle;
    RM_STATUS               status = RM_OK;
    PCOMMONOBJECT           pCommonObject;
    PCLASS                  pClass;
    U032                    lockBit;
    U032                    instSize;

    GR_PRINTF((DBG_LEVEL_INFO, "NVRM: grDestroyObj\r\n"));

    //
    // Just in case...
    //
    if (Object == NULL)
        return (RM_OK);

    //
    // A nice cast to make the code more readable.
    //
    pCommonObject = (PCOMMONOBJECT)Object;

    //
    // Let the HAL do it's cleanup thing.
    //
    pClass = Object->ThisClass;
    nvHalGrFree(pDev, pCommonObject->Base.ChID, pCommonObject->Instance);

    //
    // Invalidate any objects attached to this context
    //
    // !!KJK Only need to do this if we link the contexts to the objects
    //
    // Delete the instance data structure for this object
    //
    instSize = ENGDECL_FIELD(*pClass->EngineDecl, _OBJINSTSZ);
    if (pClass->ClassInstMalloc) {
        instSize += CLASSINSTMALLOC_FIELD(*pClass->ClassInstMalloc, _SIZE);
    }
    
    status = fbFreeInstMem(pDev, pCommonObject->Instance, instSize);
    if (status)
        return (status);
        
    pCommonObject->Instance = 0;

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pCommonObject->Base, pCommonObject->Base.ChID); 
    if (status)
        return (status);
  
    //
    // Clear per-channel allocation restrictions if applicable.
    //
    lockBit = CLASSDECL_FIELD(*pClass->ClassDecl, _LOCK);
    if (lockBit != NO_LOCK) {
        //ASSERT(pDev->Graphics.ClassLocks[pCommonObject->Base.ChID] & (1 << lockBit))
        GRCLASSLOCK_CLEAR(pDev, pCommonObject->Base.ChID, lockBit);
    }
      
    //
    // Object deallocation is a possible power mgmt trigger.  Let's go check.
    //
    status = mcPowerStateTrigger(pDev);  // no error recovery required

    //
    // And finally delete the object itself.
    //    
    return (osFreeMem(Object));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\fifo\nv4\fifonv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** Chip Specific HAL FIFO Routines **********************\
*                                                                           *
* Module: FIFONV04.C                                                        *
*   The NV4 specific HAL FIFO routines reside in this file.                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalFifoControl_NV04(VOID *);
RM_STATUS nvHalFifoAllocPio_NV04(VOID *);
RM_STATUS nvHalFifoAllocDma_NV04(VOID *);
RM_STATUS nvHalFifoFree_NV04(VOID *);
RM_STATUS nvHalFifoGetExceptionData_NV04(VOID *);
RM_STATUS nvHalFifoService_NV04(VOID *);
RM_STATUS nvHalFifoAccess_NV04(VOID *);
RM_STATUS nvHalFifoHashAdd_NV04(VOID *);
RM_STATUS nvHalFifoHashDelete_NV04(VOID *);
RM_STATUS nvHalFifoHashFunc_NV04(VOID *);

//
// The context switch interface is only used internally, but perhaps
// should be made available to the resource manager anyway.
//
static RM_STATUS nvHalFifoContextSwitch_NV04(PHALHWINFO, U032);

static U032 nvHalFifoCalcDmaFetch_NV04(U032, U032, U032);

RM_STATUS
nvHalFifoControl_NV04(VOID *arg)
{
    PFIFOCONTROLARG_000 pFifoControlArg = (PFIFOCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV04 pFifoHalPvtInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoControlArg->id != FIFO_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

	pHalHwInfo = pFifoControlArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalPvtInfo;

    switch (pFifoControlArg->cmd) {
        case FIFO_CONTROL_INIT:
            //
            // Setup default parameters. 
            //
            pFifoHalInfo->RetryCount = 255;
            pFifoHalInfo->UserBase = DEVICE_BASE(NV_USER);
            pFifoHalPvtInfo->Mode = 0;
            pFifoHalPvtInfo->InUse = 0;
            
            //
            // Setup interrupt enable mask.
            //
            pFifoHalInfo->IntrEn0 =
                DRF_DEF(_PFIFO, _INTR_EN_0, _CACHE_ERROR, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _RUNOUT, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _RUNOUT_OVERFLOW, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _DMA_PUSHER, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _DMA_PT, _ENABLED);

            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);
            //
            // Zero DMA FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, 0);
            //
            // Zero FIFO hash valid.
            //
            REG_WR32(NV_PFIFO_CACHE0_HASH, 0);
            REG_WR32(NV_PFIFO_CACHE1_HASH, 0);
            //
            // Zero engine assignments
            //
            //REG_WR32(NV_PFIFO_CACHE0_ENGINE, 0);
            //REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
            //
            // Make all FIFO's default
            //
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
            REG_WR32(NV_PFIFO_DMA, 0);
            REG_WR32(NV_PFIFO_SIZE, 0);
            //
            // Clear all pusher state
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
            //
            // Zero run-out pointers.
            //
            REG_WR_DRF_NUM(_PFIFO, _RUNOUT_PUT, _ADDRESS, 0);
            REG_WR_DRF_NUM(_PFIFO, _RUNOUT_GET, _ADDRESS, 0);
            break;
        case FIFO_CONTROL_LOAD:
            //
            // Update the dma fetch numbers using reasonable defaults.
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, _128_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, _32_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, _15));
            
            //
            // Enable default timeslicing
            //    
            REG_WR32(NV_PFIFO_DMA_TIMESLICE, 
                     DRF_DEF(_PFIFO, _DMA_TIMESLICE, _TIMEOUT, _ENABLED)
                     | DRF_DEF(_PFIFO, _DMA_TIMESLICE, _SELECT, _128K));
            
            //
            // Set retry delay to match common hardware latency.
            //
            REG_WR_DRF_NUM(_PFIFO, _DELAY_0, _WAIT_RETRY, pFifoHalInfo->RetryCount);
            //
            // Disable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            //
            // Disable pusher and puller access to cache0.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PULL0, _ACCESS, _DISABLED);
            //
            // Disable pusher and puller access to cache1.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(3, 0, 0);
            //
            // Disable the pusher, if active
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);
            
            //
            // Force a context switch to PRAMIN.
            //
            // KJK This should be replaced with a full software-based context switch
            //
            nvHalFifoContextSwitch_NV04(pHalHwInfo, (NUM_FIFOS_NV04 - 1));
            
            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);

            //
            // Enable pusher and puller access to cache1.
            //
            FIFOLOG(3, 1, 0);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _ENABLED);
            //
            // Delay for slow CACHE1_PULL.
            //
            //temp = REG_RD32(NV_PFIFO_CACHE1_PULL0);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _ENABLED);
            //
            // Enable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _ENABLED);
            break;
        case FIFO_CONTROL_UNLOAD:
            //
            // Disable dma timeslicing
            //    
            REG_WR32(NV_PFIFO_DMA_TIMESLICE, DRF_DEF(_PFIFO, _DMA_TIMESLICE, _TIMEOUT, _DISABLED));

            //
            // Empty FIFO and runout.
            //
            while ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) != NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
                   || (REG_RD_DRF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK) != NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY)
                   || (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY))
            {
                //
                // Make sure we process any fifo interrupts
                //
                HALRMSERVICEINTR(pHalHwInfo, FIFO_ENGINE_TAG);
                
                //
                // Check if GE needs servicing.
                //
                if (REG_RD32(NV_PGRAPH_INTR))
                    HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);
            }

            //
            // Disable the dma pusher, if active
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);

            //
            // Wait til idle
            //
            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
			    ;

            //
            // Disable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            //
            // Disable pusher and puller access to cache0.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PULL0, _ACCESS, _DISABLED);
            //
            // Disable pusher and puller access to cache1.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(3, 0, 0);
            //
            // Force a context switch to PRAMIN.
            //
            // KJK This should be replaced with a full software-based context switch
            //
            nvHalFifoContextSwitch_NV04(pHalHwInfo, (NUM_FIFOS_NV04 - 1));
            
            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);
            
            //
            // Flush all FIFOs.
            //
            FifoReassign = REG_RD32(NV_PFIFO_CACHES);
            FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
            FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(1, 0, 0);

            //
            // Update the FIFO context and its dirty bits.  By moving the get pointer to the current
            // put value, we are flushing any pending push data that hasn't been fetched yet.
            //
            for (i = 0; i < NUM_FIFOS_NV04; i++)
            {
                if (pFifoHalPvtInfo->InUse & (1 << i))
                {
                    REG_WR32((U032)(pFbHalPvtInfo->fifoContextAddr + (i * 32) + SF_OFFSET(NV_RAMFC_DMA_GET)), 
                             REG_RD32((U032)(pFbHalPvtInfo->fifoContextAddr + (i * 32) + SF_OFFSET(NV_RAMFC_DMA_PUT))));

                    //
                    // Also, when setting the channels get pointer equal to its put, ensure the next
                    // DWORD is interpreted as a command (and not data) by clearing RAMFC_DMA_METHOD.
                    //
                    REG_WR32((U032)(pFbHalPvtInfo->fifoContextAddr + (i * 32) + SF_OFFSET(NV_RAMFC_DMA_METHOD)), 0x0);
                }
            }

            //
            // Restore CACHE1 state.
            //
            FIFOLOG(1, FifoPull, FifoReassign);
            REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
            REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
            REG_WR32(NV_PFIFO_CACHES, FifoReassign);

            //
            // Flush all pending
            //
            REG_WR32(NV_PFIFO_DMA, 0);
            
            //
            // Disable all FIFO interrupts.
            //
            REG_WR32(NV_PFIFO_INTR_EN_0, 0);
            break;
        case FIFO_CONTROL_DESTROY:
            break;
        case FIFO_CONTROL_UPDATE:
            //
            // Update the dma fetch numbers
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, _128_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, _32_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, _15));
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

RM_STATUS
nvHalFifoAllocPio_NV04(VOID *arg)
{
    PFIFOALLOCPIOARG_000 pFifoAllocPioArg = (PFIFOALLOCPIOARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    PFIFOHALINFO_NV04 pFifoHalPvtInfo;
    U032 CacheData, InitCtxtPtr;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoAllocPioArg->id != FIFO_ALLOC_PIO_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
	pHalHwInfo = pFifoAllocPioArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalPvtInfo;

    //
    // Disable cache reassignment.
    //
    CacheData = REG_RD32(NV_PFIFO_CACHES);
    REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _DISABLED);

    //
    // Initialize freshly allocated FIFO context.
    //
    InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr + (pFifoAllocPioArg->chid * 32);
    for (i = 0; i < 8; i++)
    {
        REG_WR32(InitCtxtPtr+(i*4), 0);
    }

    //
    // Set MODE to pio.
    //
    pFifoHalPvtInfo->Mode &= ~(1 << pFifoAllocPioArg->chid);
    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

    //
    // Is this channel in use?
    //
    if ((pFifoHalInfo->AllocateCount++ == 0)
     || (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoAllocPioArg->chid))
    {
        //
        // Disable cache1.
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        //
        // Set initial cache parameters.
        //
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID,    pFifoAllocPioArg->chid);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT,   _ADDRESS, 0);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_GET,   _ADDRESS, 0);
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        //
        // Enable cache1.
        //
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS,   _ENABLED);
        CacheData = DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _ENABLED);
    }

    //
    // Restore previous cache reassignability.
    //
    REG_WR32(NV_PFIFO_CACHES, CacheData);

    //
    // Mark channel as allocated.
    //
    pFifoHalPvtInfo->InUse |= (1 << pFifoAllocPioArg->chid);

    return (RM_OK);
}

//
// nvHalFifoCalcDmaFetch
//
// Derive chip-dependent DMA fetch parameter register value
// from values specified at channel allocation time.
//
U032
nvHalFifoCalcDmaFetch_NV04(U032 fetchTrigger, U032 fetchSize, U032 fetchRequests)
{
    U032 dmaFetch;

    //
    // Input trigger value is in bytes.
    // Hardware value must be specified in increments of 8 between
    // 8 - 256 bytes.
    //
    if (fetchTrigger < 8) fetchTrigger = 8;
    if (fetchTrigger > 256) fetchTrigger = 256;
    fetchTrigger = (fetchTrigger / 8) - 1;

    //
    // Input size value is in bytes.
    // Hardware value must be specified in increments of 32
    // between 32 - 256 bytes.
    //
    if (fetchSize < 32) fetchSize = 32;
    if (fetchSize > 256) fetchSize = 256;
    fetchSize = (fetchSize / 32) - 1;

    //
    // Requests must be between 0 and 15.
    //
    if (fetchRequests > 15) fetchRequests = 15;

    //
    // Put it all together.
    //
    dmaFetch = DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, fetchTrigger) |
        DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, fetchSize) |
        DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, fetchRequests);

    return dmaFetch;
}

RM_STATUS
nvHalFifoAllocDma_NV04(VOID *arg)
{
    PFIFOALLOCDMAARG_000 pFifoAllocDmaArg = (PFIFOALLOCDMAARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    PFIFOHALINFO_NV04 pFifoHalPvtInfo;
    U032 CacheData, InitCtxtPtr;
    U032 DefaultFetch;
    U032 DmaContext;
    U032 i;

    //
    // Verify interface revision.
    //
    if (pFifoAllocDmaArg->id != FIFO_ALLOC_DMA_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
	pHalHwInfo = pFifoAllocDmaArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalPvtInfo;

    //
    // Validate push buffer state.
    //
    DmaContext = INST_RD32(pFifoAllocDmaArg->dmaInstance, SF_OFFSET(NV_DMA_CLASS));
    if (SF_VAL(_DMA, _TARGET_NODE, DmaContext) == NV_DMA_TARGET_NODE_NVM)
        return (RM_ERR_BAD_OBJECT_BUFFER);

    //
    // Disable cache reassignment.
    //
    CacheData = REG_RD32(NV_PFIFO_CACHES);
    REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _DISABLED);
    
    //
    // Initialize freshly allocated FIFO context.
    //
    InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr + (pFifoAllocDmaArg->chid * 32);
    for (i = 0 ; i < 8 ; i++ )
    {
        REG_WR32(InitCtxtPtr+(i*4), 0);
    }

    //
    // Insert the instance (note that the rest of the context can start as zero)
    //
    REG_WR32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_INST)), pFifoAllocDmaArg->dmaInstance);

    FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: nvHalFifoAllocateDma_NV04 - CACHE1 currently mapped to ChID: 0x%x\n", REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID)));
    
    //
    // Adjust fetch max request (exception to the "all start as zero" rule)
    //
    DefaultFetch = nvHalFifoCalcDmaFetch_NV04(pFifoAllocDmaArg->fetchTrigger, pFifoAllocDmaArg->fetchSize, pFifoAllocDmaArg->fetchRequests);
    REG_WR32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG)), DefaultFetch);
    
    //
    // Set channel mode to dma
    //
    pFifoHalPvtInfo->Mode |= (1 << pFifoAllocDmaArg->chid);
    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

    //
    // Is this channel in use?
    //
    if ((pFifoHalInfo->AllocateCount++ == 0)
     || (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoAllocDmaArg->chid))
    {
        //
        // KJK Warning!!  We're getting in here if this is the first (0)
        // channel allocated in the system due to the checks above.
        // We really shouldn't be...
        //
        
        //
        // Disable cache1.
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        //
        // Set initial cache parameters.
        //
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID,   pFifoAllocDmaArg->chid);
        
        if (pFifoHalPvtInfo->Mode & (1 << pFifoAllocDmaArg->chid))
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA); 
        
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_DMA_PUT, _OFFSET, 0);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_DMA_GET, _OFFSET, 0);
        
        REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, pFifoAllocDmaArg->dmaInstance);

        //
        // Force a reload of the PTE's
        //
        REG_WR32(NV_PFIFO_CACHE1_DMA_CTL, 0);
        
        //
        // Clear all pusher state
        //
        REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
        
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        
        //
        // Set default watermarks
        //
        //REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 0x000F6068);
        REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, DefaultFetch);
        
        //
        // Enable cache1.
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoAllocDmaArg->chid))
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);
        
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS,   _ENABLED);
        CacheData = DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _ENABLED);
    }

    //
    // Restore previous cache reassignability.
    //
    REG_WR32(NV_PFIFO_CACHES, CacheData);

    //
    // Mark channel as allocated.
    //
    pFifoHalPvtInfo->InUse |= (1 << pFifoAllocDmaArg->chid);

    return (RM_OK);
}

RM_STATUS
nvHalFifoFree_NV04(VOID *arg)
{
    PFIFOFREEARG_000 pFifoFreeArg = (PFIFOFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV04 pFifoHalPvtInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 InitCtxtPtr;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoFreeArg->id != FIFO_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of the argument structure.
    //
	pHalHwInfo = pFifoFreeArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalPvtInfo;

    //
    // Save CACHE1 state.
    //
    FifoReassign = REG_RD32(NV_PFIFO_CACHES);
    FifoPush     = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    FifoPull     = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    REG_WR_DRF_DEF(_PFIFO, _CACHES,       _REASSIGN, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
    FIFOLOG(4, 0, 0);

    //
    // Update the FIFO context and its dirty bits.
    //    
    if (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoFreeArg->chid)
    {
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        
        //
        // If this is a dma channel, we need to shut him down and clear out
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoFreeArg->chid))
        {
            //
            // Disable dma pusher activity
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUSH, 0);
            
            //
            // Wait til idle
            //
            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
			    ;
            
            //
            // Now zero everything out
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_TLB_PTE, 0);
            
            //
            // Move this channel back to PIO.  This way any inadvertant writes will go to runout.
            //
            pFifoHalPvtInfo->Mode &= ~(1 << pFifoFreeArg->chid);
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
        }        
    }
    else
    {
        //
        // Flush the context into the FIFO context RAM.
        //
        InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr + (pFifoFreeArg->chid * 32);
        for (i = 0; i < 8; i++)
        {
            REG_WR32(InitCtxtPtr+(4*i), 0);
        }
        
        //
        // If this is a dma channel, make sure we clear any pending pushing
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoFreeArg->chid))
        {
            //
            // Clear any pending transfers
            //
            REG_WR32(NV_PFIFO_DMA, REG_RD32(NV_PFIFO_DMA) & (~(1 << pFifoFreeArg->chid)));
            
            //
            // Move this channel back to PIO.  This way any inadvertant writes will go to runout.
            //
            pFifoHalPvtInfo->Mode &= ~(1 << pFifoFreeArg->chid);
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
        }
    }

    //
    // Restore CACHE1 state.
    //
    FIFOLOG(4, FifoPull, FifoReassign);
    REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
    REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    REG_WR32(NV_PFIFO_CACHES, FifoReassign);

    //
    // Free up channel.
    //
    pFifoHalPvtInfo->InUse &= ~(1 << pFifoFreeArg->chid);

    pFifoHalInfo->AllocateCount--;

    return (RM_OK);
}

//
// nvHalFifoContextSwitch
//
// Context switch the fifo.
//
static RM_STATUS
nvHalFifoContextSwitch_NV04(PHALHWINFO pHalHwInfo, U032 ChID)
{
    PFIFOHALINFO_NV04 pFifoHalPvtInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalPvtInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 CurrentChID;
    U032 PushPending;
    U032 CtxtPtr = (U032)pFbHalPvtInfo->fifoContextAddr;

    //if (id != FIFO_CONTEXT_SWITCH)
    //    return (HAL_ERROR);

    //
    // Save CACHE1 state.
    //
    FifoReassign = REG_RD32(NV_PFIFO_CACHES);
    FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
    FIFOLOG(1, 0, 0);
    
    //
    // Make sure our local (rm) contexts are up to date for the outgoing channel
    //
    CurrentChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID); 

    FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: Manually saving the FIFO context on ChID: 0x%x\n", CurrentChID));

    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_PUT)), REG_RD32(NV_PFIFO_CACHE1_DMA_PUT));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_GET)), REG_RD32(NV_PFIFO_CACHE1_DMA_GET));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_INST)), REG_RD32(NV_PFIFO_CACHE1_DMA_INSTANCE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_METHOD)), REG_RD32(NV_PFIFO_CACHE1_DMA_STATE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG)), REG_RD32(NV_PFIFO_CACHE1_DMA_FETCH));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_ENGINE_SUB_0)), REG_RD32(NV_PFIFO_CACHE1_ENGINE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_PULL1_ENGINE)), REG_RD32(NV_PFIFO_CACHE1_PULL1));
    
    //
    // If this is a push channel and put != get, make sure to set the push pending flag
    //
    if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
    {    
        PushPending = REG_RD32(NV_PFIFO_DMA) & ~(1 << CurrentChID);
        if (REG_RD32(NV_PFIFO_CACHE1_DMA_PUT) != REG_RD32(NV_PFIFO_CACHE1_DMA_GET))
            PushPending |= (1 << CurrentChID);
        REG_WR32(NV_PFIFO_DMA, PushPending);
    }                    
    
    //
    // Bring in the context for the new channel from the fifo context ram.
    //
    FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: Manually restoring the FIFO context on ChID: 0x%x\n", ChID));

    //
    // Update the channel and if it's DMA, set the mode
    //
    REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID, ChID);
    if ((pFifoHalPvtInfo->Mode & (1 << ChID)) && (ChID != (NUM_FIFOS_NV04 - 1)))
        FLD_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA); 
    
    REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_PUT))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_GET, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_GET))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_INST))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_METHOD))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG))));
    REG_WR32(NV_PFIFO_CACHE1_ENGINE, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_ENGINE_SUB_0))));
    REG_WR32(NV_PFIFO_CACHE1_PULL1, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_PULL1_ENGINE))));
         
    //
    // If DMA, enable the DMA Pusher
    //
    if ((pFifoHalPvtInfo->Mode & (1 << ChID)) && (ChID != (NUM_FIFOS_NV04 - 1)))
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);

    //
    // In case there are dma pusher channels still pending, give this
    // new channel enough time to do something useful before it gets
    // yanked back out again.
    //
    REG_WR32(NV_PFIFO_TIMESLICE, 0x1fffff);     
           
    //
    // Restore CACHE1 state.
    //
    FIFOLOG(1, FifoPull, FifoReassign);
    REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
    REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    REG_WR32(NV_PFIFO_CACHES, FifoReassign);

    return (RM_OK);
}

//
// nvHalFifoGetExceptionData
//
RM_STATUS
nvHalFifoGetExceptionData_NV04(VOID *arg)
{
    PFIFOGETEXCEPTIONDATAARG_000 pFifoGetExceptionDataArg = (PFIFOGETEXCEPTIONDATAARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOEXCEPTIONDATA pFifoExceptionData;
    U032 GetPtr;

    //
    // Verify interface revision.
    //
    if (pFifoGetExceptionDataArg->id != FIFO_GET_EXCEPTION_DATA_000)
        return (RM_ERR_VERSION_MISMATCH);

	pHalHwInfo = pFifoGetExceptionDataArg->pHalHwInfo;
    pFifoExceptionData = pFifoGetExceptionDataArg->pExceptionData;

    //
    // Fill in exception data.
    //
    pFifoExceptionData->Reason = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    pFifoExceptionData->ChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID);
    GetPtr = REG_RD32(NV_PFIFO_CACHE1_GET) >> 2;
    pFifoExceptionData->GetPtr = GetPtr;
    pFifoExceptionData->SubChannel =
        (((REG_RD32(NV_PFIFO_CACHE1_METHOD(GetPtr))) >> DRF_SHIFT(NV_PFIFO_CACHE1_METHOD_SUBCHANNEL)) & 
         DRF_MASK(NV_PFIFO_CACHE1_METHOD_SUBCHANNEL));
    pFifoExceptionData->Method = REG_RD32(NV_PFIFO_CACHE1_METHOD(GetPtr)) & 0x1FFC;
    pFifoExceptionData->Data = REG_RD32(NV_PFIFO_CACHE1_DATA(GetPtr));

    return (RM_OK);
}

//
// nvHalFifoService
//
RM_STATUS
nvHalFifoService_NV04(VOID *arg)
{
    PFIFOSERVICEARG_000 pFifoServiceArg = (PFIFOSERVICEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOEXCEPTIONDATA pFifoExceptionData;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV04 pFifoHalPvtInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;

    //
    // Verify interface revision.
    //
    if (pFifoServiceArg->id != FIFO_SERVICE_000)
        return (RM_ERR_VERSION_MISMATCH);
    
 	pHalHwInfo = pFifoServiceArg->pHalHwInfo;
    pFifoExceptionData = pFifoServiceArg->pExceptionData;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalPvtInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;

    //
    // Now service any exceptions that we'd like to handle w/i the HAL.
    //
    if (pFifoServiceArg->intr & DRF_DEF(_PFIFO, _INTR_0, _RUNOUT, _PENDING))
    {
        U032 GetPtr;
        U032 ChID;
        U032 SubChannel;
        U032 Type;
        U032 Reason;
        U032 Method;
        U032 Data;
        U032 FifoPush, wasDmaChannel = 0;
        U032 noValidRunoutData = 1;     // assume it's all junk

        //
        // Deal with data in runout.
        //
        FIFO_PRINTF((DBG_LEVEL_USERERRORS, "NVRM: Cache ranout.  Waiting for cache to drain.\n\r"));
        FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM:         CACHE1 ChID = 0x%x\n", REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID)));

        //
        // Don't allow another channel to switch in
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHES,       _REASSIGN, _DISABLED);

        //
        // Disable CACHE1_PUSH0, so we're able to safely resubmit the runout method/data
        // back into the CACHE1 below.
        // 
        FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
        
        //
        // If this is a DMA channel, start to shut down the current pushing
        //
        if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
        {
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);
            wasDmaChannel = 1;      // started this interrupt as a DMA channel
        }
            
        //
        // First wait for cache to drain and the dma pusher to be idle
        //
        if ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) == NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY) &&
            (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_IDLE))
        {            
            //
            // Cache is empty.  Deal with data in runout.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
            FIFOLOG(1, 0, 0);

            //
            // Since the CACHE1 has been idled, let's move its PUT/GET to the top
            // of the FIFO avoiding any overflow issues during the resubmit.
            //
#ifdef DEBUG
            if (REG_RD32(NV_PFIFO_CACHE1_PUT) != REG_RD32(NV_PFIFO_CACHE1_GET))
                DBG_BREAKPOINT();
#endif // DEBUG

            REG_WR32(NV_PFIFO_CACHE1_PUT, 0x0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0x0);

            //
            // Because we've taken the trouble to idle everything, rather than dump
            // a single method/data into the CACHE1 and wait, we'll resubmit all the
            // outstanding runout method/data back into the CACHE1.
            //
            FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: RunOut_PUT        = 0x%x\n", REG_RD32(NV_PFIFO_RUNOUT_PUT)));
            FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: RunOut_GET        = 0x%x\n", REG_RD32(NV_PFIFO_RUNOUT_GET)));

            while (REG_RD32(NV_PFIFO_RUNOUT_PUT) != REG_RD32(NV_PFIFO_RUNOUT_GET))
            {
                //
                // Read FIFO state.
                //
                GetPtr     = REG_RD32(NV_PFIFO_RUNOUT_GET);
                Data       = REG_RD32(pFbHalPvtInfo->fifoRunoutAddr + GetPtr);
                FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM:       RunOut Method = 0x%x\n", Data));

                ChID       = SF_VAL(_RAMRO, _CHID, Data);
                Type       = SF_VAL(_RAMRO, _TYPE, Data);
                Reason     = SF_VAL(_RAMRO, _REASON, Data);
                Method     = SF_VAL(_RAMRO, _METHOD, Data) & 0x1FFF;
                SubChannel = SF_VAL(_RAMRO, _SUBCHANNEL, Data) & 0x7;

                Data       = REG_RD32(pFbHalPvtInfo->fifoRunoutAddr + GetPtr + 4);
                FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM:       RunOut Data   0x%x\n= ", Data));

                //
                // Set user cache state to look just as if the runout came
                // from the bottom on the FIFO.  This keeps the OBJECT_CHANGED
                // bits in order.
                //
                if ((Type   == NV_RAMRO_TYPE_WRITE)
                    && (Reason != NV_RAMRO_REASON_ILLEGAL_ACCESS)
                    && (Reason != NV_RAMRO_REASON_RESERVED_ACCESS))
                {
                    if ((ChID < NUM_FIFOS_NV04) && (pFifoHalPvtInfo->InUse & (1 << ChID)))
                    {
                        U032 Cache1Put;

                        //
                        // We've got valid runout, so we'll be resubmitting
                        // something during this loop.
                        //
                        noValidRunoutData = 0;

                        //
                        // Since the fifo engine/resmgr no longer tracks object context on a per-subchannel
                        // basis, the only thing we can do with runout methods is to send them back down
                        // the main user fifo.
                        //
                        // Do we need to force a channel change?
                        //
                    
                        if (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) != ChID)
                        {
                            nvHalFifoContextSwitch_NV04(pHalHwInfo, ChID);

                            //
                            // If we started out the interrupt as a DMA channel and have switched into
                            // a PIO channel, make sure to clear the SUSPEND bit (but don't reenable). 
                            // The HW likes to see this bit cleared after an intr and since we now look
                            // like a PIO channel, we'll just clear it here.
                            // 
                            if (wasDmaChannel && (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _MODE) == 0))
                                FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _STATUS, _RUNNING);
                        }

                        //
                        // Resubmit
                        //
                        Cache1Put = REG_RD_DRF(_PFIFO, _CACHE1_PUT, _ADDRESS);
                        FIFO_PRINTF((DBG_LEVEL_INFO,
                                                   "NVRM: Cache runout resubmit to CACHE1 addr:0x%x\n", Cache1Put << 2));

                        REG_WR32(NV_PFIFO_CACHE1_METHOD(Cache1Put), 
                            Method | DRF_NUM(_PFIFO, _CACHE0_METHOD, _SUBCHANNEL, SubChannel));
                        REG_WR32(NV_PFIFO_CACHE1_DATA(Cache1Put), Data);

                        //
                        // Update the CACHE1 Put ptr.
                        // There are no overflow worries, since we started at the top of the CACHE1
                        //
                        Cache1Put++;
                        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT, _ADDRESS, Cache1Put);
                    }
                    else
                    {
                        FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: Access to free channel: 0x%x\n", ChID));
                        FIFO_PRINTF((DBG_LEVEL_INFO, "                 sub channel: 0x%x\n", SubChannel));
                        FIFO_PRINTF((DBG_LEVEL_INFO, "                      offset: 0x%x\n", Method));
                        FIFO_PRINTF((DBG_LEVEL_INFO, "                        data: 0x%x\n", Data));
                        DBG_BREAKPOINT();
                    }
                }
            
                //
                // Advance the RunOut get pointer.
                //
                GetPtr = (GetPtr + 8) & pFbHalPvtInfo->fifoRunoutMask;
                REG_WR32(NV_PFIFO_RUNOUT_GET, GetPtr);
                GetPtr = REG_RD32(NV_PFIFO_RUNOUT_GET);      // flush delay to update runout_status
            }

            //
            // Clear condition if no more data in runout.
            //
            if (REG_RD32(NV_PFIFO_RUNOUT_STATUS) & DRF_DEF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK, _EMPTY))
            {
                FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: RunOut has CAUGHT UP: 0x%x\n", GetPtr));
                REG_WR_DRF_DEF(_PFIFO, _INTR_0, _RUNOUT, _RESET);
            } else {
                FIFO_PRINTF((DBG_LEVEL_INFO, "NVRM: RunOut should be CAUGHT UP: 0x%x\n", GetPtr));
                DBG_BREAKPOINT();
            }

            //
            // If we interrupted a dma channel and didn't do anything,
            // then be sure we leave the DMA push access enabled.
            //
            if (wasDmaChannel && noValidRunoutData)
                REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);
        }
        else
        {
            //
            // Enable the puller to empty the cache.
            //
            FIFOLOG(1, 1, 0);
            REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _ENABLED);
        }

        // restore CACHE1_PUSH0 state
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    }
    return (RM_OK);
}

//
// nvHalFifoAccess
//
RM_STATUS
nvHalFifoAccess_NV04(VOID *arg)
{
    PFIFOACCESSARG_000 pFifoAccessArg = (PFIFOACCESSARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOACCESSINFO pFifoAccessInfo;

    //
    // Verify interface revision.
    //
    if (pFifoAccessArg->id != FIFO_ACCESS_000)
        return (RM_ERR_VERSION_MISMATCH);

	pHalHwInfo = pFifoAccessArg->pHalHwInfo;
    pFifoAccessInfo = pFifoAccessArg->pAccessInfo;

    switch (pFifoAccessArg->cmd) {
    case FIFO_ACCESS_DISABLE:
        pFifoAccessInfo->FifoReassign = REG_RD32(NV_PFIFO_CACHES);
        pFifoAccessInfo->FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
        pFifoAccessInfo->FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
        REG_WR_DRF_DEF(_PFIFO, _CACHES,       _REASSIGN, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
        break;
    case FIFO_ACCESS_ENABLE:
        REG_WR32(NV_PFIFO_CACHE1_PULL0, pFifoAccessInfo->FifoPull);
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, pFifoAccessInfo->FifoPush);
        REG_WR32(NV_PFIFO_CACHES, pFifoAccessInfo->FifoReassign);
        break;
    default:
        return (RM_ERR_BAD_ARGUMENT);
    }
    return (RM_OK);
}

//
// nvHalFifoHashAdd
//
RM_STATUS
nvHalFifoHashAdd_NV04(VOID *arg)
{
    PFIFOHASHADDARG_000 pFifoHashAddArg = (PFIFOHASHADDARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashAddArg->id != FIFO_HASH_ADD_000)
        return (RM_ERR_VERSION_MISMATCH);

	pHalHwInfo = pFifoHashAddArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo; 
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(0) + pFbHalPvtInfo->hashTableAddr);

    REG_WR32(&hwHashTable[pFifoHashAddArg->entry].ht_ObjectHandle, pFifoHashAddArg->handle);
    REG_WR32(&hwHashTable[pFifoHashAddArg->entry].ht_Context, (pFifoHashAddArg->instance & SF_MASK(NV_RAMHT_INSTANCE)) |
                                                   (pFifoHashAddArg->engine << SF_SHIFT(NV_RAMHT_ENGINE)) |
                                                   (pFifoHashAddArg->chid << SF_SHIFT(NV_RAMHT_CHID)) |
                                                   (NV_RAMHT_STATUS_VALID << SF_SHIFT(NV_RAMHT_STATUS)));
    
    return (RM_OK);
}

//
// nvHalHashDelete
//
RM_STATUS
nvHalFifoHashDelete_NV04(VOID *arg)
{
    PFIFOHASHDELETEARG_000 pFifoHashDeleteArg = (PFIFOHASHDELETEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashDeleteArg->id != FIFO_HASH_DELETE_000)
        return (RM_ERR_VERSION_MISMATCH);

	pHalHwInfo = pFifoHashDeleteArg->pHalHwInfo;

    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(0) + pFbHalPvtInfo->hashTableAddr);

    REG_WR32(&hwHashTable[pFifoHashDeleteArg->entry].ht_ObjectHandle, 0);
    REG_WR32(&hwHashTable[pFifoHashDeleteArg->entry].ht_Context, 0);

    return (RM_OK);
}

RM_STATUS
nvHalFifoHashFunc_NV04(VOID *arg)
{
    PFIFOHASHFUNCARG_000 pFifoHashFuncArg = (PFIFOHASHFUNCARG_000)arg;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashFuncArg->id != FIFO_HASH_FUNC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pFifoHashFuncArg->result = FIFO_HASH(pFifoHashFuncArg->handle, pFifoHashFuncArg->chid);

    return (RM_OK);    
}

RM_STATUS
nvHalFifoHashSearch_NV04(VOID *arg)
{
    PFIFOHASHSEARCHARG_000 pFifoHashSearchArg = (PFIFOHASHSEARCHARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PPRAMHALINFO pPramHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;
    U032 Entry;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashSearchArg->id != FIFO_HASH_SEARCH_000)
        return (RM_ERR_VERSION_MISMATCH);

	pHalHwInfo = pFifoHashSearchArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    pPramHalInfo = pHalHwInfo->pPramHalInfo; 
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(0) + pFbHalPvtInfo->hashTableAddr);

    pFifoHashSearchArg->result = 0x0;

    // Attempt to find a valid entry in the Hash (checking Name and ChID)
    for (Entry = 0; Entry < pPramHalInfo->HashDepth; Entry++)
    {
        if (REG_RD32(&hwHashTable[Entry].ht_ObjectHandle) == pFifoHashSearchArg->handle)
        {
            U032 chid, valid;
            U032 context = REG_RD32(&hwHashTable[Entry].ht_Context);
             
            chid  = context >> SF_SHIFT(NV_RAMHT_CHID) & SF_MASK(NV_RAMHT_CHID);
            valid = context >> SF_SHIFT(NV_RAMHT_STATUS) & SF_MASK(NV_RAMHT_STATUS);

            if ((valid == NV_RAMHT_STATUS_VALID) && (chid == pFifoHashSearchArg->chid))
            {
                pFifoHashSearchArg->result = context;
                break;
            }
        }
    }

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\gr\nv\gr.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GR.C                                                              *
*   The graphics engine is managed in this module.  All priviledged state   *
*   relating to the canvas and datapath is managed here.  Context switching *
*   is also contained here.                                                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <gr.h>
#include <os.h>
#include "nvhw.h"
#ifdef WIN32
#include "nvwin32.h"   // XXX this shouldn't be needed
#else
#define NV_OS_WRITE_THEN_AWAKEN	   0x00000001
#endif

//
// Externs.
//
// extern PGRAPHICSCHANNEL grTable;
//
// Globals.
//
// PVBLANKNOTIFY grVBlankList[2];

//---------------------------------------------------------------------------
//
//  Graphics VBlank servicing.
//
//---------------------------------------------------------------------------

RM_STATUS grWaitVBlank
(
    PHWINFO pDev,
    PVBLANKNOTIFY VBlankNotify,
    U032          buffer
)
{   
    //
    // Check for in-use.
    //
    if (VBlankNotify->Next)
        return (RM_ERR_NOTIFY_IN_USE);
    //
    // Stick this object on the appropriate queue waiting for the next VBlank
    //
    VBlankNotify->Next   = pDev->DBgrVBlankList[buffer];
    pDev->DBgrVBlankList[buffer] = VBlankNotify;
    return (RM_OK);
}
RM_STATUS grVBlank
(
    PHWINFO pDev
)
{
    PVBLANKNOTIFY VBlankNotify;
    PVBLANKNOTIFY VBlankNext;

    //
    // Pull all notifies annd complete them.
    //
    VBlankNotify = pDev->DBgrVBlankList[pDev->Framebuffer.FlipFrom];
    while (VBlankNotify)
    {
        VBlankNext         = VBlankNotify->Next;
        VBlankNotify->Next = NULL;
        VBlankNotify->Proc(pDev, VBlankNotify->Object,
                           VBlankNotify->Param1,
                           VBlankNotify->Param2,
                           RM_OK);
        VBlankNotify = VBlankNext;
    }
    pDev->DBgrVBlankList[pDev->Framebuffer.FlipFrom] = NULL;
    pDev->Framebuffer.FinishFlags = 0;
    return (RM_OK);
}
RM_STATUS grCancelVBlank
(
    PHWINFO pDev,
    PVBLANKNOTIFY VBlankNotify
)
{
    U032          i;
    PVBLANKNOTIFY VBlankMatch;

    for (i = 0; i < 2; i++)
    {
        if (VBlankNotify == pDev->DBgrVBlankList[i])
        {
            pDev->DBgrVBlankList[i] = VBlankNotify->Next;
            VBlankNotify->Next = NULL;
            return (RM_OK);
        }
        else
        {
            VBlankMatch = pDev->DBgrVBlankList[i];
            while (VBlankMatch && VBlankMatch->Next != VBlankNotify)
                VBlankMatch = VBlankMatch->Next;
            if (VBlankMatch)
            {
                VBlankMatch->Next  = VBlankNotify->Next;
                VBlankNotify->Next = NULL;
                return (RM_OK);
            }
        }
    }
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Helper functions.
//
//---------------------------------------------------------------------------

static RM_STATUS grGetLastIllegalMthdObject
(
    PHWINFO pDev,
    U032    ChID,
    U032    Instance,
    POBJECT *cachedObject
)
{
    POBJECT lastObject = pDev->DBfifoTable[ChID].LastIllegalMthdObject;

    *cachedObject = (POBJECT)NULL;
    if (lastObject != (POBJECT)NULL)
    {
        if (ENGDECL_FIELD(*lastObject->Class->EngineDecl, _TAG) == GR_ENGINE_TAG)
        {
            if ((((PCOMMONOBJECT)(lastObject))->Instance & 0xFFFF) == (Instance & 0xFFFF))
            {
                // found it.
                *cachedObject = lastObject;
                return RM_OK;
            }
        }
    }

    // did not find a match.
    return RM_ERR_BAD_OBJECT; 
}

static VOID grSetLastIllegalMthdObject
(
    PHWINFO pDev,
    U032    ChID,
    POBJECT Object
)
{
    pDev->DBfifoTable[ChID].LastIllegalMthdObject = Object;
}
//---------------------------------------------------------------------------
//
//  Graphics engine service.
//
//---------------------------------------------------------------------------

#define BENSWORK

V032 grService
(
    PHWINFO pDev
)
{
    RM_STATUS   status = RM_OK;
    POBJECT     Object = NULL;
    POBJECT     Object2 = NULL;
    PDMAOBJECT  DmaObject;
    V032        Intr;
    U032        Instance, NotifyInstance;
    U032        ChID;
    U032        Class;
    U032        Offset;
    U032        Data;
    U032        NotifySource;
    GREXCEPTIONDATA ExceptionData;
#ifdef BENSWORK
    U032      isDebuggerPresent;
    U032      mustNotifyDebugger;

    isDebuggerPresent  = ((PRMINFO)pDev->pRmInfo)->Debugger.object != NULL;
    mustNotifyDebugger = 0;
#endif

    NVRM_TRACE1('GISR');

    //
    // Disable FIFO from writing to GE and wait for GE idle.
    //
    REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);

    //
    // Waiting for everything in the graphics engine to go idle is too restrictive.  Some
    // exceptions are raised while the offending function has stalled part of the engine,
    // therefore making it impossible to wait for idle.
    //
    // Only wait for idle in the specific interrupt handlers.
    //
    //GR_DONE();

    Intr = REG_RD32(NV_PGRAPH_INTR);

    if (Intr == 0)
        GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics empty interrupt!!\n\r"));
    
    //
    // Query HAL for exception data.
    // any engine-based exceptions.
    //
    nvHalGrGetExceptionData(pDev, &ExceptionData);

    //
    // Here's where we'd bypass HAL gr exception handling if needed.
    // 

    //
    // Give HAL chance to service selected exceptions.
    //
    nvHalGrService(pDev, Intr, &ExceptionData);

    //
    // Refresh interrupt status since HAL may have resolved
    // some (or all) pending conditions.
    //
    if ((Intr = REG_RD32(NV_PGRAPH_INTR)) == 0)
    {
        //
        // Reset FIFO.
        //
        REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);
        NVRM_TRACE3('gisr', 1, Intr);
        return (Intr);
    }

    //
    // Decode exception data.
    //
    Class = ExceptionData.classNum;
    NotifyInstance = ExceptionData.NotifyInstance;
    Instance = ExceptionData.Instance;
    Offset = ExceptionData.Offset;
    Data = ExceptionData.Data;
    ChID = ExceptionData.ChID;
    NotifySource = ExceptionData.Nsource;
    
    //
    // Reset interrupt registers before servicing them.
    //
    REG_WR32(NV_PGRAPH_INTR, Intr);

    //
    // If that was the only reason we're in here, let's leave now.  Most of the object
    // status updates that follow aren't valid when we just context switching.
    //
    if ((Intr == DRF_DEF(_PGRAPH, _INTR, _CONTEXT_SWITCH, _PENDING)) || 
        (Intr == DRF_DEF(_PGRAPH, _INTR, _SINGLE_STEP, _PENDING)))
    {    
        //
        // Reset FIFO.
        //
        REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);
        NVRM_TRACE3('gisr', 2, Intr);
        return REG_RD32(NV_PGRAPH_INTR);
    }
    
    //
    // The rest of the exceptions require that we know what object we're currently using.
    // Convert the object instance into the actual object pointer so we can route everything
    // appropriately.
    // 
    if (!Instance)
    {    
        GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics object instance is zero!!\n\r"));
        DBG_BREAKPOINT();
    }            
    else        
    {        
        status = grGetLastIllegalMthdObject(pDev, ChID, Instance, &Object);
        if (status != RM_OK)
        {
            status = grContextInstanceToObject(pDev, ChID, Instance, &Object);
            if (status)
            {
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics exception with NO valid object\n\r"));
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Status: 0x%x\n", status));
                DBG_BREAKPOINT();
            }
        }
        //
        // Let's take this opportunity to update this object's notify information (ctx and request).
        // This is important information if we (the resmgr) need to perform the notification that
        // wasn't completed by the hardware due to this error condition.
        //
        // We need to convert the instance into a dma object, then plug the dma object
        // into this graphics object.  Also see if a notify is currently pending.
        //
        if (Object && NotifyInstance)
        {        
            status = dmaContextInstanceToObject(pDev, ChID, NotifyInstance, &DmaObject);
            if (status)
                Object->NotifyXlate = NULL;
            else
                Object->NotifyXlate = DmaObject;            
        }                

        //
        // Is there a notify pending in the hardware?
        //
        if ((NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _NOTIFICATION, _PENDING)) && Object)
        {
            GRNOTIFYDATA grNotifyData;

            nvHalGrGetNotifyData(pDev, &grNotifyData);
            if (grNotifyData.trigger == TRUE)
            {
                Object->NotifyTrigger = TRUE;
                Object->NotifyAction = grNotifyData.action;
                if (Object->NotifyXlate == NULL)
                {
                    GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Pending notification with NO valid notifier\n\r"));
                    GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Object: 0x%x\n", Object->Name));
                } else
                    status = notifyMethodComplete(pDev, Object, Offset, Data, RM_OK);

                // we've handled the notify here, so clear the PENDING bit
                NotifySource &= ~DRF_DEF(_PGRAPH, _NSOURCE, _NOTIFICATION, _PENDING);                
            }
        }
    }
    
    //
    // Missing hardware?  Must be a software method.  Route accordingly.
    //
    if ((Intr & DRF_DEF(_PGRAPH, _INTR, _MISSING_HW, _PENDING)) && Object)
    {
    
        //
        // Wait for idle
        //
        GR_DONE();
    
        //
        // Check per-class valid method.
        //
        status = classSoftwareMethod(pDev, Object, Offset, Data);
        if (status)
        {
            GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics software method.\n\r"));
            if (Object)
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics software Object: 0x%x\n", Object->Name));
            GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics software ChID:    0x%x\n", ChID));
            GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics software Class:   0x%x\n", Class));
            GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics software Offset:  0x%x\n", Offset));
            GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics software Data:    0x%x\n", Data));
        }
    }

    //
    // Software assisted notification?
    //
    // Note: only NV10 has a PGRAPH_INTR_ERROR_PENDING bit which also flags
    // illegal method exceptions, but it should be safe to check this on NV4
    // since this'll read back as 0.
    //
    if (((Intr & DRF_DEF(_PGRAPH, _INTR, _NOTIFY, _PENDING)) ||
        (Intr & DRF_DEF(_PGRAPH, _INTR, _ERROR, _PENDING))) && Object)
    {
        //
        // Notification.
        //
        GR_PRINTF((DBG_LEVEL_INFO, "NVRM: Graphics exception handler.\n\r"));
        
        // KJK!! Missing hardware as a protection fault!!
        //
        // Check per-class valid method.
        //
        if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _ILLEGAL_MTHD, _PENDING))
        {        
        
            //
            // Wait for idle
            //
            GR_DONE();
        
            //
            // Convert the incoming data into the object id so the method can handle it.  Remember
            // that the FIFO has done a hash on the incoming data and passed the actual instance
            // pointer to the graphics engine.  Since we need to process based on the original data,
            // we need to convert it back to the original user data.
            //
            if (Offset < 0x200)
            {
                if (!Data)
                    GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics object context data is zero!!\n\r"));
                status = grContextInstanceToObject(pDev, ChID, Data, &Object2);
                if (status)
                {
                    GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics exception with NO valid context\n\r"));
                    GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Status: 0x%x\n", status));
                    DBG_BREAKPOINT();
                }
                if (status == RM_OK && Object2 != NULL)    
                {
                    Data = Object2->Name;
                }
            }                
        
            // Cache this object as the lastIllegalMthdObject.
            grSetLastIllegalMthdObject(pDev, ChID, Object);
            status = classSoftwareMethod(pDev, Object, Offset, Data);
            if (status)
            {
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics software method error!\n\r"));
                if (Object)
                    GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics software Object:  0x%x\n", Object->Name));
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics software ChID:    0x%x\n", ChID));
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics software Class:   0x%x\n", Class));
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics software Offset:  0x%x\n", Offset));
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics software Data:    0x%x\n", Data));

#ifdef BENSWORK // case 1
                // external debugger registered?
                if (isDebuggerPresent)
                {
                    NvdeAppendEventForDebugger ((PNVDEOBJECT)((PRMINFO)pDev->pRmInfo)->Debugger.object,1,3,Object ? Object->Name : ~0,ChID,Class,Offset,Data,0);
                    mustNotifyDebugger = 1;
                }
#endif
            }
        }
        else if (NotifySource)
        {
            // 
            // Determine the notification type.  The hardware will only track the cause, not the
            // type of notification the client has requested.  What is actually be done with this
            // notify (action) is determined by per-object data.
            // 
            //Object->NotifyAction = REG_RD_DRF(_PGRAPH, _NOTIFY, _TYPE);
            
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _NOTIFICATION, _PENDING))
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics software notification pending!\n\r"));
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _DATA_ERROR, _PENDING))
            {
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics invalid data error!\n\r"));
            }
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _PROTECTION_ERROR, _PENDING))
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics surface protection error!\n\r"));
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _RANGE_EXCEPTION, _PENDING))
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics range exception error!\n\r"));
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _LIMIT_COLOR, _PENDING))
            {
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics color buffer limit error!\n\r"));
                if (IsNV20orBetter(pDev))
                    GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: LimitViol: 0x%x\n", REG_RD32(NV_PGRAPH_LIMIT_VIOL_MODE)));

            }
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _LIMIT_ZETA, _PENDING))
            {
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics zeta buffer limit error!\n\r"));
                if (IsNV20orBetter(pDev))
                    GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: LimitViol: 0x%x\n", REG_RD32(NV_PGRAPH_LIMIT_VIOL_MODE)));
            }
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _DMA_R_PROTECTION, _PENDING))
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics dma read protection error!\n\r"));
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _DMA_W_PROTECTION, _PENDING))
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics dma write protection error!\n\r"));
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _FORMAT_EXCEPTION, _PENDING))
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics format exception error!\n\r"));
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _PATCH_EXCEPTION, _PENDING))
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics patch exception error!\n\r"));
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _STATE_INVALID, _PENDING))
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics object state invalid error!\n\r"));
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _DOUBLE_NOTIFY, _PENDING))
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics double notify error!\n\r"));
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _NOTIFY_IN_USE, _PENDING))
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics notify in use error!\n\r"));
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _METHOD_CNT, _PENDING))
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics method count error!\n\r"));
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _BFR_NOTIFICATION, _PENDING))
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics buffer notification error!\n\r"));
            
            GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Nsource: 0x%x\n", NotifySource));
            if (Object)
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Object:   0x%x\n", Object->Name));
            GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM:   ChID:   0x%x\n", ChID));
            GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM:  Class:   0x%x\n", Class));
            GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Offset:   0x%x\n", Offset));
            GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM:   Data:   0x%x\n", Data));
            DBG_BREAKPOINT();
#ifdef BENSWORK // case 2
            // external debugger registered?
            if (isDebuggerPresent)
            {
                NvdeAppendEventForDebugger ((PNVDEOBJECT)((PRMINFO)pDev->pRmInfo)->Debugger.object,2,3,0,0,0,0,0,0);
                mustNotifyDebugger = 1;
            }
            else
            {
                DBG_BREAKPOINT();
            }
#else
            DBG_BREAKPOINT();
#endif
            status = notifyMethodComplete(pDev, Object, Offset, Data, RM_OK);
        }            
    }
    
    //
    // Software assisted buffer notification?
    //    
    if ((Intr & DRF_DEF(_PGRAPH, _INTR, _BUFFER_NOTIFY, _PENDING)) && Object)
    {
    
        //
        // Wait for idle
        //
        GR_DONE();
    
        //
        // Notification.
        //
        GR_PRINTF((DBG_LEVEL_INFO, "NVRM: Graphics buffer software notification\n\r"));
        Object->NotifyTrigger = TRUE;
        // 
        // Determine the notification type.  The hardware will only track the cause, not the
        // type of notification the client has requested.  What is actually be done with this
        // notify (action) is determined by per-object data.
        // 
        //Object->NotifyAction = REG_RD_DRF(_PGRAPH, _NOTIFY, _TYPE);
        //
        // If the notify status is zero (no error), then this must have occurred due to
        // a WRITE_THEN_AWAKEN request
        //
        //if (!REG_RD32(NV_PGRAPH_NSTATUS))
            Object->NotifyAction = NV_OS_WRITE_THEN_AWAKEN;
        status = notifyBufferHWComplete(pDev, Object, Offset, Data, 1, RM_OK);
    }

#ifdef BENSWORK // case 3
    // external debugger registered?
    if (isDebuggerPresent)
    {
        // check for DMA faults on channel A & B
        if ((Intr & DRF_DEF(_PGRAPH, _INTR, _TLB_PRESENT_A, _PENDING))
         || (Intr & DRF_DEF(_PGRAPH, _INTR, _TLB_PRESENT_B, _PENDING)))
        {
            NvdeAppendEventForDebugger ((PNVDEOBJECT)((PRMINFO)pDev->pRmInfo)->Debugger.object,3,3,0,0,0,0,0,0);
            mustNotifyDebugger = 1;
        }
    }
#endif
#ifdef DEBUG
    //
    // DMA Fault on channel A?
    //
    if (Intr & DRF_DEF(_PGRAPH, _INTR, _TLB_PRESENT_A, _PENDING))
    {
    
        GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics DMA TLB not present or valid (A)\n\r"));
    
        GR_PRINTF((DBG_LEVEL_ERRORS, "    DMA_CONTROL    = 0x%x\n", REG_RD32(NV_PGRAPH_DMA_A_CONTROL)));
        GR_PRINTF((DBG_LEVEL_ERRORS, "    DMA_LIMIT      = 0x%x\n", REG_RD32(NV_PGRAPH_DMA_A_LIMIT)));
        GR_PRINTF((DBG_LEVEL_ERRORS, "    DMA_TLB_PTE    = 0x%x\n", REG_RD32(NV_PGRAPH_DMA_A_TLB_PTE)));
        GR_PRINTF((DBG_LEVEL_ERRORS, "    DMA_TLB_TAG    = 0x%x\n", REG_RD32(NV_PGRAPH_DMA_A_TLB_TAG)));
        GR_PRINTF((DBG_LEVEL_ERRORS, "    DMA_ADJ_OFFSET = 0x%x\n", REG_RD32(NV_PGRAPH_DMA_A_ADJ_OFFSET)));
        GR_PRINTF((DBG_LEVEL_ERRORS, "    DMA_OFFSET     = 0x%x\n", REG_RD32(NV_PGRAPH_DMA_A_OFFSET)));
        GR_PRINTF((DBG_LEVEL_ERRORS, "    DMA_SIZE       = 0x%x\n", REG_RD32(NV_PGRAPH_DMA_A_SIZE)));
        GR_PRINTF((DBG_LEVEL_ERRORS, "    DMA_Y_SIZE     = 0x%x\n", REG_RD32(NV_PGRAPH_DMA_A_Y_SIZE)));
        GR_PRINTF((DBG_LEVEL_ERRORS, "    DMA_INSTANCE   = 0x%x\n", REG_RD32(NV_PGRAPH_DMA_A_XLATE_INST)));
    }

    //
    // DMA Fault on channel B?
    //
    if (Intr & DRF_DEF(_PGRAPH, _INTR, _TLB_PRESENT_B, _PENDING))
    {
    
        GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics DMA TLB not present or valid (B)\n\r"));
    
        GR_PRINTF((DBG_LEVEL_ERRORS, "    DMA_CONTROL    = 0x%x\n", REG_RD32(NV_PGRAPH_DMA_B_CONTROL)));
        GR_PRINTF((DBG_LEVEL_ERRORS, "    DMA_LIMIT      = 0x%x\n", REG_RD32(NV_PGRAPH_DMA_B_LIMIT)));
        GR_PRINTF((DBG_LEVEL_ERRORS, "    DMA_TLB_PTE    = 0x%x\n", REG_RD32(NV_PGRAPH_DMA_B_TLB_PTE)));
        GR_PRINTF((DBG_LEVEL_ERRORS, "    DMA_TLB_TAG    = 0x%x\n", REG_RD32(NV_PGRAPH_DMA_B_TLB_TAG)));
        GR_PRINTF((DBG_LEVEL_ERRORS, "    DMA_ADJ_OFFSET = 0x%x\n", REG_RD32(NV_PGRAPH_DMA_B_ADJ_OFFSET)));
        GR_PRINTF((DBG_LEVEL_ERRORS, "    DMA_OFFSET     = 0x%x\n", REG_RD32(NV_PGRAPH_DMA_B_OFFSET)));
        GR_PRINTF((DBG_LEVEL_ERRORS, "    DMA_SIZE       = 0x%x\n", REG_RD32(NV_PGRAPH_DMA_B_SIZE)));
        GR_PRINTF((DBG_LEVEL_ERRORS, "    DMA_Y_SIZE     = 0x%x\n", REG_RD32(NV_PGRAPH_DMA_B_Y_SIZE)));
        GR_PRINTF((DBG_LEVEL_ERRORS, "    DMA_INSTANCE   = 0x%x\n", REG_RD32(NV_PGRAPH_DMA_B_XLATE_INST)));
    }
    
    if (REG_RD32(NV_PGRAPH_INTR) != 0)
    {
        GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Graphics interrupt not completely serviced = 0x%x\n", REG_RD32(NV_PGRAPH_INTR)));
    }
#endif // DEBUG

    //
    // Reset FIFO.
    //
#ifdef BENSWORK
    if (mustNotifyDebugger)
    {
        osNotifyEvent(pDev, ((PRMINFO)pDev->pRmInfo)->Debugger.object, 0, 0, 0, RM_OK, NV_OS_WRITE_THEN_AWAKEN);
    }
    else
    {
#endif
    REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);
#ifdef BENSWORK
    }
#endif

    NVRM_TRACE3('gisr', 3, Intr);
    return REG_RD32(NV_PGRAPH_INTR);
}

//
//  Search for the object matching a given context instance.
//
RM_STATUS grContextInstanceToObject
(
    PHWINFO  pDev,
    U032     ChID,
    U032     Instance,
    POBJECT *GrObject
)
{
    PNODE node;
    U032  engineTag;
    
    *GrObject = NULL;
    
    //
    // Do this brute force.  Search the whole fifo tree for the object.
    // 
    // Go find the minimum value (>0) and start there.  That way we're
    // sure to visit every node.
    //
    btreeEnumStart(0, &node, pDev->DBfifoTable[ChID].ObjectTree);

    while (node != NULL)
    {
        //
        // Get engine tag associated with this object (see nvhal.h for
        // list of valid tags).
        //
        engineTag = ENGDECL_FIELD(*(((POBJECT)(node->Data))->Class)->EngineDecl, _TAG);

        //
        // We only want graphics/software objects, so prune out
        // everything else.
        //
        if (engineTag != CLASS_PSEUDO_ENGINE_TAG && engineTag != NO_ENGINE)
        {
            //
            // Verify the instance
            //
            if ((((PCOMMONOBJECT)(node->Data))->Instance & 0xFFFF) == (Instance & 0xFFFF))
            {
                // FOUND IT!!
                *GrObject = (POBJECT)(node->Data);
                return (RM_OK);
            }
        }

        btreeEnumNext(&node, pDev->DBfifoTable[ChID].ObjectTree);
    }
    
    return (RM_ERR_BAD_OBJECT);
}

//
// Delete the graphics context instance for a given object
//
RM_STATUS grDeleteObjectInstance
(
    PHWINFO       pDev,
    PCOMMONOBJECT Object
)
{
    RM_STATUS status = RM_OK;

    //
    // Free the instance
    //
    if (Object->Instance) {
        status = fbFreeInstMem(pDev, Object->Instance, 1);    // one paragraph
        if (status)
            return(status);

        //
        // Zero the fields, just in case
        //
        INST_WR32(Object->Instance, SF_OFFSET(NV_PRAMIN_CONTEXT_0), 0);
        INST_WR32(Object->Instance, SF_OFFSET(NV_PRAMIN_CONTEXT_1), 0);
        INST_WR32(Object->Instance, SF_OFFSET(NV_PRAMIN_CONTEXT_2), 0);
        
        Object->Instance = 0;
    }

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\gr\nv\grstate.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRSTATE.C                                                         *
*   The graphics state is changed in this module.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <gr.h>
#include <os.h>
#include "nvhw.h"
//
// Externs.
//
extern char strDevNodeRM[];

//
// Change graphics hardware state.
//
RM_STATUS stateGr
(
    PHWINFO pDev,
    U032    msg
)
{
    U032    data32;

    switch (msg)
    {
        case STATE_UPDATE:
            break;
        case STATE_LOAD:
            //
            // Disable data from fifo.
            //
            REG_WR32(NV_PGRAPH_FIFO, 0x0);

            // Ignore return code.
            (void) nvHalGrControl(pDev, GR_CONTROL_LOAD);

            // save off this registry value (to be loaded later)
            if (IsNV15orBetter(pDev) &&
                (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "SwathMultWidth", &data32) == RM_OK))
                nvHalGrLoadOverride(pDev, GR_LOAD_OVERRIDE_SWATHCTL, data32 | SWATH_CONTROL_VALID_BIT);
            else
                nvHalGrLoadOverride(pDev, GR_LOAD_OVERRIDE_SWATHCTL, 0);

            //
            // Reset and enabled the interrupts.
            //
            REG_WR32(NV_PGRAPH_INTR,    0xFFFFFFFF);
            REG_WR32(NV_PGRAPH_INTR_EN, 0xFFFFFFFF);
            
            pDev->Graphics.Enabled = TRUE;
            
            break;
        case STATE_UNLOAD:
            if (pDev->Graphics.Enabled)
            {
                //
                // Set disabled flag.
                //
                pDev->Graphics.Enabled = FALSE;
                
                //
                // Idle the graphics engine.
                //
                // XXXscottl - Potential calls to any of the engine
                // interrupt service routines need to be mutexed.
                // We have a problem here because we can be called
                // as a result of a win9x class-driven modeset (in which
                // case the higher-level mcService routine will have
                // grabbed the spinlock) or because of a winnt-type
                // modeset (in which case no lock is held).
                //
                GR_IDLE();

                //
                // Pull out current graphics state.
                //
                (void) nvHalGrControl(pDev, GR_CONTROL_UNLOAD);
                
                //
                // Disable data access from fifo.
                //
                REG_WR32(NV_PGRAPH_FIFO,    0x00000000);
                REG_WR32(NV_PGRAPH_INTR_EN, 0x00000000);
            }
            break;
        case STATE_INIT:
        {
            U032 i;
            RM_STATUS status;

            //
            // Allocate/initialize the graphics engine class allocation
            // locks.
            //
            status = osAllocMem((VOID **)&pDev->Graphics.ClassLocks, sizeof (U032) * NUM_FIFOS);
            if (status)
                return (status);

            for (i = 0; i < NUM_FIFOS; i++)
            {
                ((U032 *)(pDev->Graphics.ClassLocks))[i] = 0;
            }

            pDev->Graphics.Enabled = FALSE;
            
            //
            // Handle any hardware dependent initialization now.
            //
            nvHalGrControl(pDev, GR_CONTROL_INIT);

            //
            // Clear VBlank list.
            //
            pDev->DBgrVBlankList[0] = NULL;
            pDev->DBgrVBlankList[1] = NULL;
            //
            // Load any overrides.
            //
            initGrEx(pDev);
            break;
        }
        case STATE_DESTROY:
            osFreeMem((VOID *)pDev->Graphics.ClassLocks);
            break;
    }    
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\gr\nv\grval.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRVAL.C                                                           *
*   The graphics engine is managed in this module.  Graphics patches are    *
*   validated here.                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <dac.h>
#include <gr.h>
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
//
// Externs.
//
// extern PGRAPHICSCHANNEL grTable;

//---------------------------------------------------------------------------
//
//  Validate graphics patchcords.
//
//---------------------------------------------------------------------------

RM_STATUS grValidateVideoPatchcord
(
    // PHWINFO pDev,
    PVIDEOPATCHCORD   VideoPatchcord,
    PPATCHCONTEXT     PatchContext,
    U032              DestCount
)
{
    PVIDEOOBJECT VideoObject = (void *) 0;
    U032         i;
    
    //
    // Initialize context configuration.
    //
    PatchContext->VideoConfig  = BOTH_BUFFERS;
    PatchContext->ColorMap0    = NULL;
    PatchContext->ColorMap1    = NULL;
    PatchContext->VideoScaler  = NULL;
    PatchContext->VideoColorKey = NULL;

    //
    // Find output of patchcord.
    //
    if (VideoPatchcord && VideoPatchcord->FanOut)
    {
        //
        // Search for the first destination
        //
        DBG_VAL_PTR(VideoPatchcord);
        for (i = 0; (i < MAX_GRPATCH_FANOUT) && DestCount; i++)
        {
            if ((VideoObject = VideoPatchcord->Destination[i]))
            {
                DBG_VAL_PTR(VideoPatchcord->Destination[i]);
                DestCount--;
            }
        }
#if DEBUG
        if (DestCount)
        {
            GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Invalid patchcord in VidPatchValidation!\n\r"));
            DBG_BREAKPOINT();
            return (RM_ERROR);
        }
#endif // DEBUG
    }
    else
        return (RM_ERR_INCOMPLETE_PATCH);
    //
    // Accumulate video patch configuration.
    //
    while ( VideoObject && (VideoObject->Base.Class->Type != NV_VIDEO_SINK))
    {
        DBG_VAL_PTR(VideoObject);
        /* KJK
        if (VideoObject->Base.Class->Type == NV_VIDEO_SWITCH)
        {
            //
            // Check which buffers to read/write to.
            //
            if (PatchContext->VideoConfig != BOTH_BUFFERS)
                return (RM_ERR_INVALID_PATCH);
            //
            // Ordinal.
            //
            if (((PVIDEOSWITCHOBJECT)VideoObject)->Ordinal)
                PatchContext->VideoSwitch = (PVIDEOSWITCHOBJECT)VideoObject;
            else    
                return (RM_ERR_INCOMPLETE_PATCH);
            //
            // Initialize the buffer toggle for this patch if it hasn't
            //  already been done.
            //
            if (PatchContext->Canvas->BufferToggle == INVALID_BUFFER)
            {
                if (pDev->Framebuffer.ActiveCount == 1)
                    //
                    // If this is the only double buffered application, then buffer
                    // toggle is always 0 because the toggle does not actually
                    // toggle for single double bufferd clients.
                    //
                    PatchContext->Canvas->BufferToggle = 0;
                else
                    //
                    // When multiple double buffered sessions are active set it to be
                    // whatever the current buffer is.
                    //
                    PatchContext->Canvas->BufferToggle = pDev->Framebuffer.Current;
            }
            PatchContext->VideoConfig = 0;
            if (PatchContext->ColorMap0)
            {
                //
                // Video switch occurs after the colormap.
                //
                if (VideoObject->VideoInput[0] == PatchContext->ColorMap0->VideoOutput)
                    PatchContext->VideoConfig = 1;
                if (VideoObject->VideoInput[1] == PatchContext->ColorMap1->VideoOutput)
                    PatchContext->VideoConfig += 2;
            }
            else
            {
                //
                // Video switch occurs after imagevideo.
                //
                if (VideoObject->VideoInput[0] == ((PIMAGEVIDEOOBJECT)PatchContext->ImageObject)->VideoOutput)
                    PatchContext->VideoConfig = 1;
                if (VideoObject->VideoInput[1] == ((PIMAGEVIDEOOBJECT)PatchContext->ImageObject)->VideoOutput)
                    PatchContext->VideoConfig += 2;
            }
            if (PatchContext->VideoConfig == 1)
                PatchContext->ColorMap1 = NULL;
            else if (PatchContext->VideoConfig == 2)
                PatchContext->ColorMap0 = NULL;
            if (!VideoObject->VideoOutput)
                return (RM_ERR_INCOMPLETE_PATCH);
            //VideoObject = VideoObject->VideoOutput->Destination;
        }
        else*/
        if (VideoObject->Base.Class->Type == NV_VIDEO_COLORMAP)
        {
            //
            // Add the color map to the patch configuration.
            //
            PatchContext->ColorMap0 = (PVIDEOCOLORMAPOBJECT)VideoObject;
            PatchContext->ColorMap1 = (PVIDEOCOLORMAPOBJECT)VideoObject;
            if (!VideoObject->VideoOutput)
                return (RM_ERR_INCOMPLETE_PATCH);
            //VideoObject = VideoObject->VideoOutput->Destination;
        }
        else if (VideoObject->Base.Class->Type == NV_VIDEO_SCALER)
        {
            //
            // Add the scaler to the patch configuration.
            //
            PatchContext->VideoScaler = (PVIDEOSCALEROBJECT)VideoObject;
            if (!VideoObject->VideoOutput)
                return (RM_ERR_INCOMPLETE_PATCH);
        }
        else if (VideoObject->Base.Class->Type == NV_VIDEO_COLOR_KEY)
        {
            //
            // Add the color key to the patch configuration.
            //
            PatchContext->VideoColorKey = (PVIDEOCOLORKEYOBJECT)VideoObject;
            if (!VideoObject->VideoOutput)
                return (RM_ERR_INCOMPLETE_PATCH);
        }
        else
            return (RM_ERR_INVALID_PATCH);

        //
        // Follow patchcord to next video object.
        //
        VideoPatchcord = VideoObject->VideoOutput;
        if (VideoPatchcord && VideoPatchcord->FanOut)
        {
            DBG_VAL_PTR(VideoPatchcord);
            if (VideoPatchcord->FanOut > 1)
                return (RM_ERR_PATCH_TOO_COMPLEX);
            //
            // Search for the first destination.
            //    
            for (i = 0; !(VideoObject = VideoPatchcord->Destination[i]); i++)
			    ;
#if DEBUG
            if (!VideoObject)
            {
                GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Invalid patchcord in VideoPatchcordValidation!\n\r"));
                DBG_BREAKPOINT();
                return (RM_ERROR);
            }
#endif // DEBUG
        }
        else
            return (RM_ERR_INCOMPLETE_PATCH);

    }
    return (VideoObject ? RM_OK : RM_ERR_INCOMPLETE_PATCH);
}


//---------------------------------------------------------------------------
//
//  Invalidate graphics patchcords.
//
//---------------------------------------------------------------------------

RM_STATUS grInvalidateVideoPatchcord
(
    PVIDEOPATCHCORD VideoPatchcord
)
{
    U032            i;
    
    //
    // Find input of patchcord.
    //
    if (!VideoPatchcord || !VideoPatchcord->Source)
        return (RM_OK);
    DBG_VAL_PTR(VideoPatchcord);
    DBG_VAL_PTR(VideoPatchcord->Source);
    switch (VideoPatchcord->Source->Base.Class->Type)
    {
        case NV_VIDEO_COLORMAP:
            grInvalidateVideoPatchcord(((PVIDEOCOLORMAPOBJECT)VideoPatchcord->Source)->VideoInput);
            break;
        case NV_VIDEO_SINK:
            for (i = 0; i < MAX_GRPATCH_INPUT; i++)
                grInvalidateVideoPatchcord(((PVIDEOSINKOBJECT)VideoPatchcord->Source)->VideoInput[i]);
            break;
#ifdef DEBUG
        default:
            GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM:Invalid object type for InvalidateVideoPatchcord.\n\r"));
            DBG_BREAKPOINT();
#endif
    }
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Validate object context.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\gr\nv10\grcxnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRCTXT.C                                                          *
*   The graphics engine is managed in this module.  Context switching is    *
*   contained here.                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include <heap.h>
#include "nvhw.h"
#include "nvhalcpp.h"
#include "cr11help.h"

// forwards
RM_STATUS nvHalGrLoadChannelContext_NV10(PHALHWINFO, U032);
RM_STATUS nvHalGrUnloadChannelContext_NV10(PHALHWINFO, U032, PGRAPHICSCHANNEL_NV10);
VOID nvHalGrLoadHW(PHALHWINFO, U032, PGRAPHICSCHANNEL_NV10);
RM_STATUS nvHalGrGetState_NV10(PHALHWINFO, PGREXCEPTIONDATA, U032);
RM_STATUS nvHalGrPutState_NV10(PHALHWINFO, PGREXCEPTIONDATA, U032);
RM_STATUS nvHalGrSetMaterialEmission_NV10(PHALHWINFO, PGREXCEPTIONDATA);
RM_STATUS nvHalGrSetViewportOffset_NV10(PHALHWINFO, PGREXCEPTIONDATA);
RM_STATUS nvHalGrSetPassthruViewportOffset_NV10(PHALHWINFO, PGREXCEPTIONDATA);

// externs
extern RM_STATUS dmaHalInstanceToHalInfo_NV10(U032, U032, PDMAHALOBJINFO *, PHALHWINFO);

static RM_STATUS grDelay_NV10(PHALHWINFO, U032);

// values for enabling passthrough modes
static U032 Vertex_Passthr_Mode[] = {
    0x10000000,
    0x00000000
};
#define VERTEX_COUNT            (sizeof(Vertex_Passthr_Mode) / sizeof(U032))
static U032 ScaleOffset_Passthr_Mode[] = {
    0x3F800000,
    0x3F800000,
    0x3F800000,
    0x3F800000,
    0x0,
    0x0,
    0x0,
    0x0
};
#define SCALEOFFSET_COUNT       (sizeof(ScaleOffset_Passthr_Mode) / sizeof(U032))

static U032 Fog_Passthr_Mode[2][3] = {
    { 0x0,        0x0,        0x0 },           // passthrough mode values for A01
    { 0x3F800000, 0x3F800000, 0x3F800000 }     // passthrough mode values for >= A02
};
#define FOG_COUNT               (sizeof(Fog_Passthr_Mode[0]) / sizeof(U032))

static U032 Fog_EyeDist_Passthr_Mode[] = {
    0x0,
    0x0,
    0x0
};
#define FOG_EYEDIST_COUNT        (sizeof(Fog_EyeDist_Passthr_Mode) / sizeof(U032))

//
// Second Inverse ModelViewMatrix location in the XF engine needed for HW
// workaround both for RM related context switching and GetState context
// switching (see notes in grLoadChannelContext for details).
// 
#define INV2_MATRIX_OFFSET    0x653C

//
// Load Pipe Context
//
static RM_STATUS
grLoadPipeContext(
    PHALHWINFO pHalHwInfo,
    U032       Base,
    U032      *SaveAddr,
    U032       Count
)
{
    U032 i;

    REG_WR32(NV_PGRAPH_PIPE_ADDRESS, Base);
    for (i = 0; i < Count; i++) {
	  REG_WR32(NV_PGRAPH_PIPE_DATA, SaveAddr[i]);
    }
    return (RM_OK);
}

//
// Unload Pipe Context
//
static RM_STATUS
grUnloadPipeContext(
    PHALHWINFO pHalHwInfo,
    U032       Base,
    U032      *SaveAddr,
    U032       Count
)
{
    U032 i;

    REG_WR32(NV_PGRAPH_PIPE_ADDRESS, Base);
    for (i = 0; i < Count; i++) {
	  SaveAddr[i] = REG_RD32(NV_PGRAPH_PIPE_DATA);
    }
    return (RM_OK);
}

#define Z16_OVR_MASK (DRF_MASK(NV_PGRAPH_SURFACE_Z16_OVERRIDE) <<    \
                      DRF_SHIFT(NV_PGRAPH_SURFACE_Z16_OVERRIDE))

//
// We're in the midst of a context switch loading in a new 3D channel that
// needs a Celsius method resent to workaround a HW problem. We either need
// to resubmit a Vertex Buffer, or a NOP to setup a correct load of the
// Z16_OVERRIDE bit in PGRAPH_SURFACE.
//
//  1) switch to the Celsius subchannel for the new channel
//  2) save off the method in the stage 2 GR fifo
//  3) load the Celsius method in the stage 2 register
//  4) reenable enough of the GR fifo, so this method/data goes through
//  5) wait for the value to show-up, then disable the GR fifo again
//  6) reload the stage 2 register
//  7) switch back to the correct subchannel before the context switch
//
// Note: Eventhough we're checking for NV11_CELSIUS_PRIMITIVE, we'll never
//       match on that value, since the HW can only hold an 8 bit value and
//       a NV11's class number is 16 bits. But, because 0x1196 will look
//       like 0x96 (NV15's value), the class will match and should be ok.
//
static VOID
grResubmitCelsiusMethod(
    PHALHWINFO pHalHwInfo,
    U032       ChID,            // new ChID
    BOOL       resendDmaVtx
)
{
    PGRHALINFO_NV10 pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV10 pGrChan = &pGrHalPvtInfo->grChannels[ChID];    
    U032 grclass, celsius;
    U032 st2, datalo, datahi, z16_data=0;
    U032 notifyReq;

    //
    // On the initial load of this channel, we don't have any saved context, so
    // applying one of these workarounds doesn't seem possible. But really, it's
    // unnecessary, since the HW's going to receive the state setting methods
    // anyways.
    //
    if (DRF_VAL(_PGRAPH, _CTX_USER, _CHID, pGrChan->ContextUser) != ChID)
        return;

    // mark this new channel as owning graphics
    REG_WR32(NV_PGRAPH_CTX_USER, pGrChan->ContextUser);

    if (resendDmaVtx) {
        //
        // Determine which is the Celsius subchan and make it current
        //
        for (celsius = 0; celsius < NUM_SUBCHANNELS; celsius++)
        {
            grclass = DRF_VAL(_PGRAPH, _CTX_CACHE1, _GRCLASS, pGrChan->ContextCache1[celsius]);
            if ((grclass == NV10_CELSIUS_PRIMITIVE) ||
                (grclass == NV15_CELSIUS_PRIMITIVE) ||
                (grclass == NV11_CELSIUS_PRIMITIVE))
                    break;
        }
        if (celsius == NUM_SUBCHANNELS)
            return;     // couldn't find the Celsius object loaded

    } else {
        // use the existing subchan (all classes can handle a NOP)
        celsius = REG_RD_DRF(_PGRAPH, _CTX_USER, _SUBCH);
    }

    //
    // Make the Celsius object current by copying the saved subchan
    // state for CTX_CACHE(celsius) into the CTX_SWITCH registers.
    //
    REG_WR32(NV_PGRAPH_CTX_SWITCH1, pGrChan->ContextCache1[celsius]);
    REG_WR32(NV_PGRAPH_CTX_SWITCH2, pGrChan->ContextCache2[celsius]);
    REG_WR32(NV_PGRAPH_CTX_SWITCH3, pGrChan->ContextCache3[celsius]);
    REG_WR32(NV_PGRAPH_CTX_SWITCH4, pGrChan->ContextCache4[celsius]);
    REG_WR32(NV_PGRAPH_CTX_SWITCH5, pGrChan->ContextCache5[celsius]);

    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _SUBCH, celsius);

    // save the stage2 values, which'll be reloaded after the method's been sent
    st2     = REG_RD32(NV_PGRAPH_FFINTFC_ST2);
    datalo  = REG_RD32(NV_PGRAPH_FFINTFC_ST2_DL);
    datahi  = REG_RD32(NV_PGRAPH_FFINTFC_ST2_DH);

    
    // if a NOTIFY is pending, then turn it off so that this method does not
    //   cause spurious NOTIFY.  Since we are called in middle of channel
    //   switch, it is possible for the outgoing channel to have NOTIFY:REQ set
    //   which this method would then invoke -- but on the wrong channel/subc.
    notifyReq = REG_RD_DRF(_PGRAPH, _NOTIFY, _REQ);
    FLD_WR_DRF_DEF(_PGRAPH, _NOTIFY, _REQ, _NOT_PENDING);

    if (resendDmaVtx) {
        // Set an invalid instance address in GLOBALSTATE1
        FLD_WR_DRF_DEF(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_2, _INVALID);

        // Load the method/data into the stage2 register
        REG_WR32(NV_PGRAPH_FFINTFC_ST2,                         NV056_SET_CONTEXT_DMA_VERTEX    |
                 DRF_NUM(_PGRAPH, _FFINTFC_ST2, _SUBCH,         celsius)                        |
                 DRF_NUM(_PGRAPH, _FFINTFC_ST2, _CHID,          ChID)                           |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _DATAHIGH,      _INVALID)                       |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _STATUS,        _VALID)                         |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHID_STATUS,   _VALID)                         |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHSWITCH,      _SET)                           |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _FIFOHOLD,      _SET));

        REG_WR32(NV_PGRAPH_FFINTFC_ST2_DL,
                 DRF_VAL(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_2, pGrChan->CurrentPatch.GlobalState1));
    } else {    // resend Z16 override for NV11
        //        
        // Flip all the bits that are in trapped data currently, mask
        // off the bit we want and or in the bit we want to show up in
        // Z16 override
        //
        z16_data  =  (REG_RD32(NV_PGRAPH_TRAPPED_DATA_LOW) ^ 0xFFFFFFFF);
        z16_data  &= ~Z16_OVR_MASK;
        z16_data  |= (Z16_OVR_MASK & pGrChan->CurrentPatch.Surface);

        // Load the method/data into the stage2 register
        REG_WR32(NV_PGRAPH_FFINTFC_ST2,                         NV1196_NO_OPERATION             |
                 DRF_NUM(_PGRAPH, _FFINTFC_ST2, _SUBCH,         celsius)                        |
                 DRF_NUM(_PGRAPH, _FFINTFC_ST2, _CHID,          ChID)                           |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _DATAHIGH,      _INVALID)                       |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _STATUS,        _VALID)                         |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHID_STATUS,   _VALID)                         |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHSWITCH,      _SET)                           |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _FIFOHOLD,      _SET));

        // Method data is either 0x0 or 0x1, depending on desired value of Z16_OVERRIDE
        REG_WR32(NV_PGRAPH_FFINTFC_ST2_DL, z16_data);
    }

    // Briefly enable PGRAPH_FIFO_ACCESS (and mark the channel valid),
    // so our method can come through
    FLD_WR_DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID, _VALID);
    FLD_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);

    if (resendDmaVtx) {
        // spin until we see our instance address show up in the register
        while (REG_RD_DRF(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_2) !=
               DRF_VAL(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_2, pGrChan->CurrentPatch.GlobalState1))
            ;
    } else {
        // spin until we see the NOP method and data in the trapped registers
        while ((REG_RD_DRF(_PGRAPH, _TRAPPED_ADDR, _MTHD) !=
                DRF_VAL(_PGRAPH, _TRAPPED_ADDR, _MTHD, NV1196_NO_OPERATION)) ||
                (REG_RD32(NV_PGRAPH_TRAPPED_DATA_LOW) != z16_data))
                ;
    }

    // Disable PGRAPH_FIFO_ACCESS again
    FLD_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);

    // Now, restore the stage2 method/data
    REG_WR32(NV_PGRAPH_FFINTFC_ST2,    st2);
    REG_WR32(NV_PGRAPH_FFINTFC_ST2_DL, datalo);
    REG_WR32(NV_PGRAPH_FFINTFC_ST2_DH, datahi);

    // and the NOTIFY bit
    FLD_WR_DRF_NUM(_PGRAPH, _NOTIFY, _REQ, notifyReq);
}

//
// nvHalGrLoadChannelContext
//
RM_STATUS
nvHalGrLoadChannelContext_NV10(PHALHWINFO pHalHwInfo, U032 ChID)
{
    PGRHALINFO_NV10 pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    U032 misc;

    GR_PRINTF((DBG_LEVEL_INFO, "NVRM: nvHalGrLoadChannelContext_NV10\r\n"));

    //
    // Service any outstanding graphics exceptions.
    //
    if (REG_RD32(NV_PGRAPH_INTR))
        HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);
        
    //
    // Save current graphics interface state.
    //
    GR_SAVE_STATE(misc);
    HAL_GR_IDLE(pHalHwInfo);
    
    //
    // Unload current context.
    //   
    if (pGrHalPvtInfo->currentChID != ChID) {
        nvHalGrUnloadChannelContext_NV10(pHalHwInfo,
                                         pGrHalPvtInfo->currentChID,
                                         &pGrHalPvtInfo->grChannels[pGrHalPvtInfo->currentChID]);
    }

    if ((pGrHalPvtInfo->currentChID = ChID) == INVALID_CHID)
    {
        //
        // Set current channel to an invalid one.
        //
        FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, (NUM_FIFOS_NV10 - 1));

        //
        // Update current channel.
        //    
        REG_WR32(NV_PGRAPH_CTX_CONTROL, DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                                      | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _NOT_EXPIRED)
                                      | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                                      | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                                      | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
        REG_WR_DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHID_STATUS, _VALID);

        //
        // Restore graphics interface state.
        //
		misc |= DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);
        GR_RESTORE_STATE(misc); // FIFO reenabled in here

        return (RM_OK);
        //
        // Is the channel ID valid?
        //
    }
    else if (ChID >= NUM_FIFOS_NV10)
    {
        GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Invalid Channel on Graphics Context Switch: 0x%x\n", ChID));
        DBG_BREAKPOINT();
        return (RM_ERROR);
    }

    // Reload the HW for the new channel
    nvHalGrLoadHW(pHalHwInfo,
                  ChID,
                  &pGrHalPvtInfo->grChannels[ChID]);

    // Update current channel.
    REG_WR32(NV_PGRAPH_CTX_CONTROL, DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _NOT_EXPIRED)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _VALID)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
                                  
    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, ChID);
    
    //
    // Clear the graphics fifo channel context.  This fixes a subtle hardware bug
    // when thrashing channel changes within the graphics fifo.  Ideally the fifo
    // would hold off pending data while a change is active, but it can actually
    // hold multiple changes.  In order to reduce hw confusion, they added a few
    // state bits within one stage fifo.  Clear those bits on channel changes.
    //
    // Since the bits are write only, they'll read as a zero.
    // Clear those bits on channel changes. Don't rely on these to read as zero
    // eventhough these bits are write only.
    //
    // XXX adding the comments from NV4/NV5 ... actually, we hit this on NV10
    // also (our FIFOHOLD bits were set, so we'll also mask these off on a read)
    // in case this explains the fifo hang we saw.
    //
    // We have to OR in the top bit to fool the Watcom compiler for the Win3.1 version
    // of the resmgr.
    //
    // REG_WR32(NV_PGRAPH_FFINTFC_ST2, REG_RD32(NV_PGRAPH_FFINTFC_ST2) | 0x80000000);
    REG_WR32(NV_PGRAPH_FFINTFC_ST2, REG_RD32(NV_PGRAPH_FFINTFC_ST2) & 0xCFFFFFFF);

    return (RM_OK);
}

U032 reset_delay = 0x0;

VOID
nvHalGrLoadHW(PHALHWINFO pHalHwInfo, U032 ChID, PGRAPHICSCHANNEL_NV10 pGrChan)
{
    PGRHALINFO_NV10 pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    U032 i;

    //
    // Because unloading the previous channel may not have reset GR
    // state, after the unload we'll manually reset the engines. In
    // doing this, we'll also need to restore the GR tiling registers,
    // since they get lost on a reset.
    //
    REG_WR_DRF_DEF(_PGRAPH, _DEBUG_0, _STATE, _RESET);

    // delay for at least 10 nvclks
    if (reset_delay == 0) {
        reset_delay = (1000000000 / pHalHwInfo->pDacHalInfo->NVClk);   // nvclk cycle time, in ns
        reset_delay *= 10;
    }
    grDelay_NV10(pHalHwInfo, reset_delay);
    
    // jump back out of reset
    REG_WR_DRF_DEF(_PGRAPH, _DEBUG_0, _STATE, _NORMAL);

    HAL_GR_IDLE(pHalHwInfo);

    //
    // Check for integrated graphics -- we need to setup tiling through the north bridge
    //
    if( IsNV1A_NV10(pHalHwInfo->pMcHalInfo) )
    {
        //North bridge integrated graphics has a different tile setup
        U016	wNBVendorID;
        U016	wNBDeviceID;
        VOID    *uNBHandle = 0;
        U032	uNBFakeTLIMIT;
        U032	uNBFakeTSIZE;
        U032	uNBFakeTILE;
        U032	uNBTBASE;
        U032	uNBTLIMIT;

        uNBHandle = osPciInitHandle(0, 0, 2, &wNBVendorID, &wNBDeviceID);
        if( !uNBHandle )
        {
	    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Unable to touch integrated graphics tiling\n");
	    DBG_BREAKPOINT();
	    return;
        }

        // restore PGRAPH_TILE regs after PGRAPH_DEBUG_0_STATE_RESET
        for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
        {
	    uNBTBASE  = osPciReadDword(uNBHandle, CR_XL_TBASE(i)  & 0xFF );
	    uNBTLIMIT = osPciReadDword(uNBHandle, CR_XL_TLIMIT(i) & 0xFF );
	    uNBFakeTLIMIT = FormatPFBTLimit( ReadNBPitch( uNBTBASE, uNBTLIMIT ), ReadNBOffset( uNBTBASE, uNBTLIMIT ), ReadNBSize( uNBTBASE, uNBTLIMIT ), ReadNBValid( uNBTBASE, uNBTLIMIT ) );
	    uNBFakeTSIZE  = FormatPFBTSize ( ReadNBPitch( uNBTBASE, uNBTLIMIT ), ReadNBOffset( uNBTBASE, uNBTLIMIT ), ReadNBSize( uNBTBASE, uNBTLIMIT ), ReadNBValid( uNBTBASE, uNBTLIMIT ) );
	    uNBFakeTILE   = FormatPFBTile  ( ReadNBPitch( uNBTBASE, uNBTLIMIT ), ReadNBOffset( uNBTBASE, uNBTLIMIT ), ReadNBSize( uNBTBASE, uNBTLIMIT ), ReadNBValid( uNBTBASE, uNBTLIMIT ) );

            REG_WR32(NV_PGRAPH_TLIMIT(i), uNBFakeTLIMIT);
            REG_WR32(NV_PGRAPH_TSIZE(i),  uNBFakeTSIZE);
            REG_WR32(NV_PGRAPH_TILE(i),   uNBFakeTILE);
        }
    }
    else
    {
        // restore PGRAPH_TILE regs after PGRAPH_DEBUG_0_STATE_RESET
        for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
        {
            REG_WR32(NV_PGRAPH_TLIMIT(i), REG_RD32(NV_PFB_TLIMIT(i)));
            REG_WR32(NV_PGRAPH_TSIZE(i),  REG_RD32(NV_PFB_TSIZE(i)));
            REG_WR32(NV_PGRAPH_TILE(i),   REG_RD32(NV_PFB_TILE(i)));
        }
    }

    //
    // Apply context switch related workarounds after we've unloaded the
    // previous channels state, but before loading this new channels state.
    //
    if (pGrHalPvtInfo->currentObjects3d[ChID] != 0)
    {
        //
        // Eventhough we're about to reload GLOBALSTATE1 which holds the inst addr for
        // the vertex buffers context DMA, neither the channel switch nor the priv write
        // invalidates a shadowed copy kept in the hardware. The only thing that does
        // is a SetContextDmaVertex method, so we'll send that before the priv write.
        //
        if (DRF_VAL(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_2, pGrChan->CurrentPatch.GlobalState1))
        {
            grResubmitCelsiusMethod(pHalHwInfo, ChID, TRUE);
        }

        //
        // With NV11, on a priv write to PGRAPH_SURFACE, the Z16_OVERRIDE bit is taken
        // from the last user method not from the RBI bus. To work around this, we'll
        // send down a NOP with the correct data pattern for the bit (0x0 or 0x1), so
        // the correct thing happens on the priv write to PGRAPH_SURFACE.
        // 
        REG_WR32(NV_PGRAPH_SURFACE, pGrChan->CurrentPatch.Surface);        

        if (REG_RD32(NV_PGRAPH_SURFACE) != pGrChan->CurrentPatch.Surface)
        {
            grResubmitCelsiusMethod(pHalHwInfo, ChID, FALSE);

            // wait for the pipe to go idle 
            HAL_GR_IDLE(pHalHwInfo);

            // rewrite PGRAPH_SURFACE to the correct value (done again below).
            REG_WR32(NV_PGRAPH_SURFACE, pGrChan->CurrentPatch.Surface);        

#ifdef DEBUG
            // make sure we've got the expected NV_PGRAPH_SURFACE value
            if (DRF_VAL(_PGRAPH, _CTX_USER, _CHID, pGrChan->ContextUser) == ChID) {
                if (REG_RD32(NV_PGRAPH_SURFACE) != pGrChan->CurrentPatch.Surface) {
                    GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Incorrect Z16 override setting\r\n"));
                    DBG_BREAKPOINT();
                }
            }
#endif
        }
    }

    //
    // Reload context state
    //
    REG_WR32(NV_PGRAPH_CTX_SWITCH1, pGrChan->ContextSwitch1);
    REG_WR32(NV_PGRAPH_CTX_SWITCH2, pGrChan->ContextSwitch2);
    REG_WR32(NV_PGRAPH_CTX_SWITCH3, pGrChan->ContextSwitch3);
    REG_WR32(NV_PGRAPH_CTX_SWITCH4, pGrChan->ContextSwitch4);
    REG_WR32(NV_PGRAPH_CTX_SWITCH5, pGrChan->ContextSwitch5);

    for (i = 0; i < 8; i++)
    {    
        REG_WR32(NV_PGRAPH_CTX_CACHE1(i), pGrChan->ContextCache1[i]);
        REG_WR32(NV_PGRAPH_CTX_CACHE2(i), pGrChan->ContextCache2[i]);
        REG_WR32(NV_PGRAPH_CTX_CACHE3(i), pGrChan->ContextCache3[i]);
        REG_WR32(NV_PGRAPH_CTX_CACHE4(i), pGrChan->ContextCache4[i]);
        REG_WR32(NV_PGRAPH_CTX_CACHE5(i), pGrChan->ContextCache5[i]);
    }
    
    REG_WR32(NV_PGRAPH_CTX_USER, pGrChan->ContextUser);
    
    //
    // Reload current dma registers
    //
    REG_WR32(NV_PGRAPH_DMA_START_0, pGrChan->DmaStart0);
    REG_WR32(NV_PGRAPH_DMA_START_1, pGrChan->DmaStart1);
    REG_WR32(NV_PGRAPH_DMA_LENGTH,  pGrChan->DmaLength);
    REG_WR32(NV_PGRAPH_DMA_MISC,    pGrChan->DmaMisc);
    REG_WR32(NV_PGRAPH_DMA_PITCH,   pGrChan->DmaPitch);
            
    //
    // Reload current graphics state
    //
    for (i = 0; i < 6; i++)
    {    
        REG_WR32(NV_PGRAPH_BOFFSET(i),  pGrChan->CurrentPatch.BufferOffset[i]);
        REG_WR32(NV_PGRAPH_BBASE(i),    pGrChan->CurrentPatch.BufferBase[i]);
        REG_WR32(NV_PGRAPH_BLIMIT(i),   pGrChan->CurrentPatch.BufferLimit[i]);
    }
    
    for (i = 0; i < 5; i++)
        REG_WR32(NV_PGRAPH_BPITCH(i),   pGrChan->CurrentPatch.BufferPitch[i]);
        
    REG_WR32(NV_PGRAPH_SURFACE,         pGrChan->CurrentPatch.Surface);        
    REG_WR32(NV_PGRAPH_STATE,           pGrChan->CurrentPatch.State);        
    REG_WR32(NV_PGRAPH_BSWIZZLE2,       pGrChan->CurrentPatch.BufferSwizzle[0]);        
    REG_WR32(NV_PGRAPH_BSWIZZLE5,       pGrChan->CurrentPatch.BufferSwizzle[1]);        
    REG_WR32(NV_PGRAPH_BPIXEL,          pGrChan->CurrentPatch.BufferPixel);

    REG_WR32(NV_PGRAPH_NOTIFY,          pGrChan->CurrentPatch.Notify);
    
    REG_WR32(NV_PGRAPH_PATT_COLOR0,     pGrChan->CurrentPatch.PatternColor0);    
    REG_WR32(NV_PGRAPH_PATT_COLOR1,     pGrChan->CurrentPatch.PatternColor1);
    
    // In NV10, we can access the pattern RAM anytime after the engine's been idled
    for (i = 0; i < 64; i++)
        REG_WR32(NV_PGRAPH_PATT_COLORRAM(i), pGrChan->CurrentPatch.PatternColorRam[i]);
        
    REG_WR32(NV_PGRAPH_PATTERN(0),      pGrChan->CurrentPatch.Pattern[0]);
    REG_WR32(NV_PGRAPH_PATTERN(1),      pGrChan->CurrentPatch.Pattern[1]);
    REG_WR32(NV_PGRAPH_PATTERN_SHAPE,   pGrChan->CurrentPatch.PatternShape);
    
    REG_WR32(NV_PGRAPH_MONO_COLOR0,     pGrChan->CurrentPatch.MonoColor0);
    REG_WR32(NV_PGRAPH_ROP3,            pGrChan->CurrentPatch.Rop3);
    REG_WR32(NV_PGRAPH_CHROMA,          pGrChan->CurrentPatch.Chroma);
    REG_WR32(NV_PGRAPH_BETA_AND,        pGrChan->CurrentPatch.BetaAnd);
    REG_WR32(NV_PGRAPH_BETA_PREMULT,    pGrChan->CurrentPatch.BetaPremult);
    
    REG_WR32(NV_PGRAPH_CONTROL0,        pGrChan->CurrentPatch.Control0);
    REG_WR32(NV_PGRAPH_CONTROL1,        pGrChan->CurrentPatch.Control1);
    REG_WR32(NV_PGRAPH_CONTROL2,        pGrChan->CurrentPatch.Control2);
    REG_WR32(NV_PGRAPH_CONTROL3,        pGrChan->CurrentPatch.Control3);
    
    REG_WR32(NV_PGRAPH_BLEND,           pGrChan->CurrentPatch.Blend);
    REG_WR32(NV_PGRAPH_BLENDCOLOR,      pGrChan->CurrentPatch.BlendColor);
    REG_WR32(NV_PGRAPH_SETUPRASTER,     pGrChan->CurrentPatch.SetupRaster);
    REG_WR32(NV_PGRAPH_FOGCOLOR,        pGrChan->CurrentPatch.FogColor);
    REG_WR32(NV_PGRAPH_COLORKEYCOLOR0,  pGrChan->CurrentPatch.ColorKeyColor0);
    REG_WR32(NV_PGRAPH_COLORKEYCOLOR1,  pGrChan->CurrentPatch.ColorKeyColor1);
    REG_WR32(NV_PGRAPH_POINTSIZE,       pGrChan->CurrentPatch.PointSize);

    REG_WR32(NV_PGRAPH_ZOFFSETFACTOR,   pGrChan->CurrentPatch.ZOffsetFactor);
    REG_WR32(NV_PGRAPH_ZOFFSETBIAS,     pGrChan->CurrentPatch.ZOffsetBias);
    REG_WR32(NV_PGRAPH_ZCLIPMIN,        pGrChan->CurrentPatch.ZClipMin);
    REG_WR32(NV_PGRAPH_ZCLIPMAX,        pGrChan->CurrentPatch.ZClipMax);

    for (i = 0; i < 8; i++)
    {
        REG_WR32(NV_PGRAPH_WINDOWCLIP_HORIZONTAL(i), pGrChan->CurrentPatch.WinClipHorz[i]);
        REG_WR32(NV_PGRAPH_WINDOWCLIP_VERTICAL(i),   pGrChan->CurrentPatch.WinClipVert[i]);
    }

    REG_WR32(NV_PGRAPH_XFMODE0,         pGrChan->CurrentPatch.XFMode[0]);
    REG_WR32(NV_PGRAPH_XFMODE1,         pGrChan->CurrentPatch.XFMode[1]);

    REG_WR32(NV_PGRAPH_GLOBALSTATE0,         pGrChan->CurrentPatch.GlobalState0);
    REG_WR32(NV_PGRAPH_GLOBALSTATE1,         pGrChan->CurrentPatch.GlobalState1);

    REG_WR32(NV_PGRAPH_STORED_FMT,      pGrChan->CurrentPatch.StoredFmt);
    REG_WR32(NV_PGRAPH_SOURCE_COLOR,    pGrChan->CurrentPatch.SourceColor);
    
    for (i = 0; i < 32; i++)
    {
        REG_WR32(NV_PGRAPH_ABS_X_RAM(i), pGrChan->CurrentPatch.AbsXRam[i]);
        REG_WR32(NV_PGRAPH_ABS_Y_RAM(i), pGrChan->CurrentPatch.AbsYRam[i]);
    }        
    
    REG_WR32(NV_PGRAPH_ABS_UCLIP_XMIN,  pGrChan->CurrentPatch.AbsUClipXMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_XMAX,  pGrChan->CurrentPatch.AbsUClipXMax);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_YMIN,  pGrChan->CurrentPatch.AbsUClipYMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_YMAX,  pGrChan->CurrentPatch.AbsUClipYMax);

    REG_WR32(NV_PGRAPH_ABS_UCLIP3D_XMIN, pGrChan->CurrentPatch.AbsUClip3DXMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP3D_XMAX, pGrChan->CurrentPatch.AbsUClip3DXMax);
    REG_WR32(NV_PGRAPH_ABS_UCLIP3D_YMIN, pGrChan->CurrentPatch.AbsUClip3DYMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP3D_YMAX, pGrChan->CurrentPatch.AbsUClip3DYMax);

    REG_WR32(NV_PGRAPH_ABS_UCLIPA_XMIN, pGrChan->CurrentPatch.AbsUClipAXMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_XMAX, pGrChan->CurrentPatch.AbsUClipAXMax);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_YMIN, pGrChan->CurrentPatch.AbsUClipAYMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_YMAX, pGrChan->CurrentPatch.AbsUClipAYMax);
    
    REG_WR32(NV_PGRAPH_ABS_ICLIP_XMAX,  pGrChan->CurrentPatch.AbsIClipXMax);
    REG_WR32(NV_PGRAPH_ABS_ICLIP_YMAX,  pGrChan->CurrentPatch.AbsIClipYMax);
    
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC0,  pGrChan->CurrentPatch.XYLogicMisc0);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC1,  pGrChan->CurrentPatch.XYLogicMisc1);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC2,  pGrChan->CurrentPatch.XYLogicMisc2);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC3,  pGrChan->CurrentPatch.XYLogicMisc3);

    REG_WR32(NV_PGRAPH_CLIPX_0,         pGrChan->CurrentPatch.ClipX0);
    REG_WR32(NV_PGRAPH_CLIPX_1,         pGrChan->CurrentPatch.ClipX1);
    REG_WR32(NV_PGRAPH_CLIPY_0,         pGrChan->CurrentPatch.ClipY0);
    REG_WR32(NV_PGRAPH_CLIPY_1,         pGrChan->CurrentPatch.ClipY1);
    
    REG_WR32(NV_PGRAPH_COMBINE0ALPHAICW,   pGrChan->CurrentPatch.Combine0AlphaICW);
    REG_WR32(NV_PGRAPH_COMBINE0COLORICW,   pGrChan->CurrentPatch.Combine0ColorICW);
    REG_WR32(NV_PGRAPH_COMBINE1ALPHAICW,   pGrChan->CurrentPatch.Combine1AlphaICW);
    REG_WR32(NV_PGRAPH_COMBINE1COLORICW,   pGrChan->CurrentPatch.Combine1ColorICW);
    
    REG_WR32(NV_PGRAPH_COMBINE0FACTOR,     pGrChan->CurrentPatch.Combine0Factor);
    REG_WR32(NV_PGRAPH_COMBINE1FACTOR,     pGrChan->CurrentPatch.Combine1Factor);

    REG_WR32(NV_PGRAPH_COMBINE0ALPHAOCW,   pGrChan->CurrentPatch.Combine0AlphaOCW);
    REG_WR32(NV_PGRAPH_COMBINE0COLOROCW,   pGrChan->CurrentPatch.Combine0ColorOCW);
    REG_WR32(NV_PGRAPH_COMBINE1ALPHAOCW,   pGrChan->CurrentPatch.Combine1AlphaOCW);
    REG_WR32(NV_PGRAPH_COMBINE1COLOROCW,   pGrChan->CurrentPatch.Combine1ColorOCW);

    REG_WR32(NV_PGRAPH_COMBINESPECFOGCW0,   pGrChan->CurrentPatch.CombineSpecFogCW0);
    REG_WR32(NV_PGRAPH_COMBINESPECFOGCW1,   pGrChan->CurrentPatch.CombineSpecFogCW1);

    REG_WR32(NV_PGRAPH_TEXTUREOFFSET0,      pGrChan->CurrentPatch.TextureOffset0);
    REG_WR32(NV_PGRAPH_TEXTUREOFFSET1,      pGrChan->CurrentPatch.TextureOffset1);
    REG_WR32(NV_PGRAPH_TEXTUREPALETTE0,     pGrChan->CurrentPatch.TexturePalette0);
    REG_WR32(NV_PGRAPH_TEXTUREPALETTE1,     pGrChan->CurrentPatch.TexturePalette1);

    REG_WR32(NV_PGRAPH_TEXFORMAT0,         pGrChan->CurrentPatch.TexFormat0);
    REG_WR32(NV_PGRAPH_TEXFORMAT1,         pGrChan->CurrentPatch.TexFormat1);

    REG_WR32(NV_PGRAPH_TEXCONTROL0_0,      pGrChan->CurrentPatch.TexControl0_0);
    REG_WR32(NV_PGRAPH_TEXCONTROL0_1,      pGrChan->CurrentPatch.TexControl0_1);
    REG_WR32(NV_PGRAPH_TEXCONTROL1_0,      pGrChan->CurrentPatch.TexControl1_0);
    REG_WR32(NV_PGRAPH_TEXCONTROL1_1,      pGrChan->CurrentPatch.TexControl1_1);
    REG_WR32(NV_PGRAPH_TEXCONTROL2_0,      pGrChan->CurrentPatch.TexControl2_0);
    REG_WR32(NV_PGRAPH_TEXCONTROL2_1,      pGrChan->CurrentPatch.TexControl2_1);

    REG_WR32(NV_PGRAPH_IMAGERECT0,      pGrChan->CurrentPatch.ImageRect0);
    REG_WR32(NV_PGRAPH_IMAGERECT1,      pGrChan->CurrentPatch.ImageRect1);

    REG_WR32(NV_PGRAPH_FILTER0,         pGrChan->CurrentPatch.Filter0);
    REG_WR32(NV_PGRAPH_FILTER1,         pGrChan->CurrentPatch.Filter1);
    
    REG_WR32(NV_PGRAPH_PASSTHRU_0,      pGrChan->CurrentPatch.Passthru0);    
    REG_WR32(NV_PGRAPH_PASSTHRU_1,      pGrChan->CurrentPatch.Passthru1);    
    REG_WR32(NV_PGRAPH_PASSTHRU_2,      pGrChan->CurrentPatch.Passthru2);    
    
    REG_WR32(NV_PGRAPH_DIMX_TEXTURE,    pGrChan->CurrentPatch.DimxTexture);
    REG_WR32(NV_PGRAPH_WDIMX_TEXTURE,   pGrChan->CurrentPatch.WdimxTexture);

    REG_WR32(NV_PGRAPH_DVD_COLORFMT,    pGrChan->CurrentPatch.DVDColorFormat);    
    REG_WR32(NV_PGRAPH_SCALED_FORMAT,   pGrChan->CurrentPatch.ScaledFormat);    
    
    REG_WR32(NV_PGRAPH_MISC24_0,        pGrChan->CurrentPatch.Misc24_0);
    REG_WR32(NV_PGRAPH_MISC24_1,        pGrChan->CurrentPatch.Misc24_1);
    REG_WR32(NV_PGRAPH_MISC24_2,        pGrChan->CurrentPatch.Misc24_2);
    REG_WR32(NV_PGRAPH_X_MISC,          pGrChan->CurrentPatch.XMisc);
    REG_WR32(NV_PGRAPH_Y_MISC,          pGrChan->CurrentPatch.YMisc);
    REG_WR32(NV_PGRAPH_VALID1,          pGrChan->CurrentPatch.Valid1);
    REG_WR32(NV_PGRAPH_VALID2,          pGrChan->CurrentPatch.Valid2);

    // wait for the pipe to go idle again after loading the pipeline context
    HAL_GR_IDLE(pHalHwInfo);

    // restore pipe context if a 3D object exists in the channel
    if (pGrHalPvtInfo->currentObjects3d[ChID] != 0)
    {
        U032 grclass = INST_RD32(pGrHalPvtInfo->currentObjects3d[ChID],
                                 SF_OFFSET(NV_PRAMIN_CONTEXT_0)) & DRF_MASK(NV_PGRAPH_CTX_SWITCH1_GRCLASS);

        // set vertex passthrough mode (pass data unchanged down the pipe)
        REG_WR32(NV_PGRAPH_XFMODE0,         Vertex_Passthr_Mode[0]);
        REG_WR32(NV_PGRAPH_XFMODE1,         Vertex_Passthr_Mode[1]);

        // set scale and offset constants in ModelViewMatrix1 for passthrough
        grLoadPipeContext(pHalHwInfo, PIPE_CHEOPS_BASE + (3*64), ScaleOffset_Passthr_Mode, SCALEOFFSET_COUNT);

        // set fog constants for passthrough (different between A01 and A02)
        if (IsNV10MaskRevA02orBetter_NV10(pHalHwInfo->pMcHalInfo))
        {
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), Fog_Passthr_Mode[1], FOG_COUNT);
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x28 << 4), Fog_EyeDist_Passthr_Mode, FOG_EYEDIST_COUNT);
        } else
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), Fog_Passthr_Mode[0], FOG_COUNT);


        if ((grclass == NV10_DX5_TEXTURED_TRIANGLE) || (grclass == NV10_DX6_MULTI_TEXTURE_TRIANGLE))
        {
            // set PrimType=NONE (0x0), which puts the following vertices into the vertex file
            i = 0x0;
            grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE, &i, 0x1);
            grLoadPipeContext(pHalHwInfo, PIPE_FILE_BASE, pGrChan->CurrentPatch.CurrentPipe.VertexFile, VERTEX_FILE_COUNT);
        }
        else
        {
            // set PrimType=QUAD (0x8), which puts the following vertices into primitive assembly
            i = 0x8;
            grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE, &i, 0x1);
            grLoadPipeContext(pHalHwInfo, PIPE_ASSM_BASE, pGrChan->CurrentPatch.CurrentPipe.PrimAssm, PRIM_ASSM_COUNT);
        }

        REG_WR32(NV_PGRAPH_XFMODE0,         pGrChan->CurrentPatch.XFMode[0]);
        REG_WR32(NV_PGRAPH_XFMODE1,         pGrChan->CurrentPatch.XFMode[1]);

        // load transform engine state
        grLoadPipeContext(pHalHwInfo, PIPE_CHEOPS_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_CHEOPS, XF_CHEOPS_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER, XF_ZOSER_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_C0_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C0, XF_ZOSER_C0_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_C1_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C1, XF_ZOSER_C1_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_C2_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C2, XF_ZOSER_C2_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_C3_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C3, XF_ZOSER_C3_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_VAB_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_VAB, XF_VAB_COUNT);

        if (grclass == NV10_CELSIUS_PRIMITIVE)
        {
            U032 format, temp;

            //
            // The 8 FORMAT_SIZE values (bits 7:4) don't get saved correctly during an unload due
            // to a HW bug. To workaround this, the drivers shadow the values in the last DWORD of
            // the last row of the 2nd Inverse ModelViewMatrix (offset = 0x653C).
            // 
            // During a load of this ChID, we'll read the DWORD out of the matrix, unpack the bits
            // and put the correct values in grTable before they're restored into FORMAT_BASE.
            //
            format = pGrChan->CurrentPatch.CurrentPipe.XF_CHEOPS[(INV2_MATRIX_OFFSET - PIPE_CHEOPS_BASE)/4];
        
            for (i = 1; i < INDEX_DMA_FORMAT_COUNT; i += 2, format >>= 4)
            {
                temp = pGrChan->CurrentPatch.CurrentPipe.IndexDmaFormat[i];
                temp = (temp & 0xFFFFFF0F) | ((format & 0xF) << 4);
                pGrChan->CurrentPatch.CurrentPipe.IndexDmaFormat[i] = temp;
            }
        }

        // load index DMA pipe state
        grLoadPipeContext(pHalHwInfo, PIPE_FORMAT_BASE,	pGrChan->CurrentPatch.CurrentPipe.IndexDmaFormat, INDEX_DMA_FORMAT_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE, pGrChan->CurrentPatch.CurrentPipe.IndexDmaPrim, INDEX_DMA_PRIM_COUNT);

        // wait for the pipe to go idle 
        HAL_GR_IDLE(pHalHwInfo);

#ifdef NOTDEF
        //
        // Force an invalidate of the vertex cache. Since we force a
        // GR reset of the chip, this shouldn't be necessary anymore.
        //
        i = 0x0;
        grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE+0x80, &i, 0x1);
#endif
    }
}

RM_STATUS
nvHalGrUnloadChannelContext_NV10(PHALHWINFO pHalHwInfo, U032 ChID, PGRAPHICSCHANNEL_NV10 pGrChan)
{
    PGRHALINFO_NV10 pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    U032 i;

    GR_PRINTF((DBG_LEVEL_INFO, "NVRM: nvHalGrUnloadChannelContext_NV10\r\n"));

    //
    // No need to unload an invalid channel
    //
    if (ChID  == INVALID_CHID)
        return (RM_OK);

    //
    // Unload current context registers.
    //
    pGrChan->ContextSwitch1    = REG_RD32(NV_PGRAPH_CTX_SWITCH1);
    pGrChan->ContextSwitch2    = REG_RD32(NV_PGRAPH_CTX_SWITCH2);
    pGrChan->ContextSwitch3    = REG_RD32(NV_PGRAPH_CTX_SWITCH3);        
    pGrChan->ContextSwitch4    = REG_RD32(NV_PGRAPH_CTX_SWITCH4);
    pGrChan->ContextSwitch5    = REG_RD32(NV_PGRAPH_CTX_SWITCH5);

    for (i = 0; i < 8; i++)
    {    
        pGrChan->ContextCache1[i] = REG_RD32(NV_PGRAPH_CTX_CACHE1(i));
        pGrChan->ContextCache2[i] = REG_RD32(NV_PGRAPH_CTX_CACHE2(i));
        pGrChan->ContextCache3[i] = REG_RD32(NV_PGRAPH_CTX_CACHE3(i));
        pGrChan->ContextCache4[i] = REG_RD32(NV_PGRAPH_CTX_CACHE4(i));
        pGrChan->ContextCache5[i] = REG_RD32(NV_PGRAPH_CTX_CACHE5(i));
    }
    
    pGrChan->ContextUser       = REG_RD32(NV_PGRAPH_CTX_USER);
    
    //
    // Unload current dma registers
    //
    pGrChan->DmaStart0         = REG_RD32(NV_PGRAPH_DMA_START_0);
    pGrChan->DmaStart1         = REG_RD32(NV_PGRAPH_DMA_START_1);
    pGrChan->DmaLength         = REG_RD32(NV_PGRAPH_DMA_LENGTH);
    pGrChan->DmaMisc           = REG_RD32(NV_PGRAPH_DMA_MISC);
    pGrChan->DmaPitch          = REG_RD32(NV_PGRAPH_DMA_PITCH);
            
    //
    // Unload current graphics state
    //
    for (i = 0; i < 6; i++)
    {    
        pGrChan->CurrentPatch.BufferOffset[i] = REG_RD32(NV_PGRAPH_BOFFSET(i));
        pGrChan->CurrentPatch.BufferBase[i]   = REG_RD32(NV_PGRAPH_BBASE(i));
        pGrChan->CurrentPatch.BufferLimit[i]  = REG_RD32(NV_PGRAPH_BLIMIT(i));
    }
    
    for (i = 0; i < 5; i++)
        pGrChan->CurrentPatch.BufferPitch[i]  = REG_RD32(NV_PGRAPH_BPITCH(i));
        
    pGrChan->CurrentPatch.Surface             = REG_RD32(NV_PGRAPH_SURFACE);        
    pGrChan->CurrentPatch.State               = REG_RD32(NV_PGRAPH_STATE);        
    pGrChan->CurrentPatch.BufferSwizzle[0]    = REG_RD32(NV_PGRAPH_BSWIZZLE2);        
    pGrChan->CurrentPatch.BufferSwizzle[1]    = REG_RD32(NV_PGRAPH_BSWIZZLE5);        
    pGrChan->CurrentPatch.BufferPixel         = REG_RD32(NV_PGRAPH_BPIXEL);
    
    pGrChan->CurrentPatch.Notify              = REG_RD32(NV_PGRAPH_NOTIFY);
    pGrChan->CurrentPatch.PatternColor0       = REG_RD32(NV_PGRAPH_PATT_COLOR0);    
    pGrChan->CurrentPatch.PatternColor1       = REG_RD32(NV_PGRAPH_PATT_COLOR1);
    
    // In NV10, we can access the pattern RAM anytime after the engine's been idled
    for (i = 0; i < 64; i++)
        pGrChan->CurrentPatch.PatternColorRam[i] = REG_RD32(NV_PGRAPH_PATT_COLORRAM(i));
    
    pGrChan->CurrentPatch.Pattern[0]          = REG_RD32(NV_PGRAPH_PATTERN(0));
    pGrChan->CurrentPatch.Pattern[1]          = REG_RD32(NV_PGRAPH_PATTERN(1));
    pGrChan->CurrentPatch.PatternShape        = REG_RD32(NV_PGRAPH_PATTERN_SHAPE);
    
    pGrChan->CurrentPatch.MonoColor0          = REG_RD32(NV_PGRAPH_MONO_COLOR0);
    pGrChan->CurrentPatch.Rop3                = REG_RD32(NV_PGRAPH_ROP3);
    pGrChan->CurrentPatch.Chroma              = REG_RD32(NV_PGRAPH_CHROMA);
    pGrChan->CurrentPatch.BetaAnd             = REG_RD32(NV_PGRAPH_BETA_AND);
    pGrChan->CurrentPatch.BetaPremult         = REG_RD32(NV_PGRAPH_BETA_PREMULT);
    
    pGrChan->CurrentPatch.Control0            = REG_RD32(NV_PGRAPH_CONTROL0);
    pGrChan->CurrentPatch.Control1            = REG_RD32(NV_PGRAPH_CONTROL1);
    pGrChan->CurrentPatch.Control2            = REG_RD32(NV_PGRAPH_CONTROL2);
    pGrChan->CurrentPatch.Control3            = REG_RD32(NV_PGRAPH_CONTROL3);
    
    pGrChan->CurrentPatch.Blend               = REG_RD32(NV_PGRAPH_BLEND);
    pGrChan->CurrentPatch.BlendColor          = REG_RD32(NV_PGRAPH_BLENDCOLOR);
    pGrChan->CurrentPatch.SetupRaster         = REG_RD32(NV_PGRAPH_SETUPRASTER);
    pGrChan->CurrentPatch.FogColor            = REG_RD32(NV_PGRAPH_FOGCOLOR);
    pGrChan->CurrentPatch.ColorKeyColor0      = REG_RD32(NV_PGRAPH_COLORKEYCOLOR0);
    pGrChan->CurrentPatch.ColorKeyColor1      = REG_RD32(NV_PGRAPH_COLORKEYCOLOR1);
    pGrChan->CurrentPatch.PointSize           = REG_RD32(NV_PGRAPH_POINTSIZE);

    pGrChan->CurrentPatch.ZOffsetFactor       = REG_RD32(NV_PGRAPH_ZOFFSETFACTOR);
    pGrChan->CurrentPatch.ZOffsetBias         = REG_RD32(NV_PGRAPH_ZOFFSETBIAS);
    pGrChan->CurrentPatch.ZClipMin            = REG_RD32(NV_PGRAPH_ZCLIPMIN);
    pGrChan->CurrentPatch.ZClipMax            = REG_RD32(NV_PGRAPH_ZCLIPMAX);
    
    for (i = 0; i < 8; i++)
    {
        pGrChan->CurrentPatch.WinClipHorz[i]    = REG_RD32(NV_PGRAPH_WINDOWCLIP_HORIZONTAL(i));
        pGrChan->CurrentPatch.WinClipVert[i]    = REG_RD32(NV_PGRAPH_WINDOWCLIP_VERTICAL(i));
    }

    pGrChan->CurrentPatch.XFMode[0]           = REG_RD32(NV_PGRAPH_XFMODE0);
    pGrChan->CurrentPatch.XFMode[1]           = REG_RD32(NV_PGRAPH_XFMODE1);

    pGrChan->CurrentPatch.GlobalState0        = REG_RD32(NV_PGRAPH_GLOBALSTATE0);
    pGrChan->CurrentPatch.GlobalState1        = REG_RD32(NV_PGRAPH_GLOBALSTATE1);

    pGrChan->CurrentPatch.StoredFmt           = REG_RD32(NV_PGRAPH_STORED_FMT);
    pGrChan->CurrentPatch.SourceColor         = REG_RD32(NV_PGRAPH_SOURCE_COLOR);
    
    for (i = 0; i < 32; i++)
    {
        pGrChan->CurrentPatch.AbsXRam[i]      = REG_RD32(NV_PGRAPH_ABS_X_RAM(i));
        pGrChan->CurrentPatch.AbsYRam[i]      = REG_RD32(NV_PGRAPH_ABS_Y_RAM(i));
    }        
    
    pGrChan->CurrentPatch.AbsUClipXMin        = REG_RD32(NV_PGRAPH_ABS_UCLIP_XMIN);
    pGrChan->CurrentPatch.AbsUClipXMax        = REG_RD32(NV_PGRAPH_ABS_UCLIP_XMAX);
    pGrChan->CurrentPatch.AbsUClipYMin        = REG_RD32(NV_PGRAPH_ABS_UCLIP_YMIN);
    pGrChan->CurrentPatch.AbsUClipYMax        = REG_RD32(NV_PGRAPH_ABS_UCLIP_YMAX);
    
    pGrChan->CurrentPatch.AbsUClip3DXMin      = REG_RD32(NV_PGRAPH_ABS_UCLIP3D_XMIN);
    pGrChan->CurrentPatch.AbsUClip3DXMax      = REG_RD32(NV_PGRAPH_ABS_UCLIP3D_XMAX);
    pGrChan->CurrentPatch.AbsUClip3DYMin      = REG_RD32(NV_PGRAPH_ABS_UCLIP3D_YMIN);
    pGrChan->CurrentPatch.AbsUClip3DYMax      = REG_RD32(NV_PGRAPH_ABS_UCLIP3D_YMAX);
    
    pGrChan->CurrentPatch.AbsUClipAXMin       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_XMIN);
    pGrChan->CurrentPatch.AbsUClipAXMax       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_XMAX);
    pGrChan->CurrentPatch.AbsUClipAYMin       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_YMIN);
    pGrChan->CurrentPatch.AbsUClipAYMax       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_YMAX);
    
    pGrChan->CurrentPatch.AbsIClipXMax        = REG_RD32(NV_PGRAPH_ABS_ICLIP_XMAX);
    pGrChan->CurrentPatch.AbsIClipYMax        = REG_RD32(NV_PGRAPH_ABS_ICLIP_YMAX);
    
    pGrChan->CurrentPatch.XYLogicMisc0        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC0);
    pGrChan->CurrentPatch.XYLogicMisc1        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC1);
    pGrChan->CurrentPatch.XYLogicMisc2        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC2);
    pGrChan->CurrentPatch.XYLogicMisc3        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC3);

    pGrChan->CurrentPatch.ClipX0              = REG_RD32(NV_PGRAPH_CLIPX_0);
    pGrChan->CurrentPatch.ClipX1              = REG_RD32(NV_PGRAPH_CLIPX_1);
    pGrChan->CurrentPatch.ClipY0              = REG_RD32(NV_PGRAPH_CLIPY_0);
    pGrChan->CurrentPatch.ClipY1              = REG_RD32(NV_PGRAPH_CLIPY_1);
    
    pGrChan->CurrentPatch.Combine0AlphaICW    = REG_RD32(NV_PGRAPH_COMBINE0ALPHAICW);
    pGrChan->CurrentPatch.Combine1AlphaICW    = REG_RD32(NV_PGRAPH_COMBINE1ALPHAICW);
    pGrChan->CurrentPatch.Combine0ColorICW    = REG_RD32(NV_PGRAPH_COMBINE0COLORICW);
    pGrChan->CurrentPatch.Combine1ColorICW    = REG_RD32(NV_PGRAPH_COMBINE1COLORICW);

    pGrChan->CurrentPatch.Combine0Factor      = REG_RD32(NV_PGRAPH_COMBINE0FACTOR);
    pGrChan->CurrentPatch.Combine1Factor      = REG_RD32(NV_PGRAPH_COMBINE1FACTOR);

    pGrChan->CurrentPatch.Combine0AlphaOCW    = REG_RD32(NV_PGRAPH_COMBINE0ALPHAOCW);
    pGrChan->CurrentPatch.Combine1AlphaOCW    = REG_RD32(NV_PGRAPH_COMBINE1ALPHAOCW);
    pGrChan->CurrentPatch.Combine0ColorOCW    = REG_RD32(NV_PGRAPH_COMBINE0COLOROCW);
    pGrChan->CurrentPatch.Combine1ColorOCW    = REG_RD32(NV_PGRAPH_COMBINE1COLOROCW);

    pGrChan->CurrentPatch.CombineSpecFogCW0   = REG_RD32(NV_PGRAPH_COMBINESPECFOGCW0);
    pGrChan->CurrentPatch.CombineSpecFogCW1   = REG_RD32(NV_PGRAPH_COMBINESPECFOGCW1);

    pGrChan->CurrentPatch.TextureOffset0      = REG_RD32(NV_PGRAPH_TEXTUREOFFSET0);
    pGrChan->CurrentPatch.TextureOffset1      = REG_RD32(NV_PGRAPH_TEXTUREOFFSET1);
    pGrChan->CurrentPatch.TexturePalette0     = REG_RD32(NV_PGRAPH_TEXTUREPALETTE0);
    pGrChan->CurrentPatch.TexturePalette1     = REG_RD32(NV_PGRAPH_TEXTUREPALETTE1);
    pGrChan->CurrentPatch.TexFormat0          = REG_RD32(NV_PGRAPH_TEXFORMAT0);
    pGrChan->CurrentPatch.TexFormat1          = REG_RD32(NV_PGRAPH_TEXFORMAT1);
    pGrChan->CurrentPatch.TexControl0_0       = REG_RD32(NV_PGRAPH_TEXCONTROL0_0);
    pGrChan->CurrentPatch.TexControl0_1       = REG_RD32(NV_PGRAPH_TEXCONTROL0_1);
    pGrChan->CurrentPatch.TexControl1_0       = REG_RD32(NV_PGRAPH_TEXCONTROL1_0);
    pGrChan->CurrentPatch.TexControl1_1       = REG_RD32(NV_PGRAPH_TEXCONTROL1_1);
    pGrChan->CurrentPatch.TexControl2_0       = REG_RD32(NV_PGRAPH_TEXCONTROL2_0);
    pGrChan->CurrentPatch.TexControl2_1       = REG_RD32(NV_PGRAPH_TEXCONTROL2_1);

    pGrChan->CurrentPatch.ImageRect0          = REG_RD32(NV_PGRAPH_IMAGERECT0);
    pGrChan->CurrentPatch.ImageRect1          = REG_RD32(NV_PGRAPH_IMAGERECT1);

    pGrChan->CurrentPatch.Filter0             = REG_RD32(NV_PGRAPH_FILTER0);
    pGrChan->CurrentPatch.Filter1             = REG_RD32(NV_PGRAPH_FILTER1);
    
    pGrChan->CurrentPatch.Passthru0           = REG_RD32(NV_PGRAPH_PASSTHRU_0);    
    pGrChan->CurrentPatch.Passthru1           = REG_RD32(NV_PGRAPH_PASSTHRU_1);    
    pGrChan->CurrentPatch.Passthru2           = REG_RD32(NV_PGRAPH_PASSTHRU_2);    
    
    pGrChan->CurrentPatch.DimxTexture         = REG_RD32(NV_PGRAPH_DIMX_TEXTURE);
    pGrChan->CurrentPatch.WdimxTexture        = REG_RD32(NV_PGRAPH_WDIMX_TEXTURE);

    pGrChan->CurrentPatch.DVDColorFormat      = REG_RD32(NV_PGRAPH_DVD_COLORFMT);    
    pGrChan->CurrentPatch.ScaledFormat        = REG_RD32(NV_PGRAPH_SCALED_FORMAT);    
    
    pGrChan->CurrentPatch.Misc24_0            = REG_RD32(NV_PGRAPH_MISC24_0);
    pGrChan->CurrentPatch.Misc24_1            = REG_RD32(NV_PGRAPH_MISC24_1);
    pGrChan->CurrentPatch.Misc24_2            = REG_RD32(NV_PGRAPH_MISC24_2);
    pGrChan->CurrentPatch.XMisc               = REG_RD32(NV_PGRAPH_X_MISC);
    pGrChan->CurrentPatch.YMisc               = REG_RD32(NV_PGRAPH_Y_MISC);
    pGrChan->CurrentPatch.Valid1              = REG_RD32(NV_PGRAPH_VALID1);
    pGrChan->CurrentPatch.Valid2              = REG_RD32(NV_PGRAPH_VALID2);

    // save pipe context if a 3D object exists in the channel
    if (pGrHalPvtInfo->currentObjects3d[ChID] != 0)
    {
        U032 grclass = INST_RD32(pGrHalPvtInfo->currentObjects3d[ChID],
                                 SF_OFFSET(NV_PRAMIN_CONTEXT_0)) & DRF_MASK(NV_PGRAPH_CTX_SWITCH1_GRCLASS);

        if ((grclass == NV10_DX5_TEXTURED_TRIANGLE) || (grclass == NV10_DX6_MULTI_TEXTURE_TRIANGLE))
        {
            grUnloadPipeContext(pHalHwInfo, PIPE_FILE_BASE, pGrChan->CurrentPatch.CurrentPipe.VertexFile, VERTEX_FILE_COUNT);
            grUnloadPipeContext(pHalHwInfo, PIPE_VAB_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_VAB, XF_VAB_COUNT);
        }
        else
        {
            grUnloadPipeContext(pHalHwInfo, PIPE_VAB_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_VAB, XF_VAB_COUNT);
            grUnloadPipeContext(pHalHwInfo, PIPE_ASSM_BASE,	pGrChan->CurrentPatch.CurrentPipe.PrimAssm, PRIM_ASSM_COUNT);
        }

        // unload transform engine state
        grUnloadPipeContext(pHalHwInfo, PIPE_CHEOPS_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_CHEOPS, XF_CHEOPS_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER, XF_ZOSER_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_C0_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C0, XF_ZOSER_C0_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_C1_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C1, XF_ZOSER_C1_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_C2_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C2, XF_ZOSER_C2_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_C3_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C3, XF_ZOSER_C3_COUNT);

        // unload index DMA pipe state
        grUnloadPipeContext(pHalHwInfo, PIPE_PRIM_BASE, pGrChan->CurrentPatch.CurrentPipe.IndexDmaPrim, INDEX_DMA_PRIM_COUNT);

#ifdef CHECK_VTX_COUNT
{
        U032 InitCtxtPtr = pHalHwInfo->pPramHalInfo->FifoContextAddr + (ChID * 32);
        U032 vtxcount = pGrChan->CurrentPatch.CurrentPipe.IndexDmaPrim[0x3] & 0x1F00;

        if (vtxcount) {
            U032 method = REG_RD32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_METHOD))) & 0x1FFF;
            if ((method < NV056_INLINE_ARRAY(0)) || (method >= NV056_INLINE_ARRAY(0x200)))
                _asm int 3;
        }
}
#endif
        grUnloadPipeContext(pHalHwInfo, PIPE_FORMAT_BASE, pGrChan->CurrentPatch.CurrentPipe.IndexDmaFormat, INDEX_DMA_FORMAT_COUNT);

        // wait for the pipe to go idle again after unloading the pipeline context
        HAL_GR_IDLE(pHalHwInfo);
    }

    //
    // Invalidate hw's channel ID.
    //
    REG_WR32(NV_PGRAPH_CTX_CONTROL, DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _EXPIRED)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));

    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, (NUM_FIFOS_NV10 - 1));

    return (RM_OK);
}

RM_STATUS
nvHalGrGetState_NV10(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData, U032 useCtxDma)
{
    PGRHALINFO_NV10 pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV10 pGrChannel;
    U032 ChID;
    U032 access, instance;
    U032 i, format, temp;
    NvGraphicsState *stateptr;
    RM_STATUS status;
    PDMAHALOBJINFO pDmaHalInfo;

    GR_PRINTF((DBG_LEVEL_INFO, "NVRM: nvHalGrGetState\r\n"));

    pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    pGrChannel = &pGrHalPvtInfo->grChannels[pGrExceptionData->ChID];
    ChID = pGrExceptionData->ChID;

#ifdef DEBUG
    // we're from a GR exception, so we should be idled/disable already
    if (REG_RD_DRF(_PGRAPH, _FIFO, _ACCESS) || REG_RD32(NV_PGRAPH_STATUS))
        DBG_BREAKPOINT();
#endif

    access = REG_RD32(NV_PGRAPH_FIFO);
	REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);
    GR_DONE();

    if (useCtxDma)
    {
        // determine where the ContextDmaState buffer resides (kept in GLOBALSTATE1)
        if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) == ChID)
            instance = REG_RD_DRF(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_3);
        else
            instance = DRF_VAL(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_3, pGrChannel[ChID].CurrentPatch.GlobalState1);

        if (!instance)
        {
            GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: NULL ContextDmaState buffer\n\r"));
            DBG_BREAKPOINT();
            return RM_ERR_INVALID_STATE;
        }

        // convert instance address to DmaHalInfo structure
        status = dmaHalInstanceToHalInfo_NV10(ChID, instance, &pDmaHalInfo, pHalHwInfo);
        if (status)
        {
            GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: ContextDmaState invalid instance\n\r"));
            DBG_BREAKPOINT();
            return RM_ERR_INVALID_STATE;
        }

        if (pDmaHalInfo->BufferSize < sizeof (NvGraphicsState))
        {
            GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: ContextDmaState smaller than GetState data\n\r"));
            DBG_BREAKPOINT();
            return status;
        }

        stateptr = (NvGraphicsState *)pDmaHalInfo->BufferBase;
    }
    else
    {
        // use the local NvGraphicsState for the Snapshot/Reload interface
        stateptr = &pGrHalPvtInfo->grSnapShots[ChID];
    }

    // copy out the data
    if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) == ChID)
    {
        // first 4 DWORDS of NvGraphicsState is the PerFragment state
        ((U032 *)stateptr)[0] = REG_RD32(NV_PGRAPH_CONTROL0);
        ((U032 *)stateptr)[1] = REG_RD32(NV_PGRAPH_CONTROL1);
        ((U032 *)stateptr)[2] = REG_RD32(NV_PGRAPH_CONTROL2);
        ((U032 *)stateptr)[3] = REG_RD32(NV_PGRAPH_BLEND);

        // save the WITHIN_BEGINEND state
        stateptr->glBeginEndState = REG_RD32(NV_PGRAPH_GLOBALSTATE0);

        // read the
        //      PerVertexState from the VAB,
        //      PrimitiveAssembly from PIPE_ASSM_BASE
        //      PerVertextState.EdgeFlag from PRIM_BASE
        //      VertexArrayState from PIPE_FORMAT
        grUnloadPipeContext(pHalHwInfo, PIPE_VAB_BASE,    (U032 *)(&stateptr->PerVertexState), XF_VAB_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_ASSM_BASE,   (U032 *)(&stateptr->PrimitiveAssmState), PRIM_ASSM_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_PRIM_BASE,   (U032 *)(&stateptr->PerVertexState.pad3), INDEX_DMA_PRIM_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_FORMAT_BASE, (U032 *)(&stateptr->VertexArrayState), INDEX_DMA_FORMAT_COUNT);
    } else {
        // first 4 DWORDS of NvGraphicsState is the PerFragment state
        ((U032 *)stateptr)[0] = pGrChannel->CurrentPatch.Control0;
        ((U032 *)stateptr)[1] = pGrChannel->CurrentPatch.Control1;
        ((U032 *)stateptr)[2] = pGrChannel->CurrentPatch.Control2;
        ((U032 *)stateptr)[3] = pGrChannel->CurrentPatch.Blend;
            
        // read the
        //      PerVertexState from the VAB,
        //      PrimitiveAssembly from PIPE_ASSM_BASE
        //      PerVertextState.EdgeFlag from PRIM_BASE
        //      VertexArrayState from PIPE_FORMAT
        for (i = 0; i < (XF_VAB_COUNT << 2); i++)
            *(((char *)(&stateptr->PerVertexState))+i) = *(((char *)pGrChannel->CurrentPatch.CurrentPipe.XF_VAB)+i);

        for (i = 0; i < (PRIM_ASSM_COUNT << 2); i++)
            *(((char *)(&stateptr->PrimitiveAssmState))+i) = *(((char *)pGrChannel->CurrentPatch.CurrentPipe.PrimAssm)+i);

        for (i = 0; i < (INDEX_DMA_PRIM_COUNT << 2); i++)
            *(((char *)(&stateptr->PerVertexState.pad3))+i) = *(((char *)pGrChannel->CurrentPatch.CurrentPipe.IndexDmaPrim)+i);

        for (i = 0; i < (INDEX_DMA_FORMAT_COUNT << 2); i++)
            *(((char *)(&stateptr->VertexArrayState))+i) = *(((char *)pGrChannel->CurrentPatch.CurrentPipe.IndexDmaFormat)+i);
    }

#ifdef CHECK_BEGINEND_MISMATCH
    if (stateptr->PerVertexState.pad3 && 
        (REG_RD_DRF(_PGRAPH, _GLOBALSTATE0, _WITHIN_BEGINEND) == 0)) {
        _asm int 3;
    }
    if ((stateptr->PerVertexState.pad3 == 0) && 
         REG_RD_DRF(_PGRAPH, _GLOBALSTATE0, _WITHIN_BEGINEND)) {
        _asm int 3;
    }
#endif

    // correct FORMAT_SIZE bits 7:4 for the HW context read bug (driver shadowed in INV2_MATRIX_OFFSET)
    grUnloadPipeContext(pHalHwInfo, INV2_MATRIX_OFFSET, &format, 0x1);

    for (i = 1; i < INDEX_DMA_FORMAT_COUNT; i += 2, format >>= 4)
    {
        temp = ((U032 *) &stateptr->VertexArrayState)[i];
        temp = (temp & 0xFFFFFF0F) | ((format & 0xF) << 4);
        ((U032 *) &stateptr->VertexArrayState)[i] = temp;
    }

    GR_DONE();
    REG_WR32(NV_PGRAPH_FIFO, access);

    return RM_OK;
}

RM_STATUS
nvHalGrPutState_NV10(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData, U032 useCtxDma)
{
    PGRHALINFO_NV10 pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV10 pGrChannel;
    U032 access, instance;
    U032 i;
    NvGraphicsState *stateptr;
    RM_STATUS   status;
    PDMAHALOBJINFO pDmaHalInfo;

    GR_PRINTF((DBG_LEVEL_INFO, "NVRM: nvHalGrPutState\r\n"));

    pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    pGrChannel = &pGrHalPvtInfo->grChannels[pGrExceptionData->ChID];

    access = REG_RD32(NV_PGRAPH_FIFO);
    REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);
    GR_DONE();

    if (useCtxDma) {
        // determine where the ContextDmaState buffer resides (kept in GLOBALSTATE1)
        if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) == pGrExceptionData->ChID)
            instance = REG_RD_DRF(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_3);
        else
            instance = DRF_VAL(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_3, pGrChannel[pGrExceptionData->ChID].CurrentPatch.GlobalState1);

        if (!instance)
        {
            GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: NULL ContextDmaState buffer\n\r"));
            DBG_BREAKPOINT();
            return RM_ERROR;
        }

        // convert instance address to DmaHalInfo structure
        status = dmaHalInstanceToHalInfo_NV10(pGrExceptionData->ChID, instance, &pDmaHalInfo, pHalHwInfo);
        if (status)
        {
            GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Invalid ContextDmaState buffer\n\r"));
            DBG_BREAKPOINT();
            return RM_ERR_INVALID_STATE;
        }

        // ensure DmaState buffer is large enough for the GetState data
        if (pDmaHalInfo->BufferSize < sizeof(NvGraphicsState))
        {
            GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: ContextDmaState smaller than GetState data\n\r"));
            DBG_BREAKPOINT();
            return status;
        }

        stateptr = (NvGraphicsState *)pDmaHalInfo->BufferBase;
    } else {
        // use the local NvGraphicsState for the Snapshot/Reload interface
        stateptr = &pGrHalPvtInfo->grSnapShots[pGrExceptionData->ChID];
    }

    // copy data to the HW
    if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) == pGrExceptionData->ChID)
    {
        U032 xfmode0, xfmode1;
        U032 scale[SCALEOFFSET_COUNT];
        U032 fog[FOG_COUNT];
        U032 fog_eyedist[FOG_EYEDIST_COUNT];

        // first 4 DWORDS of NvGraphicsState is the PerFragment state
        REG_WR32(NV_PGRAPH_CONTROL0, ((U032 *)stateptr)[0]);
        REG_WR32(NV_PGRAPH_CONTROL1, ((U032 *)stateptr)[1]);
        REG_WR32(NV_PGRAPH_CONTROL2, ((U032 *)stateptr)[2]);
        REG_WR32(NV_PGRAPH_BLEND,    ((U032 *)stateptr)[3]);

        // restore the WITHIN_BEGINEND state
        REG_WR32(NV_PGRAPH_GLOBALSTATE0, stateptr->glBeginEndState);

        // Because we'll need to change bits of the pipe state to put the engines
        // in passthrough mode, we'll need to keep the current values, so we can
        // restore them after we've reloaded PRIM_ASSM.

        // save current xfmode values (modified for passthrough)
        xfmode0 = REG_RD32(NV_PGRAPH_XFMODE0);
        xfmode1 = REG_RD32(NV_PGRAPH_XFMODE1);

        // save current scale/offset constants in ModelViewMatrix1 (modified for passthrough)
        grUnloadPipeContext(pHalHwInfo, PIPE_CHEOPS_BASE + (3*64), scale, SCALEOFFSET_COUNT);

        // save current fog constants (modified for passthrough)
        if (IsNV10MaskRevA02orBetter_NV10(pHalHwInfo->pMcHalInfo))
        {
            grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), fog, FOG_COUNT);
            grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x28 << 4), fog_eyedist, FOG_EYEDIST_COUNT);
        } else
            grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), fog, FOG_COUNT);

        // Now, change the pipe state so that the engines are in passthrough mode.

        // set vertex passthrough mode (pass data unchanged down the pipe)
        REG_WR32(NV_PGRAPH_XFMODE0,         Vertex_Passthr_Mode[0]);
        REG_WR32(NV_PGRAPH_XFMODE1,         Vertex_Passthr_Mode[1]);

        // set scale and offset constants in ModelViewMatrix1 for passthrough
        grLoadPipeContext(pHalHwInfo, PIPE_CHEOPS_BASE + (3*64), ScaleOffset_Passthr_Mode, SCALEOFFSET_COUNT);

        // set fog constants for passthrough (different between A01 and A02)
        if (IsNV10MaskRevA02orBetter_NV10(pHalHwInfo->pMcHalInfo))
        {
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), Fog_Passthr_Mode[1], FOG_COUNT);
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x28 << 4), Fog_EyeDist_Passthr_Mode, FOG_EYEDIST_COUNT);
        } else
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), Fog_Passthr_Mode[0], FOG_COUNT);

        // set PrimType=QUAD (0x8), which puts the following vertices into primitive assembly
        i = 0x8;
        grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE, &i, 0x1);

        // restore the PrimitiveAssembly
        grLoadPipeContext(pHalHwInfo, PIPE_ASSM_BASE,   (U032 *)(&stateptr->PrimitiveAssmState), PRIM_ASSM_COUNT);

        // After primitive assembly is restored, reload the original values we
        // modified to put the engines in passthrough mode.

        // restore current xfmode (modified for passthrough)
        REG_WR32(NV_PGRAPH_XFMODE0, xfmode0);
        REG_WR32(NV_PGRAPH_XFMODE1, xfmode1);

        // restore current scale/offset constants in ModelViewMatrix1 (modified for passthrough)
        grLoadPipeContext(pHalHwInfo, PIPE_CHEOPS_BASE + (3*64), scale, SCALEOFFSET_COUNT);
        
        // restore current fog constants (modified for passthrough)
        if (IsNV10MaskRevA02orBetter_NV10(pHalHwInfo->pMcHalInfo))
        {
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), fog, FOG_COUNT);
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x28 << 4), fog_eyedist, FOG_EYEDIST_COUNT);
        } else
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), fog, FOG_COUNT);

        // restore the
        //      PerVertexState to the VAB,
        //      VertexArrayState to PIPE_FORMAT
        //      PerVertextState.EdgeFlag to PRIM_BASE
        grLoadPipeContext(pHalHwInfo, PIPE_VAB_BASE,    (U032 *)(&stateptr->PerVertexState), XF_VAB_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_FORMAT_BASE, (U032 *)(&stateptr->VertexArrayState), INDEX_DMA_FORMAT_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE,   (U032 *)(&stateptr->PerVertexState.pad3), INDEX_DMA_PRIM_COUNT);

		// force an invalidate of the vertex cache 
        i = 0x0;
        grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE+0x80, &i, 0x1);

#ifdef CHECK_BEGINEND_MISMATCH
        // check for a state mismatch
        if (stateptr->PerVertexState.pad3 && 
            (REG_RD_DRF(_PGRAPH, _GLOBALSTATE0, _WITHIN_BEGINEND) == 0)) {
            _asm int 3;
        }

        if ((stateptr->PerVertexState.pad3 == 0) && 
             REG_RD_DRF(_PGRAPH, _GLOBALSTATE0, _WITHIN_BEGINEND)) {
            _asm int 3;
        }
#endif
    } else {
        // first 4 DWORDS of NvGraphicsState is the PerFragment state
        pGrChannel->CurrentPatch.Control0 = ((U032 *)stateptr)[0];
        pGrChannel->CurrentPatch.Control1 = ((U032 *)stateptr)[1];
        pGrChannel->CurrentPatch.Control2 = ((U032 *)stateptr)[2];
        pGrChannel->CurrentPatch.Blend    = ((U032 *)stateptr)[3];

        // restore the
        //      PerVertexState to the VAB,
        //      PrimitiveAssembly to PIPE_ASSM_BASE
        //      PerVertextState.EdgeFlag to PRIM_BASE
        //      VertexArrayState to PIPE_FORMAT
        for (i = 0; i < (XF_VAB_COUNT << 2); i++)
            *(((char *)pGrChannel->CurrentPatch.CurrentPipe.XF_VAB)+i) = *(((char *)(&stateptr->PerVertexState))+i);

        for (i = 0; i < (PRIM_ASSM_COUNT << 2); i++)
            *(((char *)pGrChannel->CurrentPatch.CurrentPipe.PrimAssm)+i) = *(((char *)(&stateptr->PrimitiveAssmState))+i);

        for (i = 0; i < (INDEX_DMA_PRIM_COUNT << 2); i++)
            *(((char *)pGrChannel->CurrentPatch.CurrentPipe.IndexDmaPrim)+i) = *(((char *)(&stateptr->PerVertexState.pad3))+i);

        for (i = 0; i < (INDEX_DMA_FORMAT_COUNT << 2); i++)
            *(((char *)pGrChannel->CurrentPatch.CurrentPipe.IndexDmaFormat)+i) = *(((char *)(&stateptr->VertexArrayState))+i);
    }

    GR_DONE();
    REG_WR32(NV_PGRAPH_FIFO, access);

    return RM_OK;
}

#define ZOSER_MATERIAL_COLOR_BASE   0x6aa0

//
// Workaround a HW problem where a Celsius SetMaterialEmission will be ignored in
// between a Begin/End. This is a SW method OGL calls to have us plugin the value.
// 
RM_STATUS nvHalGrSetMaterialEmission_NV10(
    PHALHWINFO pHalHwInfo,
    PGREXCEPTIONDATA pGrExceptionData
)
{
    U032    pipeAddr = ZOSER_MATERIAL_COLOR_BASE + (pGrExceptionData->Offset - NV056_SET_MATERIAL_EMISSION_SW(0));

    grLoadPipeContext(pHalHwInfo, pipeAddr, &pGrExceptionData->Data, 0x1);
    GR_DONE();

    return (RM_OK);
}

//
// This method gives D3D access to the eye direction state.
//

#define ZOSER_EYE_DIR_BASE      0x6a80

RM_STATUS nvHalGrSetEyeDirection_NV10(
    PHALHWINFO pHalHwInfo,
    PGREXCEPTIONDATA pGrExceptionData
)
{
    U032    pipeAddr = ZOSER_EYE_DIR_BASE + (pGrExceptionData->Offset - NV056_SET_EYE_DIRECTION_SW(0));

    grLoadPipeContext(pHalHwInfo, pipeAddr, &pGrExceptionData->Data, 0x1);
    GR_DONE();

    return (RM_OK);
}

#define CHEOPS_VIEWPORT_OFFSET_BASE  0x6790

//
// Workaround a HW problem where a Celsius SetViewportOffset will be ignored in
// between a Begin/End. This is a SW method OGL calls to have us plugin the value.
// 
RM_STATUS nvHalGrSetViewportOffset_NV10(
    PHALHWINFO pHalHwInfo,
    PGREXCEPTIONDATA pGrExceptionData
)
{
    U032    pipeAddr = CHEOPS_VIEWPORT_OFFSET_BASE + 
                       (pGrExceptionData->Offset - NV056_SET_VIEWPORT_OFFSET_SW(0));

    grLoadPipeContext(pHalHwInfo, pipeAddr, &pGrExceptionData->Data, 0x1);
    GR_DONE();

    return (RM_OK);
}

#define CHEOPS_PASSTHRU_VIEWPORT_OFFSET_BASE  0x64d0

//
// Workaround a HW problem where a Celsius SetViewportOffset will be ignored in
// between a Begin/End. This is a SW method OGL calls to have us plugin the value.
// 
RM_STATUS nvHalGrSetPassthruViewportOffset_NV10(
    PHALHWINFO pHalHwInfo,
    PGREXCEPTIONDATA pGrExceptionData
)
{
    U032    pipeAddr = CHEOPS_PASSTHRU_VIEWPORT_OFFSET_BASE +
                       (pGrExceptionData->Offset - NV056_SET_PASSTHRU_VIEWPORT_OFFSET_SW(0));

    grLoadPipeContext(pHalHwInfo, pipeAddr, &pGrExceptionData->Data, 0x1);
    GR_DONE();

    return (RM_OK);
}

static RM_STATUS grDelay_NV10(
    PHALHWINFO pHalHwInfo,
    U032 nsec
)
{
    U032 TimeHi;
    U032 TimeLo;
    U032 TimeCheck;
    
    //
    // For small delays which can only wrap PTIMER_TIME_0 once, doing 2's
    // comp math on TIME_0 is enough and means we don't have to sync TIME_1
    //
#define MAX_SMALLNS_TMRDELAY (0xFFFFFFFF >> 2)

    if (nsec < MAX_SMALLNS_TMRDELAY)
    {
        U032 TimeStart = REG_RD32(NV_PTIMER_TIME_0);
        while (nsec > ((volatile U032)REG_RD32(NV_PTIMER_TIME_0) - TimeStart))
		    ;
        return (RM_OK);
    }

    //
    // Get current time.
    //
    do
    {
        TimeCheck = REG_RD32(NV_PTIMER_TIME_1);
        TimeLo    = REG_RD32(NV_PTIMER_TIME_0);
        TimeHi    = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != TimeHi);

    //
    // Add nanosecond delay.
    //
    TimeLo += nsec;
    if (TimeLo < nsec)
        TimeHi++;
    //
    // Wait until time catches up.
    //
    while (TimeHi > (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_1)))
        ;
    //
    // Try to avoid infinite delay.
    //
    while ((TimeLo > (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_0))) &&
           (TimeHi == (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_1))))
                 ;

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\gr\nv20\grmdnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: grmdnv20.c                                                        *
*   The graphics chip dependent method routines are kept here.              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// First level method handler.
//
RM_STATUS nvHalGrClassSoftwareMethod_NV20(PHALHWINFO, PGREXCEPTIONDATA);

//
// Externs.
//
extern RM_STATUS nvHalGrGetState_NV20(PHALHWINFO, PGREXCEPTIONDATA);
extern RM_STATUS nvHalGrPutState_NV20(PHALHWINFO, PGREXCEPTIONDATA);
extern RM_STATUS nvHalGrSnapshot_NV20(PHALHWINFO, PGREXCEPTIONDATA);
extern RM_STATUS nvHalGrReload_NV20(PHALHWINFO, PGREXCEPTIONDATA);
extern RM_STATUS nvHalGrSetEyeDirection_NV20(PHALHWINFO, PGREXCEPTIONDATA);
extern RM_STATUS nvHalGrSetViewportOffsetCelsius_NV20(PHALHWINFO, PGREXCEPTIONDATA);
extern RM_STATUS nvHalGrSetPassthruViewportOffsetCelsius_NV20(PHALHWINFO, PGREXCEPTIONDATA);
extern RM_STATUS nvHalGrSetViewportOffsetKelvin_NV20(PHALHWINFO, PGREXCEPTIONDATA);
extern RM_STATUS nvHalGrSetPassthruViewportOffsetKelvin_NV20(PHALHWINFO, PGREXCEPTIONDATA);

//
// GetState method wrapper.
//
RM_STATUS nvHalGr3dGetState_NV20(PHALHWINFO, PGREXCEPTIONDATA);

//
// NV10_CELSIUS methods handled in the HAL.
//
static HALGRMETHOD Nv10CelsiusPrimitiveHalMethods[] =
{
    {nvHalGr3dGetState_NV20,                        0x010c, 0x010f},
    {nvHalGrSetEyeDirection_NV20,                   0x072c, 0x0737},
    // The OpenGL driver uses the two software methods below when
    // the clip changes in mid-begin/end to work-around the fact
    // that the front-end rejects the corresponding hardware
    // methods when inside a begin/end.
    {nvHalGrSetViewportOffsetCelsius_NV20,          0x1638, 0x1647},
    {nvHalGrSetPassthruViewportOffsetCelsius_NV20,  0x1648, 0x1657},
};

//
// NV15_CELSIUS / NV11_CELSIUS methods handled in the HAL.
//
static HALGRMETHOD Nv15CelsiusPrimitiveHalMethods[] =
{
    {nvHalGr3dGetState_NV20,                        0x010c, 0x010f},
    {nvHalGrSetEyeDirection_NV20,                   0x072c, 0x0737},
    // The OpenGL driver uses the two software methods below when
    // the clip changes in mid-begin/end to work-around the fact
    // that the front-end rejects the corresponding hardware
    // methods when inside a begin/end.
    {nvHalGrSetViewportOffsetCelsius_NV20,          0x1638, 0x1647},
    {nvHalGrSetPassthruViewportOffsetCelsius_NV20,  0x1648, 0x1657},
};

//
// NV20_KELVIN HAL method table.
//
static HALGRMETHOD Nv20KelvinPrimitiveHalMethods[] =
{
    {nvHalGr3dGetState_NV20,                        0x010c, 0x010f},
    // The OpenGL driver uses the two software methods below when
    // the clip changes in mid-begin/end to work-around the fact
    // that the front-end rejects the corresponding hardware
    // methods when inside a begin/end.
    {nvHalGrSetViewportOffsetKelvin_NV20,           0x1f00, 0x1f0f},
    {nvHalGrSetPassthruViewportOffsetKelvin_NV20,   0x1f10, 0x1f1f},
};

//
// HAL graphics method table.
//
HALGRMETHODS nvHalGrMethods_NV20[] =
{
    { NV10_CELSIUS_PRIMITIVE,           Nv10CelsiusPrimitiveHalMethods,
                                        sizeof (Nv10CelsiusPrimitiveHalMethods) / sizeof (HALGRMETHOD) },

    { NV15_CELSIUS_PRIMITIVE,           Nv15CelsiusPrimitiveHalMethods,
                                        sizeof (Nv15CelsiusPrimitiveHalMethods) / sizeof (HALGRMETHOD) },

    // NV11 and NV15 Celsius share the same method struct.
    { NV11_CELSIUS_PRIMITIVE,           Nv15CelsiusPrimitiveHalMethods,
                                        sizeof (Nv15CelsiusPrimitiveHalMethods) / sizeof (HALGRMETHOD) },

    { NV20_KELVIN_PRIMITIVE,            Nv20KelvinPrimitiveHalMethods,
                                        sizeof (Nv20KelvinPrimitiveHalMethods) / sizeof (HALGRMETHOD) },
};
#define NUM_HALGRMETHODS                sizeof (nvHalGrMethods_NV20) / sizeof (HALGRMETHODS)

RM_STATUS
nvHalGrClassSoftwareMethod_NV20(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    U032 i, j;

    for (i = 0; i < NUM_HALGRMETHODS; i++)
    {
        //
        // Find out if this class has any HAL methods.
        //
        if (nvHalGrMethods_NV20[i].classNum == pGrExceptionData->classNum)
        {
            //
            // See if this particular method is a HAL method.
            //
            for (j = 0; j < nvHalGrMethods_NV20[i].methodMax; j++)
            {
                if ((pGrExceptionData->Offset >= nvHalGrMethods_NV20[i].pMethods[j].Low) &&
                    (pGrExceptionData->Offset < nvHalGrMethods_NV20[i].pMethods[j].High))
                {
                    //
                    // Idle graphics.
                    //
                    GR_DONE();

                    //
                    // Route the method.
                    //
                    pGrExceptionData->MethodStatus = nvHalGrMethods_NV20[i].pMethods[j].Proc(pHalHwInfo, pGrExceptionData);
                    return (RM_OK);
                }
            }
        }
    }

    //
    // HAL didn't service this method.
    // This isn't really an error, since the RM may still want
    // to do something.
    //
    return (RM_ERROR);
}

//
// NV20 GetState method.
//
// Used by class056/class096/class097 methods.  Assumes all
// have identical semantics.
//
RM_STATUS
nvHalGr3dGetState_NV20(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    RM_STATUS retval;

    GR_PRINTF((DBG_LEVEL_INFO, "NVRM: nvHalGr3dGetState_NV20\r\n"));

    switch (pGrExceptionData->Data)
    {
        case NV056_GET_STATE_GETSTATE_ALL_STATE:
            retval = nvHalGrGetState_NV20(pHalHwInfo, pGrExceptionData);
            break;

        case NV056_GET_STATE_PUTSTATE_ALL_STATE:
            retval = nvHalGrPutState_NV20(pHalHwInfo, pGrExceptionData);
            break;

        case NV056_GET_STATE_GETSTATE_SNAPSHOT_PRIM_ASSM:
            retval = nvHalGrSnapshot_NV20(pHalHwInfo, pGrExceptionData);
            break;

        case NV056_GET_STATE_GETSTATE_RELOAD_PRIM_ASSM:
            retval = nvHalGrReload_NV20(pHalHwInfo, pGrExceptionData);
            break;

        default:
            retval = RM_ERR_BAD_ARGUMENT;
    }    

    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\gr\nv20\grcxnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: grcxnv20.c                                                        *
*   The nv20 graphics engine context switching is managed in this module.   *
*   On nv20, context switching is handled in hardware, so all we really     *
*   have to do here is handle methods in the 3d classes that require        *
*   accessing internal pipe state.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include <heap.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
static VOID grUnloadRdiContext(PHALHWINFO, U032, U032, U032, U032 *);
static VOID grLoadRdiContext(PHALHWINFO, U032, U032, U032, U032 *);

RM_STATUS nvHalGrLoadChannelContext_NV20(PHALHWINFO, U032);
RM_STATUS nvHalGrUnloadChannelContext_NV20(PHALHWINFO, U032);

// externs
extern RM_STATUS dmaHalInstanceToHalInfo_NV20(U032, U032, PDMAHALOBJINFO *, PHALHWINFO);

//
// Load Pipe Context
//
#if 0  // static, but never called
static RM_STATUS
grLoadPipeContext(
    PHALHWINFO pHalHwInfo,
    U032       Base,
    U032      *SaveAddr,
    U032       Count
)
{
    U032 i;

    REG_WR32(NV_PGRAPH_PIPE_ADDRESS, Base);
    for (i = 0; i < Count; i++) {
	  REG_WR32(NV_PGRAPH_PIPE_DATA, SaveAddr[i]);
    }
    return (RM_OK);
}

//
// Unload Pipe Context
//
static RM_STATUS
grUnloadPipeContext(
    PHALHWINFO pHalHwInfo,
    U032       Base,
    U032      *SaveAddr,
    U032       Count
)
{
    U032 i;

    REG_WR32(NV_PGRAPH_PIPE_ADDRESS, Base);
    for (i = 0; i < Count; i++) {
	  SaveAddr[i] = REG_RD32(NV_PGRAPH_PIPE_DATA);
    }
    return (RM_OK);
}
#endif

//
// Unload Rdi Context
//
static VOID
grUnloadRdiContext(
    PHALHWINFO pHalHwInfo,
    U032       ramSel,
    U032       offset,
    U032       count,
    U032      *saveAddr
)
{
    U032 i;

    REG_WR32(NV_PGRAPH_RDI_INDEX, (ramSel<<16 | offset));
    for (i = 0; i < count; i++)
        saveAddr[i] = REG_RD32(NV_PGRAPH_RDI_DATA);
}

//
// Load RDI Context
//
static VOID
grLoadRdiContext(
    PHALHWINFO pHalHwInfo,
    U032       ramSel,
    U032       offset,
    U032       count,
    U032      *saveAddr
)
{
    U032 i;

    REG_WR32(NV_PGRAPH_RDI_INDEX, (ramSel<<16 | offset));
    for (i = 0; i < count; i++)
        REG_WR32(NV_PGRAPH_RDI_DATA, saveAddr[i]);
}

RM_STATUS
nvHalGrGetState_NV20(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    PGRHALINFO_NV20 pGrHalPvtInfo;
    U032 ChID;
    U032 access, instance;
    U032 temp;
    NvGraphicsState *stateptr;
    RM_STATUS status;
    PDMAHALOBJINFO pDmaHalInfo;

    GR_PRINTF((DBG_LEVEL_INFO, "NVRM: nvHalGrGetState\r\n"));

    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;
    ChID = pGrExceptionData->ChID;

#ifdef DEBUG
    // we're from a GR exception, so we should be idled/disable already
    if (REG_RD_DRF(_PGRAPH, _FIFO, _ACCESS) || REG_RD32(NV_PGRAPH_STATUS))
        DBG_BREAKPOINT();
#endif

    access = REG_RD32(NV_PGRAPH_FIFO);
    REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);
    GR_DONE();

    // make sure we're the current channel
    if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) != ChID)
    {
        GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: GetState method issued on non-current channel: 0x%x\n", ChID));
        DBG_BREAKPOINT();
        return RM_ERR_INVALID_STATE;
    }

    // determine where the ContextDmaState buffer resides
    instance = REG_RD_DRF(_PGRAPH, _GETSTATE, _DMA_INSTANCE);

    if (!instance)
    {
        GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: NULL ContextDmaState buffer\n\r"));
        DBG_BREAKPOINT();
        return RM_ERR_INVALID_STATE;
    }

    // convert instance address to DmaHalInfo structure
    status = dmaHalInstanceToHalInfo_NV20(ChID, instance, &pDmaHalInfo, pHalHwInfo);
    if (status)
    {
        GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: ContextDmaState invalid instance\n\r"));
        DBG_BREAKPOINT();
        return RM_ERR_INVALID_STATE;
    }

    if (pDmaHalInfo->BufferSize < sizeof (NvGraphicsState))
    {
        GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: ContextDmaState smaller than GetState data\n\r"));
        DBG_BREAKPOINT();
        return status;
    }

    stateptr = (NvGraphicsState *)pDmaHalInfo->BufferBase;

    // first 4 DWORDS of NvGraphicsState is the PerFragment state
    ((U032 *)stateptr)[0] = REG_RD32(NV_PGRAPH_CONTROL_0);
    ((U032 *)stateptr)[1] = REG_RD32(NV_PGRAPH_CONTROL_1);
    ((U032 *)stateptr)[2] = REG_RD32(NV_PGRAPH_CONTROL_2);
    ((U032 *)stateptr)[3] = REG_RD32(NV_PGRAPH_BLEND);

    // save the WITHIN_BEGINEND state
    stateptr->glBeginEndState = REG_RD32(NV_PGRAPH_SHADOW);

    //
    // Fetch PerVertexState from the VAB.
    //
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_DIFF<<4, 4, (U032 *)(&stateptr->PerVertexState.primaryColor[0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_SPEC<<4, 3, (U032 *)(&stateptr->PerVertexState.secondaryColor[0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_FOG<<4, 1, (U032 *)(&stateptr->PerVertexState.fogCoord));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_TXT0<<4, 4, (U032 *)(&stateptr->PerVertexState.texCoord[0][0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_TXT1<<4, 4, (U032 *)(&stateptr->PerVertexState.texCoord[1][0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_NRM<<4, 3, (U032 *)(&stateptr->PerVertexState.normal[0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_WGHT<<4, 1, (U032 *)(&stateptr->PerVertexState.vertexWeight));

    //
    // Fetch VertexArrayState from IDX_FMT.
    //
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_POS<<3, 2, (U032 *)(&stateptr->VertexArrayState.vertexOffset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_DIFF<<3, 2, (U032 *)(&stateptr->VertexArrayState.diffuseOffset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_SPEC<<3, 2, (U032 *)(&stateptr->VertexArrayState.specularOffset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_TXT0<<3, 2, (U032 *)(&stateptr->VertexArrayState.texCoord0Offset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_TXT1<<3, 2, (U032 *)(&stateptr->VertexArrayState.texCoord1Offset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_NRM<<3, 2, (U032 *)(&stateptr->VertexArrayState.normalOffset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_WGHT<<3, 2, (U032 *)(&stateptr->VertexArrayState.weightOffset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_FOG<<3, 2, (U032 *)(&stateptr->VertexArrayState.fogOffset));

    //
    // Fetch edgeFlag from IDX_FMT (word 48, bit 28).
    //
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, 48<<2, 1, &temp);
    stateptr->PerVertexState.edgeFlag = (temp >> 28) & 1;

    //
    // Fetch PrimitiveAssmState from Cas0/Cas1/Cas2.
    //
    // The nv10 layout (16 word values):
    //
    //  X   Y   Z   W
    //  D   S   F   ef,ptsize
    //  S   T   R   Q
    //  S   T   R   Q
    //
    // The nv20 layout (spread out over 32 word values):
    //
    //  D   S   Z   W
    //  -   -   F   -
    //  S   T   R   Q
    //  S   T   R   Q
    //  -   -   -   -
    //  -   -   -   -
    //  X   Y   ef,ptsize -
    //
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 0<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+4]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 1<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+5]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 2<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+2]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 3<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+3]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 6<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+6]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 8<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+8]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 12<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+12]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 24<<2, 2, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 26<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+7]));

    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 0<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+4]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 1<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+5]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 2<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+2]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 3<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+3]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 6<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+6]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 8<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+8]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 12<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+12]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 24<<2, 2, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 26<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+7]));

    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 0<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+4]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 1<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+5]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 2<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+2]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 3<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+3]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 6<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+6]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 8<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+8]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 12<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+12]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 24<<2, 2, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 26<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+7]));

#ifdef CHECK_BEGINEND_MISMATCH
    if (stateptr->PerVertexState.pad3 && 
        (REG_RD_DRF(_PGRAPH, _SHADOW, _WITHIN_BEGINEND) == 0)) {
        _asm int 3;
    }
    if ((stateptr->PerVertexState.pad3 == 0) && 
         REG_RD_DRF(_PGRAPH, _SHADOW, _WITHIN_BEGINEND)) {
        _asm int 3;
    }
#endif

    GR_DONE();
    REG_WR32(NV_PGRAPH_FIFO, access);

    return RM_OK;
}

RM_STATUS
nvHalGrPutState_NV20(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    PGRHALINFO_NV20 pGrHalPvtInfo;
    U032 access, instance;
    U032 temp;
    NvGraphicsState *stateptr;
    RM_STATUS status;
    PDMAHALOBJINFO pDmaHalInfo;

    GR_PRINTF((DBG_LEVEL_INFO, "NVRM: nvHalGrPutState\r\n"));

    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;

    access = REG_RD32(NV_PGRAPH_FIFO);
    REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);
    GR_DONE();

    // make sure we're the current channel
    if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) != pGrExceptionData->ChID)
    {
        GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: PutState method issued on non-current channel: 0x%x\n", pGrExceptionData->ChID));
        DBG_BREAKPOINT();
        return RM_ERR_INVALID_STATE;
    }

    // determine where the ContextDmaState buffer resides
    instance = REG_RD_DRF(_PGRAPH, _GETSTATE, _DMA_INSTANCE);
    if (!instance)
    {
        GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: NULL ContextDmaState buffer\n\r"));
        DBG_BREAKPOINT();
        return RM_ERROR;
    }

    // convert instance address to DmaHalInfo structure
    status = dmaHalInstanceToHalInfo_NV20(pGrExceptionData->ChID, instance, &pDmaHalInfo, pHalHwInfo);
    if (status)
    {
        GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Invalid ContextDmaState buffer\n\r"));
        DBG_BREAKPOINT();
        return RM_ERR_INVALID_STATE;
    }

    // ensure DmaState buffer is large enough for the GetState data
    if (pDmaHalInfo->BufferSize < sizeof (NvGraphicsState))
    {
        GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: ContextDmaState smaller than GetState data\n\r"));
        DBG_BREAKPOINT();
        return status;
    }

    stateptr = (NvGraphicsState *)pDmaHalInfo->BufferBase;

    // first 4 DWORDS of NvGraphicsState is the PerFragment state
    REG_WR32(NV_PGRAPH_CONTROL_0, ((U032 *)stateptr)[0]);
    REG_WR32(NV_PGRAPH_CONTROL_1, ((U032 *)stateptr)[1]);
    REG_WR32(NV_PGRAPH_CONTROL_2, ((U032 *)stateptr)[2]);
    REG_WR32(NV_PGRAPH_BLEND,    ((U032 *)stateptr)[3]);

    // restore the WITHIN_BEGINEND state
    REG_WR32(NV_PGRAPH_SHADOW, stateptr->glBeginEndState);

    //
    // Fetch PerVertexState from the VAB.
    //
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_DIFF<<4, 4, (U032 *)(&stateptr->PerVertexState.primaryColor[0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_SPEC<<4, 3, (U032 *)(&stateptr->PerVertexState.secondaryColor[0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_FOG<<4, 1, (U032 *)(&stateptr->PerVertexState.fogCoord));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_TXT0<<4, 4, (U032 *)(&stateptr->PerVertexState.texCoord[0][0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_TXT1<<4, 4, (U032 *)(&stateptr->PerVertexState.texCoord[1][0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_NRM<<4, 3, (U032 *)(&stateptr->PerVertexState.normal[0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_WGHT<<4, 1, (U032 *)(&stateptr->PerVertexState.vertexWeight));

    //
    // Fetch VertexArrayState from IDX_FMT.
    //
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_POS<<3, 2, (U032 *)(&stateptr->VertexArrayState.vertexOffset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_DIFF<<3, 2, (U032 *)(&stateptr->VertexArrayState.diffuseOffset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_SPEC<<3, 2, (U032 *)(&stateptr->VertexArrayState.specularOffset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_TXT0<<3, 2, (U032 *)(&stateptr->VertexArrayState.texCoord0Offset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_TXT1<<3, 2, (U032 *)(&stateptr->VertexArrayState.texCoord1Offset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_NRM<<3, 2, (U032 *)(&stateptr->VertexArrayState.normalOffset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_WGHT<<3, 2, (U032 *)(&stateptr->VertexArrayState.weightOffset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_FOG<<3, 2, (U032 *)(&stateptr->VertexArrayState.fogOffset));

    //
    // Fetch edgeFlag from IDX_FMT (word 48, bit 28).
    //
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, 48<<2, 1, &temp);
    temp &= ~0x10000000;
    temp |= ((stateptr->PerVertexState.edgeFlag & 1) << 28);
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, 48<<2, 1, &temp);

    //
    // Fetch PrimitiveAssmState from Cas0/Cas1/Cas2.
    //
    // The nv10 layout (16 word values):
    //
    //  X   Y   Z   W
    //  D   S   F   ef,ptsize
    //  S   T   R   Q
    //  S   T   R   Q
    //
    // The nv20 layout (spread out over 32 word values):
    //
    //  D   S   Z   W
    //  -   -   F   -
    //  S   T   R   Q
    //  S   T   R   Q
    //  -   -   -   -
    //  -   -   -   -
    //  X   Y   ef,ptsize -
    //
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 0<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+4]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 1<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+5]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 2<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+2]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 3<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+3]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 6<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+6]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 8<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+8]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 12<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+12]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 24<<2, 2, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 26<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+7]));

    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 0<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+4]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 1<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+5]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 2<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+2]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 3<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+3]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 6<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+6]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 8<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+8]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 12<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+12]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 24<<2, 2, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 26<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+7]));

    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 0<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+4]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 1<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+5]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 2<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+2]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 3<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+3]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 6<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+6]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 8<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+8]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 12<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+12]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 24<<2, 2, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 26<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+7]));

#ifdef CHECK_BEGINEND_MISMATCH
        // check for a state mismatch
        if (stateptr->PerVertexState.pad3 && 
            (REG_RD_DRF(_PGRAPH, _SHADOW, _WITHIN_BEGINEND) == 0)) {
            _asm int 3;
        }

        if ((stateptr->PerVertexState.pad3 == 0) && 
             REG_RD_DRF(_PGRAPH, _SHADOW, _WITHIN_BEGINEND)) {
            _asm int 3;
        }
#endif

    GR_DONE();
    REG_WR32(NV_PGRAPH_FIFO, access);

    return RM_OK;
}

RM_STATUS
nvHalGrSnapshot_NV20(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    PGRHALINFO_NV20 pGrHalPvtInfo;
    PGRAPHICSSTATE_NV20 pGrState;
    U032 access;

    GR_PRINTF((DBG_LEVEL_INFO, "NVRM: nvHalGrGetState\r\n"));

    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;

#ifdef DEBUG
    // we're from a GR exception, so we should be idled/disable already
    if (REG_RD_DRF(_PGRAPH, _FIFO, _ACCESS) || REG_RD32(NV_PGRAPH_STATUS))
        DBG_BREAKPOINT();
#endif

    access = REG_RD32(NV_PGRAPH_FIFO);
    REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);
    GR_DONE();

    // make sure we're the current channel
    if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) != pGrExceptionData->ChID)
    {
        GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: GetState method issued on non-current channel ", pGrExceptionData->ChID));
        DBG_BREAKPOINT();
        return RM_ERR_INVALID_STATE;
    }

    pGrState = &pGrHalPvtInfo->grSnapShots[pGrExceptionData->ChID];

    // save PerFragment state
    pGrState->PerFragmentState.Control0 = REG_RD32(NV_PGRAPH_CONTROL_0);
    pGrState->PerFragmentState.Control1 = REG_RD32(NV_PGRAPH_CONTROL_1);
    pGrState->PerFragmentState.Control2 = REG_RD32(NV_PGRAPH_CONTROL_2);
    pGrState->PerFragmentState.Control3 = REG_RD32(NV_PGRAPH_CONTROL_3);
    pGrState->PerFragmentState.Blend = REG_RD32(NV_PGRAPH_BLEND);

    // save the WITHIN_BEGINEND state
    pGrState->glBeginEndState = REG_RD32(NV_PGRAPH_SHADOW);

    // fetch PerVertexState from the VAB.
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, RDI_ADDR_ZERO, XL_VAB_COUNT, pGrState->PerVertexState.XlVab);

    // fetch VertexArrayState from IDX_FMT.
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, RDI_ADDR_ZERO, IDX_FMT_COUNT, pGrState->VertexArrayState.IdxFmt);

    // fetch PrimitiveAssmState from Cas0/Cas1/Cas2.
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, RDI_ADDR_ZERO, CAS0_COUNT, pGrState->PrimitiveAssmState.Cas0);
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, RDI_ADDR_ZERO, CAS1_COUNT, pGrState->PrimitiveAssmState.Cas1);
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, RDI_ADDR_ZERO, CAS2_COUNT, pGrState->PrimitiveAssmState.Cas2);
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_ASSM_STATE, RDI_ADDR_ZERO, ASSM_STATE_COUNT, pGrState->PrimitiveAssmState.AssmState);

#ifdef CHECK_BEGINEND_MISMATCH
    if (pGrState->PerVertexState.pad3 && 
        (REG_RD_DRF(_PGRAPH, _SHADOW, _WITHIN_BEGINEND) == 0)) {
        _asm int 3;
    }
    if ((pGrState->PerVertexState.pad3 == 0) && 
        REG_RD_DRF(_PGRAPH, _SHADOW, _WITHIN_BEGINEND)) {
        _asm int 3;
    }
#endif

    GR_DONE();
    REG_WR32(NV_PGRAPH_FIFO, access);

    return RM_OK;
}

RM_STATUS
nvHalGrReload_NV20(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    PGRHALINFO_NV20 pGrHalPvtInfo;
    PGRAPHICSSTATE_NV20 pGrState;
    U032 access;

    GR_PRINTF((DBG_LEVEL_INFO, "NVRM: nvHalGrPutState\r\n"));

    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;

    access = REG_RD32(NV_PGRAPH_FIFO);
    REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);
    GR_DONE();

    // make sure we're the current channel
    if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) != pGrExceptionData->ChID)
    {
        GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: PutState method issued on non-current channel ", pGrExceptionData->ChID));
        DBG_BREAKPOINT();
        return RM_ERR_INVALID_STATE;
    }

    pGrState = &pGrHalPvtInfo->grSnapShots[pGrExceptionData->ChID];

    // restore VAB state
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, RDI_ADDR_ZERO, XL_VAB_COUNT, pGrState->PerVertexState.XlVab);

    // restore VertexArrayState
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, RDI_ADDR_ZERO, IDX_FMT_COUNT, pGrState->VertexArrayState.IdxFmt);

    // restore PrimitiveAssmState
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, RDI_ADDR_ZERO, CAS0_COUNT, pGrState->PrimitiveAssmState.Cas0);
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, RDI_ADDR_ZERO, CAS1_COUNT, pGrState->PrimitiveAssmState.Cas1);
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, RDI_ADDR_ZERO, CAS2_COUNT, pGrState->PrimitiveAssmState.Cas2);
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_ASSM_STATE, RDI_ADDR_ZERO, ASSM_STATE_COUNT, pGrState->PrimitiveAssmState.AssmState);

    // restore per-fragment state
    REG_WR32(NV_PGRAPH_CONTROL_0, pGrState->PerFragmentState.Control0);
    REG_WR32(NV_PGRAPH_CONTROL_1, pGrState->PerFragmentState.Control1);
    REG_WR32(NV_PGRAPH_CONTROL_2, pGrState->PerFragmentState.Control2);
    REG_WR32(NV_PGRAPH_CONTROL_3, pGrState->PerFragmentState.Control3);
    REG_WR32(NV_PGRAPH_BLEND, pGrState->PerFragmentState.Blend);

    // restore the WITHIN_BEGINEND state
    REG_WR32(NV_PGRAPH_SHADOW, pGrState->glBeginEndState);

#ifdef CHECK_BEGINEND_MISMATCH
    // check for a state mismatch
    if (stateptr->PerVertexState.pad3 && 
        (REG_RD_DRF(_PGRAPH, _SHADOW, _WITHIN_BEGINEND) == 0)) {
        _asm int 3;
    }

    if ((stateptr->PerVertexState.pad3 == 0) && 
        REG_RD_DRF(_PGRAPH, _SHADOW, _WITHIN_BEGINEND)) {
        _asm int 3;
    }
#endif

    GR_DONE();
    REG_WR32(NV_PGRAPH_FIFO, access);

    return RM_OK;
}

//
// This method gives D3D access to the eye direction state.
// It would be nice to go thru RDI for this, but it turned
// out to be too problematic so we use PIPE_ADDRESS/PIPE_DATA
// instead.
//
RM_STATUS nvHalGrSetEyeDirection_NV20
(
    PHALHWINFO pHalHwInfo,
    PGREXCEPTIONDATA pGrExceptionData
)
{
    U032 offset = (pGrExceptionData->Offset - NV056_SET_EYE_DIRECTION_SW(0))/4;

    REG_WR32(NV_PGRAPH_PIPE_ADDRESS, NV_IGRAPH_XF2PIPE(NV_IGRAPH_XF_CMD_LTCTX,NV_IGRAPH_XF_LTCTX_EYED<<4) + (offset<<2));
    REG_WR32(NV_PGRAPH_PIPE_DATA, pGrExceptionData->Data);
    GR_DONE();

    return (RM_OK);
}

RM_STATUS nvHalGrSetViewportOffsetCelsius_NV20
(
    PHALHWINFO pHalHwInfo,
    PGREXCEPTIONDATA pGrExceptionData
)
{
    U032 offset = (pGrExceptionData->Offset - NV056_SET_VIEWPORT_OFFSET_SW(0))/4;
    REG_WR32(NV_PGRAPH_PIPE_ADDRESS, NV_IGRAPH_XF2PIPE(NV_IGRAPH_XF_CMD_XFCTX, NV_IGRAPH_XF_XFCTX_VPOFF<<4) + (offset<<2));
    REG_WR32(NV_PGRAPH_PIPE_DATA, pGrExceptionData->Data);
    GR_DONE();

    return (RM_OK);
}

RM_STATUS nvHalGrSetPassthruViewportOffsetCelsius_NV20
(
    PHALHWINFO pHalHwInfo,
    PGREXCEPTIONDATA pGrExceptionData
)
{
    U032 offset = (pGrExceptionData->Offset - NV056_SET_PASSTHRU_VIEWPORT_OFFSET_SW(0))/4;
    // Update second row of the second modelview matrix
    REG_WR32(NV_PGRAPH_PIPE_ADDRESS, NV_IGRAPH_XF2PIPE(NV_IGRAPH_XF_CMD_XFCTX, (NV_IGRAPH_XF_XFCTX_MMAT1+1)<<4) + (offset<<2));
    REG_WR32(NV_PGRAPH_PIPE_DATA, pGrExceptionData->Data);
    GR_DONE();

    return (RM_OK);
}

RM_STATUS nvHalGrSetViewportOffsetKelvin_NV20
(
    PHALHWINFO pHalHwInfo,
    PGREXCEPTIONDATA pGrExceptionData
)
{
    U032 offset = (pGrExceptionData->Offset - NV097_SET_VIEWPORT_OFFSET_SW(0))/4;
    REG_WR32(NV_PGRAPH_PIPE_ADDRESS, NV_IGRAPH_XF2PIPE(NV_IGRAPH_XF_CMD_XFCTX, NV_IGRAPH_XF_XFCTX_VPOFF<<4) + (offset<<2));
    REG_WR32(NV_PGRAPH_PIPE_DATA, pGrExceptionData->Data);
    GR_DONE();

    return (RM_OK);
}

RM_STATUS nvHalGrSetPassthruViewportOffsetKelvin_NV20
(
    PHALHWINFO pHalHwInfo,
    PGREXCEPTIONDATA pGrExceptionData
)
{
    U032 offset = (pGrExceptionData->Offset - NV097_SET_PASSTHRU_VIEWPORT_OFFSET_SW(0))/4;
    // Update second row of the second modelview matrix
    REG_WR32(NV_PGRAPH_PIPE_ADDRESS, NV_IGRAPH_XF2PIPE(NV_IGRAPH_XF_CMD_XFCTX, (NV_IGRAPH_XF_XFCTX_MMAT1+1)<<4) + (offset<<2));
    REG_WR32(NV_PGRAPH_PIPE_DATA, pGrExceptionData->Data);
    GR_DONE();

    return (RM_OK);
}

RM_STATUS
nvHalGrLoadChannelContext_NV20
(
    PHALHWINFO pHalHwInfo,
    U032 ChID
)
{
    PGRHALINFO_NV20 pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;
    U032 misc;
    U032 ctxSwitch1 = 0;

    //
    // Service any outstanding graphics exceptions.
    //
    if (REG_RD32(NV_PGRAPH_INTR))
        HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);
        
    //
    // Save current graphics interface state.
    //
    GR_SAVE_STATE(misc);
    HAL_GR_IDLE(pHalHwInfo);

    //
    // Unload current context.
    //   
    if (pGrHalPvtInfo->currentChID != ChID) {
        (void) nvHalGrUnloadChannelContext_NV20(pHalHwInfo, pGrHalPvtInfo->currentChID);
    }

    //
    // If the incoming channel is our "invalid" channel, then
    // invalidate and we're done.
    //
    if ((pGrHalPvtInfo->currentChID = ChID) == NUM_FIFOS_NV20)
    {
        REG_WR32(NV_PGRAPH_CTX_CONTROL,
                 DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US) |
                 DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME, _NOT_EXPIRED) |
                 DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID, _INVALID) |
                 DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING, _IDLE) |
                 DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE, _ENABLED));
        REG_WR_DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHID_STATUS, _VALID);

        //
        // Restore graphics interface state.
        //
		misc |= DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);
        GR_RESTORE_STATE(misc); // FIFO reenabled in here

        return (RM_OK);
    }
    else if (ChID > NUM_FIFOS_NV20)
    {
        GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: Invalid Channel on Graphics Context Switch: 0x%x\n", ChID));
        DBG_BREAKPOINT();
        return (RM_ERROR);
    }

    //
    // If we have 3D state in this channel, then we need to
    // workaround a problem with FD state (see magnus' chsw3.c
    // diag in //hw/nv20/diag/tests/src for more info).
    //
    if (pGrHalPvtInfo->currentObjects3d[ChID] != 0)
    {
        U032 i;

        // Reset IDX/VTX/CAS state.
        REG_WR32(NV_PGRAPH_DEBUG_0,
                 DRF_DEF(_PGRAPH, _DEBUG_0, _IDX_STATE, _RESET) |
                 DRF_DEF(_PGRAPH, _DEBUG_0, _VTX_STATE, _RESET) |
                 DRF_DEF(_PGRAPH, _DEBUG_0, _CAS_STATE, _RESET));
        i = REG_RD32(NV_PGRAPH_DEBUG_0);
        REG_WR32(NV_PGRAPH_DEBUG_0, 0x0);
        i = REG_RD32(NV_PGRAPH_DEBUG_0);

        // Clear FD mode by writing 0 to all FD registers.
        REG_WR32(NV_PGRAPH_RDI_INDEX,
                 DRF_NUM(_PGRAPH, _RDI_INDEX, _SELECT, RDI_RAMSEL_FD_CTRL) |
                 DRF_NUM(_PGRAPH, _RDI_INDEX, _ADDRESS, 0));
        for (i = 0; i < 15; i++)
            REG_WR32(NV_PGRAPH_RDI_DATA, 0);
    }

    //
    // Invalidate tcache.
    //
    FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_1, _CACHE, _INVALIDATE);

    REG_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, ChID);

    //
    // WAR PART1:
    //
    // There's a ctx switch bug that leads to IDX_FMT compsel
    // bit corruption.  These compsel bits are handled differently
    // between kelvin and celsius.  At ctx switch time, the IDX_FMT
    // kelvin mode is enabled if the current CTX_SWITCH1_GRCLASS isn't
    // celsius.  The problem is that it still could be a celsius
    // channel, but a different object currently loaded (e.g. a blit
    // object).  A kelvin mode save of this state when celsius is the
    // _real_ class leads to a hang.
    //
    // The war involves the following when the incoming channel is
    // a celsius channel:
    //    - save the incoming CTX_SWITCH1 register value
    //    - spoof a celsius instance in the CTX_SWITCH1 context buffer location
    //    - tell the hw to restore the context
    //    - update the CTX_SWITCH1 register in hw with the stashed
    //      original value
    //
    if (pGrHalPvtInfo->hasCelsius & (1 << ChID))
    {
        ctxSwitch1 = INST_RD32(pGrHalPvtInfo->CtxTable[ChID], 4);
        INST_WR32(pGrHalPvtInfo->CtxTable[ChID], 4, DRF_NUM(_PGRAPH, _CTX_SWITCH1, _GRCLASS, NV15_CELSIUS_PRIMITIVE));
    }

    //
    // Load new context.
    //
    REG_WR_DRF_NUM(_PGRAPH, _CHANNEL_CTX_POINTER, _INST, pGrHalPvtInfo->CtxTable[ChID]);
    REG_WR_DRF_DEF(_PGRAPH, _CHANNEL_CTX_TRIGGER, _READ_IN, _ACTIVATE);

    HAL_GR_IDLE(pHalHwInfo);

    //
    // WAR PART2:
    //
    // Update hardware with saved value.
    //
    if (pGrHalPvtInfo->hasCelsius & (1 << ChID))
    {
        REG_WR32(NV_PGRAPH_CTX_SWITCH1, ctxSwitch1);
    }

    //
    // Update hardware with new chid.
    // 
    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, ChID);
    REG_WR32(NV_PGRAPH_CTX_CONTROL,
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME, _NOT_EXPIRED) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID, _VALID) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING, _IDLE) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE, _ENABLED));

    REG_WR32(NV_PGRAPH_FFINTFC_ST2, REG_RD32(NV_PGRAPH_FFINTFC_ST2) & 0xCFFFFFFF);

    return (RM_OK);
}

RM_STATUS
nvHalGrUnloadChannelContext_NV20
(
    PHALHWINFO pHalHwInfo,
    U032 ChID
)
{
    PGRHALINFO_NV20 pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;
    U032 ctxSwitch1 = 0;

    //
    // No need to unload an invalid channel
    //
    if (ChID == NUM_FIFOS_NV20)
        return (RM_OK);

    //
    // WAR PART1:
    //
    // There's a ctx switch bug that leads to IDX_FMT compsel
    // bit corruption.  These compsel bits are handled differently
    // between kelvin and celsius.  At ctx switch time, the IDX_FMT
    // kelvin mode is enabled if the current CTX_SWITCH1_GRCLASS isn't
    // celsius.  The problem is that it still could be a celsius
    // channel, but a different object currently loaded (e.g. a blit
    // object).  A kelvin mode save of this state when celsius is the
    // _real_ class leads to a hang.
    //
    // The war involves the following when the outgoing channel is
    // a celsius channel:
    //    - stash the current CTX_SWITCH1 register value
    //    - spoof a celsius instance in CTX_SWITCH1
    //    - tell the hw to save the context
    //    - update the saved CTX_SWITCH1 value in the context buffer
    //      with the stashed original value
    //
    if (pGrHalPvtInfo->hasCelsius & (1 << ChID))
    {
        ctxSwitch1 = REG_RD32(NV_PGRAPH_CTX_SWITCH1);
        REG_WR32(NV_PGRAPH_CTX_SWITCH1, DRF_NUM(_PGRAPH, _CTX_SWITCH1, _GRCLASS, NV15_CELSIUS_PRIMITIVE));
    }


    // Unload context.
    //
    REG_WR_DRF_NUM(_PGRAPH, _CHANNEL_CTX_POINTER, _INST, pGrHalPvtInfo->CtxTable[ChID]);
    REG_WR_DRF_DEF(_PGRAPH, _CHANNEL_CTX_TRIGGER, _WRITE_OUT, _ACTIVATE);

    HAL_GR_IDLE(pHalHwInfo);

    //
    // WAR PART2:
    //
    // Update context buffer with saved value.  The CTX_SWITCH1 value
    // is at offset 4 from the start of the context buffer (see nv20_gr.h).
    //
    if (pGrHalPvtInfo->hasCelsius & (1 << ChID))
    {
        INST_WR32(pGrHalPvtInfo->CtxTable[ChID], 4, ctxSwitch1);
    }

    //
    // Invalidate hw's channel ID.
    //
    REG_WR32(NV_PGRAPH_CTX_CONTROL,
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME, _EXPIRED) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID, _INVALID) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING, _IDLE) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE, _ENABLED));

    return (RM_OK);
}

#ifdef NV20_SW_CTX_SWITCH
RM_STATUS nvHalGrLoadChannelContext_NV20(PHALHWINFO pHalHwInfo, U032 ChID)
{
    PGRHALINFO_NV20 pGrHalPvtInfo = (PGRHALINFO_NV20) pHalHwInfo->pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV20 pSwCtxTable = (PGRAPHICSCHANNEL_NV20) pGrHalPvtInfo->SwCtxTable;

    int i, status;
    U032 debug_1;
    
    GR_PRINTF((DBG_LEVEL_INFO, "NVRM: nvHalGrLoadChannelContext_NV20\r\n"));

    //
    // Service any outstanding graphics exceptions.
    //
    if (REG_RD32(NV_PGRAPH_INTR))
        HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);

    HAL_GR_IDLE(pHalHwInfo);

    //
    // Unload current context.
    //   
    if (pGrHalPvtInfo->currentChID != ChID)
    {
        nvHalGrUnloadChannelContext_NV20(pHalHwInfo,
                                         pGrHalPvtInfo->currentChID,
                                         &pGrHalPvtInfo->SwCtxTable[pGrHalPvtInfo->currentChID]);
    }

    debug_1 = REG_RD32(NV_PGRAPH_DEBUG_1);
    REG_WR32(NV_PGRAPH_DEBUG_1, debug_1 | DRF_DEF(_PGRAPH,_DEBUG_1,_CACHE,_INVALIDATE));
    
    REG_WR32(NV_PGRAPH_CTX_USER, pSwCtxTable[ChID].grCtxCmn.ContextUser);
    
    //
    // Reload context state
    //
    REG_WR32(NV_PGRAPH_CTX_SWITCH1,       pSwCtxTable[ChID].grCtxCmn.ContextSwitch1);
    REG_WR32(NV_PGRAPH_CTX_SWITCH2,       pSwCtxTable[ChID].grCtxCmn.ContextSwitch2);
    REG_WR32(NV_PGRAPH_CTX_SWITCH3,       pSwCtxTable[ChID].grCtxCmn.ContextSwitch3);
    REG_WR32(NV_PGRAPH_CTX_SWITCH4,       pSwCtxTable[ChID].grCtxCmn.ContextSwitch4);
    REG_WR32(NV_PGRAPH_CTX_SWITCH5,       pSwCtxTable[ChID].grCtxCmn.ContextSwitch5);
    
    for (i = 0; i < 8; i++)
      REG_WR32(NV_PGRAPH_CTX_CACHE1(i),   pSwCtxTable[ChID].grCtxCmn.ContextCache1[i]);
    
    for (i = 0; i < 8; i++)
      REG_WR32(NV_PGRAPH_CTX_CACHE2(i),   pSwCtxTable[ChID].grCtxCmn.ContextCache2[i]);
    
    for (i = 0; i < 8; i++)
      REG_WR32(NV_PGRAPH_CTX_CACHE3(i),   pSwCtxTable[ChID].grCtxCmn.ContextCache3[i]);
    
    for (i = 0; i < 8; i++)
      REG_WR32(NV_PGRAPH_CTX_CACHE4(i),   pSwCtxTable[ChID].grCtxCmn.ContextCache4[i]);
    
    for (i = 0; i < 8; i++)
      REG_WR32(NV_PGRAPH_CTX_CACHE5(i),   pSwCtxTable[ChID].grCtxCmn.ContextCache5[i]);
    
    
    REG_WR32(NV_PGRAPH_MONO_COLOR0,       pSwCtxTable[ChID].grCtxCmn.MonoColor0);
    REG_WR32(NV_PGRAPH_BSWIZZLE2,         pSwCtxTable[ChID].grCtxCmn.BufferSwizzle2);        
    REG_WR32(NV_PGRAPH_BSWIZZLE5,         pSwCtxTable[ChID].grCtxCmn.BufferSwizzle5);        
    
    for (i = 0; i < 6; i++)
      REG_WR32(NV_PGRAPH_BOFFSET(i),      pSwCtxTable[ChID].grCtxCmn.BufferOffset[i]);
    
    for (i = 0; i < 6; i++)
      REG_WR32(NV_PGRAPH_BBASE(i),        pSwCtxTable[ChID].grCtxCmn.BufferBase[i]);
    
    for (i = 0; i < 5; i++)
      REG_WR32(NV_PGRAPH_BPITCH(i),       pSwCtxTable[ChID].grCtxCmn.BufferPitch[i]);
    
    for (i = 0; i < 6; i++)
      REG_WR32(NV_PGRAPH_BLIMIT(i),       pSwCtxTable[ChID].grCtxCmn.BufferLimit[i]);
    
    REG_WR32(NV_PGRAPH_CHROMA,            pSwCtxTable[ChID].grCtxCmn.Chroma);
    REG_WR32(NV_PGRAPH_SURFACE,           pSwCtxTable[ChID].grCtxCmn.Surface);        
    REG_WR32(NV_PGRAPH_STATE,             pSwCtxTable[ChID].grCtxCmn.State);        
    REG_WR32(NV_PGRAPH_NOTIFY,            pSwCtxTable[ChID].grCtxCmn.Notify);
    
    REG_WR32(NV_PGRAPH_BPIXEL,            pSwCtxTable[ChID].grCtxCmn.BufferPixel);
    
    REG_WR32(NV_PGRAPH_DMA_PITCH,         pSwCtxTable[ChID].grCtxCmn.DmaPitch);
    
    REG_WR32(NV_PGRAPH_DVD_COLORFMT,      pSwCtxTable[ChID].grCtxCmn.DvdColorFmt);    
    REG_WR32(NV_PGRAPH_SCALED_FORMAT,     pSwCtxTable[ChID].grCtxCmn.ScaledFormat);    
    
    REG_WR32(NV_PGRAPH_PATT_COLOR0,       pSwCtxTable[ChID].grCtxCmn.PatternColor0);    
    REG_WR32(NV_PGRAPH_PATT_COLOR1,       pSwCtxTable[ChID].grCtxCmn.PatternColor1);
    
    REG_WR32(NV_PGRAPH_PATTERN(0),        pSwCtxTable[ChID].grCtxCmn.Pattern[0]);
    REG_WR32(NV_PGRAPH_PATTERN(1),        pSwCtxTable[ChID].grCtxCmn.Pattern[1]);
    REG_WR32(NV_PGRAPH_PATTERN_SHAPE,     pSwCtxTable[ChID].grCtxCmn.PatternShape);
    
    for (i = 0; i < 64; i++)
      REG_WR32(NV_PGRAPH_PATT_COLORRAM(i), pSwCtxTable[ChID].grCtxCmn.PattColorRam[i]);
    
    REG_WR32(NV_PGRAPH_ROP3,              pSwCtxTable[ChID].grCtxCmn.Rop3);
    REG_WR32(NV_PGRAPH_BETA_AND,          pSwCtxTable[ChID].grCtxCmn.BetaAnd);
    REG_WR32(NV_PGRAPH_BETA_PREMULT,      pSwCtxTable[ChID].grCtxCmn.BetaPreMult);
    
    REG_WR32(NV_PGRAPH_STORED_FMT,        pSwCtxTable[ChID].grCtxCmn.StoredFmt);
    
    for (i = 0; i < 10; i++)
      REG_WR32(NV_PGRAPH_ABS_X_RAM(i),    pSwCtxTable[ChID].grCtxCmn.AbsXRam[i]);
    
    for (i = 0; i < 10; i++)
      REG_WR32(NV_PGRAPH_ABS_Y_RAM(i),    pSwCtxTable[ChID].grCtxCmn.AbsYRam[i]);
    
    REG_WR32(NV_PGRAPH_ABS_ICLIP_XMAX,    pSwCtxTable[ChID].grCtxCmn.AbsIClipXMax);
    REG_WR32(NV_PGRAPH_ABS_ICLIP_YMAX,    pSwCtxTable[ChID].grCtxCmn.AbsIClipYMax);
    
    REG_WR32(NV_PGRAPH_ABS_UCLIP_XMIN,    pSwCtxTable[ChID].grCtxCmn.AbsUClipXMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_XMAX,    pSwCtxTable[ChID].grCtxCmn.AbsUClipXMax);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_YMIN,    pSwCtxTable[ChID].grCtxCmn.AbsUClipYMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_YMAX,    pSwCtxTable[ChID].grCtxCmn.AbsUClipYMax);
    
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_XMIN,   pSwCtxTable[ChID].grCtxCmn.AbsUClipAXMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_XMAX,   pSwCtxTable[ChID].grCtxCmn.AbsUClipAXMax);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_YMIN,   pSwCtxTable[ChID].grCtxCmn.AbsUClipAYMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_YMAX,   pSwCtxTable[ChID].grCtxCmn.AbsUClipAYMax);
    
    REG_WR32(NV_PGRAPH_SOURCE_COLOR,      pSwCtxTable[ChID].grCtxCmn.SourceColor);
    REG_WR32(NV_PGRAPH_MISC24_0,          pSwCtxTable[ChID].grCtxCmn.Misc24_0);
    
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC0,    pSwCtxTable[ChID].grCtxCmn.XYLogicMisc0);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC1,    pSwCtxTable[ChID].grCtxCmn.XYLogicMisc1);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC2,    pSwCtxTable[ChID].grCtxCmn.XYLogicMisc2);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC3,    pSwCtxTable[ChID].grCtxCmn.XYLogicMisc3);
    
    REG_WR32(NV_PGRAPH_CLIPX_0,           pSwCtxTable[ChID].grCtxCmn.ClipX0);
    REG_WR32(NV_PGRAPH_CLIPX_1,           pSwCtxTable[ChID].grCtxCmn.ClipX1);
    REG_WR32(NV_PGRAPH_CLIPY_0,           pSwCtxTable[ChID].grCtxCmn.ClipY0);
    REG_WR32(NV_PGRAPH_CLIPY_1,           pSwCtxTable[ChID].grCtxCmn.ClipY1);
    
    REG_WR32(NV_PGRAPH_PASSTHRU_0,        pSwCtxTable[ChID].grCtxCmn.Passthru0);    
    REG_WR32(NV_PGRAPH_PASSTHRU_1,        pSwCtxTable[ChID].grCtxCmn.Passthru1);    
    REG_WR32(NV_PGRAPH_PASSTHRU_2,        pSwCtxTable[ChID].grCtxCmn.Passthru2);    
    
    REG_WR32(NV_PGRAPH_DIMX_TEXTURE,      pSwCtxTable[ChID].grCtxCmn.DimxTexture);    
    REG_WR32(NV_PGRAPH_WDIMX_TEXTURE,     pSwCtxTable[ChID].grCtxCmn.WdimxTexture);    
    
    REG_WR32(NV_PGRAPH_DMA_START_0,       pSwCtxTable[ChID].grCtxCmn.DmaStart0);
    REG_WR32(NV_PGRAPH_DMA_START_1,       pSwCtxTable[ChID].grCtxCmn.DmaStart1);
    REG_WR32(NV_PGRAPH_DMA_LENGTH,        pSwCtxTable[ChID].grCtxCmn.DmaLength);
    REG_WR32(NV_PGRAPH_DMA_MISC,          pSwCtxTable[ChID].grCtxCmn.DmaMisc);
    
    REG_WR32(NV_PGRAPH_MISC24_1,          pSwCtxTable[ChID].grCtxCmn.Misc24_1);
    REG_WR32(NV_PGRAPH_MISC24_2,          pSwCtxTable[ChID].grCtxCmn.Misc24_2);
    REG_WR32(NV_PGRAPH_X_MISC,            pSwCtxTable[ChID].grCtxCmn.XMisc);
    REG_WR32(NV_PGRAPH_Y_MISC,            pSwCtxTable[ChID].grCtxCmn.YMisc);
    REG_WR32(NV_PGRAPH_VALID1,            pSwCtxTable[ChID].grCtxCmn.Valid1);
    
    if (pGrHalPvtInfo->currentObjects3d[ChID] != 0) {
        // 3D stuff
        REG_WR32(NV_PGRAPH_DEBUG_0, 0x0007000); //reset IDX, VTX and CAS
        REG_RD32(NV_PGRAPH_DEBUG_0);
        REG_WR32(NV_PGRAPH_DEBUG_0, 0x0);
        
        REG_WR32(NV_PGRAPH_ANTIALIASING,      pSwCtxTable[ChID].grCtx3d.AntiAliasing);
        REG_WR32(NV_PGRAPH_BLEND,             pSwCtxTable[ChID].grCtx3d.Blend);
        REG_WR32(NV_PGRAPH_BLENDCOLOR,        pSwCtxTable[ChID].grCtx3d.BlendColor);
        REG_WR32(NV_PGRAPH_BORDERCOLOR0,      pSwCtxTable[ChID].grCtx3d.BorderColor0);
        REG_WR32(NV_PGRAPH_BORDERCOLOR1,      pSwCtxTable[ChID].grCtx3d.BorderColor1);
        REG_WR32(NV_PGRAPH_BORDERCOLOR2,      pSwCtxTable[ChID].grCtx3d.BorderColor2);
        REG_WR32(NV_PGRAPH_BORDERCOLOR3,      pSwCtxTable[ChID].grCtx3d.BorderColor3);
        
        REG_WR32(NV_PGRAPH_BUMPMAT00_1,       pSwCtxTable[ChID].grCtx3d.BumpMat00_1);
        REG_WR32(NV_PGRAPH_BUMPMAT00_2,       pSwCtxTable[ChID].grCtx3d.BumpMat00_2);
        REG_WR32(NV_PGRAPH_BUMPMAT00_3,       pSwCtxTable[ChID].grCtx3d.BumpMat00_3);
        REG_WR32(NV_PGRAPH_BUMPMAT01_1,       pSwCtxTable[ChID].grCtx3d.BumpMat01_1);
        REG_WR32(NV_PGRAPH_BUMPMAT01_2,       pSwCtxTable[ChID].grCtx3d.BumpMat01_2);
        REG_WR32(NV_PGRAPH_BUMPMAT01_3,       pSwCtxTable[ChID].grCtx3d.BumpMat01_3);
        REG_WR32(NV_PGRAPH_BUMPMAT10_1,       pSwCtxTable[ChID].grCtx3d.BumpMat10_1);
        REG_WR32(NV_PGRAPH_BUMPMAT10_2,       pSwCtxTable[ChID].grCtx3d.BumpMat10_2);
        REG_WR32(NV_PGRAPH_BUMPMAT10_3,       pSwCtxTable[ChID].grCtx3d.BumpMat10_3);
        REG_WR32(NV_PGRAPH_BUMPMAT11_1,       pSwCtxTable[ChID].grCtx3d.BumpMat11_1);
        REG_WR32(NV_PGRAPH_BUMPMAT11_2,       pSwCtxTable[ChID].grCtx3d.BumpMat11_2);
        REG_WR32(NV_PGRAPH_BUMPMAT11_3,       pSwCtxTable[ChID].grCtx3d.BumpMat11_3);
        
        REG_WR32(NV_PGRAPH_BUMPOFFSET1,       pSwCtxTable[ChID].grCtx3d.BumpOffset1);
        REG_WR32(NV_PGRAPH_BUMPOFFSET2,       pSwCtxTable[ChID].grCtx3d.BumpOffset2);
        REG_WR32(NV_PGRAPH_BUMPOFFSET3,       pSwCtxTable[ChID].grCtx3d.BumpOffset3);
        
        REG_WR32(NV_PGRAPH_BUMPSCALE1,        pSwCtxTable[ChID].grCtx3d.BumpScale1);
        REG_WR32(NV_PGRAPH_BUMPSCALE2,        pSwCtxTable[ChID].grCtx3d.BumpScale2);
        REG_WR32(NV_PGRAPH_BUMPSCALE3,        pSwCtxTable[ChID].grCtx3d.BumpScale3);
        
        REG_WR32(NV_PGRAPH_CLEARRECTX,        pSwCtxTable[ChID].grCtx3d.ClearRectX);
        REG_WR32(NV_PGRAPH_CLEARRECTY,        pSwCtxTable[ChID].grCtx3d.ClearRectY);
        
        REG_WR32(NV_PGRAPH_COLORCLEARVALUE,   pSwCtxTable[ChID].grCtx3d.ColorClearValue);
        
        REG_WR32(NV_PGRAPH_COLORKEYCOLOR0,    pSwCtxTable[ChID].grCtx3d.ColorKeyColor0);
        REG_WR32(NV_PGRAPH_COLORKEYCOLOR1,    pSwCtxTable[ChID].grCtx3d.ColorKeyColor1);
        REG_WR32(NV_PGRAPH_COLORKEYCOLOR2,    pSwCtxTable[ChID].grCtx3d.ColorKeyColor2);
        REG_WR32(NV_PGRAPH_COLORKEYCOLOR3,    pSwCtxTable[ChID].grCtx3d.ColorKeyColor3);
        
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_0,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_0);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_1,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_1);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_2,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_2);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_3,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_3);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_4,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_4);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_5,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_5);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_6,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_6);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_7,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_7);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_0,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_0);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_1,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_1);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_2,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_2);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_3,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_3);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_4,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_4);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_5,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_5);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_6,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_6);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_7,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_7);
        
        REG_WR32(NV_PGRAPH_COMBINEALPHAI0,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI0);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI1,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI1);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI2,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI2);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI3,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI3);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI4,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI4);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI5,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI5);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI6,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI6);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI7,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI7);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO0,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO0);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO1,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO1);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO2,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO2);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO3,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO3);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO4,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO4);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO5,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO5);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO6,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO6);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO7,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO7);
        
        REG_WR32(NV_PGRAPH_COMBINECOLORI0,    pSwCtxTable[ChID].grCtx3d.CombineColorI0);
        REG_WR32(NV_PGRAPH_COMBINECOLORI1,    pSwCtxTable[ChID].grCtx3d.CombineColorI1);
        REG_WR32(NV_PGRAPH_COMBINECOLORI2,    pSwCtxTable[ChID].grCtx3d.CombineColorI2);
        REG_WR32(NV_PGRAPH_COMBINECOLORI3,    pSwCtxTable[ChID].grCtx3d.CombineColorI3);
        REG_WR32(NV_PGRAPH_COMBINECOLORI4,    pSwCtxTable[ChID].grCtx3d.CombineColorI4);
        REG_WR32(NV_PGRAPH_COMBINECOLORI5,    pSwCtxTable[ChID].grCtx3d.CombineColorI5);
        REG_WR32(NV_PGRAPH_COMBINECOLORI6,    pSwCtxTable[ChID].grCtx3d.CombineColorI6);
        REG_WR32(NV_PGRAPH_COMBINECOLORI7,    pSwCtxTable[ChID].grCtx3d.CombineColorI7);
        REG_WR32(NV_PGRAPH_COMBINECOLORO0,    pSwCtxTable[ChID].grCtx3d.CombineColorO0);
        REG_WR32(NV_PGRAPH_COMBINECOLORO1,    pSwCtxTable[ChID].grCtx3d.CombineColorO1);
        REG_WR32(NV_PGRAPH_COMBINECOLORO2,    pSwCtxTable[ChID].grCtx3d.CombineColorO2);
        REG_WR32(NV_PGRAPH_COMBINECOLORO3,    pSwCtxTable[ChID].grCtx3d.CombineColorO3);
        REG_WR32(NV_PGRAPH_COMBINECOLORO4,    pSwCtxTable[ChID].grCtx3d.CombineColorO4);
        REG_WR32(NV_PGRAPH_COMBINECOLORO5,    pSwCtxTable[ChID].grCtx3d.CombineColorO5);
        REG_WR32(NV_PGRAPH_COMBINECOLORO6,    pSwCtxTable[ChID].grCtx3d.CombineColorO6);
        REG_WR32(NV_PGRAPH_COMBINECOLORO7,    pSwCtxTable[ChID].grCtx3d.CombineColorO7);
        
        REG_WR32(NV_PGRAPH_COMBINECTL,        pSwCtxTable[ChID].grCtx3d.CombineCtl);
        
        REG_WR32(NV_PGRAPH_COMBINESPECFOG0,   pSwCtxTable[ChID].grCtx3d.CombineSpecFog0);
        REG_WR32(NV_PGRAPH_COMBINESPECFOG1,   pSwCtxTable[ChID].grCtx3d.CombineSpecFog1);
        
        REG_WR32(NV_PGRAPH_CONTROL_0,         pSwCtxTable[ChID].grCtx3d.Control0);
        REG_WR32(NV_PGRAPH_CONTROL_1,         pSwCtxTable[ChID].grCtx3d.Control1);
        REG_WR32(NV_PGRAPH_CONTROL_2,         pSwCtxTable[ChID].grCtx3d.Control2);
        REG_WR32(NV_PGRAPH_CONTROL_3,         pSwCtxTable[ChID].grCtx3d.Control3);
        
        REG_WR32(NV_PGRAPH_FOGCOLOR,          pSwCtxTable[ChID].grCtx3d.FogColor);
        REG_WR32(NV_PGRAPH_FOGPARAM0,         pSwCtxTable[ChID].grCtx3d.FogParam0);
        REG_WR32(NV_PGRAPH_FOGPARAM1,         pSwCtxTable[ChID].grCtx3d.FogParam1);
        REG_WR32(NV_PGRAPH_POINTSIZE,         pSwCtxTable[ChID].grCtx3d.PointSize);
        REG_WR32(NV_PGRAPH_SETUPRASTER,       pSwCtxTable[ChID].grCtx3d.SetupRaster);
        
        REG_WR32(NV_PGRAPH_SHADERCLIPMODE,    pSwCtxTable[ChID].grCtx3d.ShaderClipMode);
        REG_WR32(NV_PGRAPH_SHADERCTL,         pSwCtxTable[ChID].grCtx3d.ShaderCtl);
        REG_WR32(NV_PGRAPH_SHADERPROG,        pSwCtxTable[ChID].grCtx3d.ShaderProg);
        
        REG_WR32(NV_PGRAPH_SEMAPHOREOFFSET,   pSwCtxTable[ChID].grCtx3d.SemaphoreOffset);
        REG_WR32(NV_PGRAPH_SHADOWCTL,         pSwCtxTable[ChID].grCtx3d.ShadowCtl);
        REG_WR32(NV_PGRAPH_SHADOWZSLOPETHRESHOLD, pSwCtxTable[ChID].grCtx3d.ShadowZSlopeThreshold);
        
        REG_WR32(NV_PGRAPH_SPECFOGFACTOR0,    pSwCtxTable[ChID].grCtx3d.SpecFogFactor0);
        REG_WR32(NV_PGRAPH_SPECFOGFACTOR1,    pSwCtxTable[ChID].grCtx3d.SpecFogFactor1);
        
        REG_WR32(NV_PGRAPH_SURFACECLIPX,      pSwCtxTable[ChID].grCtx3d.SurfaceClipX);
        REG_WR32(NV_PGRAPH_SURFACECLIPY,      pSwCtxTable[ChID].grCtx3d.SurfaceClipY);
        
        REG_WR32(NV_PGRAPH_TEXADDRESS0,       pSwCtxTable[ChID].grCtx3d.TexAddress0);
        REG_WR32(NV_PGRAPH_TEXADDRESS1,       pSwCtxTable[ChID].grCtx3d.TexAddress1);
        REG_WR32(NV_PGRAPH_TEXADDRESS2,       pSwCtxTable[ChID].grCtx3d.TexAddress2);
        REG_WR32(NV_PGRAPH_TEXADDRESS3,       pSwCtxTable[ChID].grCtx3d.TexAddress3);
        
        REG_WR32(NV_PGRAPH_TEXCTL0_0,         pSwCtxTable[ChID].grCtx3d.TexCtl0_0);
        REG_WR32(NV_PGRAPH_TEXCTL0_1,         pSwCtxTable[ChID].grCtx3d.TexCtl0_1);
        REG_WR32(NV_PGRAPH_TEXCTL0_2,         pSwCtxTable[ChID].grCtx3d.TexCtl0_2);
        REG_WR32(NV_PGRAPH_TEXCTL0_3,         pSwCtxTable[ChID].grCtx3d.TexCtl0_3);
        
        REG_WR32(NV_PGRAPH_TEXCTL1_0,         pSwCtxTable[ChID].grCtx3d.TexCtl1_0);
        REG_WR32(NV_PGRAPH_TEXCTL1_1,         pSwCtxTable[ChID].grCtx3d.TexCtl1_1);
        REG_WR32(NV_PGRAPH_TEXCTL1_2,         pSwCtxTable[ChID].grCtx3d.TexCtl1_2);
        REG_WR32(NV_PGRAPH_TEXCTL1_3,         pSwCtxTable[ChID].grCtx3d.TexCtl1_3);
        
        REG_WR32(NV_PGRAPH_TEXCTL2_0,         pSwCtxTable[ChID].grCtx3d.TexCtl2_0);
        REG_WR32(NV_PGRAPH_TEXCTL2_1,         pSwCtxTable[ChID].grCtx3d.TexCtl2_1);
        
        REG_WR32(NV_PGRAPH_TEXFILTER0,        pSwCtxTable[ChID].grCtx3d.TexFilter0);
        REG_WR32(NV_PGRAPH_TEXFILTER1,        pSwCtxTable[ChID].grCtx3d.TexFilter1);
        REG_WR32(NV_PGRAPH_TEXFILTER2,        pSwCtxTable[ChID].grCtx3d.TexFilter2);
        REG_WR32(NV_PGRAPH_TEXFILTER3,        pSwCtxTable[ChID].grCtx3d.TexFilter3);
        
        REG_WR32(NV_PGRAPH_TEXFMT0,           pSwCtxTable[ChID].grCtx3d.TexFormat0);
        REG_WR32(NV_PGRAPH_TEXFMT1,           pSwCtxTable[ChID].grCtx3d.TexFormat1);
        REG_WR32(NV_PGRAPH_TEXFMT2,           pSwCtxTable[ChID].grCtx3d.TexFormat2);
        REG_WR32(NV_PGRAPH_TEXFMT3,           pSwCtxTable[ChID].grCtx3d.TexFormat3);
        
        REG_WR32(NV_PGRAPH_TEXIMAGERECT0,     pSwCtxTable[ChID].grCtx3d.TexImageRect0);
        REG_WR32(NV_PGRAPH_TEXIMAGERECT1,     pSwCtxTable[ChID].grCtx3d.TexImageRect1);
        REG_WR32(NV_PGRAPH_TEXIMAGERECT2,     pSwCtxTable[ChID].grCtx3d.TexImageRect2);
        REG_WR32(NV_PGRAPH_TEXIMAGERECT3,     pSwCtxTable[ChID].grCtx3d.TexImageRect3);
        
        REG_WR32(NV_PGRAPH_TEXOFFSET0,        pSwCtxTable[ChID].grCtx3d.TexOffset0);
        REG_WR32(NV_PGRAPH_TEXOFFSET1,        pSwCtxTable[ChID].grCtx3d.TexOffset1);
        REG_WR32(NV_PGRAPH_TEXOFFSET2,        pSwCtxTable[ChID].grCtx3d.TexOffset2);
        REG_WR32(NV_PGRAPH_TEXOFFSET3,        pSwCtxTable[ChID].grCtx3d.TexOffset3);
        
        REG_WR32(NV_PGRAPH_TEXPALETTE0,       pSwCtxTable[ChID].grCtx3d.TexPallete0);
        REG_WR32(NV_PGRAPH_TEXPALETTE1,       pSwCtxTable[ChID].grCtx3d.TexPallete1);
        REG_WR32(NV_PGRAPH_TEXPALETTE2,       pSwCtxTable[ChID].grCtx3d.TexPallete2);
        REG_WR32(NV_PGRAPH_TEXPALETTE3,       pSwCtxTable[ChID].grCtx3d.TexPallete3);
        
        REG_WR32(NV_PGRAPH_WINDOWCLIPX0,      pSwCtxTable[ChID].grCtx3d.WindowClipX[0]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX1,      pSwCtxTable[ChID].grCtx3d.WindowClipX[1]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX2,      pSwCtxTable[ChID].grCtx3d.WindowClipX[2]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX3,      pSwCtxTable[ChID].grCtx3d.WindowClipX[3]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX4,      pSwCtxTable[ChID].grCtx3d.WindowClipX[4]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX5,      pSwCtxTable[ChID].grCtx3d.WindowClipX[5]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX6,      pSwCtxTable[ChID].grCtx3d.WindowClipX[6]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX7,      pSwCtxTable[ChID].grCtx3d.WindowClipX[7]);
        
        REG_WR32(NV_PGRAPH_WINDOWCLIPY0,      pSwCtxTable[ChID].grCtx3d.WindowClipY[0]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY1,      pSwCtxTable[ChID].grCtx3d.WindowClipY[1]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY2,      pSwCtxTable[ChID].grCtx3d.WindowClipY[2]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY3,      pSwCtxTable[ChID].grCtx3d.WindowClipY[3]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY4,      pSwCtxTable[ChID].grCtx3d.WindowClipY[4]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY5,      pSwCtxTable[ChID].grCtx3d.WindowClipY[5]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY6,      pSwCtxTable[ChID].grCtx3d.WindowClipY[6]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY7,      pSwCtxTable[ChID].grCtx3d.WindowClipY[7]);
        
        REG_WR32(NV_PGRAPH_ZCOMPRESSOCCLUDE,  pSwCtxTable[ChID].grCtx3d.ZCompressOcclude);
        REG_WR32(NV_PGRAPH_ZSTENCILCLEARVALUE,pSwCtxTable[ChID].grCtx3d.ZStencilClearValue);
        
        REG_WR32(NV_PGRAPH_ZCLIPMAX,          pSwCtxTable[ChID].grCtx3d.ZClipMax);
        REG_WR32(NV_PGRAPH_ZCLIPMIN,          pSwCtxTable[ChID].grCtx3d.ZClipMin);
        
        REG_WR32(NV_PGRAPH_CONTEXTDMAA,       pSwCtxTable[ChID].grCtx3d.ContextDmaA);
        REG_WR32(NV_PGRAPH_CONTEXTDMAB,       pSwCtxTable[ChID].grCtx3d.ContextDmaB);
        REG_WR32(NV_PGRAPH_CONTEXTVTXA,       pSwCtxTable[ChID].grCtx3d.ContextDmaVtxA);
        REG_WR32(NV_PGRAPH_CONTEXTVTXB,       pSwCtxTable[ChID].grCtx3d.ContextDmaVtxB);
        
        REG_WR32(NV_PGRAPH_ZOFFSETBIAS,       pSwCtxTable[ChID].grCtx3d.ZOffsetBias);
        REG_WR32(NV_PGRAPH_ZOFFSETFACTOR,     pSwCtxTable[ChID].grCtx3d.ZOffsetFactor);
        
        REG_WR32(NV_PGRAPH_EYEVEC0,           pSwCtxTable[ChID].grCtx3d.Eyevec0);
        REG_WR32(NV_PGRAPH_EYEVEC1,           pSwCtxTable[ChID].grCtx3d.Eyevec1);
        REG_WR32(NV_PGRAPH_EYEVEC2,           pSwCtxTable[ChID].grCtx3d.Eyevec2);
        
        REG_WR32(NV_PGRAPH_SHADOW,            pSwCtxTable[ChID].grCtx3d.Shadow);
        REG_WR32(NV_PGRAPH_FD_DATA,           pSwCtxTable[ChID].grCtx3d.FdData);
        REG_WR32(NV_PGRAPH_FD_SWATCH,         pSwCtxTable[ChID].grCtx3d.FdSwatch);
        REG_WR32(NV_PGRAPH_FD_EXTRAS,         pSwCtxTable[ChID].grCtx3d.FdExtras);
        REG_WR32(NV_PGRAPH_EMISSION_BACKUP_0, pSwCtxTable[ChID].grCtx3d.Emission0);
        REG_WR32(NV_PGRAPH_EMISSION_BACKUP_1, pSwCtxTable[ChID].grCtx3d.Emission1);
        REG_WR32(NV_PGRAPH_EMISSION_BACKUP_2, pSwCtxTable[ChID].grCtx3d.Emission2);
        REG_WR32(NV_PGRAPH_SCENE_AMBIENT_BACKUP_0, pSwCtxTable[ChID].grCtx3d.SceneAmb0);
        REG_WR32(NV_PGRAPH_SCENE_AMBIENT_BACKUP_1, pSwCtxTable[ChID].grCtx3d.SceneAmb1);
        REG_WR32(NV_PGRAPH_SCENE_AMBIENT_BACKUP_2, pSwCtxTable[ChID].grCtx3d.SceneAmb2);
        REG_WR32(NV_PGRAPH_GETSTATE,          pSwCtxTable[ChID].grCtx3d.ContextDmaGetState);
        REG_WR32(NV_PGRAPH_BEGINPATCH0,       pSwCtxTable[ChID].grCtx3d.BeginPatch0);
        REG_WR32(NV_PGRAPH_BEGINPATCH1,       pSwCtxTable[ChID].grCtx3d.BeginPatch1);
        REG_WR32(NV_PGRAPH_BEGINPATCH2,       pSwCtxTable[ChID].grCtx3d.BeginPatch2);
        REG_WR32(NV_PGRAPH_BEGINPATCH3,       pSwCtxTable[ChID].grCtx3d.BeginPatch3);
        REG_WR32(NV_PGRAPH_CURVE,             pSwCtxTable[ChID].grCtx3d.BeginCurve);
        REG_WR32(NV_PGRAPH_BEGINTRANS0,       pSwCtxTable[ChID].grCtx3d.BeginTrans0);
        REG_WR32(NV_PGRAPH_BEGINTRANS1,       pSwCtxTable[ChID].grCtx3d.BeginTrans1);
        REG_WR32(NV_PGRAPH_CSV0_D,            pSwCtxTable[ChID].grCtx3d.Csv0_D);
        REG_WR32(NV_PGRAPH_CSV0_C,            pSwCtxTable[ChID].grCtx3d.Csv0_C);
        REG_WR32(NV_PGRAPH_CSV1_B,            pSwCtxTable[ChID].grCtx3d.Csv1_B);
        REG_WR32(NV_PGRAPH_CSV1_A,            pSwCtxTable[ChID].grCtx3d.Csv1_A);
        REG_WR32(NV_PGRAPH_CHEOPS_OFFSET,     pSwCtxTable[ChID].grCtx3d.CheopsOffset);
        
        do {
          status = REG_RD32(NV_PGRAPH_STATUS);
        } while (status);
        
        // wait for the pipe to go idle 
        HAL_GR_IDLE(pHalHwInfo);

        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, RDI_ADDR_ZERO, IDX_FMT_COUNT, pSwCtxTable[ChID].grCtxPipe.IdxFmt);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, RDI_ADDR_ZERO, CAS0_COUNT, pSwCtxTable[ChID].grCtxPipe.Cas0);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, RDI_ADDR_ZERO, CAS1_COUNT, pSwCtxTable[ChID].grCtxPipe.Cas1);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, RDI_ADDR_ZERO, CAS2_COUNT, pSwCtxTable[ChID].grCtxPipe.Cas2);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_ASSM_STATE, RDI_ADDR_ZERO, ASSM_STATE_COUNT, pSwCtxTable[ChID].grCtxPipe.AssmState);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE0, RDI_ADDR_ZERO, IDX_CACHE0_COUNT, pSwCtxTable[ChID].grCtxPipe.IdxCache0);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE1, RDI_ADDR_ZERO, IDX_CACHE1_COUNT, pSwCtxTable[ChID].grCtxPipe.IdxCache1);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE2, RDI_ADDR_ZERO, IDX_CACHE2_COUNT, pSwCtxTable[ChID].grCtxPipe.IdxCache2);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE3, RDI_ADDR_ZERO, IDX_CACHE3_COUNT, pSwCtxTable[ChID].grCtxPipe.IdxCache3);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_VTX_FILE0, RDI_ADDR_ZERO, VTX_FILE0_COUNT, pSwCtxTable[ChID].grCtxPipe.VtxFile0);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_VTX_FILE1, RDI_ADDR_ZERO, VTX_FILE1_COUNT, pSwCtxTable[ChID].grCtxPipe.VtxFile1);
        
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_P, RDI_ADDR_ZERO, XL_P_COUNT, pSwCtxTable[ChID].grCtxPipe.XlP);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_XFCTX, RDI_ADDR_ZERO, XL_XFCTX_COUNT, pSwCtxTable[ChID].grCtxPipe.XlXfCtx);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_LTCTX, RDI_ADDR_ZERO, XL_LTCTX_COUNT, pSwCtxTable[ChID].grCtxPipe.XlLtCtx);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_LTC, RDI_ADDR_ZERO, XL_LTC_COUNT, pSwCtxTable[ChID].grCtxPipe.XlLtc);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, RDI_ADDR_ZERO, XL_VAB_COUNT, pSwCtxTable[ChID].grCtxPipe.XlVab);
        
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CRSTR_STIPP, RDI_ADDR_ZERO, CRSTR_STIPP_COUNT, pSwCtxTable[ChID].grCtxPipe.CrstrStipp);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_FD_CTRL, RDI_ADDR_ZERO, FD_CTRL_COUNT, pSwCtxTable[ChID].grCtxPipe.FdCtrl);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_ROP_REGS, RDI_ADDR_ZERO, ROP_REGS_COUNT, pSwCtxTable[ChID].grCtxPipe.RopRegs);
    }
    
    
    REG_WR32(NV_PGRAPH_CTX_CONTROL,
        DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME,   _33US)
        | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _NOT_EXPIRED)
        | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _VALID)
        | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
        | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
                      
    
    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, ChID);

    REG_WR32(NV_PGRAPH_FFINTFC_ST2, REG_RD32(NV_PGRAPH_FFINTFC_ST2) & 0xCFFFFFFF);
    
    REG_WR_DRF_DEF(_PGRAPH,_FIFO,_ACCESS,_ENABLED);

    return (RM_OK);
}

RM_STATUS nvHalGrUnloadChannelContext_NV20(PHALHWINFO pHalHwInfo, U032 ChID, PGRAPHICSCHANNEL_NV20 pSwCtxTable)
{
    PGRHALINFO_NV20 pGrHalPvtInfo = (PGRHALINFO_NV20) pHalHwInfo->pGrHalPvtInfo;

    U032 ctxControl;
    int i;
    
    GR_PRINTF((DBG_LEVEL_INFO, "NVRM: nvHalGrUnloadChannelContext_NV20\r\n"));

    HAL_GR_IDLE(pHalHwInfo);

    ctxControl = REG_RD32(NV_PGRAPH_CTX_CONTROL);
    
    if (DRF_VAL(_PGRAPH,_CTX_CONTROL,_CHID, ctxControl) == NV_PGRAPH_CTX_CONTROL_CHID_INVALID)
    {
        GR_PRINTF((DBG_LEVEL_INFO, "NVRM: grUnloadCurrentChannelContext() current chid is invalid\n"));
        return (RM_OK);
    }
    
    pSwCtxTable->grCtxCmn.ContextUser       = REG_RD32(NV_PGRAPH_CTX_USER);
    
    //
    // Unload current context registers.
    //
    pSwCtxTable->grCtxCmn.ContextSwitch1    = REG_RD32(NV_PGRAPH_CTX_SWITCH1);
    pSwCtxTable->grCtxCmn.ContextSwitch2    = REG_RD32(NV_PGRAPH_CTX_SWITCH2);
    pSwCtxTable->grCtxCmn.ContextSwitch3    = REG_RD32(NV_PGRAPH_CTX_SWITCH3);        
    pSwCtxTable->grCtxCmn.ContextSwitch4    = REG_RD32(NV_PGRAPH_CTX_SWITCH4);
    pSwCtxTable->grCtxCmn.ContextSwitch5    = REG_RD32(NV_PGRAPH_CTX_SWITCH5);
    
    for (i = 0; i < 8; i++)
        pSwCtxTable->grCtxCmn.ContextCache1[i] = REG_RD32(NV_PGRAPH_CTX_CACHE1(i));
    
    for (i = 0; i < 8; i++)
        pSwCtxTable->grCtxCmn.ContextCache2[i] = REG_RD32(NV_PGRAPH_CTX_CACHE2(i));
    
    for (i = 0; i < 8; i++)
        pSwCtxTable->grCtxCmn.ContextCache3[i] = REG_RD32(NV_PGRAPH_CTX_CACHE3(i));
    
    for (i = 0; i < 8; i++)
        pSwCtxTable->grCtxCmn.ContextCache4[i] = REG_RD32(NV_PGRAPH_CTX_CACHE4(i));
    
    for (i = 0; i < 8; i++)
        pSwCtxTable->grCtxCmn.ContextCache5[i] = REG_RD32(NV_PGRAPH_CTX_CACHE5(i));
    
    pSwCtxTable->grCtxCmn.MonoColor0          = REG_RD32(NV_PGRAPH_MONO_COLOR0);
    pSwCtxTable->grCtxCmn.BufferSwizzle2      = REG_RD32(NV_PGRAPH_BSWIZZLE2);        
    pSwCtxTable->grCtxCmn.BufferSwizzle5      = REG_RD32(NV_PGRAPH_BSWIZZLE5);        
    
    for (i = 0; i < 6; i++)
        pSwCtxTable->grCtxCmn.BufferOffset[i] = REG_RD32(NV_PGRAPH_BOFFSET(i));
    
    for (i = 0; i < 6; i++)
        pSwCtxTable->grCtxCmn.BufferBase[i]   = REG_RD32(NV_PGRAPH_BBASE(i));
    
    for (i = 0; i < 5; i++)
        pSwCtxTable->grCtxCmn.BufferPitch[i]  = REG_RD32(NV_PGRAPH_BPITCH(i));
    
    for (i = 0; i < 6; i++)
        pSwCtxTable->grCtxCmn.BufferLimit[i]  = REG_RD32(NV_PGRAPH_BLIMIT(i));
    
    pSwCtxTable->grCtxCmn.Chroma              = REG_RD32(NV_PGRAPH_CHROMA);
    
    pSwCtxTable->grCtxCmn.Surface             = REG_RD32(NV_PGRAPH_SURFACE);        
    pSwCtxTable->grCtxCmn.State               = REG_RD32(NV_PGRAPH_STATE);        
    pSwCtxTable->grCtxCmn.Notify              = REG_RD32(NV_PGRAPH_NOTIFY);
    pSwCtxTable->grCtxCmn.BufferPixel         = REG_RD32(NV_PGRAPH_BPIXEL);
    
    pSwCtxTable->grCtxCmn.DmaPitch            = REG_RD32(NV_PGRAPH_DMA_PITCH);
    pSwCtxTable->grCtxCmn.DvdColorFmt         = REG_RD32(NV_PGRAPH_DVD_COLORFMT);    
    pSwCtxTable->grCtxCmn.ScaledFormat        = REG_RD32(NV_PGRAPH_SCALED_FORMAT);    
    
    pSwCtxTable->grCtxCmn.PatternColor0       = REG_RD32(NV_PGRAPH_PATT_COLOR0);    
    pSwCtxTable->grCtxCmn.PatternColor1       = REG_RD32(NV_PGRAPH_PATT_COLOR1);
    pSwCtxTable->grCtxCmn.Pattern[0]          = REG_RD32(NV_PGRAPH_PATTERN(0));
    pSwCtxTable->grCtxCmn.Pattern[1]          = REG_RD32(NV_PGRAPH_PATTERN(1));
    pSwCtxTable->grCtxCmn.PatternShape        = REG_RD32(NV_PGRAPH_PATTERN_SHAPE);
    
    for (i = 0; i < 64; i++)
        pSwCtxTable->grCtxCmn.PattColorRam[i] = REG_RD32(NV_PGRAPH_PATT_COLORRAM(i));
    
    
    pSwCtxTable->grCtxCmn.Rop3                = REG_RD32(NV_PGRAPH_ROP3);
    pSwCtxTable->grCtxCmn.BetaAnd             = REG_RD32(NV_PGRAPH_BETA_AND);
    pSwCtxTable->grCtxCmn.BetaPreMult         = REG_RD32(NV_PGRAPH_BETA_PREMULT);
    pSwCtxTable->grCtxCmn.StoredFmt           = REG_RD32(NV_PGRAPH_STORED_FMT);
      
    for (i = 0; i < 10; i++)
      pSwCtxTable->grCtxCmn.AbsXRam[i]        = REG_RD32(NV_PGRAPH_ABS_X_RAM(i));
    
    for (i = 0; i < 10; i++)
      pSwCtxTable->grCtxCmn.AbsYRam[i]        = REG_RD32(NV_PGRAPH_ABS_Y_RAM(i));
    
    pSwCtxTable->grCtxCmn.AbsIClipXMax        = REG_RD32(NV_PGRAPH_ABS_ICLIP_XMAX);
    pSwCtxTable->grCtxCmn.AbsIClipYMax        = REG_RD32(NV_PGRAPH_ABS_ICLIP_YMAX);
    
    pSwCtxTable->grCtxCmn.AbsUClipXMin        = REG_RD32(NV_PGRAPH_ABS_UCLIP_XMIN);
    pSwCtxTable->grCtxCmn.AbsUClipXMax        = REG_RD32(NV_PGRAPH_ABS_UCLIP_XMAX);
    pSwCtxTable->grCtxCmn.AbsUClipYMin        = REG_RD32(NV_PGRAPH_ABS_UCLIP_YMIN);
    pSwCtxTable->grCtxCmn.AbsUClipYMax        = REG_RD32(NV_PGRAPH_ABS_UCLIP_YMAX);
    
    pSwCtxTable->grCtxCmn.AbsUClipAXMin       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_XMIN);
    pSwCtxTable->grCtxCmn.AbsUClipAXMax       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_XMAX);
    pSwCtxTable->grCtxCmn.AbsUClipAYMin       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_YMIN);
    pSwCtxTable->grCtxCmn.AbsUClipAYMax       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_YMAX);
    
    pSwCtxTable->grCtxCmn.SourceColor         = REG_RD32(NV_PGRAPH_SOURCE_COLOR);
    
    pSwCtxTable->grCtxCmn.Misc24_0            = REG_RD32(NV_PGRAPH_MISC24_0);
    
    pSwCtxTable->grCtxCmn.XYLogicMisc0        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC0);
    pSwCtxTable->grCtxCmn.XYLogicMisc1        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC1);
    pSwCtxTable->grCtxCmn.XYLogicMisc2        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC2);
    pSwCtxTable->grCtxCmn.XYLogicMisc3        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC3);
    
    pSwCtxTable->grCtxCmn.ClipX0              = REG_RD32(NV_PGRAPH_CLIPX_0);
    pSwCtxTable->grCtxCmn.ClipX1              = REG_RD32(NV_PGRAPH_CLIPX_1);
    pSwCtxTable->grCtxCmn.ClipY0              = REG_RD32(NV_PGRAPH_CLIPY_0);
    pSwCtxTable->grCtxCmn.ClipY1              = REG_RD32(NV_PGRAPH_CLIPY_1);
    
    pSwCtxTable->grCtxCmn.Passthru0           = REG_RD32(NV_PGRAPH_PASSTHRU_0);    
    pSwCtxTable->grCtxCmn.Passthru1           = REG_RD32(NV_PGRAPH_PASSTHRU_1);    
    pSwCtxTable->grCtxCmn.Passthru2           = REG_RD32(NV_PGRAPH_PASSTHRU_2);    
    
    pSwCtxTable->grCtxCmn.DimxTexture         = REG_RD32(NV_PGRAPH_DIMX_TEXTURE);    
    pSwCtxTable->grCtxCmn.WdimxTexture        = REG_RD32(NV_PGRAPH_WDIMX_TEXTURE);    
    
    pSwCtxTable->grCtxCmn.DmaStart0           = REG_RD32(NV_PGRAPH_DMA_START_0);
    pSwCtxTable->grCtxCmn.DmaStart1           = REG_RD32(NV_PGRAPH_DMA_START_1);
    pSwCtxTable->grCtxCmn.DmaLength           = REG_RD32(NV_PGRAPH_DMA_LENGTH);
    pSwCtxTable->grCtxCmn.DmaMisc             = REG_RD32(NV_PGRAPH_DMA_MISC);
    
    pSwCtxTable->grCtxCmn.Misc24_1            = REG_RD32(NV_PGRAPH_MISC24_1);
    pSwCtxTable->grCtxCmn.Misc24_2            = REG_RD32(NV_PGRAPH_MISC24_2);
    pSwCtxTable->grCtxCmn.XMisc               = REG_RD32(NV_PGRAPH_X_MISC);
    pSwCtxTable->grCtxCmn.YMisc               = REG_RD32(NV_PGRAPH_Y_MISC);
    pSwCtxTable->grCtxCmn.Valid1              = REG_RD32(NV_PGRAPH_VALID1);
      
    if (pGrHalPvtInfo->currentObjects3d[ChID] != 0) {
        // 3D stuff
        pSwCtxTable->grCtx3d.AntiAliasing        = REG_RD32(NV_PGRAPH_ANTIALIASING);
        pSwCtxTable->grCtx3d.Blend               = REG_RD32(NV_PGRAPH_BLEND);
        pSwCtxTable->grCtx3d.BlendColor          = REG_RD32(NV_PGRAPH_BLENDCOLOR);
        pSwCtxTable->grCtx3d.BorderColor0        = REG_RD32(NV_PGRAPH_BORDERCOLOR0);
        pSwCtxTable->grCtx3d.BorderColor1        = REG_RD32(NV_PGRAPH_BORDERCOLOR1);
        pSwCtxTable->grCtx3d.BorderColor2        = REG_RD32(NV_PGRAPH_BORDERCOLOR2);
        pSwCtxTable->grCtx3d.BorderColor3        = REG_RD32(NV_PGRAPH_BORDERCOLOR3);
        
        pSwCtxTable->grCtx3d.BumpMat00_1         = REG_RD32(NV_PGRAPH_BUMPMAT00_1);
        pSwCtxTable->grCtx3d.BumpMat00_2         = REG_RD32(NV_PGRAPH_BUMPMAT00_2);
        pSwCtxTable->grCtx3d.BumpMat00_3         = REG_RD32(NV_PGRAPH_BUMPMAT00_3);
        pSwCtxTable->grCtx3d.BumpMat01_1         = REG_RD32(NV_PGRAPH_BUMPMAT01_1);
        pSwCtxTable->grCtx3d.BumpMat01_2         = REG_RD32(NV_PGRAPH_BUMPMAT01_2);
        pSwCtxTable->grCtx3d.BumpMat01_3         = REG_RD32(NV_PGRAPH_BUMPMAT01_3);
        pSwCtxTable->grCtx3d.BumpMat10_1         = REG_RD32(NV_PGRAPH_BUMPMAT10_1);
        pSwCtxTable->grCtx3d.BumpMat10_2         = REG_RD32(NV_PGRAPH_BUMPMAT10_2);
        pSwCtxTable->grCtx3d.BumpMat10_3         = REG_RD32(NV_PGRAPH_BUMPMAT10_3);
        pSwCtxTable->grCtx3d.BumpMat11_1         = REG_RD32(NV_PGRAPH_BUMPMAT11_1);
        pSwCtxTable->grCtx3d.BumpMat11_2         = REG_RD32(NV_PGRAPH_BUMPMAT11_2);
        pSwCtxTable->grCtx3d.BumpMat11_3         = REG_RD32(NV_PGRAPH_BUMPMAT11_3);
        
        pSwCtxTable->grCtx3d.BumpOffset1         = REG_RD32(NV_PGRAPH_BUMPOFFSET1);
        pSwCtxTable->grCtx3d.BumpOffset2         = REG_RD32(NV_PGRAPH_BUMPOFFSET2);
        pSwCtxTable->grCtx3d.BumpOffset3         = REG_RD32(NV_PGRAPH_BUMPOFFSET3);
        
        pSwCtxTable->grCtx3d.BumpScale1          = REG_RD32(NV_PGRAPH_BUMPSCALE1);
        pSwCtxTable->grCtx3d.BumpScale2          = REG_RD32(NV_PGRAPH_BUMPSCALE2);
        pSwCtxTable->grCtx3d.BumpScale3          = REG_RD32(NV_PGRAPH_BUMPSCALE3);
        
        pSwCtxTable->grCtx3d.ClearRectX          = REG_RD32(NV_PGRAPH_CLEARRECTX);
        pSwCtxTable->grCtx3d.ClearRectY          = REG_RD32(NV_PGRAPH_CLEARRECTY);
        
        pSwCtxTable->grCtx3d.ColorClearValue     = REG_RD32(NV_PGRAPH_COLORCLEARVALUE);
        
        pSwCtxTable->grCtx3d.ColorKeyColor0      = REG_RD32(NV_PGRAPH_COLORKEYCOLOR0);
        pSwCtxTable->grCtx3d.ColorKeyColor1      = REG_RD32(NV_PGRAPH_COLORKEYCOLOR1);
        pSwCtxTable->grCtx3d.ColorKeyColor2      = REG_RD32(NV_PGRAPH_COLORKEYCOLOR2);
        pSwCtxTable->grCtx3d.ColorKeyColor3      = REG_RD32(NV_PGRAPH_COLORKEYCOLOR3);
        
        pSwCtxTable->grCtx3d.CombineFactor0_0    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_0);
        pSwCtxTable->grCtx3d.CombineFactor0_1    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_1);
        pSwCtxTable->grCtx3d.CombineFactor0_2    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_2);
        pSwCtxTable->grCtx3d.CombineFactor0_3    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_3);
        pSwCtxTable->grCtx3d.CombineFactor0_4    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_4);
        pSwCtxTable->grCtx3d.CombineFactor0_5    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_5);
        pSwCtxTable->grCtx3d.CombineFactor0_6    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_6);
        pSwCtxTable->grCtx3d.CombineFactor0_7    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_7);
        pSwCtxTable->grCtx3d.CombineFactor1_0    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_0);
        pSwCtxTable->grCtx3d.CombineFactor1_1    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_1);
        pSwCtxTable->grCtx3d.CombineFactor1_2    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_2);
        pSwCtxTable->grCtx3d.CombineFactor1_3    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_3);
        pSwCtxTable->grCtx3d.CombineFactor1_4    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_4);
        pSwCtxTable->grCtx3d.CombineFactor1_5    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_5);
        pSwCtxTable->grCtx3d.CombineFactor1_6    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_6);
        pSwCtxTable->grCtx3d.CombineFactor1_7    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_7);
        
        pSwCtxTable->grCtx3d.CombineAlphaI0      = REG_RD32(NV_PGRAPH_COMBINEALPHAI0);
        pSwCtxTable->grCtx3d.CombineAlphaI1      = REG_RD32(NV_PGRAPH_COMBINEALPHAI1);
        pSwCtxTable->grCtx3d.CombineAlphaI2      = REG_RD32(NV_PGRAPH_COMBINEALPHAI2);
        pSwCtxTable->grCtx3d.CombineAlphaI3      = REG_RD32(NV_PGRAPH_COMBINEALPHAI3);
        pSwCtxTable->grCtx3d.CombineAlphaI4      = REG_RD32(NV_PGRAPH_COMBINEALPHAI4);
        pSwCtxTable->grCtx3d.CombineAlphaI5      = REG_RD32(NV_PGRAPH_COMBINEALPHAI5);
        pSwCtxTable->grCtx3d.CombineAlphaI6      = REG_RD32(NV_PGRAPH_COMBINEALPHAI6);
        pSwCtxTable->grCtx3d.CombineAlphaI7      = REG_RD32(NV_PGRAPH_COMBINEALPHAI7);
        pSwCtxTable->grCtx3d.CombineAlphaO0      = REG_RD32(NV_PGRAPH_COMBINEALPHAO0);
        pSwCtxTable->grCtx3d.CombineAlphaO1      = REG_RD32(NV_PGRAPH_COMBINEALPHAO1);
        pSwCtxTable->grCtx3d.CombineAlphaO2      = REG_RD32(NV_PGRAPH_COMBINEALPHAO2);
        pSwCtxTable->grCtx3d.CombineAlphaO3      = REG_RD32(NV_PGRAPH_COMBINEALPHAO3);
        pSwCtxTable->grCtx3d.CombineAlphaO4      = REG_RD32(NV_PGRAPH_COMBINEALPHAO4);
        pSwCtxTable->grCtx3d.CombineAlphaO5      = REG_RD32(NV_PGRAPH_COMBINEALPHAO5);
        pSwCtxTable->grCtx3d.CombineAlphaO6      = REG_RD32(NV_PGRAPH_COMBINEALPHAO6);
        pSwCtxTable->grCtx3d.CombineAlphaO7      = REG_RD32(NV_PGRAPH_COMBINEALPHAO7);
        
        pSwCtxTable->grCtx3d.CombineColorI0      = REG_RD32(NV_PGRAPH_COMBINECOLORI0);
        pSwCtxTable->grCtx3d.CombineColorI1      = REG_RD32(NV_PGRAPH_COMBINECOLORI1);
        pSwCtxTable->grCtx3d.CombineColorI2      = REG_RD32(NV_PGRAPH_COMBINECOLORI2);
        pSwCtxTable->grCtx3d.CombineColorI3      = REG_RD32(NV_PGRAPH_COMBINECOLORI3);
        pSwCtxTable->grCtx3d.CombineColorI4      = REG_RD32(NV_PGRAPH_COMBINECOLORI4);
        pSwCtxTable->grCtx3d.CombineColorI5      = REG_RD32(NV_PGRAPH_COMBINECOLORI5);
        pSwCtxTable->grCtx3d.CombineColorI6      = REG_RD32(NV_PGRAPH_COMBINECOLORI6);
        pSwCtxTable->grCtx3d.CombineColorI7      = REG_RD32(NV_PGRAPH_COMBINECOLORI7);
        pSwCtxTable->grCtx3d.CombineColorO0      = REG_RD32(NV_PGRAPH_COMBINECOLORO0);
        pSwCtxTable->grCtx3d.CombineColorO1      = REG_RD32(NV_PGRAPH_COMBINECOLORO1);
        pSwCtxTable->grCtx3d.CombineColorO2      = REG_RD32(NV_PGRAPH_COMBINECOLORO2);
        pSwCtxTable->grCtx3d.CombineColorO3      = REG_RD32(NV_PGRAPH_COMBINECOLORO3);
        pSwCtxTable->grCtx3d.CombineColorO4      = REG_RD32(NV_PGRAPH_COMBINECOLORO4);
        pSwCtxTable->grCtx3d.CombineColorO5      = REG_RD32(NV_PGRAPH_COMBINECOLORO5);
        pSwCtxTable->grCtx3d.CombineColorO6      = REG_RD32(NV_PGRAPH_COMBINECOLORO6);
        pSwCtxTable->grCtx3d.CombineColorO7      = REG_RD32(NV_PGRAPH_COMBINECOLORO7);
        
        pSwCtxTable->grCtx3d.CombineCtl          = REG_RD32(NV_PGRAPH_COMBINECTL);
        
        pSwCtxTable->grCtx3d.CombineSpecFog0     = REG_RD32(NV_PGRAPH_COMBINESPECFOG0);
        pSwCtxTable->grCtx3d.CombineSpecFog1     = REG_RD32(NV_PGRAPH_COMBINESPECFOG1);
        
        pSwCtxTable->grCtx3d.Control0            = REG_RD32(NV_PGRAPH_CONTROL_0);
        pSwCtxTable->grCtx3d.Control1            = REG_RD32(NV_PGRAPH_CONTROL_1);
        pSwCtxTable->grCtx3d.Control2            = REG_RD32(NV_PGRAPH_CONTROL_2);
        pSwCtxTable->grCtx3d.Control3            = REG_RD32(NV_PGRAPH_CONTROL_3);
        
        pSwCtxTable->grCtx3d.FogColor            = REG_RD32(NV_PGRAPH_FOGCOLOR);
        pSwCtxTable->grCtx3d.FogParam0           = REG_RD32(NV_PGRAPH_FOGPARAM0);
        pSwCtxTable->grCtx3d.FogParam1           = REG_RD32(NV_PGRAPH_FOGPARAM1);
        pSwCtxTable->grCtx3d.PointSize           = REG_RD32(NV_PGRAPH_POINTSIZE);
        pSwCtxTable->grCtx3d.SetupRaster         = REG_RD32(NV_PGRAPH_SETUPRASTER);
        
        pSwCtxTable->grCtx3d.ShaderClipMode      = REG_RD32(NV_PGRAPH_SHADERCLIPMODE);
        pSwCtxTable->grCtx3d.ShaderCtl           = REG_RD32(NV_PGRAPH_SHADERCTL);
        pSwCtxTable->grCtx3d.ShaderProg          = REG_RD32(NV_PGRAPH_SHADERPROG);
        
        pSwCtxTable->grCtx3d.SemaphoreOffset     = REG_RD32(NV_PGRAPH_SEMAPHOREOFFSET);
        pSwCtxTable->grCtx3d.ShadowCtl           = REG_RD32(NV_PGRAPH_SHADOWCTL);
        pSwCtxTable->grCtx3d.ShadowZSlopeThreshold = REG_RD32(NV_PGRAPH_SHADOWZSLOPETHRESHOLD);
        
        pSwCtxTable->grCtx3d.SpecFogFactor0      = REG_RD32(NV_PGRAPH_SPECFOGFACTOR0);
        pSwCtxTable->grCtx3d.SpecFogFactor1      = REG_RD32(NV_PGRAPH_SPECFOGFACTOR1);
        
        pSwCtxTable->grCtx3d.SurfaceClipX        = REG_RD32(NV_PGRAPH_SURFACECLIPX);
        pSwCtxTable->grCtx3d.SurfaceClipY        = REG_RD32(NV_PGRAPH_SURFACECLIPY);
        
        pSwCtxTable->grCtx3d.TexAddress0         = REG_RD32(NV_PGRAPH_TEXADDRESS0);
        pSwCtxTable->grCtx3d.TexAddress1         = REG_RD32(NV_PGRAPH_TEXADDRESS1);
        pSwCtxTable->grCtx3d.TexAddress2         = REG_RD32(NV_PGRAPH_TEXADDRESS2);
        pSwCtxTable->grCtx3d.TexAddress3         = REG_RD32(NV_PGRAPH_TEXADDRESS3);
        
        pSwCtxTable->grCtx3d.TexCtl0_0       = REG_RD32(NV_PGRAPH_TEXCTL0_0);
        pSwCtxTable->grCtx3d.TexCtl0_1       = REG_RD32(NV_PGRAPH_TEXCTL0_1);
        pSwCtxTable->grCtx3d.TexCtl0_2       = REG_RD32(NV_PGRAPH_TEXCTL0_2);
        pSwCtxTable->grCtx3d.TexCtl0_3       = REG_RD32(NV_PGRAPH_TEXCTL0_3);
        
        pSwCtxTable->grCtx3d.TexCtl1_0       = REG_RD32(NV_PGRAPH_TEXCTL1_0);
        pSwCtxTable->grCtx3d.TexCtl1_1       = REG_RD32(NV_PGRAPH_TEXCTL1_1);
        pSwCtxTable->grCtx3d.TexCtl1_2       = REG_RD32(NV_PGRAPH_TEXCTL1_2);
        pSwCtxTable->grCtx3d.TexCtl1_3       = REG_RD32(NV_PGRAPH_TEXCTL1_3);
        
        pSwCtxTable->grCtx3d.TexCtl2_0       = REG_RD32(NV_PGRAPH_TEXCTL2_0);
        pSwCtxTable->grCtx3d.TexCtl2_1       = REG_RD32(NV_PGRAPH_TEXCTL2_1);
        
        pSwCtxTable->grCtx3d.TexFilter0          = REG_RD32(NV_PGRAPH_TEXFILTER0);
        pSwCtxTable->grCtx3d.TexFilter1          = REG_RD32(NV_PGRAPH_TEXFILTER1);
        pSwCtxTable->grCtx3d.TexFilter2          = REG_RD32(NV_PGRAPH_TEXFILTER2);
        pSwCtxTable->grCtx3d.TexFilter3          = REG_RD32(NV_PGRAPH_TEXFILTER3);
        
        pSwCtxTable->grCtx3d.TexFormat0          = REG_RD32(NV_PGRAPH_TEXFMT0);
        pSwCtxTable->grCtx3d.TexFormat1          = REG_RD32(NV_PGRAPH_TEXFMT1);
        pSwCtxTable->grCtx3d.TexFormat2          = REG_RD32(NV_PGRAPH_TEXFMT2);
        pSwCtxTable->grCtx3d.TexFormat3          = REG_RD32(NV_PGRAPH_TEXFMT3);
        
        pSwCtxTable->grCtx3d.TexImageRect0       = REG_RD32(NV_PGRAPH_TEXIMAGERECT0);
        pSwCtxTable->grCtx3d.TexImageRect1       = REG_RD32(NV_PGRAPH_TEXIMAGERECT1);
        pSwCtxTable->grCtx3d.TexImageRect2       = REG_RD32(NV_PGRAPH_TEXIMAGERECT2);
        pSwCtxTable->grCtx3d.TexImageRect3       = REG_RD32(NV_PGRAPH_TEXIMAGERECT3);
        
        pSwCtxTable->grCtx3d.TexOffset0          = REG_RD32(NV_PGRAPH_TEXOFFSET0);
        pSwCtxTable->grCtx3d.TexOffset1          = REG_RD32(NV_PGRAPH_TEXOFFSET1);
        pSwCtxTable->grCtx3d.TexOffset2          = REG_RD32(NV_PGRAPH_TEXOFFSET2);
        pSwCtxTable->grCtx3d.TexOffset3          = REG_RD32(NV_PGRAPH_TEXOFFSET3);
        
        pSwCtxTable->grCtx3d.TexPallete0         = REG_RD32(NV_PGRAPH_TEXPALETTE0);
        pSwCtxTable->grCtx3d.TexPallete1         = REG_RD32(NV_PGRAPH_TEXPALETTE1);
        pSwCtxTable->grCtx3d.TexPallete2         = REG_RD32(NV_PGRAPH_TEXPALETTE2);
        pSwCtxTable->grCtx3d.TexPallete3         = REG_RD32(NV_PGRAPH_TEXPALETTE3);
        
        pSwCtxTable->grCtx3d.WindowClipX[0]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX0);
        pSwCtxTable->grCtx3d.WindowClipX[1]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX1);
        pSwCtxTable->grCtx3d.WindowClipX[2]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX2);
        pSwCtxTable->grCtx3d.WindowClipX[3]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX3);
        pSwCtxTable->grCtx3d.WindowClipX[4]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX4);
        pSwCtxTable->grCtx3d.WindowClipX[5]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX5);
        pSwCtxTable->grCtx3d.WindowClipX[6]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX6);
        pSwCtxTable->grCtx3d.WindowClipX[7]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX7);
        
        pSwCtxTable->grCtx3d.WindowClipY[0]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY0);
        pSwCtxTable->grCtx3d.WindowClipY[1]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY1);
        pSwCtxTable->grCtx3d.WindowClipY[2]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY2);
        pSwCtxTable->grCtx3d.WindowClipY[3]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY3);
        pSwCtxTable->grCtx3d.WindowClipY[4]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY4);
        pSwCtxTable->grCtx3d.WindowClipY[5]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY5);
        pSwCtxTable->grCtx3d.WindowClipY[6]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY6);
        pSwCtxTable->grCtx3d.WindowClipY[7]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY7);
        
        pSwCtxTable->grCtx3d.ZCompressOcclude    = REG_RD32(NV_PGRAPH_ZCOMPRESSOCCLUDE);
        pSwCtxTable->grCtx3d.ZStencilClearValue  = REG_RD32(NV_PGRAPH_ZSTENCILCLEARVALUE);
        
        pSwCtxTable->grCtx3d.ZClipMax            = REG_RD32(NV_PGRAPH_ZCLIPMAX);
        pSwCtxTable->grCtx3d.ZClipMin            = REG_RD32(NV_PGRAPH_ZCLIPMIN);
        
        pSwCtxTable->grCtx3d.ContextDmaA         = REG_RD32(NV_PGRAPH_CONTEXTDMAA);
        pSwCtxTable->grCtx3d.ContextDmaB         = REG_RD32(NV_PGRAPH_CONTEXTDMAB);
        pSwCtxTable->grCtx3d.ContextDmaVtxA      = REG_RD32(NV_PGRAPH_CONTEXTVTXA);
        pSwCtxTable->grCtx3d.ContextDmaVtxB      = REG_RD32(NV_PGRAPH_CONTEXTVTXB);
        
        pSwCtxTable->grCtx3d.ZOffsetBias         = REG_RD32(NV_PGRAPH_ZOFFSETBIAS);
        pSwCtxTable->grCtx3d.ZOffsetFactor       = REG_RD32(NV_PGRAPH_ZOFFSETFACTOR);
        
        pSwCtxTable->grCtx3d.Eyevec0             = REG_RD32(NV_PGRAPH_EYEVEC0);
        pSwCtxTable->grCtx3d.Eyevec1             = REG_RD32(NV_PGRAPH_EYEVEC1);
        pSwCtxTable->grCtx3d.Eyevec2             = REG_RD32(NV_PGRAPH_EYEVEC2);
        
        pSwCtxTable->grCtx3d.Shadow              = REG_RD32(NV_PGRAPH_SHADOW);
        pSwCtxTable->grCtx3d.FdData              = REG_RD32(NV_PGRAPH_FD_DATA);
        pSwCtxTable->grCtx3d.FdSwatch            = REG_RD32(NV_PGRAPH_FD_SWATCH);
        pSwCtxTable->grCtx3d.FdExtras            = REG_RD32(NV_PGRAPH_FD_EXTRAS);
        pSwCtxTable->grCtx3d.Emission0           = REG_RD32(NV_PGRAPH_EMISSION_BACKUP_0);
        pSwCtxTable->grCtx3d.Emission1           = REG_RD32(NV_PGRAPH_EMISSION_BACKUP_1);
        pSwCtxTable->grCtx3d.Emission2           = REG_RD32(NV_PGRAPH_EMISSION_BACKUP_2);
        pSwCtxTable->grCtx3d.SceneAmb0           = REG_RD32(NV_PGRAPH_SCENE_AMBIENT_BACKUP_0);
        pSwCtxTable->grCtx3d.SceneAmb1           = REG_RD32(NV_PGRAPH_SCENE_AMBIENT_BACKUP_1);
        pSwCtxTable->grCtx3d.SceneAmb2           = REG_RD32(NV_PGRAPH_SCENE_AMBIENT_BACKUP_2);
        pSwCtxTable->grCtx3d.ContextDmaGetState  = REG_RD32(NV_PGRAPH_GETSTATE);
        pSwCtxTable->grCtx3d.BeginPatch0         = REG_RD32(NV_PGRAPH_BEGINPATCH0);
        pSwCtxTable->grCtx3d.BeginPatch1         = REG_RD32(NV_PGRAPH_BEGINPATCH1);
        pSwCtxTable->grCtx3d.BeginPatch2         = REG_RD32(NV_PGRAPH_BEGINPATCH2);
        pSwCtxTable->grCtx3d.BeginPatch3         = REG_RD32(NV_PGRAPH_BEGINPATCH3);
        pSwCtxTable->grCtx3d.BeginCurve          = REG_RD32(NV_PGRAPH_CURVE);
        pSwCtxTable->grCtx3d.BeginTrans0         = REG_RD32(NV_PGRAPH_BEGINTRANS0);
        pSwCtxTable->grCtx3d.BeginTrans1         = REG_RD32(NV_PGRAPH_BEGINTRANS1);
        pSwCtxTable->grCtx3d.Csv0_D              = REG_RD32(NV_PGRAPH_CSV0_D);
        pSwCtxTable->grCtx3d.Csv0_C              = REG_RD32(NV_PGRAPH_CSV0_C);
        pSwCtxTable->grCtx3d.Csv1_B              = REG_RD32(NV_PGRAPH_CSV1_B);
        pSwCtxTable->grCtx3d.Csv1_A              = REG_RD32(NV_PGRAPH_CSV1_A);
        pSwCtxTable->grCtx3d.CheopsOffset        = REG_RD32(NV_PGRAPH_CHEOPS_OFFSET);
        
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, RDI_ADDR_ZERO, IDX_FMT_COUNT, pSwCtxTable->grCtxPipe.IdxFmt);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, RDI_ADDR_ZERO, CAS0_COUNT, pSwCtxTable->grCtxPipe.Cas0);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, RDI_ADDR_ZERO, CAS1_COUNT, pSwCtxTable->grCtxPipe.Cas1);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, RDI_ADDR_ZERO, CAS2_COUNT, pSwCtxTable->grCtxPipe.Cas2);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_ASSM_STATE, RDI_ADDR_ZERO, ASSM_STATE_COUNT, pSwCtxTable->grCtxPipe.AssmState);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE0, RDI_ADDR_ZERO, IDX_CACHE0_COUNT, pSwCtxTable->grCtxPipe.IdxCache0);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE1, RDI_ADDR_ZERO, IDX_CACHE1_COUNT, pSwCtxTable->grCtxPipe.IdxCache1);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE2, RDI_ADDR_ZERO, IDX_CACHE2_COUNT, pSwCtxTable->grCtxPipe.IdxCache2);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE3, RDI_ADDR_ZERO, IDX_CACHE3_COUNT, pSwCtxTable->grCtxPipe.IdxCache3);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_VTX_FILE0, RDI_ADDR_ZERO, VTX_FILE0_COUNT, pSwCtxTable->grCtxPipe.VtxFile0);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_VTX_FILE1, RDI_ADDR_ZERO, VTX_FILE1_COUNT, pSwCtxTable->grCtxPipe.VtxFile1);
        
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_P, RDI_ADDR_ZERO, XL_P_COUNT, pSwCtxTable->grCtxPipe.XlP);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_XFCTX, RDI_ADDR_ZERO, XL_XFCTX_COUNT, pSwCtxTable->grCtxPipe.XlXfCtx);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_LTCTX, RDI_ADDR_ZERO, XL_LTCTX_COUNT, pSwCtxTable->grCtxPipe.XlLtCtx);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_LTC, RDI_ADDR_ZERO, XL_LTC_COUNT, pSwCtxTable->grCtxPipe.XlLtc);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, RDI_ADDR_ZERO, XL_VAB_COUNT, pSwCtxTable->grCtxPipe.XlVab);
        
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CRSTR_STIPP, RDI_ADDR_ZERO, CRSTR_STIPP_COUNT, pSwCtxTable->grCtxPipe.CrstrStipp);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_FD_CTRL, RDI_ADDR_ZERO, FD_CTRL_COUNT, pSwCtxTable->grCtxPipe.FdCtrl);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_ROP_REGS, RDI_ADDR_ZERO, ROP_REGS_COUNT, pSwCtxTable->grCtxPipe.RopRegs);
    }

    // wait for the pipe to go idle again after unloading the pipeline context
    HAL_GR_IDLE(pHalHwInfo);

    //
    // Invalidate hw's channel ID.
    //
    REG_WR32(NV_PGRAPH_CTX_CONTROL, DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _EXPIRED)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));

    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, (NUM_FIFOS_NV20 - 1));

    return (RM_OK);
}
#endif // #ifdef NV20_SW_CTX_SWITCH
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\gr\nv20\grnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRNV20.C                                                          *
*   The graphics chip dependent routines are kept here.                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include <heap.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalGrControl_NV20(VOID *);
RM_STATUS nvHalGrAlloc_NV20(VOID *);
RM_STATUS nvHalGrFree_NV20(VOID *);
RM_STATUS nvHalGrGetExceptionData_NV20(VOID *);
RM_STATUS nvHalGrService_NV20(VOID *);
RM_STATUS nvHalGrGetNotifyData_NV20(VOID *);
RM_STATUS nvHalGrSetObjectContext_NV20(VOID *);

// statics
static RM_STATUS _nvHalGrInitObjectContext_NV20(PHALHWINFO, U032, U032, U032);
static RM_STATUS _nvHalGrInit3d_NV20(PHALHWINFO, U032);

// externs
extern RM_STATUS nvHalGrClassSoftwareMethod_NV20(PHALHWINFO, PGREXCEPTIONDATA);

extern RM_STATUS nvHalGrLoadChannelContext_NV20(PHALHWINFO, U032);
extern RM_STATUS nvHalGrUnloadChannelContext_NV20(PHALHWINFO, U032);

//
// nvHalGrControl
//
RM_STATUS
nvHalGrControl_NV20(VOID *arg)
{
    PGRCONTROLARG_000 pGrControlArg = (PGRCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pGrControlArg->pHalHwInfo;
    PGRHALINFO pGrHalInfo;
    PGRHALINFO_NV20 pGrHalPvtInfo;
    U032 i;

    GR_PRINTF((DBG_LEVEL_INFO, "NVRM: nvHalGrControl_NV20\r\n"));

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pGrControlArg->id != GR_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrControlArg->pHalHwInfo;
    pGrHalInfo = pHalHwInfo->pGrHalInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;
    
    switch (pGrControlArg->cmd)
    {
        case GR_CONTROL_INIT:
            //
            // Initialize graphics debug values.
            //

            // all DEBUG0 bits are RESET bits in NV20
            pGrHalPvtInfo->Debug0 = 0x0;

            pGrHalPvtInfo->Debug1 = (U032)
                DRF_DEF(_PGRAPH, _DEBUG_1, _VOLATILE_RESET,   _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_1, _VTX_PTE,          _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_1, _VTX_CACHE,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_1, _VTX_FILE,         _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_1, _DRAWDIR_AUTO,     _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_1, _DRAWDIR_Y,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_1, _INSTANCE,         _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_1, _CTX,              _INIT);

            pGrHalPvtInfo->Debug2 = (U032)
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_PITCH_CHECK_2D, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_PITCH_CHECK_BLT, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_PITCH_CHECK_CELS, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_PITCH_CHECK_3D, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_LIMIT_CHECK,    _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_OVRFLW_CHECK,   _DISABLED) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_MEMSIZE_CHECK,  _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_SWIZZLE_CHECK,  _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_TILEVIOL,       _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_ENDIAN_CHECK,   _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_LIMIT_INT,      _ENABLED) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_OVRFLW_INT,     _DISABLED) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_PASS_VIOL,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_PITCHWRAP,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_DITHER_3D,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_DITHER_2D,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_SWALLOW_REQS,   _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_SBFILTER,       _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_FASTCLEAR,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_FLUSH_HOLDOFF,  _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_TILEBIT_UPDATE, _INIT);

            pGrHalPvtInfo->Debug3 = (U032)
                DRF_DEF(_PGRAPH, _DEBUG_3, _FLUSHING,              _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _HW_CONTEXT_SWITCH,     _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _FD_CHECK,              _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _FAST_DATA_STRTCH,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _FAST_3D_SHADOW_DATA,   _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _CHECK_64BYTE_ALIGN,    _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _SINGLE_STEP,           _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _RDI_IDLE_WAIT,         _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _IDLE_FILTER,           _ENABLED) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _SYNCHRONIZE,           _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _OBJECT_RELOAD,         _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _PM_TRIGGER,            _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _ALTARCH,               _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _SINGLE_CYCLE_LOAD,     _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _BILINEAR_3D,           _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _VOLATILE_RESET,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _DATA_CHECK,            _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _DATA_CHECK_FAIL,       _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _FORMAT_CHECK,          _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _DMA_CHECK,             _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _STATE_CHECK,           _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _KELVIN_HWFLIP,         _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _FAST_3D_RESTORE,       _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _STATE3D_CHECK,         _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _XFMODE_COALESCE,       _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _CTX_METHODS,           _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _OP_METHODS,            _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _IGNORE_PATCHVALID,     _INIT);

            // all DEBUG_[4,5] bits are SPARES currently
            pGrHalPvtInfo->Debug4 = 0x0;
            pGrHalPvtInfo->Debug5 =
                DRF_DEF(_PGRAPH, _DEBUG_5, _ZCULL_REQ_FULL_CVG,    _ENABLED) |
                DRF_DEF(_PGRAPH, _DEBUG_5, _ZCULL_PUNT_FB_BUSY,    _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_5, _ZCULL_PUNT_S_ON_Z,     _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_5, _ZCULL_RETURN_COMP,     _INIT);

            pGrHalPvtInfo->Debug6 = (U032)
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_SEP_ZC_READS,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_DITHER_3D,         _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_DITHER_2D,         _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_EARLY_ZABORT,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_PASS_ROPFLUSH,     _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_CBUF_DRAIN,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_CBUF_HIGHWATER,    _FULL) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_CBUF_HIGHWATER2,   _FULL) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_COALESCE_3D,       _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_COALESCE_2D,       _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_FIXED_ADRS,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_FAST_KEEP_DST,     _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_FORCE_CREAD,       _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_ALLOW_3D_SKIP_READ, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_ZCMP_ALWAYS_READ,  _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_ZCOMPRESS_EN,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_BURST_CREADS,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_BURST_CWRITES,     _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_AUTO_INIT,         _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_HASH_TEST1,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_INTERLOCK,         _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_ZREAD,             _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_ZCULL_DATA,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_CROP_SWALLOW,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _SPARE_BIT31,           _INIT);

            pGrHalPvtInfo->Debug7 = (U032)
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_INIT_ZRD_TMSTAMP,  _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZCULL_NO_STALE,    _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZROP_INTERLOCK,    _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_FORCE_VISIBLE, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_PURGE_PER_PKT, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_FORCE_NO_16BYTE_WR, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_FORCE_FSTCLR_EXPAND, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_FORCE_NO_RMW_DISABLE, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_INHIBIT_COMPRESS, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_CMPR_FULL_BE_ONLY, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_ALWAYS_WR_STENCIL, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_INHIBIT_SKIP_WR_EQ, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_SELECTPM,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_EXTRA1,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_EXTRA2,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_EXTRA3,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_CROP_SELECTPM,     _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_EXTRA4,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZRD_HASH_TAGS,     _INIT) |
                // XXX confirm fastest setting
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_CROP_BLIT_HASH,    _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZROP_RAISE_PRI,    _ENABLE) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_CROP_RAISE_PRI,    _ENABLE) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_TC_SELECT_REQ,     _INIT);

            pGrHalPvtInfo->Debug8 = (U032)
                DRF_DEF(_PGRAPH, _DEBUG_8, _SHADER_FIFO_WATERMARK, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_8, _COMBINER_NEG_TEXTURE,  _INIT);

            pGrHalPvtInfo->Debug9 = (U032)
                DRF_DEF(_PGRAPH, _DEBUG_9, _BEGIN_PATCH0_CHECK, _ENABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _BEGIN_PATCH1_CHECK, _ENABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _BEGIN_PATCH2_CHECK, _ENABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _BEGIN_PATCH3_CHECK, _ENABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _END_PATCH_CHECK, _ENABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _BEGIN_END_SWATCH_CHECK, _ENABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _BEGIN_END_CURVE_CHECK, _DISABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _CURVE_COEFF_CHECK, _ENABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _BEGIN_TRANS0_CHECK, _ENABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _BEGIN_TRANS1_CHECK, _ENABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _BEGIN_TRANS2_CHECK, _ENABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _END_TRANSITION_CHECK, _ENABLE);

            //
            // Have to use hybrid context switch mode to work around
            // FD bug...we'll do this here so it's easier to control
            // on future chips where we'll hopefully be able to
            // employ full hw context switching.
            //
            pGrHalPvtInfo->Debug3 &= ~(U032)DRF_DEF(_PGRAPH, _DEBUG_3, _HW_CONTEXT_SWITCH, _ENABLED);

            //
            // Separate color and Z reads on SDR memory configurations
            // (i.e. same dram bank).
            //
            if (REG_RD_DRF(_PBUS, _FBIO_RAM, _TYPE) == NV_PBUS_FBIO_RAM_TYPE_SDR)
                pGrHalPvtInfo->Debug6 |= DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_SEP_ZC_READS, _ENABLED);
            else
                pGrHalPvtInfo->Debug6 |= DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_SEP_ZC_READS, _DISABLED);

            //
            // Initialize graphics channel context table register.
            //
            pGrHalPvtInfo->CtxTableBase = pHalHwInfo->grInstMem;
            REG_WR_DRF_NUM(_PGRAPH, _CHANNEL_CTX_TABLE, _INST, pHalHwInfo->grInstMem);
            for (i = 0; i < NUM_FIFOS_NV20; i++)
                INST_WR32(pGrHalPvtInfo->CtxTableBase, i*4, 0);

            //
            // Init channel id to invalid.
            //
            pGrHalPvtInfo->currentChID = NUM_FIFOS_NV20;

            //
            // Per Luke Chang...
            //
            // Fix 2D im_class (scaled class) zpipe overflow
            // bug by shortening the rbuffer in tcache by 9 entries
            //
            RDI_REG_WR32(NV_IGRAPH_TC_TPA_INDEX_SELECT,
                         NV_IGRAPH_TC_TPA_RBFRDEPTH_INDEX_ADDRESS,
                         0x30);
            RDI_REG_WR32(NV_IGRAPH_TC_TPB_INDEX_SELECT,
                         NV_IGRAPH_TC_TPA_RBFRDEPTH_INDEX_ADDRESS,
                         0x30);
            break;
        case GR_CONTROL_LOAD:
        {
            U032 misc;

            //
            // To reset graphics on nv20, we can't use
            // DEBUG_0, because the _CACHE_STATE bit will
            // cause a hang in the tcache.
            //
            // Instead, we use the PMC register.
            //
            FLD_WR_DRF_DEF(_PMC, _ENABLE, _PGRAPH, _DISABLED);
            FLD_WR_DRF_DEF(_PMC, _ENABLE, _PGRAPH, _ENABLED);

            //
            // Restore DEBUG registers.
            //
            REG_WR32(NV_PGRAPH_DEBUG_0, pGrHalPvtInfo->Debug0);
            REG_WR32(NV_PGRAPH_DEBUG_1, pGrHalPvtInfo->Debug1);
            REG_WR32(NV_PGRAPH_DEBUG_2, pGrHalPvtInfo->Debug2);
            REG_WR32(NV_PGRAPH_DEBUG_3, pGrHalPvtInfo->Debug3);
            REG_WR32(NV_PGRAPH_DEBUG_4, pGrHalPvtInfo->Debug4);
            REG_WR32(NV_PGRAPH_DEBUG_5, pGrHalPvtInfo->Debug5);
            REG_WR32(NV_PGRAPH_DEBUG_6, pGrHalPvtInfo->Debug6);
            REG_WR32(NV_PGRAPH_DEBUG_7, pGrHalPvtInfo->Debug7);
            REG_WR32(NV_PGRAPH_DEBUG_8, pGrHalPvtInfo->Debug8);
            REG_WR32(NV_PGRAPH_DEBUG_9, pGrHalPvtInfo->Debug9);

            //
            // Per Luke Chang...
            //
            // Fix 2D im_class (scaled class) zpipe overflow
            // bug by shortening the rbuffer in tcache by 9 entries
            //
            RDI_REG_WR32(NV_IGRAPH_TC_TPA_INDEX_SELECT,
                         NV_IGRAPH_TC_TPA_RBFRDEPTH_INDEX_ADDRESS,
                         0x30);
            RDI_REG_WR32(NV_IGRAPH_TC_TPB_INDEX_SELECT,
                         NV_IGRAPH_TC_TPA_RBFRDEPTH_INDEX_ADDRESS,
                         0x30);

            //
            // Restore context buffer base address.
            //
            REG_WR_DRF_NUM(_PGRAPH, _CHANNEL_CTX_TABLE, _INST, pHalHwInfo->grInstMem);

            // 
            // PGRAPH_TILE values will be reset after a PGRAPH_DEBUG_0_STATE_RESET.
            // Unfortunately, it may have had values we wanted (e.g. from stateFb),
            // so after a DEBUG_0_STATE_RESET, restore the PGRAPH values from PFB.
            //
            HAL_GR_IDLE(pGrControlArg->pHalHwInfo);

            for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
            {
                misc = REG_RD32(NV_PFB_TLIMIT(i));
                REG_WR32(NV_PGRAPH_TLIMIT(i), misc);
                RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                             NV_IGRAPH_TC_MINTFCDEBUG_TLIMIT_ADDRESS(i),
                             misc);
                
                misc = REG_RD32(NV_PFB_TSIZE(i));
                REG_WR32(NV_PGRAPH_TSIZE(i), misc);
                RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                             NV_IGRAPH_TC_MINTFCDEBUG_TPITCH_ADDRESS(i),
                             misc);

                misc = REG_RD32(NV_PFB_TILE(i));
                REG_WR32(NV_PGRAPH_TILE(i), REG_RD32(NV_PFB_TILE(i)));
                RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                             NV_IGRAPH_TC_MINTFCDEBUG_TILE_ADDRESS(i),
                             misc);

#ifdef DEBUG
                // these registers need to agree
                if (REG_RD32(NV_PFB_TILE(i)) != REG_RD32(NV_PGRAPH_TILE(i)))
                    DBG_BREAKPOINT();
                if (REG_RD32(NV_PFB_TLIMIT(i)) != REG_RD32(NV_PGRAPH_TLIMIT(i)))
                    DBG_BREAKPOINT();
                if (REG_RD32(NV_PFB_TSIZE(i)) != REG_RD32(NV_PGRAPH_TSIZE(i)))
                    DBG_BREAKPOINT();
#endif
            }

            //
            // Restore zcompression table from fb engine.
            //
            for (i = 0; i < NV_PFB_ZCOMP__SIZE_1; i++)
            {
                misc = REG_RD32(NV_PFB_ZCOMP(i));
                REG_WR32(NV_PGRAPH_ZCOMP(i), misc);
                RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                             NV_IGRAPH_TC_MINTFCDEBUG_ZCOMP_ADDRESS(i),
                             misc);
            }
            misc = REG_RD32(NV_PFB_ZCOMP_OFFSET);
            REG_WR32(NV_PGRAPH_ZCOMP_OFFSET, misc);
            RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                         NV_IGRAPH_TC_MINTFCDEBUG_ZOFFSET_ADDRESS,
                         misc);

            //
            // Restore framebuffer config registers from fb engine.
            //
            misc = REG_RD32(NV_PFB_CFG0);
            REG_WR32(NV_PGRAPH_FBCFG0, misc);
            RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                         NV_IGRAPH_TC_MINTFCDEBUG_CFG0_ADDRESS,
                         misc);

            misc = REG_RD32(NV_PFB_CFG1);
            REG_WR32(NV_PGRAPH_FBCFG1, misc);
            RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                         NV_IGRAPH_TC_MINTFCDEBUG_CFG1_ADDRESS,
                         misc);

            REG_WR32(NV_PGRAPH_CTX_SWITCH1,  0x00000000);
            REG_WR32(NV_PGRAPH_CTX_SWITCH2,  0x00000000);
            REG_WR32(NV_PGRAPH_CTX_SWITCH3,  0x00000000);
            REG_WR32(NV_PGRAPH_CTX_SWITCH4,  0x00000000);
            REG_WR32(NV_PGRAPH_CTX_CONTROL,
                     DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _EXPIRED)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
            REG_WR_DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHID_STATUS, _VALID);

            //
            // Reload current graphics context.
            //
            (void) nvHalGrLoadChannelContext_NV20(pHalHwInfo, pGrHalPvtInfo->currentChID);
            break;
        }
        case GR_CONTROL_UNLOAD:
        {
            //
            // Force an unload of the current channel.
            //
            (void) nvHalGrLoadChannelContext_NV20(pHalHwInfo, NUM_FIFOS_NV20);
            break;
        }
        case GR_CONTROL_DESTROY:
        case GR_CONTROL_UPDATE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalGrAlloc
//
RM_STATUS
nvHalGrAlloc_NV20(VOID *arg)
{
    PGRALLOCARG_000 pGrAllocArg = (PGRALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pGrAllocArg->pHalHwInfo;
    PGRHALINFO pGrHalInfo;
    PGRHALINFO_NV20 pGrHalPvtInfo;

    GR_PRINTF((DBG_LEVEL_INFO, "NVRM: nvHalGrAlloc_NV20\r\n"));

    //
    // Verify interface revision.
    //
    if (pGrAllocArg->id != GR_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrAllocArg->pHalHwInfo;
    pGrHalInfo = pHalHwInfo->pGrHalInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;

    //
    // If we've got a 3d object, keep note of it.
    //
    if ((pGrAllocArg->classNum == NV10_CELSIUS_PRIMITIVE) ||
        (pGrAllocArg->classNum == NV15_CELSIUS_PRIMITIVE) ||
        (pGrAllocArg->classNum == NV11_CELSIUS_PRIMITIVE) ||
        (pGrAllocArg->classNum == NV20_KELVIN_PRIMITIVE))
    {
        //
        // Check that a current 3D object hasn't already been created.
        //
        if (pGrHalPvtInfo->currentObjects3d[pGrAllocArg->chid] != 0) {
            GR_PRINTF((DBG_LEVEL_ERRORS, "NVRM: 3d state in use by instance: 0x%x\n", pGrHalPvtInfo->currentObjects3d[pGrAllocArg->chid]));
            return (RM_ERR_ILLEGAL_OBJECT);
        }
        // ASSERT(pGrChannel->CurrentObject3d == 0)

        pGrHalPvtInfo->currentObjects3d[pGrAllocArg->chid] = pGrAllocArg->instance;

        pGrHalInfo->has3dObject |= (0x1 << pGrAllocArg->chid);

        // WAR: pipe hang due to IDX_FMT compsel corruption during ctx switch
        if ((pGrAllocArg->classNum == NV10_CELSIUS_PRIMITIVE) ||
            (pGrAllocArg->classNum == NV15_CELSIUS_PRIMITIVE) ||
            (pGrAllocArg->classNum == NV11_CELSIUS_PRIMITIVE))
            pGrHalPvtInfo->hasCelsius |= (0x1 << pGrAllocArg->chid);

        _nvHalGrInit3d_NV20(pHalHwInfo, pGrAllocArg->chid);
    }

    //
    // Initialize generic object context.
    //
    _nvHalGrInitObjectContext_NV20(pHalHwInfo, pGrAllocArg->instance, pGrAllocArg->classNum, pGrAllocArg->flags);

    return (RM_OK);
}

//
// nvHalGrFree
//
RM_STATUS
nvHalGrFree_NV20(VOID *arg)
{
    PGRFREEARG_000 pGrFreeArg = (PGRFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PGRHALINFO pGrHalInfo;
    PGRHALINFO_NV20 pGrHalPvtInfo;
    U032 i;

    //
    // Verify interface revision.
    //
    if (pGrFreeArg->id != GR_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrFreeArg->pHalHwInfo;
    pGrHalInfo = pHalHwInfo->pGrHalInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;

    //
    // Clear 3d current object pointer if necessary.
    //
    if (pGrFreeArg->instance == pGrHalPvtInfo->currentObjects3d[pGrFreeArg->chid])
    {
        // we could ASSERT that this is a 3d object here as well
        pGrHalPvtInfo->currentObjects3d[pGrFreeArg->chid] = 0;

        // clear the 3d object bit (either never had one or it was just freed)
        pGrHalInfo->has3dObject &= ~(0x1 << pGrFreeArg->chid);

        // clear the Celsius bit (either never had one or it was just freed)
        pGrHalPvtInfo->hasCelsius &= ~(0x1 << pGrFreeArg->chid);
    }

    //
    // Zero out the object context for good measure.
    //
    for (i = 0; i < 4; i++)
    {
        INST_WR32(pGrFreeArg->instance, i, 0);
    }

    return (RM_OK);
}

//
// nvHalGrGetExceptionData
//
// Retrieve graphics engine exception data.
//
RM_STATUS
nvHalGrGetExceptionData_NV20(VOID *arg)
{
    PGRGETEXCEPTIONDATAARG_000 pGrGetExceptionDataArg = (PGRGETEXCEPTIONDATAARG_000)arg;
    PHALHWINFO pHalHwInfo = pGrGetExceptionDataArg->pHalHwInfo;
    PGREXCEPTIONDATA pGrExceptionData;

    //
    // Verify interface revision.
    //
    if (pGrGetExceptionDataArg->id != GR_GET_EXCEPTION_DATA_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrGetExceptionDataArg->pHalHwInfo;
    pGrExceptionData = pGrGetExceptionDataArg->pExceptionData;

    //
    // Fill in exception data.
    //
    pGrExceptionData->Offset = REG_RD32(NV_PGRAPH_TRAPPED_ADDR);
    pGrExceptionData->ChID = DRF_VAL(_PGRAPH, _TRAPPED_ADDR, _CHID, pGrExceptionData->Offset);
    pGrExceptionData->NotifyInstance = REG_RD_DRF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE);
    pGrExceptionData->classNum = REG_RD_DRF(_PGRAPH, _CTX_SWITCH1, _GRCLASS);
    pGrExceptionData->Data = REG_RD32(NV_PGRAPH_TRAPPED_DATA_LOW); 
    pGrExceptionData->Instance = REG_RD32(NV_PGRAPH_CTX_SWITCH4);
    pGrExceptionData->Offset &= (DRF_MASK(NV_PGRAPH_TRAPPED_ADDR_MTHD) << DRF_SHIFT(NV_PGRAPH_TRAPPED_ADDR_MTHD));
    pGrExceptionData->Nsource = REG_RD32(NV_PGRAPH_NSOURCE);
    pGrExceptionData->MethodStatus = RM_OK;

    return (RM_OK);
}

//
// nvHalGrService
//
// Handle selected graphics object exceptions.
//
RM_STATUS
nvHalGrService_NV20(VOID *arg)
{
    PGRSERVICEARG_000 pGrServiceArg = (PGRSERVICEARG_000)arg;
    PHALHWINFO pHalHwInfo = pGrServiceArg->pHalHwInfo;
    PGRHALINFO_NV20 pGrHalPvtInfo;
    PGREXCEPTIONDATA pGrExceptionData;

    //
    // Verify interface revision.
    //
    if (pGrServiceArg->id != GR_SERVICE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrServiceArg->pHalHwInfo;
    pGrExceptionData = pGrServiceArg->pExceptionData;
    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;

    //
    // Make sure object is valid.
    //
    //if (pGrExceptionData->instance == 0)
    //    return (NV_HAL_ERROR_INVALID_STATE);

    //
    // Handle any exceptions...
    //
    if (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _CONTEXT_SWITCH, _PENDING))
    {
        //
        // Reset condition.
        //
        REG_WR_DRF_DEF(_PGRAPH, _INTR, _CONTEXT_SWITCH, _RESET);

        //
        // Wait for idle
        //
        GR_DONE();
    
        //
        // Graphics channel switch.
        //
        GR_PRINTF((DBG_LEVEL_INFO, "NVRM: Graphics context switch exception.\n\r"));
        GR_PRINTF((DBG_LEVEL_INFO, "NVRM: Previous graphics channel: 0x%x\n",pGrHalPvtInfo->currentChID));
        GR_PRINTF((DBG_LEVEL_INFO, "NVRM: New graphics channel: 0x%x\n", pGrExceptionData->ChID));

        (void) nvHalGrLoadChannelContext_NV20(pHalHwInfo, pGrExceptionData->ChID);
    }

    //
    // Handle methods in software.
    //
    if (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _MISSING_HW, _PENDING))
    {
        if (nvHalGrClassSoftwareMethod_NV20(pHalHwInfo, pGrExceptionData) == RM_OK)
        {
            // Reset condition.
            REG_WR_DRF_DEF(_PGRAPH, _INTR, _MISSING_HW, _RESET);
        }
    }

    if ((pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _NOTIFY, _PENDING)) ||
        (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _ERROR, _PENDING)))
    {
        if (pGrExceptionData->Nsource & DRF_DEF(_PGRAPH, _NSOURCE, _ILLEGAL_MTHD, _PENDING))
        {
            if (nvHalGrClassSoftwareMethod_NV20(pHalHwInfo, pGrExceptionData) == RM_OK)
            {
                // Reset condition.
                if (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _NOTIFY, _PENDING))
                    REG_WR_DRF_DEF(_PGRAPH, _INTR, _NOTIFY, _RESET);
                else
                    REG_WR_DRF_DEF(_PGRAPH, _INTR, _ERROR, _RESET);
            }
        }

        if (pGrExceptionData->Nsource & DRF_DEF(_PGRAPH, _NSOURCE, _PROTECTION_ERROR, _PENDING))
        {
            //
            // There's a bug in the scaled_image class that causes us
            // to bump all context dma limits by at least 0x40 bytes.
            // This causes a perfectly aligned semaphore ctxdma to
            // limit check.  We'll recover from this case by removing
            // the number of pad bytes.
            //
            if (pGrExceptionData->classNum == NV20_KELVIN_PRIMITIVE &&
                pGrExceptionData->Offset == NV097_SET_CONTEXT_DMA_SEMAPHORE)
            {
                U032 data;

                //
                // Fix up semaphore limit.
                //
                data = INST_RD32(pGrExceptionData->Data, SF_OFFSET(NV_DMA_LIMIT));
                data -= NV20_SCALED_IMAGE_WAR_OFFSET;
                INST_WR32(pGrExceptionData->Data, SF_OFFSET(NV_DMA_LIMIT), data);

                //
                // Clear condition so RM doesn't mess with it.
                //
                pGrExceptionData->Nsource &= ~DRF_DEF(_PGRAPH, _NSOURCE, _PROTECTION_ERROR, _PENDING);
            }
        }

        if (pGrExceptionData->Nsource & DRF_DEF(_PGRAPH, _NSOURCE, _DATA_ERROR, _PENDING))
        {
            //
            // There's a bug in the nv20 Kelvin SetBumpEnv method
            // error checks that clamps the input data at
            // [-8.0,8.0].
            //
            // If we get one of these methods, we'll update the
            // priv regs directly and clear the error condition
            // (i.e. all values are legal).
            //
            if (pGrExceptionData->classNum == NV20_KELVIN_PRIMITIVE)
            {
                U032 offset = 0;

                switch (pGrExceptionData->Offset)
                {
                    case NV097_SET_TEXTURE_SET_BUMP_ENV_MAT00(1):
                        offset = NV_PGRAPH_BUMPMAT00_1;
                        break;
                    case NV097_SET_TEXTURE_SET_BUMP_ENV_MAT01(1):
                        offset = NV_PGRAPH_BUMPMAT01_1;
                        break;
                    case NV097_SET_TEXTURE_SET_BUMP_ENV_MAT10(1):
                        offset = NV_PGRAPH_BUMPMAT10_1;
                        break;
                    case NV097_SET_TEXTURE_SET_BUMP_ENV_MAT11(1):
                        offset = NV_PGRAPH_BUMPMAT11_1;
                        break;

                    case NV097_SET_TEXTURE_SET_BUMP_ENV_MAT00(2):
                        offset = NV_PGRAPH_BUMPMAT00_2;
                        break;
                    case NV097_SET_TEXTURE_SET_BUMP_ENV_MAT01(2):
                        offset = NV_PGRAPH_BUMPMAT01_2;
                        break;
                    case NV097_SET_TEXTURE_SET_BUMP_ENV_MAT10(2):
                        offset = NV_PGRAPH_BUMPMAT10_2;
                        break;
                    case NV097_SET_TEXTURE_SET_BUMP_ENV_MAT11(2):
                        offset = NV_PGRAPH_BUMPMAT11_2;
                        break;

                    case NV097_SET_TEXTURE_SET_BUMP_ENV_MAT00(3):
                        offset = NV_PGRAPH_BUMPMAT00_3;
                        break;
                    case NV097_SET_TEXTURE_SET_BUMP_ENV_MAT01(3):
                        offset = NV_PGRAPH_BUMPMAT01_3;
                        break;
                    case NV097_SET_TEXTURE_SET_BUMP_ENV_MAT10(3):
                        offset = NV_PGRAPH_BUMPMAT10_3;
                        break;
                    case NV097_SET_TEXTURE_SET_BUMP_ENV_MAT11(3):
                        offset = NV_PGRAPH_BUMPMAT11_3;
                        break;
                }

                if (offset)
                {
                    REG_WR32(offset, pGrExceptionData->Data);

                    //
                    // Clear condition so RM doesn't mess with it.
                    //
                    pGrExceptionData->Nsource &= ~DRF_DEF(_PGRAPH, _NSOURCE, _DATA_ERROR, _PENDING);
                }
            }
        }


        //
        // Workaround bug in hw that rejects 3d clip methods w/i a
        // patch.
        //
        if (((pGrExceptionData->classNum == NV10_CELSIUS_PRIMITIVE) ||
             (pGrExceptionData->classNum == NV15_CELSIUS_PRIMITIVE) ||
             (pGrExceptionData->classNum == NV11_CELSIUS_PRIMITIVE) ||
             (pGrExceptionData->classNum == NV20_KELVIN_PRIMITIVE)) &&
            (pGrExceptionData->Nsource & DRF_DEF(_PGRAPH, _NSOURCE, _FD_INVALID_OP, _PENDING)))
        {
            PGRAPHICSCHANNEL_NV20 pGrChannel = 0;
            U032 ctxOffset = 0, ctxData = 0, data32;
            U032 clipOffsetMin = 0, clipOffsetMax = 0;

#define GRCHANOFFSET(p,a)           ((U032)((char *)(&(p->a)) - (char *)p))
            
            //
            // Convert method offset/data into context buffer
            // instmem offset/data.
            //
            // NOTE: for the SET_WINDOW_CLIP_HORIZ/VERT methods, we'll
            // update a range of registers.  For example, if we get
            // method NV097_SET_WINDOW_CLIP_HORIZONTAL(0), we'll update
            // PGRAPH_WINDOWCLIPX(0) -> PGRAPH_WINDOWCLIPX(7).  If we
            // get method NV097_SET_WINDOW_CLIP_HORIZONTAL(4), we'll
            // update PGRAPH_WINDOWCLIPX(4) -> PGRAPH_WINDOWCLIPX(7).
            //
            // NOTE: the Kelvin method offsets line up with the Celsius
            // equivalents.
            //
            //
            if (pGrExceptionData->Offset == NV097_SET_WINDOW_CLIP_TYPE)
            {
                // 0|1 are the legal values
                if (pGrExceptionData->Data < 2)
                {
                    ctxOffset = GRCHANOFFSET(pGrChannel, grCtx3d.SetupRaster);
                    ctxData = pGrExceptionData->Data;
                }
            }
            else if (pGrExceptionData->Offset >= NV097_SET_WINDOW_CLIP_HORIZONTAL(0) && pGrExceptionData->Offset <= NV097_SET_WINDOW_CLIP_HORIZONTAL(7))
            {
                clipOffsetMin = (pGrExceptionData->Offset - NV097_SET_WINDOW_CLIP_HORIZONTAL(0))/4;
                clipOffsetMax = 7;
                ctxOffset = GRCHANOFFSET(pGrChannel, grCtx3d.WindowClipX[clipOffsetMin]);
                // no error checking here!
                ctxData = pGrExceptionData->Data;
            }
            else if (pGrExceptionData->Offset >= NV097_SET_WINDOW_CLIP_VERTICAL(0) && pGrExceptionData->Offset <= NV097_SET_WINDOW_CLIP_VERTICAL(7))
            {
                clipOffsetMin = (pGrExceptionData->Offset - NV097_SET_WINDOW_CLIP_VERTICAL(0))/4;
                clipOffsetMax = 7;
                ctxOffset = GRCHANOFFSET(pGrChannel, grCtx3d.WindowClipY[clipOffsetMin]);
                // no error checking here!
                ctxData = pGrExceptionData->Data;
            }

            //
            // Ctxoffset == 0 means that we got this error on a method we don't care about
            //
            if (ctxOffset != 0)
            {
                U032 misc, i;

                //
                // Reset condition.
                //
                REG_WR_DRF_DEF(_PGRAPH, _INTR, _ERROR, _RESET);

                //
                // Wait for idle
                //
                GR_DONE();

                //
                // Save current graphics interface state.
                //
                GR_SAVE_STATE(misc);
                HAL_GR_IDLE(pHalHwInfo);

                if (pGrExceptionData->ChID == pGrHalPvtInfo->currentChID)
                {
                    //
                    // Unload current channel state.
                    //
                    (void) nvHalGrUnloadChannelContext_NV20(pHalHwInfo, pGrExceptionData->ChID);

                    //
                    // CLIPTYPE needs to be moved to PGRAPH_SETUPRASTER[31].
                    //
                    if (pGrExceptionData->Offset == NV097_SET_WINDOW_CLIP_TYPE)
                    {
                        data32 = INST_RD32(pGrHalPvtInfo->CtxTable[pGrExceptionData->ChID], ctxOffset);
                        data32 &= ~(DRF_DEF(_PGRAPH, _SETUPRASTER, _WINDOWCLIPTYPE, _EXCLUSIVE));
                        data32 |= DRF_NUM(_PGRAPH, _SETUPRASTER, _WINDOWCLIPTYPE, ctxData);
                        ctxData = data32;
                    }

                    //
                    // Patch regs in just-saved context buffer.
                    // If we got one of the SET_CLIP_HORIZ/VERT methods,
                    // then we need to update a range of registers (from
                    // the specified method offset to the end of the
                    // range in hw (in this case, 7).
                    //
                    for (i = clipOffsetMin; i <= clipOffsetMax; i++)
                    {
                        INST_WR32(pGrHalPvtInfo->CtxTable[pGrExceptionData->ChID], ctxOffset, ctxData);
                        ctxOffset += 4;
                    }

                    //
                    // Reload channel.
                    //
                    (void) nvHalGrLoadChannelContext_NV20(pHalHwInfo, pGrExceptionData->ChID);

                    //
                    // Clear condition so RM doesn't mess with it.
                    //
                    pGrExceptionData->Nsource &= ~DRF_DEF(_PGRAPH, _NSOURCE, _FD_INVALID_OP, _PENDING);
                }
            }
        }
    }

    return (RM_OK);
}

//
// nvHalGrNotifyData
//
// Fill in notify data (trigger status and action).
//
RM_STATUS
nvHalGrGetNotifyData_NV20(VOID *arg)
{
    PGRGETNOTIFYDATAARG_000 pGrGetNotifyDataArg = (PGRGETNOTIFYDATAARG_000)arg;
    PHALHWINFO pHalHwInfo = pGrGetNotifyDataArg->pHalHwInfo;
    PGRNOTIFYDATA pGrNotifyData;

    GR_PRINTF((DBG_LEVEL_INFO, "NVRM: nvHalGrGetNotifyData_NV20\r\n"));

    //
    // Verify interface revision.
    //
    if (pGrGetNotifyDataArg->id != GR_GET_NOTIFY_DATA_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrGetNotifyDataArg->pHalHwInfo;
    pGrNotifyData = pGrGetNotifyDataArg->pGrNotifyData;

    if (REG_RD32(NV_PGRAPH_NOTIFY) &
        (DRF_DEF(_PGRAPH, _NOTIFY, _REQ, _PENDING) |
         DRF_DEF(_PGRAPH, _NOTIFY, _STYLE, _WRITE_THEN_AWAKEN)))
    {
        pGrNotifyData->trigger = TRUE;
        pGrNotifyData->action =  REG_RD_DRF(_PGRAPH, _NOTIFY, _STYLE);
        // clear the notify condition
        FLD_WR_DRF_DEF(_PGRAPH, _NOTIFY, _REQ, _NOT_PENDING);
    } else {
        pGrNotifyData->trigger = FALSE;
        pGrNotifyData->action = 0;
    }

    return (RM_OK);
}

//
// nvHalGrSetObjectContext
//
// Update various graphics object context bits.
// On NV20, these bits are managed by hardware so this
// routine does some error checking and returns.
//
RM_STATUS
nvHalGrSetObjectContext_NV20(VOID *arg)
{
    PGRSETOBJECTCONTEXTARG_000 pGrSetObjectContextArg = (PGRSETOBJECTCONTEXTARG_000)arg;
    PHALHWINFO pHalHwInfo = pGrSetObjectContextArg->pHalHwInfo;
    U032 context, instance;
    U032 fifo;
    U032 i;

    GR_PRINTF((DBG_LEVEL_INFO, "NVRM: nvHalGrSetObjectContext_NV20\r\n"));

    //
    // Verify interface revision.
    //
    if (pGrSetObjectContextArg->id != GR_SET_OBJECT_CONTEXT_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Verify chid.
    //
    if (pGrSetObjectContextArg->chid > NUM_FIFOS_NV20)
        return (RM_ERR_BAD_ARGUMENT);

    //
    // Verify instance (what else can we do here without
    // keeping track of all objects that pass through the
    // nvHalGrAlloc interface down in the HAL?).
    //
    if (pGrSetObjectContextArg->instance == 0)
        return (RM_ERR_BAD_ARGUMENT);

    pHalHwInfo = pGrSetObjectContextArg->pHalHwInfo;
    instance = pGrSetObjectContextArg->instance;
    
    //
    // Fetch current context.
    //
    context = INST_RD32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_0));

    //
    // Make necessary adjustments.
    //
    context &= pGrSetObjectContextArg->andMask;
    context |= pGrSetObjectContextArg->orMask;

    //
    // Write it back out                   
    //
    INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_0), context);
        
    //
    // Now we need to update the hardware context if appropriate.
    //
    if (pGrSetObjectContextArg->chid == REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID))
    {
        //
        // First disable the graphics fifo so we can get to the context rams
        //
        fifo = REG_RD32(NV_PGRAPH_FIFO);
        REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);
            
        //
        // Walk to subchannels and see if we find a match; update when we do
        //
        for (i = 0 ; i < 8 ; i++)
        {            
            if (REG_RD32(NV_PGRAPH_CTX_CACHE4(i)) == instance)
            {   
                //
                // Get the current settings
                //
                context = REG_RD32(NV_PGRAPH_CTX_CACHE1(i));

                //
                // Make necessary adjustments.
                //
                context &= pGrSetObjectContextArg->andMask;
                context |= pGrSetObjectContextArg->orMask;

                //
                // Write it back out                   
                //
                REG_WR32(NV_PGRAPH_CTX_CACHE1(i), context);
            }
        }                                    
                             
        //
        // See if the currently active subchannel also needs updating
        //
        if (REG_RD_DRF(_PGRAPH, _CTX_SWITCH4, _USER_INSTANCE) == instance)
        {   
            //
            // Get the current settings
            //
            context = REG_RD32(NV_PGRAPH_CTX_SWITCH1);

            //
            // Make necessary adjustments.
            //
            context &= pGrSetObjectContextArg->andMask;
            context |= pGrSetObjectContextArg->orMask;

            //
            // Write it back out                   
            //
            REG_WR32(NV_PGRAPH_CTX_SWITCH1, context);
        }
            
        //
        // Restore the fifo state
        //
        REG_WR32(NV_PGRAPH_FIFO, fifo);
        
    }    
    return (RM_OK);
}

static RM_STATUS
_nvHalGrInitObjectContext_NV20(
    PHALHWINFO  pHalHwInfo,
    U032        instance,
    U032        classNum,
    U032        flags
)
{
    U032 ctx1, ctx2, ctx3;

    // default _CTX_SWITCH1 value
    ctx1 = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _GRCLASS, classNum)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, _SRCCOPY_AND)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _INVALID);    

    // Endian control for this object
    //
    // Turn on big endian if we're in big endian mode.
    // Also allow for an override specified in 'flags' passed in via NvAlloc()
    //
    switch ((flags & DRF_MASK(GR_ALLOC_ENDIAN_OVERRIDE)) >> DRF_SHIFT(GR_ALLOC_ENDIAN_OVERRIDE))
    {
        case GR_ALLOC_ENDIAN_OVERRIDE_NONE:
            if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
                ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _ENDIAN_MODE, _BIG);
            else
                ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _ENDIAN_MODE, _LITTLE);
            break;

        case GR_ALLOC_ENDIAN_OVERRIDE_BIG:
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _ENDIAN_MODE, _BIG);
            break;

        case GR_ALLOC_ENDIAN_OVERRIDE_LITTLE:
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _ENDIAN_MODE, _LITTLE);
            break;                
    }

    // default _CTX_SWITCH2 value
    ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _INVALID)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);

    // default _CTX_SWITCH3 value
    ctx3 = DRF_DEF(_PGRAPH, _CTX_SWITCH3, _DMA_INSTANCE_0, _INVALID)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH3, _DMA_INSTANCE_1, _INVALID);

    switch (classNum)
    {
        case NV01_CONTEXT_BETA:
        case NV01_CONTEXT_CLIP_RECTANGLE:
        case NV01_IMAGE_BLIT:
        case NV03_CONTEXT_ROP:
        case NV04_CONTEXT_SURFACES_2D:
        case NV03_DX3_TEXTURED_TRIANGLE:
        case NV04_CONTEXT_SURFACE_SWIZZLED:
        case NV04_CONTEXT_SURFACES_3D:
        case NV03_CONTEXT_SURFACE_2D_DESTINATION:
        case NV03_CONTEXT_SURFACE_2D_SOURCE:
        case NV03_CONTEXT_SURFACE_3D_COLOR:
        case NV03_CONTEXT_SURFACE_3D_DEPTH:
        case NV04_IMAGE_BLIT:
        case NV04_CONTEXT_BETA:
        case NV10_CONTEXT_SURFACES_2D:
        case NV10_CONTEXT_SURFACES_3D:
        case NV15_CONTEXT_SURFACE_SWIZZLED:
        case NV15_IMAGE_BLIT:
            // defaults are fine
            break;
        case NV20_IMAGE_BLIT:
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CLASS_TYPE, _PERFORMANCE);
            break;
        case NV01_CONTEXT_COLOR_KEY:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X16A8Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV01_CONTEXT_PATTERN:
        case NV04_CONTEXT_PATTERN:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _CGA6_M1)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X16A8Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV01_RENDER_SOLID_LIN:
        case NV01_RENDER_SOLID_TRIANGLE:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X24Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV01_IMAGE_FROM_CPU:
        case NV03_STRETCHED_IMAGE_FROM_CPU:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV1_NULL:
            //
            // The NULL object is really a pseudo-dma object, so it needs a valid
            // limit value and should also have the PAGE_TABLE_PRESENT bit set.
            //
            ctx1 |= SF_DEF(_DMA, _PAGE_TABLE, _PRESENT);
            ctx2 = 0xffffffff;
            //INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_1), 0xFFFFFFFF);
            //FLD_WR_ISF_DEF(instance, _DMA, _PAGE_TABLE, _PRESENT);
            break;
        case NV03_SCALED_IMAGE_FROM_MEMORY:
        case NV04_SCALED_IMAGE_FROM_MEMORY:
        case NV10_SCALED_IMAGE_FROM_MEMORY:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_A1R5G5B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV11_SCALED_IMAGE_FROM_MEMORY:
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CLASS_TYPE, _PERFORMANCE);
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_A1R5G5B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV04_DVD_SUBPICTURE:
        case NV10_DVD_SUBPICTURE:
            //
            // DVD class is patchless, so it is always considered valid.  HW doesn't
            // use this bit, but let's set it anyway to be consistent with other
            // objects
            //
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID);
            break;
        case NV03_MEMORY_TO_MEMORY_FORMAT:
            // Note that this object is always considered patch valid
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID);
            break;
        case NV04_GDI_RECTANGLE_TEXT:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _CGA6_M1)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X16R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV03_GDI_RECTANGLE_TEXT:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _CGA6_M1)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X24Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV04_CONTEXT_COLOR_KEY:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_A16R5G6