py( *pStore, pValue->pbData, pValue->cbData );
    (*pStore)[ pValue->cbData ] = '\0';

    *pFields = *pStore;

    *pStore += pValue->cbData + 1;
    *pLen += pValue->cbData + 1;

    return TRUE;
}


UINT DecodeNames(
                 IN PNAME_BLOB pNameBlob,
                 IN LPSTR* pFields,
                 IN LPSTR  pStore
                 )
{
    PNAME_INFO      pNameInfo = NULL;
    DWORD           cbNameInfo;
    PRDN_VALUE_BLOB pValue;
    UINT            l = 0;

    if (!DecodeObject(X509_ASN_ENCODING,
                      (LPCSTR)X509_NAME,
                      pNameBlob->pbData,
                      pNameBlob->cbData,
                      NULL,
                      &cbNameInfo))
    {
        goto Ret;
    }

    if (NULL == (pNameInfo = (PNAME_INFO)malloc(cbNameInfo)))
    {
        goto Ret;
    }
    if (!CertDecodeName(X509_ASN_ENCODING,
                        //(LPCSTR)X509_NAME,
                        pNameBlob->pbData,
                        pNameBlob->cbData,
                        pNameInfo,
                        &cbNameInfo))
    {
        goto Ret;
    }

    if (NULL == (pValue = CertGetNameField(X509_ASN_ENCODING,
                                           COUNTRY_NAME_OBJID,
                                           pNameInfo)))
    {
        goto Ret;
    }
    StoreField( pFields+IISMDB_INDEX_ISSUER_C, &pStore, &l, pValue );

    if (NULL == (pValue = CertGetNameField(X509_ASN_ENCODING,
                                           ORGANIZATION_NAME_OBJID,
                                           pNameInfo)))
    {
        goto Ret;
    }
    StoreField( pFields+IISMDB_INDEX_ISSUER_O, &pStore, &l, pValue );

    if (NULL == (pValue = CertGetNameField(X509_ASN_ENCODING,
                                           ORGANIZATIONAL_UNIT_NAME_OBJID,
                                           pNameInfo)))
    {
        goto Ret;
    }
    StoreField( pFields+IISMDB_INDEX_ISSUER_OU, &pStore, &l, pValue );

    if (NULL == (pValue = CertGetNameField(X509_ASN_ENCODING,
                                           COMMON_NAME_OBJID,
                                           pNameInfo)))
    {
        goto Ret;
    }
    StoreField( pFields+IISMDB_INDEX_ISSUER_C+1, &pStore, &l, pValue );

Ret:
    free(pNameInfo);
    return l;
}


UINT DecodeCert(
                       IN PBYTE pbEncodedCert,
                       IN DWORD cbEncodedCert,
                       LPSTR*   pFields,
                       LPSTR    pStore
                       )
{
    PCCERT_CONTEXT pCert = NULL;
    UINT l;

    if (NULL == (pCert = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                      pbEncodedCert,
                                                      cbEncodedCert)))
    {
        return 0;
    }

    l =  DecodeNames(&pCert->pCertInfo->Issuer, pFields, pStore )
             +
         DecodeNames(&pCert->pCertInfo->Subject, pFields+3, pStore );

    CertFreeCertificateContext( pCert );

    return l;
}
#endif

///////////////////////

//
//  Taken from NCSA HTTP and wwwlib.
//
//  NOTE: These conform to RFC1113, which is slightly different then the Unix
//        uuencode and uudecode!
//

const int _pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

const int _pr2six64[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,
    16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,
    40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
     0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr64[64] = {
    '`','!','"','#','$','%','&','\'','(',')','*','+',',',
    '-','.','/','0','1','2','3','4','5','6','7','8','9',
    ':',';','<','=','>','?','@','A','B','C','D','E','F',
    'G','H','I','J','K','L','M','N','O','P','Q','R','S',
    'T','U','V','W','X','Y','Z','[','\\',']','^','_'
};

BOOL IISuudecode(char   * bufcoded,
              BYTE   * bufout,
              DWORD  * pcbDecoded,
              BOOL     fBase64
             )
{
    int nbytesdecoded;
    char *bufin = bufcoded;
    int nprbytes;
    int *pr2six = (int*)(fBase64 ? _pr2six64 : _pr2six);
    int chL;

    /* Strip leading whitespace. */

    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++;

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */
    bufin = bufcoded;
    while(pr2six[*(bufin++)] <= 63);
    nprbytes = DIFF(bufin - bufcoded) - 1;
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    bufin = bufcoded;

    while (nprbytes > 0) {
        chL = bufin[2];
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(pr2six[chL] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;

    return TRUE;
}

//
// NOTE NOTE NOTE
// If the buffer length isn't a multiple of 3, we encode one extra byte beyond the
// end of the buffer. This garbage byte is stripped off by the uudecode code, but
// -IT HAS TO BE THERE- for uudecode to work. This applies not only our uudecode, but
// to every uudecode() function that is based on the lib-www distribution [probably
// a fairly large percentage of the code that's floating around out there].
//

BOOL IISuuencode( BYTE *   bufin,
               DWORD    nbytes,
               BYTE *   outptr,
               BOOL     fBase64 )
{
   unsigned int i;
   unsigned int iRemainder = 0;
   unsigned int iClosestMultOfThree = 0;
   char *six2pr = fBase64 ? _six2pr64 : _six2pr;
   BOOL fOneByteDiff = FALSE;
   BOOL fTwoByteDiff = FALSE;


   iRemainder = nbytes % 3; //also works for nbytes == 1, 2
   fOneByteDiff = (iRemainder == 1 ? TRUE : FALSE);
   fTwoByteDiff = (iRemainder == 2 ? TRUE : FALSE);
   iClosestMultOfThree = ((nbytes - iRemainder)/3) * 3 ;

   //
   // Encode bytes in buffer up to multiple of 3 that is closest to nbytes.
   //
   for (i=0; i< iClosestMultOfThree ; i += 3) {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];/*c3*/
      *(outptr++) = six2pr[bufin[2] & 077];         /* c4 */

      bufin += 3;
   }

   //
   // We deal with trailing bytes by pretending that the input buffer has been padded with
   // zeros. Expressions are thus the same as above, but the second half drops off b'cos
   // ( a | ( b & 0) ) = ( a | 0 ) = a
   //
   if (fOneByteDiff)
   {
       *(outptr++) = six2pr[*bufin >> 2]; /* c1 */
       *(outptr++) = six2pr[((*bufin << 4) & 060)]; /* c2 */

       //pad with '='
       *(outptr++) = '='; /* c3 */
       *(outptr++) = '='; /* c4 */
   }
   else if (fTwoByteDiff)
   {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074)];/*c3*/

      //pad with '='
       *(outptr++) = '='; /* c4 */
   }

   //encoded buffer must be zero-terminated
   *outptr = '\0';

   return TRUE;
}


#if 0

//
// Functions to create 1:1 mapping using issuer, subject to NT acct
//

static CIisCert11Mapper g_ExpCert11Mapper;
LONG g_fCert11Init = FALSE;

DWORD
MappingInit(
    VOID
    )
/*++

Routine Description:

    Initialize cert 1:1 mapping entry points

Arguments:

    None

Returns:

    0 if success, otherwise NT error code

--*/
{
    DWORD st = 0;
    BOOL fFirst;

    EnterCriticalSection( &g_csIisMap );
    if ( !g_fCert11Init )
    {
        st = g_ExpCert11Mapper.Init( &fFirst, FALSE ) ? 0 : ERROR_OPEN_FAILED;
        if ( !st )
        {
            st = g_ExpCert11Mapper.Load() ? 0 : GetLastError();
        }
        g_fCert11Init = TRUE;
    }
    LeaveCriticalSection( &g_csIisMap );

    return st;
}


BOOL
UnicodeToAnsi(
    LPWSTR pwsz,
    LPSTR* ppsz,
    LPDWORD pc )
/*++

Routine Description:

    Create ANSI version of Unicode string

Arguments:

    pwsz - ptr to Unicode string
    ppsz - updated with ptr to ANSI string, or NULL if error
    pc - updated with # of chars in converted string

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD dwW = wcslen( pwsz );
#if 1 // DBCS worst case
    DWORD dwS = dwW * 2;
#else
    DWORD dwS = dwW;
#endif
    LPSTR psz;

    if ( *ppsz = psz = (LPSTR)LocalAlloc( LMEM_FIXED, dwS + 1 ) )
    {
        dwS = WideCharToMultiByte( CP_ACP, 0,
                             pwsz, dwW,
                             psz, dwS,
                             NULL, NULL );
        psz[dwS] = '\0';
        *pc = dwS;
    }

    if ( dwS == 0 && dwW != 0 )
    {
        if ( psz )
        {
            LocalFree( psz );
            *ppsz = NULL;
        }
        return FALSE;
    }

    return TRUE;
}

#define UnicodeToAnsiFree( a ) {if ( (a)!=NULL ) LocalFree(a);}


DWORD WINAPI
CreateMapping(
    LPWSTR  pwszUuIssuer,
    LPWSTR  pwszUuSubject,
    LPWSTR  pwszNtAcct
    )
/*++

Routine Description:

    Create mapping for cert 1:1 mapper

Arguments:

    pwszUuIssuer - uuencoded Issuer
    pwszSubject - uuencoded Subject
    pwszNtAcct - NT account to map to

Returns:

    0 if success, otherwise NT error code

--*/
{
    DWORD st = 0;
    LPSTR pI;
    LPSTR pS;
    LPSTR pN;
    DWORD cI;
    DWORD cS;
    DWORD cN;

    if ( (st=MappingInit()) )
    {
        return st;
    }

    CIisMapping *pM = g_ExpCert11Mapper.CreateNewMapping();
    if ( !pM )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    UnicodeToAnsi( pwszUuIssuer, &pI, &cI );
    UnicodeToAnsi( pwszUuSubject, &pS, &cS );
    UnicodeToAnsi( pwszNtAcct, &pN, &cN );

    if ( pI != NULL && pS != NULL && pN != NULL )
    {
        pM->MappingSetField( IISMDB_INDEX_CERT11_ISSUER, pI, cI, TRUE );
        pM->MappingSetField( IISMDB_INDEX_CERT11_SUBJECT, pS, cS, TRUE );
        pM->MappingSetField( IISMDB_INDEX_CERT11_NT_ACCT, pN, cN, FALSE );

        if ( !g_ExpCert11Mapper.Add( pM ) )
        {
            st = GetLastError();;
        }
    }
    else
    {
        st = ERROR_NOT_ENOUGH_MEMORY;
    }

    UnicodeToAnsiFree( pI );
    UnicodeToAnsiFree( pS );
    UnicodeToAnsiFree( pN );

    return st;
}


DWORD WINAPI
CheckMapping(
    LPWSTR  pwszUuIssuer,
    LPWSTR  pwszUuSubject,
    LPWSTR* ppwszNtAcct          // Out
    )
/*++

Routine Description:

    Check if mapping exists for cert 1:1 mapper

Arguments:

    pwszUuIssuer - uuencoded Issuer
    pwszSubject - uuencoded Subject
    ppwszNtAcct - receive ptr to mapped NT account if exist
                  or NULL if any error
                  Must be released by a call to LocalFree()

Returns:

    0 if success, otherwise NT error code
    ERROR_INVALID_PARAMETER if no such mapping

--*/
{
    DWORD st = 0;
    LPSTR pI;
    LPSTR pS;
    DWORD cI;
    DWORD cS;
    LPWSTR  pwszNtAcct = NULL;

    if ( (st=MappingInit()) )
    {
        return st;
    }

    CIisMapping *pM = g_ExpCert11Mapper.CreateNewMapping();
    if ( !pM )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    UnicodeToAnsi( pwszUuIssuer, &pI, &cI );
    UnicodeToAnsi( pwszUuSubject, &pS, &cS );

    if ( pI != NULL && pS != NULL )
    {
        pM->MappingSetField( IISMDB_INDEX_CERT11_ISSUER, pI, cI, TRUE );
        pM->MappingSetField( IISMDB_INDEX_CERT11_SUBJECT, pS, cS, TRUE );

        DWORD iCurrent = 0xffffffff;
        CIisMapping* pMi;
        LPSTR pAcct;
        DWORD dwAcct;

        if ( !g_ExpCert11Mapper.FindMatch( pM, &pMi ) ||
             !pMi->MappingGetField( IISMDB_INDEX_CERT11_NT_ACCT, &pAcct, &dwAcct, FALSE )
             || pAcct == NULL )
        {
            st = ERROR_INVALID_PARAMETER;
        }
        else
        {
            DWORD dw;
            if ( !(pwszNtAcct = (LPWSTR)LocalAlloc( LMEM_FIXED,
                                                    (dwAcct+1)*sizeof(WCHAR) )) )
            {
                st = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                dw = MultiByteToWideChar( CP_ACP, 0,
                                          pAcct, dwAcct,
                                          pwszNtAcct, dwAcct );
                pwszNtAcct[dw] = L'\0';
                *ppwszNtAcct = pwszNtAcct;
            }
        }
    }
    else
    {
        st = ERROR_NOT_ENOUGH_MEMORY;
    }

    g_ExpCert11Mapper.DeleteMappingObject( pM );
    UnicodeToAnsiFree( pI );
    UnicodeToAnsiFree( pS );

    if ( st )
    {
        *ppwszNtAcct = NULL;
    }

    return st;
}


DWORD WINAPI
SaveMapping(
    VOID
    )
/*++

Routine Description:

    Save mappings for cert 1:1 mapper

Arguments:

    None

Returns:

    0 if success, otherwise NT error code
    ERROR_WRITE_FAULT if generic write error

--*/
{
    DWORD st = 0;

    if ( (st=MappingInit()) )
    {
        return st;
    }

    SetLastError( 0 );
    if ( !g_ExpCert11Mapper.Save() )
    {
        st = GetLastError();
        st =  st ? st : ERROR_WRITE_FAULT;
    }

    return st;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\acache.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
       acache.cxx

   Abstract:
       This module implements the Allocation cache handler and associated
        objects.

   Author:

       Murali R. Krishnan    ( MuraliK )     12-Sept-1996

   Environment:
       Win32 - User Mode

   Project:

       Internet Server DLL

   Functions Exported:



   Revision History:

--*/

// TODO:
// * (Debug only) Add guard blocks before and after each allocation to detect
//   under- and overruns.
// * (Debug only) Change the order of the freelist to FIFO (instead of
//   LIFO) to help catch cases of a block being free'd while something
//   else still points to it and then getting reused.

/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"

#include <acache.hxx>
#include <irtlmisc.h>

#define PRIVATE_HEAP

//
// # of CPUs in machine (for allocation threshold scaling)
//
DWORD g_cCPU = 1;

//
// specifies the registry location to use for getting the ATQ Configuration
//   (Global overrides)
//
CHAR g_PSZ_ACACHE_CONFIG_PARAMS_REG_KEY[] = ACACHE_REG_PARAMS_REG_KEY;

/************************************************************
 *    Inlined Documentation on Alloc-Cache
 *
 * Allocation Cache:
 *    This module is to cache the commonly allocated objects
 *    to serve following goals
 *      1) we can have maximum reuse of blocks
 *      2) avoid traffic to the process heap manager
 *      3) gather statistics for understanding of usage
 *
 * Details on Allocation Cache:
 *   There is one ALLOC_CACHE_HANDLER (shortly ACH) object per
 *   object that we decide to cache. The ACH is initialized by
 *   the configuration supplied during its construction. ACH serves
 *   as the main object for allocation/free of the objects it is created
 *   to cache. ACH gathers statistics of various operations and provides
 *   hooks to export the gathered statistics. There is a periodic cleanup
 *   scavenger that frees up long unused blocks thus reducing the working
 *   set of the system.
 *
 *   All ACH objects created are chained and maintained in the global
 *   list of allocation cache handler objects. This global list is used
 *   for enumeration, debugging, and statistics dumps
 *
 * Allocation cache Configuration:
 *
 *   Each ACH object is created with the ALLOC_CACHE_CONFIGURATION that
 *   specifies the (concurrency factor, threshold, size) desired.
 *   The concurrency factor ensures that we support the specified level
 *   of concurrency in allocations. The threshold specifies the number
 *   of objects that we will maintain (max) in the free-list. When the
 *   threshold is exceeded the freed objects are pushed to the process
 *   pool until the currently active objects fall below the threshold.
 *   In addition, each ACH object also retains a read-only name for the
 *   object allocated - for friendly tracking purposes.
 *
 *   There is also a global configuration parameter that specifies the
 *   Lookaside cleanup interval.
 *
 * Allocation and Free:
 *   Allocation allocates one free object from the free-list if any exist.
 *   Otherwise the allocation will result in fetching a new object from
 *   the process heap manager.
 *   A free adds the freed object to the free-list if the # free objects
 *   is less than the threshold specified. Otherwise the object is freed
 *   to the process heap manager.
 *   Statistics are gathered during both allocation and free operations.
 *
 * Statistics:
 *   Statistics are gathered during the alloc/free operations throughout
 *   the life-time of the ACH. These statistics are reported via the
 *   DumpStatsToHtml() exported function. The statistics can also be
 *   gathered by the NTSD helper function.
 *
 * Scheduled List cleanup:
 *   There is a scheduled work item for the lookaside cleanup interval.
 *   The callback function walks through the list of ACH items on global
 *   list and takes snapshot of the # allocation calls. On a subsequent
 *   walk-through, if the # allocation calls remains the same (which will
 *   be the case if there is no allocation activity), then, the entire
 *   list of alloced objects is pruned. This pruning reduces the working
 *   set of the process.
 ************************************************************/

/************************************************************
 *    Static Functions of ALLOC_CACHE_HANDLER
 ************************************************************/

CRITICAL_SECTION ALLOC_CACHE_HANDLER::sm_csItems;
LIST_ENTRY       ALLOC_CACHE_HANDLER::sm_lItemsHead;
DWORD            ALLOC_CACHE_HANDLER::sm_dwScheduleCookie = 0;
LONG             ALLOC_CACHE_HANDLER::sm_nFillPattern = 0xACA50000 ;


// This class is used to implement the free list.  We cast the free'd
// memory block to a CFreeList*.  The signature is used to guard against
// double deletion.  We also fill memory with a pattern.

class CFreeList
{
public:
    SINGLE_LIST_ENTRY Next;
    DWORD             dwSig;

    enum {
        FREESIG = (('A') | ('C' << 8) | ('a' << 16) | (('$' << 24) | 0x80)),
    };
};


/* class static */
BOOL
ALLOC_CACHE_HANDLER::Initialize(VOID)
{
    // get the number of processors for this machine
    // do it only for NT Server only (don't scale workstation)
    if ( TsIsNtServer() ) {
        SYSTEM_INFO si;
        GetSystemInfo( &si );
        g_cCPU = si.dwNumberOfProcessors;
    } else {
        g_cCPU = 1;
    }

    // initialize the class statics
    InitializeListHead( &sm_lItemsHead);
    INITIALIZE_CRITICAL_SECTION( &sm_csItems);
    
    return ( TRUE);
} // ALLOC_CACHE_HANDLER::Initialize()


/* class static */
BOOL
ALLOC_CACHE_HANDLER::Cleanup(VOID)
{
    DBG_ASSERT( sm_dwScheduleCookie == 0);

    DBG_ASSERT( IsListEmpty(&sm_lItemsHead));
    DeleteCriticalSection( &sm_csItems);

    return ( TRUE);

} // ALLOC_CACHE_HANDLER::Cleanup()


/* class static */
VOID
ALLOC_CACHE_HANDLER::InsertNewItem( IN ALLOC_CACHE_HANDLER * pach)
{
    EnterCriticalSection( &sm_csItems);

    InsertTailList( &sm_lItemsHead, &pach->m_lItemsEntry);
    LeaveCriticalSection( &sm_csItems);

    return;
} // ALLOC_CACHE_HANDLER::InsertNewItem()



/* class static */
VOID
ALLOC_CACHE_HANDLER::RemoveItem( IN ALLOC_CACHE_HANDLER * pach)
{
    EnterCriticalSection( &sm_csItems);

    RemoveEntryList( &pach->m_lItemsEntry);
    LeaveCriticalSection( &sm_csItems);

    return;
} // ALLOC_CACHE_HANDLER::RemoveItem()



/* class static */
BOOL
ALLOC_CACHE_HANDLER::DumpStatsToHtml(
   OUT CHAR * pchBuffer,
   IN OUT LPDWORD lpcchBuffer )
/*++
  Description:
    This function dumps the stats on all allocation cached objects
     to HTML format for diagnostics

  Arguments:
    pchBuffer - pointer to buffer that will contain the html results
    lpcchBuffer - pointer to DWORD containing the size of buffer on entry
               On return this contains the # of bytes written out to buffer

  Return:
    TRUE for success and FALSE for failure
    Look at GetLastError() for the error code.
--*/
{
    LIST_ENTRY  * pEntry;
    DWORD  iCount, cch;
    DWORD  cbTotalMem = 0;
    BOOL   fRet = TRUE;

    if ( (lpcchBuffer == NULL) ) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    EnterCriticalSection( &sm_csItems);

    if ( 300 < *lpcchBuffer ) {

        // Print the header blob
        cch = wsprintf( pchBuffer,
                        "\r\nAllocCacheTable Data <br>\r\n"
                        "<TABLE BORDER> <TR> "
                        "<TH> Item Name </TH> "
                        "<TH> Config(concurr, threshold, size) </TH> "
                        "<TH> # Total Items </TH> "
                        "<TH> # Alloc Calls </TH> "
                        "<TH> # Free Calls </TH> "
                        "<TH> # Free Entries </TH> "
                        "<TH> # Total Size (bytes) </TH> "
                        "<TH> Fill Pattern </TH> "
                        "<TH> Heap </TH> "
                        " </TR>\r\n"
                        );
    } else {
        cch = 300;
    }

    for ( pEntry = sm_lItemsHead.Flink, iCount = 0;
          pEntry != &sm_lItemsHead;
          pEntry = pEntry->Flink, iCount++
          ) {

        ALLOC_CACHE_HANDLER * pach =
            CONTAINING_RECORD( pEntry,
                               ALLOC_CACHE_HANDLER,
                               m_lItemsEntry
                               );

        cbTotalMem += pach->m_acConfig.cbSize * pach->m_nTotal;

        if ( (cch + 160 + strlen( pach->m_pszName)) < *lpcchBuffer) {
            cch += wsprintf( pchBuffer + cch,
                             " <TR> <TD> [%d] %s </TD>"
                             " <TD> (%d, %d, %d) </TD>"
                             " <TD> %4d </TD>"
                             " <TD> %4d </TD>"
                             " <TD> %4d </TD>"
                             " <TD> %4d </TD>"
                             " <TD> %4d </TD>"
                             " <TD> 0x%08lX </TD>"
                             " <TD> %p </TD>"
                             " </TR>\r\n"
                             ,
                             iCount, pach->m_pszName,
                             pach->m_acConfig.nConcurrency,
                             pach->m_acConfig.nThreshold,
                             pach->m_acConfig.cbSize,
                             pach->m_nTotal,
                             pach->m_nAllocCalls,
                             pach->m_nFreeCalls,
                             pach->m_nFreeEntries,
                             pach->m_acConfig.cbSize * pach->m_nTotal,
                             pach->m_nFillPattern,
                             pach->m_hHeap
                             );
        } else {
            cch += 160 + strlen( pach->m_pszName);
        }
    } // for

    LeaveCriticalSection( &sm_csItems);

    //
    // dump the final summary
    //
    if ( (cch + 100 ) < *lpcchBuffer) {
        cch += wsprintf( pchBuffer + cch,
                         " <b>"
                         " <TR> </TR>"
                         " <TR> <TD> Total </TD> <TD> </TD>"
                         " <TD> </TD>"
                         " <TD> </TD>"
                         " <TD> </TD>"
                         " <TD> </TD>"
                         " <TD> %4d </TD>"
                         " </TR>"
                         "</b>\r\n"
                         " </TABLE>\r\n\r\n"
                         ,
                         cbTotalMem
                         );
    } else {
        cch += 100;
    }

    if ( *lpcchBuffer < cch ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER);
        fRet = FALSE;
    }

    *lpcchBuffer = cch;

    return (fRet);
} // ALLOC_CACHE_HANDLER::DumpStatsToHtml()

extern "C"
BOOL AllocCacheDumpStatsToHtml( OUT CHAR * pch,
                                IN OUT LPDWORD lpcchBuff)
{
    return ( ALLOC_CACHE_HANDLER::DumpStatsToHtml( pch, lpcchBuff));
}

/* class static */
BOOL
ALLOC_CACHE_HANDLER::SetLookasideCleanupInterval( VOID )
{
    DWORD               dwError;
    DWORD               dwVal = 0;
    HKEY                hkey;

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            g_PSZ_ACACHE_CONFIG_PARAMS_REG_KEY,
                            0,
                            KEY_READ,
                            &hkey);

    if ( dwError == NO_ERROR ) {

        //
        // get the lookaside list cleanup period
        //

        dwVal = I_AtqReadRegDword( hkey,
                                   ACACHE_REG_LOOKASIDE_CLEANUP_INTERVAL,
                                   ACACHE_REG_DEFAULT_CLEANUP_INTERVAL );

        DBG_REQUIRE( !RegCloseKey( hkey ) );
    }

    if ( dwVal != 0 )
    {
        sm_dwScheduleCookie =
            ScheduleWorkItem( ALLOC_CACHE_HANDLER::CleanupAllLookasides,
                              NULL,
                              dwVal * 1000,
                              TRUE );

        if ( sm_dwScheduleCookie == 0 )
        {
            return FALSE;
        }
    }

    return TRUE;
} // ALLOC_CACHE_HANDLER::SetLookasideCleanupInterval()


/* class static */
BOOL
ALLOC_CACHE_HANDLER::ResetLookasideCleanupInterval( VOID )
{
    BOOL fReturn = TRUE;
    if ( sm_dwScheduleCookie )
    {
        fReturn = RemoveWorkItem( sm_dwScheduleCookie );
        if (fReturn) {
            sm_dwScheduleCookie = 0;
        }
    }

    return ( fReturn);
} // ALLOC_CACHE_HANDLER::ResetLookasideCleanupInterval()



/* class static */
VOID
WINAPI
ALLOC_CACHE_HANDLER::CleanupAllLookasides(
    IN PVOID            /* pvContext */
)
{
    LIST_ENTRY *        pEntry;

    EnterCriticalSection( &sm_csItems);

    for ( pEntry = sm_lItemsHead.Flink;
          pEntry != &sm_lItemsHead;
          pEntry = pEntry->Flink )
    {
        ALLOC_CACHE_HANDLER * pach =
            CONTAINING_RECORD( pEntry,
                               ALLOC_CACHE_HANDLER,
                               m_lItemsEntry
                               );

        IF_DEBUG( ALLOC_CACHE) {
            DBGPRINTF(( DBG_CONTEXT,
                         "Cleaning lookaside list for '%s' handler\n",
                         pach->m_pszName ));
        }

        pach->CleanupLookaside( FALSE );
    }

    LeaveCriticalSection( &sm_csItems);
} // ALLOC_CACHE_HANDLER::CleanupAllLookasides()




/************************************************************
 *    Member Functions of ALLOC_CACHE_HANDLER
 ************************************************************/

ALLOC_CACHE_HANDLER::ALLOC_CACHE_HANDLER(
    IN LPCSTR pszName,
    IN const ALLOC_CACHE_CONFIGURATION * pacConfig,
    IN BOOL fEnableCleanupAsserts /* = TRUE */
    )
    : m_fValid ( FALSE),
      m_nTotal       (0),
      m_nAllocCalls  (0),
      m_nFreeCalls   (0),
      m_nFreeEntries (0),
      m_pszName      (pszName),
      m_nLastAllocCount(0),
      m_hHeap        (NULL),
      m_fCleanupAssertsEnabled(fEnableCleanupAsserts)
{
    DBG_ASSERT( NULL != pacConfig );
    m_acConfig = *pacConfig;

    if ( pacConfig->nThreshold == INFINITE) {
        // this will be compared against a signed value. So be careful.
        m_acConfig.nThreshold = 0x7FFFFFFF;
    } else {
        // scale by the number of processors on MP machines
        m_acConfig.nThreshold *= g_cCPU;
    }

    // make sure the block is big enough to hold a CFreeList
    m_acConfig.cbSize = max(m_acConfig.cbSize, sizeof(CFreeList));
    // round up the block size to a multiple of the size of a LONG (for
    // the fill pattern in Free()).
    m_acConfig.cbSize = 
        (m_acConfig.cbSize + sizeof(LONG) - 1) & ~(sizeof(LONG) - 1);

    INITIALIZE_CRITICAL_SECTION( & m_csLock);

    m_lHead.Next = NULL;
    m_nFillPattern = InterlockedIncrement(&sm_nFillPattern);

    //
    // Create private heap
    //

#ifdef PRIVATE_HEAP
    if (TsIsNtServer())
        m_hHeap = HeapCreate( 0, 0, 0 );
    else
        m_hHeap = IisHeap();

    if( m_hHeap == NULL )
    {
        return;
    }
#endif

    ALLOC_CACHE_HANDLER::InsertNewItem( this);
    m_fValid = TRUE;
    return;
} // ALLOC_CACHE_HANDLER::ALLOC_CACHE_HANDLER()



ALLOC_CACHE_HANDLER::~ALLOC_CACHE_HANDLER(VOID)
{
    if ( m_fValid) {

        CleanupLookaside( TRUE );

        DeleteCriticalSection( & m_csLock);
        ALLOC_CACHE_HANDLER::RemoveItem( this);
        
#ifdef PRIVATE_HEAP
        if ( m_hHeap )
        {
            if (TsIsNtServer())
                DBG_REQUIRE( HeapDestroy( m_hHeap ) );
            m_hHeap = NULL;
        }
#endif
    }

    if (m_fCleanupAssertsEnabled) {
        DBG_ASSERT( 0 == m_nTotal );
        DBG_ASSERT( m_lHead.Next == NULL);
    }

    return;
} // ALLOC_CACHE_HANDLER::~ALLOC_CACHE_HANDLER()



VOID
ALLOC_CACHE_HANDLER::CleanupLookaside(
    IN BOOL             fForceCleanup
)
/*++
  Description:
    This function cleans up the lookaside list by removing excess storage space
    used by the objects allocated by this instance. This function is
    used by the periodic scavenging operation as well as for final cleanup.

  Arguments:
    fForceCleanup - forces a cleanup operation always.

  Returns:
     None
--*/
{
    if ( !fForceCleanup )
    {
        //
        // We are called for the regular scavenging operation
        // Take a snapshot of the # allocation calls so that
        //  we may cleanup space when services are idle.
        //

        IF_DEBUG( ALLOC_CACHE) {
            DBGPRINTF(( DBG_CONTEXT,
                         "AllocCalls = %ld, LastAllocCount = %ld\n",
                         m_nAllocCalls,
                         m_nLastAllocCount ));
        }

        if ( m_nAllocCalls != m_nLastAllocCount )
        {
            InterlockedExchange( &m_nLastAllocCount,
                                 m_nAllocCalls );
            return;
        }
    }

    SINGLE_LIST_ENTRY listHeadCopy;

    //
    // make a copy of the first element in the list inside the lock
    // Free the entire chain outside the locked section.
    // Otherwise on a busy system the threads will be waiting for
    //  this thread to complete
    //

    Lock();
    listHeadCopy.Next = m_lHead.Next;

    //
    // we are about to cleanup all entries -> so set state back properly.
    //
    m_lHead.Next      = NULL;
    m_nFreeEntries    = 0; // no more free-entries available
    Unlock();

    //
    // free up all the entries in the list
    //

    PSINGLE_LIST_ENTRY pl;
    pl = PopEntryList( &listHeadCopy);
    while ( pl != NULL) {

        InterlockedDecrement( &m_nTotal);
#ifdef PRIVATE_HEAP
        HeapFree( m_hHeap, 0, pl );
#else
        ::LocalFree(pl);
#endif
        pl = PopEntryList( &listHeadCopy);
    } // for

    DBG_ASSERT( listHeadCopy.Next == NULL);

    return;
} // ALLOC_CACHE_HANDLER::CleanupLookaside()



LPVOID
ALLOC_CACHE_HANDLER::Alloc( VOID )
{
    LPVOID pv = NULL;

    if ( m_nFreeEntries > 0) {

        //
        // There are free entries available - allocate from the free pool
        //

        // Only acquire the lock if there's potentially something to grab
        Lock();

        // Check again if the free entry is available.
        if ( m_nFreeEntries > 0) {
            pv = (LPVOID) PopEntryList( & m_lHead);  // get the real object
            m_nFreeEntries--;
        }

        Unlock();

        if ( NULL != pv ) {
            CFreeList* pfl = (CFreeList*) pv;
            // If the signature is wrong then somebody's been scribbling
            // on memory that they've freed
            DBG_ASSERT(pfl->dwSig == CFreeList::FREESIG);
            pfl->dwSig = 0; // clear; just in case caller never overwrites
        }
    }

    if ( NULL == pv) {

        //
        // No free entry. Need to alloc a new object.
        //
        
#ifdef PRIVATE_HEAP
        DBG_ASSERT( m_hHeap != NULL );

        pv = (LPVOID) HeapAlloc( m_hHeap,
                                 HEAP_ZERO_MEMORY,
                                 m_acConfig.cbSize );
#else
        pv = (LPVOID) LocalAlloc( LPTR, m_acConfig.cbSize );
#endif
        if ( NULL != pv) {
            // update counters
            InterlockedIncrement( &m_nTotal);
        }
    }

    if ( NULL != pv ) {
        InterlockedIncrement( &m_nAllocCalls);
    }

    return ( pv);
} // ALLOC_CACHE_HANDLER::Alloc()



BOOL
ALLOC_CACHE_HANDLER::Free( LPVOID pv)
{
    // Assume that this is allocated using the Alloc() function
    DBG_ASSERT( NULL != pv);

    // use a signature to check against double deletions
    CFreeList* pfl = (CFreeList*) pv;
    DBG_ASSERT(pfl->dwSig != CFreeList::FREESIG);

#ifdef _DEBUG
    // Fill the memory with an improbable pattern that is unique
    // to this allocator (for identification in the debugger)
    RtlFillMemoryUlong(pv, m_acConfig.cbSize, m_nFillPattern);
#else  // !_DEBUG
    // Start filling the space beyond the portion overlaid by the initial
    // CFreeList.  Fill at most 6 DWORDS.
    LONG* pl = (LONG*) (pfl+1);

    for (LONG cb = (LONG)min(6 * sizeof(LONG),m_acConfig.cbSize) - sizeof(CFreeList);
         cb > 0;
         cb -= sizeof(LONG))
    {
        *pl++ = m_nFillPattern;
    }
#endif // !_DEBUG

    // Now, set the signature
    pfl->dwSig = CFreeList::FREESIG;

    // store the items in the alloc cache.

    if ( m_nFreeEntries >= m_acConfig.nThreshold) {

        //
        // threshold for free entries is exceeded. free the object to
        //  process pool
        //
        
#ifdef PRIVATE_HEAP
        HeapFree( m_hHeap, 0, pv );
#else
        ::LocalFree(pv);
#endif

        InterlockedDecrement( &m_nTotal);
    } else {

        //
        // Store the given pointer in the single linear list
        //

        Lock();
        PushEntryList( &m_lHead,  &pfl->Next);
        m_nFreeEntries++;
        Unlock();
    }

    InterlockedIncrement( &m_nFreeCalls);

    return ( TRUE);
} // ALLOC_CACHE_HANDLER::Free()




VOID
ALLOC_CACHE_HANDLER::Print( VOID)
{
    CHAR  rgchBuffer[8192];
    DWORD cchBuffer = sizeof(rgchBuffer);

    DBG_REQUIRE( IpPrint( rgchBuffer, &cchBuffer));

    DBGDUMP(( DBG_CONTEXT, rgchBuffer));

    return;
} // ALLOC_CACHE_HANDLER::Print()



BOOL
ALLOC_CACHE_HANDLER::IpPrint( OUT CHAR * pchBuffer, IN OUT LPDWORD pcchSize)
{
    DWORD cchUsed;

    cchUsed = wsprintfA( pchBuffer,
                         "[%d]ALLOC_CACHE_HANDLER[%08p]. Config: "
                         " ObjSize = %d. Concurrency=%d. Thres=%d.\n"
                         " TotalObjs = %d. Calls: Alloc(%d), Free(%d)."
                         " FreeEntries = %d. FillPattern = 0x%08lX.\n"
                         ,
                         GetCurrentThreadId(),
                         this,
                         m_acConfig.cbSize,
                         m_acConfig.nConcurrency,
                         m_acConfig.nThreshold,
                         m_nTotal, m_nAllocCalls, m_nFreeCalls,
                         m_nFreeEntries, m_nFillPattern
                         );
    Lock();

    // NYI: Print the list of individual pointers
    Unlock();

    DBG_ASSERT( *pcchSize > cchUsed);
    *pcchSize = cchUsed;

    return (TRUE);
} // ALLOC_CACHE_HANDLER::IpPrint()



VOID
ALLOC_CACHE_HANDLER::QueryStats( IN ALLOC_CACHE_STATISTICS * pacStats )
{
    DBG_ASSERT( pacStats != NULL );

    pacStats->acConfig      = m_acConfig;
    pacStats->nTotal        = m_nTotal;
    pacStats->nAllocCalls   = m_nAllocCalls;
    pacStats->nFreeCalls    = m_nFreeCalls;
    pacStats->nFreeEntries  = m_nFreeEntries;

    return;
} // ALLOC_CACHE_HANDLER::QueryStats()


//
// Global functions
//


DWORD
I_AtqReadRegDword(
   IN HKEY     hkey,
   IN LPCSTR   pszValueName,
   IN DWORD    dwDefaultValue )
/*++

    NAME:       I_AtqReadRegDword

    SYNOPSIS:   Reads a DWORD value from the registry.

    ENTRY:      hkey - Openned registry key to read

                pszValueName - The name of the value.

                dwDefaultValue - The default value to use if the
                    value cannot be read.

    RETURNS     DWORD - The value from the registry, or dwDefaultValue.

--*/
{
    DWORD  err;
    DWORD  dwBuffer;

    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;

    if( hkey != NULL ) {
        err = RegQueryValueExA( hkey,
                               pszValueName,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

        if( ( err == NO_ERROR ) && ( dwType == REG_DWORD ) ) {
            dwDefaultValue = dwBuffer;
        }
    }

    return dwDefaultValue;

} // I_AtqReadRegDword()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\auxctrs.h ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       auxctrs.h

   Abstract:
       This module defines the auxiliary counters for Internet Common Services.

   Author:

       Murali R. Krishnan    ( MuraliK )    02-Apr-1996

   Environment:

       Windows NT - User Mode

   Project:

       Internet Services Common DLL

   Revision History:

--*/

# ifndef _IIS_AUX_COUNTERS_HXX_
# define _IIS_AUX_COUNTERS_HXX_

/************************************************************
 *     Include Headers
 ************************************************************/


/************************************************************
 *   Symbolic Definitions
 ************************************************************/

/*++
  Counters belong to two categories
  1. Active Counter - one that counts up and down
      It is expected that this counter consists of the current
      active items and hence this should not be wildly high, unless
      there are large # of counted objects.

  2. Cumulative Counters - counts values up and up
      This count value is used to measure the # of times event(s)
      related to this counter occurred.

  Naming Conventions:
   prefixes used are: Aac & Cac
   Aac - Active Auxiliary Counter
   Cac - Cumulative Auxiliary Counter
   Ac  - Auxiliar Counter

--*/

typedef enum  {   // Ac - stands for Aux Counters.

    CacBufferAllocs = 0,
    CacBufferFrees,
    CacBufferReallocs,

    CacBufferCons,         // constructed buffer class items
    CacBufferDest,         // destructed buffer class items

    CacBufferLT32,         // less than 32 byte allocs
    CacBufferGE32,         // >= 32

    CacCopyLT16,           // less than 16 byte allocs
    CacCopyGE16,           // >= 16

    CacStringCons,
    CacStringDest,

    CacStringCopy,
    CacStringAppend,

    CacMultiszCopy,
    CacMultiszAppend,

    AacSBMaxCounters                // sentinel counter
} ENUM_IIS_AUX_COUNTER;


# define NUM_AUX_COUNTERS    (AacSBMaxCounters)

#ifdef IIS_AUX_COUNTERS

//
// Macros for operating on these counters
//

# define AcIncrement( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ?  \
  InterlockedIncrement( g_SBAuxCounters+(acCounter)) : \
  0)

# define AcDecrement( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ?  \
  InterlockedDecrement( g_SBAuxCounters+(acCounter)) : \
  0)

# define AcCounter( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ? g_SBAuxCounters[acCounter] : 0)


extern LONG g_SBAuxCounters[];


# else // IIS_AUX_COUNTERS

# define AcIncrement( acCounter)       (0)    /* do nothing */
# define AcDecrement( acCounter)       (0)    /* do nothing */
# define AcCounter  ( acCounter)       (0)    /* do nothing */

#endif // IIS_AUX_COUNTERS


# endif // _IIS_AUX_COUNTERS_HXX_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\alloc.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    Alloc.h

Abstract:
    Custom heap allocator

   Author:
       George V. Reilly      (GeorgeRe)     Oct-1999

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:
       10/11/1999 - Initial

--*/

#ifndef __ALLOC_H__
#define __ALLOC_H__

#ifndef __IRTLMISC_H__
# include <irtlmisc.h>
#endif // !__IRTLMISC_H__

extern HANDLE g_hHeap;

BOOL
WINAPI
IisHeapInitialize();

VOID
WINAPI
IisHeapTerminate();


#endif // __ALLOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\buffer.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991-1996           **/
/**********************************************************************/

/*
    buffer.cxx
    Implementation of the BUFFER class.

    FILE HISTORY:
        MuraliK     3-July-1996 Rewrote the buffer class
*/

#include "precomp.hxx"

#include <buffer.hxx>
#include "dbgutil.h"

#include <auxctrs.h>

#include <irtlmisc.h>


LONG g_SBAuxCounters[NUM_AUX_COUNTERS];


BUFFER::~BUFFER(void)
{
    if ( IsDynAlloced())
    {
        /* INTRINSA suppress = all */
        ::IisFree( m_pb );
    }
}


/*******************************************************************

    NAME:       BUFFER::GetNewStorage

    SYNOPSIS:   Given an object with no allocated storage,
                allocate the initial memory.

    ENTRY:      cbRequested - amount of storage requested in bytes

    EXIT:       Either storage alloc'd, or error reported
                Sets m_cb, m_pb and m_fIsDynAlloced

    RETURNS:    TRUE if successful, FALSE for GetLastError()

    NOTES:
        Private member function.

********************************************************************/

BOOL
BUFFER::GetNewStorage( UINT cbRequested )
{
    AcIncrement( CacBufferAllocs);

    if ( cbRequested <= m_cb) {

        return TRUE;
    }

    DBG_ASSERT( !IsDynAlloced());  // otherwise I should free up the block :(
    m_pb = (BYTE*) ::IisMalloc( cbRequested );

    if ( !m_pb ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    } else {
        m_pb[0] = '\0'; // just store null
        m_cb = cbRequested;
        m_fIsDynAlloced = 1;
    }

    return (m_pb != NULL);
} // BUFFER::GetNewStorage()



/*******************************************************************

    NAME:       BUFFER::ReallocStorage

    SYNOPSIS:   Do a "hard" reallocation to the new size

    ENTRY:      cbNewRequested - new size, in bytes

    EXIT:       Storage realloc'd. m_pb, m_cb, m_fIsDynAlloced changed

    RETURNS:    TRUE if successful, FALSE for GetLastError()

********************************************************************/

BOOL
BUFFER::ReallocStorage( UINT cbNewRequested )
{
    if ( cbNewRequested <= m_cb) {

        return (TRUE);
    }

    BYTE* pb = (BYTE*) ((IsDynAlloced())
                        ? (::IisReAlloc(m_pb, cbNewRequested))
                        : (::IisMalloc(cbNewRequested))
                        );

    AcIncrement( CacBufferReallocs);

    if (pb == NULL)
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    if ( !IsDynAlloced()) {
        // First time this block is allocated. Copy over old contents.
        CopyMemory( pb, m_pb, m_cb);
        m_fIsDynAlloced = 1;
    }

    m_pb = pb;
    m_cb = cbNewRequested;

    DBG_ASSERT( m_pb != NULL );

    return TRUE;
} // BUFFER::ReallocStorage()



/*******************************************************************

    NAME:       BUFFER::VerifyState

    SYNOPSIS:   Verifies the state of the object.
                Asserts out if the state is invalid, i.e. if an
                internal error took place.

    NOTES:      This function does nothing in the retail version.

********************************************************************/

VOID BUFFER::VerifyState() const
{
    //
    //  1. If Dynamically Allocated ==>
    //       m_pb points to something other than m_rgb &
    //       m_cb > INLINED_BUFFER_LEN
    //  2. If not Dynamicall Allocated ==>
    //       (a)  it can be using user-supplied buffer & any sized
    //       (b)  it can be using inlined buffer & m_cb == INLINED_BUFFER_LEN
    //

    DBG_ASSERT(( IsDynAlloced() && (m_pb != m_rgb) &&
                 (m_cb > INLINED_BUFFER_LEN)) ||
               ( !IsDynAlloced() &&
                 ( m_pb != m_rgb || m_cb == INLINED_BUFFER_LEN)
                 )
               );

} // BUFFER::VerifyState()



/*******************************************************************

    NAME:       BUFFER::FreeMemory

    SYNOPSIS:   Frees the heap memory associated with this buffer object

********************************************************************/

VOID
BUFFER::FreeMemory(
    VOID
    )
{
    if ( IsDynAlloced()) {
        ::IisFree( m_pb );
        m_pb = m_rgb;
        m_cb = INLINED_BUFFER_LEN;
        m_fIsDynAlloced = 0;
    }

    m_rgb[0] = '\0';  // reset the contents
}



BOOL
BUFFER_CHAIN::AppendBuffer(
    BUFFER_CHAIN_ITEM * pBCI
    )
/*++

Routine Description:

    Adds a new buffer chain item to the end of the buffer chain

Arguments:

    pBCI - Chain item to append

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DBG_ASSERT( pBCI );
    DBG_ASSERT( pBCI->_ListEntry.Flink == NULL );

    InsertTailList( &_ListHead,
                    &pBCI->_ListEntry );

    return TRUE;
}



DWORD
BUFFER_CHAIN::DeleteChain(
    VOID
    )
/*++

Routine Description:

    Deletes all of the buffers in this chain

Return Value:

    Total number of allocated bytes freed by this call

--*/
{
    BUFFER_CHAIN_ITEM * pBCI;
    DWORD               cbFreed = 0;

    while ( !IsListEmpty( &_ListHead ))
    {
        pBCI = CONTAINING_RECORD( _ListHead.Flink,
                                  BUFFER_CHAIN_ITEM,
                                  _ListEntry );

        DBG_ASSERT( pBCI->_ListEntry.Flink != NULL );

        RemoveEntryList( &pBCI->_ListEntry );

        cbFreed += pBCI->QuerySize();

        delete pBCI;
    }

    return cbFreed;
}



BUFFER_CHAIN_ITEM *
BUFFER_CHAIN::NextBuffer(
    BUFFER_CHAIN_ITEM * pBCI
    )
/*++

Routine Description:

    Returns the next buffer in the chain.  Start the enumeration by
    passing pBCI as NULL.  Continue it by passing the return value

Arguments:

    pBCI - Previous item in enumeration

Return Value:

    Pointer to next item in chain, NULL when done

--*/
{
    if ( pBCI != NULL )
    {
        if ( pBCI->_ListEntry.Flink != &_ListHead )
        {
            return CONTAINING_RECORD( pBCI->_ListEntry.Flink,
                                      BUFFER_CHAIN_ITEM,
                                      _ListEntry );
        }
        else
        {
            return NULL;
        }
    }

    if ( !IsListEmpty( &_ListHead ))
    {
        return CONTAINING_RECORD( _ListHead.Flink,
                                  BUFFER_CHAIN_ITEM,
                                  _ListEntry );
    }

    return NULL;
}



DWORD
BUFFER_CHAIN::CalcTotalSize(
    BOOL fUsed
    ) const
/*++

Routine Description:

    Returns the total amount of memory allocated by this buffer chain
    excluding the size of the structures themselves


Arguments:

    fUsed - If FALSE, returns total allocated by chain, if TRUE returns
        total used by chain

Return Value:

    Total bytes allocated or total bytes used

--*/
{
    LIST_ENTRY *        pEntry;
    BUFFER_CHAIN_ITEM * pBCI;
    DWORD               cbRet = 0;

    for ( pEntry  = _ListHead.Flink;
          pEntry != &_ListHead;
          pEntry  = pEntry->Flink )
    {
        pBCI = CONTAINING_RECORD( pEntry, BUFFER_CHAIN_ITEM, _ListEntry );

        if ( fUsed == FALSE )
            cbRet += pBCI->QuerySize();
        else
            cbRet += pBCI->QueryUsed();
    }

    return cbRet;
}

/***************************** End Of File ******************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\datetime.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

      datetime.cxx

   Abstract:

      This module exports common functions for date and time fields,
      Expanding into strings and manipulation.

   Author:

           Murali R. Krishnan    ( MuraliK )    3-Jan-1995

--*/

#include "precomp.hxx"

#include <stdlib.h>
#include <pudebug.h>

# if !defined(dllexp)
# define dllexp __declspec( dllexport)
# endif

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT

#include <datetime.hxx>
#include <inetsvcs.h>

#include "date.hxx"


class dllexp CDateTime
{
public:
    FILETIME_UINT64 m_ftu;
    SYSTEMTIME      m_st;
    
    CDateTime()
    { /* do nothing */ }

    CDateTime(const SYSTEMTIME& rst)
    { SetTime(rst); }
      
    CDateTime(const FILETIME& rft)
    { SetTime(rft); }

    CDateTime(const FILETIME& rft, const SYSTEMTIME& rst)
    { m_ftu.ft = rft; m_st = rst; }
    
    BOOL
    GetCurrentTime()
    {
        GetSystemTimeAsFileTime(&m_ftu.ft);
        return FileTimeToSystemTime(&m_ftu.ft, &m_st);
    }

    BOOL
    SetTime(const SYSTEMTIME& rst)
    { m_st = rst; return SystemTimeToFileTime(&m_st, &m_ftu.ft); }

    BOOL
    SetTime(const FILETIME& rft)
    { m_ftu.ft = rft; return FileTimeToSystemTime(&m_ftu.ft, &m_st); }
};



static const CHAR  g_rgchTwoDigits[100][2] =
{
    { '0', '0' }, { '0', '1' }, { '0', '2' }, { '0', '3' }, { '0', '4' },
    { '0', '5' }, { '0', '6' }, { '0', '7' }, { '0', '8' }, { '0', '9' },

    { '1', '0' }, { '1', '1' }, { '1', '2' }, { '1', '3' }, { '1', '4' },
    { '1', '5' }, { '1', '6' }, { '1', '7' }, { '1', '8' }, { '1', '9' },

    { '2', '0' }, { '2', '1' }, { '2', '2' }, { '2', '3' }, { '2', '4' },
    { '2', '5' }, { '2', '6' }, { '2', '7' }, { '2', '8' }, { '2', '9' },

    { '3', '0' }, { '3', '1' }, { '3', '2' }, { '3', '3' }, { '3', '4' },
    { '3', '5' }, { '3', '6' }, { '3', '7' }, { '3', '8' }, { '3', '9' },

    { '4', '0' }, { '4', '1' }, { '4', '2' }, { '4', '3' }, { '4', '4' },
    { '4', '5' }, { '4', '6' }, { '4', '7' }, { '4', '8' }, { '4', '9' },

    { '5', '0' }, { '5', '1' }, { '5', '2' }, { '5', '3' }, { '5', '4' },
    { '5', '5' }, { '5', '6' }, { '5', '7' }, { '5', '8' }, { '5', '9' },

    { '6', '0' }, { '6', '1' }, { '6', '2' }, { '6', '3' }, { '6', '4' },
    { '6', '5' }, { '6', '6' }, { '6', '7' }, { '6', '8' }, { '6', '9' },

    { '7', '0' }, { '7', '1' }, { '7', '2' }, { '7', '3' }, { '7', '4' },
    { '7', '5' }, { '7', '6' }, { '7', '7' }, { '7', '8' }, { '7', '9' },

    { '8', '0' }, { '8', '1' }, { '8', '2' }, { '8', '3' }, { '8', '4' },
    { '8', '5' }, { '8', '6' }, { '8', '7' }, { '8', '8' }, { '8', '9' },

    { '9', '0' }, { '9', '1' }, { '9', '2' }, { '9', '3' }, { '9', '4' },
    { '9', '5' }, { '9', '6' }, { '9', '7' }, { '9', '8' }, { '9', '9' },
};


//
//  Constants
//

#define APPEND_STR(a,b)  \
    {CopyMemory(a,b,sizeof(b));  a += sizeof(b)-sizeof(CHAR);}

#define APPEND_PSZ( pszTail, psz )          \
    { DWORD cb = strlen( psz );             \
      CopyMemory( (pszTail), (psz), cb + 1 );\
      (pszTail) += cb;                      \
    }

//
// Makes a two-digit zero padded number (i.e., "23", or "05")
//

inline
VOID
AppendTwoDigits(
    CHAR*& rpszTail,
    DWORD Num
    )
{
    if ( Num < 100 )
    {
        rpszTail[0] = g_rgchTwoDigits[Num][0];
        rpszTail[1] = g_rgchTwoDigits[Num][1];
        rpszTail[2] = '\0';
        rpszTail += 2;
    }
    else
    {
        DBG_ASSERT(!"Num >= 100");
    }
}


//
// Years conversion
//


#define MAX_CACHED_YEARS 32
static DWORD g_nMinYear = 0, g_nMaxYear = 0;
static char  g_aszYears[MAX_CACHED_YEARS][4+1];

typedef CDataCache<CDateTime> CCacheTime;
static CCacheTime             g_ctCurrentTime;

void
InitializeDateTime()
{
    SYSTEMTIME    st;
    GetSystemTime(&st);

    g_nMinYear = st.wYear - MAX_CACHED_YEARS / 2;
    g_nMaxYear = g_nMinYear + MAX_CACHED_YEARS - 1;

    DBG_ASSERT(1000 <= g_nMinYear  &&  g_nMaxYear <= 9999);

    for (DWORD i = g_nMinYear;  i <= g_nMaxYear;  i++)
    {
        _itoa( i, g_aszYears[i - g_nMinYear], 10 );
    }

    CDateTime dt(st);
    g_ctCurrentTime.Write(dt);
}


void
TerminateDateTime()
{
    // nothing to be done, at least for now
}


inline
VOID
AppendYear(
    CHAR* &rpszTail,
    DWORD dwYear
    )
{
    DBG_ASSERT(g_nMinYear >= 1000);
    DWORD i = dwYear - g_nMinYear;
    
    if (i < MAX_CACHED_YEARS)
    {
        DBG_ASSERT(g_nMinYear <= dwYear  &&  dwYear <= g_nMaxYear);
        const char* pszYear = g_aszYears[i];
        *rpszTail++ = *pszYear++;
        *rpszTail++ = *pszYear++;
        *rpszTail++ = *pszYear++;
        *rpszTail++ = *pszYear++;
        *rpszTail = '\0';
    }
    else
    {
        CHAR  __ach[32];
        DBG_ASSERT( dwYear >= 1000 && dwYear <= 9999 );
        _itoa( dwYear, __ach, 10 );

        CopyMemory( rpszTail, __ach, 4+1 );
        rpszTail += 4;
    }
}


// Since ::GetSystemTime is relatively expensive (310 instructions) and
// ::GetSystemTimeAsFileTime is pretty cheap (20 instructions), we cache
// the SYSTEMTIME representation of the current time with an accuracy of
// 1.0 seconds.

BOOL
IISGetCurrentTime(
    OUT FILETIME*   pft,
    OUT SYSTEMTIME* pst)
{
    BOOL fUpdatedCachedTime = FALSE;
    CDateTime dt;
    
    while (! g_ctCurrentTime.Read(dt))
    {
        // empty loop
    }
    
    FILETIME_UINT64 ftu;
    GetSystemTimeAsFileTime(&ftu.ft);
    
    if (ftu.u64 - dt.m_ftu.u64 >= FILETIME_1_SECOND)
    {
#undef WT_INSTRUCTION_COUNTS
        
#ifndef WT_INSTRUCTION_COUNTS
        fUpdatedCachedTime = TRUE;
        dt.SetTime(ftu.ft);
        g_ctCurrentTime.Write(dt);
#endif
    }
    
    if (pft != NULL)
        *pft = dt.m_ftu.ft;
    if (pst != NULL)
        *pst = dt.m_st;

    return fUpdatedCachedTime;
}



/************************************************************
 *   Data
 ************************************************************/
static const TCHAR* s_rgchDays[] =  {
    TEXT("Sun"), TEXT("Mon"), TEXT("Tue"), TEXT("Wed"),
    TEXT("Thu"), TEXT("Fri"), TEXT("Sat")
};

static const TCHAR* s_rgchMonths[] = {
    TEXT("Jan"), TEXT("Feb"), TEXT("Mar"), TEXT("Apr"),
    TEXT("May"), TEXT("Jun"), TEXT("Jul"), TEXT("Aug"),
    TEXT("Sep"), TEXT("Oct"), TEXT("Nov"), TEXT("Dec")
};

LPCTSTR
DayOfWeek3CharNames(DWORD dwDayOfWeek)
{
    return s_rgchDays[dwDayOfWeek];
}

LPCTSTR
Month3CharNames(DWORD dwMonth)
{
    return s_rgchMonths[dwMonth];
}

// Custom hash table for make_month() for mapping "Apr" to 4
static const CHAR MonthIndexTable[64] = {
   -1,'A',  2, 12, -1, -1, -1,  8, // A to G
   -1, -1, -1, -1,  7, -1,'N', -1, // F to O
    9, -1,'R', -1, 10, -1, 11, -1, // P to W
   -1,  5, -1, -1, -1, -1, -1, -1, // X to Z
   -1,'A',  2, 12, -1, -1, -1,  8, // a to g
   -1, -1, -1, -1,  7, -1,'N', -1, // f to o
    9, -1,'R', -1, 10, -1, 11, -1, // p to w
   -1,  5, -1, -1, -1, -1, -1, -1  // x to z
};


static const BYTE TensDigit[10] = { 0, 10, 20, 30, 40, 50, 60, 70, 80, 90 };


/************************************************************
 *    Functions
 ************************************************************/

WORD
iis_2atoi(
    PCHAR s
    )
/*++

    Converts a 2 character string to integer

    Arguments:
        s   String to convert

    Returns:
        numeric equivalent, 0 on failure.
--*/
{

    DWORD tens = s[0] - '0';
    DWORD ones = s[1] - '0';

    if ( (tens <= 9) && (ones <= 9) ) {
        return((WORD)(TensDigit[tens] + ones));
    }
    return(0);
}

#if 1
WORD
make_month(
    PCHAR s
    )
{
    UCHAR monthIndex;
    UCHAR c;
    LPCTSTR monthString;

    //
    // use the third character as the index
    //

    c = (s[2] - 0x40) & 0x3F;

    monthIndex = MonthIndexTable[c];

    if ( monthIndex < 13 ) {
        goto verify;
    }

    //
    // ok, we need to look at the second character
    //

    if ( monthIndex == 'N' ) {

        //
        // we got an N which we need to resolve further
        //

        //
        // if s[1] is 'u' then Jun, if 'a' then Jan
        //

        if ( MonthIndexTable[(s[1]-0x40) & 0x3f] == 'A' ) {
            monthIndex = 1;
        } else {
            monthIndex = 6;
        }

    } else if ( monthIndex == 'R' ) {

        //
        // if s[1] is 'a' then March, if 'p' then April
        //

        if ( MonthIndexTable[(s[1]-0x40) & 0x3f] == 'A' ) {
            monthIndex = 3;
        } else {
            monthIndex = 4;
        }
    } else {
        goto error_exit;
    }

verify:

    monthString = s_rgchMonths[monthIndex-1];

    if ( (s[0] == monthString[0]) &&
         (s[1] == monthString[1]) &&
         (s[2] == monthString[2]) ) {

        return(monthIndex);

    } else if ( (toupper(s[0]) == monthString[0]) &&
                (tolower(s[1]) == monthString[1]) &&
                (tolower(s[2]) == monthString[2]) ) {

        return monthIndex;
    }

error_exit:
    return(0);

} // make_month
#else
int
make_month(
    TCHAR * s
    )
{
    int i;

    for (i=0; i<12; i++)
        if (!_strnicmp(s_rgchMonths[i], s, 3))
            return i + 1;
    return 0;
}
#endif

BOOL
SystemTimeToGMT(
    IN  const SYSTEMTIME & st,
    OUT CHAR *             pszBuff,
    IN  DWORD              cbBuff
    )
/*++
  Converts the given system time to string representation
  containing GMT Formatted String.

  Arguments:
      st         System time that needs to be converted.
      pstr       pointer to string which will contain the GMT time on
                  successful return.
      cbBuff     size of pszBuff in bytes

  Returns:
     TRUE on success.  FALSE on failure.

  History:
     MuraliK        3-Jan-1995
--*/
{
    DBG_ASSERT( pszBuff != NULL);

    if ( cbBuff < 40 ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    //
    //  Formats a string like: "Thu, 14 Jul 1994 15:26:05 GMT"
    //

    APPEND_PSZ( pszBuff, s_rgchDays[st.wDayOfWeek] );   // 0-based
    *pszBuff++ = ',';
    *pszBuff++ = ' ';
    AppendTwoDigits( pszBuff, st.wDay );
    *pszBuff++ = ' ';
    APPEND_PSZ( pszBuff, s_rgchMonths[st.wMonth - 1] ); // 1-based
    *pszBuff++ = ' ';
    AppendYear( pszBuff, st.wYear );
    *pszBuff++ = ' ';
    AppendTwoDigits( pszBuff, st.wHour );
    *pszBuff++ = ':';
    AppendTwoDigits( pszBuff, st.wMinute );
    *pszBuff++ = ':';
    AppendTwoDigits( pszBuff, st.wSecond );
    *pszBuff++ = ' ';
    *pszBuff++ = 'G';
    *pszBuff++ = 'M';
    *pszBuff++ = 'T';
    *pszBuff   = '\0';

    return ( TRUE);

} // SystemTimeToGMT()


BOOL
NtLargeIntegerTimeToLocalSystemTime(
    IN const LARGE_INTEGER * pliTime,
    OUT SYSTEMTIME * pst)
/*++
  Converts the time returned by NTIO apis ( which is a LARGE_INTEGER) into
  Win32 SystemTime in Local Time zone.

  Arguments:
    pliTime        pointer to large integer containing the time in NT format.
    pst            pointer to SYSTEMTIME structure which contains the time
                         fields on successful conversion.

  Returns:
    TRUE on success and FALSE on failure.

  History:

    MuraliK            27-Apr-1995

  Limitations:
     This is an NT specific function !! Reason is: Win32 uses FILETIME
      structure for times. However LARGE_INTEGER and FILETIME both use
      similar structure with one difference that is one has a LONG while
      other has a ULONG.
--*/
{
    FILETIME  ftLocal;

    if ( pliTime == NULL || pst == NULL) {

        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    //
    //  Convert the given large integer to local file time and
    //  then convert that to SYSTEMTIME.
    //   structure, containing the time details.
    //  I dont like this cast ( assumes too much about time structures)
    //   but again suitable methods are not available.
    //
    return (FileTimeToLocalFileTime((FILETIME *) pliTime,
                                     &ftLocal) &&
            FileTimeToSystemTime(&ftLocal, pst)
            );

} // NtLargeIntegerTimeToLocalSystemTime()


BOOL
SystemTimeToGMTEx(
    IN  const SYSTEMTIME & st,
    OUT CHAR *      pszBuff,
    IN  DWORD       cbBuff,
    IN  DWORD       csecOffset
    )
/*++
  Converts the given system time to string representation
  containing GMT Formatted String.

  Arguments:
      st         System time that needs to be converted.
      pstr       pointer to string which will contain the GMT time on
                  successful return.
      cbBuff     size of pszBuff in bytes
      csecOffset The number of seconds to offset the specified system time

  Returns:
     TRUE on success.  FALSE on failure.

  History:
     MuraliK        3-Jan-1995
--*/
{
    SYSTEMTIME    sttmp;
    DWORD         dwSeconds = 0;
    ULARGE_INTEGER liTime;
    FILETIME    ft;

    DBG_ASSERT( pszBuff != NULL);

    //
    //  If an offset is specified, calculate that now
    //

    if (!SystemTimeToFileTime( &st, &ft )) {
        return(FALSE);
    }

    liTime.HighPart = ft.dwHighDateTime;
    liTime.LowPart = ft.dwLowDateTime;

    //
    //  Nt Large integer times are stored in 100ns increments, so convert the
    //  second offset to 100ns increments then add it
    //

    liTime.QuadPart += ((ULONGLONG) csecOffset) * (ULONGLONG) FILETIME_1_SECOND;

    ft.dwHighDateTime = liTime.HighPart;
    ft.dwLowDateTime = liTime.LowPart;

    FileTimeToSystemTime( &ft, &sttmp );

    return SystemTimeToGMT( sttmp,
                            pszBuff,
                            cbBuff );
} // SystemTimeToGMTEx


BOOL
FileTimeToGMT(
    IN  const FILETIME   & ft,
    OUT CHAR *             pszBuff,
    IN  DWORD              cbBuff
    )
/*++
  Converts the given system time to string representation
  containing GMT Formatted String.

  Arguments:
      ft         File time that needs to be converted.
      pstr       pointer to string which will contain the GMT time on
                  successful return.
      cbBuff     size of pszBuff in bytes

  Returns:
     TRUE on success.  FALSE on failure.
--*/
{
    SYSTEMTIME st;

    if (FileTimeToSystemTime(&ft, &st))
        return SystemTimeToGMT(st, pszBuff, cbBuff);
    else
        return FALSE;
}


BOOL
FileTimeToGMTEx(
    IN  const FILETIME   & ft,
    OUT CHAR *             pszBuff,
    IN  DWORD              cbBuff,
    IN  DWORD              csecOffset
    )
/*++
  Converts the given system time to string representation
  containing GMT Formatted String.

  Arguments:
      ft         File time that needs to be converted.
      pstr       pointer to string which will contain the GMT time on
                  successful return.
      cbBuff     size of pszBuff in bytes
      csecOffset The number of seconds to offset the specified system time

  Returns:
     TRUE on success.  FALSE on failure.
--*/
{
    SYSTEMTIME    sttmp;
    DWORD         dwSeconds = 0;
    ULARGE_INTEGER liTime;

    DBG_ASSERT( pszBuff != NULL);

    liTime.HighPart = ft.dwHighDateTime;
    liTime.LowPart = ft.dwLowDateTime;

    //
    //  Nt Large integer times are stored in 100ns increments, so convert the
    //  second offset to 100ns increments then add it
    //

    liTime.QuadPart += ((ULONGLONG) csecOffset) * (ULONGLONG) FILETIME_1_SECOND;

    FILETIME ft2 = ft;
    ft2.dwHighDateTime = liTime.HighPart;
    ft2.dwLowDateTime = liTime.LowPart;

    FileTimeToSystemTime( &ft2, &sttmp );

    return SystemTimeToGMT( sttmp,
                            pszBuff,
                            cbBuff );
}

BOOL
NtLargeIntegerTimeToSystemTime(
    IN const LARGE_INTEGER & liTime,
    OUT SYSTEMTIME * pst)
/*++
  Converts the time returned by NTIO apis ( which is a LARGE_INTEGER) into
  Win32 SystemTime in GMT

  Arguments:
    liTime             large integer containing the time in NT format.
    pst                pointer to SYSTEMTIME structure which contains the time
                         fields on successful conversion.

  Returns:
    TRUE on success and FALSE on failure.

  History:

    MuraliK            3-Jan-1995

  Limitations:
     This is an NT specific function !! Reason is: Win32 uses FILETIME
      structure for times. However LARGE_INTEGER and FILETIME both use
      similar structure with one difference that is one has a LONG while
      other has a ULONG. Will that make a difference ? God knows.
       Or substitute whatever you want for God...
--*/
{
    FILETIME ft;

    if ( pst == NULL) {

        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    //
    // convert li to filetime
    //

    ft.dwLowDateTime = liTime.LowPart;
    ft.dwHighDateTime = liTime.HighPart;

    //
    // convert to system time
    //

    if (!FileTimeToSystemTime(&ft,pst)) {
        return(FALSE);
    }

    return ( TRUE);

} // NtLargeIntegerTimeToSystemTime()

BOOL
NtSystemTimeToLargeInteger(
    IN  const SYSTEMTIME * pst,
    OUT LARGE_INTEGER *    pli
    )
{

    FILETIME ft;

    //
    // Convert to file time
    //

    if ( !SystemTimeToFileTime( pst, &ft ) ) {
        return(FALSE);
    }

    //
    // Convert file time to large integer
    //

    pli->LowPart = ft.dwLowDateTime;
    pli->HighPart = ft.dwHighDateTime;

    return(TRUE);
}

BOOL
StringTimeToFileTime(
    IN  const TCHAR * pszTime,
    OUT LARGE_INTEGER * pliTime
    )
/*++

  Converts a string representation of a GMT time (three different
  varieties) to an NT representation of a file time.

  We handle the following variations:

    Sun, 06 Nov 1994 08:49:37 GMT   (RFC 822 updated by RFC 1123)
    Sunday, 06-Nov-94 08:49:37 GMT  (RFC 850)
    Sun Nov  6 08:49:37 1994        (ANSI C's asctime() format

  Arguments:
    pszTime             String representation of time field
    pliTime             large integer containing the time in NT format.

  Returns:
    TRUE on success and FALSE on failure.

  History:

    Johnl       24-Jan-1995     Modified from WWW library

--*/
{

    TCHAR * s;
    SYSTEMTIME    st;

    if (pszTime == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    st.wMilliseconds = 0;

    if ((s = strchr(pszTime, ','))) {

        DWORD len;

        //
        // Thursday, 10-Jun-93 01:29:59 GMT
        // or: Thu, 10 Jan 1993 01:29:59 GMT */
        //

        s++;

        while (*s && *s==' ') s++;
        len = strlen(s);

        if (len < 18) {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        if ( *(s+2) == '-' ) {        /* First format */

            st.wDay = (WORD) atoi(s);
            st.wMonth = (WORD) make_month(s+3);
            st.wYear = (WORD) atoi(s+7);
            st.wHour = (WORD) atoi(s+10);
            st.wMinute = (WORD) atoi(s+13);
            st.wSecond = (WORD) atoi(s+16);

        } else {                /* Second format */

            if (len < 20) {
                SetLastError( ERROR_INVALID_PARAMETER );
                return FALSE;
            }

            st.wDay = iis_2atoi(s);
            st.wMonth = make_month(s+3);
            st.wYear = iis_2atoi(s+7) * 100  +  iis_2atoi(s+9);
            st.wHour = iis_2atoi(s+12);
            st.wMinute = iis_2atoi(s+15);
            st.wSecond = iis_2atoi(s+18);

        }
    } else {    /* Try the other format:  Wed Jun  9 01:29:59 1993 GMT */

        s = (TCHAR *) pszTime;
        while (*s && *s==' ') s++;

        if ((int)strlen(s) < 24) {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        st.wDay = (WORD) atoi(s+8);
        st.wMonth = (WORD) make_month(s+4);
        st.wYear = (WORD) atoi(s+20);
        st.wHour = (WORD) atoi(s+11);
        st.wMinute = (WORD) atoi(s+14);
        st.wSecond = (WORD) atoi(s+17);
    }

    //
    //  Adjust for dates with only two digits
    //

    if ( st.wYear < 1000 ) {
        if ( st.wYear < 50 ) {
            st.wYear += 2000;
        } else {
            st.wYear += 1900;
        }
    }

    if ( !NtSystemTimeToLargeInteger( &st,pliTime )) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    return(TRUE);
}


/************************************************************
 *  Cached Date Time Formats
 *
 *  Formatting Date and Time for
 *    HTTP headers & Logging Requests
 *    is a costly operation.
 *  Using default NT Formatting operations with wsprintf()
 *    consumes about 6000 instructions/transaction
 *
 *  Following code addresses this issue by
 *   1) Caching formatted date/time pair for all purposes
 *   2) Caching is done at the granularity of seconds/minute
 *      If there is a match till seconds, we return entire
 *        formatted information.
 *      If there is a match till the minutes, then the seconds
 *        portion is over-written using a seconds-lookup-table.
 *
 *   Murali R. Krishnan (MuraliK)   23-Feb-1996
 ************************************************************/

//
// The delimiter string is :  <logDelimiterChar><blank>
// The delimiter char should be same as the one used for LOG_RECORD
//   in the file: ilogcls.cxx
//
const TCHAR G_PSZ_LOG_DELIMITER[3] = TEXT(", ");



#ifdef ENABLE_AUX_COUNTERS

# define CdtCountAccesses()  InterlockedIncrement( &m_nAccesses)
# define CdtCountMisses()    InterlockedIncrement( &m_nMisses)

# else  // ENABLE_AUX_COUNTERS

# define CdtCountAccesses()  /* do nothing */
# define CdtCountMisses()    /* do nothing */

# endif // ENABLE_AUX_COUNTERS






VOID
DATETIME_FORMAT_ENTRY::CopyFormattedData(
    IN const SYSTEMTIME * pst,
    OUT CHAR * pchDateTime) const
{
    //
    // copy the formatted date/time information
    //
    
    CopyMemory(pchDateTime,
               m_rgchDateTime,
               m_cbDateTime
               );
    
    if ( m_stDateTime.wSecond != pst->wSecond) {
        
        //
        // seconds do not match. update seconds portion alone
        //
        
        LPSTR pch = pchDateTime + m_cchOffsetSeconds;
        
        *pch       = g_rgchTwoDigits[pst->wSecond][0];
        *(pch + 1) = g_rgchTwoDigits[pst->wSecond][1];
    }
    
    return;
}



BOOL
CDFTCache::CopyFormattedData(
    IN const SYSTEMTIME * pst,
    OUT CHAR * pchDateTime) const
{
    // See <readmost.hxx> for an explanation of this routine
    const LONG nSequence = _ReadSequence();
    
    // Is the data being updated on another thread?
    if (nSequence != UPDATING)
    { 
        // The weird const_cast syntax is necessitated by the volatile
        // attribute on m_tData (DATETIME_FORMAT_ENTRY).
        LPCSTR pchDate = FormattedBuffer();
        DWORD cbDateTime = DateTimeChars();
        
        // Copy the string
        CopyMemory(pchDateTime, pchDate, cbDateTime);
        
        if (Seconds() != pst->wSecond) {
            
            //
            // seconds do not match. update seconds portion alone
            //
            
            LPSTR pch = pchDateTime + OffsetSeconds();
            
            *pch       = g_rgchTwoDigits[pst->wSecond][0];
            *(pch + 1) = g_rgchTwoDigits[pst->wSecond][1];
        }

        // If the sequence number is unchanged, the read was valid.
        const LONG nSequence2 = _ReadSequence();

        return (nSequence == nSequence2);
    }

    return FALSE;
}



VOID
ASCLOG_DATETIME_CACHE::GenerateDateTimeString(
    IN PDFT_ENTRY pdft,
    IN const SYSTEMTIME * pst
    )
/*++
  Description:

     This function generates the datetime formats for all predefined
      sequences. It attempts to generate the formatted date/time
      to the accuracy of a minute. If need be the seconds portion
      is obtained by indexing an array.

     This function should be called for a locked pdft entry,
     and the caller should make sure that the structures can be accessed
     freely for update

  Arguments:
     pst  - pointer to system time for which the datetime format is required

  Returns:
     None
--*/
{
    CHAR rgchTime[25];
    CHAR * pchDateTime;
    DWORD cchLen;

    DBG_ASSERT( pdft != NULL  &&  pst != NULL );


    //
    // Format date for Logging (dftLog)

    //  Format is:
    //      <Date><DelimiterString><Time><DelimiterString>
    //
    // We need to generate the date format again, only if it changes
    //

    pchDateTime = pdft->m_rgchDateTime;
    if ( !SameDate( &pdft->m_stDateTime, pst) ) {

        ::GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                     LOCALE_NOUSEROVERRIDE,
                                     pst, NULL,
                                     pchDateTime,
                                     15);

        lstrcat( pchDateTime, G_PSZ_LOG_DELIMITER);

        //
        // cache the date length for future use.
        //

        pdft->m_cchDateLen = lstrlen( pchDateTime);

    }

    cchLen = pdft->m_cchDateLen;

    //
    // format the time portion
    //

    ::GetTimeFormat( LOCALE_SYSTEM_DEFAULT,
                                 (LOCALE_NOUSEROVERRIDE |
                                  TIME_FORCE24HOURFORMAT|
                                  TIME_NOTIMEMARKER),
                                 pst, NULL,
                                 rgchTime, 15);

    DBG_ASSERT(lstrlen(rgchTime) + lstrlen( G_PSZ_LOG_DELIMITER) <
               sizeof(rgchTime));
    lstrcat( rgchTime, G_PSZ_LOG_DELIMITER);

    //
    // append time to date generated
    //

    DBG_ASSERT( cchLen > 0); // range is fine
    lstrcpy(pchDateTime + cchLen, rgchTime);

    DBG_ASSERT( lstrlen( pchDateTime) < sizeof( pdft->m_rgchDateTime));

    //
    // Calculate the offset for seconds based on time format.
    // the time is usually formatted as hh:mm:ss if wHour >= 10  Offset =6
    //       and is formatted as         h:mm:ss if wHour < 10   Offset =5
    //

    pdft->m_cchOffsetSeconds = ( cchLen + 5 + ((pst->wHour < 10) ? 0 : 1));

    //
    // !!! for the german locale, it's always hh:mm:ss
    //

    if ( pdft->m_rgchDateTime[pdft->m_cchOffsetSeconds] == ':' ) {
        pdft->m_cchOffsetSeconds++;
    }

    pdft->m_cbDateTime = lstrlen( pdft->m_rgchDateTime) + 1;
    DBG_ASSERT(pdft->m_cbDateTime <= MAX_FORMATTED_DATETIME_LEN);

    //
    // store the valid time now
    //

    pdft->m_stDateTime = *pst;

    return;

} // ASCLOG_DATETIME_CACHE::GenerateDateTimeString


VOID
EXTLOG_DATETIME_CACHE::GenerateDateTimeString(
    IN PDFT_ENTRY pdft,
    IN const SYSTEMTIME * pst
    )
/*++
  Description:

    Used for W3C Extended Logging format.
     This function generates the datetime formats for all predefined
      sequences. It attempts to generate the formatted date/time
      to the accuracy of a minute. If need be the seconds portion
      is obtained by indexing an array.

     This function should be called for a locked pdft entry,
     and the caller should make sure that the structures can be accessed
     freely for update

  Arguments:
     pst  - pointer to system time for which the datetime format is required

  Returns:
     None
--*/
{
    PCHAR pchDateTime;
    DWORD cchLen;

    DBG_ASSERT( pdft != NULL  &&  pst != NULL );

    //
    //  Format is:
    //      Date    YYYY-MM-DD
    //      Time    HH:MM:SS
    //

    pchDateTime = pdft->m_rgchDateTime;
    if ( !SameDate( &pdft->m_stDateTime, pst) ) {

        AppendYear( pchDateTime, pst->wYear );
        *pchDateTime++ = '-';
        AppendTwoDigits( pchDateTime, pst->wMonth );
        *pchDateTime++ = '-';
        AppendTwoDigits( pchDateTime, pst->wDay );

        //
        // cache the date length for future use.
        //

        pchDateTime++;
        pdft->m_cchDateLen = lstrlen( pdft->m_rgchDateTime );
        DBG_ASSERT( pdft->m_cchDateLen == 10 );

    } else {

        DBG_ASSERT( pdft->m_cchDateLen == 10 );
        pchDateTime += (pdft->m_cchDateLen+1);
    }

    cchLen = pdft->m_cchDateLen;

    //
    // format the time portion
    //

    AppendTwoDigits( pchDateTime, pst->wHour );
    *pchDateTime++ = ':';
    AppendTwoDigits( pchDateTime, pst->wMinute );
    *pchDateTime++ = ':';
    AppendTwoDigits( pchDateTime, pst->wSecond );
    pchDateTime++;

    //
    // Calculate the offset for seconds based on time format.
    // YYYY-MM-DD HH:MM:SS
    //

    pdft->m_cchOffsetSeconds = cchLen + 7;
    pdft->m_cbDateTime = DIFF(pchDateTime - (PCHAR)pdft->m_rgchDateTime);
    DBG_ASSERT(pdft->m_cbDateTime <= MAX_FORMATTED_DATETIME_LEN);

    //
    // store the valid time now
    //

    pdft->m_stDateTime = *pst;

    return;

} // EXTLOG_DATETIME_CACHE::GenerateDateTimeString



VOID
W3_DATETIME_CACHE::GenerateDateTimeString(
    IN PDFT_ENTRY pdft,
    IN const SYSTEMTIME * pst
    )
/*++
  Description:

     This function generates the datetime formats for all predefined
      sequences. It attempts to generate the formatted date/time
      to the accuracy of a minute. If need be the seconds portion
      is obtained by indexing an array.

     This function should be called for a locked pdft entry,
     and the caller should make sure that the structures can be accessed
     freely for update

  Arguments:
     pst  - pointer to system time for which the datetime format is required

  Returns:
     None
--*/
{
    CHAR  rgchTime[25];
    PCHAR pchDateTime;
    DWORD cchLen;

    DBG_ASSERT( pdft != NULL  &&  pst != NULL );

    //
    // Format date for Logging (dftGmt)
    //  Format is:
    //   Date: <date-time> GMT\r\n
    //

    pchDateTime = pdft->m_rgchDateTime;

    static const char szDate[] = "Date: ";
    static const char szCRLF[] = "\r\n";

    CopyMemory( pchDateTime, szDate, sizeof(szDate) - 1 );
    pchDateTime += sizeof(szDate) - 1;

    if ( !::SystemTimeToGMT( *pst,
                       pchDateTime,
                       sizeof(pdft->m_rgchDateTime)
                         - sizeof( szDate) - sizeof(szCRLF) + 1 ) )
    {
        pdft->m_rgchDateTime[0] = '\0';
    } else {

        pchDateTime += lstrlen( pchDateTime );

        pdft->m_cchOffsetSeconds =
                DIFF(pchDateTime - pdft->m_rgchDateTime)
                - 2         // minus 2 digits for seconds
                - 4;        // minus " GMT"

        pdft->m_cchDateLen = pdft->m_cchOffsetSeconds 
                - 7;        // minus " hh:mm:"

        CopyMemory( pchDateTime, szCRLF, sizeof(szCRLF) );
    }

    pdft->m_cbDateTime = ( lstrlen( pdft->m_rgchDateTime ) + 1);
    DBG_ASSERT(pdft->m_cbDateTime <= MAX_FORMATTED_DATETIME_LEN);

    //
    // store the valid time now
    //

    pdft->m_stDateTime = *pst;

    return;

} // W3_DATETIME_CACHE::GenerateDateTimeString




CACHED_DATETIME_FORMATS::CACHED_DATETIME_FORMATS( VOID )
    :
#if ENABLE_AUX_COUNTERS
    m_nMisses       ( 0),
    m_nAccesses     ( 0),
#endif // ENABLE_AUX_COUNTERS
    m_idftCurrent   ( 0)
{
    DATETIME_FORMAT_ENTRY dft;
    ZeroMemory( &dft, sizeof(dft));
    for (int i = 0;  i < CACHE_SIZE;  i++)
    {
        m_rgDateTimes[i].Write(dft);
    }
}



DWORD
CACHED_DATETIME_FORMATS::GetFormattedDateTime(
    IN const SYSTEMTIME * pst,
    OUT TCHAR * pchDateTime
    )
/*++
  This function obtains formatted string for date specified in *pst.

  It uses a cache to do lookup for the formatted date and time.

  If all entries fail, then it calls the Formatting functions to
    generate a new format.

  It has been experimentally determined that the cost of formatting is too
    high and hence we resort to caching and this comprehensive lookup function.

  Also this function is NOT a GENERAL PURPOSE DATE-FORMAT cacher.
   We cache with the ASSUMPTION that the date format requests will be for
   consecutive time intervals.

  Arguments:
    pst   - pointer to SYSTEMTIME
    pchDateTime - pointer to character buffer into which the formatted
                     date will be copied.

  Returns:
    Length of string (excluding the NULL terminator)

--*/
{
    DBG_ASSERT( pst != NULL && pchDateTime != NULL);

    CdtCountAccesses();
    
    CDFTCache* pdft;
    LONG i = m_idftCurrent + CACHE_SIZE; // modulo operation in loop
                                        //   => start at m_idftCurrent

    // m_rgDateTimes is a circular buffer of CDFTCaches.  The current entry
    // is pointed to by m_idftCurrent.  The second-most recent entry is at
    // (m_idftCurrent - 1) % CACHE_SIZE.  Etc.
    for (int j = CACHE_SIZE  ;  --j >= 0;  i--)
    {
        pdft = &m_rgDateTimes[i & CACHE_MASK];
        
        if (pdft->IsHit(pst)
            &&  pdft->CopyFormattedData(pst, pchDateTime))
        {
            return pdft->DateTimeChars() - 1;
        }
    }
    
    // Not found in cache?  Then generate the time string and add it
    DATETIME_FORMAT_ENTRY dft;
    dft.m_stDateTime.wYear = 0; // invalid date

    GenerateDateTimeString(&dft, pst);
    i = InterlockedIncrement(const_cast<LONG*>(&m_idftCurrent));
    pdft = &m_rgDateTimes[i & CACHE_MASK];
    pdft->Write(dft);

    CdtCountMisses();

    //
    // The date time format is valid. Copy formatted date time.  It is 
    // assumed that the buffer has sufficient space for the formatted date
    //

    dft.CopyFormattedData(pst, pchDateTime);
    return dft.m_cbDateTime - 1;
} // CACHED_DATETIME_FORMATS::GetFormattedDateTime()



DWORD
CACHED_DATETIME_FORMATS::GetFormattedCurrentDateTime(
    OUT PCHAR pchDateTime
    )
{
    DBG_ASSERT(pchDateTime != NULL);
    SYSTEMTIME st;
    IISGetCurrentTimeAsSystemTime(&st);
    return GetFormattedDateTime(&st, pchDateTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\dbgutil.h ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to
      modify for each application the accompanying pgmutils.dll is used.

   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable
// begin_user_unmodifiable



/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants
//

# define DEBUG_ALLOC_CACHE          0x01000000
# define DEBUG_SCHED                0x02000000
# define DEBUG_RESOURCE             0x04000000

// Use the default constants from pudebug.h

# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\dllmain.cpp ===
// DllMain

#include "precomp.hxx"

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <irtldbg.h>
#include <lkrhash.h>
#include <inetinfo.h>
#include "sched.hxx"
#include "date.hxx"
#include "alloc.h"

#undef SMALL_BLOCK_HEAP

#ifdef SMALL_BLOCK_HEAP
# include <malloc.h>
#endif

/////////////////////////////////////////////////////////////////////////////
// Globals


#ifndef _NO_TRACING_
#include <initguid.h>
#ifndef _EXEXPRESS
DEFINE_GUID(IisRtlGuid, 
0x784d8900, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DEFINE_GUID(IisKRtlGuid,
0x784d8912, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#endif

// NOTE: It is very important to remember that anything that needs to be 
// initialized here also needs to be initialized in the main of iisrtl2!!!
extern "C" CRITICAL_SECTION g_csGuidList;
extern "C" LIST_ENTRY g_pGuidList;
extern "C" DWORD g_dwSequenceNumber;

#else // _NO_TRACING
DECLARE_DEBUG_VARIABLE();
#endif // _NO_TRACING

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();

// HKLM\System\CurrentControlSet\Services\InetInfo\IISRTL\DebugFlags
const CHAR g_pszIisRtlRegLocation[] =
    INET_INFO_PARAMETERS_KEY TEXT("\\IISRTL");


#undef ALWAYS_CLEANUP



/////////////////////////////////////////////////////////////////////////////
// Additional initialization needed.  The shutdown of the scheduler threads
// in DLLMain has caused us some considerable grief.

int              g_cRefs;
CRITICAL_SECTION g_csInit;

BOOL
WINAPI 
InitializeIISRTL()
{
    BOOL fReturn = TRUE;  // ok

    EnterCriticalSection(&g_csInit);

    IF_DEBUG(INIT_CLEAN)
        DBGPRINTF((DBG_CONTEXT, "InitializeIISRTL, %d %s\n",
                   g_cRefs, (g_cRefs == 0 ? "initializing" : "")));

    if (g_cRefs++ == 0)
    {
        if (SchedulerInitialize())
        {
            DBG_REQUIRE(ALLOC_CACHE_HANDLER::SetLookasideCleanupInterval());
        
            IF_DEBUG(INIT_CLEAN)
                DBGPRINTF((DBG_CONTEXT, "Scheduler Initialized\n"));
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT, "Initializing Scheduler Failed\n"));
            fReturn = FALSE;
        }
    }

    LeaveCriticalSection(&g_csInit);

    return fReturn;
}



/////////////////////////////////////////////////////////////////////////////
// Additional termination needed

void
WINAPI 
TerminateIISRTL()
{
    EnterCriticalSection(&g_csInit);

    IF_DEBUG(INIT_CLEAN)
        DBGPRINTF((DBG_CONTEXT, "TerminateIISRTL, %d %s\n",
                   g_cRefs, (g_cRefs == 1 ? "Uninitializing" : "")));

    if (--g_cRefs == 0)
    {
        DBG_REQUIRE(ALLOC_CACHE_HANDLER::ResetLookasideCleanupInterval());
    
        SchedulerTerminate();
    }

    LeaveCriticalSection(&g_csInit);
}



/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
// Note: any changes here probably also need to go into ..\iisrtl2\main.cxx

extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD     dwReason,
    LPVOID    lpvReserved)
{
    BOOL  fReturn = TRUE;  // ok

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);

#ifdef SMALL_BLOCK_HEAP
        // _set_sbh_threshold(480);    // VC5
        _set_sbh_threshold(1016);   // VC6
#endif

        g_cRefs = 0;
        INITIALIZE_CRITICAL_SECTION(&g_csInit);

        IisHeapInitialize();

        InitializeStringFunctions();

        IRTL_DEBUG_INIT();

#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT("iisrtl");
#else
        // These initializations MUST always be before the CREATE_DEBUG_PRINT_OBJECT
        InitializeListHead(&g_pGuidList);
        InitializeCriticalSection(&g_csGuidList);

#ifndef _EXEXPRESS
        CREATE_DEBUG_PRINT_OBJECT("iisrtl", IisRtlGuid);
#else
        CREATE_DEBUG_PRINT_OBJECT("kisrtl", IisKRtlGuid);
#endif
#endif
        if (!VALID_DEBUG_PRINT_OBJECT()) {
            return (FALSE);
        }

#ifdef _NO_TRACING_
        LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszIisRtlRegLocation, DEBUG_ERROR );
#endif

        IF_DEBUG(INIT_CLEAN)
            DBGPRINTF((DBG_CONTEXT, "IISRTL::DllMain::DLL_PROCESS_ATTACH\n"));

        //
        // Initialize the platform type
        //
        INITIALIZE_PLATFORM_TYPE();
        IRTLASSERT(IISIsValidPlatform());

        InitializeSecondsTimer();
        InitializeDateTime();

        DBG_REQUIRE(ALLOC_CACHE_HANDLER::Initialize());
        IF_DEBUG(INIT_CLEAN) {
            DBGPRINTF((DBG_CONTEXT, "Alloc Cache initialized\n"));
        }

        fReturn = LKRHashTableInit();

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
#ifndef ALWAYS_CLEANUP
        if (lpvReserved == NULL)
#endif
        {
            //
            //  Only Cleanup if there is a FreeLibrary() call.
            //

            IF_DEBUG(INIT_CLEAN)
                DBGPRINTF((DBG_CONTEXT,
                           "IISRTL::DllMain::DLL_PROCESS_DETACH\n"));

            if (g_cRefs != 0)
                DBGPRINTF((DBG_CONTEXT, "iisrtl!g_cRefs = %d\n", g_cRefs));
            
            LKRHashTableUninit();

            DBG_REQUIRE(ALLOC_CACHE_HANDLER::Cleanup());

            TerminateDateTime();
            TerminateSecondsTimer();
            
            DELETE_DEBUG_PRINT_OBJECT();
            
#ifndef _NO_TRACING_
            // This delete MUST always be after the DELETE_DEBUG_PRINT_OBJECT
            DeleteCriticalSection(&g_csGuidList);
#endif

            IRTL_DEBUG_TERM();

            IisHeapTerminate();

            DeleteCriticalSection(&g_csInit);
        }
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\aucommon.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    aucommon.cxx

    Common routines for ANSI/UNICODE classes.


    FILE HISTORY:
    5/21/97      michth      created

*/
#include "precomp.hxx"
#include "aucommon.hxx"

int
ConvertMultiByteToUnicode(LPSTR pszSrcAnsiString,
                          BUFFER *pbufDstUnicodeString,
                          DWORD dwStringLen)
{
    DBG_ASSERT(pszSrcAnsiString != NULL);
    int iStrLen = -1;
    BOOL bTemp;

    bTemp = pbufDstUnicodeString->Resize((dwStringLen + 1) * sizeof(WCHAR));
    if (bTemp) {
        iStrLen = MultiByteToWideChar(CP_ACP,
                                      MB_PRECOMPOSED,
                                      pszSrcAnsiString,
                                      dwStringLen + 1,
                                      (LPWSTR)pbufDstUnicodeString->QueryPtr(),
                                      (int)pbufDstUnicodeString->QuerySize());
        if (iStrLen == 0) {
            DBG_ASSERT(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
            iStrLen = -1;
        }
        else {
            //
            // Don't count '\0'
            //
            iStrLen--;
        }


    }
    return iStrLen;
}

int
ConvertUnicodeToMultiByte(LPWSTR pszSrcUnicodeString,
                          BUFFER *pbufDstAnsiString,
                          DWORD dwStringLen)
{
    DBG_ASSERT(pszSrcUnicodeString != NULL);
    BOOL bTemp;
    int iStrLen = 0;

    iStrLen = WideCharToMultiByte(CP_ACP,
                                  0,
                                  pszSrcUnicodeString,
                                  dwStringLen + 1,
                                  (LPSTR)pbufDstAnsiString->QueryPtr(),
                                  (int)pbufDstAnsiString->QuerySize(),
                                  NULL,
                                  NULL);
    if ((iStrLen == 0) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        iStrLen = WideCharToMultiByte(CP_ACP,
                                      0,
                                      pszSrcUnicodeString,
                                      dwStringLen + 1,
                                      NULL,
                                      0,
                                      NULL,
                                      NULL);
        if (iStrLen != 0) {
            bTemp = pbufDstAnsiString->Resize(iStrLen);
            if (!bTemp) {
                iStrLen = 0;
            }
            else {
                iStrLen = WideCharToMultiByte(CP_ACP,
                                              0,
                                              pszSrcUnicodeString,
                                              dwStringLen + 1,
                                              (LPSTR)pbufDstAnsiString->QueryPtr(),
                                              (int)pbufDstAnsiString->QuerySize(),
                                              NULL,
                                              NULL);
            }

        }
    }
    //
    // Don't count '\0'
    // and convert 0 to -1 for errors
    //
    iStrLen--;
    return iStrLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\gip.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Global Interface Pointer API support

File: Gip.cpp

Owner: DmitryR

This is the GIP source file.
===================================================================*/

#include "precomp.hxx"

#include <gip.h>

/*===================================================================
  Globals
===================================================================*/

CGlobalInterfaceAPI g_GIPAPI;

/*===================================================================
  C  G l o b a l  I n t e r f a c e  A P I
===================================================================*/

/*===================================================================
CGlobalInterfaceAPI::CGlobalInterfaceAPI

CGlobalInterfaceAPI constructor

Parameters:

Returns:
===================================================================*/	
CGlobalInterfaceAPI::CGlobalInterfaceAPI() 
    : m_fInited(FALSE), m_pGIT(NULL)
{
}
    
/*===================================================================
CGlobalInterfaceAPI::~CGlobalInterfaceAPI

CGlobalInterfaceAPI destructor

Parameters:

Returns:
===================================================================*/	
CGlobalInterfaceAPI::~CGlobalInterfaceAPI()
{
    UnInit();
}

/*===================================================================
CGlobalInterfaceAPI::Init

Creates instance of GlobalInterfaceTable

Parameters:

Returns:
    HRESULT
===================================================================*/	
HRESULT CGlobalInterfaceAPI::Init()
{
    IRTLASSERT(!m_fInited); // don't init twice
    
    HRESULT hr = CoCreateInstance
        (
        CLSID_StdGlobalInterfaceTable,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IGlobalInterfaceTable,
        (void **)&m_pGIT
        );
        
    if (SUCCEEDED(hr))
        m_fInited = TRUE;
    else
        m_pGIT = NULL;

    return hr;
}

/*===================================================================
CGlobalInterfaceAPI::UnInit

Releases instance of GlobalInterfaceTable

Parameters:

Returns:
    HRESULT (NOERROR)
===================================================================*/	
HRESULT CGlobalInterfaceAPI::UnInit()
{
    if (m_pGIT)
    {
        m_pGIT->Release();
        m_pGIT = NULL;
    }
    
    m_fInited = FALSE;
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\eventlog.cxx ===
/*++

   Copyright    (c)    1996-1997        Microsoft Corporation

   Module Name:
        eventlog.cxx

   Abstract:

        This module defines the generic class for logging events.


   Author:

        Murali R. Krishnan    (MuraliK)    28-Sept-1994

   Depends Upon:
        Internet Services Platform Library (isplat.lib)
        Internet Services Debugging Library (isdebug.lib)

--*/

#include "precomp.hxx"

//
//  Include Headers
//

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT

# include <isplat.h>
# include <dbgutil.h>
# include <eventlog.hxx>
# include <string.hxx>


#define EVENTLOG_KEY  \
            "SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\"

#define EVENTLOG_VALUE_KEY      "EventMessageFile"


EVENT_LOG::EVENT_LOG(
    IN LPCTSTR lpszSource
    )
/*++

   Description
     Constructor function for given event log object.
     Initializes event logging services.

   Arguments:

      lpszSource:    Source string for the Event.

   Note:

     This is intended to be executed once only.
     This is not to be used for creating multiple event
      log handles for same given source name.
     But can be used for creating EVENT_LOG objects for
      different source names.

--*/
:
    m_ErrorCode         (NO_ERROR),
    m_pDateTimeCache    (NULL),
    m_hLogFile          (INVALID_HANDLE_VALUE)
{

    (VOID)IISGetPlatformType();

    IF_DEBUG( INIT_CLEAN) {
        DBGPRINTF( ( DBG_CONTEXT,
                   " Initializing Event Log for %s[%p] fLogFile[%x]\n",
                    lpszSource, this, TsIsWindows95()));
    }

    //
    //  Register as an event source.
    //

    if ( TsIsWindows95() ) {

        m_hEventSource = RegisterEventSourceChicagoStyle(
                                                lpszSource,
                                                &m_hLogFile
                                                );
    } else {

        m_hEventSource = RegisterEventSource( NULL, lpszSource);
    }

    if ( m_hEventSource != NULL ) {

        //
        //  Success!
        //

        IF_DEBUG( ERROR) {
            DBGPRINTF( ( DBG_CONTEXT,
                         " Event Log for %s initialized (hEventSource=%p)\n",
                         lpszSource,
                         m_hEventSource));
        }
    } else {

        DBG_ASSERT(m_hLogFile == INVALID_HANDLE_VALUE);

        //
        // An Error in initializing the event log.
        //

        m_ErrorCode = GetLastError();
        DBGPRINTF( ( DBG_CONTEXT,
                     "Could not register event source (%s) ( Error %lu)\n",
                     lpszSource,
                     m_ErrorCode));
    }

    return;

} // EVENT_LOG::EVENT_LOG()



EVENT_LOG::~EVENT_LOG(
    VOID
    )
/*++

    Description:
        Destructor function for given EVENT_LOG object.
        Terminates event logging functions and closes
         event log handle

--*/
{

    IF_DEBUG( INIT_CLEAN) {
        DBGPRINTF( ( DBG_CONTEXT,
                    "Terminating events logging[%p] fFile[%x]\n",
                        this, TsIsWindows95() ));
    }

    if ( TsIsWindows95() ) {

        if ( m_hLogFile != INVALID_HANDLE_VALUE ) {
            FlushFileBuffers(m_hLogFile);
            DBG_REQUIRE(CloseHandle( m_hLogFile ));
            m_hLogFile = INVALID_HANDLE_VALUE;
        }

        if ( m_pDateTimeCache != NULL ) {
            delete m_pDateTimeCache;
            m_pDateTimeCache = NULL;
        }

    } else {

        //
        // If there is a valid Events handle, deregister it
        //

        if ( m_hEventSource != NULL) {

            BOOL fSuccess;

            fSuccess = DeregisterEventSource( m_hEventSource);

            if ( !fSuccess) {

                //
                // An Error in DeRegistering
                //

                m_ErrorCode = GetLastError();

                IF_DEBUG( INIT_CLEAN) {

                    DBGPRINTF( ( DBG_CONTEXT,
                                 "Termination of EventLog[%p] failed."
                                 " error %lu\n",
                                 this,
                                 m_ErrorCode));
                }
            }

            //
            //  Reset the handle's value. Just as a precaution
            //
            m_hEventSource = NULL;
        }
    }


    IF_DEBUG( API_EXIT) {
        DBGPRINTF( ( DBG_CONTEXT, "Terminated events log[%p]\n",this));
    }

} /* EVENT_LOG::~EVENT_LOG() */



VOID
EVENT_LOG::LogEvent(
        IN DWORD  idMessage,
        IN WORD   nSubStrings,
        IN const CHAR * rgpszSubStrings[],
        IN DWORD  errCode)
/*++

     Description:
        Log an event to the event logger

     Arguments:

       idMessage           Identifies the event message

       nSubStrings         Number of substrings to include in
                            this message. (Maybe 0)

       rgpszSubStrings     array of substrings included in the message
                            (Maybe NULL if nSubStrings == 0)

       errCode             An error code from Win32 or WinSock or NT_STATUS.
                            If this is not Zero, it is considered as
                            "raw" data to be included in message

   Returns:

     None

--*/
{

    WORD wType;                // Type of Event to be logged

    //
    //  Find type of message for the event log
    //

    IF_DEBUG( API_ENTRY)  {

        DWORD i;

        DBGPRINTF( ( DBG_CONTEXT,
                    "reporting event %08lX, Error Code = %lu\n",
                    idMessage,
                    errCode ));

        for( i = 0 ; i < nSubStrings ; i++ ) {
            DBGPRINTF(( DBG_CONTEXT,
                       "    substring[%lu] = %s\n",
                       i,
                       rgpszSubStrings[i] ));
        }
    }

    if ( NT_INFORMATION( idMessage)) {

        wType = EVENTLOG_INFORMATION_TYPE;

    } else {

        if ( NT_WARNING( idMessage)) {

            wType = EVENTLOG_WARNING_TYPE;

        } else {

            wType = EVENTLOG_ERROR_TYPE;

            DBG_ASSERT(NT_ERROR( idMessage));
        }
    }

    //
    //  Log the event
    //

    EVENT_LOG::LogEventPrivate( idMessage,
                              wType,
                              nSubStrings,
                              rgpszSubStrings,
                              errCode);


    return;

} /* EVENT_LOG::LogEvent() */


//
//  Private functions.
//

VOID
EVENT_LOG::LogEventPrivate(
    IN DWORD   idMessage,
    IN WORD    wEventType,
    IN WORD    nSubStrings,
    IN const CHAR  * apszSubStrings[],
    IN DWORD   errCode
    )
/*++

     Description:
        Log an event to the event logger.
        ( Private version, includes EventType)

     Arguments:

       idMessage           Identifies the event message

       wEventType          Specifies the severety of the event
                            (error, warning, or informational).

       nSubStrings         Number of substrings to include in
                            this message. (Maybe 0)

       apszSubStrings     array of substrings included in the message
                            (Maybe NULL if nSubStrings == 0)

       errCode             An error code from Win32 or WinSock or NT_STATUS.
                            If this is not Zero, it is considered as
                            "raw" data to be included in message

   Returns:

     None

--*/
{
    VOID  * pRawData  = NULL;
    DWORD   cbRawData = 0;
    BOOL    fReport;
    DWORD   dwErr;

    if ( m_hEventSource == NULL ) {

        IF_DEBUG(ERROR) {
            DBGPRINTF((DBG_CONTEXT,"Attempt to log with no event source\n"));
        }
        return;
    }

    ASSERT( (nSubStrings == 0) || (apszSubStrings != NULL));

    if( errCode != 0 ) {
        pRawData  = &errCode;
        cbRawData = sizeof(errCode);
    }

    m_ErrorCode  = NO_ERROR;
    dwErr = GetLastError();

    if ( TsIsWindows95() ) {
        fReport = ReportEventChicagoStyle(
                                m_hEventSource,
                                m_hLogFile,
                                idMessage,
                                apszSubStrings,
                                errCode
                                );

    } else {

        fReport = ReportEvent(
                           m_hEventSource,                   // hEventSource
                           wEventType,                       // fwEventType
                           0,                                // fwCategory
                           idMessage,                        // IDEvent
                           NULL,                             // pUserSid,
                           nSubStrings,                      // cStrings
                           cbRawData,                        // cbData
                           (LPCTSTR *) apszSubStrings,       // plpszStrings
                           pRawData );                       // lpvData

#ifdef DBG
    
        //
        // Output the event log to the debugger
        //
        
        CHAR buffer[MAX_PATH+1];
        PCHAR pBuffer = buffer;

        ::FormatMessageA(FORMAT_MESSAGE_MAX_WIDTH_MASK  |
                           FORMAT_MESSAGE_FROM_HMODULE |
                           FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           m_hEventSource,
                           idMessage,
                           0,
                           (LPSTR)pBuffer,
                           (DWORD)sizeof(buffer),
                           (va_list*)apszSubStrings
                           );

        DBGPRINTF((DBG_CONTEXT,"Reporting EVENT_LOG Event - %s\n", buffer));

#endif                           
    }

    if ( !fReport ) {

        IF_DEBUG( ERROR) {

            m_ErrorCode = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                        "Cannot report event for %p, error %lu\n",
                        this,
                        m_ErrorCode));
        }
    }
    else {
        SetLastError( dwErr );
    }

}  // EVENT_LOG::LogEventPrivate()



HANDLE
EVENT_LOG::RegisterEventSourceChicagoStyle(
    IN LPCSTR   lpszSource,
    IN PHANDLE  hFile
    )
/*++

     Description:
        Register event source in win95

     Arguments:

        lpszSource  - name of event source
        hFile       - on return, contains handle to log file

    Returns:

        if successful, Handle to event source
        NULL, otherwise
--*/
{
    HANDLE hSource = NULL;
    CHAR szPath[MAX_PATH+1];
    STR regKey;
    DWORD len;
    DWORD err = NO_ERROR;
    HKEY hKey;
    HANDLE hEventFile = INVALID_HANDLE_VALUE;

    //
    // Initialize the cache
    //

    m_pDateTimeCache = new ASCLOG_DATETIME_CACHE(); //log format
    if ( m_pDateTimeCache == NULL ) {
        err = GetLastError();

        DBGPRINTF((DBG_CONTEXT,
            "Cannot allocate datetime cache[%d]\n", err));
        goto exit;
    }

    //
    // Contruct the log file name
    //

    len = GetWindowsDirectory(szPath, sizeof(szPath));

    if ( len == 0 ) {
        DBGPRINTF((DBG_CONTEXT,"GetWindowsDirectory returns 0\n"));
        goto exit;
    }

    DBG_ASSERT(len <= MAX_PATH);

    strcat(szPath, "\\");
    strcat(szPath, lpszSource);
    strcat(szPath, ".event.log");

    IF_DEBUG( INIT_CLEAN) {
        DBGPRINTF((DBG_CONTEXT,"Event log file set to %s\n", szPath));
    }

    //
    // Open the file
    //

    hEventFile = CreateFile(
                        szPath,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if ( hEventFile == INVALID_HANDLE_VALUE ) {
        err = GetLastError();
        goto exit;
    }

    //
    // Move to end of file
    //

    if ( SetFilePointer( hEventFile, 0, NULL, FILE_END ) == (DWORD)-1 ) {
        err = GetLastError();
        goto exit;
    }

    //
    // If log file successfully opened - register event message source file.
    // On Win9x registration simply means locating module handle for DLL,
    // where we will load messages from.
    //

    regKey.Copy(EVENTLOG_KEY);
    regKey.Append(lpszSource);

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                regKey.QueryStr(),
                0,
                KEY_ALL_ACCESS,
                &hKey);

    if ( err == NO_ERROR) {

        DWORD cbBuffer;

        cbBuffer = sizeof(szPath);
        szPath[0] = '\0';

        err = RegQueryValueEx( hKey,
                               EVENTLOG_VALUE_KEY,
                               NULL,
                               NULL,
                               (LPBYTE) szPath,
                               &cbBuffer);

        RegCloseKey( hKey);

        if ( err == NO_ERROR ) {

            hSource  = GetModuleHandle(szPath);
            if ( hSource == NULL ) {
                err = GetLastError();

                DBGPRINTF((DBG_CONTEXT,"GetModuleHandle[%s] returns %d\n",
                    szPath, err));
            }
        } else {

            DBGPRINTF((DBG_CONTEXT,
                "Cannot find value %s. Err = %d\n",
                    EVENTLOG_VALUE_KEY, err ));
        }
    } else {

        DBGPRINTF((DBG_CONTEXT,
            "Cannot open key %s. Err = %d\n",
                regKey.QueryStr(), err ));
    }

exit:

    if ( (err != NO_ERROR) || (hSource == NULL) ) {

        if ( hEventFile != INVALID_HANDLE_VALUE ) {
            CloseHandle( hEventFile );
            hEventFile = INVALID_HANDLE_VALUE;
        }
        hSource = NULL;
        SetLastError(err);
    }

    *hFile = hEventFile;
    return(hSource);

} // RegisterEventSourceChicagoStyle()



BOOL
EVENT_LOG::ReportEventChicagoStyle(
        IN HANDLE       hEventSource,
        IN HANDLE       hLogFile,
        IN DWORD        idMessage,
        IN LPCSTR *     apszSubStrings,
        IN DWORD        dwErrorCode
        )
{
    SYSTEMTIME st;
    DWORD cch;
    DWORD nDate;
    CHAR buffer[MAX_PATH+1];
    PCHAR pBuffer = buffer;
    BOOL fReturn = FALSE;

    GetLocalTime( &st );
    nDate = m_pDateTimeCache->GetFormattedDateTime(&st, pBuffer);
    pBuffer += nDate;

    //
    // Read message and add inserts
    //

    cch = ::FormatMessageA(FORMAT_MESSAGE_MAX_WIDTH_MASK  |
                           FORMAT_MESSAGE_FROM_HMODULE |
                           FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           hEventSource,
                           idMessage,
                           0,
                           (LPSTR)pBuffer,
                           (DWORD)(sizeof(buffer) - nDate),
                           (va_list*)apszSubStrings
                           );

    if (cch != 0) {

        DWORD nBytes = 0;

        DBGPRINTF((DBG_CONTEXT,"Reporting EVENT_LOG Event - %s\n", buffer));
 
        cch += nDate;
        fReturn = WriteFile(
                        hLogFile,
                        buffer,
                        cch,
                        &nBytes,
                        NULL);

        if (nBytes != 0) {

            DBG_ASSERT(cch == nBytes);

            cch = wsprintf(buffer,"[%x]\r\n",dwErrorCode);
            fReturn = WriteFile(hLogFile,buffer,cch,&nBytes,NULL);
        }
    }

    return(fReturn);

} // ReportEventChicagoStyle()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\isutils.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      isutils.cxx

   Abstract:
      This module defines functions that are generic for Internet servers

   Author:

       Murali R. Krishnan    ( MuraliK )     15-Nov-1995

   Environment:
      Win32 - User Mode

   Project:

       Internet Servers Common DLL

   Functions Exported:

       IsLargeIntegerToChar();

   Revision History:

--*/

#include "precomp.hxx"

#include <inetsvcs.h>
#include <mbstring.h>


DWORD
IsLargeIntegerToDecimalChar(
    IN  const LARGE_INTEGER * pliValue,
    OUT LPSTR                pchBuffer
    )
/*++

Routine Description:

    Maps a Large Integer to be a displayable string.

Arguments:

    pliValue -  The LARGE INTEGER to be mapped.
    pchBuffer - pointer to character buffer to store the result
      (This buffer should be at least about 32 bytes long to hold
       entire large integer value as well as null character)

Return Value:

    Win32 Error code. NO_ERROR on success

--*/
{

    PSTR p1;
    PSTR p2;
    BOOL negative;
    LONGLONG Value;

    if ( pchBuffer == NULL || pliValue == NULL) {

        return ( ERROR_INVALID_PARAMETER);
    }


    //
    // Handling zero specially makes everything else a bit easier.
    //

    if( pliValue->QuadPart == 0 ) {

        // store the value 0 and return.
        pchBuffer[0] = '0';
        pchBuffer[1] = '\0';

        return (NO_ERROR);
    }

    Value = pliValue->QuadPart;  // cache the value.

    //
    // Remember if the value is negative.
    //

    if( Value < 0 ) {

        negative = TRUE;
        Value = -Value;

    } else {

        negative = FALSE;
    }

    //
    // Pull the least signifigant digits off the value and store them
    // into the buffer. Note that this will store the digits in the
    // reverse order.
    //  p1 is used for storing the digits as they are computed
    //  p2 is used during the reversing stage.
    //

    p1 = p2 = pchBuffer;

    for ( p1 = pchBuffer; Value != 0; ) {

        int digit = (int)( Value % 10 );
        Value = Value / 10;

        *p1++ = '0' + digit;
    } // for

    //
    // Tack on a '-' if necessary.
    //

    if( negative ) {

        *p1++ = '-';

    }

    // terminate the string
    *p1-- = '\0';


    //
    // Reverse the digits in the buffer.
    //

    for( p2 = pchBuffer; ( p1 > p2 ); p1--, p2++)  {

        CHAR ch = *p1;
        *p1 = *p2;
        *p2 = ch;
    } // for

    return ( NO_ERROR);

} // IsLargeIntegerToDecimalChar()



BOOL
ZapRegistryKey(
    IN HKEY   hKey,
    IN LPCSTR pszRegPath
    )
/*++

    Description:

        Zaps the reg key starting from pszRegPath down

    Arguments:

        hkey        - handle for parent
        pszRegPath - Key to zap

    Returns:
        FALSE if there is any error.
        TRUE when the reg key was successfully zapped.

--*/
{
    DWORD   err = NO_ERROR;
    DWORD   i = 0;
    HKEY    hKeyParam;

    if ( hKey == NULL ) {
        hKey = HKEY_LOCAL_MACHINE;
    }

    //
    // Loop through instance keys
    //

    err = RegOpenKeyEx( hKey,
                        pszRegPath,
                        0,
                        KEY_ALL_ACCESS,
                        &hKeyParam );

    if( err != NO_ERROR ) {
        return(TRUE);
    }

    while ( TRUE ) {

        CHAR  szKeyName[MAX_PATH+1];
        DWORD cbKeyName   = sizeof( szKeyName );
        FILETIME ft;
        BOOL fRet;
        DWORD dwInstance;
        CHAR szRegKey[MAX_PATH+1];

        err = RegEnumKeyEx( hKeyParam,
                            i,
                            szKeyName,
                            &cbKeyName,
                            NULL,
                            NULL,
                            NULL,
                            &ft );

        if ( err == ERROR_NO_MORE_ITEMS ) {
            err = NO_ERROR;
            break;
        }

        //
        // Zap this key
        //

        ZapRegistryKey(hKeyParam, szKeyName);
    }

    RegCloseKey(hKeyParam);

    err = RegDeleteKey(
                hKey,
                pszRegPath
                );

    if ( err != NO_ERROR ) {
        return(FALSE);
    }
    return(TRUE);

} // ZapRegistryKey


HKEY
CreateKey(
    IN HKEY   RootKey,
    IN LPCSTR KeyName,
    IN LPCSTR KeyValue
    )
{
    HKEY hKey = NULL;
    DWORD dwDisp;

    if ( RegCreateKeyExA(RootKey,
                    KeyName,
                    NULL,
                    "",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &dwDisp) != ERROR_SUCCESS ) {

        goto exit;
    }

    if ( KeyValue != NULL ) {
        if (RegSetValueExA(hKey,
                    "",
                    NULL,
                    REG_SZ,
                    (LPBYTE)KeyValue,
                    lstrlen(KeyValue)+1)!=ERROR_SUCCESS) {

            RegCloseKey(hKey);
            hKey = NULL;
        }
    }

exit:
    return hKey;

} // CreateKey


BOOL
IISCreateDirectory(
    IN LPCSTR   DirectoryName,
    IN BOOL     fAllowNetDrive
    )
{

    PCHAR p;
    DWORD len;

    len = strlen(DirectoryName);

    if ( (len < 3) ||
         (DirectoryName[1] != ':') ||
         (DirectoryName[2] != '\\') ) {

        SetLastError(ERROR_INVALID_NAME);
        return(FALSE);
    }

    if ( !fAllowNetDrive ) {

        UINT    driveType;
        CHAR    path[4];

        CopyMemory(path, DirectoryName, 3);
        path[3] = '\0';

        driveType = GetDriveType(path);
        if ( driveType == DRIVE_REMOTE ) {
            DBGPRINTF((DBG_CONTEXT,
                "%s is a remote directory. Not allowed\n", path));

            SetLastError(ERROR_INVALID_NAME);
            return(FALSE);
        }
    }

    p = (PCHAR)DirectoryName+3;

    do {

        p = (PCHAR)_mbschr((PUCHAR)p,'\\');
        if ( p != NULL ) {
            *p = '\0';
        }

        if ( !CreateDirectoryA(DirectoryName,NULL) ) {

            DWORD err = GetLastError();
            if ( err != ERROR_ALREADY_EXISTS ) {
                DBGPRINTF((DBG_CONTEXT,
                    "Error %d in CreateDirectory [%s]\n",
                    err, DirectoryName));

                if ( p != NULL ) {
                    *p = '\\';
                }
                SetLastError(err);
                return(FALSE);
            }
        }

        if ( p != NULL ) {
            *p = '\\';
            p++;
        }

    } while ( p != NULL );

    return(TRUE);

} // IISCreateDirectory
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\ipsupp.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      ipsupp.cxx

   Abstract:
      This module defines functions that are generic for Internet servers

   Author:

       Murali R. Krishnan    ( MuraliK )     15-Nov-1995

--*/

#include "precomp.hxx"

#include <inetsvcs.h>
#include <winsock2.h>

#define LOCAL127            0x0100007F  // 127.0.0.1


BOOL
IsIPAddressLocal(
    IN DWORD LocalIP,
    IN DWORD RemoteIP
    )
{
    INT err;
    CHAR nameBuf[MAX_PATH+1];
    PHOSTENT    hostent;
    PIN_ADDR    p;
    CHAR        **list;

    //
    // if local and remote are the same, then this is local
    //

    if ( (LocalIP == RemoteIP)  ||
         (RemoteIP == LOCAL127) ||
         (LocalIP == LOCAL127) ) {

        return(TRUE);
    }

    err = gethostname( nameBuf, sizeof(nameBuf));

    if ( err != 0 ) {
        IIS_PRINTF((buff,"IsIPAddressLocal: Err %d in gethostname\n",
            WSAGetLastError()));
        return(FALSE);
    }

    hostent = gethostbyname( nameBuf );
    if ( hostent == NULL ) {
        IIS_PRINTF((buff,"IsIPAddressLocal: Err %d in gethostbyname\n",
            WSAGetLastError()));
        return(FALSE);
    }

    list = hostent->h_addr_list;

    while ( (p = (PIN_ADDR)*list++) != NULL ) {

        if ( p->s_addr == RemoteIP ) {
            return(TRUE);
        }
    }

    IIS_PRINTF((buff,"Not Local[%x %x]\n", LocalIP, RemoteIP));
    return(FALSE);

} // IsIPAddressLocal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\hashtab.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
       hashtab.cxx

   Abstract:
       Implements the member functions for Hash table

   Author:

       Murali R. Krishnan    ( MuraliK )     02-Oct-1996

   Environment:
       Win32 - User Mode

   Project:

       Internet Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"

# if !defined(dllexp)
# define dllexp __declspec( dllexport)
# endif

# include <hashtab.hxx>



/*++
  Organization of Hash Table

  The hash table consists of a set of hash buckets controlled
  by the number of buckets specified during creation.

  Each bucket consists of a set of bucket chunks. Each bucket
  owns a separate critical section to protect the entries in
  the bucket itself.

  Each bucket chunk consists of an array of MAX_ELEMENTS_PER_BUCKET
   HashTableBucketElement Entries (HTBE_ENTRY).

  Each HTBE_ENTRY maintains a hash value and pointer to the Hash Element.

--*/

/************************************************************
 *    HASH_TABLE_BUCKET
 ************************************************************/

struct HTBE_ENTRY {
    DWORD        m_hashValue;
    HT_ELEMENT * m_phte;

    inline
    BOOL IsMatch( DWORD hashValue, LPCSTR pszKey, DWORD cchKey) const
    { return ((hashValue == m_hashValue) &&
              (NULL != m_phte) &&
              m_phte->IsMatch( pszKey, cchKey)
              );
    }

    inline
    BOOL IsMatch( IN HT_ELEMENT * phte) const
    { return ( phte == m_phte); }

    inline BOOL
    IsEmpty( VOID) const { return ( NULL == m_phte); }

    VOID Print( VOID) const
    { m_phte->Print(); }
};

typedef HTBE_ENTRY * PHTBE_ENTRY;

//
// Chunk size should be carefully (empirically) chosen.
// Small Chunk size => large number of chunks
// Large Chunk size => high cost of search on failures.
// For now we choose the chunk size to be 20 entries.
# define MAX_ELEMENTS_PER_BUCKET    ( 20 )

struct dllexp HTB_ELEMENT {

    HTBE_ENTRY   m_rgElements[MAX_ELEMENTS_PER_BUCKET];
    DWORD        m_nElements;
    LIST_ENTRY   m_ListEntry;

    HTB_ELEMENT(VOID)
        : m_nElements ( 0)
    {
        InitializeListHead( &m_ListEntry);
        ZeroMemory( m_rgElements, sizeof( m_rgElements));
    }

    ~HTB_ELEMENT(VOID)
    { Cleanup(); }

    VOID Cleanup( VOID);

    inline
    HT_ELEMENT * Lookup( IN DWORD hashValue, IN LPCSTR pszKey, DWORD cchKey);

    inline
    BOOL Insert( IN DWORD hashVal, IN HT_ELEMENT * phte);

    inline
    BOOL Delete( IN HT_ELEMENT * phte);

    VOID Print( IN DWORD level) const;

    HTBE_ENTRY * FirstElement(VOID) { return ( m_rgElements); }
    HTBE_ENTRY * LastElement(VOID)
    { return ( m_rgElements + MAX_ELEMENTS_PER_BUCKET); }
    VOID NextElement( HTBE_ENTRY * & phtbe)
    { phtbe++; }

    VOID IncrementElements(VOID) { m_nElements++; }
    VOID DecrementElements(VOID) { m_nElements--; }
    DWORD NumElements( VOID) const { return ( m_nElements); }
    BOOL IsSpaceAvailable(VOID) const
    { return ( NumElements() < MAX_ELEMENTS_PER_BUCKET); }

    DWORD FindNextElement( IN OUT LPDWORD pdwPos,
                           OUT HT_ELEMENT ** pphte);

};

typedef HTB_ELEMENT * PHTB_ELEMENT;

class dllexp HASH_TABLE_BUCKET {

public:
    HASH_TABLE_BUCKET(VOID);
    ~HASH_TABLE_BUCKET( VOID);

    HT_ELEMENT * Lookup( IN DWORD hashValue, IN LPCSTR pszKey, DWORD cchKey);
    BOOL Insert( IN DWORD       hashVal,
                 IN HT_ELEMENT * phte,
                 IN BOOL        fCheckForDuplicate);

    BOOL Delete( IN HT_ELEMENT * phte);
    VOID Print( IN DWORD level);

    DWORD NumEntries( VOID);

    DWORD  InitializeIterator( IN HT_ITERATOR * phti);

    DWORD  FindNextElement( IN HT_ITERATOR * phti,
                                   OUT HT_ELEMENT ** pphte);
    DWORD  CloseIterator( IN HT_ITERATOR * phti);

private:
    CRITICAL_SECTION   m_csLock;

    LIST_ENTRY         m_lHead;
    DWORD              m_nEntries;

    HTB_ELEMENT        m_htbeFirst; // the first bucket chunk

    VOID Lock(VOID) { EnterCriticalSection( &m_csLock); }
    VOID Unlock( VOID) { LeaveCriticalSection( &m_csLock); }
};




/************************************************************
 *    Member Functions of HTB_ELEMENT
 ************************************************************/

VOID
HTB_ELEMENT::Cleanup( VOID)
{

    if ( m_nElements > 0) {
        PHTBE_ENTRY phtbeEntry;

        // free up all the entries in this bucket.
        for (phtbeEntry = FirstElement();
             phtbeEntry < (LastElement());
             NextElement( phtbeEntry)) {

            if ( !phtbeEntry->IsEmpty() ) {

                // release the object now.
                DecrementElements();

                // Assert that ref == 1
                DerefAndKillElement( phtbeEntry->m_phte);
                phtbeEntry->m_phte = NULL;
                phtbeEntry->m_hashValue = 0;
            }
        } // for
    }

    DBG_ASSERT( 0 == m_nElements);
    return;
} // HTB_ELEMENT::Cleanup()


inline
HT_ELEMENT *
HTB_ELEMENT::Lookup( IN DWORD hashValue, IN LPCSTR pszKey, DWORD cchKey)
{
    HT_ELEMENT * phte = NULL;

    if ( m_nElements > 0) {

        PHTBE_ENTRY phtbeEntry;
        // find the entry by scanning all entries in this bucket chunk
        // if found, increment ref count and return a pointer to the object
        for (phtbeEntry = FirstElement();
             phtbeEntry < (LastElement());
             NextElement( phtbeEntry)) {

            //
            // If the hash values match and the strings match up, return
            //  the corresponding hash table entry object
            //
            if ( phtbeEntry->IsMatch( hashValue, pszKey, cchKey)) {

                // we found the entry. return it.
                phte = phtbeEntry->m_phte;
                DBG_REQUIRE( phte->Reference() > 0);
                break;
            }
        } // for
    }

    return ( phte);
} // HTB_ELEMENT::Lookup()


inline BOOL
HTB_ELEMENT::Insert( IN DWORD hashVal,
                     IN HT_ELEMENT * phte
                     )
{
    if ( m_nElements < MAX_ELEMENTS_PER_BUCKET) {

        // there is some empty space.
        // Find one such a slot and add this new entry

        PHTBE_ENTRY phtbeEntry;

        for (phtbeEntry = FirstElement();
             phtbeEntry < LastElement();
             NextElement( phtbeEntry)) {

            if ( phtbeEntry->IsEmpty() ) {

                DBG_ASSERT( NULL != phte);

                // Assume that the object phte already has non-zero ref count

                // we found a free entry. insert the new element here.
                phtbeEntry->m_hashValue = hashVal;
                phtbeEntry->m_phte = phte;
                IncrementElements();
                return ( TRUE);
            }
        } // for

        // we should not come here. If we do then there is trouble :(
        DBG_ASSERT( FALSE);
    }

    SetLastError( ERROR_INSUFFICIENT_BUFFER);
    return ( FALSE);
} // HTB_ELEMENT::Insert()


DWORD
HTB_ELEMENT::FindNextElement( IN OUT LPDWORD pdwPos, OUT HT_ELEMENT ** pphte)
{
    DWORD dwErr = ERROR_NO_MORE_ITEMS;

    DBG_ASSERT( NULL != pdwPos );
    DBG_ASSERT( NULL != pphte );

    // Find the first valid element to return back.

    //
    // Given that deletion might happen any time, we cannot rely on the
    //   comparison  *pdwPos < m_nElements
    //
    // Do scans with *pdwPos < MAX_ELEMENTS_PER_BUCKET
    //

    if ( *pdwPos < MAX_ELEMENTS_PER_BUCKET ) {

        PHTBE_ENTRY phtbeEntry;

        // find the entry by scanning all entries in this bucket chunk
        // if found, increment ref count and return a pointer to the object
        for (phtbeEntry = m_rgElements + *pdwPos;
             phtbeEntry < (LastElement());
             NextElement( phtbeEntry)) {

            if ( phtbeEntry->m_phte != NULL ) {

                //
                // Store the element pointer and the offset
                // and return after referencing the element
                //
                *pphte = phtbeEntry->m_phte;
                (*pphte)->Reference();
                *pdwPos = ( 1 + DIFF(phtbeEntry - FirstElement()));
                dwErr = NO_ERROR;
                break;
            }
        } // for
    }

    return ( dwErr);
} // HTB_ELEMENT::FindNextElement()


inline BOOL
HTB_ELEMENT::Delete( IN HT_ELEMENT * phte)
{
    DBG_ASSERT( NULL != phte);

    if ( m_nElements > 0) {

        PHTBE_ENTRY phtbeEntry;
        // find the entry by scanning all entries in this bucket chunk
        // if found, increment ref count and return a pointer to the object
        for (phtbeEntry = FirstElement();
             phtbeEntry < (LastElement());
             NextElement( phtbeEntry)) {

            //
            // If the hash values match and the strings match up,
            //  decrement ref count and kill the element.
            //
            if ( phtbeEntry->IsMatch( phte)) {

                // We found the entry.  Remove it from the table

                phtbeEntry->m_phte = NULL;
                DecrementElements();

                DerefAndKillElement( phte);

                return ( TRUE);
            }
        } // for
    }

    return ( FALSE);
} // HTB_ELEMENT::Delete()


VOID
HTB_ELEMENT::Print(IN DWORD level) const
{
    const HTBE_ENTRY * phtbeEntry;
    CHAR rgchBuffer[MAX_ELEMENTS_PER_BUCKET * 22 + 200];
    DWORD cch;
    DWORD i;

    cch = wsprintf( rgchBuffer,
                    "HTB_ELEMENT(%08x)  # Elements %4d; "
                    "Flink: %08x  Blink: %08x\n"
                    ,
                    this, m_nElements,
                    m_ListEntry.Flink, m_ListEntry.Blink);

    if ( level > 0) {

        // NYI: I need to walk down the entire array.
        // Not just the first few entries
        for( i = 0; i < m_nElements; i++) {

            phtbeEntry = &m_rgElements[i];
            cch += wsprintf( rgchBuffer + cch,
                             "  %08x %08x",
                         phtbeEntry->m_hashValue,
                             phtbeEntry->m_phte
                             );
            if ( i % 4 == 0) {
                rgchBuffer[cch++] = '\n';
                rgchBuffer[cch] = '\0';
            }
        } // for
    }

    DBGDUMP(( DBG_CONTEXT, rgchBuffer));
    return;
} // HTB_ELEMENT::Print()



/************************************************************
 *    Member Functions of HASH_TABLE_BUCKET
 ************************************************************/

HASH_TABLE_BUCKET::HASH_TABLE_BUCKET(VOID)
    : m_nEntries ( 0),
      m_htbeFirst()
{
    InitializeListHead( &m_lHead);
    INITIALIZE_CRITICAL_SECTION( & m_csLock);
} // HASH_TABLE_BUCKET::HASH_TABLE_BUCKET()


HASH_TABLE_BUCKET::~HASH_TABLE_BUCKET( VOID)
{
    PLIST_ENTRY pl;
    PHTB_ELEMENT phtbe;

    // Free up the elements in the list
    Lock();
    while ( !IsListEmpty( &m_lHead)) {
        pl = RemoveHeadList( &m_lHead);
        phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT, m_ListEntry);
        delete phtbe;
    } // while

    m_htbeFirst.Cleanup();
    Unlock();

    DeleteCriticalSection( &m_csLock);
} // HASH_TABLE_BUCKET::~HASH_TABLE_BUCKET()



HT_ELEMENT *
HASH_TABLE_BUCKET::Lookup( IN DWORD hashValue, IN LPCSTR pszKey, DWORD cchKey)
{
    HT_ELEMENT * phte;

    Lock();
    // 1. search in the first bucket
    phte = m_htbeFirst.Lookup( hashValue, pszKey, cchKey);

    if ( NULL == phte ) {

        // 2. search in the auxiliary buckets
        PLIST_ENTRY pl;

        for ( pl = m_lHead.Flink; (phte == NULL) && (pl != &m_lHead);
              pl = pl->Flink) {

            HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl,
                                                     HTB_ELEMENT,
                                                     m_ListEntry);
            phte = phtbe->Lookup( hashValue, pszKey, cchKey);
        } // for
    }

    Unlock();

    return (phte);
} // HASH_TABLE_BUCKET::Lookup()


BOOL
HASH_TABLE_BUCKET::Insert( IN DWORD hashValue,
                           IN HT_ELEMENT * phte,
                           IN BOOL fCheckForDuplicate)
{
    BOOL fReturn = FALSE;

    if ( fCheckForDuplicate) {

        Lock();

        // do a lookup and find out if this data exists.
        HT_ELEMENT * phteLookedup = Lookup( hashValue,
                                            phte->QueryKey(),
                                            phte->QueryKeyLen()
                                            );

        if ( NULL != phteLookedup) {
            // the element is already present - return failure

            DerefAndKillElement( phteLookedup);
        }

        Unlock();

        if ( NULL != phteLookedup) {
            SetLastError( ERROR_DUP_NAME);
            return ( FALSE);
        }
    }

    Lock();

    // 1. try inserting in the first bucket chunk, if possible
    if ( m_htbeFirst.IsSpaceAvailable()) {

        fReturn = m_htbeFirst.Insert( hashValue, phte);
    } else {

        // 2. Find the first chunk that has space and insert it there.
        PLIST_ENTRY pl;
        HTB_ELEMENT * phtbe;

        for ( pl = m_lHead.Flink; (pl != &m_lHead);
              pl = pl->Flink) {

            phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT, m_ListEntry);

            if ( phtbe->IsSpaceAvailable()) {
                fReturn = phtbe->Insert( hashValue, phte);
                break;
            }
        } // for

        if ( !fReturn ) {

            //
            // We ran out of space.
            // Allocate a new bucket and insert the new element.
            //

            phtbe = new HTB_ELEMENT();
            if ( NULL != phtbe) {

                // add the bucket to the list of buckets and
                // then add the element to the bucket
                InsertTailList( &m_lHead, &phtbe->m_ListEntry);
                fReturn = phtbe->Insert(hashValue, phte);
            } else {

                IF_DEBUG( ERROR) {
                    DBGPRINTF(( DBG_CONTEXT,
                                " HTB(%08x)::Insert: Unable to add a chunk\n",
                                this));
                }
                SetLastError( ERROR_NOT_ENOUGH_MEMORY);
            }
        }
    }

    Unlock();

    return ( fReturn);
} // HASH_TABLE_BUCKET::Insert()



BOOL
HASH_TABLE_BUCKET::Delete( IN HT_ELEMENT * phte)
{
    BOOL fReturn = FALSE;


    // We do not know which bucket this element belongs to.
    // So we should try all chunks to delete this element.

    Lock();

    // 1. try deleting the element from first bucket chunk, if possible
    fReturn = m_htbeFirst.Delete( phte);

    if (!fReturn) {

        // it was not on the first bucket chunk.

        // 2. Find the first chunk that might contain this element
        // and delete it.
        PLIST_ENTRY pl;

        for ( pl = m_lHead.Flink;
              !fReturn && (pl != &m_lHead);
              pl = pl->Flink) {

            HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl,
                                                     HTB_ELEMENT,
                                                     m_ListEntry);
            fReturn = phtbe->Delete( phte);
        } // for

        // the element should have been in the hash table,
        // otherwise the app is calling with wrong entry
        DBG_ASSERT( fReturn);
    }

    Unlock();

    return ( fReturn);
} // HASH_TABLE_BUCKET::Delete()


DWORD
HASH_TABLE_BUCKET::NumEntries( VOID)
{
    DWORD nEntries;

    Lock();

    nEntries = m_htbeFirst.NumElements();

    PLIST_ENTRY pl;

    for ( pl = m_lHead.Flink;
          (pl != &m_lHead);
          pl = pl->Flink) {

        HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT,
                                                 m_ListEntry);
        nEntries += phtbe->NumElements();
    } // for

    Unlock();

    return (nEntries);

} // HASH_TABLE_BUCKET::NumEntries()


DWORD
HASH_TABLE_BUCKET::InitializeIterator( IN HT_ITERATOR * phti)
{
    DWORD dwErr = ERROR_NO_MORE_ITEMS;

    //
    // find the first chunk that has a valid element.
    // if we find one, leave the lock on for subsequent accesses.
    // CloseIterator will shut down the lock
    // If we do not find one, we should unlock and return
    //

    phti->nChunkId = NULL;
    phti->nPos = 0;

    Lock();
    if ( m_htbeFirst.NumElements() > 0) {
        phti->nChunkId = (PVOID ) &m_htbeFirst;
        dwErr = NO_ERROR;
    } else {

        // find the first chunk that has an element

        PLIST_ENTRY pl;

        for ( pl = m_lHead.Flink; (pl != &m_lHead); pl = pl->Flink) {

            HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT,
                                                     m_ListEntry);
            if ( phtbe->NumElements() > 0) {
                phti->nChunkId = (PVOID ) phtbe;
                dwErr = NO_ERROR;
                break;
            }
        } // for
    }

    // if we did not find any elements, then unlock and return
    // Otherwise leave the unlocking to the CloseIterator()
    if ( dwErr == ERROR_NO_MORE_ITEMS) {

        // get out of this bucket completely.
        Unlock();
    }

    return ( dwErr);

} // HASH_TABLE_BUCKET::InitializeIterator()


DWORD
HASH_TABLE_BUCKET::FindNextElement( IN HT_ITERATOR * phti,
                                    OUT HT_ELEMENT ** pphte)
{
    //  this function should be called only when the bucket is locked.

    DWORD dwErr;
    HTB_ELEMENT * phtbe = (HTB_ELEMENT * )phti->nChunkId;

    //
    // phti contains the <chunk, pos> from which we should start scan for
    //   next element.
    //

    DBG_ASSERT( NULL != phtbe);
    dwErr = phtbe->FindNextElement( &phti->nPos, pphte);

    if ( ERROR_NO_MORE_ITEMS == dwErr ) {

        // scan the rest of the chunks for next element

        PLIST_ENTRY pl = ((phtbe == &m_htbeFirst) ? m_lHead.Flink :
                          phtbe->m_ListEntry.Flink);

        for ( ; (pl != &m_lHead); pl = pl->Flink) {

            phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT,
                                       m_ListEntry);
            if ( phtbe->NumElements() > 0) {
                phti->nPos = 0;
                dwErr = phtbe->FindNextElement( &phti->nPos, pphte);
                DBG_ASSERT( NO_ERROR == dwErr);
                phti->nChunkId = (PVOID ) phtbe;
                break;
            }
        } // for
    }

    if ( dwErr == ERROR_NO_MORE_ITEMS) {

        phti->nChunkId = NULL;
    }

    return ( dwErr);
} // HASH_TABLE_BUCKET::FindNextElement()


DWORD
HASH_TABLE_BUCKET::CloseIterator( IN HT_ITERATOR * phti)
{
    // just unlock the current bucket.
    Unlock();

    return ( NO_ERROR);
} // HASH_TABLE_BUCKET::CloseIterator()


VOID
HASH_TABLE_BUCKET::Print( IN DWORD level)
{
    Lock();
    DBGPRINTF(( DBG_CONTEXT,
                "\n\nHASH_TABLE_BUCKET (%08x): Head.Flink=%08x; Head.Blink=%08x\n"
                " Bucket Chunk # 0:\n"
                ,
                this, m_lHead.Flink, m_lHead.Blink
                ));

    m_htbeFirst.Print( level);

    if ( level > 0) {
        PLIST_ENTRY pl;
        DWORD i;

        for ( pl = m_lHead.Flink, i = 1;
              (pl != &m_lHead);
              pl = pl->Flink, i++) {

            HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT,
                                                     m_ListEntry);
            DBGPRINTF(( DBG_CONTEXT, "\n Bucket Chunk # %d\n", i));
            phtbe->Print( level);
        } // for
    }

    Unlock();
    return;
} // HASH_TABLE_BUCKET::Print()




/************************************************************
 *    Member Functions of HASH_TABLE
 ************************************************************/

HASH_TABLE::HASH_TABLE( IN DWORD   nBuckets,
                        IN LPCSTR  pszIdentifier,
                        IN DWORD   dwHashTableFlags
                        )
    : m_nBuckets   ( nBuckets),
      m_dwFlags    ( dwHashTableFlags),
      m_nEntries   ( 0),
      m_nLookups   ( 0),
      m_nHits      ( 0),
      m_nInserts   ( 0),
      m_nFlushes   ( 0)
{
    if ( NULL != pszIdentifier) {

        lstrcpynA( m_rgchId, pszIdentifier, sizeof( m_rgchId));
    }

    m_prgBuckets = new HASH_TABLE_BUCKET[nBuckets];

} // HASH_TABLE::HASH_TABLE()



DWORD
HASH_TABLE::CalculateHash( IN LPCSTR pszKey, DWORD cchKey) const
{
    DWORD hash = 0;

    DBG_ASSERT( pszKey != NULL );

    if ( cchKey > 8) {
        //
        // hash the last 8 characters
        //
        pszKey = (pszKey + cchKey - 8);
    }

    while ( *pszKey != '\0') {

        //
        // This is an extremely slimey way of getting upper case.
        // Kids, don't try this at home
        // -johnson
        //

        DWORD ch = ((*pszKey++) & ~0x20);

        // NYI: this is a totally pipe-line unfriendly code. Improve this.
        hash <<= 2;
        hash ^= ch;
        hash += ch;
    } // while

    //
    // Multiply by length (to introduce some randomness.  Murali said so.
    //

    return( hash * cchKey);
} // CalculateHash()


VOID
HASH_TABLE::Cleanup(VOID)
{
    if ( NULL != m_prgBuckets ) {

        delete [] m_prgBuckets;
        m_prgBuckets = NULL;
    }

} // HASH_TABLE::Cleanup()



# define INCREMENT_LOOKUPS()  \
       { InterlockedIncrement( (LPLONG ) &m_nLookups); }

# define INCREMENT_HITS( phte)  \
       if ( NULL != phte) { InterlockedIncrement( (LPLONG ) &m_nHits); }

# define INCREMENT_INSERTS()  \
       { InterlockedIncrement( (LPLONG ) &m_nInserts); }

# define INCREMENT_FLUSHES()  \
       { InterlockedIncrement( (LPLONG ) &m_nFlushes); }

# define INCREMENT_ENTRIES( fRet)  \
       if ( fRet) { InterlockedIncrement( (LPLONG ) &m_nEntries); }

# define DECREMENT_ENTRIES( fRet)  \
       if ( fRet) { InterlockedDecrement( (LPLONG ) &m_nEntries); }

HT_ELEMENT *
HASH_TABLE::Lookup( IN LPCSTR pszKey, DWORD cchKey)
{
    // 1. Calculate the hash value for pszKey
    // 2. Find the bucket for the hash value
    // 3. Search for given item in the bucket
    // 4. return the result, after updating statistics

    DWORD hashVal = CalculateHash( pszKey, cchKey);
    HT_ELEMENT * phte;

    INCREMENT_LOOKUPS();

    DBG_ASSERT( NULL != m_prgBuckets);
    phte = m_prgBuckets[hashVal % m_nBuckets].Lookup( hashVal, pszKey, cchKey);

    INCREMENT_HITS( phte);

    return ( phte);
} // HASH_TABLE::Lookup()


BOOL
HASH_TABLE::Insert( HT_ELEMENT * phte, IN BOOL fCheckBeforeInsert)
{
    // 1. Calculate the hash value for key of the HT_ELEMENT object
    // 2. Find the bucket for the hash value
    // 3. Check if this item is not already present and insert
    //     it into the hash table.
    //  (the check can be bypassed if fCheck is set to FALSE)
    // 4. return the result, after updating statistics

    DWORD hashVal = CalculateHash( phte->QueryKey(),
                                   phte->QueryKeyLen() );
    BOOL  fRet;

    INCREMENT_INSERTS();

    DBG_ASSERT( NULL != m_prgBuckets);
    fRet = m_prgBuckets[hashVal % m_nBuckets].Insert( hashVal,
                                                      phte,
                                                      fCheckBeforeInsert);

    IF_DEBUG( ERROR) {
        if ( !fRet) {
            DBGPRINTF(( DBG_CONTEXT,
                        " Unable to insert %08x into bucket %d."
                        "  Bucket has %d elements. Error = %d\n",
                        phte, hashVal % m_nBuckets,
                        m_prgBuckets[hashVal % m_nBuckets].NumEntries(),
                        GetLastError()
                        ));
        }
    }
    INCREMENT_ENTRIES( fRet);

    return ( fRet);
} // HASH_TABLE::Insert()



BOOL
HASH_TABLE::Delete( HT_ELEMENT * phte)
{
    BOOL  fRet;
    DWORD hashVal = CalculateHash( phte->QueryKey(), phte->QueryKeyLen());

    DBG_ASSERT( NULL != m_prgBuckets);
    fRet = m_prgBuckets[hashVal % m_nBuckets].Delete( phte);

    DECREMENT_ENTRIES( fRet);

    return ( fRet);
} // HASH_TABLE::Delete()



VOID
HASH_TABLE::Print( IN DWORD level)
{
    DWORD i;

    DBGPRINTF(( DBG_CONTEXT,
                "HASH_TABLE(%08x) "
                "%s: nBuckets = %d; dwFlags = %d;"
                " nEntries = %d; nLookups = %d; nHits = %d;"
                " nInserts = %d; nFlushes = %d;"
                " m_prgBuckets = %d\n",
                this, m_rgchId, m_nBuckets, m_dwFlags,
                m_nEntries, m_nLookups, m_nHits, m_nInserts,
                m_nFlushes, m_prgBuckets));

    if ( level == 0 ) {

        CHAR rgchBuff[2000];
        DWORD cch;

        cch = wsprintfA( rgchBuff, "\tBucket  NumEntries\n");
        DBG_ASSERT( NULL != m_prgBuckets);
        for (i = 0; i < m_nBuckets; i++) {

            cch += wsprintf( rgchBuff + cch, "\t[%4d]  %4d,\n",
                             i, m_prgBuckets[i].NumEntries());
        } // for

        DBGDUMP(( DBG_CONTEXT, rgchBuff));
    } else {

        DBG_ASSERT( NULL != m_prgBuckets);
        for (i = 0; i < m_nBuckets; i++) {

            m_prgBuckets[i].Print( level);
        } // for
    }

    return;
} // HASH_TABLE::Print()



DWORD
HASH_TABLE::InitializeIterator( IN HT_ITERATOR * phti)
{
    DWORD dwErr = ERROR_NO_MORE_ITEMS;
    DBG_ASSERT( IsValid());
    DBG_ASSERT( NULL != phti);

    // initialize the iterator
    phti->nBucketNumber = INFINITE;
    phti->nChunkId = NULL;
    phti->nPos = 0;

    if ( m_nEntries > 0) {
        // set the iterator to point to the first bucket with some elements.
        for ( DWORD i = 0; (i < m_nBuckets); i++) {

            dwErr = m_prgBuckets[i].InitializeIterator( phti);
            if ( dwErr == NO_ERROR) {
                phti->nBucketNumber = i;
                break;
            }
        }
    }

    return ( dwErr);
} // HASH_TABLE::InitializeIterator()


DWORD
HASH_TABLE::FindNextElement( IN HT_ITERATOR * phti,
                             OUT HT_ELEMENT ** pphte)
{
    DWORD dwErr = ERROR_NO_MORE_ITEMS;
    DBG_ASSERT( IsValid());
    DBG_ASSERT( NULL != phti);
    DBG_ASSERT( NULL != pphte);

    if ( INFINITE != phti->nBucketNumber) {

        // iterator has some valid state use it.
        DBG_ASSERT( phti->nBucketNumber < m_nBuckets);

        dwErr =
            m_prgBuckets[ phti->nBucketNumber].FindNextElement( phti, pphte);

        if ( ERROR_NO_MORE_ITEMS == dwErr) {

            DBG_REQUIRE( m_prgBuckets[ phti->nBucketNumber].
                            CloseIterator( phti)
                         == NO_ERROR
                        );

            // hunt for the next bucket with an element.
            for ( DWORD i = (phti->nBucketNumber + 1); (i < m_nBuckets); i++) {

                dwErr = m_prgBuckets[i].InitializeIterator( phti);

                if ( dwErr == NO_ERROR) {
                    phti->nBucketNumber = i;
                    dwErr = m_prgBuckets[ i].FindNextElement( phti, pphte);
                    DBG_ASSERT( dwErr == NO_ERROR);
                    break;
                }
            } // for

            if ( ERROR_NO_MORE_ITEMS == dwErr) {
                // reset the bucket number
                phti->nBucketNumber = INFINITE;
            }
        }
    }

    return ( dwErr);
} // HASH_TABLE::FindNextElement()


DWORD
HASH_TABLE::CloseIterator( IN HT_ITERATOR * phti)
{
    DBG_ASSERT( IsValid());
    DBG_ASSERT( NULL != phti);

    if ( INFINITE != phti->nBucketNumber) {
        DBG_ASSERT( phti->nBucketNumber < m_nBuckets);
        DBG_REQUIRE( m_prgBuckets[ phti->nBucketNumber].
                     CloseIterator( phti)
                     == NO_ERROR
                     );
        phti->nBucketNumber = INFINITE;
    }

    return ( NO_ERROR);
} // HASH_TABLE::CloseIterator()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\irtldbg.cpp ===
// Implementation of debug support functions

#include "precomp.hxx"

#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <malloc.h>

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <irtldbg.h>


IRTL_DLLEXP
void __cdecl
IrtlTrace(
    LPCTSTR ptszFormat,
    ...)
{
    TCHAR tszBuff[2048];
    va_list args;
    
    va_start(args, ptszFormat);
    _vstprintf(tszBuff, ptszFormat, args);
    va_end(args);

    DBGPRINTF((DBG_CONTEXT, tszBuff));
}



#ifdef _DEBUG

# if defined(USE_DEBUG_CRTS)  &&  defined(_MSC_VER)  &&  (_MSC_VER >= 1000)


#  ifdef RUNNING_AS_SERVICE

// The default assertion mechanism set up by Visual C++ 4 will not
// work with Active Server Pages because it's running inside a service
// and there is no desktop to interact with.

// Note: for this to work properly, #define _WIN32_WINNT 0x400 before
// including <winuser.h> or MB_SERVICE_NOTIFICATION won't be #define'd.

int __cdecl
AspAssertHandler(
    int   nReportType,
    char* pszErrorText,
    int*  pnReturn)
{
    const char szInfo[] = " (Press ABORT to terminate IIS,"
                          " RETRY to debug this failure,"
                          " or IGNORE to continue.)";
    char* pszMessageTitle = NULL;
    
    // These flags enable message boxes to show up on the user's console
    switch (nReportType)
    {
    case _CRT_WARN:
        // If using MFC's TRACE macro (AfxTrace), the report hook
        // (AspAssertHandler) will get called with _CRT_WARN.  Ignore.
        pszMessageTitle = "Warning";
        *pnReturn = 0;
        return FALSE;

    case _CRT_ERROR:
        pszMessageTitle = "Fatal Error";
        break;

    case _CRT_ASSERT:
        pszMessageTitle = "Assertion Failed";
        break;
    }   
    
    char* pszMessageText =
        static_cast<char*>(_alloca(strlen(pszErrorText) + strlen(szInfo) + 1));

    strcpy(pszMessageText, pszErrorText);
    strcat(pszMessageText, szInfo);
    
    const int n = MessageBoxA(NULL, pszMessageText, pszMessageTitle,
                              (MB_SERVICE_NOTIFICATION | MB_TOPMOST
                               | MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION));

    if (n == IDABORT)
    {
        exit(1);
    }
    else if (n == IDRETRY)
    {
        *pnReturn = 1;   // tell _CrtDbgReport to start the debugger
        return TRUE;     // tell _CrtDbgReport to run
    }
    
    *pnReturn = 0;       // nothing for _CrtDbgReport to do

    return FALSE;
}

#  endif // RUNNING_AS_SERVICE
# endif // _MSC_VER >= 1000



void
IrtlDebugInit()
{
# if defined(USE_DEBUG_CRTS)  &&  defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef RUNNING_AS_SERVICE
    // If we end up in _CrtDbgReport, don't put up a message box
    // _CrtSetReportMode(_CRT_WARN,   _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ERROR,  _CRTDBG_MODE_DEBUG);

    // Use AspAssertHandler to put up a message box instead
    _CrtSetReportHook(AspAssertHandler);
#  endif // RUNNING_AS_SERVICE

    
    // Enable debug heap allocations & check for memory leaks at program exit
    // The memory leak check will not be performed if inetinfo.exe is
    // run directly under a debugger, only if it is run as a service.
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF
                   | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
# endif // _MSC_VER >= 1000
}



void
IrtlDebugTerm()
{
# if defined(USE_DEBUG_CRTS)  &&  defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef RUNNING_AS_SERVICE
    // Turn off AspAssertHandler, so that we don't get numerous message boxes
    // if there are memory leaks on shutdown
    _CrtSetReportHook(NULL);
#  endif // RUNNING_AS_SERVICE
# endif // _MSC_VER >= 1000
}

#endif //_DEBUG



BOOL
IsValidString(
    LPCTSTR ptsz,
    int nLength /* =-1 */)
{
    if (ptsz == NULL)
        return FALSE;

    return !IsBadStringPtr(ptsz, nLength);
}



BOOL
IsValidAddress(
    LPCVOID pv,
    UINT nBytes,
    BOOL fReadWrite /* =TRUE */)
{
    return (pv != NULL
            &&  !IsBadReadPtr(pv, nBytes)
            &&  (!fReadWrite  ||  !IsBadWritePtr((LPVOID) pv, nBytes)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\isplat.cxx ===
/*++

    Copyright (c) 1996  Microsoft Corporation

    Module  Name :
        isplat.cxx

    Abstract:

        This module defines functions for determining platform types

    Author:

        Johnson Apacible    (johnsona)      19-Nov-1996

        Murali Krishnan     (MuraliK)       17-Apr-1997
                   Added CriticalSectionWith SpinCount stuff (moved to locks.cxx)
--*/

#include "precomp.hxx"

#include <inetsvcs.h>

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <locks.h>


typedef
BOOLEAN
(NTAPI *GET_PRODUCT_TYPE)(
            PNT_PRODUCT_TYPE
            );

extern "C"
PLATFORM_TYPE
IISGetPlatformType(
        VOID
        )
/*++

  This function consults the registry and determines the platform type
   for this machine.

  Arguments:

    None

  Returns:
    Platform type

--*/
{
    PLATFORM_TYPE pt;
    LONG result;
    HKEY keyHandle;
    WCHAR productType[30];
    DWORD type;
    BOOL isNt = TRUE;

    OSVERSIONINFO osInfo;

    //
    // See if the platform type has already been discovered.
    //

    if ( g_PlatformType != PtInvalid ) {
        return(g_PlatformType);
    }

    //
    // see if this is win95
    //

    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( GetVersionEx( &osInfo ) ) {
        isNt = (osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
    } else {
        IIS_PRINTF((buff,"GetVersionEx failed with %d\n",
                    GetLastError()));
    }

    if ( isNt ) {

        HINSTANCE hNtdll;
        NT_PRODUCT_TYPE ntType;
        GET_PRODUCT_TYPE pfnGetProductType;

        //
        // Get the product type from the system
        //

        pt = PtNtWorkstation;
        hNtdll = LoadLibrary("ntdll.dll");
        if ( hNtdll != NULL ) {

            pfnGetProductType = (GET_PRODUCT_TYPE)
                GetProcAddress(hNtdll, "RtlGetNtProductType");

            if ( (pfnGetProductType != NULL) &&
                  pfnGetProductType( &ntType ) ) {

                if ( (ntType == NtProductLanManNt) ||
                     (ntType == NtProductServer) ) {

                    pt = PtNtServer;
                }
            }

            FreeLibrary( hNtdll );
        }

    } else {
        pt = PtWindows95;
    }

    g_PlatformType = pt;
    return(pt);

} // IISGetPlatformType



// Thunking wrapper for ::SetCriticalSectionSpinCount that will work on
// systems that don't have this API in kernel32

DWORD
IISSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount)
{
    return CCritSec::SetSpinCount(lpCriticalSection, dwSpinCount);
}


// Thunking wrapper for ::InitializeCriticalSectionAndSpinCount that will
// work on systems that don't have this API in kernel32.  Sets the spin count
// to the IIS default, IIS_DEFAULT_CS_SPIN_COUNT, which is defined in
// <pudebug.h>

VOID
IISInitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection)
{
    InitializeCriticalSection(lpCriticalSection);
    CCritSec::SetSpinCount(lpCriticalSection, IIS_DEFAULT_CS_SPIN_COUNT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\lkrhash.cpp ===
/*++

   Copyright    (c) 1998-2001    Microsoft Corporation

   Module  Name :
       LKRhash.cpp

   Abstract:
       Implements LKRhash: a fast, scalable, cache- and MP-friendly hash table

   Author:
       Paul (Per-Ake) Larson, palarson@microsoft.com, July 1997
       Murali R. Krishnan    (MuraliK)
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:
       Jan 1998   - Massive cleanup and rewrite.  Templatized.
       10/01/1998 - Change name from LKhash to LKRhash

--*/

#include "precomp.hxx"


#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <lkrhash.h>

#ifdef __LKRHASH_NAMESPACE__
namespace LKRHash {
#endif // __LKRHASH_NAMESPACE__



#ifdef LKRHASH_ALLOCATOR_NEW

# define DECLARE_ALLOCATOR(CLASS)                        \
  CLKRhashAllocator* CLASS::sm_palloc = NULL;            \

# define DECLARE_ALLOCATOR_LHTSUBCLASS(CLASS)            \
  CLKRhashAllocator* CLKRLinearHashTable::CLASS::sm_palloc = NULL; \


  // DECLARE_ALLOCATOR(CLKRLinearHashTable);
  // DECLARE_ALLOCATOR(CLKRHashTable);
  DECLARE_ALLOCATOR_LHTSUBCLASS(CNodeClump);
  DECLARE_ALLOCATOR_LHTSUBCLASS(CSmallSegment);
  DECLARE_ALLOCATOR_LHTSUBCLASS(CMediumSegment);
  DECLARE_ALLOCATOR_LHTSUBCLASS(CLargeSegment);

#endif // LKRHASH_ALLOCATOR_NEW


static bool s_fInitialized = false;


// -------------------------------------------------------------------------
// Initialize per-class allocators
// -------------------------------------------------------------------------

bool
LKRHashTableInit()
{
    bool f = true;

    TRACE("LKRHashTableInit\n");

#define INIT_ALLOCATOR(CLASS, N)                                \
    LKRHASH_ALLOCATOR_INIT(CLASS, N, f);                         \

#define INIT_ALLOCATOR_LHTSUBCLASS(CLASS, N)                    \
    LKRHASH_ALLOCATOR_INIT(CLKRLinearHashTable::CLASS, N, f);     \


    // INIT_ALLOCATOR(CLKRLinearHashTable,        20);
    // INIT_ALLOCATOR(CLKRHashTable,               4);
    INIT_ALLOCATOR_LHTSUBCLASS(CNodeClump,    200);
    INIT_ALLOCATOR_LHTSUBCLASS(CSmallSegment,   5);
    INIT_ALLOCATOR_LHTSUBCLASS(CMediumSegment,  5);
    INIT_ALLOCATOR_LHTSUBCLASS(CLargeSegment,   5);

    s_fInitialized = f;

    return f;
} // LKRHashTableInit



// -------------------------------------------------------------------------
// Destroy per-class allocators
// -------------------------------------------------------------------------

void
LKRHashTableUninit()
{
#define UNINIT_ALLOCATOR(CLASS)                        \
    LKRHASH_ALLOCATOR_UNINIT(CLASS);                    \

#define UNINIT_ALLOCATOR_LHTSUBCLASS(CLASS)            \
    LKRHASH_ALLOCATOR_UNINIT(CLKRLinearHashTable::CLASS);\

    s_fInitialized = false;

    // UNINIT_ALLOCATOR(CLKRLinearHashTable);
    // UNINIT_ALLOCATOR(CLKRHashTable);
    UNINIT_ALLOCATOR_LHTSUBCLASS(CNodeClump);
    UNINIT_ALLOCATOR_LHTSUBCLASS(CSmallSegment);
    UNINIT_ALLOCATOR_LHTSUBCLASS(CMediumSegment);
    UNINIT_ALLOCATOR_LHTSUBCLASS(CLargeSegment);

    TRACE("LKRHashTableUninit done\n");
} // LKRHashTableUninit



// -------------------------------------------------------------------------
// class static member variables
// -------------------------------------------------------------------------

#ifdef LOCK_INSTRUMENTATION
LONG CLKRLinearHashTable::CBucket::sm_cBuckets    = 0;

LONG CLKRLinearHashTable::sm_cTables              = 0;
#endif // LOCK_INSTRUMENTATION


#ifdef LKR_NEWCODE
CLockedDoubleList CLKRLinearHashTable::sm_llGlobalList;
CLockedDoubleList CLKRHashTable::sm_llGlobalList;
#endif // LKR_NEWCODE



// CLKRLinearHashTable --------------------------------------------------------
// Public Constructor for class CLKRLinearHashTable.
// -------------------------------------------------------------------------

CLKRLinearHashTable::CLKRLinearHashTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Upperbound on the average chain length
    DWORD           initsize,       // Initial size of hash table.
    DWORD         /*num_subtbls*/   // for compatiblity with CLKRHashTable
    )
    :
#ifdef LOCK_INSTRUMENTATION
      m_Lock(_LockName()),
#endif // LOCK_INSTRUMENTATION
#ifdef LKR_NEWCODE
      m_nTableLockType(TableLock::LockType()),
      m_nBucketLockType(BucketLock::LockType()),
      m_phtParent(NULL)
#endif // LKR_NEWCODE
{
    IRTLVERIFY(LK_SUCCESS
               == _Initialize(pfnExtractKey, pfnCalcKeyHash, pfnEqualKeys,
                              pfnAddRefRecord, pszName, maxload, initsize));

#ifdef LKR_NEWCODE
    _InsertThisIntoGlobalList();
#endif // LKR_NEWCODE
} // CLKRLinearHashTable::CLKRLinearHashTable



#ifdef LKR_NEWCODE

// CLKRLinearHashTable --------------------------------------------------------
// Private Constructor for class CLKRLinearHashTable, used by CLKRHashTable.
// -------------------------------------------------------------------------

CLKRLinearHashTable::CLKRLinearHashTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Upperbound on the average chain length
    DWORD           initsize,       // Initial size of hash table.
    CLKRHashTable*  phtParent       // Owning table.
    )
    :
#ifdef LOCK_INSTRUMENTATION
      m_Lock(_LockName()),
#endif // LOCK_INSTRUMENTATION
      m_nTableLockType(TableLock::LockType()),
      m_nBucketLockType(BucketLock::LockType()),
      m_phtParent(phtParent)
{
    IRTLASSERT(m_phtParent != NULL);
    IRTLVERIFY(LK_SUCCESS
               == _Initialize(pfnExtractKey, pfnCalcKeyHash, pfnEqualKeys,
                              pfnAddRefRecord, pszName, maxload, initsize));

    _InsertThisIntoGlobalList();
} // CLKRLinearHashTable::CLKRLinearHashTable

#endif // LKR_NEWCODE


// _Initialize -------------------------------------------------------------
// Do all the real work of constructing a CLKRLinearHashTable
// -------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Initialize(
    PFnExtractKey   pfnExtractKey,
    PFnCalcKeyHash  pfnCalcKeyHash,
    PFnEqualKeys    pfnEqualKeys,
    PFnAddRefRecord pfnAddRefRecord,
    LPCSTR          pszName,
    double          maxload,
    DWORD           initsize)
{
    m_dwSignature =     SIGNATURE;
    m_dwBktAddrMask =   0;
#ifdef LKR_MASK
    m_dwBktAddrMask1 =  0;
#endif // LKR_MASK
    m_iExpansionIdx =   0;
    m_paDirSegs =       NULL;
    m_lkts =            LK_MEDIUM_TABLESIZE;
    m_dwSegBits =       0;
    m_dwSegSize =       0;
    m_dwSegMask =       0;
    m_lkrcState =       LK_UNUSABLE;
    m_MaxLoad =         LK_DFLT_MAXLOAD;
    m_nLevel =          0;
    m_cDirSegs =        0;
    m_cRecords =        0;
    m_cActiveBuckets =  0;
    m_wBucketLockSpins= LOCK_USE_DEFAULT_SPINS;
    m_pfnExtractKey =   pfnExtractKey;
    m_pfnCalcKeyHash =  pfnCalcKeyHash;
    m_pfnEqualKeys =    pfnEqualKeys;
    m_pfnAddRefRecord = pfnAddRefRecord;

    strncpy(m_szName, pszName, NAME_SIZE-1);
    m_szName[NAME_SIZE-1] = '\0';

    IRTLASSERT(m_pfnExtractKey != NULL
               && m_pfnCalcKeyHash != NULL
               && m_pfnEqualKeys != NULL
               && m_pfnAddRefRecord != NULL);

    IRTLASSERT(s_fInitialized);

    if (!s_fInitialized)
        return (m_lkrcState = LK_NOT_INITIALIZED);

    if (m_pfnExtractKey == NULL
            || m_pfnCalcKeyHash == NULL
            || m_pfnEqualKeys == NULL
            || m_pfnAddRefRecord == NULL)
        return (m_lkrcState = LK_BAD_PARAMETERS);

    // TODO: better sanity check for ridiculous values?
    m_MaxLoad = (maxload <= 1.0)  ?  LK_DFLT_MAXLOAD  :  maxload;
    m_MaxLoad = min(m_MaxLoad, 10 * NODES_PER_CLUMP);

    // Choose the size of the segments according to the desired "size" of
    // the table, small, medium, or large.
    LK_TABLESIZE lkts;

    if (initsize == LK_SMALL_TABLESIZE)
    {
        lkts = LK_SMALL_TABLESIZE;
        initsize = CSmallSegment::INITSIZE;
    }
    else if (initsize == LK_MEDIUM_TABLESIZE)
    {
        lkts = LK_MEDIUM_TABLESIZE;
        initsize = CMediumSegment::INITSIZE;
    }
    else if (initsize == LK_LARGE_TABLESIZE)
    {
        lkts = LK_LARGE_TABLESIZE;
        initsize = CLargeSegment::INITSIZE;
    }

    // specified an explicit initial size
    else
    {
        // force Small::INITSIZE <= initsize <= MAX_DIRSIZE * Large::INITSIZE
        initsize = min(max(initsize, CSmallSegment::INITSIZE),
                       (MAX_DIRSIZE >> CLargeSegment::SEGBITS)
                            * CLargeSegment::INITSIZE);

        // Guess a table size
        if (initsize <= 8 * CSmallSegment::INITSIZE)
            lkts = LK_SMALL_TABLESIZE;
        else if (initsize >= CLargeSegment::INITSIZE)
            lkts = LK_LARGE_TABLESIZE;
        else
            lkts = LK_MEDIUM_TABLESIZE;
    }

    m_cActiveBuckets = initsize;
    _SetSegVars(lkts);

    return m_lkrcState;
} // CLKRLinearHashTable::_Initialize



// CLKRHashTable ----------------------------------------------------------
// Constructor for class CLKRHashTable.
// ---------------------------------------------------------------------

CLKRHashTable::CLKRHashTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Bound on the average chain length
    DWORD           initsize,       // Initial size of hash table.
    DWORD           num_subtbls     // Number of subordinate hash tables.
    )
    : m_dwSignature(SIGNATURE),
      m_cSubTables(0),
      m_palhtDir(NULL),
      m_pfnExtractKey(pfnExtractKey),
      m_pfnCalcKeyHash(pfnCalcKeyHash),
      m_lkrcState(LK_BAD_PARAMETERS)
{
    strncpy(m_szName, pszName, NAME_SIZE-1);
    m_szName[NAME_SIZE-1] = '\0';

#ifdef LKR_NEWCODE
    _InsertThisIntoGlobalList();
#endif // LKR_NEWCODE

    IRTLASSERT(pfnExtractKey != NULL
               && pfnCalcKeyHash != NULL
               && pfnEqualKeys != NULL
               && pfnAddRefRecord != NULL);

    if (pfnExtractKey == NULL
            || pfnCalcKeyHash == NULL
            || pfnEqualKeys == NULL
            || pfnAddRefRecord == NULL)
        return;

    LK_TABLESIZE lkts = NumSubTables(initsize, num_subtbls);

#ifdef _DEBUG
    int cBuckets = initsize;
    if (initsize == LK_SMALL_TABLESIZE)
        cBuckets = SubTable::CSmallSegment::INITSIZE;
    else if (initsize == LK_MEDIUM_TABLESIZE)
        cBuckets = SubTable::CMediumSegment::INITSIZE;
    else if (initsize == LK_LARGE_TABLESIZE)
        cBuckets = SubTable::CLargeSegment::INITSIZE;

    TRACE("CLKRHashTable: %s, %d subtables, initsize = %d, "
          "total #buckets = %d\n",
          ((lkts == LK_SMALL_TABLESIZE) ? "small" : 
           (lkts == LK_MEDIUM_TABLESIZE) ? "medium" : "large"),
          num_subtbls, initsize, cBuckets * num_subtbls);
#endif

    m_lkrcState = LK_ALLOC_FAIL;
    m_palhtDir  = _AllocateSubTableArray(num_subtbls);

    if (m_palhtDir == NULL)
        return;
    else
    {
        m_cSubTables = num_subtbls;
        for (DWORD i = 0;  i < m_cSubTables;  i++)
            m_palhtDir[i] = NULL;
    }

    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i] = _AllocateSubTable(pszName, pfnExtractKey,
                                          pfnCalcKeyHash, pfnEqualKeys,
                                          pfnAddRefRecord, maxload,
                                          initsize, this);

        // Failed to allocate a subtable.  Destroy everything allocated so far.
        if (m_palhtDir[i] == NULL  ||  !m_palhtDir[i]->IsValid())
        {
            for (DWORD j = i;  j-- > 0;  )
                _FreeSubTable(m_palhtDir[j]);
            _FreeSubTableArray(m_palhtDir);
            m_cSubTables = 0;
            m_palhtDir   = NULL;

            return;
        }
    }

    m_lkrcState = LK_SUCCESS; // so IsValid/IsUsable won't fail
} // CLKRHashTable::CLKRHashTable



// ~CLKRLinearHashTable ------------------------------------------------------
// Destructor for class CLKRLinearHashTable
//-------------------------------------------------------------------------

CLKRLinearHashTable::~CLKRLinearHashTable()
{
    // must acquire all locks before deleting to make sure
    // that no other threads are using the table
    WriteLock();
    _Clear(false);
    WriteUnlock();

#ifdef LKR_NEWCODE
    _RemoveThisFromGlobalList();
#endif // LKR_NEWCODE

    m_dwSignature = SIGNATURE_FREE;
    m_lkrcState = LK_UNUSABLE; // so IsUsable will fail
} // CLKRLinearHashTable::~CLKRLinearHashTable



// ~CLKRHashTable ------------------------------------------------------------
// Destructor for class CLKRHashTable
//-------------------------------------------------------------------------
CLKRHashTable::~CLKRHashTable()
{
    // delete in reverse order, just like delete[].
    for (DWORD i = m_cSubTables;  i-- > 0;  )
        _FreeSubTable(m_palhtDir[i]);

    _FreeSubTableArray(m_palhtDir);

#ifdef LKR_NEWCODE
    _RemoveThisFromGlobalList();
#endif // LKR_NEWCODE

    m_dwSignature = SIGNATURE_FREE;
    m_lkrcState = LK_UNUSABLE; // so IsUsable will fail
} // CLKRHashTable::~CLKRHashTable



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::NumSubTables
// Synopsis: 
//------------------------------------------------------------------------

LK_TABLESIZE
CLKRLinearHashTable::NumSubTables(
    DWORD& rinitsize,
    DWORD& rnum_subtbls)
{
    LK_TABLESIZE lkts = LK_MEDIUM_TABLESIZE;

    return lkts;
} // CLKRLinearHashTable::NumSubTables



//------------------------------------------------------------------------
// Function: CLKRHashTable::NumSubTables
// Synopsis: 
//------------------------------------------------------------------------

LK_TABLESIZE
CLKRHashTable::NumSubTables(
    DWORD& rinitsize,
    DWORD& rnum_subtbls)
{
    LK_TABLESIZE lkts;
    
    // Establish the table size
    if (rinitsize == LK_SMALL_TABLESIZE
        ||  rinitsize == LK_MEDIUM_TABLESIZE
        ||  rinitsize == LK_LARGE_TABLESIZE)
    {
        lkts = static_cast<LK_TABLESIZE>(rinitsize);
    }
    else
    {
        if (rnum_subtbls != LK_DFLT_NUM_SUBTBLS)
        {
            rinitsize = (rinitsize - 1) / rnum_subtbls + 1;

            if (rinitsize <= SubTable::CSmallSegment::SEGSIZE)
                lkts = LK_SMALL_TABLESIZE;
            else if (rinitsize >= SubTable::CLargeSegment::SEGSIZE)
                lkts = LK_LARGE_TABLESIZE;
            else
                lkts = LK_MEDIUM_TABLESIZE;
        }
        else
        {
            lkts = LK_MEDIUM_TABLESIZE;
        }
    }

    // Choose a suitable number of subtables
    if (rnum_subtbls == LK_DFLT_NUM_SUBTBLS)
    {
        int nCPUs = NumProcessors();
        switch (lkts)
        {
        case LK_SMALL_TABLESIZE:
            rnum_subtbls = min(2, nCPUs);
            break;
        
        case LK_MEDIUM_TABLESIZE:
            rnum_subtbls = 2 * nCPUs;
            break;
        
        case LK_LARGE_TABLESIZE:
            rnum_subtbls = 4 * nCPUs;
            break;
        }
    }

    return lkts;
} // CLKRHashTable::NumSubTables


#ifdef LKR_COMPACT_DELETE

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_IsNodeCompact
// Synopsis: validates that a node is correctly compacted
//------------------------------------------------------------------------

int
CLKRLinearHashTable::_IsNodeCompact(
    CBucket* const pbkt) const
{
    CNodeClump* pncCurr;
    CNodeClump* pncPrev;
    bool fEmpty = pbkt->m_ncFirst.InvalidSignature(0);
    int cErrors = fEmpty ? !pbkt->m_ncFirst.IsLastClump() : 0;

    for (pncCurr = &pbkt->m_ncFirst, pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        for (DWORD i = 0;  i < NODES_PER_CLUMP;  i++)
        {
            if (fEmpty)
            {
                cErrors += (!pncCurr->InvalidSignature(i));
                cErrors += (!pncCurr->IsEmptyNode(i));
            }
            else if (pncCurr->InvalidSignature(i))
            {
                fEmpty = true;
                cErrors += (!pncCurr->IsEmptyNode(i));
                cErrors += (!pncCurr->IsLastClump());
            }
            else // still in non-empty portion
            {
                cErrors += (pncCurr->InvalidSignature(i));
                cErrors += (pncCurr->IsEmptyNode(i));
            }
        }
    }

    return cErrors;
}

#endif // LKR_COMPACT_DELETE


//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_InsertRecord
// Synopsis: Inserts a new record into the hash table. If this causes the
//           average chain length to exceed the upper bound, the table is
//           expanded by one bucket.
// Output:   LK_SUCCESS,    if the record was inserted.
//           LK_KEY_EXISTS, if the record was not inserted (because a record
//               with the same key value already exists in the table, unless
//               fOverwrite==true).
//           LK_ALLOC_FAIL, if failed to allocate the required space
//           LK_UNUSABLE,   if hash table not in usable state
//           LK_BAD_RECORD, if record is bad.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_InsertRecord(
    const void* pvRecord,   // Pointer to the record to add to table
    DWORD       dwSignature,// hash signature
    bool        fOverwrite  // overwrite record if key already present
    )
{
#ifdef LKR_SUBTABLE
    IRTLASSERT(IsUsable()
               &&  pvRecord != NULL
               &&  dwSignature != HASH_INVALID_SIGNATURE);
#else
    if (!IsUsable())
        return LK_UNUSABLE;

    if (pvRecord == NULL)
        return LK_BAD_RECORD;
#endif

    // find the beginning of the correct bucket chain
    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, true);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    WriteUnlock();

    // check that no record with the same key value exists
    // and save a pointer to the last element on the chain
    LK_RETCODE lkrc = LK_SUCCESS;
    CNodeClump* pncFree = NULL;
    int         iFreePos = -1;
    CNodeClump* pncPrev;
    CNodeClump* pncCurr;
    bool        fUpdate = false;
    const DWORD_PTR pnKey = _ExtractKey(pvRecord);

    // walk down the entire bucket chain, looking for matching hash
    // signatures and keys
    for (pncCurr = &pbkt->m_ncFirst, pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        for (DWORD i = 0;  i < NODES_PER_CLUMP;  i++)
        {
#ifdef LKR_COMPACT_DELETE
            if (pncCurr->InvalidSignature(i))
            {
                IRTLASSERT(pncCurr->IsEmptyNode(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());

                pncFree  = pncCurr;
                iFreePos = i;
                goto insert;
            }
#endif // LKR_COMPACT_DELETE

            if (dwSignature == pncCurr->m_dwKeySigs[i]
                &&  _EqualKeys(pnKey,  _ExtractKey(pncCurr->m_pvNode[i])))
            {
                if (fOverwrite)
                {
                    // If we allow overwrites, this is the slot to do it to
                    fUpdate  = true;
                    pncFree  = pncCurr;
                    iFreePos = i;
                    goto insert;
                }
                else
                {
                    // overwrites forbidden: return an error
                    lkrc = LK_KEY_EXISTS;
                    goto exit;
                }
            }

#ifndef LKR_COMPACT_DELETE
            // keep track of the first free slot in the bucket chain
            if (pncFree == NULL  &&  pncCurr->IsEmptyNode(i))
            {
                IRTLASSERT(pncCurr->InvalidSignature(i));
                pncFree  = pncCurr;
                iFreePos = i;
            }
#endif // !LKR_COMPACT_DELETE
        }
    }

  insert:
    if (pncFree != NULL)
    {
        pncCurr = pncFree;
        IRTLASSERT(iFreePos >= 0);
    }
    else
    {
        // No free slots.  Attach the new node to the end of the chain
        IRTLASSERT(iFreePos < 0);
        pncCurr = _AllocateNodeClump();

        if (pncCurr == NULL)
        {
            lkrc = LK_ALLOC_FAIL;
            goto exit;
        }

        IRTLASSERT(pncPrev != NULL  &&  pncPrev->IsLastClump());
        pncPrev->m_pncNext = pncCurr;
        iFreePos = 0;
    }

    // Bump the new record's reference count upwards
    _AddRefRecord(pvRecord, +1);

    if (fUpdate)
    {
        // We're overwriting an existing record.  Adjust the old record's
        // refcount downwards.  (Doing ++new, --old in this order ensures
        // that the refcount won't briefly go to zero if new and old are
        // the same record.)
        IRTLASSERT(!pncCurr->IsEmptyNode(iFreePos));
        _AddRefRecord(pncCurr->m_pvNode[iFreePos], -1);
    }
    else
    {
        IRTLASSERT(pncCurr->IsEmptyNode(iFreePos));
        InterlockedIncrement(reinterpret_cast<LONG*>(&m_cRecords));
    }

    pncCurr->m_dwKeySigs[iFreePos] = dwSignature;
    pncCurr->m_pvNode[iFreePos]    = pvRecord;

  exit:
    pbkt->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        // If the average load factor has grown too high, we grow the
        // table one bucket at a time.
        while (m_cRecords > m_MaxLoad * m_cActiveBuckets)
        {
            // If _Expand returns an error code (viz. LK_ALLOC_FAIL), it
            // just means that there isn't enough spare memory to expand
            // the table by one bucket. This is likely to cause problems
            // elsewhere soon, but this hashtable has not been corrupted.
            // If the call to _AllocateNodeClump above failed, then we do
            // have a real error that must be propagated back to the caller
            // because we were unable to insert the element at all.
            if (_Expand() != LK_SUCCESS)
                break;  // expansion failed
        }
    }

    return lkrc;
} // CLKRLinearHashTable::_InsertRecord



//-------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteKey
// Synopsis: Deletes the record with the given key value from the hash
//           table (if it exists). Holes created by deletions are not filled
//           immediately by moving records around. They will eventually be
//           filled by insertions or reorganizations during expansions or
//           contractions.
// Returns:  LK_SUCCESS, if record found and deleted.
//           LK_NO_SUCH_KEY, if no record with the given key value was found.
//           LK_UNUSABLE, if hash table not in usable state
//-------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_DeleteKey(
    const DWORD_PTR pnKey,      // Key value of the record, depends on key type
    DWORD           dwSignature
    )
{
#ifdef LKR_SUBTABLE
    IRTLASSERT(IsUsable());
#else
    if (!IsUsable())
        return LK_UNUSABLE;
#endif

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, true);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    WriteUnlock();

    // scan down the bucket chain, looking for the victim
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        for (int i = 0;  i < NODES_PER_CLUMP;  i++)
        {
#ifdef LKR_COMPACT_DELETE
            if (pncCurr->InvalidSignature(i))
            {
                IRTLASSERT(pncCurr->IsEmptyNode(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }
#endif // LKR_COMPACT_DELETE

            if (dwSignature == pncCurr->m_dwKeySigs[i]
                &&  _EqualKeys(pnKey,  _ExtractKey(pncCurr->m_pvNode[i])))
            {
                IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));
                lkrc = LK_SUCCESS;
                goto exit;
            }
        }
    }

  exit:
    pbkt->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        // contract the table if necessary
        double maxcontract = 1.0 / static_cast<double>(m_MaxLoad);

        for (int contractions = 0;
             m_cRecords < m_MaxLoad * m_cActiveBuckets
                 &&  m_cActiveBuckets > m_dwSegSize * MIN_DIRSIZE
                 &&  contractions < maxcontract;
             ++contractions)
        {
            // If _Contract returns an error code (viz. LK_ALLOC_FAIL), it
            // just means that there isn't enough spare memory to contract
            // the table by one bucket. This is likely to cause problems
            // elsewhere soon, but this hashtable has not been corrupted.
            if (_Contract() != LK_SUCCESS)
                break;
        }
    }

    return lkrc;
} // CLKRLinearHashTable::_DeleteKey



//-------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteRecord
// Synopsis: Deletes the specified record from the hash table (if it
//           exists). Holes created by deletions are not filled immediately
//           by moving records around. They will eventually be filled by
//           insertions or reorganizations during expansions or
//           contractions.  This is not the same thing as calling
//           DeleteKey(_ExtractKey(pvRecord)).  If that were called for a
//           record that doesn't exist in the table, it could delete some
//           completely unrelated record that happened to have the key.
// Returns:  LK_SUCCESS, if record found and deleted.
//           LK_NO_SUCH_KEY, if the record is not found in the table.
//           LK_UNUSABLE, if hash table not in usable state.
//-------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_DeleteRecord(
    const void* pvRecord,   // Pointer to the record to delete from the table
    DWORD       dwSignature
    )
{
#ifdef LKR_SUBTABLE
    IRTLASSERT(IsUsable()  &&  pvRecord != NULL);
#else
    if (!IsUsable())
        return LK_UNUSABLE;

    if (pvRecord == NULL)
        return LK_NO_SUCH_KEY;
#endif

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, true);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    WriteUnlock();

    const DWORD_PTR pnKey = _ExtractKey(pvRecord);
    IRTLASSERT(dwSignature == _CalcKeyHash(pnKey));

    // scan down the bucket chain, looking for the victim
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        for (int i = 0;  i < NODES_PER_CLUMP;  i++)
        {
#ifdef LKR_COMPACT_DELETE
            if (pncCurr->IsEmptyNode(i))
            {
                IRTLASSERT(pncCurr->InvalidSignature(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }
#endif // LKR_COMPACT_DELETE

            if (pncCurr->m_pvNode[i] == pvRecord)
            {
                IRTLASSERT(_EqualKeys(pnKey,
                                      _ExtractKey(pncCurr->m_pvNode[i])));
                IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[i]);
                IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));
                lkrc = LK_SUCCESS;
                goto exit;
            }
        }
    }

  exit:
    pbkt->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        // contract the table if necessary
        double maxcontract = 1.0 / static_cast<double>(m_MaxLoad);

        for (int contractions = 0;
             m_cRecords < m_MaxLoad * m_cActiveBuckets
                 &&  m_cActiveBuckets > m_dwSegSize * MIN_DIRSIZE
                 &&  contractions < maxcontract;
             ++contractions)
        {
            // If _Contract returns an error code (viz. LK_ALLOC_FAIL), it
            // just means that there isn't enough spare memory to contract
            // the table by one bucket. This is likely to cause problems
            // elsewhere soon, but this hashtable has not been corrupted.
            if (_Contract() != LK_SUCCESS)
                break;
        }
    }

    return lkrc;
} // CLKRLinearHashTable::_DeleteRecord



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteNode
// Synopsis: Deletes a node; removes the node clump if empty
// Returns:  true if successful
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_DeleteNode(
    CBucket*     pbkt,      // bucket chain containing node
    CNodeClump*& rpnc,      // actual node
    CNodeClump*& rpncPrev,  // predecessor of actual node, or NULL
    int&         riNode)    // index within node
{
    IRTLASSERT(pbkt != NULL  &&  pbkt->IsWriteLocked());
    IRTLASSERT(rpnc != NULL);
    IRTLASSERT(rpncPrev == NULL  ||  rpncPrev->m_pncNext == rpnc);
    IRTLASSERT(0 <= riNode  &&  riNode < NODES_PER_CLUMP);
    IRTLASSERT(!rpnc->IsEmptyNode(riNode));
    IRTLASSERT(!rpnc->InvalidSignature(riNode));

#ifdef _DEBUG
    // Check that the node clump really does belong to the bucket
    CNodeClump* pnc1 = &pbkt->m_ncFirst;

    while (pnc1 != NULL  &&  pnc1 != rpnc)
         pnc1 = pnc1->m_pncNext;

    IRTLASSERT(pnc1 == rpnc);
#endif // _DEBUG

    // Release the reference to the record
    _AddRefRecord(rpnc->m_pvNode[riNode], -1);

#ifdef LKR_COMPACT_DELETE
    IRTLASSERT(0 == _IsNodeCompact(pbkt));

    // Compact the nodeclump by moving the very last node back to the
    // newly freed slot
    CNodeClump* pnc2 = rpnc;
    int iNode2 = riNode;

    // Find the last nodeclump in the chain
    while (!pnc2->IsLastClump())
    {
         pnc2 = pnc2->m_pncNext;
         iNode2 = 0;
    }

    IRTLASSERT(0 <= iNode2  &&  iNode2 < NODES_PER_CLUMP);
    IRTLASSERT(!pnc2->InvalidSignature(iNode2));
    // Find the first empty slot in the nodeclump
    while (iNode2 < NODES_PER_CLUMP  &&  !pnc2->InvalidSignature(iNode2))
    {
        iNode2++;
    }

    // Back up to last non-empty slot
    --iNode2;
    IRTLASSERT(0 <= iNode2  &&  iNode2 < NODES_PER_CLUMP
               &&  !pnc2->InvalidSignature(iNode2));
    IRTLASSERT(iNode2+1 == NODES_PER_CLUMP
               ||  pnc2->InvalidSignature(iNode2+1));

#ifdef _DEBUG
    // Check that all the remaining nodes are empty
    IRTLASSERT(pnc2->IsLastClump());
    for (int iNode3 = iNode2 + 1;  iNode3 < NODES_PER_CLUMP;  ++iNode3)
    {
        IRTLASSERT(pnc2->InvalidSignature(iNode3)
                   &&  pnc2->IsEmptyNode(iNode3));
    }
#endif // _DEBUG

    // Move the last node's data back to the current node
    rpnc->m_pvNode[riNode]    = pnc2->m_pvNode[iNode2];
    rpnc->m_dwKeySigs[riNode] = pnc2->m_dwKeySigs[iNode2];

    // Blank the old last node.
    // Correct even if (rpnc, riNode) == (pnc2, iNode2).
    pnc2->m_pvNode[iNode2]    = NULL;
    pnc2->m_dwKeySigs[iNode2] = HASH_INVALID_SIGNATURE;

    IRTLASSERT(0 == _IsNodeCompact(pbkt));

    // Back up riNode by one, so that the next iteration of the loop
    // calling _DeleteNode will end up pointing to the same spot.
    if (riNode != 0)
    {
        riNode--;
    }
    else
    {
        // rewind rpnc and rpncPrev to previous node
        if (rpnc == &pbkt->m_ncFirst)
        {
            riNode = -1;
        }
        else
        {
            riNode = NODES_PER_CLUMP;
            rpnc = rpncPrev;
            if (rpnc == &pbkt->m_ncFirst)
            {
                rpncPrev = NULL;
            }
            else
            {
                for (rpncPrev = &pbkt->m_ncFirst;
                     rpncPrev->m_pncNext != rpnc;
                     rpncPrev = rpncPrev->m_pncNext)
                {}
            }
        }
    }

    // Is the last node clump now completely empty?  Delete, if possible
    if (iNode2 == 0  &&  pnc2 != &pbkt->m_ncFirst)
    {
        // Find preceding nodeclump
        CNodeClump* pnc3 = &pbkt->m_ncFirst;
        while (pnc3->m_pncNext != pnc2)
        {
            pnc3 = pnc3->m_pncNext;
            IRTLASSERT(pnc3 != NULL);
        }

        pnc3->m_pncNext = NULL;
#ifdef _DEBUG
        pnc2->m_pncNext = NULL; // or dtor will ASSERT
#endif // _DEBUG
        _FreeNodeClump(pnc2);
    }

#else // !LKR_COMPACT_DELETE

    // Delete the node from the table
    rpnc->m_pvNode[riNode]    = NULL;
    rpnc->m_dwKeySigs[riNode] = HASH_INVALID_SIGNATURE;

    // Is clump empty now?  Delete it, if possible
    if (rpncPrev != NULL)
    {
        bool fEmpty = true;
        for (int j = 0;  j < NODES_PER_CLUMP;  j++)
        {
            if (!rpnc->IsEmptyNode(j))
            {
                fEmpty = false;
                break;
            }
        }

        // if clump is now empty, disconnect and delete it.
        if (fEmpty)
        {
            IRTLASSERT(rpnc != &pbkt->m_ncFirst);
            IRTLASSERT(rpncPrev->m_pncNext == rpnc);
            rpncPrev->m_pncNext = rpnc->m_pncNext;
#ifdef _DEBUG
            rpnc->m_pncNext = NULL; // or dtor will ASSERT
#endif // _DEBUG
            _FreeNodeClump(rpnc);

            // Reset these to point to the end of the preceding clump so
            // that the calling procedure's loop variables aren't pointing
            // into limbo.
            rpnc   = rpncPrev;
            riNode = NODES_PER_CLUMP;
            if (rpnc == &pbkt->m_ncFirst)
                rpncPrev = NULL;
            else
            {
                for (rpncPrev = &pbkt->m_ncFirst;
                     rpncPrev->m_pncNext != rpnc;
                     rpncPrev = rpncPrev->m_pncNext)
                {}
            }
        }
    }

#endif // !LKR_COMPACT_DELETE

    IRTLASSERT(rpncPrev == NULL  ||  rpncPrev->m_pncNext == rpnc);

    InterlockedDecrement(reinterpret_cast<LONG*>(&m_cRecords));

    return true;
} // CLKRLinearHashTable::_DeleteNode



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FindKey
// Synopsis: Locate the record associated with the given key value.
// Returns:  Pointer to the record, if it is found.
//           NULL, if the record is not found.
// Returns:  LK_SUCCESS, if record found (record is returned in *ppvRecord)
//           LK_BAD_RECORD, if ppvRecord is invalid
//           LK_NO_SUCH_KEY, if no record with the given key value was found.
//           LK_UNUSABLE, if hash table not in usable state
// Note:     the record is AddRef'd.  You must decrement the reference count
//           when you are finished with the record (if you're implementing
//           refcounting semantics).
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_FindKey(
    const DWORD_PTR  pnKey,  // Key value of the record, depends on key type
    DWORD        dwSignature,// hash signature
    const void** ppvRecord   // resultant record
    ) const
{
#ifdef LKR_SUBTABLE
    IRTLASSERT(IsUsable()  &&  ppvRecord != NULL);
#else
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(ppvRecord != NULL);
    if (ppvRecord == NULL)
        return LK_BAD_RECORD;
#endif

    *ppvRecord = NULL;
    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, false);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsReadLocked());
    ReadUnlock();

    // walk down the bucket chain
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst;
         pncCurr != NULL;
         pncCurr = pncCurr->m_pncNext)
    {
        for (DWORD i = 0;  i < NODES_PER_CLUMP;  i++)
        {
#ifdef LKR_COMPACT_DELETE
            if (pncCurr->InvalidSignature(i))
            {
                IRTLASSERT(pncCurr->IsEmptyNode(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }
#endif // LKR_COMPACT_DELETE

            if (dwSignature == pncCurr->m_dwKeySigs[i]
                &&  _EqualKeys(pnKey,  _ExtractKey(pncCurr->m_pvNode[i])))
            {
                    *ppvRecord = pncCurr->m_pvNode[i];
                    lkrc = LK_SUCCESS;

#ifdef LKR_FIND_FIRST
                    // Move the found node to very first slot in the bucket
                    // Hopefully, the principle of temporal locality will
                    // come into play.
                    const DWORD dwTempSig    = pbkt->m_ncFirst.m_dwKeySigs[0];
                    const void* pvTempRecord = pbkt->m_ncFirst.m_pvNode[0];
                    
                    pbkt->m_ncFirst.m_dwKeySigs[0] = pncCurr->m_dwKeySigs[i];
                    pbkt->m_ncFirst.m_pvNode[0]    = pncCurr->m_pvNode[i];

                    pncCurr->m_dwKeySigs[i] = dwTempSig;
                    pncCurr->m_pvNode[i]    = pvTempRecord;
#endif //  LKR_FIND_FIRST

                    // bump the reference count before handing the record
                    // back to the user.  The user should decrement the
                    // reference count when finished with this record.
                    _AddRefRecord(*ppvRecord, +1);
                    goto exit;
            }
        }
    }

  exit:
    pbkt->ReadUnlock();

    return lkrc;
} // CLKRLinearHashTable::_FindKey



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FindRecord
// Synopsis: Sees if the record is contained in the table
// Returns:  Pointer to the record, if it is found.
//           NULL, if the record is not found.
// Returns:  LK_SUCCESS, if record found
//           LK_BAD_RECORD, if pvRecord is invalid
//           LK_NO_SUCH_KEY, if the record was not found in the table
//           LK_UNUSABLE, if hash table not in usable state
// Note:     The record is *not* AddRef'd.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_FindRecord(
    const void* pvRecord,    // Pointer to the record to find in the table
    DWORD       dwSignature  // hash signature
    ) const
{
#ifdef LKR_SUBTABLE
    IRTLASSERT(IsUsable()  &&  pvRecord != NULL);
#else
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(pvRecord != NULL);
    if (pvRecord == NULL)
        return LK_BAD_RECORD;
#endif

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, false);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsReadLocked());
    ReadUnlock();

    const DWORD_PTR pnKey = _ExtractKey(pvRecord);
    IRTLASSERT(dwSignature == _CalcKeyHash(pnKey));

    // walk down the bucket chain
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst;
         pncCurr != NULL;
         pncCurr = pncCurr->m_pncNext)
    {
        for (DWORD i = 0;  i < NODES_PER_CLUMP;  i++)
        {
#ifdef LKR_COMPACT_DELETE
            if (pncCurr->IsEmptyNode(i))
            {
                IRTLASSERT(pncCurr->InvalidSignature(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }
#endif // LKR_COMPACT_DELETE

            if (pncCurr->m_pvNode[i] == pvRecord)
            {
                IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[i]);
                IRTLASSERT(_EqualKeys(pnKey,
                                      _ExtractKey(pncCurr->m_pvNode[i])));
                lkrc = LK_SUCCESS;

#ifdef LKR_FIND_FIRST
                // Move the found node to very first slot in the bucket
                // Hopefully, the principle of temporal locality will
                // come into play.
                const DWORD dwTempSig    = pbkt->m_ncFirst.m_dwKeySigs[0];
                const void* pvTempRecord = pbkt->m_ncFirst.m_pvNode[0];
                
                pbkt->m_ncFirst.m_dwKeySigs[0] = pncCurr->m_dwKeySigs[i];
                pbkt->m_ncFirst.m_pvNode[0]    = pncCurr->m_pvNode[i];
                
                pncCurr->m_dwKeySigs[i] = dwTempSig;
                pncCurr->m_pvNode[i]    = pvTempRecord;
#endif //  LKR_FIND_FIRST

                goto exit;
            }
        }
    }

  exit:
    pbkt->ReadUnlock();

    return lkrc;
} // CLKRLinearHashTable::_FindRecord



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::Apply(
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    LK_PREDICATE lkp = LKP_PERFORM;
    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    DWORD dw = _Apply(pfnAction, pvState, lkl, lkp);
    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    return dw;
} // CLKRLinearHashTable::Apply



//------------------------------------------------------------------------
// Function: CLKRHashTable::Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::Apply(
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        for (DWORD i = 0;  i < m_cSubTables;  i++)
        {
            dw += m_palhtDir[i]->_Apply(pfnAction, pvState, lkl, lkp);
            if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
                ||  lkp == LKP_DELETE_STOP)
                break;
        }
    }

    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    return dw;
} // CLKRHashTable::Apply



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::ApplyIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::ApplyIf(
    PFnRecordPred   pfnPredicate,
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        dw = _ApplyIf(pfnPredicate, pfnAction, pvState, lkl, lkp);
    }

    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();
    return dw;
} // CLKRLinearHashTable::ApplyIf



//------------------------------------------------------------------------
// Function: CLKRHashTable::ApplyIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::ApplyIf(
    PFnRecordPred   pfnPredicate,
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        for (DWORD i = 0;  i < m_cSubTables;  i++)
        {
            dw += m_palhtDir[i]->_ApplyIf(pfnPredicate, pfnAction,
                                          pvState, lkl, lkp);
            if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
                ||  lkp == LKP_DELETE_STOP)
                break;
        }
    }

    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    return dw;
} // CLKRHashTable::ApplyIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::DeleteIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::DeleteIf(
    PFnRecordPred pfnPredicate,
    void*         pvState)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    WriteLock();
    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());
    if (IsValid())
        dw = _DeleteIf(pfnPredicate, pvState, lkp);
    WriteUnlock();

    return dw;
} // CLKRLinearHashTable::DeleteIf



//------------------------------------------------------------------------
// Function: CLKRHashTable::DeleteIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::DeleteIf(
    PFnRecordPred pfnPredicate,
    void*         pvState)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        for (DWORD i = 0;  i < m_cSubTables;  i++)
        {
            dw += m_palhtDir[i]->_DeleteIf(pfnPredicate, pvState, lkp);
            if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
                ||  lkp == LKP_DELETE_STOP)
                break;
        }
    }

    WriteUnlock();

    return dw;
} // CLKRHashTable::DeleteIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::_Apply(
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl,
    LK_PREDICATE&  rlkp)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(lkl == LKL_WRITELOCK  ?  IsWriteLocked()  :  IsReadLocked());
    return _ApplyIf(_PredTrue, pfnAction, pvState, lkl, rlkp);
} // CLKRLinearHashTable::_Apply



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_ApplyIf
// Synopsis:
// Returns:  Number of successful actions
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::_ApplyIf(
    PFnRecordPred   pfnPredicate,
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl,
    LK_PREDICATE&  rlkp)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(lkl == LKL_WRITELOCK  ?  IsWriteLocked()  :  IsReadLocked());
    IRTLASSERT(pfnPredicate != NULL  &&  pfnAction != NULL);

    if ((lkl == LKL_WRITELOCK  ?  !IsWriteLocked()  :  !IsReadLocked())
            ||  pfnPredicate == NULL  ||  pfnAction == NULL)
        return 0;

    DWORD cActions = 0;

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);

        if (lkl == LKL_WRITELOCK)
            pbkt->WriteLock();
        else
            pbkt->ReadLock();

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            for (int i = 0;  i < NODES_PER_CLUMP;  i++)
            {
#ifdef LKR_COMPACT_DELETE
                if (pncCurr->IsEmptyNode(i))
                {
                    IRTLASSERT(pncCurr->InvalidSignature(i));
                    IRTLASSERT(0 == _IsNodeCompact(pbkt));
                    IRTLASSERT(pncCurr->IsLastClump());
                    goto unlock;
                }
                else
#else // !LKR_COMPACT_DELETE
                if (!pncCurr->IsEmptyNode(i))
#endif // !LKR_COMPACT_DELETE
                {
                    rlkp = (*pfnPredicate)(pncCurr->m_pvNode[i], pvState);

                    switch (rlkp)
                    {
                    case LKP_ABORT:
                        if (lkl == LKL_WRITELOCK)
                            pbkt->WriteUnlock();
                        else
                            pbkt->ReadUnlock();
                        return cActions;
                        break;

                    case LKP_NO_ACTION:
                        // nothing to do
                        break;

                    case LKP_DELETE:
                    case LKP_DELETE_STOP:
                        if (lkl != LKL_WRITELOCK)
                        {
                            pbkt->ReadUnlock();
                            return cActions;
                        }

                        // fall through

                    case LKP_PERFORM:
                    case LKP_PERFORM_STOP:
                    {
                        LK_ACTION lka;

                        if (rlkp == LKP_DELETE  ||  rlkp == LKP_DELETE_STOP)
                        {
                            IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));
                            ++cActions;
                            lka = LKA_SUCCEEDED;
                        }
                        else
                        {
                            lka = (*pfnAction)(pncCurr->m_pvNode[i], pvState);

                            switch (lka)
                            {
                            case LKA_ABORT:
                                if (lkl == LKL_WRITELOCK)
                                    pbkt->WriteUnlock();
                                else
                                    pbkt->ReadUnlock();
                                return cActions;
                                
                            case LKA_FAILED:
                                // nothing to do
                                break;
                                
                            case LKA_SUCCEEDED:
                                ++cActions;
                                break;
                                
                            default:
                                IRTLASSERT(FALSE);
                                break;
                            }
                        }

                        if (rlkp == LKP_PERFORM_STOP
                            ||  rlkp == LKP_DELETE_STOP)
                        {
                            if (lkl == LKL_WRITELOCK)
                                pbkt->WriteUnlock();
                            else
                                pbkt->ReadUnlock();
                            return cActions;
                        }

                        break;
                    }

                    default:
                        IRTLASSERT(FALSE);
                        break;
                    }
                }
            }
        }

#ifdef LKR_COMPACT_DELETE
      unlock:
#endif // LKR_COMPACT_DELETE

        if (lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();
    }

    return cActions;
} // CLKRLinearHashTable::_ApplyIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteIf
// Synopsis: Deletes all records that match the predicate
// Returns:  Count of successful deletions
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::_DeleteIf(
    PFnRecordPred  pfnPredicate,
    void*          pvState,
    LK_PREDICATE& rlkp)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(IsWriteLocked());
    IRTLASSERT(pfnPredicate != NULL);

    if (!IsWriteLocked()  ||  pfnPredicate == NULL)
        return 0;

    DWORD cActions = 0;

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);
        pbkt->WriteLock();

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            for (int i = 0;  i < NODES_PER_CLUMP;  i++)
            {
#ifdef LKR_COMPACT_DELETE
                if (pncCurr->IsEmptyNode(i))
                {
                    IRTLASSERT(pncCurr->InvalidSignature(i));
                    IRTLASSERT(0 == _IsNodeCompact(pbkt));
                    IRTLASSERT(pncCurr->IsLastClump());
                    goto unlock;
                }
                else
#else // !LKR_COMPACT_DELETE
                if (!pncCurr->IsEmptyNode(i))
#endif // !LKR_COMPACT_DELETE
                {
                    rlkp = (*pfnPredicate)(pncCurr->m_pvNode[i], pvState);

                    switch (rlkp)
                    {
                    case LKP_ABORT:
                        pbkt->WriteUnlock();
                        return cActions;
                        break;

                    case LKP_NO_ACTION:
                        // nothing to do
                        break;

                    case LKP_PERFORM:
                    case LKP_PERFORM_STOP:
                    case LKP_DELETE:
                    case LKP_DELETE_STOP:
                    {
                        IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));
                        ++cActions;

                        if (rlkp == LKP_PERFORM_STOP
                            ||  rlkp == LKP_DELETE_STOP)
                        {
                            pbkt->WriteUnlock();
                            return cActions;
                        }

                        break;
                    }

                    default:
                        IRTLASSERT(FALSE);
                        break;
                    }
                }
            }
        }

#ifdef LKR_COMPACT_DELETE
      unlock:
#endif // LKR_COMPACT_DELETE
        pbkt->WriteUnlock();
    }

    return cActions;
} // CLKRLinearHashTable::_DeleteIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::CheckTable
// Synopsis: Verify that all records are in the right place and can be located.
// Returns:   0 => hash table is consistent
//           >0 => that many misplaced records
//           <0 => otherwise invalid
//------------------------------------------------------------------------

int
CLKRLinearHashTable::CheckTable() const
{
    if (!IsUsable())
        return LK_UNUSABLE;

    ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (!IsValid())
    {
        ReadUnlock();
        return LK_UNUSABLE;
    }

    int       cMisplaced = 0;
    DWORD     cRecords = 0;
    int       retcode = 0;

    // Check every bucket
    for (DWORD i = 0;  i < m_cActiveBuckets;  i++)
    {
        CBucket* const pbkt = _Bucket(i);

        IRTLASSERT(pbkt != NULL);
        retcode += !(pbkt != NULL);

        pbkt->ReadLock();

#ifdef LKR_COMPACT_DELETE
        IRTLASSERT(0 == _IsNodeCompact(pbkt));
#endif // LKR_COMPACT_DELETE

        // Walk the bucket chain
        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            for (DWORD j = 0;  j < NODES_PER_CLUMP;  j++)
            {
#ifdef LKR_COMPACT_DELETE
                if (pncCurr->IsEmptyNode(j))
                {
                    IRTLASSERT(pncCurr->IsLastClump());
                    retcode += !(pncCurr->IsLastClump());

                    for (DWORD k = j;  k < NODES_PER_CLUMP;  k++)
                    {
                        IRTLASSERT(pncCurr->IsEmptyNode(k));
                        retcode += !pncCurr->IsEmptyNode(k);
                        IRTLASSERT(pncCurr->InvalidSignature(k));
                        retcode += !pncCurr->InvalidSignature(k);
                    }
                    break;
                }
#endif // LKR_COMPACT_DELETE

                if (!pncCurr->IsEmptyNode(j))
                {
                    ++cRecords;

                    const DWORD_PTR pnKey = _ExtractKey(pncCurr->m_pvNode[j]);

                    DWORD dwSignature = _CalcKeyHash(pnKey);
                    IRTLASSERT(dwSignature != HASH_INVALID_SIGNATURE);
                    retcode += !(dwSignature != HASH_INVALID_SIGNATURE);
                    IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[j]);
                    retcode += !(dwSignature == pncCurr->m_dwKeySigs[j]);

                    DWORD address = _BucketAddress(dwSignature);
                    IRTLASSERT(address == i);
                    retcode += !(address == i);

                    if (address != i || dwSignature != pncCurr->m_dwKeySigs[j])
                        cMisplaced++;
                }
                else // pncCurr->IsEmptyNode(j)
                {
                    IRTLASSERT(pncCurr->InvalidSignature(j));
                    retcode += !pncCurr->InvalidSignature(j);
                }
            }
            if (pncPrev != NULL)
            {
                IRTLASSERT(pncPrev->m_pncNext == pncCurr);
                retcode += !(pncPrev->m_pncNext == pncCurr);
            }
        }
        pbkt->ReadUnlock();
    }

    if (cRecords != m_cRecords)
        ++retcode;

    IRTLASSERT(cRecords == m_cRecords);
    retcode += !(cRecords == m_cRecords);

    if (cMisplaced > 0)
        retcode = cMisplaced;

    IRTLASSERT(cMisplaced == 0);
    retcode += !(cMisplaced == 0);

    ReadUnlock();

    return retcode;
} // CheckTable



//------------------------------------------------------------------------
// Function: CLKRHashTable::CheckTable
// Synopsis: Verify that all records are in the right place and can be located.
// Returns:   0 => hash table is consistent
//           >0 => that many misplaced records
//           <0 => otherwise invalid
//------------------------------------------------------------------------
int
CLKRHashTable::CheckTable() const
{
    if (!IsUsable())
        return LK_UNUSABLE;

    int retcode = 0;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
        retcode += m_palhtDir[i]->CheckTable();

    return retcode;
} // CLKRHashTable::CheckTable



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Print
// Synopsis: Prints the table
//------------------------------------------------------------------------

void
CLKRLinearHashTable::Print() const
{
    DBGPRINTF(( DBG_CONTEXT,
                "CLKRLinearHashTable(%08p)  # Elements %4d; ",
                this, m_cRecords));
    // TODO: flesh out further
} // CLKRLinearHashTable::Print



//------------------------------------------------------------------------
// Function: CLKRHashTable::Print
// Synopsis: Prints the table
//------------------------------------------------------------------------

void
CLKRHashTable::Print() const
{
    DBGPRINTF(( DBG_CONTEXT,
                "CLKRHashTable(%08p)  # Subtables = %4d.\n",
                this, m_cSubTables));

    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->Print();

    // TODO: print footer?
} // CLKRHashTable::Print



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Clear
// Synopsis: Remove all data from the table
//------------------------------------------------------------------------

void
CLKRLinearHashTable::_Clear(
    bool fShrinkDirectory)  // Shrink to min size but don't destroy entirely?
{
    if (!IsUsable())
        return;

    IRTLASSERT(IsWriteLocked());

#ifdef _DEBUG
    DWORD cDeleted = 0;
    DWORD cOldRecords = m_cRecords;
#endif // _DEBUG

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);
        pbkt->WriteLock();

#ifdef LKR_COMPACT_DELETE
        IRTLASSERT(0 == _IsNodeCompact(pbkt));
#endif // LKR_COMPACT_DELETE

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             )
        {
            for (int i = 0;  i < NODES_PER_CLUMP;  i++)
            {

#ifdef LKR_COMPACT_DELETE
                if (pncCurr->IsEmptyNode(i))
                {
                    IRTLASSERT(pncCurr->InvalidSignature(i));
                    IRTLASSERT(pncCurr->IsLastClump());
                    break;
                }
                else
                {
                    _AddRefRecord(pncCurr->m_pvNode[i], -1);
                    pncCurr->m_pvNode[i]    = NULL;
                    pncCurr->m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
                    m_cRecords--;

#ifdef _DEBUG
                    ++cDeleted;
#endif // _DEBUG
                }

#else // !LKR_COMPACT_DELETE

                if (!pncCurr->IsEmptyNode(i))
                {
                    IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));

#ifdef _DEBUG
                    ++cDeleted;
#endif // _DEBUG
                }
#endif // !LKR_COMPACT_DELETE

            } // for (i ...

            pncPrev = pncCurr;
            pncCurr = pncCurr->m_pncNext;
            pncPrev->m_pncNext = NULL;

#ifdef LKR_COMPACT_DELETE
            if (pncPrev != &pbkt->m_ncFirst)
                _FreeNodeClump(pncPrev);
#endif // LKR_COMPACT_DELETE
        } // for (pncCurr ...

        pbkt->WriteUnlock();
    } // for (iBkt ...

    IRTLASSERT(m_cRecords == 0  &&  cDeleted == cOldRecords);

    // delete all (or all but the first MIN_DIRSIZE) segments
    for (DWORD iSeg = 0;  iSeg < m_cActiveBuckets;  iSeg += m_dwSegSize)
    {
        _FreeSegment(_Segment(iSeg));
        _Segment(iSeg) = NULL;
    }

    _FreeSegmentDirectory(m_paDirSegs);
    m_paDirSegs = NULL;
    m_cDirSegs = m_nLevel = m_cActiveBuckets = m_iExpansionIdx = 0;
    m_dwBktAddrMask  = 1;
#ifdef LKR_MASK
    m_dwBktAddrMask1 = (m_dwBktAddrMask << 1) | 1;
#endif // LKR_MASK

    // reduce directory of segments to minimum size
    if (fShrinkDirectory)
    {
        if (LK_SMALL_TABLESIZE == m_lkts)
            m_cActiveBuckets = CSmallSegment::INITSIZE;
        else if (LK_MEDIUM_TABLESIZE == m_lkts)
            m_cActiveBuckets = CMediumSegment::INITSIZE;
        else if (LK_LARGE_TABLESIZE == m_lkts)
            m_cActiveBuckets = CLargeSegment::INITSIZE;
        else
            IRTLASSERT(! "Unknown LK_TABLESIZE");

        _SetSegVars(m_lkts);
    }
} // CLKRLinearHashTable::_Clear



//------------------------------------------------------------------------
// Function: CLKRHashTable::Clear
// Synopsis: Remove all data from the table
//------------------------------------------------------------------------

void
CLKRHashTable::Clear()
{
    WriteLock();
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->_Clear(true);
    WriteUnlock();
} // CLKRHashTable::Clear



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::GetStatistics
// Synopsis: Gather statistics about the table
//------------------------------------------------------------------------

CLKRHashTableStats
CLKRLinearHashTable::GetStatistics() const
{
    CLKRHashTableStats stats;

    if (!IsUsable())
        return stats;

    if (m_paDirSegs != NULL)
    {
        stats.RecordCount   = m_cRecords;
        stats.TableSize     = m_cActiveBuckets;
        stats.SplitFactor   = static_cast<double>(m_iExpansionIdx)
                              / (1 << m_nLevel);
        stats.DirectorySize = m_cDirSegs;
        stats.NodeClumpSize = NODES_PER_CLUMP;
        stats.CBucketSize   = sizeof(CBucket);

#ifdef LOCK_INSTRUMENTATION
        stats.m_alsBucketsAvg.m_nContentions     = 0;
        stats.m_alsBucketsAvg.m_nSleeps          = 0;
        stats.m_alsBucketsAvg.m_nContentionSpins = 0;
        stats.m_alsBucketsAvg.m_nAverageSpins    = 0;
        stats.m_alsBucketsAvg.m_nReadLocks       = 0;
        stats.m_alsBucketsAvg.m_nWriteLocks      = 0;
        stats.m_alsBucketsAvg.m_nItems           = 0;
#endif // LOCK_INSTRUMENTATION

        int empty = 0;
        int totacc = 0;
        int low_count = 0;
        int high_count = 0;
        int max_length = 0;

        for (DWORD i = 0;  i < m_cActiveBuckets;  i++)
        {
            int acc = 0;

            for (CNodeClump* pncCurr = &_Bucket(i)->m_ncFirst;
                 pncCurr != NULL;
                 pncCurr = pncCurr->m_pncNext)
            {
                for (DWORD j = 0;  j < NODES_PER_CLUMP;  j++)
                {
                    if (!pncCurr->IsEmptyNode(j))
                    {
                        acc++;
                        totacc += acc;
                        int iBucketIndex = stats.BucketIndex(acc);
                        ++stats.m_aBucketLenHistogram[iBucketIndex];
                    }
                }
            }

#ifdef LOCK_INSTRUMENTATION
            CLockStatistics ls = _Bucket(i)->LockStats();

            stats.m_alsBucketsAvg.m_nContentions     += ls.m_nContentions;
            stats.m_alsBucketsAvg.m_nSleeps          += ls.m_nSleeps;
            stats.m_alsBucketsAvg.m_nContentionSpins += ls.m_nContentionSpins;
            stats.m_alsBucketsAvg.m_nAverageSpins    += ls.m_nAverageSpins;
            stats.m_alsBucketsAvg.m_nReadLocks       += ls.m_nReadLocks;
            stats.m_alsBucketsAvg.m_nWriteLocks      += ls.m_nWriteLocks;
            stats.m_alsBucketsAvg.m_nItems           ++;
#endif // LOCK_INSTRUMENTATION

            max_length = max(max_length, acc);
            if (acc == 0)
                empty++;

            if (_H0(i) < m_iExpansionIdx)
            {
                low_count += acc;
            }
            else
            {
                high_count += acc;
            }
        }

        stats.LongestChain = max_length;
        stats.EmptySlots   = empty;

        if (m_cActiveBuckets > 0)
        {
            if (m_cRecords > 0)
            {
                double x=static_cast<double>(m_iExpansionIdx) /(1 << m_nLevel);
                double alpha= static_cast<double>(m_cRecords)/m_cActiveBuckets;
                double low_sl = 0.0;
                double high_sl = 0.0;
                
                stats.AvgSearchLength= static_cast<double>(totacc) /m_cRecords;
                stats.ExpSearchLength  = 1 + alpha * 0.25 * (2 + x - x*x);
                
                if (m_iExpansionIdx > 0)
                    low_sl  = static_cast<double>(low_count)
                        / (2.0 * m_iExpansionIdx);
                if (m_cActiveBuckets - 2 * m_iExpansionIdx > 0)
                    high_sl = static_cast<double>(high_count)
                        / (m_cActiveBuckets - 2.0 * m_iExpansionIdx);
                stats.AvgUSearchLength = low_sl * x + high_sl * (1.0 - x);
                stats.ExpUSearchLength = alpha * 0.5 * (2 + x - x*x);
            }

#ifdef LOCK_INSTRUMENTATION
            stats.m_alsBucketsAvg.m_nContentions     /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nSleeps          /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nContentionSpins /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nAverageSpins    /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nReadLocks       /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nWriteLocks      /= m_cActiveBuckets;
#endif // LOCK_INSTRUMENTATION

        }
        else
        {
            stats.AvgSearchLength  = 0.0;
            stats.ExpSearchLength  = 0.0;
            stats.AvgUSearchLength = 0.0;
            stats.ExpUSearchLength = 0.0;
        }
    }

#ifdef LOCK_INSTRUMENTATION
    stats.m_gls     = TableLock::GlobalStatistics();
    CLockStatistics ls = _LockStats();

    stats.m_alsTable.m_nContentions     = ls.m_nContentions;
    stats.m_alsTable.m_nSleeps          = ls.m_nSleeps;
    stats.m_alsTable.m_nContentionSpins = ls.m_nContentionSpins;
    stats.m_alsTable.m_nAverageSpins    = ls.m_nAverageSpins;
    stats.m_alsTable.m_nReadLocks       = ls.m_nReadLocks;
    stats.m_alsTable.m_nWriteLocks      = ls.m_nWriteLocks;
    stats.m_alsTable.m_nItems           = 1;
#endif // LOCK_INSTRUMENTATION

    return stats;
} // CLKRLinearHashTable::GetStatistics



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetStatistics
// Synopsis: Gather statistics about the table
//------------------------------------------------------------------------

CLKRHashTableStats
CLKRHashTable::GetStatistics() const
{
    CLKRHashTableStats hts;

    if (!IsUsable())
        return hts;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        CLKRHashTableStats stats = m_palhtDir[i]->GetStatistics();

        hts.RecordCount +=      stats.RecordCount;
        hts.TableSize +=        stats.TableSize;
        hts.DirectorySize +=    stats.DirectorySize;
        hts.LongestChain =      max(hts.LongestChain, stats.LongestChain);
        hts.EmptySlots +=       stats.EmptySlots;
        hts.SplitFactor +=      stats.SplitFactor;
        hts.AvgSearchLength +=  stats.AvgSearchLength;
        hts.ExpSearchLength +=  stats.ExpSearchLength;
        hts.AvgUSearchLength += stats.AvgUSearchLength;
        hts.ExpUSearchLength += stats.ExpUSearchLength;
        hts.NodeClumpSize =     stats.NodeClumpSize;
        hts.CBucketSize =       stats.CBucketSize;

        for (int j = 0;  j < CLKRHashTableStats::MAX_BUCKETS;  ++j)
            hts.m_aBucketLenHistogram[j] += stats.m_aBucketLenHistogram[j];

#ifdef LOCK_INSTRUMENTATION
        hts.m_alsTable.m_nContentions     += stats.m_alsTable.m_nContentions;
        hts.m_alsTable.m_nSleeps          += stats.m_alsTable.m_nSleeps;
        hts.m_alsTable.m_nContentionSpins
            += stats.m_alsTable.m_nContentionSpins;
        hts.m_alsTable.m_nAverageSpins    += stats.m_alsTable.m_nAverageSpins;
        hts.m_alsTable.m_nReadLocks       += stats.m_alsTable.m_nReadLocks;
        hts.m_alsTable.m_nWriteLocks      += stats.m_alsTable.m_nWriteLocks;
        
        hts.m_alsBucketsAvg.m_nContentions
            += stats.m_alsBucketsAvg.m_nContentions;
        hts.m_alsBucketsAvg.m_nSleeps
            += stats.m_alsBucketsAvg.m_nSleeps;
        hts.m_alsBucketsAvg.m_nContentionSpins
            += stats.m_alsBucketsAvg.m_nContentionSpins;
        hts.m_alsBucketsAvg.m_nAverageSpins
            += stats.m_alsBucketsAvg.m_nAverageSpins;
        hts.m_alsBucketsAvg.m_nReadLocks
            += stats.m_alsBucketsAvg.m_nReadLocks;
        hts.m_alsBucketsAvg.m_nWriteLocks
            += stats.m_alsBucketsAvg.m_nWriteLocks;
        hts.m_alsBucketsAvg.m_nItems
            += stats.m_alsBucketsAvg.m_nItems;
        
        hts.m_gls = stats.m_gls;
#endif // LOCK_INSTRUMENTATION
    }

    // Average out the subtables statistics.  (Does this make sense
    // for all of these fields?)
    hts.DirectorySize /=    m_cSubTables;
    hts.SplitFactor /=      m_cSubTables;
    hts.AvgSearchLength /=  m_cSubTables;
    hts.ExpSearchLength /=  m_cSubTables;
    hts.AvgUSearchLength /= m_cSubTables;
    hts.ExpUSearchLength /= m_cSubTables;

#ifdef LOCK_INSTRUMENTATION
    hts.m_alsTable.m_nContentions     /= m_cSubTables;
    hts.m_alsTable.m_nSleeps          /= m_cSubTables;
    hts.m_alsTable.m_nContentionSpins /= m_cSubTables;
    hts.m_alsTable.m_nAverageSpins    /= m_cSubTables;
    hts.m_alsTable.m_nReadLocks       /= m_cSubTables;
    hts.m_alsTable.m_nWriteLocks      /= m_cSubTables;
    hts.m_alsTable.m_nItems            = m_cSubTables;

    hts.m_alsBucketsAvg.m_nContentions     /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nSleeps          /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nContentionSpins /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nAverageSpins    /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nReadLocks       /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nWriteLocks      /= m_cSubTables;
#endif // LOCK_INSTRUMENTATION

    return hts;
} // CLKRHashTable::GetStatistics



//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_SetSegVars
// Synopsis: sets the size-specific segment variables
//-----------------------------------------------------------------------

void
CLKRLinearHashTable::_SetSegVars(
    LK_TABLESIZE lkts)
{
    switch (lkts)
    {
    case LK_SMALL_TABLESIZE:
        m_lkts      = LK_SMALL_TABLESIZE;
        m_dwSegBits = CSmallSegment::SEGBITS;
        m_dwSegSize = CSmallSegment::SEGSIZE;
        m_dwSegMask = CSmallSegment::SEGMASK;
        break;
        
    default:
        IRTLASSERT(! "Unknown LK_TABLESIZE");
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
        m_lkts      = LK_MEDIUM_TABLESIZE;
        m_dwSegBits = CMediumSegment::SEGBITS;
        m_dwSegSize = CMediumSegment::SEGSIZE;
        m_dwSegMask = CMediumSegment::SEGMASK;
        break;
        
    case LK_LARGE_TABLESIZE:
        m_lkts      = LK_LARGE_TABLESIZE;
        m_dwSegBits = CLargeSegment::SEGBITS;
        m_dwSegSize = CLargeSegment::SEGSIZE;
        m_dwSegMask = CLargeSegment::SEGMASK;
        break;
    }

    m_dwBktAddrMask  = m_dwSegMask;
    m_nLevel         = m_dwSegBits;

#ifdef LKR_MASK
    m_dwBktAddrMask1 = (m_dwBktAddrMask << 1) | 1;
#endif // LKR_MASK

    IRTLASSERT(m_cActiveBuckets > 0);

    IRTLASSERT(m_nLevel == m_dwSegBits);
    IRTLASSERT(m_dwBktAddrMask == (1U << m_nLevel) - 1);
    IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask << 1) | 1));

    IRTLASSERT(m_dwSegBits > 0);
    IRTLASSERT(m_dwSegSize == (1U << m_dwSegBits));
    IRTLASSERT(m_dwSegMask == (m_dwSegSize - 1));
    IRTLASSERT(m_dwBktAddrMask == m_dwSegMask);

    // adjust m_dwBktAddrMask (== m_dwSegMask) to make it large
    // enough to distribute the buckets across the address space
    for (DWORD tmp = m_cActiveBuckets >> m_dwSegBits;  tmp > 1;  tmp >>= 1)
    {
        ++m_nLevel;
        m_dwBktAddrMask = (m_dwBktAddrMask << 1) | 1;
    }

    m_dwBktAddrMask1 = (m_dwBktAddrMask << 1) | 1;

    IRTLASSERT(_H1(m_cActiveBuckets) == m_cActiveBuckets);
    m_iExpansionIdx = m_cActiveBuckets & m_dwBktAddrMask;

    // create and clear directory of segments
    DWORD cDirSegs = MIN_DIRSIZE;
    while (cDirSegs < (m_cActiveBuckets >> m_dwSegBits))
        cDirSegs <<= 1;

    cDirSegs = min(cDirSegs, MAX_DIRSIZE);
    IRTLASSERT((cDirSegs << m_dwSegBits) >= m_cActiveBuckets);

    m_lkrcState = LK_ALLOC_FAIL;
    m_paDirSegs = _AllocateSegmentDirectory(cDirSegs);

    if (m_paDirSegs != NULL)
    {
        m_cDirSegs = cDirSegs;
        IRTLASSERT(m_cDirSegs >= MIN_DIRSIZE
                   &&  (m_cDirSegs & (m_cDirSegs-1)) == 0);  // == (1 << N)

        // create and initialize only the required segments
        DWORD dwMaxSegs = (m_cActiveBuckets + m_dwSegSize - 1) >> m_dwSegBits;
        IRTLASSERT(dwMaxSegs <= m_cDirSegs);

        TRACE(TEXT("InitSegDir: m_lkts = %d, m_cActiveBuckets = %lu, ")
              TEXT("m_dwSegSize = %lu, bits = %lu\n")
              TEXT("m_cDirSegs = %lu, dwMaxSegs = %lu, ")
              TEXT("segment total size = %lu bytes\n"),
              m_lkts, m_cActiveBuckets,
              m_dwSegSize, m_dwSegBits,
              m_cDirSegs, dwMaxSegs,
              m_dwSegSize * sizeof(CBucket));

        m_lkrcState = LK_SUCCESS; // so IsValid/IsUsable won't fail

        for (DWORD i = 0;  i < dwMaxSegs;  i++)
        {
            CSegment* pSeg = _AllocateSegment();
            if (pSeg != NULL)
                m_paDirSegs[i].m_pseg = pSeg;
            else
            {
                // problem: deallocate everything
                m_lkrcState = LK_ALLOC_FAIL;
                for (DWORD j = i;  j-- > 0;  )
                {
                    _FreeSegment(m_paDirSegs[j].m_pseg);
                    m_paDirSegs[j].m_pseg = NULL;
                }
                _FreeSegmentDirectory(m_paDirSegs);
                break;
            }
        }
    }

    if (m_lkrcState != LK_SUCCESS)
    {
        m_paDirSegs      = NULL;
        m_cDirSegs       = 0;
        m_cActiveBuckets = 0;
        m_iExpansionIdx  = 0;

        // Propagate error back up to parent (if it exists). This ensures
        // that all of the parent's public methods will start failing.
        if (m_phtParent != NULL)
            m_phtParent->m_lkrcState = m_lkrcState;
    }
} // CLKRLinearHashTable::_SetSegVars




#include <stdlib.h>

// #define LKR_RANDOM_MEMORY_FAILURES 1000  // 1..RAND_MAX (32767)

// Memory allocation wrappers to allow us to simulate allocation
// failures during testing

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateSegmentDirectory
// Synopsis: 
//------------------------------------------------------------------------

CLKRLinearHashTable::CDirEntry* const
CLKRLinearHashTable::_AllocateSegmentDirectory(
    size_t n)
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif
    CDirEntry* pade = new CDirEntry [n];

#ifdef _DEBUG
    for (size_t i = 0;  i < n;  ++i)
        IRTLASSERT(pade[i].m_pseg == NULL);
#endif

    return pade;
}



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeSegmentDirectory
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeSegmentDirectory(
    CLKRLinearHashTable::CDirEntry* paDirSegs)
{
    delete [] paDirSegs;
    return true;
}



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateNodeClump
// Synopsis: 
//------------------------------------------------------------------------

CLKRLinearHashTable::CNodeClump* const
CLKRLinearHashTable::_AllocateNodeClump()
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif
    return new CNodeClump;
}



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeSegment
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeNodeClump(
    CLKRLinearHashTable::CNodeClump* pnc)
{
    delete pnc;
    return true;
}



//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateSegment
// Synopsis: creates a new segment of the approriate size
// Output:   pointer to the new segment; NULL => failure
//-----------------------------------------------------------------------

CLKRLinearHashTable::CSegment* const
CLKRLinearHashTable::_AllocateSegment(
    ) const
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif
    CSegment* pseg = NULL;

    switch (m_lkts)
    {
    case LK_SMALL_TABLESIZE:
        IRTLASSERT(CLKRLinearHashTable::CSmallSegment::sm_palloc != NULL);
        pseg = new CSmallSegment;
        break;
        
    default:
        IRTLASSERT(FALSE);
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
        IRTLASSERT(CLKRLinearHashTable::CMediumSegment::sm_palloc != NULL);
        pseg = new CMediumSegment;
        break;
        
    case LK_LARGE_TABLESIZE:
        IRTLASSERT(CLKRLinearHashTable::CLargeSegment::sm_palloc != NULL);
        pseg = new CLargeSegment;
        break;
    }

    IRTLASSERT(pseg != NULL);

    if (pseg != NULL  &&  BucketLock::PerLockSpin() == LOCK_INDIVIDUAL_SPIN)
    {
        for (DWORD i = 0;  i < m_dwSegSize;  ++i)
            pseg->Slot(i).SetSpinCount(m_wBucketLockSpins);
    }

    return pseg;
} // CLKRLinearHashTable::_AllocateSegment



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeSegment
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeSegment(
    CLKRLinearHashTable::CSegment* pseg) const
{
    delete pseg;
    return true;
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::_AllocateSubTableArray
// Synopsis: 
//------------------------------------------------------------------------

CLKRHashTable::SubTable** const
CLKRHashTable::_AllocateSubTableArray(
    size_t n)
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif
    return new SubTable* [n];
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::_FreeSubTableArray
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::_FreeSubTableArray(
    CLKRHashTable::SubTable** palht)
{
    delete [] palht;
    return true;
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::_AllocateSubTable
// Synopsis: 
//------------------------------------------------------------------------

CLKRHashTable::SubTable* const
CLKRHashTable::_AllocateSubTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Upperbound on average chain length
    DWORD           initsize,       // Initial size of hash table.
    CLKRHashTable*  phtParent       // Owning table.
    )
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif
    return new SubTable(pszName, pfnExtractKey, pfnCalcKeyHash,
                        pfnEqualKeys,  pfnAddRefRecord,
                        maxload, initsize, phtParent);
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::_FreeSubTable
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::_FreeSubTable(
    CLKRHashTable::SubTable* plht)
{
    delete plht;
    return true;
}




//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Expand
// Synopsis: Expands the table by one bucket. Done by splitting the
//           bucket pointed to by m_iExpansionIdx.
// Output:   LK_SUCCESS, if expansion was successful.
//           LK_ALLOC_FAIL, if expansion failed due to lack of memory.
//-----------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Expand()
{
    if (m_cActiveBuckets >= MAX_DIRSIZE * m_dwSegSize - 1)
        return LK_ALLOC_FAIL;  // table is not allowed to grow any more

    WriteLock();

    // double segment directory size if necessary
    if (m_cActiveBuckets >= m_cDirSegs * m_dwSegSize)
    {
        IRTLASSERT(m_cDirSegs < MAX_DIRSIZE);
        DWORD cDirSegsNew = (m_cDirSegs == 0) ? MIN_DIRSIZE : m_cDirSegs << 1;
        CDirEntry* paDirSegsNew = _AllocateSegmentDirectory(cDirSegsNew);

        if (paDirSegsNew != NULL)
        {
            for (DWORD j = 0;  j < m_cDirSegs;  j++)
            {
                paDirSegsNew[j] = m_paDirSegs[j];
                m_paDirSegs[j].m_pseg = NULL;
            }

            _FreeSegmentDirectory(m_paDirSegs);
            m_paDirSegs = paDirSegsNew;
            m_cDirSegs  = cDirSegsNew;
        }
        else
        {
            WriteUnlock();
            return LK_ALLOC_FAIL;  // expansion failed
        }
    }

    // locate the new bucket, creating a new segment if necessary
    ++m_cActiveBuckets;

    DWORD     dwOldBkt = m_iExpansionIdx;
    DWORD     dwNewBkt = (1 << m_nLevel) | dwOldBkt;

    IRTLASSERT(dwOldBkt < m_cActiveBuckets);
    IRTLASSERT(dwNewBkt < m_cActiveBuckets);

    CSegment* psegNew  = _Segment(dwNewBkt);

    if (psegNew == NULL)
    {
        psegNew = _AllocateSegment();
        if (psegNew == NULL)
        {
            --m_cActiveBuckets;
            WriteUnlock();
            return LK_ALLOC_FAIL;  // expansion failed
        }
        _Segment(dwNewBkt) = psegNew;
    }

    // prepare to relocate records to the new bucket
    CBucket* pbktOld = _Bucket(dwOldBkt);
    CBucket* pbktNew = _Bucket(dwNewBkt);

    // get locks on the two buckets involved
    pbktOld->WriteLock();
    pbktNew->WriteLock();

    // Now work out if we need to allocate any extra CNodeClumps.  We do
    // this up front, before calling _SplitRecordSet, as it's hard to
    // gracefully recover from the depths of that routine should we run
    // out of memory.

    CNodeClump* pncFreeList = NULL;
    LK_RETCODE  lkrc        = LK_SUCCESS;

    // If the old bucket has more than one CNodeClump, there's a chance that
    // we'll need extra CNodeClumps in the new bucket too.  If it doesn't,
    // we definitely won't. One CNodeClump is enough to prime the freelist.
    if (!pbktOld->m_ncFirst.IsLastClump())
    {
        pncFreeList = _AllocateNodeClump();
        if (pncFreeList == NULL)
        {
            lkrc = LK_ALLOC_FAIL;
            --m_cActiveBuckets;
        }
    }

    // adjust expansion pointer, level, and mask
    if (lkrc == LK_SUCCESS)
    {
        if (++m_iExpansionIdx == (1U << m_nLevel))
        {
            ++m_nLevel;
            m_iExpansionIdx = 0;
            m_dwBktAddrMask = (m_dwBktAddrMask << 1) | 1;
            // m_dwBktAddrMask = 00011..111
            IRTLASSERT((m_dwBktAddrMask & (m_dwBktAddrMask+1)) == 0);
#ifdef LKR_MASK
            m_dwBktAddrMask1 = (m_dwBktAddrMask << 1) | 1;
            IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
#endif // LKR_MASK
        }
    }

    DWORD iExpansionIdx = m_iExpansionIdx;  // save to avoid race conditions
    DWORD dwBktAddrMask = m_dwBktAddrMask;  // ditto

    // Release the table lock before doing the actual relocation
    WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        lkrc = _SplitRecordSet(&pbktOld->m_ncFirst, &pbktNew->m_ncFirst,
                               iExpansionIdx, dwBktAddrMask,
                               dwNewBkt, pncFreeList);
    }

    pbktNew->WriteUnlock();
    pbktOld->WriteUnlock();

    return lkrc;
} // CLKRLinearHashTable::_Expand



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_SplitRecordSet
// Synopsis: Split records between the old and new buckets.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_SplitRecordSet(
    CNodeClump* pncOldTarget,
    CNodeClump* pncNewTarget,
    DWORD       iExpansionIdx,
    DWORD       dwBktAddrMask,
    DWORD       dwNewBkt,
    CNodeClump* pncFreeList     // list of free nodes available for reuse
    )
{
    CNodeClump  ncFirst = *pncOldTarget;    // save head of old target chain
    CNodeClump* pncOldList = &ncFirst;
    CNodeClump* pncTmp;
    int         iOldSlot = 0;
    int         iNewSlot = 0;

    // clear target buckets
    pncOldTarget->Clear();
    pncNewTarget->Clear();

    // scan through the old bucket chain and decide where to move each record
    while (pncOldList != NULL)
    {
        for (DWORD i = 0;  i < NODES_PER_CLUMP;  i++)
        {
            // node already empty?
            if (pncOldList->IsEmptyNode(i))
            {
                IRTLASSERT(pncOldList->InvalidSignature(i));
                continue;
            }

            // calculate bucket address of this node
            DWORD dwBkt = _H0(pncOldList->m_dwKeySigs[i], dwBktAddrMask);
            if (dwBkt < iExpansionIdx)
                dwBkt = _H1(pncOldList->m_dwKeySigs[i], dwBktAddrMask);

            // record to be moved to the new address?
            if (dwBkt == dwNewBkt)
            {
                // node in new bucket chain full?
                if (iNewSlot == NODES_PER_CLUMP)
                {
                    // the calling routine has passed in a FreeList adequate
                    // for all needs
                    IRTLASSERT(pncFreeList != NULL);
                    pncTmp = pncFreeList;
                    pncFreeList = pncFreeList->m_pncNext;
                    pncTmp->Clear();
                    pncNewTarget->m_pncNext = pncTmp;
                    pncNewTarget = pncTmp;
                    iNewSlot = 0;
                }

                pncNewTarget->m_dwKeySigs[iNewSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncNewTarget->m_pvNode[iNewSlot]
                    = pncOldList->m_pvNode[i];
                ++iNewSlot;
            }

            // no, record stays in its current bucket chain
            else
            {
                // node in old bucket chain full?
                if (iOldSlot == NODES_PER_CLUMP)
                {
                    // the calling routine has passed in a FreeList adequate
                    // for all needs
                    IRTLASSERT(pncFreeList != NULL);
                    pncTmp = pncFreeList;
                    pncFreeList = pncFreeList->m_pncNext;
                    pncTmp->Clear();
                    pncOldTarget->m_pncNext = pncTmp;
                    pncOldTarget = pncTmp;
                    iOldSlot = 0;
                }

                pncOldTarget->m_dwKeySigs[iOldSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncOldTarget->m_pvNode[iOldSlot]
                    = pncOldList->m_pvNode[i];
                ++iOldSlot;
            }

            // clear old slot
            pncOldList->m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
            pncOldList->m_pvNode[i]    = NULL;
        }

        // keep walking down the original bucket chain
        pncTmp     = pncOldList;
        pncOldList = pncOldList->m_pncNext;

        // ncFirst is a stack variable, not allocated on the heap
        if (pncTmp != &ncFirst)
        {
            pncTmp->m_pncNext = pncFreeList;
            pncFreeList = pncTmp;
        }
    }

    // delete any leftover nodes
    while (pncFreeList != NULL)
    {
        pncTmp = pncFreeList;
        pncFreeList = pncFreeList->m_pncNext;
#ifdef _DEBUG
        pncTmp->m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // _DEBUG
        _FreeNodeClump(pncTmp);
    }

#ifdef _DEBUG
    ncFirst.m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // _DEBUG

    return LK_SUCCESS;
} // CLKRLinearHashTable::_SplitRecordSet



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Contract
// Synopsis: Contract the table by deleting the last bucket in the active
//           address space. Return the records to the "buddy" of the
//           deleted bucket.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Contract()
{
    WriteLock();

    // update the state variables (expansion ptr, level and mask)
    if (m_iExpansionIdx > 0)
        --m_iExpansionIdx;
    else
    {
        --m_nLevel;
        m_iExpansionIdx = (1 << m_nLevel) - 1;
        IRTLASSERT(m_nLevel > 0  &&  m_iExpansionIdx > 0);
        m_dwBktAddrMask >>= 1;
        IRTLASSERT((m_dwBktAddrMask & (m_dwBktAddrMask+1)) == 0); // 00011..111
#ifdef LKR_MASK
        m_dwBktAddrMask1 >>= 1;
        IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask << 1) | 1));
        IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
#endif // LKR_MASK
    }

    // The last bucket is the one that will be emptied
    CBucket* pbktLast = _Bucket(m_cActiveBuckets - 1);
    pbktLast->WriteLock();

    // Decrement after calculating pbktLast, or _Bucket() will assert.
    --m_cActiveBuckets;

    // Where the nodes from pbktLast will end up
    CBucket* pbktNew = _Bucket(m_iExpansionIdx);
    pbktNew->WriteLock();

    // Now we work out if we need to allocate any extra CNodeClumps.  We do
    // this up front, before calling _MergeRecordSets, as it's hard to
    // gracefully recover from the depths of that routine should we run
    // out of memory.
    
    CNodeClump* pnc;
    int         c = 0;

    // First, count the number of items in the old bucket
    for (pnc = &pbktLast->m_ncFirst;  pnc != NULL;  pnc = pnc->m_pncNext)
    {
        for (DWORD i = 0;  i < NODES_PER_CLUMP;  i++)
        {
            if (!pnc->IsEmptyNode(i))
            {
                IRTLASSERT(!pnc->InvalidSignature(i));
                c++;
            }
        }
    }

    // Then, subtract off the number of empty slots in the new bucket
    for (pnc = &pbktNew->m_ncFirst;  pnc != NULL;  pnc = pnc->m_pncNext)
    {
        for (DWORD i = 0;  i < NODES_PER_CLUMP;  i++)
        {
            if (pnc->IsEmptyNode(i))
            {
                IRTLASSERT(pnc->InvalidSignature(i));
                c--;
            }
        }
    }

    CNodeClump* pncFreeList = NULL;  // list of nodes available for reuse
    LK_RETCODE  lkrc        = LK_SUCCESS;

    // Do we need to allocate CNodeClumps to accommodate the surplus items?
    if (c > 0)
    {
        pncFreeList = _AllocateNodeClump();
        if (pncFreeList == NULL)
            lkrc = LK_ALLOC_FAIL;
        else if (c > NODES_PER_CLUMP)
        {
            // In the worst case, we need a 2-element freelist for
            // _MergeRecordSets. Two CNodeClumps always suffice since the
            // freelist will be augmented by the CNodeClumps from the old
            // bucket as they are processed.
            pnc = _AllocateNodeClump();
            if (pnc == NULL)
            {
                _FreeNodeClump(pncFreeList);
                lkrc = LK_ALLOC_FAIL;
            }
            else
                pncFreeList->m_pncNext = pnc;
        }
    }

    // Abort if we couldn't allocate enough CNodeClumps
    if (lkrc != LK_SUCCESS)
    {
        // undo the changes to the state variables
        if (++m_iExpansionIdx == (1U << m_nLevel))
        {
            ++m_nLevel;
            m_iExpansionIdx = 0;
            m_dwBktAddrMask = (m_dwBktAddrMask << 1) | 1;
#ifdef LKR_MASK
            m_dwBktAddrMask1 = (m_dwBktAddrMask << 1) | 1;
#endif // LKR_MASK
        }
        ++m_cActiveBuckets;

        // Unlock the buckets and the table
        pbktLast->WriteUnlock();
        pbktNew->WriteUnlock();
        WriteUnlock();

        return lkrc;
    }

    // Copy the chain of records from pbktLast
    CNodeClump ncOldFirst = pbktLast->m_ncFirst;

    // destroy pbktLast
    pbktLast->m_ncFirst.Clear();
    pbktLast->WriteUnlock();

    // remove segment, if empty
    if (_SegIndex(m_cActiveBuckets) == 0)
    {
#ifdef _DEBUG
        // double-check that the supposedly empty segment is really empty
        IRTLASSERT(_Segment(m_cActiveBuckets) != NULL);
        for (DWORD i = 0;  i < m_dwSegSize;  ++i)
        {
            CBucket* pbkt = &_Segment(m_cActiveBuckets)->Slot(i);
            IRTLASSERT(pbkt->IsWriteUnlocked()  &&  pbkt->IsReadUnlocked());
            IRTLASSERT(pbkt->m_ncFirst.IsLastClump());

            for (DWORD j = 0;  j < NODES_PER_CLUMP;  ++j)
            {
                IRTLASSERT(pbkt->m_ncFirst.InvalidSignature(j)
                           &&  pbkt->m_ncFirst.IsEmptyNode(j));
            }
        }
#endif
        _FreeSegment(_Segment(m_cActiveBuckets));
        _Segment(m_cActiveBuckets) = NULL;
    }

    // reduce directory of segments if possible
    if (m_cActiveBuckets <= ((m_cDirSegs * m_dwSegSize) >> 1)
        &&  m_cDirSegs > MIN_DIRSIZE)
    {
        DWORD cDirSegsNew = m_cDirSegs >> 1;
        CDirEntry* paDirSegsNew = _AllocateSegmentDirectory(cDirSegsNew);

        // Memory allocation failure here does not require us to abort; it
        // just means that the directory of segments is larger than we'd like.
        if (paDirSegsNew != NULL)
        {
            for (DWORD j = 0;  j < cDirSegsNew;  j++)
                paDirSegsNew[j] = m_paDirSegs[j];
            for (j = 0;  j < m_cDirSegs;  j++)
                m_paDirSegs[j].m_pseg = NULL;

            _FreeSegmentDirectory(m_paDirSegs);
            m_paDirSegs = paDirSegsNew;
            m_cDirSegs  = cDirSegsNew;
        }
    }

    // release the table lock before doing the reorg
    WriteUnlock();

    lkrc = _MergeRecordSets(pbktNew, &ncOldFirst, pncFreeList);

    pbktNew->WriteUnlock();

#ifdef _DEBUG
    ncOldFirst.m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // _DEBUG

    return lkrc;
} // CLKRLinearHashTable::_Contract



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_MergeRecordSets
// Synopsis: Merge two record sets.  Copy the contents of pncOldList
//           into pbktNewTarget.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_MergeRecordSets(
    CBucket*    pbktNewTarget,
    CNodeClump* pncOldList,
    CNodeClump* pncFreeList
    )
{
    IRTLASSERT(pbktNewTarget != NULL  &&  pncOldList != NULL);

    CNodeClump*   pncTmp = NULL;
    CNodeClump* const pncOldFirst = pncOldList;
    CNodeClump*   pncNewTarget = &pbktNewTarget->m_ncFirst;
    DWORD         iNewSlot;

    // find the first nodeclump in the new target bucket with an empty slot
    while (!pncNewTarget->IsLastClump())
    {
        for (iNewSlot = 0;  iNewSlot < NODES_PER_CLUMP;  iNewSlot++)
            if (pncNewTarget->IsEmptyNode(iNewSlot))
                break;

        if (iNewSlot == NODES_PER_CLUMP)
            pncNewTarget = pncNewTarget->m_pncNext;
        else
            break;
    }

    IRTLASSERT(pncNewTarget != NULL);

    // find the first empty slot in pncNewTarget;
    // if none, iNewSlot == NODES_PER_CLUMP
    for (iNewSlot = 0;  iNewSlot < NODES_PER_CLUMP;  iNewSlot++)
    {
        if (pncNewTarget->IsEmptyNode(iNewSlot))
        {
            break;
        }
    }
    
    while (pncOldList != NULL)
    {
        for (DWORD i = 0;  i < NODES_PER_CLUMP;  i++)
        {
            if (!pncOldList->IsEmptyNode(i))
            {
                // any empty slots left in pncNewTarget?
                if (iNewSlot == NODES_PER_CLUMP)
                {
                    // no, so walk down pncNewTarget until we find another
                    // emptry slot
                    while (!pncNewTarget->IsLastClump())
                    {
                        pncNewTarget = pncNewTarget->m_pncNext;
                        for (iNewSlot = 0;
                             iNewSlot < NODES_PER_CLUMP;
                             iNewSlot++)
                        {
                            if (pncNewTarget->IsEmptyNode(iNewSlot))
                                goto found_slot;
                        }
                    }

                    // Oops, reached the last nodeclump in pncNewTarget
                    // and it's full.  Get a new nodeclump off the free
                    // list, which is big enough to handle all needs.
                    IRTLASSERT(pncNewTarget != NULL);
                    IRTLASSERT(pncFreeList != NULL);
                    pncTmp = pncFreeList;
                    pncFreeList = pncFreeList->m_pncNext;
                    pncTmp->Clear();
                    pncNewTarget->m_pncNext = pncTmp;
                    pncNewTarget = pncTmp;
                    iNewSlot = 0;
                }

              found_slot:
                // We have an empty slot in pncNewTarget
                IRTLASSERT(iNewSlot < NODES_PER_CLUMP
                       &&  pncNewTarget != NULL
                       &&  pncNewTarget->IsEmptyNode(iNewSlot)
                       &&  pncNewTarget->InvalidSignature(iNewSlot));

                // Let's copy the node from pncOldList
                pncNewTarget->m_dwKeySigs[iNewSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncNewTarget->m_pvNode[iNewSlot]
                    = pncOldList->m_pvNode[i];

                // Clear old slot
                pncOldList->m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
                pncOldList->m_pvNode[i]    = NULL;

                // find the next free slot in pncNewTarget
                while (++iNewSlot < NODES_PER_CLUMP)
                {
                    if (pncNewTarget->IsEmptyNode(iNewSlot))
                    {
                        break;
                    }
                }
            }
            else // iNewSlot != NODES_PER_CLUMP
            {
                IRTLASSERT(pncOldList->InvalidSignature(i));
            }
        }

        // Move into the next nodeclump in pncOldList
        pncTmp = pncOldList;
        pncOldList = pncOldList->m_pncNext;

        // Append to the free list.  Don't put the first node of
        // pncOldList on the free list, as it's a stack variable.
        if (pncTmp != pncOldFirst)
        {
            pncTmp->m_pncNext = pncFreeList;
            pncFreeList = pncTmp;
        }
    }

    // delete any leftover nodes
    while (pncFreeList != NULL)
    {
        pncTmp = pncFreeList;
        pncFreeList = pncFreeList->m_pncNext;
#ifdef _DEBUG
        pncTmp->m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // _DEBUG
        _FreeNodeClump(pncTmp);
    }

    return LK_SUCCESS;
} // CLKRLinearHashTable::_MergeRecordSets




//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_InitializeIterator
// Synopsis: Make the iterator point to the first record in the hash table.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_InitializeIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  IsWriteLocked()
               :  IsReadLocked());
    if (piter == NULL  ||  piter->m_plht != NULL)
        return LK_BAD_ITERATOR;

    piter->m_plht = this;
    piter->m_dwBucketAddr = 0;

    CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
    IRTLASSERT(pbkt != NULL);
    if (piter->m_lkl == LKL_WRITELOCK)
        pbkt->WriteLock();
    else
        pbkt->ReadLock();

    piter->m_pnc = &pbkt->m_ncFirst;
    piter->m_iNode = -1;

    // Let IncrementIterator do the hard work of finding the first
    // slot in use.
    return IncrementIterator(piter);
} // CLKRLinearHashTable::_InitializeIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::InitializeIterator
// Synopsis: make the iterator point to the first record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::InitializeIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL  &&  piter->m_pht == NULL);
    if (piter == NULL  ||  piter->m_pht != NULL)
        return LK_BAD_ITERATOR;

    // First, lock all the subtables
    if (piter->m_lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());
    if (!IsValid())
        return LK_UNUSABLE;

    piter->m_pht  = this;
    piter->m_ist  = -1;
    piter->m_plht = NULL;

    // Let IncrementIterator do the hard work of finding the first
    // valid node in the subtables.
    return IncrementIterator(piter);
} // CLKRHashTable::InitializeIterator



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::IncrementIterator
// Synopsis: move the iterator on to the next record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::IncrementIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_plht == this);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  IsWriteLocked()
               :  IsReadLocked());
    IRTLASSERT(piter->m_dwBucketAddr < m_cActiveBuckets);
    IRTLASSERT(piter->m_pnc != NULL);
    IRTLASSERT(-1 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP);

    if (piter == NULL  ||  piter->m_plht != this)
        return LK_BAD_ITERATOR;

    const void* pvRecord = NULL;

    if (piter->m_iNode >= 0)
    {
        // Release the reference acquired in the previous call to
        // IncrementIterator
        pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
        _AddRefRecord(pvRecord, -1);
    }

    do
    {
        do
        {
            // find the next slot in the nodeclump that's in use
            while (++piter->m_iNode < NODES_PER_CLUMP)
            {
                pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
                if (pvRecord != NULL)
                {
                    // Add a new reference
                    _AddRefRecord(pvRecord, +1);
                    return LK_SUCCESS;
                }
            }

            // try the next nodeclump in the bucket chain
            piter->m_iNode = -1;
            piter->m_pnc = piter->m_pnc->m_pncNext;
        } while (piter->m_pnc != NULL);

        // Exhausted this bucket chain.  Unlock it.
        CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
        IRTLASSERT(pbkt != NULL);
        IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
                   ?  pbkt->IsWriteLocked()
                   :  pbkt->IsReadLocked());
        if (piter->m_lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();

        // Try the next bucket, if there is one
        if (++piter->m_dwBucketAddr < m_cActiveBuckets)
        {
            pbkt = _Bucket(piter->m_dwBucketAddr);
            IRTLASSERT(pbkt != NULL);
            if (piter->m_lkl == LKL_WRITELOCK)
                pbkt->WriteLock();
            else
                pbkt->ReadLock();
            piter->m_pnc = &pbkt->m_ncFirst;
        }
    } while (piter->m_dwBucketAddr < m_cActiveBuckets);

    // We have fallen off the end of the hashtable
    piter->m_iNode = -1;
    piter->m_pnc = NULL;

    return LK_NO_MORE_ELEMENTS;
} // CLKRLinearHashTable::IncrementIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::IncrementIterator
// Synopsis: move the iterator on to the next record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::IncrementIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_pht == this);
    IRTLASSERT(-1 <= piter->m_ist
           &&  piter->m_ist < static_cast<int>(m_cSubTables));

    if (piter == NULL  ||  piter->m_pht != this)
        return LK_BAD_ITERATOR;

    // Table is already locked
    if (!IsValid())
        return LK_UNUSABLE;

    LK_RETCODE lkrc;
    CLHTIterator* pBaseIter = static_cast<CLHTIterator*>(piter);

    for (;;)
    {
        // Do we have a valid iterator into a subtable?  If not, get one.
        while (piter->m_plht == NULL)
        {
            while (++piter->m_ist < static_cast<int>(m_cSubTables))
            {
                lkrc = m_palhtDir[piter->m_ist]->_InitializeIterator(piter);
                if (lkrc == LK_SUCCESS)
                {
                    IRTLASSERT(m_palhtDir[piter->m_ist] == piter->m_plht);
                    return lkrc;
                }
                else if (lkrc == LK_NO_MORE_ELEMENTS)
                    lkrc = piter->m_plht->_CloseIterator(pBaseIter);

                if (lkrc != LK_SUCCESS)
                    return lkrc;
            }

            // There are no more subtables left.
            return LK_NO_MORE_ELEMENTS;
        }

        // We already have a valid iterator into a subtable.  Increment it.
        lkrc = piter->m_plht->IncrementIterator(pBaseIter);
        if (lkrc == LK_SUCCESS)
            return lkrc;

        // We've exhausted that subtable.  Move on.
        if (lkrc == LK_NO_MORE_ELEMENTS)
            lkrc = piter->m_plht->_CloseIterator(pBaseIter);

        if (lkrc != LK_SUCCESS)
            return lkrc;
    }
} // CLKRHashTable::IncrementIterator



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_CloseIterator
// Synopsis: release the resources held by the iterator
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_CloseIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_plht == this);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  IsWriteLocked()
               :  IsReadLocked());
    IRTLASSERT(piter->m_dwBucketAddr <= m_cActiveBuckets);
    IRTLASSERT(-1 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP);

    if (piter == NULL  ||  piter->m_plht != this)
        return LK_BAD_ITERATOR;

    // Are we abandoning the iterator before the end of the table?
    // If so, need to unlock the bucket.
    if (piter->m_dwBucketAddr < m_cActiveBuckets)
    {
        CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
        IRTLASSERT(pbkt != NULL);
        IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
                   ?  pbkt->IsWriteLocked()
                   :  pbkt->IsReadLocked());
        if (0 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP)
        {
            IRTLASSERT(piter->m_pnc != NULL);
            const void* pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
            _AddRefRecord(pvRecord, -1);
        }
        if (piter->m_lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();
    }

    piter->m_plht = NULL;
    piter->m_pnc  = NULL;

    return LK_SUCCESS;
} // CLKRLinearHashTable::_CloseIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::CloseIterator
// Synopsis: release the resources held by the iterator
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::CloseIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_pht == this);
    IRTLASSERT(-1 <= piter->m_ist
           &&  piter->m_ist <= static_cast<int>(m_cSubTables));

    if (piter == NULL  ||  piter->m_pht != this)
        return LK_BAD_ITERATOR;

    LK_RETCODE lkrc = LK_SUCCESS;

    if (!IsValid())
        lkrc = LK_UNUSABLE;
    else
    {
        // Are we abandoning the iterator before we've reached the end?
        // If so, close the subtable iterator.
        if (piter->m_plht != NULL)
        {
            IRTLASSERT(piter->m_ist < static_cast<int>(m_cSubTables));
            CLHTIterator* pBaseIter = static_cast<CLHTIterator*>(piter);
            piter->m_plht->_CloseIterator(pBaseIter);
        }
    }

    // Unlock all the subtables
    if (piter->m_lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    piter->m_plht = NULL;
    piter->m_pht  = NULL;
    piter->m_ist  = -1;

    return lkrc;
} // CLKRHashTable::CloseIterator


//------------------------------------------------------------------------
// Function: CLKRHashTable::WriteLock
// Synopsis: Lock all subtables for writing
//------------------------------------------------------------------------

void
CLKRHashTable::WriteLock()
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->WriteLock();
        IRTLASSERT(m_palhtDir[i]->IsWriteLocked());
    }
} // CLKRHashTable::WriteLock



//------------------------------------------------------------------------
// Function: CLKRHashTable::ReadLock
// Synopsis: Lock all subtables for reading
//------------------------------------------------------------------------

void
CLKRHashTable::ReadLock() const
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->ReadLock();
        IRTLASSERT(m_palhtDir[i]->IsReadLocked());
    }
} // CLKRHashTable::ReadLock



//------------------------------------------------------------------------
// Function: CLKRHashTable::WriteUnlock
// Synopsis: Unlock all subtables
//------------------------------------------------------------------------

void
CLKRHashTable::WriteUnlock() const
{
    // unlock in reverse order: LIFO
    for (DWORD i = m_cSubTables;  i-- > 0;  )
    {
        IRTLASSERT(m_palhtDir[i]->IsWriteLocked());
        m_palhtDir[i]->WriteUnlock();
        IRTLASSERT(m_palhtDir[i]->IsWriteUnlocked());
    }
} // CLKRHashTable::WriteUnlock



//------------------------------------------------------------------------
// Function: CLKRHashTable::ReadUnlock
// Synopsis: Unlock all subtables
//------------------------------------------------------------------------

void
CLKRHashTable::ReadUnlock() const
{
    // unlock in reverse order: LIFO
    for (DWORD i = m_cSubTables;  i-- > 0;  )
    {
        IRTLASSERT(m_palhtDir[i]->IsReadLocked());
        m_palhtDir[i]->ReadUnlock();
        IRTLASSERT(m_palhtDir[i]->IsReadUnlocked());
    }
} // CLKRHashTable::ReadUnlock



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsWriteLocked
// Synopsis: Are all subtables write-locked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsWriteLocked() const
{
    bool fLocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fLocked = fLocked && m_palhtDir[i]->IsWriteLocked();
    }
    return fLocked;
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsReadLocked
// Synopsis: Are all subtables read-locked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsReadLocked() const
{
    bool fLocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fLocked = fLocked && m_palhtDir[i]->IsReadLocked();
    }
    return fLocked;
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsWriteUnlocked
// Synopsis: Are all subtables write-unlocked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsWriteUnlocked() const
{
    bool fUnlocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fUnlocked = fUnlocked && m_palhtDir[i]->IsWriteUnlocked();
    }
    return fUnlocked;
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsReadUnlocked
// Synopsis: Are all subtables read-unlocked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsReadUnlocked() const
{
    bool fUnlocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fUnlocked = fUnlocked && m_palhtDir[i]->IsReadUnlocked();
    }
    return fUnlocked;
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::Size
// Synopsis: Number of elements in the table
//------------------------------------------------------------------------

DWORD
CLKRHashTable::Size() const
{
    DWORD cSize = 0;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
        cSize += m_palhtDir[i]->Size();

    return cSize;
} // CLKRHashTable::Size



//------------------------------------------------------------------------
// Function: CLKRHashTable::MaxSize
// Synopsis: Maximum possible number of elements in the table
//------------------------------------------------------------------------

DWORD
CLKRHashTable::MaxSize() const
{
    return (m_cSubTables == 0)  ? 0  : m_cSubTables * m_palhtDir[0]->MaxSize();
} // CLKRHashTable::MaxSize



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsValid
// Synopsis: is the table valid?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsValid() const
{
    bool f = (m_lkrcState == LK_SUCCESS     // serious internal failure?
              &&  (m_palhtDir != NULL  &&  m_cSubTables > 0)
              &&  ValidSignature());

    for (DWORD i = 0;  f  &&  i < m_cSubTables;  i++)
        f = f && m_palhtDir[i]->IsValid();

    if (!f)
        m_lkrcState = LK_UNUSABLE;

    return f;
} // CLKRHashTable::IsValid



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRLinearHashTable::SetBucketLockSpinCount(
    WORD wSpins)
{
    m_wBucketLockSpins = wSpins;

    if (BucketLock::PerLockSpin() != LOCK_INDIVIDUAL_SPIN)
        return;
    
    for (DWORD i = 0;  i < m_cDirSegs;  i++)
    {
        CSegment* pseg = m_paDirSegs[i].m_pseg;

        if (pseg != NULL)
        {
            for (DWORD j = 0;  j < m_dwSegSize;  ++j)
            {
                pseg->Slot(j).SetSpinCount(wSpins);
            }
        }
    }
} // CLKRLinearHashTable::SetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRLinearHashTable::GetBucketLockSpinCount()
{
    return m_wBucketLockSpins;
} // CLKRLinearHashTable::GetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetTableLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRHashTable::SetTableLockSpinCount(
    WORD wSpins)
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->SetTableLockSpinCount(wSpins);
} // CLKRHashTable::SetTableLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetTableLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRHashTable::GetTableLockSpinCount()
{
    return ((m_cSubTables == 0)
            ?  LOCK_DEFAULT_SPINS
            :  m_palhtDir[0]->GetTableLockSpinCount());
} // CLKRHashTable::GetTableLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRHashTable::SetBucketLockSpinCount(
    WORD wSpins)
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->SetBucketLockSpinCount(wSpins);
} // CLKRHashTable::SetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRHashTable::GetBucketLockSpinCount()
{
    return ((m_cSubTables == 0)
            ?  LOCK_DEFAULT_SPINS
            :  m_palhtDir[0]->GetBucketLockSpinCount());
} // CLKRHashTable::GetBucketLockSpinCount



#ifdef __LKRHASH_NAMESPACE__
}
#endif // __LKRHASH_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\manodel.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    manodel.cxx

    This module contains the code for a memory allocation class that doesn't
    delete memory until the class goes away.



    FILE HISTORY:
    1/9/98      michth      created
*/

#include "precomp.hxx"

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <manodel.hxx>


MEMORY_ALLOC_NO_DELETE::MEMORY_ALLOC_NO_DELETE( DWORD dwAllocSize,
                                                DWORD dwAlignment,
                                                BOOL  bSortFree,
                                                DWORD dwMinBlockMultiple,
                                                HANDLE hHeap):
          m_dwAllocSize(dwAllocSize),
          m_dwAlignment(dwAlignment),
          m_dwBlockMultiple(dwMinBlockMultiple),
          m_hHeap(hHeap),
          m_dwNumAlloced(0),
          m_dwNumFree(0),
          m_dwNumBlocks(0),
          m_bSortFree(bSortFree),
          m_pvBlockList(NULL),
          m_pvFreeList(NULL)
{

    //
    // Make sure there really is an alignment
    //

    if (m_dwAlignment == 0) {
        m_dwAlignment = 4;
    }

    //
    // Now Make sure the alignment is a multiple of 4
    //

    AlignAdjust(m_dwAlignment, 4);

    //
    // Align the size
    //

    AlignAdjust(m_dwAllocSize, m_dwAlignment);

    //
    // Calculate the Max Block Multiple
    //

    if (m_dwAllocSize <= 100) {
        m_dwMaxBlockMultiple = 2000 / m_dwAllocSize;
    }
    else if (m_dwAllocSize <= 1000) {
        m_dwMaxBlockMultiple = 10;
    }
    else {
        m_dwMaxBlockMultiple = 5;
    }

    //
    // Determine space to alloc for block header
    //

    m_dwBlockHeaderSpace = BLOCK_HEADER_SIZE;
    AlignAdjust(m_dwBlockHeaderSpace, LESSER_OF(8, m_dwAlignment));


    if (m_dwAlignment > 8) {
        m_dwAlignBytes = m_dwAlignment - 8;
    }
    else {
        m_dwAlignBytes = 0;
    }
    //
    // Get Heap Handle if not passed in
    //

    if (m_hHeap == USE_PROCESS_HEAP) {
        m_hHeap = GetProcessHeap();
    }
    DBG_ASSERT(m_hHeap != NULL);

    INITIALIZE_CRITICAL_SECTION(&m_csLock);
    SET_CRITICAL_SECTION_SPIN_COUNT( &m_csLock, 4000);
}

MEMORY_ALLOC_NO_DELETE::~MEMORY_ALLOC_NO_DELETE()
{
    LockThis();

    PVOID pvIndex, pvNext;

    for (pvIndex = m_pvBlockList;
         pvIndex != NULL;
         pvIndex = pvNext) {
        pvNext = *((PVOID *)pvIndex);
        HeapFree(m_hHeap,
                 /* Flags */ 0,
                 pvIndex);

    }

    UnlockThis();

    DeleteCriticalSection(&m_csLock);
}


PVOID
MEMORY_ALLOC_NO_DELETE::Alloc()
{
    PVOID pvAlloc = NULL;

    LockThis();
    pvAlloc = GetAllocFromFreeList();

    if (pvAlloc == NULL) {
        if (AllocBlock()) {
            pvAlloc = GetAllocFromFreeList();
            DBG_ASSERT (pvAlloc != NULL);
        }
    }
    UnlockThis();
    return pvAlloc;
}

BOOL
MEMORY_ALLOC_NO_DELETE::Free (PVOID pvMem)
{
    if (pvMem != NULL) {

        LockThis();

        if (!m_bSortFree) {
            *((PVOID *)pvMem) = m_pvFreeList;
            m_pvFreeList = pvMem;
        }
        else {

            //
            // Sort the free list.
            // Sort in reverse order, since AddBlockToFreeList
            // puts them on in reverse order.
            //

            PVOID *ppvIndex;
            for (ppvIndex = &m_pvFreeList;
                 (*ppvIndex != NULL) && (*ppvIndex > pvMem);
                 ppvIndex = *(PVOID **)(ppvIndex)) {
            }
            *(PVOID *)pvMem = *ppvIndex;
            *ppvIndex = pvMem;
        }
        m_dwNumFree++;

        UnlockThis();
    }
    return TRUE;
}

VOID
MEMORY_ALLOC_NO_DELETE::GetNewBlockMultiple()
{
    DWORD dwCalculatedMultiple = LESSER_OF((m_dwNumAlloced / 5), m_dwMaxBlockMultiple);
    m_dwBlockMultiple = GREATER_OF(m_dwBlockMultiple, dwCalculatedMultiple);
}

PVOID
MEMORY_ALLOC_NO_DELETE::GetAllocFromFreeList()
{
    PVOID pvAlloc = m_pvFreeList;

    //
    // Remove from free list if necessary
    //

    if (m_pvFreeList != NULL) {
        m_pvFreeList = *((PVOID *)m_pvFreeList);
        m_dwNumFree--;
    }
    return pvAlloc;
}

BOOL
MEMORY_ALLOC_NO_DELETE::AllocBlock()
{
    PVOID pvNewBlock = NULL;
    DWORD dwBlockSize;
    BOOL  bReturn = FALSE;

    GetNewBlockMultiple();

    dwBlockSize = (m_dwAllocSize * m_dwBlockMultiple) +
                  m_dwBlockHeaderSpace + m_dwAlignBytes;

    pvNewBlock = HeapAlloc(m_hHeap,
                           /* Flags */ 0,
                           dwBlockSize);

    if (pvNewBlock == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        *((PVOID *)pvNewBlock) = m_pvBlockList;
        m_pvBlockList = pvNewBlock;
        AddBlockToFreeList(pvNewBlock);
        m_dwNumAlloced += m_dwBlockMultiple;
        m_dwNumBlocks++;
        bReturn = TRUE;
    }
    return bReturn;
}

VOID
MEMORY_ALLOC_NO_DELETE::AddBlockToFreeList(PVOID pvNewBlock)
{
    DBG_ASSERT(pvNewBlock != NULL);

    PBYTE pbFirstAlloc = (PBYTE)pvNewBlock + m_dwBlockHeaderSpace;

    if (m_dwAlignment > 8) {

        //
        // May need to put some bytes in front to align allocs
        // Find the first place that is aligned.
        //

        ULONG_PTR firstAlloc = (ULONG_PTR)pbFirstAlloc;
        AlignAdjust(firstAlloc, (ULONG_PTR)m_dwAlignment);
        pbFirstAlloc = (PBYTE)firstAlloc;
    }

    PVOID pvEnd = (PVOID)((PBYTE)pbFirstAlloc + (m_dwBlockMultiple * m_dwAllocSize));

    for (PVOID pvAllocIndex = (PVOID)pbFirstAlloc;
         pvAllocIndex < pvEnd;
        pvAllocIndex = (PVOID)((PBYTE)pvAllocIndex + m_dwAllocSize)) {
        *((PVOID *)pvAllocIndex) = m_pvFreeList;
        m_pvFreeList = pvAllocIndex;
    }
    m_dwNumFree += m_dwBlockMultiple;
}


VOID
MEMORY_ALLOC_NO_DELETE::AlignAdjust(DWORD &rdwSize, DWORD dwAlignment)
{
    if ((rdwSize % dwAlignment != 0)) {
        rdwSize &= (0xFFFFFFFF - dwAlignment + 1);
        rdwSize += dwAlignment;
    }
}

#ifdef _WIN64
VOID
MEMORY_ALLOC_NO_DELETE::AlignAdjust(ULONG_PTR &rSize, ULONG_PTR Alignment)
{
    rSize = ( rSize + Alignment - 1 ) & ~( Alignment - 1 );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\misc.cpp ===
#include "precomp.hxx"

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <irtlmisc.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\locks.cpp ===
/*++

   Copyright    (c)    1998-1999    Microsoft Corporation

   Module  Name :
       locks.cpp

   Abstract:
       A collection of locks for multithreaded access to data structures

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/


#include "precomp.hxx"

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <locks.h>


#ifdef __LOCKS_NAMESPACE__
namespace Locks {
#endif // __LOCKS_NAMESPACE__


#define LOCK_DEFAULT_SPIN_DATA(CLASS)                       \
  WORD   CLASS::sm_wDefaultSpinCount  = LOCK_DEFAULT_SPINS; \
  double CLASS::sm_dblDfltSpinAdjFctr = 0.5


#ifdef LOCK_INSTRUMENTATION

# define LOCK_STATISTICS_DATA(CLASS)            \
LONG        CLASS::sm_cTotalLocks       = 0;    \
LONG        CLASS::sm_cContendedLocks   = 0;    \
LONG        CLASS::sm_nSleeps           = 0;    \
LONGLONG    CLASS::sm_cTotalSpins       = 0;    \
LONG        CLASS::sm_nReadLocks        = 0;    \
LONG        CLASS::sm_nWriteLocks       = 0


# define LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CLASS)            \
CLockStatistics                 CLASS::Statistics() const       \
{return CLockStatistics();}                                     \
CGlobalLockStatistics           CLASS::GlobalStatistics()       \
{return CGlobalLockStatistics();}                               \
void                            CLASS::ResetGlobalStatistics()  \
{}


# define LOCK_STATISTICS_REAL_IMPLEMENTATION(CLASS)             \
                                                                \
/* Per-lock statistics */                                       \
CLockStatistics                                                 \
CLASS::Statistics() const                                       \
{                                                               \
    CLockStatistics ls;                                         \
                                                                \
    ls.m_nContentions     = m_nContentions;                     \
    ls.m_nSleeps          = m_nSleeps;                          \
    ls.m_nContentionSpins = m_nContentionSpins;                 \
    if (m_nContentions > 0)                                     \
        ls.m_nAverageSpins = m_nContentionSpins / m_nContentions;\
    else                                                        \
        ls.m_nAverageSpins = 0;                                 \
    ls.m_nReadLocks       = m_nReadLocks;                       \
    ls.m_nWriteLocks      = m_nWriteLocks;                      \
    strcpy(ls.m_szName, m_szName);                              \
                                                                \
    return ls;                                                  \
}                                                               \
                                                                \
                                                                \
/* Global statistics for CLASS */                               \
CGlobalLockStatistics                                           \
CLASS::GlobalStatistics()                                       \
{                                                               \
    CGlobalLockStatistics gls;                                  \
                                                                \
    gls.m_cTotalLocks      = sm_cTotalLocks;                    \
    gls.m_cContendedLocks  = sm_cContendedLocks;                \
    gls.m_nSleeps          = sm_nSleeps;                        \
    gls.m_cTotalSpins      = sm_cTotalSpins;                    \
    if (sm_cContendedLocks > 0)                                 \
        gls.m_nAverageSpins = static_cast<LONG>(sm_cTotalSpins / \
                                                sm_cContendedLocks);\
    else                                                        \
        gls.m_nAverageSpins = 0;                                \
    gls.m_nReadLocks       = sm_nReadLocks;                     \
    gls.m_nWriteLocks      = sm_nWriteLocks;                    \
                                                                \
    return gls;                                                 \
}                                                               \
                                                                \
                                                                \
/* Reset global statistics for CLASS */                         \
void                                                            \
CLASS::ResetGlobalStatistics()                                  \
{                                                               \
    sm_cTotalLocks       = 0;                                   \
    sm_cContendedLocks   = 0;                                   \
    sm_nSleeps           = 0;                                   \
    sm_cTotalSpins       = 0;                                   \
    sm_nReadLocks        = 0;                                   \
    sm_nWriteLocks       = 0;                                   \
}


// Note: we are not using Interlocked operations for the shared
// statistical counters.  We'll lose perfect accuracy, but we'll
// gain by reduced bus synchronization traffic.
# define LOCK_INSTRUMENTATION_PROLOG()  \
    ++sm_cContendedLocks;               \
    LONG cTotalSpins = 0;               \
    WORD cSleeps = 0

// Don't need InterlockedIncrement or InterlockedExchangeAdd for 
// member variables, as the lock is now locked by this thread.
# define LOCK_INSTRUMENTATION_EPILOG()  \
    ++m_nContentions;                   \
    m_nSleeps += cSleeps;               \
    m_nContentionSpins += cTotalSpins;  \
    sm_nSleeps += cSleeps;              \
    sm_cTotalSpins += cTotalSpins

#else // !LOCK_INSTRUMENTATION
# define LOCK_STATISTICS_DATA(CLASS)
# define LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CLASS)
# define LOCK_STATISTICS_REAL_IMPLEMENTATION(CLASS)
# define LOCK_INSTRUMENTATION_PROLOG()
# define LOCK_INSTRUMENTATION_EPILOG()
#endif // !LOCK_INSTRUMENTATION



//------------------------------------------------------------------------
// Function: RandomBackoffFactor
// Synopsis: A fudge factor to help avoid synchronization problems
//------------------------------------------------------------------------

double
RandomBackoffFactor()
{
    static const double s_aFactors[] = {
        1.020, 0.965,  0.890, 1.065,
        1.025, 1.115,  0.940, 0.995,
        1.050, 1.080,  0.915, 0.980,
        1.010,
    };
    const int nFactors = sizeof(s_aFactors) / sizeof(s_aFactors[0]);

    // Alternatives for nRand include a static counter
    // or the low DWORD of QueryPerformanceCounter().
    DWORD nRand = ::GetCurrentThreadId();

    return s_aFactors[nRand % nFactors];
}
    


// CSmallSpinLock static member variables

LOCK_DEFAULT_SPIN_DATA(CSmallSpinLock);

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION

LOCK_STATISTICS_DATA(CSmallSpinLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CSmallSpinLock);

#endif // LOCK_SMALL_SPIN_INSTRUMENTATION


//------------------------------------------------------------------------
// Function: CSmallSpinLock::_LockSpin
// Synopsis: Acquire an exclusive lock.  Blocks until acquired.
//------------------------------------------------------------------------

void
CSmallSpinLock::_LockSpin()
{
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    LOCK_INSTRUMENTATION_PROLOG();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
    
    DWORD dwSleepTime = 0;
    LONG  cBaseSpins  = sm_wDefaultSpinCount;
    LONG  cBaseSpins2 = static_cast<LONG>(cBaseSpins * RandomBackoffFactor());

    // This lock cannot be acquired recursively. Attempting to do so will
    // deadlock this thread forever. Use CSpinLock instead if you need that
    // kind of lock.
    if (m_lTid == (LONG) ::GetCurrentThreadId())
    {
        IRTLASSERT(
           !"CSmallSpinLock: Illegally attempted to acquire lock recursively");
    }

    while (!_TryLock())
    {
        // Only spin on a multiprocessor machine and then only if
        // spinning is enabled
        if (NumProcessors() > 1  &&  cBaseSpins != LOCK_DONT_SPIN)
        {
            LONG cSpins = cBaseSpins2;
        
            // Check no more than cBaseSpins2 times then yield.
            // It is important not to use the InterlockedExchange in the
            // inner loop in order to minimize system memory bus traffic.
            while (m_lTid != 0)
            { 
                if (--cSpins < 0)
                { 
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
                    cTotalSpins += cBaseSpins2;
                    ++cSleeps;
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
                    Sleep(dwSleepTime) ;

                    // Backoff algorithm: reduce (or increase) busy wait time
                    cBaseSpins2 = (int) (cBaseSpins2 * sm_dblDfltSpinAdjFctr);
                    // LOCK_MINIMUM_SPINS <= cBaseSpins2 <= LOCK_MAXIMUM_SPINS
                    cBaseSpins2 = min(LOCK_MAXIMUM_SPINS, cBaseSpins2);
                    cBaseSpins2 = max(cBaseSpins2, LOCK_MINIMUM_SPINS);
                    cSpins = cBaseSpins2;

                    // Using Sleep(0) leads to the possibility of priority
                    // inversion.  Sleep(0) only yields the processor if
                    // there's another thread of the same priority that's
                    // ready to run.  If a high-priority thread is trying to
                    // acquire the lock, which is held by a low-priority
                    // thread, then the low-priority thread may never get
                    // scheduled and hence never free the lock.  NT attempts
                    // to avoid priority inversions by temporarily boosting
                    // the priority of low-priority runnable threads, but the
                    // problem can still occur if there's a medium-priority
                    // thread that's always runnable.  If Sleep(1) is used,
                    // then the thread unconditionally yields the CPU.  We
                    // only do this for the second and subsequent even
                    // iterations, since a millisecond is a long time to wait
                    // if the thread can be scheduled in again sooner
                    // (~100,000 instructions).
                    // Avoid priority inversion: 0, 1, 0, 1,...
                    dwSleepTime = !dwSleepTime;
                }
                else
                {
                    Lock_Yield();
                }
            }

            // Lock is now available, but we still need to do the
            // InterlockedExchange to atomically grab it for ourselves.
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
            cTotalSpins += cBaseSpins2 - cSpins;
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
        }

        // On a 1P machine, busy waiting is a waste of time
        else
        {
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
            ++cSleeps;
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
            Sleep(dwSleepTime);

            // Avoid priority inversion: 0, 1, 0, 1,...
            dwSleepTime = !dwSleepTime;
        }

    }

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    LOCK_INSTRUMENTATION_EPILOG();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
}



// CSpinLock static member variables

LOCK_DEFAULT_SPIN_DATA(CSpinLock);
LOCK_STATISTICS_DATA(CSpinLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CSpinLock);


//------------------------------------------------------------------------
// Function: CSpinLock::_LockSpin
// Synopsis: Acquire an exclusive lock.  Blocks until acquired.
//------------------------------------------------------------------------

void
CSpinLock::_LockSpin()
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime   = 0;
    bool  fAcquiredLock = false;
    LONG  cBaseSpins    = sm_wDefaultSpinCount;

    cBaseSpins = static_cast<LONG>(cBaseSpins * RandomBackoffFactor());

    while (!fAcquiredLock)
    {
        // Only spin on a multiprocessor machine and then only if
        // spinning is enabled
        if (NumProcessors() > 1  &&  sm_wDefaultSpinCount != LOCK_DONT_SPIN)
        {
            LONG cSpins = cBaseSpins;
        
            // Check no more than cBaseSpins times then yield
            while (m_lTid != 0)
            { 
                if (--cSpins < 0)
                { 
#ifdef LOCK_INSTRUMENTATION
                    cTotalSpins += cBaseSpins;
                    ++cSleeps;
#endif // LOCK_INSTRUMENTATION

                    Sleep(dwSleepTime) ;

                    // Backoff algorithm: reduce (or increase) busy wait time
                    cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
                    // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
                    cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
                    cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
                    cSpins = cBaseSpins;
            
                    // Avoid priority inversion: 0, 1, 0, 1,...
                    dwSleepTime = !dwSleepTime;
                }
                else
                {
                    Lock_Yield();
                }
            }

            // Lock is now available, but we still need to atomically
            // update m_cOwners and m_nThreadId to grab it for ourselves.
#ifdef LOCK_INSTRUMENTATION
            cTotalSpins += cBaseSpins - cSpins;
#endif // LOCK_INSTRUMENTATION
        }

        // on a 1P machine, busy waiting is a waste of time
        else
        {
#ifdef LOCK_INSTRUMENTATION
            ++cSleeps;
#endif // LOCK_INSTRUMENTATION
            Sleep(dwSleepTime);
            
            // Avoid priority inversion: 0, 1, 0, 1,...
            dwSleepTime = !dwSleepTime;
        }

        // Is the lock unowned?
        if (_TryLock())
            fAcquiredLock = true; // got the lock
    }

    IRTLASSERT((m_lTid & OWNER_MASK) > 0
               &&  (m_lTid & THREAD_MASK) == _CurrentThreadId());

    LOCK_INSTRUMENTATION_EPILOG();
}



// CFakeLock static member variables

LOCK_DEFAULT_SPIN_DATA(CFakeLock);
LOCK_STATISTICS_DATA(CFakeLock);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CFakeLock);


// CCritSec static member variables

LOCK_DEFAULT_SPIN_DATA(CCritSec);
LOCK_STATISTICS_DATA(CCritSec);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CCritSec);


//------------------------------------------------------------------------
// SetCriticalSectionSpinCount hackery


typedef
DWORD
(WINAPI * PFN_SET_CRITICAL_SECTION_SPIN_COUNT)(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
   );

static PFN_SET_CRITICAL_SECTION_SPIN_COUNT  g_pfnSetCSSpinCount = NULL;


//------------------------------------------------------------------------
// Function: FakeSetCriticalSectionSpinCount
// Synopsis: This function fakes setting critical section spin count.
//           See CCritSec::SetSpinCount() for details
// Returns:  0 - since we are faking the set of cs with spin count
//------------------------------------------------------------------------

static DWORD WINAPI
FakeSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION /*lpCriticalSection*/,
    DWORD              /*dwSpinCount*/)
{
    // For faked critical sections, the previous spin count is just ZERO!
    return 0;
}


//------------------------------------------------------------------------
// Function: CCritSec::SetSpinCount
// Synopsis: This function is used to call the appropriate underlying
//           functions to set the spin count for the supplied critical
//           section. The original function is supposed to be exported out
//           of kernel32.dll from NT 4.0 SP3. If the func is not available
//           from the dll, we will use a fake function.
//
// Arguments:
//   lpCriticalSection
//      Points to the critical section object.
//
//   dwSpinCount
//      Supplies the spin count for the critical section object. For UP
//      systems, the spin count is ignored and the critical section spin
//      count is set to 0. For MP systems, if contention occurs, instead of
//      waiting on a semaphore associated with the critical section, the
//      calling thread will spin for spin count iterations before doing the
//      hard wait. If the critical section becomes free during the spin, a
//      wait is avoided.
//
// Returns:
//      The previous spin count for the critical section is returned.
//------------------------------------------------------------------------

DWORD
CCritSec::SetSpinCount(
    LPCRITICAL_SECTION pcs,
    DWORD dwSpinCount)
{
    if (g_pfnSetCSSpinCount == NULL)
    {
        PFN_SET_CRITICAL_SECTION_SPIN_COUNT pfn = NULL;

        //
        // load kernel32 and get NT specific entry points
        //

        HINSTANCE tmpInstance = LoadLibrary("kernel32.dll");
        if (tmpInstance != NULL)
        {
            pfn = (PFN_SET_CRITICAL_SECTION_SPIN_COUNT)
                    GetProcAddress(tmpInstance, "SetCriticalSectionSpinCount");

            //
            // We can free this because we are statically linked to it
            //

            FreeLibrary(tmpInstance);
        }

        // fallback to thunking to the dummy routine
        g_pfnSetCSSpinCount = ((pfn != NULL)
                               ? pfn
                               : FakeSetCriticalSectionSpinCount);
    }

    // Pass the inputs to the global function pointer which is already setup.
    return g_pfnSetCSSpinCount(pcs, dwSpinCount);
}



// CRtlResource static member variables

LOCK_DEFAULT_SPIN_DATA(CRtlResource);
LOCK_STATISTICS_DATA(CRtlResource);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CRtlResource);


// CShareLock static member variables

LOCK_DEFAULT_SPIN_DATA(CShareLock);
LOCK_STATISTICS_DATA(CShareLock);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CShareLock);



// CReaderWriterLock static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock);
LOCK_STATISTICS_DATA(CReaderWriterLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock);


void
CReaderWriterLock::_LockSpin(
    bool fWrite)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = static_cast<LONG>(sm_wDefaultSpinCount
                                           * RandomBackoffFactor());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        if (NumProcessors() < 2  ||  sm_wDefaultSpinCount == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock = fWrite  ?  _TryWriteLock()  :  _TryReadLock();
            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        Sleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT(fWrite ? IsWriteLocked() : IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



// CReaderWriterLock2 static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock2);
LOCK_STATISTICS_DATA(CReaderWriterLock2);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock2);


void
CReaderWriterLock2::_WriteLockSpin()
{
    // Add ourselves to the queue of waiting writers
    for (LONG l = m_lRW;  !_CmpExch(l + SL_WRITER_INCR, l);  l = m_lRW)
    {
        Lock_Yield();
    }
    
    _LockSpin(true);
}


void
CReaderWriterLock2::_LockSpin(
    bool fWrite)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = static_cast<LONG>(sm_wDefaultSpinCount
                                           * RandomBackoffFactor());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        if (NumProcessors() < 2  ||  sm_wDefaultSpinCount == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock = fWrite  ?  _TryWriteLock(0)  :  _TryReadLock();

            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        Sleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT(fWrite ? IsWriteLocked() : IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



// CReaderWriterLock3 static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock3);
LOCK_STATISTICS_DATA(CReaderWriterLock3);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock3);


void
CReaderWriterLock3::_WriteLockSpin()
{
    // Add ourselves to the queue of waiting writers
    for (LONG l = m_lRW;  !_CmpExch(l + SL_WRITER_INCR, l);  l = m_lRW)
    {
        Lock_Yield();
    }
    
    _LockSpin(true);
}


void
CReaderWriterLock3::_LockSpin(
    bool fWrite)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = static_cast<LONG>(sm_wDefaultSpinCount
                                           * RandomBackoffFactor());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        if (NumProcessors() < 2  ||  sm_wDefaultSpinCount == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock = fWrite  ?  _TryWriteLock(0)  :  _TryReadLock();

            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        Sleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT(fWrite ? IsWriteLocked() : IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



#ifdef __LOCKS_NAMESPACE__
}
#endif // __LOCKS_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\madel.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    madel.cxx

    This module contains the code for a memory allocation class that doesn't
    delete memory until the class goes away.



    FILE HISTORY:
    1/12/98      michth      created
*/

#include "precomp.hxx"

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <manodel.hxx>
#include <madel.hxx>

MEMORY_ALLOC_DELETE::MEMORY_ALLOC_DELETE( DWORD dwAllocSize,
                                          DWORD dwAlignment,
                                          DWORD dwReserveNum,
                                          DWORD dwMinBlockMultiple,
                                          DWORD dwMaxBlockMultiple,
                                          HANDLE hHeap):
          m_dwAllocSize(dwAllocSize),
          m_dwAlignment(dwAlignment),
          m_dwReserveNum(dwReserveNum),
          m_dwBlockMultiple(dwMinBlockMultiple),
          m_dwMaxBlockMultiple(dwMaxBlockMultiple),
          m_hHeap(hHeap),
          m_dwNumAlloced(0),
          m_dwNumFree(0),
          m_dwNumBlocks(0),
          m_dwBlockHeaderSpace(sizeof(MADEL_BLOCK_HEADER)),
          m_dwAllocHeaderSpace(sizeof(MADEL_ALLOC_HEADER))
{
    //DebugBreak();

    //DBG_ASSERT ((dwAlignment == 4) || (dwAlignment == 8));

    //
    // Make sure there really is an alignment
    //

    if (m_dwAlignment == 0) {
        m_dwAlignment = 4;
    }

    //
    // Now Make sure the alignment is a multiple of 4
    //

    AlignAdjust(m_dwAlignment, 4);

    //
    // The alloc header uses 7 bits to store the block number, so max block multiple
    // is 128
    //

    m_dwMaxBlockMultiple = LESSER_OF(m_dwMaxBlockMultiple, MADEL_MAX_ALLOWED_BLOCK_MULTIPLE);
    m_dwBlockMultiple = LESSER_OF(m_dwBlockMultiple, MADEL_MAX_ALLOWED_BLOCK_MULTIPLE);

    if (m_dwBlockMultiple > m_dwMaxBlockMultiple) {
        m_dwBlockMultiple = m_dwMaxBlockMultiple;
    }

    m_bMaxBlockMultipleEqualsMin = (m_dwMaxBlockMultiple == m_dwBlockMultiple) ? TRUE : FALSE;

    //
    // Align the size
    //

    AlignAdjust(m_dwAllocSize, m_dwAlignment);
    DBG_ASSERT(m_dwAllocSize != 0);
    DBG_ASSERT(m_dwAllocSize <= MADEL_MAX_ALLOWED_SIZE);

    //
    // Determine space to alloc for block header & Alloc header
    // The block header just needs to be aligned by 4. It will be
    // placed appropriately in the block so that the first alloc
    // header will be appropriately aligned.
    //

    AlignAdjust(m_dwBlockHeaderSpace, LESSER_OF(8, m_dwAlignment));

    AlignAdjust(m_dwAllocHeaderSpace, m_dwAlignment);

    if (m_dwAlignment > 8) {
        m_dwAlignBytes = m_dwAlignment - 8;
    }
    else {
        m_dwAlignBytes = 0;
    }

    //
    // Get Heap Handle if not passed in
    //

    if (m_hHeap == MADEL_USE_PROCESS_HEAP) {
        m_hHeap = GetProcessHeap();
    }
    DBG_ASSERT(m_hHeap != NULL);

    INITIALIZE_CRITICAL_SECTION(&m_csLock);
    SET_CRITICAL_SECTION_SPIN_COUNT( &m_csLock, 4000);

    InitializeListHead( &m_leBlockList );
    InitializeListHead( &m_leFreeList );
    InitializeListHead( &m_leDeleteList );
}

MEMORY_ALLOC_DELETE::~MEMORY_ALLOC_DELETE()
{
    LockThis();

    PLIST_ENTRY pleIndex, pleNext;

    for ( pleIndex = m_leDeleteList.Flink ;
          pleIndex != &m_leDeleteList ;
          pleIndex =  pleNext )
    {
        pleNext = pleIndex->Flink;
        RemoveEntryList(pleIndex);
        HeapFree(m_hHeap,
                 /* Flags */ 0,
                 (PVOID)((PBYTE)pleIndex - ((PMADEL_BLOCK_HEADER)pleIndex)->byteAlignBytes));

    }

    DBG_ASSERT(IsListEmpty(&m_leBlockList));
    DBG_ASSERT(IsListEmpty(&m_leFreeList));

    UnlockThis();

    DeleteCriticalSection(&m_csLock);
}

PVOID
MEMORY_ALLOC_DELETE::Alloc()
{
    PVOID pvAlloc = NULL;

    LockThis();

    pvAlloc = GetAllocFromList(&m_leFreeList);

    if (pvAlloc == NULL) {
        pvAlloc = GetAllocFromList(&m_leDeleteList);
    }

    if (pvAlloc == NULL) {
        if (AllocBlock()) {
            pvAlloc = GetAllocFromList(&m_leFreeList);
            DBG_ASSERT (pvAlloc != NULL);
        }
    }

    UnlockThis();
    return (PVOID)((PBYTE)pvAlloc + m_dwAllocHeaderSpace);
}

BOOL
MEMORY_ALLOC_DELETE::Free (PVOID pvMem)
{
    if (pvMem != NULL) {

        PMADEL_BLOCK_HEADER pmbhCurrentBlock;
        PMADEL_ALLOC_HEADER pmahCurrentAlloc;
        PLIST_ENTRY pleIndex, pleNext;

        LockThis();

        //
        // pvMem points to usable mem, header precedes it.
        //

        pmahCurrentAlloc = (PMADEL_ALLOC_HEADER)((PBYTE)pvMem - m_dwAllocHeaderSpace);

        //
        // First find the block this is on
        //

        pmbhCurrentBlock = GetBlockFromAlloc(pmahCurrentAlloc);

        //
        // Add it to the free list
        //

        *((PVOID *)pvMem) = pmbhCurrentBlock->pvFreeList;
        pmbhCurrentBlock->pvFreeList = (PVOID)pmahCurrentAlloc;
        pmbhCurrentBlock->byteNumFree++;
        m_dwNumFree++;

        DBG_ASSERT(&(pmbhCurrentBlock->m_leBlockList) == (PLIST_ENTRY)pmbhCurrentBlock);

        if (pmbhCurrentBlock->byteNumFree == pmbhCurrentBlock->byteBlockMultiple) {

            //
            // Move to Delete List
            //

            if (IsListEmpty(&m_leDeleteList)) {
                m_byteLeastAllocsOnFreeList = pmbhCurrentBlock->byteBlockMultiple;
            }
            else {
                m_byteLeastAllocsOnFreeList =
                    LESSER_OF(m_byteLeastAllocsOnFreeList, pmbhCurrentBlock->byteBlockMultiple);
            }

            RemoveEntryList((PLIST_ENTRY)pmbhCurrentBlock);
            InsertHeadList(&m_leDeleteList,(PLIST_ENTRY)pmbhCurrentBlock);


        }
        else if ( pmbhCurrentBlock->byteNumFree == 1 ) {

            //
            // It's on the block list, Move to free list
            //

            RemoveEntryList((PLIST_ENTRY)pmbhCurrentBlock);
            InsertHeadList(&m_leFreeList, (PLIST_ENTRY)pmbhCurrentBlock);
        }

        //
        // Now see if a block can be deleted. This could be because one was added above,
        // or because m_dwNumFree is now high enough.
        //

        if (!IsListEmpty(&m_leDeleteList) && (m_dwNumFree >= (m_dwReserveNum + m_byteLeastAllocsOnFreeList))) {

            //
            // Remove Block and reset min
            //

            if (m_bMaxBlockMultipleEqualsMin) {

                //
                // Don't need to find a block that fits or recalculate the minblock multiple.
                // Just delete a block;
                //

                pleIndex = m_leDeleteList.Flink;
                RemoveEntryList(pleIndex);
                m_dwNumFree -= ((PMADEL_BLOCK_HEADER)pleIndex)->byteNumFree;
                m_dwNumAlloced -= ((PMADEL_BLOCK_HEADER)pleIndex)->byteNumFree;
                m_dwNumBlocks--;
                HeapFree(m_hHeap,
                         /* Flags */ 0,
                         (PVOID)((PBYTE)pleIndex - ((PMADEL_BLOCK_HEADER)pleIndex)->byteAlignBytes));
            }
            else {

                m_byteLeastAllocsOnFreeList = (BYTE)m_dwMaxBlockMultiple;

                for ( pleIndex = m_leDeleteList.Flink ;
                      pleIndex != &m_leDeleteList ;
                      pleIndex =  pleNext )
                {
                    pleNext = pleIndex->Flink;
                    if (m_dwNumFree >= (m_dwReserveNum + ((PMADEL_BLOCK_HEADER)pleIndex)->byteBlockMultiple) ) {
                        RemoveEntryList(pleIndex);
                        m_dwNumFree -= ((PMADEL_BLOCK_HEADER)pleIndex)->byteNumFree;
                        m_dwNumAlloced -= ((PMADEL_BLOCK_HEADER)pleIndex)->byteNumFree;
                        m_dwNumBlocks--;
                        HeapFree(m_hHeap,
                                 /* Flags */ 0,
                                 (PVOID)((PBYTE)pleIndex - ((PMADEL_BLOCK_HEADER)pleIndex)->byteAlignBytes));

                    }
                    else {
                        m_byteLeastAllocsOnFreeList =
                            LESSER_OF(m_byteLeastAllocsOnFreeList, ((PMADEL_BLOCK_HEADER)pleIndex)->byteBlockMultiple);
                    }
                }
            }

        }

        UnlockThis();
    }
    return TRUE;
}

VOID
MEMORY_ALLOC_DELETE::GetNewBlockMultiple()
{
    DWORD dwCalculatedMultiple = LESSER_OF((m_dwNumAlloced / 5), m_dwMaxBlockMultiple);
    m_dwBlockMultiple = GREATER_OF(m_dwBlockMultiple, dwCalculatedMultiple);
}

PVOID
MEMORY_ALLOC_DELETE::GetAllocFromList(PLIST_ENTRY pleListHead)
{
    PVOID pvAlloc = NULL;
    PLIST_ENTRY pleFreeBlock;
    PMADEL_BLOCK_HEADER pmbhFreeBlock;

    //
    // Remove from list
    //

    if (!IsListEmpty(pleListHead)) {
        pleFreeBlock = RemoveHeadList(pleListHead);
        DBG_ASSERT(pleFreeBlock != NULL);
        pmbhFreeBlock = (PMADEL_BLOCK_HEADER)pleFreeBlock;
        DBG_ASSERT(pmbhFreeBlock == (CONTAINING_RECORD(pleFreeBlock, MADEL_BLOCK_HEADER, m_leBlockList)));
        pvAlloc = pmbhFreeBlock->pvFreeList;
        DBG_ASSERT(pvAlloc != NULL);
        pmbhFreeBlock->pvFreeList = *((PVOID *)((PBYTE)(pmbhFreeBlock->pvFreeList) + m_dwAllocHeaderSpace));
        pmbhFreeBlock->byteNumFree--;
        m_dwNumFree--;

        //
        // Put the block back on a list.
        // Just removed one element, so know it doesn't go on the Delete list.
        //

        if (pmbhFreeBlock->byteNumFree == 0) {
            InsertHeadList(&m_leBlockList, pleFreeBlock);
        }
        else {
            InsertHeadList(&m_leFreeList, pleFreeBlock);
        }
    }
    return pvAlloc;
}

BOOL
MEMORY_ALLOC_DELETE::AllocBlock()
{
    PVOID pvNewBlock = NULL;
    DWORD dwBlockSize;
    BOOL  bReturn = FALSE;

    GetNewBlockMultiple();

    dwBlockSize = ((m_dwAllocSize + m_dwAllocHeaderSpace) * m_dwBlockMultiple) +
                  m_dwBlockHeaderSpace + m_dwAlignBytes;

    pvNewBlock = HeapAlloc(m_hHeap,
                           /* Flags */ 0,
                           dwBlockSize);
    if (pvNewBlock == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {

        //
        // Put the block on the free list. Since all allocs are available,
        // it really belongs on the delete list, but one will immediately be
        // taken off, so just put it on the free list.
        //

        PBYTE pbFirstAlloc = (PBYTE)pvNewBlock + m_dwBlockHeaderSpace;

        if (m_dwAlignment > 8) {

            //
            // May need to put some bytes in front to align allocs
            // Find the first place that is aligned.
            //

            ULONG_PTR firstAlloc = (ULONG_PTR)pbFirstAlloc;
            AlignAdjust(firstAlloc, (ULONG_PTR)m_dwAlignment);
            pbFirstAlloc = (PBYTE)firstAlloc;
        }

        PMADEL_BLOCK_HEADER pmbhBlockHeader = (PMADEL_BLOCK_HEADER)((PBYTE)pbFirstAlloc - m_dwBlockHeaderSpace);

        InsertHeadList(&m_leFreeList, (PLIST_ENTRY)pmbhBlockHeader);
        pmbhBlockHeader->byteBlockMultiple = (BYTE)m_dwBlockMultiple;
        pmbhBlockHeader->byteNumFree = (BYTE)m_dwBlockMultiple;
        pmbhBlockHeader->byteAlignBytes = DIFF((PBYTE)pmbhBlockHeader - (PBYTE)pvNewBlock);
        CreateBlockFreeList(pmbhBlockHeader);
        m_dwNumAlloced += m_dwBlockMultiple;
        m_dwNumFree += m_dwBlockMultiple;
        m_dwNumBlocks++;
        bReturn = TRUE;
    }
    /* INTRINSA suppress = leaks */
    return bReturn;
}

VOID
MEMORY_ALLOC_DELETE::CreateBlockFreeList(PMADEL_BLOCK_HEADER pmbhNewBlock)
{
   PVOID pvEnd = (PVOID)((PBYTE)pmbhNewBlock + m_dwBlockHeaderSpace +
                         (m_dwBlockMultiple * (m_dwAllocSize + m_dwAllocHeaderSpace)));

   DBG_ASSERT(pmbhNewBlock != NULL);

   pmbhNewBlock->pvFreeList = NULL;

   BYTE i;
   PVOID pvAllocIndex;

   for ((pvAllocIndex = (PVOID)((PBYTE)pmbhNewBlock + m_dwBlockHeaderSpace)), i = 0;
        pvAllocIndex < pvEnd;
        pvAllocIndex = (PVOID)((PBYTE)pvAllocIndex + m_dwAllocSize + m_dwAllocHeaderSpace), i++) {
       InitAllocHead((PMADEL_ALLOC_HEADER)pvAllocIndex, i);
       *((PVOID *)((PBYTE)pvAllocIndex + m_dwAllocHeaderSpace)) = pmbhNewBlock->pvFreeList;
       pmbhNewBlock->pvFreeList = pvAllocIndex;
   }
}

VOID
MEMORY_ALLOC_DELETE::AlignAdjust(DWORD &rdwSize, DWORD dwAlignment)
{
    if ((rdwSize % dwAlignment != 0)) {
        rdwSize &= (0xFFFFFFFF - dwAlignment + 1);
        rdwSize += dwAlignment;
    }
}

#ifdef _WIN64
VOID
MEMORY_ALLOC_DELETE::AlignAdjust(ULONG_PTR &rSize, ULONG_PTR Alignment)
{
    rSize = ( rSize + Alignment - 1 ) & ~( Alignment - 1 );
}
#endif

VOID
MEMORY_ALLOC_DELETE::InitAllocHead(PMADEL_ALLOC_HEADER pvAlloc,
                                   DWORD dwAllocIndex)
{
    pvAlloc->dwSize = m_dwAllocSize;
    pvAlloc->bNumAlloc = dwAllocIndex;
    pvAlloc->bMadelAlloc = 1;
}

PMADEL_BLOCK_HEADER
MEMORY_ALLOC_DELETE::GetBlockFromAlloc(PMADEL_ALLOC_HEADER pmahMem)
{
    return (PMADEL_BLOCK_HEADER)((PBYTE)pmahMem -
        ((pmahMem->bNumAlloc * (m_dwAllocSize + m_dwAllocHeaderSpace)) + m_dwBlockHeaderSpace));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\mlszau.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    string.cxx

    This module contains a light weight string class


    FILE HISTORY:
    4/8/97      michth      created

*/


//
// Normal includes only for this module to be active
//

#include "precomp.hxx"
#include "aucommon.hxx"


/*******************************************************************

    NAME:       MLSZAU::STR

    SYNOPSIS:   Construct a string object

    ENTRY:      Optional object initializer

    NOTES:      If the object is not valid (i.e. !IsValid()) then GetLastError
                should be called.

                The object is guaranteed to construct successfully if nothing
                or NULL is passed as the initializer.

********************************************************************/

// Inlined in stringau.hxx


VOID
MLSZAU::AuxInit( const LPSTR pInit,
                 DWORD cbLen )
{
    BOOL fRet;

    if ( pInit )
    {
        INT cbCopy;

        if (cbLen != 0) {
            DBG_ASSERT(cbLen >= 2);
            DBG_ASSERT(pInit[cbLen -1] == '\0');
            DBG_ASSERT(pInit[cbLen -2] == '\0');
            cbCopy = cbLen;
        }
        else {
            LPSTR pszIndex;
            for (pszIndex = pInit;
                 *pszIndex != '\0' || *(pszIndex + 1) != '\0';
                 pszIndex++) {
            }
            cbCopy = ((DWORD)(pszIndex - pInit)) + 2;
        }

        fRet = m_bufAnsi.Resize( cbCopy );

        if ( fRet ) {
            CopyMemory( m_bufAnsi.QueryPtr(), pInit, cbCopy );
            m_cbMultiByteLen = (cbCopy)/sizeof(CHAR);
            m_bUnicode = FALSE;
            m_bInSync = FALSE;
        } else {
            m_bIsValid = FALSE;
        }

    } else {
        Reset();
    }

    return;
} // MLSZAU::AuxInit()


VOID
MLSZAU::AuxInit( const LPWSTR pInit,
                DWORD cchLen )
{
    BOOL fRet;

    if ( pInit )
    {
        INT cbCopy;

        if (cchLen != 0) {
            DBG_ASSERT(cchLen >= 2);
            DBG_ASSERT(pInit[cchLen -1] == (WCHAR)'\0');
            DBG_ASSERT(pInit[cchLen -2] == (WCHAR)'\0');
            cbCopy = cchLen * sizeof(WCHAR);
        }
        else {
            LPWSTR pszIndex;
            for (pszIndex = pInit;
                 *pszIndex != '\0' || *(pszIndex + 1) != '\0';
                 pszIndex++) {
            }
            cbCopy = ((DIFF(pszIndex - pInit)) + 2) * sizeof(WCHAR);
        }

        fRet = m_bufUnicode.Resize( cbCopy );

        if ( fRet ) {
            CopyMemory( m_bufUnicode.QueryPtr(), pInit, cbCopy );
            m_cchUnicodeLen = (cbCopy)/sizeof(WCHAR);
            m_bUnicode = TRUE;
            m_bInSync = FALSE;
        } else {
            m_bIsValid = FALSE;
        }

    } else {
        Reset();
    }

    return;
} // MLSZAU::AuxInit()



LPTSTR
MLSZAU::QueryStr(BOOL bUnicode)
{

    //
    // This routine can fail.
    // On failure, return a valid UNICODE or ANSI string
    // so clients don't trap.
    //
    LPTSTR pszReturn = NULL;
    int iNewStrLen;

    if (m_bIsValid) {
        if ((bUnicode != m_bUnicode) &&
            (!m_bInSync) &&
            ((m_bUnicode && (m_cchUnicodeLen != 0)) ||
              (!m_bUnicode && (m_cbMultiByteLen != 0)))) {
            //
            // Need to Convert First
            //
            if (bUnicode) {
                //
                // Convert current string to UNICODE
                //
                // Conversion routines assume a real string and
                // add 1 to length for trailing \0 so subtract
                // one from total length.
                //
                iNewStrLen = ConvertMultiByteToUnicode((LPSTR)m_bufAnsi.QueryPtr(), &m_bufUnicode, m_cbMultiByteLen - 1);
                if (STR_CONVERSION_SUCCEEDED(iNewStrLen)) {
                    m_cchUnicodeLen = iNewStrLen+1;
                    m_bInSync = TRUE;
                }
                else {
                    m_bIsValid = FALSE;
                }
            }
            else {
                //
                // Convert current string to Ansi
                //
                iNewStrLen = ConvertUnicodeToMultiByte((LPWSTR)m_bufUnicode.QueryPtr(), &m_bufAnsi, m_cchUnicodeLen - 1);
                if (STR_CONVERSION_SUCCEEDED(iNewStrLen)) {
                    m_cbMultiByteLen = iNewStrLen+1;
                    m_bInSync = TRUE;
                }
                else {
                    m_bIsValid = FALSE;
                }
            }
        }

        if (m_bIsValid) {
            if (bUnicode) {
                pszReturn = (LPTSTR)m_bufUnicode.QueryPtr();
            }
            else {
                pszReturn = (LPTSTR)m_bufAnsi.QueryPtr();
            }

        }
    }

    return pszReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\multisz.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    multisz.cxx

    This module contains a light weight multi-string class


    FILE HISTORY:
        KeithMo     20-Jan-1997 Created from string.cxx

*/

#include "precomp.hxx"


# include <dbgutil.h>
# include <multisz.hxx>
# include <auxctrs.h>

# include <tchar.h>

//
//  Private Definitions
//

//
//  When appending data, this is the extra amount we request to avoid
//  reallocations
//
#define STR_SLOP        128


DWORD
MULTISZ::CalcLength( const CHAR * str,
                     LPDWORD pcStrings )
{
    DWORD count = 0;
    DWORD total = 1;
    DWORD len;

    while( *str ) {
        len = ::strlen( str ) + 1;
        total += len;
        str += len;
        count++;
    }

    if( pcStrings != NULL ) {
        *pcStrings = count;
    }

    return total;

}   // MULTISZ::CalcLength


BOOL
MULTISZ::FindString( const CHAR * str )
{

    CHAR * multisz;

    //
    // Sanity check.
    //

    DBG_ASSERT( QueryStr() != NULL );
    DBG_ASSERT( str != NULL );
    DBG_ASSERT( *str != '\0' );

    //
    // Scan it.
    //

    multisz = QueryStr();

    while( *multisz != '\0' ) {

        if( !::strcmp( multisz, str ) ) {

            return TRUE;

        }

        multisz += ::strlen( multisz ) + 1;

    }

    return FALSE;

}   // MULTISZ::FindString


VOID
MULTISZ::AuxInit( const BYTE * pInit )
{
    BOOL fRet;

    if ( pInit )
    {
        DWORD cStrings;
        int cbCopy = CalcLength( (const CHAR *)pInit, &cStrings ) * sizeof(CHAR);
        fRet = Resize( cbCopy );

        if ( fRet ) {
            CopyMemory( QueryPtr(), pInit, cbCopy );
            m_cchLen = (cbCopy)/sizeof(CHAR);
            m_cStrings = cStrings;
        } else {
            BUFFER::SetValid( FALSE);
        }

    } else {

        Reset();

    }

} // MULTISZ::AuxInit()


/*******************************************************************

    NAME:       MULTISZ::AuxAppend

    SYNOPSIS:   Appends the string onto the multisz.

    ENTRY:      Object to append
********************************************************************/

BOOL MULTISZ::AuxAppend( const BYTE * pStr, UINT cbStr, BOOL fAddSlop )
{
    DBG_ASSERT( pStr != NULL );

    UINT cbThis = QueryCB();

    DBG_ASSERT( cbThis >= 2 );

    if( cbThis == 2 ) {

        //
        // It's empty, so start at the beginning.
        //

        cbThis = 0;

    } else {

        //
        // It's not empty, so back up over the final terminating NULL.
        //

        cbThis--;

    }

    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //

    AcIncrement( CacMultiszAppend);
    if ( QuerySize() < cbThis + cbStr + 1)
    {
        if ( !Resize( cbThis + cbStr + 1 + (fAddSlop ? STR_SLOP : 0 )) )
            return FALSE;
    }

    // copy the exact string and tack on the double terminator
    memcpy( (BYTE *) QueryPtr() + cbThis,
            pStr,
            cbStr);

    *((BYTE *)QueryPtr() + cbThis + cbStr) = '\0';

    m_cchLen = CalcLength( (const CHAR *)QueryPtr(), &m_cStrings );
    return TRUE;

} // MULTISZ::AuxAppend()


#if 0

BOOL
MULTISZ::CopyToBuffer( WCHAR * lpszBuffer, LPDWORD lpcch) const
/*++
    Description:
        Copies the string into the WCHAR buffer passed in if the buffer
        is sufficient to hold the translated string.
        If the buffer is small, the function returns small and sets *lpcch
        to contain the required number of characters.

    Arguments:
        lpszBuffer      pointer to WCHAR buffer which on return contains
                        the UNICODE version of string on success.
        lpcch           pointer to DWORD containing the length of the buffer.
                        If *lpcch == 0 then the function returns TRUE with
                        the count of characters required stored in *lpcch.
                        Also in this case lpszBuffer is not affected.
    Returns:
        TRUE on success.
        FALSE on failure.  Use GetLastError() for further details.

    History:
        MuraliK         11-30-94
--*/
{
   BOOL fReturn = TRUE;

    if ( lpcch == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    if ( *lpcch == 0) {

      //
      //  Inquiring the size of buffer alone
      //
      *lpcch = QueryCCH() + 1;    // add one character for terminating null
    } else {

        //
        // Copy after conversion from ANSI to Unicode
        //
        int  iRet;
        iRet = MultiByteToWideChar( CP_ACP,   MB_PRECOMPOSED,
                                    QueryStrA(),  QueryCCH() + 1,
                                    lpszBuffer, (int )*lpcch);

        if ( iRet == 0 || iRet != (int ) *lpcch) {

            //
            // Error in conversion.
            //
            fReturn = FALSE;
        }
    }

    return ( fReturn);
} // MULTISZ::CopyToBuffer()
#endif

BOOL
MULTISZ::CopyToBuffer( CHAR * lpszBuffer, LPDWORD lpcch) const
/*++
    Description:
        Copies the string into the CHAR buffer passed in if the buffer
          is sufficient to hold the translated string.
        If the buffer is small, the function returns small and sets *lpcch
          to contain the required number of characters.

    Arguments:
        lpszBuffer      pointer to CHAR buffer which on return contains
                        the string on success.
        lpcch           pointer to DWORD containing the length of the buffer.
                        If *lpcch == 0 then the function returns TRUE with
                        the count of characters required stored in *lpcch.
                        Also in this case lpszBuffer is not affected.
    Returns:
        TRUE on success.
        FALSE on failure.  Use GetLastError() for further details.

    History:
        MuraliK         20-Nov-1996
--*/
{
   BOOL fReturn = TRUE;

    if ( lpcch == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    register DWORD cch = QueryCCH() + 1;

    if ( *lpcch >= cch) {

        DBG_ASSERT( lpszBuffer);
        CopyMemory( lpszBuffer, QueryStrA(), cch);
    } else {
        DBG_ASSERT( *lpcch < cch);
        SetLastError( ERROR_INSUFFICIENT_BUFFER);
        fReturn = FALSE;
    }

    *lpcch = cch;

    return ( fReturn);
} // MULTISZ::CopyToBuffer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\perfutil.c ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      perfutil.c

   Abstract:

      This file implements the utility routines used for all perfmon 
       interface dlls in the internet services group.

   Author:

       Murali R. Krishnan    ( MuraliK )     16-Nov-1995  
          Pulled from  perfmon interface common code.

   Environment:
       User Mode
       
   Project:

       Internet Servies Common Runtime functions

   Functions Exported:

        DWORD GetQueryType();
        BOOL  IsNumberInUnicodeList();
        VOID  MonBuildInstanceDefinition();

   Revision History:

       Sophia Chung (sophiac)  05-Nov-1996
          Added routine to support multiple instances

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include <windows.h>
#include <string.h>

#include <winperf.h>
#include <perfutil.h>


/************************************************************
 *     Global Data Definitions
 ************************************************************/

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

#define ALIGN_ON_QWORD(x) \
     ((VOID *)(((ULONG_PTR)(x) + ((8)-1)) & ~((ULONG_PTR)(8)-1)))


/************************************************************
 *    Functions 
 ************************************************************/



DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}



BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList



VOID
MonBuildInstanceDefinition(
    OUT PERF_INSTANCE_DEFINITION *pBuffer,
    OUT PVOID *pBufferNext,
    IN DWORD ParentObjectTitleIndex,
    IN DWORD ParentObjectInstance,
    IN DWORD UniqueID,
    IN LPWSTR Name
    )
/*++

MonBuildInstanceDefinition  

    Build an instance of an object

Arguments:

    OUT pBuffer         -   pointer to buffer where instance is to
                            be constructed

    OUT pBufferNext     -   pointer to a pointer which will contain
                                next available location, DWORD aligned

    IN  ParentObjectTitleIndex
                        -   Title Index of parent object type; 0 if
                            no parent object

    IN  ParentObjectInstance
                        -   Index into instances of parent object
                            type, starting at 0, for this instances
                            parent object instance

    IN  UniqueID        -   a unique identifier which should be used
                            instead of the Name for identifying
                            this instance

    IN  Name            -   Name of this instance

Return Value:

    None.

--*/
{
    DWORD NameLength;
    LPWSTR pName;
    //
    //  Include trailing null in name size
    //

    NameLength = (lstrlenW(Name) + 1) * sizeof(WCHAR);

    pBuffer->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) +
                          DWORD_MULTIPLE(NameLength);

    pBuffer->ParentObjectTitleIndex = ParentObjectTitleIndex;
    pBuffer->ParentObjectInstance = ParentObjectInstance;
    pBuffer->UniqueID = UniqueID;
    pBuffer->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    pBuffer->NameLength = NameLength;

    // copy name to name buffer
    pName = (LPWSTR)&pBuffer[1];
    RtlMoveMemory(pName,Name,NameLength);

#if 0
    // allign on 8 byte boundary for new NT5 requirement
    pBuffer->ByteLength = QWORD_MULTIPLE(pBuffer->ByteLength);
    // update "next byte" pointer
    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);
#endif

    // update "next byte" pointer
    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);

    // round up to put next buffer on a QUADWORD boundry
    *pBufferNext = ALIGN_ON_QWORD (*pBufferNext);
    // adjust length value to match new length
    pBuffer->ByteLength = (ULONG)((ULONG_PTR)*pBufferNext - (ULONG_PTR)pBuffer);

    return;
}



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\pudebug.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

    Module  Name :
        pudebug.c

    Abstract:

        This module defines functions required for
         Debugging and logging messages for a dynamic program.

    Author:
         Murali R. Krishnan ( MuraliK )    10-Sept-1994
         Modified to be moved to common dll in 22-Dec-1994.

    Revisions:
         MuraliK  16-May-1995  Code to load and save debug flags from registry
         MuraliK  16-Nov-1995  Remove DbgPrint (undoc api)
         JasAndre Jan-1998     Replaced tracing mechanism with WMI Tracing
--*/


/************************************************************
 * Include Headers
 ************************************************************/

# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windows.h>
# include <stdio.h>
# include <stdlib.h>
# include <stdarg.h>
# include <string.h>

# include "pudebug.h"
# include <winbase.h>
# include <coguid.h>
# include <objbase.h>

#ifndef _NO_TRACING_
DEFINE_GUID(IisRtlGuid,
0x784d8900, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#endif

/*************************************************************
 * Global Variables and Default Values
 *************************************************************/

# define MAX_PRINTF_OUTPUT  ( 10240)

# define DEFAULT_DEBUG_FLAGS_VALUE  ( 0)
# define DEBUG_FLAGS_REGISTRY_LOCATION_A   "DebugFlags"
# define DEBUG_BREAK_ENABLED_REGKEYNAME_A  "BreakOnAssert"


/*************************************************************
 *   Functions
 *************************************************************/

# ifndef _NO_TRACING_

// Critical section used to control access to the list of known guids used for
// WMI tracing
CRITICAL_SECTION g_csGuidList;
// The list of known guids which are used with WMI Tracing
LIST_ENTRY  g_pGuidList;
// The sequence number of the trace message we are about to log
LONG        g_dwSequenceNumber = 0;
// This flag tells us whether or not to do any WMI handling
BOOL        g_bTracingEnabled = FALSE;
// This flag tells us if we had to start WMI tracing
BOOL        g_bStartedTracing = FALSE;
TRACEHANDLE g_hLoggerHandle = 0;
// This flag tells us whether to enable the guids as they are defined or to
// wait for an enable command from WMI
BOOL        g_bTracingActive = FALSE;
// This flag tells us whether or not to log info to OutputDebugString, this is
// SLOW. It is on by default for CHK builds and off by default for FRE builds
//#ifdef DBG
//BOOL        g_ODSEnabled = TRUE;
//#else
BOOL        g_ODSEnabled = FALSE;
//#endif
// The filename and session name to use for the WMI Tracing file
char        g_szLogFileName[MAX_PATH] = "";
char        g_szLogSessionName[MAX_PATH] = "";
// The WMI Tracing buffer size, in KB, and the min and max number of buffers
// that are permitted, and max file size, 0 means use default
// If max file size is set then circular buffers are used
ULONG       g_ulBufferSize = 0;
ULONG       g_ulMinBuffers = 0;
ULONG       g_ulMaxBuffers = 0;
ULONG       g_ulMaxFileSize = 0;
// Three special modes that it is possible to start the logger in
BOOL        g_bRealTimeMode = FALSE;
BOOL        g_bInMemoryMode = FALSE;
BOOL        g_bUserMode = FALSE;
// The default values used for control flags and the error level. These
// settings are only used for modules that have their active flags set
DWORD       g_dwDefaultControlFlag = 0;
DWORD       g_dwDefaultErrorLevel = 0;
// This flag tells us if we have done the registry initialization, we can't
// register with WMI until this has been done
BOOL        g_bHaveDoneInit = FALSE;
// This flag tells us whether we have registered with WMI or not
BOOL        g_bHadARegister = FALSE;

void SetLevel(int iDefaultErrorLevel, int *piErrorFlags)
/*++
   Support function used by all and sundry to convert the level, ie. 1, 2 or 3
   into the bitmapped format used in the error flags variable

   Arguments:
      iDefaultErrorLevel    new value to decode for the error level
      *piErrorFlags         pointer to the variable to set the error level in

   Returns:

--*/
{
    if (piErrorFlags) {

        // Mask out all but the ODS flag
        // Note: Why do we do this? There is a problem that if this module is
        // compiled as FRE but the caller is CHK then this function would
        // erase the callers ODS setting, so by masking out all but the ODS
        // flag here we can maintain the callers ODS setting
        *piErrorFlags &= DEBUG_FLAG_ODS;

        // Then or in the appropriate bit
        switch (iDefaultErrorLevel) {
            case DEBUG_LEVEL_ERROR:
                *piErrorFlags |= DEBUG_FLAG_ERROR;
                break;

            case DEBUG_LEVEL_WARN:
                *piErrorFlags |= DEBUG_FLAG_WARN;
                break;

            case DEBUG_LEVEL_INFO:
                *piErrorFlags |= DEBUG_FLAG_INFO;
                break;

            default:
                break;
        };

        if (g_ODSEnabled)
            *piErrorFlags |= DEBUG_FLAG_ODS;
    }
}


SGuidList *FindGuid(
    IN GUID *ControlGuid
    )
/*++
   Support function used by all and sundry to find a guid in the guid list.
   NOTE: It is the responsibility of the caller to enter the guid list
         critical section before calling this function

   Arguments:
      *ControlGuid   pointer to the guid that we are looking for

   Returns:
      NULL           if the guid is not in the list
      *DEBUG_PRINTS  the data relating to the guid if it is in the list

--*/
{
    LIST_ENTRY *pEntry;
    SGuidList *pGE = NULL;
    BOOL bFound = FALSE;

    for (pEntry = g_pGuidList.Flink;
         pEntry != &g_pGuidList;
         pEntry = pEntry->Flink)
    {
        pGE = CONTAINING_RECORD(pEntry,
                                SGuidList,
                                m_leEntry);

        DBG_ASSERT(TRACESIG == pGE->dwSig);

        if (IsEqualGUID(ControlGuid, &pGE->m_dpData.m_guidControl)) {

            bFound = TRUE;
            break;
        }
    }

    return bFound ? pGE : NULL;
}

dllexp ULONG IISTraceControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
/*++
   Callback function supplied to WMI so that it can notify me when the user
   requests a change to the level or control flags for logging

   Arguments:
      RequestCode       control code used to determine what function to perform
      RequestContext    not used
      InOutBufferSize   size of the buffer supplied by WMI, set to 0 as we don't
                        send any data back to WMI through this mechanism
      Buffer            contains EVENT_TRACE_HEADER needed to identify whom a
                        request is for

   Returns:

--*/
{
    PEVENT_TRACE_HEADER pHeader = (PEVENT_TRACE_HEADER) Buffer;
    TRACEHANDLE hTrace = GetTraceLoggerHandle(Buffer);
    LPGUID pGuid = &pHeader->Guid;
    ULONG Status = ERROR_SUCCESS;
    SGuidList *pGE = NULL;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
            EnterCriticalSection(&g_csGuidList);

            DBG_ASSERT(pGuid);
            DBG_REQUIRE(pGE = FindGuid(pGuid));

            if (pGuid && pGE) {

                DEBUG_PRINTS *pGEData = &pGE->m_dpData;

                pGEData->m_iControlFlag = GetTraceEnableFlags(hTrace);
                pGEData->m_hLogger = hTrace;

                if (pGEData->m_piErrorFlags) {

                    SetLevel(GetTraceEnableLevel(hTrace), pGEData->m_piErrorFlags);

                    // Flag us as no longer needing an initialize, important step
                    // to prevent re-initialization attempts in PuInitiateDebug
                    pGE->m_iInitializeFlags &= ~DEBUG_FLAG_INITIALIZE;
                    pGE->m_iDefaultErrorLevel = GetTraceEnableLevel(hTrace);
                }
                else {
                    pGE->m_iInitializeFlags = DEBUG_FLAG_DEFERRED_START;
                    pGE->m_iDefaultErrorLevel = GetTraceEnableLevel(hTrace);
                }
            }
            LeaveCriticalSection(&g_csGuidList);
            break;
        }

        case WMI_DISABLE_EVENTS:
        {
            EnterCriticalSection(&g_csGuidList);

            if (pGuid && (NULL != (pGE = FindGuid(pGuid)))) {

                DEBUG_PRINTS *pGEData = &pGE->m_dpData;

                pGEData->m_iControlFlag = 0;
                pGEData->m_hLogger = hTrace;

                if (pGEData->m_piErrorFlags) {
                    SetLevel(0, pGEData->m_piErrorFlags);
                    pGE->m_iDefaultErrorLevel = 0;
                }
            }
            LeaveCriticalSection(&g_csGuidList);
            break;
        }

        default:
        {
            char szTemp[MAX_PATH];

            _snprintf(szTemp, sizeof(szTemp),
                      "IISTRACE:\t%s(%d), IISTraceControlCallback: Invalid parameter\n",
                      __FILE__, __LINE__);
            OutputDebugString(szTemp);
            Status = ERROR_INVALID_PARAMETER;
            break;
        }
    }
    *InOutBufferSize = 0;
    return Status;
}


void LoadGuidFromRegistry(char *pszModuleName)
/*++
   This function is used to load all the information stored in the registry
   about a module and to allocate an entry in the guid list for it
   NOTE: It is the responsibility of the caller to enter the guid list
         critical section before calling this function

   Arguments:
      pszModuleName  pointer to the name of the module we are about to process

   Returns:

--*/
{
    char KeyName[MAX_PATH * 2] = REG_TRACE_IIS "\\";
    HKEY hk = 0;

    // Create the name of the key for this GUID using the english name
    strcat(KeyName, pszModuleName);
    // Open the GUIDs key
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, KeyName, &hk)) {
        WCHAR szwTemp[MAX_PATH];
        DWORD dwReadSize;

        // 1. Load the guid number from the registry, we can only continue
        // processing this module if we find a guid for it
        dwReadSize = sizeof(szwTemp);
        if (ERROR_SUCCESS == RegQueryValueExW(hk, REG_TRACE_IIS_GUID,
                                             NULL, NULL,
                                             (BYTE *) szwTemp,
                                             &dwReadSize)) {
            CLSID ControlGuid;

            // 2. Convert the guid string into a guid
            if (SUCCEEDED(CLSIDFromString(szwTemp, &ControlGuid))) {

                // 3. Ensure it is not already in the guid list
                if (!FindGuid(&ControlGuid)) {
                    DEBUG_PRINTS *pGEData = NULL;
                    BOOL bGuidEnabled;
                    int iTemp;

                    // 4. Try and insert it into the guid list
                    SGuidList *pGE = (SGuidList *) LocalAlloc(LPTR, sizeof(SGuidList));

                    if (pGE) {

                        pGEData = &pGE->m_dpData;

                        // Set the GuidList signature
                        pGE->dwSig = TRACESIG;

                        // Set the SGuidList.m_dpData member variables
                        strncpy(pGEData->m_rgchLabel,
                                pszModuleName, MAX_LABEL_LENGTH - 1);
                        pGEData->m_guidControl = ControlGuid;
                        pGEData->m_bBreakOnAssert = TRUE;   // Default - Break if Assert Fails

                        // Add it to the head of the list. Put it at the head in case this
                        // is an object which is being loaded and unloaded continuosly.
                        InsertHeadList(&g_pGuidList, &pGE->m_leEntry);

                        // 5. Try to load any previous control settings from the registry
                        // 5.1 See if the guid is enabled, if so flag us as needing
                        // to start this guid when we initialize with WMI
                        dwReadSize = sizeof(bGuidEnabled);
                        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_ACTIVE,
                                                             NULL, NULL,
                                                             (BYTE *) &bGuidEnabled,
                                                             &dwReadSize)) {
                            if (bGuidEnabled)
                                pGE->m_iInitializeFlags = DEBUG_FLAG_INITIALIZE;
                        }
                        // Otherwise use the global setting to determine this
                        else if (g_bTracingActive)
                            pGE->m_iInitializeFlags = DEBUG_FLAG_INITIALIZE;

                        // If it is enabled then load the remaining flags
                        if (pGE->m_iInitializeFlags & DEBUG_FLAG_INITIALIZE) {

                            // 5.2 So next load the ControlFlags, the flags default
                            // to the global setting
                            dwReadSize = sizeof(&iTemp);
                            if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_CONTROL,
                                                                 NULL, NULL,
                                                                 (BYTE *) &iTemp,
                                                                 &dwReadSize))
                                pGEData->m_iControlFlag = iTemp;
                            else
                                pGEData->m_iControlFlag = g_dwDefaultControlFlag;

                            // 5.3 Then load the Level, it also defaults to the global
                            // setting
                            if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_LEVEL,
                                                                 NULL, NULL,
                                                                 (BYTE *) &iTemp,
                                                                 &dwReadSize)) {
                                pGE->m_iDefaultErrorLevel = iTemp;
                            }
                            else
                                pGE->m_iDefaultErrorLevel = g_dwDefaultErrorLevel;
                        }
                    }
                }

            }

        }

        RegCloseKey(hk);
    }
}


dllexp void
AddToRegistry(
    IN SGuidList *pGE
    )
/*++
   This function creates new registry entries for this module so that it will
   be correctly loaded next time IIS is started
   NOTE: It is the responsibility of the caller to enter the guid list
         critical section before calling this function

   Arguments:
      *pGE                  pointer to the SGuidList entry which has all the
                            information about the guid to add

   Returns:
      This returns void as it does not matter to the running program whether
      this works or not, it just improves restart performance if it does.

--*/
{
    HKEY hk = 0;
    HKEY hkNew = 0;

    // Open the IIS Trace registry key
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REG_TRACE_IIS, &hk)) {

        DEBUG_PRINTS *pGEData = &pGE->m_dpData;
        BOOL bCreatedGuid = FALSE;
        DWORD dwDisposition;

        // 1. Create a new key for the module
        if (ERROR_SUCCESS == RegCreateKeyEx(hk, pGEData->m_rgchLabel,
                                            0, NULL,
                                            REG_OPTION_NON_VOLATILE,
                                            KEY_ALL_ACCESS,
                                            NULL, &hkNew, &dwDisposition))
        {
            WCHAR szwTemp[MAX_PATH];

            // 2. Convert the guid to a string so that we can add it to the
            // registry, the format is E.g.
            // {37EABAF0-7FB6-11D0-8817-00A0C903B83C}
            if (StringFromGUID2(&pGEData->m_guidControl,
                                (WCHAR *) szwTemp,
                                MAX_PATH)) {

                // 3. Add the guid string to the module information
                if (ERROR_SUCCESS == RegSetValueExW(hkNew,
                                                    REG_TRACE_IIS_GUID,
                                                    0,
                                                    REG_SZ,
                                                    (BYTE *) szwTemp,
                                                    wcslen(szwTemp) * sizeof(WCHAR))) {
                    bCreatedGuid = TRUE;
                }
            }

            RegCloseKey(hkNew);

            if (!bCreatedGuid && (REG_CREATED_NEW_KEY == dwDisposition)) {

                RegDeleteKey(hk, pGEData->m_rgchLabel);
            }
        }

        RegCloseKey(hk);
    }
}

TRACEHANDLE
GetTraceFileHandle(
    VOID)
/*++
   This function create the tracing file for the current log file. It only does
   this if a module that has the DEBUG_FLAG_INITIALIZE bit is successfully
   registered with WMI.

   Arguments:

   Returns:
--*/
{
    TRACEHANDLE hLogger = 0;

    // There must be a valid log file name and session name in order to create
    // the trace file
    if (g_szLogFileName[0] && g_szLogSessionName[0]) {

        struct {
            EVENT_TRACE_PROPERTIES Header;
            char LoggerName[MAX_PATH];
            char LogFileName[MAX_PATH];
        } Properties;

        PEVENT_TRACE_PROPERTIES LoggerInfo;
        PCHAR Offset;

        ULONG Status = ERROR_SUCCESS;

        LoggerInfo = (PEVENT_TRACE_PROPERTIES)&Properties.Header;

        // Set up the request structure
        RtlZeroMemory(&Properties, sizeof(Properties));
        LoggerInfo->Wnode.BufferSize = sizeof(Properties);
        LoggerInfo->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
        if (0 == g_ulMaxFileSize)
            LoggerInfo->LogFileMode = EVENT_TRACE_FILE_MODE_SEQUENTIAL;
        else {
            LoggerInfo->LogFileMode = EVENT_TRACE_FILE_MODE_CIRCULAR;
            LoggerInfo->MaximumFileSize = g_ulMaxFileSize;
        }
        if (g_bRealTimeMode)
            LoggerInfo->LogFileMode |= EVENT_TRACE_REAL_TIME_MODE;
        else if (g_bInMemoryMode)
            LoggerInfo->LogFileMode |= EVENT_TRACE_BUFFERING_MODE;
        else if (g_bUserMode)
            LoggerInfo->LogFileMode |= EVENT_TRACE_PRIVATE_LOGGER_MODE;

        strcpy(&Properties.LoggerName[0], g_szLogSessionName);
        strcpy(&Properties.LogFileName[0], g_szLogFileName);
        LoggerInfo->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
        LoggerInfo->LogFileNameOffset = LoggerInfo->LoggerNameOffset +
                                        MAX_PATH;

        LoggerInfo->BufferSize = g_ulBufferSize;

        LoggerInfo->MinimumBuffers = g_ulMinBuffers;
        LoggerInfo->MaximumBuffers = g_ulMaxBuffers;

        Status = QueryTrace(0,
                            g_szLogSessionName,
                            (PEVENT_TRACE_PROPERTIES) LoggerInfo);
        if (ERROR_SUCCESS == Status)
            hLogger = LoggerInfo->Wnode.HistoricalContext;
        else if (ERROR_WMI_INSTANCE_NOT_FOUND == Status) {
            // The logger is not already started so try to start it now
            Status = StartTrace(&hLogger,
                                g_szLogSessionName,
                                LoggerInfo);
        }
        if (ERROR_SUCCESS == Status) {
            g_bStartedTracing = TRUE;
            strcpy(g_szLogSessionName, &Properties.LoggerName[0]);
            strcpy(g_szLogFileName, &Properties.LogFileName[0]);
        }
        else {
            char szTemp[MAX_PATH];

            _snprintf(szTemp, sizeof(szTemp),
                      "IISRTL:\t%s(%d), Unable to get the Logger Handle, return code = %d\n",
                      __FILE__, __LINE__,
                      Status);
            OutputDebugString(szTemp);
        }
    }

    return hLogger;
}

dllexp VOID
PuUninitiateDebug(
    VOID)
/*++
   This function stops tracing for the current log file but only if we started
   the tracing in the initiate debug

   Arguments:

   Returns:
--*/
{
    BOOL bStartedTracing = FALSE;
    DWORD dwError;

    EnterCriticalSection(&g_csGuidList);

    bStartedTracing = g_bStartedTracing;
    g_bStartedTracing = FALSE;

    LeaveCriticalSection(&g_csGuidList);

    if (bStartedTracing) {

        struct {
            EVENT_TRACE_PROPERTIES Header;
            char LoggerName[MAX_PATH];
            char LogFileName[MAX_PATH];
        } Properties;
        PEVENT_TRACE_PROPERTIES LoggerInfo;

        LoggerInfo = (PEVENT_TRACE_PROPERTIES) &Properties.Header;
        RtlZeroMemory(&Properties, sizeof(Properties));
        LoggerInfo->Wnode.BufferSize = sizeof(Properties);
        LoggerInfo->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
        LoggerInfo->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
        LoggerInfo->LogFileNameOffset = LoggerInfo->LoggerNameOffset + MAX_PATH;

        // Stop tracing to the log file
        dwError = StopTrace(g_hLoggerHandle, g_szLogSessionName, LoggerInfo);
        if (dwError == ERROR_SUCCESS) {
            strcpy(g_szLogFileName, &Properties.LogFileName[0]);
            strcpy(g_szLogSessionName, &Properties.LoggerName[0]);
        }
    }
}


dllexp VOID
PuInitiateDebug(
    VOID
    )
/*++
   This function iterates through the list of modules in the guid list
   registering all of them and starting up logging if that is the state that
   was stored in the registry

   Arguments:

   Returns:
--*/
{
    BOOL bStartedLogger = FALSE;

    EnterCriticalSection(&g_csGuidList);

    if (!g_bHadARegister) {

        LIST_ENTRY pRegList;
        SGuidList *pGEReg = NULL;
        LIST_ENTRY *pEntry;
        SGuidList *pGE = NULL;
        char szTemp[MAX_PATH];

        // Flag us as having done this so that we can later leave this
        // critical section
        g_bHadARegister = TRUE;

        // Only do the WMI registration if tracing is enabled
        if (g_bTracingEnabled) {

            // Initialize the list of guids which need to be registered with WMI
            InitializeListHead(&pRegList);

            // Iterate through the guid list
            for (pEntry = g_pGuidList.Flink;
                 pEntry != &g_pGuidList;
                 pEntry = pEntry->Flink)
            {

                pGE = CONTAINING_RECORD(pEntry,
                                        SGuidList,
                                        m_leEntry);

                DBG_ASSERT(TRACESIG == pGE->dwSig);

                // Allocate memory for a local copy of the entry so that we can
                // add it to our local list
                pGEReg = (SGuidList *) _alloca(sizeof(SGuidList));

                if (NULL != pGEReg) {

                    // Copy the entry and add it to the local list
                    memcpy(pGEReg, pGE, sizeof(SGuidList));
                    InsertHeadList(&pRegList, &pGEReg->m_leEntry);
                }
            }

            LeaveCriticalSection(&g_csGuidList);

            // Now iterate through our local copy of the list and register all the
            // guids with WMI
            for (pEntry = pRegList.Flink;
                 pEntry != &pRegList;
                 pEntry = pEntry->Flink)
            {
                TRACE_GUID_REGISTRATION RegGuids;
                ULONG Status = ERROR_SUCCESS;

                pGEReg = CONTAINING_RECORD(pEntry,
                                           SGuidList,
                                           m_leEntry);

                DBG_ASSERT(TRACESIG == pGEReg->dwSig);

                // Initialise the GUID registration structure
                memset(&RegGuids, 0x00, sizeof(RegGuids));
                RegGuids.Guid = (LPGUID) &pGEReg->m_dpData.m_guidControl;

                // And then register the guid
                Status = RegisterTraceGuidsW(IISTraceControlCallback,
                                             NULL,
                                             (LPGUID) &pGEReg->m_dpData.m_guidControl,
                                             1,
                                             &RegGuids,
                                             NULL,
                                             NULL,
                                             &pGEReg->m_dpData.m_hRegistration);

                if (ERROR_SUCCESS != Status)
                {
                    _snprintf(szTemp, sizeof(szTemp),
                              "%16s:\t%s(%d), RegisterTraceGuids returned %d, main ID = %08X\n",
                              pGEReg->m_dpData.m_rgchLabel,
                              __FILE__, __LINE__,
                              Status,
                              pGEReg->m_dpData.m_guidControl.Data1);
                    OutputDebugString(szTemp);
                }
                else if (pGEReg->m_iInitializeFlags & DEBUG_FLAG_INITIALIZE) {

                    // Turn off the initialize flag
                    pGEReg->m_iInitializeFlags &= ~DEBUG_FLAG_INITIALIZE;

                    // Get the trace file handle if necessary
                    if (!bStartedLogger) {

                        bStartedLogger = TRUE;
                        g_hLoggerHandle = GetTraceFileHandle();
                    }

                    // And enable tracing for the module. If this is successful
                    // then WMI will call the IISTraceControlCallback
                    Status = EnableTrace(TRUE,
                                         pGEReg->m_dpData.m_iControlFlag,
                                         pGEReg->m_iDefaultErrorLevel,
                                         (LPGUID) &pGEReg->m_dpData.m_guidControl,
                                         g_hLoggerHandle);
                    if ((ERROR_SUCCESS != Status) && (ERROR_WMI_ALREADY_ENABLED != Status)) {
                        _snprintf(szTemp, sizeof(szTemp),
                                  "%16s:\t%s(%d), Unable to EnableTrace, return code = %d\n",
                                  pGEReg->m_dpData.m_rgchLabel,
                                  __FILE__, __LINE__,
                                  Status);
                        OutputDebugString(szTemp);
                    }
                }
            }

            // Now re-enter the critical section so that we can save the results
            // back to our global data structure
            EnterCriticalSection(&g_csGuidList);

            for (pEntry = pRegList.Flink;
                 pEntry != &pRegList;
                 pEntry = pEntry->Flink)
            {
                pGEReg = CONTAINING_RECORD(pEntry,
                                           SGuidList,
                                           m_leEntry);

                DBG_ASSERT(TRACESIG == pGEReg->dwSig);

                // Find the guid in our original guid list
                pGE = FindGuid(&pGEReg->m_dpData.m_guidControl);

                if (pGE) {

                    // Save the only two things that could have changed
                    pGE->m_iInitializeFlags = pGEReg->m_iInitializeFlags;
                    pGE->m_dpData.m_hRegistration = pGEReg->m_dpData.m_hRegistration;
                }
            }
        }
    }

    LeaveCriticalSection(&g_csGuidList);

} // PuInitiateDebug()


VOID
PuLoadRegistryInfo(
    VOID
    )
/*++
   This function loads all the registry settings for the project and adds all
   the known modules to the Guid list
   NOTE: It is the responsibility of the caller to enter the guid list
         critical section before calling this function

   Arguments:

   Returns:

--*/
{
    HKEY hk = 0;

    // Get the global settings which need only be read once, and only for
    // the master
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REG_TRACE_IIS, &hk)) {

        DWORD dwIndex = 0;
        ULONG ulTemp = 0;
        LONG iRegRes = 0;
        char szTemp[MAX_PATH];
        char szModuleName[MAX_PATH];
        DWORD dwReadSize = sizeof(ulTemp);
        DWORD dwSizeOfModuleName = sizeof(szModuleName);

        // 1. Get the enabled flag, if this is false we do not do any WMI
        // processing, by default this is FALSE
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_ENABLED,
                                             NULL, NULL,
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_bTracingEnabled = ulTemp;

        // 2. Get the AlwaysODS flag, if this is true we will always write
        // trace out with OutputDebugString, effectively CHK build
        // compatability mode
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_ODS,
                                             NULL, NULL,
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_ODSEnabled = ulTemp;

        // 3. Determine if the active flag is set, if it was then it means
        // that something was active at shut down, so for each module load
        // read the appropriate registry entries at start up
        dwReadSize = sizeof(ulTemp);
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_ACTIVE,
                                             NULL, NULL,
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_bTracingActive = ulTemp;

        // 4. Get the trace configuration information, log file name,
        // logging session name, min/max number of buffers, buffer size & mode
        dwReadSize = sizeof(szTemp);
        if (ERROR_SUCCESS == (iRegRes = RegQueryValueEx(hk,
                                                        REG_TRACE_IIS_LOG_FILE_NAME,
                                                        NULL,
                                                        NULL,
                                                       (BYTE *) &szTemp,
                                                       &dwReadSize)))
            strcpy(g_szLogFileName, szTemp);
        else if (ERROR_MORE_DATA == iRegRes) {
            DBGERROR((DBG_CONTEXT,
                     "Unable to load tracing logfile name, name too long.\n"));
        }
        else
            DBGWARN((DBG_CONTEXT,
                    "Unable to load tracing logfile name, Windows error %d\n",
                    iRegRes));
        dwReadSize = sizeof(szTemp);
        if (ERROR_SUCCESS == (iRegRes = RegQueryValueEx(hk,
                                                       REG_TRACE_IIS_LOG_SESSION_NAME,
                                                       NULL,
                                                       NULL,
                                                       (BYTE *) &szTemp,
                                                       &dwReadSize)))
            strcpy(g_szLogSessionName, szTemp);
        else if (ERROR_MORE_DATA == iRegRes) {
            DBGERROR((DBG_CONTEXT,
                     "Unable to load tracing log session name, name too long.\n"));
        }
        else
            DBGWARN((DBG_CONTEXT,
                    "Unable to load tracing log session name, Windows error %d\n",
                    iRegRes));
        dwReadSize = sizeof(ulTemp);
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_LOG_BUFFER_SIZE,
                                             NULL, NULL,
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_ulBufferSize = ulTemp;
        dwReadSize = sizeof(ulTemp);
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_LOG_MIN_BUFFERS,
                                             NULL, NULL,
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_ulMinBuffers = ulTemp;
        dwReadSize = sizeof(ulTemp);
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_LOG_MAX_BUFFERS,
                                             NULL, NULL,
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_ulMaxBuffers = ulTemp;
        dwReadSize = sizeof(ulTemp);
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_LOG_MAX_FILESIZE,
                                             NULL, NULL,
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_ulMaxFileSize = ulTemp;
        dwReadSize = sizeof(ulTemp);
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_LOG_MAX_FILESIZE,
                                             NULL, NULL,
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_bRealTimeMode = ulTemp;
        dwReadSize = sizeof(ulTemp);
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_LOG_MAX_FILESIZE,
                                             NULL, NULL,
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_bInMemoryMode = ulTemp;
        dwReadSize = sizeof(ulTemp);
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_LOG_MAX_FILESIZE,
                                             NULL, NULL,
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_bUserMode = ulTemp;

        // 5. Load the ControlFlags and Level. Both default to 0, off
        dwReadSize = sizeof(ulTemp);
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_CONTROL,
                                             NULL, NULL,
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_dwDefaultControlFlag = ulTemp;
        dwReadSize = sizeof(ulTemp);
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_LEVEL,
                                             NULL, NULL,
                                             (BYTE *) &ulTemp,
                                             &dwReadSize)) {
            g_dwDefaultErrorLevel = ulTemp;
        }

        DBGPRINTF((DBG_CONTEXT, "Enumerating module for : %s\n", REG_TRACE_IIS));
        // Enumerate all the modules listed in the registry for IIS
        while (ERROR_NO_MORE_ITEMS != RegEnumKeyEx(hk, dwIndex,
                                             szModuleName,
                                             &dwSizeOfModuleName,
                                             NULL, NULL, NULL, NULL))
        {
            // Then load the setting for this guid from the registry and
            // set up any defaults that are needed
            LoadGuidFromRegistry(szModuleName);

            dwSizeOfModuleName = sizeof(szModuleName);
            ++dwIndex;
        }
        RegCloseKey(hk);
    }
#ifdef DBG
    else
        if (g_ODSEnabled)
            OutputDebugString("IISTRACE: Warning, could not find IIS trace entry in "
                              "the registry.\n\t  Unable to initialize WMI tracing.\n");

#endif

} // PuLoadRegistryInfo()


LPDEBUG_PRINTS
PuCreateDebugPrintsObject(
    IN const char * pszPrintLabel,
    IN GUID *       ControlGuid,
    IN int *        ErrorFlags,
    IN int          DefaultControlFlags
    )
/*++
   This function looks for and if necessary creates a new DEBUG_PRINTS object
   for the required module

   Arguments:
      *pszPrintLabel        pointer to null-terminated string containing the
                            label for program's debugging output
      *ControlGuid          the unique GUID used to identify this module
      *ErrorFlags           pointer to the error flags variable used by the
                            module to determine whether or not to log something
      DefaultControlFlags   default flags used by IF_DEBUG

   Returns:
       pointer to a new DEBUG_PRINTS object on success.
       Returns NULL on failure.
--*/
{
    DEBUG_PRINTS *pGEData = NULL;
    LIST_ENTRY *pEntry;
    SGuidList *pGE = NULL;

    DBG_ASSERT(NULL != ErrorFlags);
    DBG_ASSERT(0 != pszPrintLabel[0]);

    // Look through the guid list for this module
    EnterCriticalSection(&g_csGuidList);

    // See if we have done the registry initialization stuff, if we have then
    // we should have the guid list. The initialization need only be done once
    if (!g_bHaveDoneInit) {
        g_bHaveDoneInit = TRUE;
        PuLoadRegistryInfo();
    }

    pGE = FindGuid(ControlGuid);

    // If we don't have a pointer to the data member it means we could not
    // find the guid, so add it to the list
    if (NULL == pGE) {

        pGE = (SGuidList *) LocalAlloc(LPTR, sizeof(SGuidList));
        if (pGE) {

            pGEData = &pGE->m_dpData;

            // Set the SGuidList member variables
            pGE->dwSig = TRACESIG;
            pGE->m_iDefaultErrorLevel = g_dwDefaultErrorLevel;

            // Set the SGuidList.m_dpData member variables
            strncpy(pGEData->m_rgchLabel,
                    pszPrintLabel, MAX_LABEL_LENGTH - 1);
            pGEData->m_rgchLabel[MAX_LABEL_LENGTH-1] = '\0';
            pGEData->m_guidControl = *ControlGuid;
            pGEData->m_bBreakOnAssert = TRUE;   // Default - Break if Assert Fails
            pGEData->m_iControlFlag = g_dwDefaultControlFlag;

            // Add it to the head of the list. Put it at the head in case this
            // is an object which is being loaded and unloaded continuosly.
            InsertHeadList(&g_pGuidList, &pGE->m_leEntry);

            // And now update the registry with the information about the guid
            // so that we don't have to do this again. While we have already
            // done a DBG_ASSERT above we should still verify that the module
            // has a name before calling this in case of new components
            if (pGEData->m_rgchLabel[0])
                AddToRegistry(pGE);
        }
    }
    else
        pGEData = &pGE->m_dpData;

    // And then if we have the member initialize its data members with the
    // parameters supplied by the caller
    if (NULL != pGEData) {

        DBG_ASSERT(!strncmp(pGEData->m_rgchLabel,
                            pszPrintLabel,
                            MAX_LABEL_LENGTH - 1));

        // Check to see if we had a deferred start waiting, this would happen
        // if we received a WMI initialize during the main phase but we had not
        // yet loaded this module
        if (pGE->m_iInitializeFlags & DEBUG_FLAG_DEFERRED_START) {

            pGE->m_iInitializeFlags &= ~(DEBUG_FLAG_DEFERRED_START | DEBUG_FLAG_INITIALIZE);
        }
        // Otherwise load the default control flags, but only if we are not
        // waiting for initialization. When we are waiting, the registry
        // entries we have already loaded are to take precedence
        else if (!(pGE->m_iInitializeFlags & DEBUG_FLAG_INITIALIZE)) {

            // Set the SGuidList.m_dpData member variables
            pGEData->m_iControlFlag = DefaultControlFlags;
        }

        // Save the pointer to the error flags and set the level
        pGEData->m_piErrorFlags = ErrorFlags;
        SetLevel(pGE->m_iDefaultErrorLevel, pGEData->m_piErrorFlags);
    }

    if (NULL == pGEData) {
        char szTemp[MAX_PATH];

        _snprintf(szTemp, sizeof(szTemp),
                  "%16s:\t%s(%d), Unable to find in or add a Guid to the trace list, return code = %d\n",
                  pszPrintLabel, __FILE__, __LINE__,
                  GetLastError());
        OutputDebugString(szTemp);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    // And finally ALWAYS or in the ODS flag if enabled
    if (g_ODSEnabled && ErrorFlags)
        *ErrorFlags |= DEBUG_FLAG_ODS;

    LeaveCriticalSection(&g_csGuidList);

    return pGEData;

} // PuCreateDebugPrintsObject()


VOID
PuDeleteDebugPrintsObject(
    IN OUT LPDEBUG_PRINTS pDebugPrints
    )
/*++
    This function cleans up the pDebugPrints object and does an frees of
    allocated memory that may be required.

    Arguments:
       pDebugPrints         pointer to the DEBUG_PRINTS object.

    Returns:

--*/
{
    SGuidList *pGE = NULL;

    EnterCriticalSection(&g_csGuidList);

    if (NULL != pDebugPrints) {

        // Since we no longer delete anything or bother to shut it down all we
        // need to do here is clear the pointer to the error flag
        pDebugPrints->m_piErrorFlags = NULL;

        // we allocated an SGuidList that contained the DEBUG_PRINTS struct
        pGE = CONTAINING_RECORD(pDebugPrints, SGuidList, m_dpData);
        DBG_ASSERT(TRACESIG == pGE->dwSig);
        if (pGE)
        {
            RemoveEntryList(&pGE->m_leEntry);
            pGE->dwSig = 0;
            LocalFree(pGE);
        }
    }

    LeaveCriticalSection(&g_csGuidList);

} // PuDeleteDebugPrintsObject()

VOID
PuDbgPrintMain(
   IN OUT LPDEBUG_PRINTS pDebugPrints,
   IN const BOOL         bUnicodeRequest,
   IN const char *       pszFilePath,
   IN int                nLineNum,
   IN const char *       pszFormat,
   IN va_list            argptr
)
/*++
    Main function that examines the incoming message and works out what to do
    with the header and the message.

    Arguments:
       pDebugPrints         pointer to the DEBUG_PRINTS object.
       pszFilePath          null terminated string which is the file name
       nLineNum             the number of the line where the tracing is coming from
       pszFormat & ...      the format and arguments to be written out

    Returns:

--*/
{
    LPCSTR pszFileName = strrchr( pszFilePath, '\\');
    WCHAR szwOutput[ MAX_PRINTF_OUTPUT + 2];
    char *pszOutput = (char *) szwOutput;
    char rgchLabel[MAX_LABEL_LENGTH] = "";
    TRACEHANDLE hLogger = 0;
    TRACE_INFO tiTraceInfo;
    DWORD dwSequenceNumber;
    BOOL bUseODS = FALSE;
    int cchOutput;
    int nLength;

    // Save the current error state so that we don't disrupt it
    DWORD dwErr = GetLastError();

    // Skip the '\' and retain only the file name in pszFileName
    if (pszFileName)
        ++pszFileName;
    else
        pszFileName = pszFilePath;

    EnterCriticalSection(&g_csGuidList);

    // Determine if we are to do an OutputDebugString
    if (g_ODSEnabled &&
        (pDebugPrints &&
         pDebugPrints->m_piErrorFlags &&
         (*pDebugPrints->m_piErrorFlags & DEBUG_FLAG_ODS)))
    {
        bUseODS = TRUE;
    }

    if (NULL != pDebugPrints) {
        // Save local copies of the data needed for the ODS case
        if (bUseODS) {
            strncpy(rgchLabel, pDebugPrints->m_rgchLabel, sizeof(rgchLabel));
        }

        // Save local copies of the data needed for the WMI Tracing case
        if (pDebugPrints->m_hLogger) {

            dwSequenceNumber = ++g_dwSequenceNumber;
            hLogger = pDebugPrints->m_hLogger;

            // Initialize our traceinfo structure
            memset(&tiTraceInfo, 0x00, sizeof(tiTraceInfo));
            tiTraceInfo.TraceHeader.Guid = pDebugPrints->m_guidControl;
        }
    }

    // All data is now local so we can leave the critical section
    LeaveCriticalSection(&g_csGuidList);

    if (hLogger) {

        int pid = GetCurrentProcessId();
        ULONG Status = ERROR_SUCCESS;
        // Format the incoming message using vsnprintf() so that we don't exceed
        // the buffer length
        if (bUnicodeRequest) {
            cchOutput = _vsnwprintf(szwOutput, MAX_PRINTF_OUTPUT, (WCHAR *) pszFormat, argptr);
            // If the string is too long, we get back a length of -1, so just use the
            // partial data that fits in the string
            if (cchOutput == -1) {
                // Terminate the string properly since _vsnprintf() does not terminate
                // properly on failure.
                cchOutput = MAX_PRINTF_OUTPUT;
                szwOutput[ cchOutput] = '\0';
            }
            ++cchOutput;
            cchOutput *= sizeof(WCHAR);
        }
        else {
            cchOutput = _vsnprintf(pszOutput, sizeof(szwOutput), pszFormat, argptr);
            // If the string is too long, we get back a length of -1, so just use the
            // partial data that fits in the string
            if (cchOutput == -1) {
                // Terminate the string properly since _vsnprintf() does not terminate
                // properly on failure.
                cchOutput = sizeof(szwOutput) - 1;
                pszOutput[cchOutput] = '\0';
            }
            ++cchOutput;
        }
        // Fill out the Tracing structure
        tiTraceInfo.TraceHeader.Size = sizeof(TRACE_INFO);
        tiTraceInfo.TraceHeader.Class.Type = EVENT_TRACE_TYPE_INFO;
        tiTraceInfo.TraceHeader.Flags = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;
        tiTraceInfo.TraceHeader.ThreadId = GetCurrentThreadId();
        tiTraceInfo.MofFields[0].DataPtr = (ULONGLONG) &dwSequenceNumber;
        tiTraceInfo.MofFields[0].Length = sizeof(int);
        tiTraceInfo.MofFields[1].DataPtr = (ULONGLONG) &pid;
        tiTraceInfo.MofFields[1].Length = sizeof(int);
        tiTraceInfo.MofFields[2].DataPtr = (ULONGLONG) &nLineNum;
        tiTraceInfo.MofFields[2].Length = sizeof(int);
        tiTraceInfo.MofFields[3].DataPtr = (ULONGLONG) pszFileName;
        tiTraceInfo.MofFields[3].Length = strlen(pszFileName) + 1;
        tiTraceInfo.MofFields[4].DataPtr = (ULONGLONG) szwOutput;
        tiTraceInfo.MofFields[4].Length = cchOutput;
        // Send the trace information to the trace class
        TraceEvent(hLogger, (PEVENT_TRACE_HEADER) &tiTraceInfo);
    }

    if (bUseODS) {

        int cchPrologue;
        // Create the prologue
        if (bUnicodeRequest) {
            WCHAR wszLabel[MAX_PRINTF_OUTPUT];
            WCHAR wszFileName[MAX_PRINTF_OUTPUT];
            int iLength = MAX_PRINTF_OUTPUT;

            if (MultiByteToWideChar(CP_ACP, 0, rgchLabel, -1, wszLabel, iLength) &&
                MultiByteToWideChar(CP_ACP, 0, pszFileName, -1, wszFileName, iLength))
            {
                cchOutput = _snwprintf(szwOutput,
                                       MAX_PRINTF_OUTPUT,
                                       L"IISTRACE\t%s\t(%lu)\t[ %12s : %5d]\t",
                                       wszLabel,
                                       GetCurrentThreadId(),
                                       wszFileName,
                                       nLineNum);
                cchOutput = _vsnwprintf(szwOutput + cchOutput,
                                       MAX_PRINTF_OUTPUT - cchOutput - 1,
                                       (WCHAR *) pszFormat,
                                       argptr);
                // If the string is too long, we get back -1. So we get the string
                // length for partial data.
                if (cchOutput == -1) {
                    // Terminate the string properly, since _vsnprintf() does not
                    // terminate properly on failure.
                    cchOutput = MAX_PRINTF_OUTPUT;
                    szwOutput[ cchOutput] = '\0';
                }
                OutputDebugStringW(szwOutput);
            }
        }
        else {
            int cchPrologue;
            // Create the prologue
            cchPrologue = _snprintf(pszOutput,
                                    sizeof(szwOutput),
                                    "IISTRACE\t%s\t(%lu)\t[ %12s : %5d]\t",
                                    rgchLabel,
                                    GetCurrentThreadId(),
                                    pszFileName,
                                    nLineNum);
            // Format the incoming message using vsnprintf() so that the overflows are
            //  captured
            cchOutput = _vsnprintf(pszOutput + cchPrologue,
                                   sizeof(szwOutput) - cchPrologue - 1,
                                   pszFormat,
                                   argptr);
            // If the string is too long, we get back -1. So we get the string
            // length for partial data.
            if (cchOutput == -1) {
                // Terminate the string properly, since _vsnprintf() does not
                // terminate properly on failure.
                cchOutput = sizeof(szwOutput) - 1;
                pszOutput[cchOutput] = '\0';
            }
            OutputDebugStringA(pszOutput);
        }
    }

    // Restore the error state
    SetLastError( dwErr );
} // PuDbgPrintMain()

VOID
PuDbgPrint(
   IN OUT LPDEBUG_PRINTS pDebugPrints,
   IN const char *       pszFilePath,
   IN int                nLineNum,
   IN const char *       pszFormat,
   ...)
{
    va_list argsList;

    va_start(argsList, pszFormat);
    PuDbgPrintMain(pDebugPrints, FALSE, pszFilePath, nLineNum, pszFormat, argsList);
    va_end(argsList);
}

dllexp VOID
PuDbgPrintW(
   IN OUT LPDEBUG_PRINTS pDebugPrints,
   IN const char *       pszFilePath,
   IN int                nLineNum,
   IN const WCHAR *      pszFormat,
   ...)
{
    va_list argsList;

    va_start(argsList, pszFormat);
    PuDbgPrintMain(pDebugPrints, TRUE, pszFilePath, nLineNum, (char *) pszFormat, argsList);
    va_end(argsList);
}

VOID
PuDbgDumpMain(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN BOOL                 bUnicodeRequest,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszDump
   )
/*++
    Function that write a dump of a buffer out to the trace file.

    Arguments:
       pDebugPrints         pointer to the DEBUG_PRINTS object.
       pszFilePath          null terminated string which is the file name
       nLineNum             the number of the line where the tracing is coming from
       pszDump              the dump to be written out

    Returns:

--*/
{
    LPCSTR pszFileName = strrchr( pszFilePath, '\\');
    TRACEHANDLE hLogger = 0;
    TRACE_INFO tiTraceInfo;
    DWORD dwSequenceNumber;
    BOOL bUseODS = FALSE;
    DWORD cbDump;

    // Save the current error state so that we don't disrupt it
    DWORD dwErr = GetLastError();

    // Skip the complete path name and retain only the file name in pszFileName
    if ( pszFileName)
        ++pszFileName;
    else
        pszFileName = pszFilePath;

    EnterCriticalSection(&g_csGuidList);

    // Determine if we are to do an OutputDebugString
    if (g_ODSEnabled ||
        (pDebugPrints &&
         pDebugPrints->m_piErrorFlags &&
         (*pDebugPrints->m_piErrorFlags & DEBUG_FLAG_ODS)))
    {
        bUseODS = TRUE;
    }

    // Save local copies of the data needed for the WMI Tracing case
    if ((NULL != pDebugPrints) && pDebugPrints->m_hLogger) {

        dwSequenceNumber = ++g_dwSequenceNumber;
        hLogger = pDebugPrints->m_hLogger;

        if (bUnicodeRequest)
            cbDump = (wcslen((WCHAR *) pszDump) + 1) * sizeof(WCHAR);
        else
            cbDump = strlen( pszDump) + 1;

        // Initialize our traceinfo structure
        memset(&tiTraceInfo, 0x00, sizeof(tiTraceInfo));
        tiTraceInfo.TraceHeader.Guid = pDebugPrints->m_guidControl;
    }

    // All data is now local so we can leave the critical section
    LeaveCriticalSection(&g_csGuidList);

    // Send the outputs to respective files.
    if (hLogger) {
        int pid = GetCurrentProcessId();
        // Fill out the Tracing structure
        tiTraceInfo.TraceHeader.Size = sizeof(TRACE_INFO);
        tiTraceInfo.TraceHeader.Class.Type = EVENT_TRACE_TYPE_INFO;
        tiTraceInfo.TraceHeader.Flags = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;
        tiTraceInfo.TraceHeader.ThreadId = GetCurrentThreadId();
        tiTraceInfo.MofFields[0].DataPtr = (ULONGLONG) &dwSequenceNumber;
        tiTraceInfo.MofFields[0].Length = sizeof(int);
        tiTraceInfo.MofFields[1].DataPtr = (ULONGLONG) &pid;
        tiTraceInfo.MofFields[1].Length = sizeof(int);
        tiTraceInfo.MofFields[2].DataPtr = (ULONGLONG) &nLineNum;
        tiTraceInfo.MofFields[2].Length = sizeof(int);
        tiTraceInfo.MofFields[3].DataPtr = (ULONGLONG) pszFileName;
        tiTraceInfo.MofFields[3].Length = strlen(pszFileName) + 1;
        tiTraceInfo.MofFields[4].DataPtr = (ULONGLONG) pszDump;
        tiTraceInfo.MofFields[4].Length = cbDump;
        // Send the trace information to the trace class
        TraceEvent(hLogger, (PEVENT_TRACE_HEADER) &tiTraceInfo);
    }

    if (bUseODS) {
        if (bUnicodeRequest)
            OutputDebugStringW((WCHAR *) pszDump);
        else
            OutputDebugString(pszDump);
    }

    // Restore the error state
    SetLastError( dwErr );
} // PuDbgDumpMain()

VOID
PuDbgDump(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszDump
   )
{
    PuDbgDumpMain(pDebugPrints, FALSE, pszFilePath, nLineNum, pszDump);
}

dllexp VOID
PuDbgDumpW(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const WCHAR *        pszDump
   )
{
    PuDbgDumpMain(pDebugPrints, TRUE, pszFilePath, nLineNum, (char *) pszDump);
}

//
// N.B. For PuDbgCaptureContext() to work properly, the calling function
// *must* be __cdecl, and must have a "normal" stack frame. So, we decorate
// PuDbgAssertFailed() with the __cdecl modifier and disable the frame pointer
// omission (FPO) optimization.
//

#pragma optimize( "y", off )    // disable frame pointer omission (FPO)

VOID
__cdecl
PuDbgAssertFailed(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum,
    IN const char *               pszExpression)
/*++
    This function calls assertion failure and records assertion failure
     in log file.

--*/
{
    CONTEXT context;

    PuDbgCaptureContext( &context );

    PuDbgPrint(pDebugPrints, pszFilePath, nLineNum,
               " Assertion (%s) Failed\n"
               " use !cxr %p to dump context\n",
               pszExpression,
               &context);

    if (( NULL == pDebugPrints) || (TRUE == pDebugPrints->m_bBreakOnAssert))
    {
        DebugBreak();
    }
} // PuDbgAssertFailed()

#pragma optimize( "", on )      // restore frame pointer omission (FPO)

# else // !_NO_TRACING_

LPDEBUG_PRINTS
PuCreateDebugPrintsObject(
    IN const char *         pszPrintLabel,
    IN DWORD                dwOutputFlags)
/*++
   This function creates a new DEBUG_PRINTS object for the required
     program.

   Arguments:
      pszPrintLabel     pointer to null-terminated string containing
                         the label for program's debugging output
      dwOutputFlags     DWORD containing the output flags to be used.

   Returns:
       pointer to a new DEBUG_PRINTS object on success.
       Returns NULL on failure.
--*/
{

   LPDEBUG_PRINTS   pDebugPrints;

   pDebugPrints = GlobalAlloc( GPTR, sizeof( DEBUG_PRINTS));

   if ( pDebugPrints != NULL) {

        if ( strlen( pszPrintLabel) < MAX_LABEL_LENGTH) {

            strcpy( pDebugPrints->m_rgchLabel, pszPrintLabel);
        } else {
            strncpy( pDebugPrints->m_rgchLabel,
                     pszPrintLabel, MAX_LABEL_LENGTH - 1);
            pDebugPrints->m_rgchLabel[MAX_LABEL_LENGTH-1] = '\0';
                // terminate string
        }

        memset( pDebugPrints->m_rgchLogFilePath, 0, MAX_PATH);
        memset( pDebugPrints->m_rgchLogFileName, 0, MAX_PATH);

        pDebugPrints->m_LogFileHandle = INVALID_HANDLE_VALUE;

        pDebugPrints->m_dwOutputFlags = dwOutputFlags;
        pDebugPrints->m_StdErrHandle  = GetStdHandle( STD_ERROR_HANDLE);
        pDebugPrints->m_fInitialized  = TRUE;
        pDebugPrints->m_fBreakOnAssert= TRUE;   // Default - Break if Assert Fails
    }


   return ( pDebugPrints);
} // PuCreateDebugPrintsObject()




LPDEBUG_PRINTS
PuDeleteDebugPrintsObject(
    IN OUT LPDEBUG_PRINTS pDebugPrints)
/*++
    This function cleans up the pDebugPrints object and
      frees the allocated memory.

    Arguments:
       pDebugPrints     poitner to the DEBUG_PRINTS object.

    Returns:
        NULL  on  success.
        pDebugPrints() if the deallocation failed.

--*/
{
    if ( pDebugPrints != NULL) {

        DWORD dwError = PuCloseDbgPrintFile( pDebugPrints);

        if ( dwError != NO_ERROR) {

            SetLastError( dwError);
        } else {

            pDebugPrints = GlobalFree( pDebugPrints);  // returns NULL on success
        }

    }

    return ( pDebugPrints);

} // PuDeleteDebugPrintsObject()




dllexp VOID
PuSetDbgOutputFlags(
    IN OUT LPDEBUG_PRINTS   pDebugPrints,
    IN DWORD                dwFlags)
{

    if ( pDebugPrints == NULL) {

        SetLastError( ERROR_INVALID_PARAMETER);
    } else {

        pDebugPrints->m_dwOutputFlags = dwFlags;
    }

    return;
} // PuSetDbgOutputFlags()



dllexp DWORD
PuGetDbgOutputFlags(
    IN const LPDEBUG_PRINTS      pDebugPrints)
{
    return ( pDebugPrints != NULL) ? pDebugPrints->m_dwOutputFlags : 0;

} // PuGetDbgOutputFlags()


DWORD
PuOpenDbgFileLocal(
   IN OUT LPDEBUG_PRINTS pDebugPrints)
{
    if ( pDebugPrints == NULL)
        return ERROR_INVALID_PARAMETER;

    if ( pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {

        //
        // Silently return as a file handle exists.
        //
        return ( NO_ERROR);
    }

    pDebugPrints->m_LogFileHandle =
                      CreateFile( pDebugPrints->m_rgchLogFileName,
                                  GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);

    if ( pDebugPrints->m_LogFileHandle == INVALID_HANDLE_VALUE) {

        CHAR  pchBuffer[1024];
        DWORD dwError = GetLastError();

        wsprintfA( pchBuffer,
                  " Critical Error: Unable to Open File %s. Error = %d\n",
                  pDebugPrints->m_rgchLogFileName, dwError);
        OutputDebugString( pchBuffer);

        return ( dwError);
    }

    return ( NO_ERROR);
} // PuOpenDbgFileLocal()





dllexp DWORD
PuOpenDbgPrintFile(
   IN OUT LPDEBUG_PRINTS      pDebugPrints,
   IN const char *            pszFileName,
   IN const char *            pszPathForFile)
/*++

  Opens a Debugging log file. This function can be called to set path
  and name of the debugging file.

  Arguments:
     pszFileName           pointer to null-terminated string containing
                            the name of the file.

     pszPathForFile        pointer to null-terminated string containing the
                            path for the given file.
                           If NULL, then the old place where dbg files were
                           stored is used or if none,
                           default windows directory will be used.

   Returns:
       Win32 error codes. NO_ERROR on success.

--*/
{
    if ( pszFileName == NULL || pDebugPrints == NULL) {

        return ( ERROR_INVALID_PARAMETER);
    }

    //
    //  Setup the Path information. if necessary.
    //

    if ( pszPathForFile != NULL) {

        // Path is being changed.

        if ( strlen( pszPathForFile) < MAX_PATH) {

            strcpy( pDebugPrints->m_rgchLogFilePath, pszPathForFile);
        } else {

            return ( ERROR_INVALID_PARAMETER);
        }
    } else {

        if ( pDebugPrints->m_rgchLogFilePath[0] == '\0' &&  // no old path
            !GetWindowsDirectory( pDebugPrints->m_rgchLogFilePath, MAX_PATH)) {

            //
            //  Unable to get the windows default directory. Use current dir
            //

            strcpy( pDebugPrints->m_rgchLogFilePath, ".");
        }
    }

    //
    // Should need be, we need to create this directory for storing file
    //


    //
    // Form the complete Log File name and open the file.
    //
    if ( (strlen( pszFileName) + strlen( pDebugPrints->m_rgchLogFilePath))
         >= MAX_PATH) {

        return ( ERROR_NOT_ENOUGH_MEMORY);
    }

    //  form the complete path
    strcpy( pDebugPrints->m_rgchLogFileName, pDebugPrints->m_rgchLogFilePath);

    if ( pDebugPrints->m_rgchLogFileName[ strlen(pDebugPrints->m_rgchLogFileName) - 1]
        != '\\') {
        // Append a \ if necessary
        strcat( pDebugPrints->m_rgchLogFileName, "\\");
    };
    strcat( pDebugPrints->m_rgchLogFileName, pszFileName);

    return  PuOpenDbgFileLocal( pDebugPrints);

} // PuOpenDbgPrintFile()




dllexp DWORD
PuReOpenDbgPrintFile(
    IN OUT LPDEBUG_PRINTS    pDebugPrints)
/*++

  This function closes any open log file and reopens a new copy.
  If necessary. It makes a backup copy of the file.

--*/
{
    if ( pDebugPrints == NULL) {
        return ( ERROR_INVALID_PARAMETER);
    }

    PuCloseDbgPrintFile( pDebugPrints);      // close any existing file.

    if ( pDebugPrints->m_dwOutputFlags & DbgOutputBackup) {

        // MakeBkupCopy();

        OutputDebugString( " Error: MakeBkupCopy() Not Yet Implemented\n");
    }

    return PuOpenDbgFileLocal( pDebugPrints);

} // PuReOpenDbgPrintFile()




dllexp DWORD
PuCloseDbgPrintFile(
    IN OUT LPDEBUG_PRINTS    pDebugPrints)
{
    DWORD dwError = NO_ERROR;

    if ( pDebugPrints == NULL ) {
        dwError = ERROR_INVALID_PARAMETER;
    } else {

        if ( pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {

            FlushFileBuffers( pDebugPrints->m_LogFileHandle);

            if ( !CloseHandle( pDebugPrints->m_LogFileHandle)) {

                CHAR pchBuffer[1024];

                dwError = GetLastError();

                wsprintf( pchBuffer,
                          "CloseDbgPrintFile() : CloseHandle( %d) failed."
                          " Error = %d\n",
                          pDebugPrints->m_LogFileHandle,
                          dwError);
                OutputDebugString( pchBuffer);
            }

            pDebugPrints->m_LogFileHandle = INVALID_HANDLE_VALUE;
        }
    }

    return ( dwError);
} // DEBUG_PRINTS::CloseDbgPrintFile()


VOID
PuDbgPrint(
   IN OUT LPDEBUG_PRINTS      pDebugPrints,
   IN const char *            pszFilePath,
   IN int                     nLineNum,
   IN const char *            pszFormat,
   ...)
/*++

   Main function that examines the incoming message and prints out a header
    and the message.

--*/
{
   LPCSTR pszFileName = strrchr( pszFilePath, '\\');
   char pszOutput[ MAX_PRINTF_OUTPUT + 2];
   LPCSTR pszMsg = "";
   INT  cchOutput;
   INT  cchPrologue;
   va_list argsList;
   DWORD dwErr;


   //
   //  Skip the complete path name and retain file name in pszName
   //

   if ( pszFileName== NULL) {

      pszFileName = pszFilePath;  // if skipping \\ yields nothing use whole path.
   }

# ifdef _PRINT_REASONS_INCLUDED_

  switch (pr) {

     case PrintError:
        pszMsg = "ERROR: ";
        break;

     case PrintWarning:
        pszMsg = "WARNING: ";
        break;

     case PrintCritical:
        pszMsg = "FATAL ERROR ";
        break;

     case PrintAssertion:
        pszMsg = "ASSERTION Failed ";
        break;

     case PrintLog:
        pfnPrintFunction = &DEBUG_PRINTS::DebugPrintNone;
     default:
        break;

  } /* switch */

# endif // _PRINT_REASONS_INClUDED_

  dwErr = GetLastError();

  // Format the message header

  cchPrologue = wsprintf( pszOutput, "IISTRACE\t%s\t(%lu)\t[ %12s : %05d]\t",
                        pDebugPrints ? pDebugPrints->m_rgchLabel : "??",
                        GetCurrentThreadId(),
                        pszFileName, nLineNum);

  // Format the incoming message using vsnprintf() so that the overflows are
  //  captured

  va_start( argsList, pszFormat);

  cchOutput = _vsnprintf( pszOutput + cchPrologue,
                          MAX_PRINTF_OUTPUT - cchPrologue - 1,
                          pszFormat, argsList);
  va_end( argsList);

  //
  // The string length is long, we get back -1.
  //   so we get the string length for partial data.
  //

  if ( cchOutput == -1 ) {

      //
      // terminate the string properly,
      //   since _vsnprintf() does not terminate properly on failure.
      //
      cchOutput = MAX_PRINTF_OUTPUT;
      pszOutput[ cchOutput] = '\0';
  }

  //
  // Send the outputs to respective files.
  //

  if ( pDebugPrints != NULL)
  {
      if ( pDebugPrints->m_dwOutputFlags & DbgOutputStderr) {

          DWORD nBytesWritten;

          ( VOID) WriteFile( pDebugPrints->m_StdErrHandle,
                             pszOutput,
                             strlen( pszOutput),
                             &nBytesWritten,
                             NULL);
      }

      if ( pDebugPrints->m_dwOutputFlags & DbgOutputLogFile &&
           pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {

          DWORD nBytesWritten;

          //
          // Truncation of log files. Not yet implemented.

          ( VOID) WriteFile( pDebugPrints->m_LogFileHandle,
                             pszOutput,
                             strlen( pszOutput),
                             &nBytesWritten,
                             NULL);

      }
  }


  if ( pDebugPrints == NULL ||
       pDebugPrints->m_dwOutputFlags & DbgOutputKdb)
  {
      OutputDebugString( pszOutput);
  }

  SetLastError( dwErr );

  return;

} // PuDbgPrint()



VOID
PuDbgDump(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszDump
   )
{
   LPCSTR pszFileName = strrchr( pszFilePath, '\\');
   LPCSTR pszMsg = "";
   DWORD dwErr;
   DWORD cbDump;


   //
   //  Skip the complete path name and retain file name in pszName
   //

   if ( pszFileName== NULL) {

      pszFileName = pszFilePath;
   }

   dwErr = GetLastError();

   // No message header for this dump
   cbDump = strlen( pszDump);

   //
   // Send the outputs to respective files.
   //

   if ( pDebugPrints != NULL)
   {
       if ( pDebugPrints->m_dwOutputFlags & DbgOutputStderr) {

           DWORD nBytesWritten;

           ( VOID) WriteFile( pDebugPrints->m_StdErrHandle,
                              pszDump,
                              cbDump,
                              &nBytesWritten,
                              NULL);
       }

       if ( pDebugPrints->m_dwOutputFlags & DbgOutputLogFile &&
            pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {

           DWORD nBytesWritten;

           //
           // Truncation of log files. Not yet implemented.

           ( VOID) WriteFile( pDebugPrints->m_LogFileHandle,
                              pszDump,
                              cbDump,
                              &nBytesWritten,
                              NULL);

       }
   }

   if ( pDebugPrints == NULL
       ||  pDebugPrints->m_dwOutputFlags & DbgOutputKdb)
   {
       OutputDebugString( pszDump);
   }

   SetLastError( dwErr );

  return;
} // PuDbgDump()

//
// N.B. For PuDbgCaptureContext() to work properly, the calling function
// *must* be __cdecl, and must have a "normal" stack frame. So, we decorate
// PuDbgAssertFailed() with the __cdecl modifier and disable the frame pointer
// omission (FPO) optimization.
//

#pragma optimize( "y", off )    // disable frame pointer omission (FPO)

VOID
__cdecl
PuDbgAssertFailed(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum,
    IN const char *               pszExpression,
    IN const char *               pszMessage)
/*++
    This function calls assertion failure and records assertion failure
     in log file.

--*/
{
    CONTEXT context;

    PuDbgCaptureContext( &context );

    PuDbgPrint( pDebugPrints, pszFilePath, nLineNum,
                " Assertion (%s) Failed: %s\n"
                " use !cxr %p to dump context\n",
                pszExpression,
                pszMessage,
                &context);

    if (( NULL == pDebugPrints) || (TRUE == pDebugPrints->m_fBreakOnAssert))
    {
        DebugBreak();
    }

    return;
} // PuDbgAssertFailed()

#pragma optimize( "", on )      // restore frame pointer omission (FPO)



dllexp VOID
PuDbgPrintCurrentTime(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum
    )
/*++
  This function generates the current time and prints it out to debugger
   for tracing out the path traversed, if need be.

  Arguments:
      pszFile    pointer to string containing the name of the file
      lineNum    line number within the file where this function is called.

  Returns:
      NO_ERROR always.
--*/
{
    PuDbgPrint( pDebugPrints, pszFilePath, nLineNum,
                " TickCount = %u\n",
                GetTickCount()
                );

    return;
} // PrintOutCurrentTime()




dllexp DWORD
PuLoadDebugFlagsFromReg(IN HKEY hkey, IN DWORD dwDefault, IN LPDEBUG_PRINTS pDebugPrints)
/*++
  This function reads the debug flags assumed to be stored in
   the location  "DebugFlags" under given key.
  If there is any error the default value is returned.
--*/
{
    DWORD err;
    DWORD dwDebug = dwDefault;
    DWORD  dwBuffer;
    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;

    if( hkey != NULL )
    {
        err = RegQueryValueExA( hkey,
                               DEBUG_FLAGS_REGISTRY_LOCATION_A,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

        if( ( err == NO_ERROR ) && ( dwType == REG_DWORD ) )
        {
            dwDebug = dwBuffer;
        }

        cbBuffer = sizeof(DWORD);

        if (pDebugPrints)
        {
            err = RegQueryValueExA( hkey,
                               DEBUG_BREAK_ENABLED_REGKEYNAME_A,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

            if( ( err == NO_ERROR ) && ( dwType == REG_DWORD ) )
            {
                pDebugPrints->m_fBreakOnAssert = dwBuffer;
            }
        }
    }

    return dwDebug;
} // PuLoadDebugFlagsFromReg()




dllexp DWORD
PuLoadDebugFlagsFromRegStr(IN LPCSTR pszRegKey, IN DWORD dwDefault, IN LPDEBUG_PRINTS pDebugPrints)
/*++
Description:
  This function reads the debug flags assumed to be stored in
   the location  "DebugFlags" under given key location in registry.
  If there is any error the default value is returned.

Arguments:
  pszRegKey - pointer to registry key location from where to read the key from
  dwDefault - default values in case the read from registry fails

Returns:
   Newly read value on success
   If there is any error the dwDefault is returned.
--*/
{
    HKEY        hkey = NULL;

    DWORD dwVal = dwDefault;

    DWORD dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                  pszRegKey,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hkey);
    if ( dwError == NO_ERROR) {
        dwVal = PuLoadDebugFlagsFromReg( hkey, dwDefault, pDebugPrints);
        RegCloseKey( hkey);
        hkey = NULL;
    }

    return ( dwVal);
} // PuLoadDebugFlagsFromRegStr()





dllexp DWORD
PuSaveDebugFlagsInReg(IN HKEY hkey, IN DWORD dwDbg)
/*++
  Saves the debug flags in registry. On failure returns the error code for
   the operation that failed.

--*/
{
    DWORD err;

    if( hkey == NULL ) {

        err = ERROR_INVALID_PARAMETER;
    } else {

        err = RegSetValueExA(hkey,
                             DEBUG_FLAGS_REGISTRY_LOCATION_A,
                             0,
                             REG_DWORD,
                             (LPBYTE)&dwDbg,
                             sizeof(dwDbg) );
    }

    return (err);
} // PuSaveDebugFlagsInReg()

#endif // !_NO_TRACING_

VOID
PuDbgCaptureContext (
    OUT PCONTEXT ContextRecord
    )
{

    RtlCaptureContext(ContextRecord);
    return;

}   // PuDbgCaptureContext

/****************************** End of File ******************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\reftrace.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    reftrace.c

Abstract:

    This module implements a reference count tracing facility.

Author:

    Keith Moore (keithmo)        01-May-1997

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <pudebug.h>
#include <reftrace.h>
#include <stktrace.h>



PTRACE_LOG
CreateRefTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    )
/*++

Routine Description:

    Creates a new (empty) ref count trace log buffer.

Arguments:

    LogSize - The number of entries in the log.

    ExtraBytesInHeader - The number of extra bytes to include in the
        log header. This is useful for adding application-specific
        data to the log.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--*/
{

    return CreateTraceLog(
               LogSize,
               ExtraBytesInHeader,
               sizeof(REF_TRACE_LOG_ENTRY)
               );

}   // CreateRefTraceLog


VOID
DestroyRefTraceLog(
    IN PTRACE_LOG Log
    )
/*++

Routine Description:

    Destroys a ref count trace log buffer created with CreateRefTraceLog().

Arguments:

    Log - The ref count trace log buffer to destroy.

Return Value:

    None.

--*/
{

    DestroyTraceLog( Log );

}   // DestroyRefTraceLog


//
// N.B. For IISCaptureStackBackTrace() to work properly, the calling function
// *must* be __cdecl, and must have a "normal" stack frame. So, we decorate
// WriteRefTraceLog[Ex]() with the __cdecl modifier and disable the frame
// pointer omission (FPO) optimization.
//

#pragma optimize( "y", off )    // disable frame pointer omission (FPO)

LONG
__cdecl
WriteRefTraceLog(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context
    )
/*++

Routine Description:

    Writes a new entry to the specified ref count trace log. The entry
    written contains the updated reference count and a stack backtrace
    leading up to the current caller.

Arguments:

    Log - The log to write to.

    NewRefCount - The updated reference count.

    Context - An uninterpreted context to associate with the log entry.

Return Value:

    Index of entry in log.

--*/
{

    return WriteRefTraceLogEx(
        Log,
        NewRefCount,
        Context,
        REF_TRACE_EMPTY_CONTEXT, // suppress use of optional extra contexts
        REF_TRACE_EMPTY_CONTEXT,
        REF_TRACE_EMPTY_CONTEXT
        );

}   // WriteRefTraceLog




LONG
__cdecl
WriteRefTraceLogEx(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context,
    IN PVOID Context1, // optional extra context
    IN PVOID Context2, // optional extra context
    IN PVOID Context3  // optional extra context
    )
/*++

Routine Description:

    Writes a new "extended" entry to the specified ref count trace log.
    The entry written contains the updated reference count, stack backtrace
    leading up to the current caller and extra context information.

Arguments:

    Log - The log to write to.

    NewRefCount - The updated reference count.

    Context  - An uninterpreted context to associate with the log entry.
    Context1 - An uninterpreted context to associate with the log entry.
    Context2 - An uninterpreted context to associate with the log entry.
    Context3 - An uninterpreted context to associate with the log entry.

    NOTE Context1/2/3 are "optional" in that the caller may suppress
    debug display of these values by passing REF_TRACE_EMPTY_CONTEXT
    for each of them.

Return Value:

    Index of entry in log.

--*/
{

    REF_TRACE_LOG_ENTRY entry;
    ULONG hash;
    DWORD cStackFramesSkipped;

    //
    // Initialize the entry.
    //

    RtlZeroMemory(
        &entry,
        sizeof(entry)
        );

    //
    //  Set log entry members.
    //

    entry.NewRefCount = NewRefCount;
    entry.Context = Context;
    entry.Thread = GetCurrentThreadId();
    entry.Context1 = Context1;
    entry.Context2 = Context2;
    entry.Context3 = Context3;

    //
    // Capture the stack backtrace. Normally, we skip two stack frames:
    // one for this routine, and one for IISCaptureStackBackTrace() itself.
    // For non-Ex callers who come in via WriteRefTraceLog,
    // we skip three stack frames.
    //

    if (    entry.Context1 == REF_TRACE_EMPTY_CONTEXT 
         && entry.Context2 == REF_TRACE_EMPTY_CONTEXT
         && entry.Context3 == REF_TRACE_EMPTY_CONTEXT
         ) {

         cStackFramesSkipped = 3;

    } else {
    
         cStackFramesSkipped = 2;

    }

    IISCaptureStackBackTrace(
        cStackFramesSkipped,
        REF_TRACE_LOG_STACK_DEPTH,
        entry.Stack,
        &hash
        );

    //
    // Write it to the log.
    //

    return WriteTraceLog(
        Log,
        &entry
        );

}   // WriteRefTraceLogEx

#pragma optimize( "", on )      // restore frame pointer omission (FPO)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\sched.cxx ===
/*++

   Copyright    (c)    1995-2000     Microsoft Corporation

   Module Name:

       sched.cxx

   Abstract:

        This module contains a simple timer interface for scheduling future
        work items


   Author:

        John Ludeman    (johnl)     17-Jul-1995

   Project:

        Internet Servers Common Server DLL

   Revisions:
        Murali R. Krishnan  (MuraliK)     16-Sept-1996
          Added scheduler items cache
        George V. Reilly      (GeorgeRe)        May-1999
          Removed the global variables; turned into refcounted objects, so
          that code will survive stops and restarts when work items take a
          long time to complete
--*/

//
//  Include Headers
//

#include "precomp.hxx"
#include <objbase.h>

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <irtldbg.h>
#include "sched.hxx"


// Initialize class static members
CSchedData*       CSchedData::sm_psd = NULL;
CLockedDoubleList CSchedData::sm_lstSchedulers;
LONG              CSchedData::sm_nID = 0;
LONG              CThreadData::sm_nID = 1000;
LONG      SCHED_ITEM::sm_lSerialNumber = SCHED_ITEM::SERIAL_NUM_INITIAL_VALUE;




// SCHED_ITEM Finite State Machine
SCHED_ITEM_STATE sg_rgSchedNextState[SI_OP_MAX][SI_MAX_ITEMS] = {

    // operation = SI_OP_ADD
    {                          // old state
        SI_ERROR,               // SI_ERROR
        SI_ACTIVE,              // SI_IDLE
        SI_ERROR,               // SI_ACTIVE
        SI_ERROR,               // SI_ACTIVE_PERIODIC
        SI_ERROR,               // SI_CALLBACK_PERIODIC
        SI_ERROR,               // SI_TO_BE_DELETED
    },

    // operation = SI_OP_ADD_PERIODIC
    {                          // old state
        SI_ERROR,               // SI_ERROR
        SI_ACTIVE_PERIODIC,     // SI_IDLE
        SI_ERROR,               // SI_ACTIVE
        SI_ERROR,               // SI_ACTIVE_PERIODIC
        SI_ACTIVE_PERIODIC,     // SI_CALLBACK_PERIODIC: rescheduling
                                //   periodic item
        SI_ERROR,               // SI_TO_BE_DELETED
    },

    // operation = SI_OP_CALLBACK
    {                          // old state
        SI_ERROR,               // SI_ERROR
        SI_ERROR,               // SI_IDLE
        SI_TO_BE_DELETED,       // SI_ACTIVE: to be removed after completing
                                //   callbacks
        SI_CALLBACK_PERIODIC,   // SI_ACTIVE_PERIODIC
        SI_ERROR,               // SI_CALLBACK_PERIODIC
        SI_ERROR,               // SI_TO_BE_DELETED
    },

    // operation = SI_OP_DELETE
    {                          // old state
        SI_ERROR,               // SI_ERROR
        SI_ERROR,               // SI_IDLE
        SI_IDLE,                // SI_ACTIVE
        SI_IDLE,                // SI_ACTIVE_PERIODIC
        SI_TO_BE_DELETED,       // SI_CALLBACK_PERIODIC: mark this to be
                                //   deleted after return
        SI_TO_BE_DELETED,       // SI_TO_BE_DELETED: idempotent delete ops
    }
};



//
//  Global data items
//
LONG              cSchedInits = 0;
LONG              cSchedUninits = 0;


/************************************************************
 *  Public functions of Scheduler
 ************************************************************/



BOOL
SchedulerInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes the scheduler/timer package

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
// g_fErrorFlags |= DEBUG_SCHED;
// g_pDebug->m_iControlFlag |= DEBUG_SCHED;

    ++cSchedInits;

    unsigned idThread;
    LONG     i, numThreads;
    CSchedData* const psd = new CSchedData();

    if (psd == NULL  ||  !psd->IsValid())
        return FALSE;

    IF_DEBUG(SCHED)
    {
        DBGPRINTF(( DBG_CONTEXT, "SchedulerInitialize: inits=%d, uninits=%d\n",
                    cSchedInits, cSchedUninits));
    }

    if ( TsIsNtServer() ) {
        numThreads = max(NumProcessors(), NUM_SCHEDULE_THREADS_NTS);
    } else {
        numThreads = NUM_SCHEDULE_THREADS_PWS;
    }

    numThreads = min(numThreads, MAX_THREADS);
// numThreads = MAX_THREADS;

    DBG_ASSERT(numThreads > 0);

    for (i = 0;  i < numThreads;  ++i)
    {
        CThreadData* ptd = new CThreadData(psd);

        if (ptd == NULL  ||  !ptd->IsValid())
        {
            numThreads = i;
            if (ptd != NULL)
                ptd->Release();
            break;
        }
    }

    if (numThreads == 0)
    {
        delete psd;
        return FALSE;
    }

    // Kick scheduler threads into life now that everything has been
    // initialized.
    psd->m_lstThreads.Lock();

    for (CListEntry* ple = psd->m_lstThreads.First();
         ple != psd->m_lstThreads.HeadNode();
         ple = ple->Flink)
    {
        CThreadData* ptd = CONTAINING_RECORD(ple, CThreadData, m_leThreads);
        DBG_ASSERT(ptd->CheckSignature());
        ResumeThread(ptd->m_hThreadSelf);
    }

    psd->m_lstThreads.Unlock();

    // Update the global pointer to the scheduler
    CSchedData* const psd2 =
        (CSchedData*) InterlockedExchangePointer((VOID**)&CSchedData::sm_psd, psd);

    DBG_ASSERT(psd2 == NULL);

    return TRUE;
} // SchedulerInitialize()



VOID
SchedulerTerminate(
    VOID
    )
/*++

Routine Description:

    Terminates and cleans up the scheduling package.  Any items left on the
    list are *not* called during cleanup.

--*/
{
    // Grab the global pointer, then set it to NULL
    CSchedData* const psd =
        (CSchedData*) InterlockedExchangePointer((VOID**)&CSchedData::sm_psd, NULL);

    DBG_ASSERT(psd == NULL  ||  !psd->m_fShutdown);

    ++cSchedUninits;

    IF_DEBUG(SCHED)
    {
        DBGPRINTF(( DBG_CONTEXT, "SchedulerTerminate: inits=%d, uninits=%d\n",
                    cSchedInits, cSchedUninits));
    }

    if (psd == NULL  ||  psd->m_fShutdown)
    {
        // already shutting down
        return;
    }

    psd->Terminate();
}


void
CSchedData::Terminate()
{
    HANDLE ahThreadIds[MAX_THREADS];
    int i;
    CListEntry* ple;

    m_fShutdown = TRUE;

    const int nMaxTries = 1;
    const DWORD dwTimeOut = INFINITE;

    for (int iTries = 0;  iTries < nMaxTries;  ++iTries)
    {
        int nThreads = 0;
    
        m_lstThreads.Lock();
        
        for (ple = m_lstThreads.First(), i = 0;
             ple != m_lstThreads.HeadNode();
             ple = ple->Flink, i++)
        {
            CThreadData* ptd = CONTAINING_RECORD(ple, CThreadData,
                                                 m_leThreads);
            DBG_ASSERT(ptd->CheckSignature());
            // Set the shutdown event once for each thread
            DBGPRINTF(( DBG_CONTEXT, "CSchedData::Terminate: iteration %d, "
                        "notifying %ld\n", iTries, ptd->m_nID));
            DBG_REQUIRE( SetEvent(ptd->m_hevtShutdown) );
            ahThreadIds[i] = ptd->m_hThreadSelf;
            ++nThreads;
        }
        
        m_lstThreads.Unlock();
        
        if (nThreads == 0)
            break;

        // Wait for all the threads to shut down
        DWORD dw = WaitForMultipleObjects(nThreads, ahThreadIds,
                                          TRUE, dwTimeOut);
        DBGPRINTF(( DBG_CONTEXT, "CSchedData::Terminate: WFMO = %x\n", dw));
    }
        
    LockItems();
        
    //
    //  Delete all of the items that were scheduled, note we do *not*
    //  call any scheduled items in the list (there shouldn't be any)
    //

    if ( !m_lstItems.IsEmpty() )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[CSchedData::Terminate] Warning - Items in schedule list "
                    "at termination\n" ));
        int c = 0;

        CListEntry* pleSave = NULL;

        for (ple = m_lstItems.First();
             ple != m_lstItems.HeadNode();
             ple =  pleSave)
        {
            SCHED_ITEM* psiList = CONTAINING_RECORD( ple, SCHED_ITEM,
                                                     _ListEntry );
            DBG_ASSERT(psiList->CheckSignature());

            IF_DEBUG(SCHED)
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "[%8p] ser=%d ctxt=%p fncbk=%p state=%d thrd=%d\n",
                            psiList,
                            psiList->_dwSerialNumber,
                            psiList->_pContext,
                            psiList->_pfnCallback,
                            psiList->_siState,
                            psiList->_dwCallbackThreadId
                            ));
            }

            pleSave = ple->Flink;

            if (!psiList->FInsideCallbackOnOtherThread())
            {
                CDoubleList::RemoveEntry( &psiList->_ListEntry );
                ple->Flink = NULL;
                DeleteSchedItem(psiList);
                ++c;
            }
        }
        DBGPRINTF(( DBG_CONTEXT,
                    "[CSchedData::Terminate] %d items deleted\n", c ));
    }

    UnlockItems();

    Release();  // release the last reference to `this'
} // CSchedData::Terminate()


CSchedData::~CSchedData()
{
    DBG_ASSERT(m_lstThreads.IsEmpty());
    DBG_ASSERT(m_lstItems.IsEmpty());
    DBG_ASSERT(m_cThreads == 0);
    DBG_ASSERT(m_cRefs == 0);
    
    sm_lstSchedulers.RemoveEntry(&m_leGlobalList);
    CloseHandle(m_hevtNotify);
    delete m_pachSchedItems;
    
    CListEntry* pleSave = NULL;
    for (CListEntry* ple = m_lstDeadThreads.First();
         ple != m_lstDeadThreads.HeadNode();
         ple =  pleSave)
    {
        pleSave = ple->Flink;
        CThreadData* ptd = CONTAINING_RECORD(ple, CThreadData, m_leThreads);
        DBG_ASSERT(ptd->CheckSignature());
        delete ptd;
    }
    
    m_dwSignature = SIGNATURE_SCHEDDATA_FREE;
}



DWORD
WINAPI 
ScheduleWorkItem(
    PFN_SCHED_CALLBACK pfnCallback,
    PVOID              pContext,
    DWORD              msecTime,
    BOOL               fPeriodic
    )
/*++

Routine Description:

    Adds a timed work item to the work list

Arguments:

    pfnCallback - Function to call
    pContext - Context to pass to the callback
    msecTime - number of milliseconds to wait before calling timeout
    nPriority - Thread priority to set for work item

Return Value:

    zero on failure, non-zero on success.  The return value can be used to
    remove the scheduled work item.

--*/
{
    CSchedData* const psd = CSchedData::Scheduler();

    if (psd == NULL)
        return 0;

    //
    // 1. alloc a new scheduler item
    //

    SCHED_ITEM* psi = psd->NewSchedItem(pfnCallback, pContext, msecTime);

    if ( !psi )
    {
        // unable to create the item - return error cookie '0'
        return 0;
    }

    DWORD dwRet = psi->_dwSerialNumber;
    SCHED_OPS  siop = ((fPeriodic)? SI_OP_ADD_PERIODIC : SI_OP_ADD);
    psi->_siState = sg_rgSchedNextState[siop][SI_IDLE];

    //
    // 2. Insert the scheduler item into the active scheduler work-items list.
    //

    psd->LockItems();
    psd->InsertIntoWorkItemList( psi);
    psd->UnlockItems();

    //
    // 3. Indicate to scheduler threads that there is one new item on the list
    //

    DBG_REQUIRE( SetEvent( psd->m_hevtNotify ));

    IF_DEBUG(SCHED)
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "ScheduleWorkItem: (%d) "
                    "[%8p] ser=%d ctxt=%p fncbk=%p state=%d thrd=%d\n",
                    psd->m_nID,
                    psi,
                    psi->_dwSerialNumber,
                    psi->_pContext,
                    psi->_pfnCallback,
                    psi->_siState,
                    psi->_dwCallbackThreadId
                    ));
    }

    return dwRet;
} // ScheduleWorkItem()



BOOL
WINAPI 
RemoveWorkItem(
    DWORD  dwCookie
    )
/*++

Routine Description:

    Removes a scheduled work item

Arguments:

    dwCookie - The return value from a previous call to ScheduleWorkItem

Return Value:

    TRUE if the item was found, FALSE if the item was not found.

--*/
{
    CSchedData* const psd = CSchedData::Scheduler();

    if (psd == NULL)
        return FALSE;
    
    SCHED_ITEM*       psi = NULL;
    BOOL              fWait = FALSE;

    IF_DEBUG(SCHED)
    {
        DBGPRINTF(( DBG_CONTEXT, "RemoveWorkItem: cookie=%d sched=%d\n",
                    dwCookie, psd->m_nID));
    }

    //
    // 1. lock the list
    //

    psd->LockItems();

    //
    // 2. Find scheduler item on the list.
    //

    psi = psd->FindSchedulerItem( dwCookie);

    if ( NULL != psi)
    {

        //
        // 3. based on the state of the item take necessary actions.
        //

        SCHED_ITEM_STATE st =
            sg_rgSchedNextState[SI_OP_DELETE][psi->_siState];
        psi->_siState = st;
        switch ( st)
        {

        case SI_TO_BE_DELETED:
        {

            DBGPRINTF(( DBG_CONTEXT,
                        "SchedItem(%08p) marked to be deleted\n",
                        psi));
            // item will be deleted later.

            if (psi->FInsideCallbackOnOtherThread()) {
                // need to wait till callback complete
                psi->AddEvent();
                fWait = TRUE;
                break;
            }
        }
        // fallthru

        case SI_IDLE:
        {
            // delete immediately
            CDoubleList::RemoveEntry( &psi->_ListEntry );
            psi->_ListEntry.Flink = NULL;

            IF_DEBUG(SCHED)
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "RemoveWorkItem: "
                            "[%8p] ser=%d ctxt=%p fncbk=%p state=%d thrd=%d\n",
                            psi,
                            psi->_dwSerialNumber,
                            psi->_pContext,
                            psi->_pfnCallback,
                            psi->_siState,
                            psi->_dwCallbackThreadId
                            ));
            }

            psd->DeleteSchedItem(psi);
            break;
        }

        default:
            DBG_ASSERT( FALSE);
            break;
        } // switch()
    }

    // 4. Unlock the list
    psd->UnlockItems();

    // 5. Wait for callback event and release the item
    if (fWait)
    {
        LONG l = psi->WaitForEventAndRelease();
        IF_DEBUG(SCHED)
        {
            DBGPRINTF(( DBG_CONTEXT, "RemoveWorkItem: %d "
                        "WaitForEventAndRelease returned %d.\n",
                        dwCookie, l));
        }
        if (l == 0)
            psd->DeleteSchedItem(psi);
    }

    IF_DEBUG(SCHED)
    {
        if ( NULL == psi)
            DBGPRINTF(( DBG_CONTEXT, "RemoveWorkItem: %d not found\n",
                        dwCookie));
    }

    // return TRUE if we found the item
    return ( NULL != psi);
} // RemoveWorkItem()





DWORD
WINAPI 
ScheduleAdjustTime(
    DWORD dwCookie,
    DWORD msecNewTime
    )
/*++
  This function finds the scheduler object for given cookie and
  changes the interval for next timeout of the item. Returns a
  Win32 error code: NO_ERROR => success.

--*/
{
    CSchedData* const psd = CSchedData::Scheduler();

    if (psd == NULL)
        return ERROR_NO_DATA;

    DBG_ASSERT( 0 != dwCookie);

    psd->LockItems();

    // 1. Find the work item for given cookie
    SCHED_ITEM* psi = psd->FindSchedulerItem( dwCookie);

    if ( NULL != psi)
    {

        // 2. Remove the item from the list
        CDoubleList::RemoveEntry( &psi->_ListEntry );
        psi->_ListEntry.Flink = NULL;

        // 3. Change the timeout value

        psi->ChangeTimeInterval( msecNewTime);

        // 4. Recalc expiry time and reinsert into the list of work items.
        psi->CalcExpiresTime();
        psd->InsertIntoWorkItemList( psi);

        IF_DEBUG(SCHED)
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "ScheduleAdjustTime: "
                        "[%8p] ser=%d ctxt=%p fncbk=%p state=%d thrd=%d\n",
                        psi,
                        psi->_dwSerialNumber,
                        psi->_pContext,
                        psi->_pfnCallback,
                        psi->_siState,
                        psi->_dwCallbackThreadId
                        ));
        }

    }

    psd->UnlockItems();

    // 5. Indicate to scheduler threads that there is one new item on the list
    if (NULL != psi)
        DBG_REQUIRE( SetEvent( psd->m_hevtNotify ));

    return ( (NULL != psi) ? NO_ERROR : ERROR_INVALID_PARAMETER);
} // ScheduleAdjustTime()



/************************************************************
 *  Internal functions of Scheduler
 ************************************************************/



VOID
CSchedData::InsertIntoWorkItemList(SCHED_ITEM*  psi)
{
    SCHED_ITEM* psiList;
    CListEntry* ple;

    DBG_ASSERT( NULL != psi);
    DBG_ASSERT(psi->CheckSignature());
    DBG_ASSERT( (psi->_siState == SI_ACTIVE) ||
                (psi->_siState == SI_ACTIVE_PERIODIC) ||
                (psi->_siState == SI_CALLBACK_PERIODIC ) );

    // Assumed that the scheduler list is locked.
    DBG_ASSERT(m_lstItems.IsLocked());

    //
    //  Insert the list in order based on expires time
    //

    for ( ple =  m_lstItems.First();
          ple != m_lstItems.HeadNode();
          ple =  ple->Flink )
    {
        psiList = CONTAINING_RECORD( ple, SCHED_ITEM, _ListEntry );
        DBG_ASSERT(psiList->CheckSignature());

        if ( psiList->_msecExpires > psi->_msecExpires )
        {
            break;
        }
    }

    //
    // Insert the item psi in front of the item ple
    //  This should work in whether the list is empty or this is the last item
    //  on the circular list
    //

    psi->_ListEntry.Flink = ple;
    psi->_ListEntry.Blink = ple->Blink;

    ple->Blink->Flink  = &psi->_ListEntry;
    ple->Blink         = &psi->_ListEntry;

    return;
} // InsertIntoWorkItemList()


SCHED_ITEM*
CSchedData::FindSchedulerItem(DWORD dwCookie)
{
    CListEntry* ple;
    SCHED_ITEM* psi = NULL;

    // Should be called with the scheduler list locked.
    DBG_ASSERT(m_lstItems.IsLocked());

    for ( ple =  m_lstItems.First();
          ple != m_lstItems.HeadNode();
          ple = ple->Flink )
    {
        psi = CONTAINING_RECORD( ple, SCHED_ITEM, _ListEntry );
        DBG_ASSERT( psi->CheckSignature() );

        if ( dwCookie == psi->_dwSerialNumber )
        {

            // found the match - return
            return ( psi);
        }
    } // for

    return ( NULL);
} // FindSchedulerItem()



unsigned
__stdcall
SchedulerWorkerThread(
    void* pvParam
    )
/*++

Routine Description:

    ThreadProc for scheduler.

Arguments:

    Unused.

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    CThreadData* const ptd = (CThreadData*) pvParam;
    DBG_ASSERT( ptd != NULL );

    CSchedData*  const psd = ptd->m_psdOwner;
    DBG_ASSERT( psd != NULL );

    IF_DEBUG(SCHED)
    {
        DBGPRINTF(( DBG_CONTEXT, "SchedulerWorkerThread (%d) starting: "
                    "CThreadData=%p CSchedData=%p, %d\n",
                    ptd->m_nID,
                    ptd, psd, psd->m_nID));
    }
    
    int          cExecuted = 0;
    DWORD        cmsecWait = INFINITE;
    __int64      TickCount;
    SCHED_ITEM * psi, * psiExpired;
    CListEntry * ple;
    BOOL         fListLocked = FALSE;
    DWORD        dwWait;
    HRESULT      hr;
    HANDLE       ahEvt[2] = {psd->m_hevtNotify, ptd->m_hevtShutdown};

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (hr != S_OK && hr != S_FALSE)
    {
        DBG_ASSERT(FALSE);
        return FALSE;
    }

    while (!psd->m_fShutdown)
    {
        DBG_ASSERT(!fListLocked); // the list must be unlocked here

        while ( TRUE )
        {

            MSG msg;

            //
            // Need to do MsgWait instead of WaitForSingleObject
            // to process windows msgs.  We now have a window
            // because of COM.
            //

            dwWait = MsgWaitForMultipleObjects( 2,
                                             ahEvt,
                                             FALSE,     // wait for anything
                                             cmsecWait,
                                             QS_ALLINPUT );

            if (psd->m_fShutdown)
                goto exit;

            if ( (dwWait == WAIT_OBJECT_0) ||       // psd->m_hevtNotify
                 (dwWait == WAIT_OBJECT_0 + 1) ||   // ptd->m_hevtShutdown
                 (dwWait == WAIT_TIMEOUT) )
            {
                break;
            }

            while ( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ))
            {
                TranslateMessage( &msg );
                DispatchMessage( &msg );
            }
        }

        switch (dwWait)
        {
        default:
            DBGPRINTF(( DBG_CONTEXT,
                        "[Scheduler] Error %d waiting on SchedulerEvent\n",
                        GetLastError() ));
            //  Fall through

        case WAIT_OBJECT_0:
            //  Means a new item has been scheduled, reset the timeout, or
            //  we are shutting down

            psd->LockItems();
            fListLocked = TRUE;

            //  Get the timeout value for the first item in the list

            if (!psd->m_lstItems.IsEmpty())
            {
                psi = CONTAINING_RECORD( psd->m_lstItems.First(),
                                         SCHED_ITEM,
                                         _ListEntry );
                DBG_ASSERT(psi->CheckSignature());

                //  Make sure the front item hasn't already expired

                TickCount = GetCurrentTimeInMilliseconds();

                if (TickCount > psi->_msecExpires)
                {
                    //  Run scheduled items
                    break;
                }

                // the delay is guaranteed NOT to be > 1<<32
                // as per parameter to SCHED_ITEM constructor

                cmsecWait = (DWORD)(psi->_msecExpires - TickCount);
            }
            else
            {
                cmsecWait = INFINITE;
            }

            psd->UnlockItems();
            fListLocked = FALSE;

            // Wait for something else (back to sleep)
            continue;

        case WAIT_TIMEOUT:
            //  Run scheduled items
            break;
        }

        //  Run scheduled items

        while (!psd->m_fShutdown)
        {
            //  Lock the list if needed

            if (!fListLocked)
            {
                psd->LockItems();
                fListLocked = TRUE;
            }

            //  No timeout by default (if no items found)

            cmsecWait = INFINITE;

            if (psd->m_lstItems.IsEmpty())
                break;

            //  Find the first expired work item

            TickCount = GetCurrentTimeInMilliseconds();

            psiExpired = NULL;

            for ( ple  = psd->m_lstItems.First();
                  ple != psd->m_lstItems.HeadNode();
                  ple = ple->Flink
                )
            {
                psi = CONTAINING_RECORD(ple, SCHED_ITEM, _ListEntry);
                DBG_ASSERT(psi->CheckSignature());

                if ( ((psi->_siState == SI_ACTIVE) ||
                      (psi->_siState == SI_ACTIVE_PERIODIC)) )
                {

                    if (TickCount > psi->_msecExpires)
                    {
                        //  Found Expired Item
                        psiExpired = psi;
                    }
                    else
                    {
                        //  Since they are in sorted order, once we hit one
                        //  that's not expired, we don't need to look further
                        cmsecWait = (DWORD)(psi->_msecExpires - TickCount);
                    }
                    break;
                }
            }

            //  If no expired work items found, go back to sleep

            if (psiExpired == NULL)
            {
                break;
            }

            //  Take care of the found expired work item

            SCHED_ITEM_STATE st =
                sg_rgSchedNextState[SI_OP_CALLBACK][psiExpired->_siState];

            psiExpired->_siState = st;
            psiExpired->_dwCallbackThreadId = GetCurrentThreadId();

            DBG_ASSERT(st == SI_TO_BE_DELETED  ||  st == SI_CALLBACK_PERIODIC);

            //  Unlock the list while in the callback
            DBG_ASSERT(fListLocked);
            psd->UnlockItems();
            fListLocked = FALSE;

            //  While in PERIODIC callback the list is kept unlocked
            //  leaving the object exposed

            IF_DEBUG(SCHED)
            {
                DBGPRINTF((DBG_CONTEXT,
                           "SchedulerWorkerThread (%d): starting %scall: "
                           "ser=%d ctxt=%p fncbk=%p state=%d\n",
                           ptd->m_nID,
                           (st == SI_CALLBACK_PERIODIC) ? "periodic " : "",
                           psiExpired->_dwSerialNumber,
                           psiExpired->_pContext,
                           psiExpired->_pfnCallback,
                           psiExpired->_siState));
            }

            // Is this still a valid function? There have been problems
            // with scheduler clients (such as isatq.dll) getting unloaded,
            // without first calling RemoveWorkItem to clean up.
            if (IsBadCodePtr(reinterpret_cast<FARPROC>(psiExpired->_pfnCallback)))
            {
                DWORD dwErr = GetLastError();
                IF_DEBUG(SCHED)
                {
                    DBGPRINTF((DBG_CONTEXT,
                               "SchedulerWorkerThread (%d): "
                               "invalid callback function %p, error %d\n",
                               ptd->m_nID,
                               psiExpired->_pfnCallback, dwErr));
                }
                psiExpired->_siState = SI_TO_BE_DELETED;
                goto relock;
            }

            __try 
            {
                psiExpired->_pfnCallback(psiExpired->_pContext);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                DWORD dwErr = GetExceptionCode();

                IF_DEBUG(SCHED)
                {
                    DBGPRINTF((DBG_CONTEXT,
                               "SchedulerWorkerThread (%d): "
                               "exception %d in callback function %p\n",
                               ptd->m_nID,
                               dwErr, psiExpired->_pfnCallback));
                }
                psiExpired->_siState = SI_TO_BE_DELETED;
            }

            ++cExecuted;
            
            IF_DEBUG(SCHED)
            {
                DBGPRINTF((DBG_CONTEXT,
                           "SchedulerWorkerThread (%d): finished %scall: "
                           "ser=%d ctxt=%p fncbk=%p state=%d\n",
                           ptd->m_nID,
                           (st == SI_CALLBACK_PERIODIC) ? "periodic " : "",
                           psiExpired->_dwSerialNumber,
                           psiExpired->_pContext,
                           psiExpired->_pfnCallback,
                           psiExpired->_siState));
            }
            
relock:
            //  Relock the list
            DBG_ASSERT(!fListLocked);
            psd->LockItems();
            fListLocked = TRUE;

            psiExpired->_dwCallbackThreadId = 0;

            //  While in the callback the state can change
            if (psiExpired->_siState == SI_TO_BE_DELETED)
            {
                //  User requested delete

                //  Remove this item from the list
                CDoubleList::RemoveEntry( &psiExpired->_ListEntry );
                psiExpired->_ListEntry.Flink = NULL;

                //  While in callback RemoveWorkItem() could have attached
                //  an event to notify itself when callback is done
                if (psiExpired->_hCallbackEvent)
                {
                    //  Signal the event after item is gone from the list
                    SetEvent(psiExpired->_hCallbackEvent);
                    //  RemoveWorkItem() will remove the item
                }
                else
                {
                    //  Get rid of the item
                    psd->DeleteSchedItem(psiExpired);
                }
            }
            else
            {
                // no events attached
                DBG_ASSERT(psiExpired->_hCallbackEvent == NULL);

                // must still remain SI_CALLBACK_PERIODIC unless deleted
                DBG_ASSERT(psiExpired->_siState == SI_CALLBACK_PERIODIC);

                // NYI: For now remove from the list and reinsert it
                CDoubleList::RemoveEntry( &psiExpired->_ListEntry );
                psiExpired->_ListEntry.Flink = NULL;

                // recalc the expiry time and reinsert into the list
                psiExpired->_siState =
                    sg_rgSchedNextState[SI_OP_ADD_PERIODIC]
                                       [psiExpired->_siState];
                psiExpired->CalcExpiresTime();
                psd->InsertIntoWorkItemList(psiExpired);
            }

            //  Start looking in the list from the beginning in case
            //  new items have been added or other threads removed them

        } // while

        if (fListLocked)
        {
            psd->UnlockItems();
            fListLocked = FALSE;
        }

    } // while

exit:
    CoUninitialize();
    
    // Destroy the thread object
    ptd->Release();

    return cExecuted;
} // SchedulerWorkerThread()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\rpcutil.c ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      rpcutil.c

   Abstract:

      This module defines functions that may help to replace the rpc util
        functions from rpcutil.lib

   Author:

       Murali R. Krishnan    ( MuraliK )     15-Sept-1995

   Environment:
       Win32 User Mode

   Project:

       Common Code for Internet Services

   Functions Exported:

        MIDL_user_allocate()
        MIDL_user_free()
        RpcBindHandleForServer()
        RpcBindHandleFree()

   Revision History:

        Murali R. Krishnan (MuraliK) 21-Dec-1995  Support TcpIp binding & free.
        Murali R. Krishnan (MuraliK) 20-Feb-1996  Support Lpc binding & free.

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>
# include <rpc.h>

# include "apiutil.h"

#ifndef _NO_TRACING_

#include <pudebug.h>

#else

# if DBG

# include <stdio.h>
# include <stdlib.h>

# define DBGPRINTF(s)       { CHAR rgchBuff[1024]; \
                              sprintf s ; \
                              OutputDebugStringA( rgchBuff); \
                            }
# define DBG_CONTEXT        ( rgchBuff)


# else // DBG


# define DBGPRINTF(s)     /* nothing */
# define DBG_CONTEXT      /* nothing */

# endif // DBG

# endif // _NO_TRACING_

#define ISRPC_CLIENT_OVER_TCPIP          0x00000001
#define ISRPC_CLIENT_OVER_NP             0x00000002
#define ISRPC_CLIENT_OVER_SPX            0x00000004
#define ISRPC_CLIENT_OVER_LPC            0x00000008

// # define MAX_COMPUTERNAME_LENGTH    (255)


/************************************************************
 *    Functions
 ************************************************************/


PVOID
MIDL_user_allocate(IN size_t size)
/*++

Routine Description:

    MIDL memory allocation.

Arguments:

    size : Memory size requested.

Return Value:

    Pointer to the allocated memory block.

--*/
{
    PVOID pvBlob;

    pvBlob = LocalAlloc( LPTR, size);

    return( pvBlob );

} // MIDL_user_allocate()




VOID
MIDL_user_free(IN PVOID pvBlob)
/*++

Routine Description:

    MIDL memory free .

Arguments:

    pvBlob : Pointer to a memory block that is freed.


Return Value:

    None.

--*/
{
    LocalFree( pvBlob);

    return;
}  // MIDL_user_free()




RPC_STATUS
RpcBindHandleOverNamedPipe( OUT handle_t * pBindingHandle,
                           IN LPWSTR      pwszServerName,
                           IN LPWSTR      pwszEndpoint,
                           IN LPWSTR      pwszOptions
                          )
/*++
  This function uses the parameters supplied and generates a named pipe
   binding handle for RPC.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszEndpoint     pointer to string containing the Named Pipe Endpoint
   pwszOptions      pointer to string containing any additional options for
                       binding.


  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPWSTR     pwszBinding = NULL;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingComposeW(0,            // ObjUuid
                                         L"ncacn_np",  // prot seq: named pipe
                                         pwszServerName, // NetworkAddr
                                         pwszEndpoint, // Endpoint
                                         pwszOptions,  // Options
                                         &pwszBinding);    // StringBinding

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBindingW(pwszBinding,
                                                 pBindingHandle );
    }


    //
    // Cleanup and return back.
    //

    if ( pwszBinding != NULL) {
        RpcStringFreeW(&pwszBinding);
    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            RpcBindingFree(pBindingHandle);
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverNamedPipe()

RPC_STATUS
RpcBindHandleOverLpc( OUT handle_t * pBindingHandle,
                      IN LPWSTR      pwszEndpoint,
                      IN LPWSTR      pwszOptions
                     )
/*++
  This function uses the parameters supplied and generates a lpc
   binding handle for RPC.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszEndpoint     pointer to string containing the lpc Endpoint
   pwszOptions      pointer to string containing any additional options for
                       binding.


  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPWSTR     pwszBinding = NULL;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingComposeW(0,            // ObjUuid
                                         L"ncalrpc",   // prot seq: lpc
                                         NULL,         // NetworkAddr
                                         pwszEndpoint, // Endpoint
                                         pwszOptions,  // Options
                                         &pwszBinding);    // StringBinding

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBindingW(pwszBinding,
                                                 pBindingHandle );
    }


    //
    // Cleanup and return back.
    //

    if ( pwszBinding != NULL) {
        RpcStringFreeW(&pwszBinding);
    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            RpcBindingFree(pBindingHandle);
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverLpc()




#ifndef CHICAGO

//
// If changes are made to the NT version, check out the windows 95
// version located right after this routine and see if the change
// needs to be propagated there too.
//

RPC_STATUS
RpcBindHandleOverTcpIp( OUT handle_t * pBindingHandle,
                       IN LPWSTR       pwszServerName,
                       IN LPWSTR       pwszInterfaceName
                       )
/*++

    NT Version

  This function uses the parameters supplied and generates a dynamic end point
     binding handle for RPC over TCP/IP.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszInterfaceName pointer to string containing the interface name

  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPWSTR     pwszBinding = NULL;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }
    else
        return RPC_S_INVALID_BINDING;

    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingComposeW(0,               // ObjUuid
                                         L"ncacn_ip_tcp", // tcpip seq
                                         pwszServerName,  // NetworkAddr
                                         NULL,            // Endpoint
                                         L"",             // Options
                                         &pwszBinding);   // StringBinding

    DBGPRINTF( (DBG_CONTEXT, "\nRpcStringBindingComposeW(%S, %S) return %S."
                " Error = %ld\n",
                L"ncacn_ip_tcp",
                pwszServerName,
                pwszBinding,
                rpcStatus)
              );

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBindingW(pwszBinding,
                                                 pBindingHandle );

        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingFromStringBindingW(%S) return %d."
                    "Binding=%p\n",
                    pwszBinding,
                    rpcStatus,
                    *pBindingHandle)
                  );
    }

    if ( rpcStatus == RPC_S_OK) {

        //
        // set up the security information
        //

        rpcStatus =
          RpcBindingSetAuthInfoW(*pBindingHandle,
                                 pwszInterfaceName,   // pszPrincipalName
                                 RPC_C_AUTHN_LEVEL_CONNECT,
                                 RPC_C_AUTHN_WINNT,
                                 NULL,                // AuthnIdentity
                                 0                    // AuthzSvc
                                 );
        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingSetAuthInfo(%S(Interface=%S), %p)"
                    " return %d.\n",
                    pwszBinding,
                    pwszInterfaceName,
                    *pBindingHandle,
                    rpcStatus
                    )
                  );

    }

    //
    // Cleanup and return back.
    //

    if ( pwszBinding != NULL) {

        DWORD rpcStatus1 = RpcStringFreeW(&pwszBinding);
        DBGPRINTF( (DBG_CONTEXT, "RpcStringFreeW() returns %d.",
                    rpcStatus1)
                  );

    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            DWORD rpcStatus1 = RpcBindingFree(pBindingHandle);
            DBGPRINTF( (DBG_CONTEXT, "RpcBindingFree() returns %d.\n",
                        rpcStatus1)
                      );
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverTcpIp()

#else // CHICAGO



RPC_STATUS
RpcBindHandleOverTcpIp( OUT handle_t * pBindingHandle,
                       IN LPWSTR       pwszServerName,
                       IN LPWSTR       pwszInterfaceName
                       )
/*++

    Windows 95 version

  This function uses the parameters supplied and generates a dynamic end point
     binding handle for RPC over TCP/IP.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszInterfaceName pointer to string containing the interface name

  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPSTR     pszBindingA = NULL;
    CHAR    szServerA[MAX_PATH];
    CHAR    szInterfaceA[MAX_PATH];
    int        cch;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }
    else
        return RPC_S_INVALID_BINDING;

    *szServerA = '0';

    if (pwszServerName)
    cch = WideCharToMultiByte(CP_ACP,
                              0,
                              pwszServerName,
                              -1,
                              szServerA,
                              sizeof(szServerA)/sizeof(CHAR),
                              NULL,NULL
                              );

    *szInterfaceA = '0';

    if(pwszInterfaceName)
    cch = WideCharToMultiByte(CP_ACP,
                              0,
                              pwszInterfaceName,
                              -1,
                              szInterfaceA,
                              sizeof(szInterfaceA)/sizeof(CHAR),
                              NULL,NULL
                              );


    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingCompose(0,            // ObjUuid
                                         "ncacn_ip_tcp", // tcpip seq
                                         szServerA, // NetworkAddr
                                         NULL, // Endpoint
                                         NULL, //L"",  // Options
                                         &pszBindingA);    // StringBinding

    DBGPRINTF( (DBG_CONTEXT, "\nRpcStringBindingCompose(%s, %s) return %s."
                " Error = %ld\n",
                "ncacn_ip_tcp",
                szServerA,
                pszBindingA,
                rpcStatus)
              );

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBinding(pszBindingA,
                                                 pBindingHandle );

        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingFromStringBinding(%s) return %d."
                    "Binding=%p\n",
                    pszBindingA,
                    rpcStatus,
                    *pBindingHandle)
                  );
    }

    if ( rpcStatus == RPC_S_OK) {

        //
        // set up the security information
        //

        rpcStatus =
          RpcBindingSetAuthInfo(*pBindingHandle,
                                 szInterfaceA,   // pszPrincipalName
                                 RPC_C_AUTHN_LEVEL_CONNECT,
                                 RPC_C_AUTHN_WINNT,
                                 NULL,  // AuthnIdentity
                                 0      // AuthzSvc
                                 );
        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingSetAuthInfo(%s(Interface=%s), %p)"
                    " return %d.\n",
                    pszBindingA,
                    szInterfaceA,
                    *pBindingHandle,
                    rpcStatus
                    )
                  );

    }

    //
    // Cleanup and return back.
    //

    if ( pszBindingA != NULL) {

        DWORD rpcStatus1 = RpcStringFree(&pszBindingA);
        DBGPRINTF( (DBG_CONTEXT, "RpcStringFreeW() returns %d.",
                    rpcStatus1)
                  );

    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            DWORD rpcStatus1 = RpcBindingFree(pBindingHandle);
            DBGPRINTF( (DBG_CONTEXT, "RpcBindingFree() returns %d.\n",
                        rpcStatus1)
                      );
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverTcpIp()
#endif



#ifndef CHICAGO
DWORD
RpcuFindProtocolToUse( IN LPCWSTR pwszServerName)
/*++
  Given the server name this funciton determines the protocol
  to use for RPC binding.

  The transport used is determined dynamically based on following rules.

  If server name is NULL or 127.0.0.1 or same as local computer name
      then use the LPC.

  If server name starts with a leading "\\" (double slash),
      then attempt RPC binding over NamedPipe.

  If server name does not start with leading "\\",
      then attempt RPC binding over TCPIP.

  If TCPIP binding fails, then this function tries binding over NamedPipe.


  Argument:
    pwszServerName - pointer to string containing the name of the server


  Returns:
    DWORD containing the type of protocol to use.

--*/
{
    static WCHAR g_wchLocalMachineName[ MAX_COMPUTERNAME_LENGTH + 1];
    BOOL   fLeadingSlashes;
    DWORD  dwBindProtocol = ISRPC_CLIENT_OVER_NP;
    BOOL   fLocalMachine;

    if ( pwszServerName == NULL ||
         _wcsicmp( L"127.0.0.1", pwszServerName) == 0) {


        return (ISRPC_CLIENT_OVER_LPC);
    }

    if ( g_wchLocalMachineName[0] == L'\0') {

        DWORD cchComputerNameLen = MAX_COMPUTERNAME_LENGTH+1;

        //
        // Obtain the local computer name
        //

        if (!GetComputerNameW( g_wchLocalMachineName,
                              &cchComputerNameLen)
            ) {

            *g_wchLocalMachineName = L'\0';
        }
    }

    fLeadingSlashes = ((*pwszServerName == L'\\') &&
                       (*(pwszServerName+1) == L'\\')
                       );


    //
    // Check to see if machine name matches local computer name
    //  if so, use LPC
    //

    fLocalMachine = !_wcsicmp( g_wchLocalMachineName,
                              ((fLeadingSlashes) ?
                               (pwszServerName + 2) : pwszServerName)
                              );

    if ( fLocalMachine) {

        return (ISRPC_CLIENT_OVER_LPC);
    }

    if ( !fLeadingSlashes) {

        DWORD  nDots;
        LPCWSTR pszName;

        //
        // Check if the name has dotted decimal name.
        // If so then suggest TCP binding.
        //

        for( nDots = 0, pszName = pwszServerName;
            ((pszName = wcschr( pszName, L'.' )) != NULL);
            nDots++, pszName++)
          ;

        if ( nDots == 3) {

            //
            // if the string has 3 DOTs exactly then this string must represent
            // an IpAddress.
            //

            return(ISRPC_CLIENT_OVER_TCPIP);
        }
    }


    return ( ISRPC_CLIENT_OVER_NP);
} // RpcuFindProtocolToUse()
#endif



RPC_STATUS
RpcBindHandleForServer( OUT handle_t * pBindingHandle,
                       IN LPWSTR      pwszServerName,
                       IN LPWSTR      pwszInterfaceName,
                       IN LPWSTR      pwszOptions
                       )
/*++
  This function uses the parameters supplied and generates a binding
    handle for RPC.


  It is assumed that binding over named pipe uses static end point
      with the interface name and options as provided.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszInterfaceName pointer to string containing the interface name
   pwszOptions      pointer to string containing any additional options for
                       binding.

  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus = RPC_S_SERVER_UNAVAILABLE;
    LPWSTR     pwszBinding = NULL;
    DWORD      dwBindProtocol = 0;


    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }
    else
        return RPC_S_INVALID_BINDING;

#ifndef CHICAGO
    dwBindProtocol = RpcuFindProtocolToUse( pwszServerName);
#else
    dwBindProtocol = ISRPC_CLIENT_OVER_TCPIP;
#endif

    switch ( dwBindProtocol) {

      case ISRPC_CLIENT_OVER_LPC:
        {

            WCHAR  rgchLpc[1024];

            //
            // generate a LPC end point name from the interface name.
            //  the End point =   <InterfaceName>_LPC
            //

            if ( lstrlenW( pwszInterfaceName) >=
                ( sizeof(rgchLpc)/sizeof(WCHAR) - 6)) {

                SetLastError( ERROR_INVALID_PARAMETER);
                return ( ERROR_INVALID_PARAMETER);
            }

            lstrcpyW( rgchLpc, pwszInterfaceName);
            lstrcatW( rgchLpc, L"_LPC");

            //
            // Attempt binding over static LPC.
            //

            rpcStatus = RpcBindHandleOverLpc( pBindingHandle,
                                             rgchLpc,
                                             pwszOptions
                                             );

            DBGPRINTF(( DBG_CONTEXT,
                       " RpcBindingOverLpc(%S) returns %d."
                       " Handle = %p\n",
                       pwszServerName, rpcStatus, *pBindingHandle));

            break;
        }

      case ISRPC_CLIENT_OVER_TCPIP:

// # ifdef RPC_BIND_OVER_TCP

        //
        // Attempt binding over TCPIP using Dynamic Endpoint.
        //

        rpcStatus = RpcBindHandleOverTcpIp( pBindingHandle,
                                           pwszServerName,
                                           pwszInterfaceName);

        DBGPRINTF(( DBG_CONTEXT,
                   " RpcBindingOverTcpIp(%S) returns %d. Handle = %p\n",
                   pwszServerName, rpcStatus, *pBindingHandle));

        if ( rpcStatus == RPC_S_OK) {

            break;  // done with RPC binding over TCP
        }

        // Fall Through

// # endif // RPC_BIND_OVER_TCP

      case ISRPC_CLIENT_OVER_NP:
        {
            WCHAR  rgchNp[1024];

            //
            // generate a NamedPipe end point name from the interface name.
            //  the End point =   \PIPE\<InterfaceName>
            //

            lstrcpyW( rgchNp, L"\\PIPE\\");
            if ( lstrlenW( pwszInterfaceName) >=
                ( sizeof(rgchNp)/sizeof(WCHAR) - 10)) {

                SetLastError( ERROR_INVALID_PARAMETER);
                return ( ERROR_INVALID_PARAMETER);
            }

            lstrcatW( rgchNp, pwszInterfaceName);

            //
            // Attempt binding over static NamedPipe.
            //

            rpcStatus = RpcBindHandleOverNamedPipe( pBindingHandle,
                                                   pwszServerName,
                                                   rgchNp,
                                                   pwszOptions
                                                   );

            DBGPRINTF(( DBG_CONTEXT,
                       " RpcBindingOverNamedPipe(%S) returns %d."
                       " Handle = %p\n",
                       pwszServerName, rpcStatus, *pBindingHandle));
            break;
        }

      default:
        break;

    } // switch()

    return ( rpcStatus);

} // RpcBindHandleForServer()





RPC_STATUS
RpcBindHandleFree(IN OUT handle_t * pBindingHandle)
/*++

  Description:

    This function frees up the binding handle allocated using
      RpcBindHandleForServer(). It uses RPC Binding Free routing to do this.
    This function acts just as a thunk so that the alloc/free of RPC contexts
      are consolidated within this module.

  Arguments:
    pBindingHandle  pointer to RPC binding handle that needs to be freed.


  Returns:
    RPC_STATUS - containig the RPC status. RPC_S_OK for success.

--*/
{

    return ( RpcBindingFree( pBindingHandle));

} // RpcBindHandleFree()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\resource.cxx ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    Resource.c

Abstract:

    This module implements the executive functions to acquire and release
    a shared resource.

Author:

    Mark Lucovsky       (markl)     04-Aug-1989

Environment:

    These routines are statically linked in the caller's executable and
    are callable in only from user mode.  They make use of Nt system
    services.

Revision History:

--*/

#include "precomp.hxx"

#include "dbgutil.h"
#include <tsres.hxx>
#include <isplat.h>

//
//  The semaphore wait time before retrying the wait
//

#define INET_RES_TIMEOUT            (2 * 60 * 1000)
#define TIMEOUT_BREAK_COUNT         15


#if DBG
LONG g_InetResourcesCreated = 0;
LONG g_InetResourcesDeleted = 0;
#endif



BOOL
InetInitializeResource(
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine initializes the input resource variable

Arguments:

    Resource - Supplies the resource variable being initialized

Return Value:

    None

--*/

{

    PLATFORM_TYPE platformType;

    //
    //  Initialize the lock fields, the count indicates how many are waiting
    //  to enter or are in the critical section, LockSemaphore is the object
    //  to wait on when entering the critical section.  SpinLock is used
    //  for the add interlock instruction.
    //

    INITIALIZE_CRITICAL_SECTION( &Resource->CriticalSection );

    //
    // The critical section's DebugInfo field is only valid under NT.
    // If we're running under NT, then set the critical section type
    // to mark this as a resource. This is useful when debugging resource
    // leaks.
    //

    platformType = IISGetPlatformType();

    if( platformType == PtNtServer ||
        platformType == PtNtWorkstation ) {
        Resource->CriticalSection.DebugInfo->Type = RTL_RESOURCE_TYPE;
    }

    Resource->DebugInfo = NULL;

    //
    //  Initialize flags so there is a default value.
    //  (Some apps may set RTL_RESOURCE_FLAGS_LONG_TERM to affect timeouts.)
    //

    Resource->Flags = 0;

    //
    //  Initialize the shared and exclusive waiting counters and semaphore.
    //  The counters indicate how many are waiting for access to the resource
    //  and the semaphores are used to wait on the resource.  Note that
    //  the semaphores can also indicate the number waiting for a resource
    //  however there is a race condition in the alogrithm on the acquire
    //  side if count if not updated before the critical section is exited.
    //

    Resource->SharedSemaphore = IIS_CREATE_SEMAPHORE(
                                    "RTL_RESOURCE::SharedSemaphore",
                                    Resource,
                                    0,
                                    MAXLONG
                                    );

    if ( !Resource->SharedSemaphore ) {
        return FALSE;
    }

    Resource->NumberOfWaitingShared = 0;

    Resource->ExclusiveSemaphore = IIS_CREATE_SEMAPHORE(
                                       "RTL_RESOURCE::ExclusiveSemaphore",
                                       Resource,
                                       0,
                                       MAXLONG
                                       );

    if ( !Resource->ExclusiveSemaphore ){
        CloseHandle( Resource->SharedSemaphore );

        return FALSE;
    }

    Resource->NumberOfWaitingExclusive = 0;

    //
    //  Initialize the current state of the resource
    //

    Resource->NumberOfActive = 0;

    Resource->ExclusiveOwnerThread = NULL;

#if DBG
    InterlockedIncrement( &g_InetResourcesCreated );
#endif

    return TRUE;
}


BOOL
InetAcquireResourceShared(
    IN PRTL_RESOURCE Resource,
    IN BOOL          Wait
    )

/*++

Routine Description:

    The routine acquires the resource for shared access.  Upon return from
    the procedure the resource is acquired for shared access.

Arguments:

    Resource - Supplies the resource to acquire

    Wait - Indicates if the call is allowed to wait for the resource
        to become available for must return immediately

Return Value:

    BOOL - TRUE if the resource is acquired and FALSE otherwise

--*/

{
    DWORD          ret;
    ULONG          TimeoutCount = 0;
    DWORD          TimeoutTime  = INET_RES_TIMEOUT;
    //
    //  Enter the critical section
    //

    EnterCriticalSection(&Resource->CriticalSection);

    //
    //  If it is not currently acquired for exclusive use then we can acquire
    //  the resource for shared access.  Note that this can potentially
    //  starve an exclusive waiter however, this is necessary given the
    //  ability to recursively acquire the resource shared.  Otherwise we
    //  might/will reach a deadlock situation where a thread tries to acquire
    //  the resource recusively shared but is blocked by an exclusive waiter.
    //
    //  The test to reanable not starving an exclusive waiter is:
    //
    //      if ((Resource->NumberOfWaitingExclusive == 0) &&
    //          (Resource->NumberOfActive >= 0)) {
    //

    if (Resource->NumberOfActive >= 0) {

        //
        //  The resource is ours, so indicate that we have it and
        //  exit the critical section
        //

        Resource->NumberOfActive += 1;

        LeaveCriticalSection(&Resource->CriticalSection);

    //
    //  Otherwise check to see if this thread is the one currently holding
    //  exclusive access to the resource.  And if it is then we change
    //  this shared request to an exclusive recusive request and grant
    //  access to the resource.
    //

    } else if (Resource->ExclusiveOwnerThread == NtCurrentTeb()->ClientId.UniqueThread) {

        //
        //  The resource is ours (recusively) so indicate that we have it
        //  and exit the critial section
        //

        Resource->NumberOfActive -= 1;

        LeaveCriticalSection(&Resource->CriticalSection);

    //
    //  Otherwise we'll have to wait for access.
    //

    } else {

        //
        //  Check if we are allowed to wait or must return immedately, and
        //  indicate that we didn't acquire the resource
        //

        if (!Wait) {

            LeaveCriticalSection(&Resource->CriticalSection);

            return FALSE;

        }

        //
        //  Otherwise we need to wait to acquire the resource.
        //  To wait we will increment the number of waiting shared,
        //  release the lock, and wait on the shared semaphore
        //

        Resource->NumberOfWaitingShared += 1;

        LeaveCriticalSection(&Resource->CriticalSection);

rewait:
        if ( Resource->Flags & RTL_RESOURCE_FLAG_LONG_TERM ) {
            TimeoutTime = INFINITE;
        }
        ret = WaitForSingleObject(
                    Resource->SharedSemaphore,
                    TimeoutTime
                    );

        if ( ret == WAIT_TIMEOUT ) {
            IF_DEBUG(RESOURCE) {
                DBGPRINTF(( DBG_CONTEXT,
                            "%08p::[InetAcquireResourceShared] Sem timeout\n",
                            Resource));
            }

            TimeoutCount++;
            if ( TimeoutCount == TIMEOUT_BREAK_COUNT ) {
#if DBG && TIMEOUT_BREAK_COUNT > 0
                DebugBreak();
#endif
            }
            IF_DEBUG(RESOURCE) {

                DBGPRINTF(( DBG_CONTEXT,
                            "%08p::[InetAcquireResourceShared] Re-Waiting\n",
                            Resource));
            }

            goto rewait;
        } else if ( ret != WAIT_OBJECT_0 ) {
            IF_DEBUG(RESOURCE) {
                DBGPRINTF(( DBG_CONTEXT,
                            "%08p::[InetAcquireResourceShared] "
                            "WaitForSingleObject Failed\n",
                            Resource));
            }

        }
    }

    //
    //  Now the resource is ours, for shared access
    //

    return TRUE;

}


BOOL
InetAcquireResourceExclusive(
    IN PRTL_RESOURCE Resource,
    IN BOOL Wait
    )

/*++

Routine Description:

    The routine acquires the resource for exclusive access.  Upon return from
    the procedure the resource is acquired for exclusive access.

Arguments:

    Resource - Supplies the resource to acquire

    Wait - Indicates if the call is allowed to wait for the resource
        to become available for must return immediately

Return Value:

    BOOL - TRUE if the resource is acquired and FALSE otherwise

--*/

{
    ULONG TimeoutCount = 0;
    DWORD TimeoutTime  = INET_RES_TIMEOUT;
    DWORD ret;

    //
    //  Loop until the resource is ours or exit if we cannot wait.
    //

    while (TRUE) {

        //
        //  Enter the critical section
        //

        EnterCriticalSection(&Resource->CriticalSection);

        //
        //  If there are no shared users and it is not currently acquired for
        //  exclusive use then we can acquire the resource for exclusive
        //  access.  We also can acquire it if the resource indicates exclusive
        //  access but there isn't currently an owner.
        //

        if ((Resource->NumberOfActive == 0)

                ||

            ((Resource->NumberOfActive == -1) &&
             (Resource->ExclusiveOwnerThread == NULL))) {

            //
            //  The resource is ours, so indicate that we have it and
            //  exit the critical section
            //

            Resource->NumberOfActive = -1;

            Resource->ExclusiveOwnerThread = NtCurrentTeb()->ClientId.UniqueThread;

            LeaveCriticalSection(&Resource->CriticalSection);

            return TRUE;

        }

        //
        //  Otherwise check to see if we already have exclusive access to the
        //  resource and can simply recusively acquire it again.
        //

        if (Resource->ExclusiveOwnerThread == NtCurrentTeb()->ClientId.UniqueThread) {

            //
            //  The resource is ours (recusively) so indicate that we have it
            //  and exit the critial section
            //

            Resource->NumberOfActive -= 1;

            LeaveCriticalSection(&Resource->CriticalSection);

            return TRUE;

        }

        //
        //  Check if we are allowed to wait or must return immedately, and
        //  indicate that we didn't acquire the resource
        //

        if (!Wait) {

            LeaveCriticalSection(&Resource->CriticalSection);

            return FALSE;

        }

        //
        //  Otherwise we need to wait to acquire the resource.
        //  To wait we will increment the number of waiting exclusive,
        //  release the lock, and wait on the exclusive semaphore
        //

        Resource->NumberOfWaitingExclusive += 1;

        LeaveCriticalSection(&Resource->CriticalSection);

rewait:
        if ( Resource->Flags & RTL_RESOURCE_FLAG_LONG_TERM ) {
            TimeoutTime = INFINITE;
        }
        ret = WaitForSingleObject(
                    Resource->ExclusiveSemaphore,
                    TimeoutTime
                    );

        if ( ret == WAIT_TIMEOUT ) {
            IF_DEBUG(RESOURCE) {
                DBGPRINTF(( DBG_CONTEXT,
                            "%08p::[InetAcquireResourceExclusive] "
                            "Sem Timeout\n",
                            Resource));
            }

            TimeoutCount++;
            if ( TimeoutCount == TIMEOUT_BREAK_COUNT ) {
#if DBG && TIMEOUT_BREAK_COUNT > 0
                DebugBreak();
#endif
            }
            IF_DEBUG(RESOURCE) {
                DBGPRINTF(( DBG_CONTEXT,
                            "%08p::[InetAcquireResourceExclusive] "
                            "Re-Waiting\n",
                            Resource));
            }
            goto rewait;
        } else if ( ret != WAIT_OBJECT_0 ) {
            IF_DEBUG(RESOURCE) {
                DBGPRINTF(( DBG_CONTEXT,
                            "%08p::[InetAcquireResourceExclusive] "
                            "WaitForSingleObject Failed\n",
                            Resource));
            }
        }
    }

    return TRUE;
}


BOOL
InetReleaseResource(
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine release the input resource.  The resource can have been
    acquired for either shared or exclusive access.

Arguments:

    Resource - Supplies the resource to release

Return Value:

    None.

--*/

{
    LONG PreviousCount;
    BOOL fResult = FALSE;

    //
    //  Enter the critical section
    //

    EnterCriticalSection(&Resource->CriticalSection);

    //
    //  Test if the resource is acquired for shared or exclusive access
    //

    if (Resource->NumberOfActive > 0) {

        //
        //  Releasing shared access to the resource, so decrement
        //  the number of shared users
        //

        Resource->NumberOfActive -= 1;

        //
        //  If the resource is now available and there is a waiting
        //  exclusive user then give the resource to the waiting thread
        //

        if ((Resource->NumberOfActive == 0) &&
            (Resource->NumberOfWaitingExclusive > 0)) {

            //
            //  Set the resource state to exclusive (but not owned),
            //  decrement the number of waiting exclusive, and release
            //  one exclusive waiter
            //

            Resource->NumberOfActive = -1;
            Resource->ExclusiveOwnerThread = NULL;

            Resource->NumberOfWaitingExclusive -= 1;

            if ( !ReleaseSemaphore(
                         Resource->ExclusiveSemaphore,
                         1,
                         &PreviousCount
                         )) {
                goto cleanup;
            }
        }

    } else if (Resource->NumberOfActive < 0) {

        //
        //  Releasing exclusive access to the resource, so increment the
        //  number of active by one.  And continue testing only
        //  if the resource is now available.
        //

        Resource->NumberOfActive += 1;

        if (Resource->NumberOfActive == 0) {

            //
            //  The resource is now available.  Remove ourselves as the
            //  owner thread
            //

            Resource->ExclusiveOwnerThread = NULL;

            //
            //  If there is another waiting exclusive then give the resource
            //  to it.
            //

            if (Resource->NumberOfWaitingExclusive > 0) {

                //
                //  Set the resource to exclusive, and its owner undefined.
                //  Decrement the number of waiting exclusive and release one
                //  exclusive waiter
                //

                Resource->NumberOfActive = -1;
                Resource->NumberOfWaitingExclusive -= 1;

                if ( !ReleaseSemaphore(
                             Resource->ExclusiveSemaphore,
                             1,
                             &PreviousCount
                             )) {
                    goto cleanup;
                }

            //
            //  Check to see if there are waiting shared, who should now get
            //  the resource
            //

            } else if (Resource->NumberOfWaitingShared > 0) {

                //
                //  Set the new state to indicate that all of the shared
                //  requesters have access and there are no more waiting
                //  shared requesters, and then release all of the shared
                //  requsters
                //

                Resource->NumberOfActive = Resource->NumberOfWaitingShared;

                Resource->NumberOfWaitingShared = 0;

                if ( !ReleaseSemaphore(
                             Resource->SharedSemaphore,
                             Resource->NumberOfActive,
                             &PreviousCount
                             )) {
                    goto cleanup;
                }
            }
        }

#if DBG
    } else {

        //
        //  The resource isn't current acquired, there is nothing to release
        //  so tell the user the mistake
        //


        DBGPRINTF(( DBG_CONTEXT,
                    "%08p::[InetReleaseResource] "
                    "Resource released too many times!\n",
                    Resource));
        DebugBreak();
#endif
    }

    //
    // If we reached here, we successfully released the resource
    //

    fResult = TRUE;

  cleanup:
    //
    //  Exit the critical section, and return to the caller
    //

    LeaveCriticalSection(&Resource->CriticalSection);

    return fResult;
}


BOOL
InetConvertSharedToExclusive(
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine converts a resource acquired for shared access into
    one acquired for exclusive access.  Upon return from the procedure
    the resource is acquired for exclusive access

Arguments:

    Resource - Supplies the resource to acquire for shared access, it
        must already be acquired for shared access

Return Value:

    None

--*/

{
    DWORD ret;
    DWORD TimeoutTime  = INET_RES_TIMEOUT;
    ULONG TimeoutCount = 0;

    //
    //  Enter the critical section
    //

    EnterCriticalSection(&Resource->CriticalSection);

    //
    //  If there is only one shared user (it's us) and we can acquire the
    //  resource for exclusive access.
    //

    if (Resource->NumberOfActive == 1) {

        //
        //  The resource is ours, so indicate that we have it and
        //  exit the critical section, and return
        //

        Resource->NumberOfActive = -1;

        Resource->ExclusiveOwnerThread = NtCurrentTeb()->ClientId.UniqueThread;

        LeaveCriticalSection(&Resource->CriticalSection);

        return TRUE;
    }

    //
    //  If the resource is currently acquired exclusive and it's us then
    //  we already have exclusive access
    //

    if ((Resource->NumberOfActive < 0) &&
        (Resource->ExclusiveOwnerThread == NtCurrentTeb()->ClientId.UniqueThread)) {

        //
        //  We already have exclusive access to the resource so we'll just
        //  exit the critical section and return
        //

        LeaveCriticalSection(&Resource->CriticalSection);

        return TRUE;
    }

    //
    //  If the resource is acquired by more than one shared then we need
    //  to wait to get exclusive access to the resource
    //

    if (Resource->NumberOfActive > 1) {

        //
        //  To wait we will decrement the fact that we have the resource for
        //  shared, and then loop waiting on the exclusive lock, and then
        //  testing to see if we can get exclusive access to the resource
        //

        Resource->NumberOfActive -= 1;

        while (TRUE) {

            //
            //  Increment the number of waiting exclusive, exit and critical
            //  section and wait on the exclusive semaphore
            //

            Resource->NumberOfWaitingExclusive += 1;

            LeaveCriticalSection(&Resource->CriticalSection);
rewait:
        if ( Resource->Flags & RTL_RESOURCE_FLAG_LONG_TERM ) {
            TimeoutTime = INFINITE;
        }
        ret = WaitForSingleObject(
                    Resource->ExclusiveSemaphore,
                    TimeoutTime
                    );

        if ( ret == WAIT_TIMEOUT ) {
            IF_DEBUG(RESOURCE) {
                DBGPRINTF(( DBG_CONTEXT,
                            "%08p::[InetConvertSharedToExclusive] Sem timeout\n",
                            Resource));
            }

            TimeoutCount++;
            if ( TimeoutCount == TIMEOUT_BREAK_COUNT ) {
#if DBG && TIMEOUT_BREAK_COUNT > 0
                DebugBreak();
#endif
            }
            IF_DEBUG(RESOURCE) {
                DBGPRINTF(( DBG_CONTEXT,
                            "%08p::[InetConvertSharedToExclusive] Re-Waiting\n",
                            Resource));
            }
            goto rewait;
        } else if ( ret != WAIT_OBJECT_0 ) {
            IF_DEBUG(RESOURCE) {
                DBGPRINTF(( DBG_CONTEXT,
                            "%08p::[InetConvertSharedToExclusive] "
                            "WaitForSingleObject Failed\n",
                            Resource));
            }

            return FALSE;
        }

            //
            //  Enter the critical section
            //

            EnterCriticalSection(&Resource->CriticalSection);

            //
            //  If there are no shared users and it is not currently acquired
            //  for exclusive use then we can acquire the resource for
            //  exclusive access.  We can also acquire it if the resource
            //  indicates exclusive access but there isn't currently an owner
            //

            if ((Resource->NumberOfActive == 0)

                    ||

                ((Resource->NumberOfActive == -1) &&
                 (Resource->ExclusiveOwnerThread == NULL))) {

                //
                //  The resource is ours, so indicate that we have it and
                //  exit the critical section and return.
                //

                Resource->NumberOfActive = -1;

                Resource->ExclusiveOwnerThread = NtCurrentTeb()->ClientId.UniqueThread;

                LeaveCriticalSection(&Resource->CriticalSection);

                return TRUE;
            }

            //
            //  Otherwise check to see if we already have exclusive access to
            //  the resource and can simply recusively acquire it again.
            //

            if (Resource->ExclusiveOwnerThread == NtCurrentTeb()->ClientId.UniqueThread) {

                //
                //  The resource is ours (recusively) so indicate that we have
                //  it and exit the critical section and return.
                //

                Resource->NumberOfActive -= 1;

                LeaveCriticalSection(&Resource->CriticalSection);

                return TRUE;
            }
        }

    }

    //
    //  The resource is not currently acquired for shared so this is a
    //  spurious call
    //

#if DBG
    DBGPRINTF(( DBG_CONTEXT,
                "%08p::[InetConvertSharedToExclusive] "
                "Failed error - SHARED_RESOURCE_CONV_ERROR\n",
                Resource));
    DebugBreak();
#endif

    return FALSE;
}


BOOL
InetConvertExclusiveToShared(
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine converts a resource acquired for exclusive access into
    one acquired for shared access.  Upon return from the procedure
    the resource is acquired for shared access

Arguments:

    Resource - Supplies the resource to acquire for shared access, it
        must already be acquired for exclusive access

Return Value:

    None

--*/

{
    LONG PreviousCount;

    //
    //  Enter the critical section
    //

    EnterCriticalSection(&Resource->CriticalSection);

    //
    //  If there is only one shared user (it's us) and we can acquire the
    //  resource for exclusive access.
    //

    if (Resource->NumberOfActive == -1) {

        Resource->ExclusiveOwnerThread = NULL;

        //
        //  Check to see if there are waiting shared, who should now get the
        //  resource along with us
        //

        if (Resource->NumberOfWaitingShared > 0) {

            //
            //  Set the new state to indicate that all of the shared requesters
            //  have access including us, and there are no more waiting shared
            //  requesters, and then release all of the shared requsters
            //

            Resource->NumberOfActive = Resource->NumberOfWaitingShared + 1;

            Resource->NumberOfWaitingShared = 0;

            if ( !ReleaseSemaphore(
                         Resource->SharedSemaphore,
                         Resource->NumberOfActive - 1,
                         &PreviousCount
                         )) {
                LeaveCriticalSection(&Resource->CriticalSection);
                return FALSE;
            }
        } else {

            //
            //  There is no one waiting for shared access so it's only ours
            //

            Resource->NumberOfActive = 1;

        }

        LeaveCriticalSection(&Resource->CriticalSection);

        return TRUE;

    }

    //
    //  The resource is not currently acquired for exclusive, or we've
    //  recursively acquired it, so this must be a spurious call
    //

#if DBG
    DBGPRINTF(( DBG_CONTEXT,
                "%08p::[InetConvertExclusiveToShared] "
                "Failed error - SHARED_RESOURCE_CONV_ERROR\n",
                Resource));
    DebugBreak();
#endif

    return FALSE;
}


VOID
InetDeleteResource (
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine deletes (i.e., uninitializes) the input resource variable


Arguments:

    Resource - Supplies the resource variable being deleted

Return Value:

    None

--*/

{
    DeleteCriticalSection( &Resource->CriticalSection );
    CloseHandle(Resource->SharedSemaphore);
    CloseHandle(Resource->ExclusiveSemaphore);
    ZeroMemory( Resource, sizeof( *Resource ) );

#if DBG
    InterlockedIncrement( &g_InetResourcesDeleted );
#endif

    return;
}



VOID
InetDumpResource(
    IN PRTL_RESOURCE Resource
    )
{
    DBGPRINTF(( DBG_CONTEXT, "Resource @ %p\n",
                Resource));
    DBGPRINTF(( DBG_CONTEXT, " NumberOfWaitingShared = %lx\n",
                Resource->NumberOfWaitingShared));
    DBGPRINTF(( DBG_CONTEXT, " NumberOfWaitingExclusive = %lx\n",
                Resource->NumberOfWaitingExclusive));
    DBGPRINTF(( DBG_CONTEXT, " NumberOfActive = %lx\n",
                Resource->NumberOfActive));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\sharelok.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//   The include files for supporting classes.
//
//   The include files for supporting classes consists of
//   classes refered to or used in this class.  The structure
//   of each source module is as follows:
//      1. Include files.
//      2. Constants local to the class.
//      3. Data structures local to the class.
//      4. Data initializations.
//      5. Static functions.
//      6. Class functions.
//   Sections that are not required are omitted.
//
///////////////////////////////////////////////////////////////////////////////

#include "precomp.hxx"

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <Sharelok.h>


//////////////////////////////////////////////////////////////////////
//
//   Class constructor.
//
//   Create a new lock and initialize it.  This call is not
//   thread safe and should only be made in a single thread
//   environment.
//
//////////////////////////////////////////////////////////////////////

CSharelock::CSharelock( SBIT32 lNewMaxSpins, SBIT32 lNewMaxUsers )
{
	//
	//   Set the initial state.
	//
	m_lExclusive = 0;
	m_lTotalUsers = 0;
    m_lWaiting = 0;

	//
	//   Check the configurable values.
	//
	if ( lNewMaxSpins > 0 )
	{ 
		m_lMaxSpins = lNewMaxSpins; 
	}
	else
	{
		throw (TEXT("Maximum spins invalid in constructor for CSharelock")); 
	}

	if ( (lNewMaxUsers > 0) && (lNewMaxUsers <= m_MaxShareLockUsers) )
	{
		m_lMaxUsers = lNewMaxUsers; 
	}
	else
	{
		throw (TEXT("Maximum share invalid in constructor for CSharelock")); 
	}

	//
	//   Create a semaphore to sleep on when the spin count exceeds
	//   its maximum.
	//
    if ( (m_hSemaphore = CreateSemaphore( NULL, 0, m_MaxShareLockUsers, NULL )) == NULL)
    {
		throw (TEXT("Create semaphore in constructor for CSharelock")); 
	}

#ifdef _DEBUG

	//
	//   Set the initial state of any debug variables.
	//
    m_lTotalExclusiveLocks = 0;
    m_lTotalShareLocks = 0;
    m_lTotalSleeps = 0;
    m_lTotalSpins = 0;
    m_lTotalTimeouts = 0;
    m_lTotalWaits = 0;
#endif
    }

//////////////////////////////////////////////////////////////////////
//
//   Sleep waiting for the lock.
//
//   We have decided it is time to sleep waiting for the lock
//   to become free.
//
//////////////////////////////////////////////////////////////////////

BOOLEAN CSharelock::SleepWaitingForLock( SBIT32 lSleep )
{
	//
	//   We have been spinning waiting for the lock but it
	//   has not become free.  Hence, it is now time to 
	//   give up and sleep for a while.
	//
	(void) InterlockedIncrement( (LPLONG) & m_lWaiting );

	//
	//   Just before we go to sleep we do one final check
	//   to make sure that the lock is still busy and that
	//   there is someone to wake us up when it becomes free.
	//
	if ( m_lTotalUsers > 0 )
	{
#ifdef _DEBUG
		//
		//   Count the number of times we have slept on this lock.
		//
		(void) InterlockedIncrement( (LPLONG) & m_lTotalSleeps );

#endif
		//
		//   When we sleep we awoken when the lock becomes free
		//   or when we timeout.  If we timeout we simply exit
		//   after decrementing various counters.
		if (WaitForSingleObject( m_hSemaphore, lSleep ) != WAIT_OBJECT_0 )
		{ 
#ifdef _DEBUG
			//
			//   Count the number of times we have timed out 
			//   on this lock.
			//
			(void) InterlockedIncrement( (LPLONG) & m_lTotalTimeouts );

#endif
			return FALSE; 
		}
	}
	else
	{
		//
		//   Lucky - the lock was just freed so lets
		//   decrement the sleep count and exit without
		//   sleeping.
		// 
		(void) InterlockedDecrement( (LPLONG) & m_lWaiting );
	}
	
	return TRUE;
}

//////////////////////////////////////////////////////////////////////
//
//   Update the spin limit.
//
//   Update the maximum number of spins while waiting for the lock.
//
//////////////////////////////////////////////////////////////////////

BOOLEAN CSharelock::UpdateMaxSpins( SBIT32 lNewMaxSpins )
{
	if ( lNewMaxSpins > 0 )
	{ 
		m_lMaxSpins = lNewMaxSpins; 

		return TRUE;
	}
	else
	{ 
		return FALSE; 
	}
}

//////////////////////////////////////////////////////////////////////
//
//   Update the sharing limit.
//
//   Update the maximum number of users that can share the lock.
//
//////////////////////////////////////////////////////////////////////

BOOLEAN CSharelock::UpdateMaxUsers( SBIT32 lNewMaxUsers )
{
	if ( (lNewMaxUsers > 0) && (lNewMaxUsers <= m_MaxShareLockUsers) )
	{
		ClaimExclusiveLock();

		m_lMaxUsers = lNewMaxUsers;
		
		ReleaseExclusiveLock();

		return TRUE;
	}
	else
	{ 
		return FALSE; 
	}
}

//////////////////////////////////////////////////////////////////////
//
//   Wait for an exclusive lock.
//
//   Wait for the spinlock to become free and then claim it.
//
//////////////////////////////////////////////////////////////////////

BOOLEAN CSharelock::WaitForExclusiveLock( SBIT32 lSleep )
{
#ifdef _DEBUG
	register SBIT32 lSpins = 0;
	register SBIT32 lWaits = 0;

#endif
	while ( m_lTotalUsers != 1 )
	{
		//
		//   The lock is busy so release it and spin waiting
		//   for it to become free.
		//
		(void) InterlockedDecrement( (LPLONG) & m_lTotalUsers );
    
		//
		//  Find out if we are allowed to spin and sleep if
		//  necessary.
		//
		if ( (lSleep > 0) || (lSleep == INFINITE) )
		{
			register SBIT32 lCount;

			//
			//   Wait by spinning and repeatedly testing the lock.
			//   We exit when the lock becomes free or the spin limit
			//   is exceeded.
			//
			for (lCount = (NumProcessors() < 2) ? 0 : m_lMaxSpins;
                 (lCount > 0) && (m_lTotalUsers > 0);
                 lCount -- )
				;
#ifdef _DEBUG

			lSpins += (m_lMaxSpins - lCount);
			lWaits ++;
#endif

			//
			//   We have exhusted our spin count so it is time to
			//   sleep waiting for the lock to clear.
			//
			if ( lCount == 0 )
			{
				//
				//   We have decide that we need to sleep but are
				//   still holding an exclusive lock so lets drop it
				//   before sleeping.
				//
				(void) InterlockedDecrement( (LPLONG) & m_lExclusive );

				//
				//   We have decide to go to sleep.  If the sleep time
				//   is not 'INFINITE' then we must subtract the time
				//   we sleep from our maximum sleep time.  If the
				//   sleep time is 'INFINITE' then we can just skip
				//   this step.
				//
				if ( lSleep != INFINITE )
				{
					register DWORD dwStartTime = GetTickCount();

					if ( ! SleepWaitingForLock( lSleep ) )
					{ 
						return FALSE; 
					}

					lSleep -= ((GetTickCount() - dwStartTime) + 1);
					lSleep = (lSleep > 0) ? lSleep : 0;
				}
				else
				{
					if ( ! SleepWaitingForLock( lSleep ) )
					{
						return FALSE; 
					}
				}

				//
				//   We have woken up again so lets reclaim the
				//   exclusive lock we had earlier.
				//
				(void) InterlockedIncrement( (LPLONG) & m_lExclusive );
			}
		}
		else
		{ 
			//
			//   We have decide that we need to exit but are still
			//   holding an exclusive lock.  so lets drop it and leave.
			//
			(void) InterlockedDecrement( (LPLONG) & m_lExclusive );

			return FALSE; 
		} 

		//
		//   Lets test the lock again.
		//
		InterlockedIncrement( (LPLONG) & m_lTotalUsers );
	}
#ifdef _DEBUG

	(void) InterlockedExchangeAdd( (LPLONG) & m_lTotalSpins, (LONG) lSpins );
	(void) InterlockedExchangeAdd( (LPLONG) & m_lTotalWaits, (LONG) lWaits );
#endif

	return TRUE;
}

//////////////////////////////////////////////////////////////////////
//
//   Wait for a shared lock.
//
//   Wait for the lock to become free and then claim it.
//
//////////////////////////////////////////////////////////////////////

BOOLEAN CSharelock::WaitForShareLock( SBIT32 lSleep )
{
#ifdef _DEBUG
	register SBIT32 lSpins = 0;
	register SBIT32 lWaits = 0;

#endif
	while ( (m_lExclusive > 0) || (m_lTotalUsers > m_lMaxUsers) )
	{
		//
		//   The lock is busy so release it and spin waiting
		//   for it to become free.
		//
		(void) InterlockedDecrement( (LPLONG) & m_lTotalUsers );

		if ( (lSleep > 0) || (lSleep == INFINITE) )
		{
			register SBIT32 lCount;

			//
			//   Wait by spinning and repeatedly testing the lock.
			//   We exit when the lock becomes free or the spin limit
			//   is exceeded.
			//
			for (lCount = (NumProcessors() < 2) ? 0 : m_lMaxSpins;
                 (lCount > 0) && ((m_lExclusive > 0) || (m_lTotalUsers >= m_lMaxUsers));
                 lCount -- )
				;
#ifdef _DEBUG

			lSpins += (m_lMaxSpins - lCount);
			lWaits ++;
#endif

			//
			//   We have exhusted our spin count so it is time to
			//   sleep waiting for the lock to clear.
			//
			if ( lCount == 0 )
			{ 
				//
				//   We have decide to go to sleep.  If the sleep time
				//   is not 'INFINITE' then we must subtract the time
				//   we sleep from our maximum sleep time.  If the
				//   sleep time is 'INFINITE' then we can just skip
				//   this step.
				//
				if ( lSleep != INFINITE )
				{
					register DWORD dwStartTime = GetTickCount();

					if ( ! SleepWaitingForLock( lSleep ) )
					{ 
						return FALSE; 
					}

					lSleep -= ((GetTickCount() - dwStartTime) + 1);
					lSleep = (lSleep > 0) ? lSleep : 0;
				}
				else
				{
					if ( ! SleepWaitingForLock( lSleep ) )
					{
						return FALSE; 
					}
				}
			}
		}
		else
		{ 
			return FALSE; 
		}

		//
		//   Lets test the lock again.
		//
		(void) InterlockedIncrement( (LPLONG) & m_lTotalUsers );
	}
#ifdef _DEBUG


	(void) InterlockedExchangeAdd( (LPLONG) & m_lTotalSpins, (LONG) lSpins );
	(void) InterlockedExchangeAdd( (LPLONG) & m_lTotalWaits, (LONG) lWaits );
#endif

	return TRUE;
}

//////////////////////////////////////////////////////////////////////
//
//   Wake all sleepers.
//
//   Wake all the sleepers who are waiting for the spinlock.
//   All sleepers are woken because this is much more efficent
//   and it is known that the lock latency is short.
//
//////////////////////////////////////////////////////////////////////

void CSharelock::WakeAllSleepers( void )
{
    register LONG lWakeup = InterlockedExchange( (LPLONG) & m_lWaiting, 0 );

    if ( lWakeup > 0 )
    {
        //
        //   Wake up all sleepers as the lock has just been freed.
        //   It is a straight race to decide who gets the lock next.
        //
        if ( ! ReleaseSemaphore( m_hSemaphore, lWakeup, NULL ) )
        { 
			throw (TEXT("Wakeup failed in ReleaseLock()")); 
		}
    }
    else
    {
        //
        //   When multiple threads pass through the critical section rapidly
        //   it is possible for the 'Waiting' count to become negative.
        //   This should be very rare but such a negative value needs to be
        //   preserved. 
        //
        InterlockedExchangeAdd( (LPLONG) & m_lWaiting, lWakeup ); 
    }
}

//////////////////////////////////////////////////////////////////////
//
//   Class destructor.
//
//   Destroy a lock.  This call is not thread safe and should
//   only be made in a single thread environment.
//
//////////////////////////////////////////////////////////////////////

CSharelock::~CSharelock( void )
{
    if ( ! CloseHandle( m_hSemaphore ) )
    { 
		throw (TEXT("Close semaphore in destructor for CSharelock")); 
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\stktrace.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    stktrace.c

Abstract:

    Implements IISCaptureStackBackTrace().

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <pudebug.h>
#include <stktrace.h>


typedef
USHORT
(NTAPI * PFN_RTL_CAPTURE_STACK_BACK_TRACE)(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    );

PFN_RTL_CAPTURE_STACK_BACK_TRACE g_pfnRtlCaptureStackBackTrace = NULL;



USHORT
NTAPI
DummyCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    )
/*++

Routine Description:

    Dummy implementation of RtlCaptureStackBackTrace() for Win9x.

Arguments:

    See IISCaptureStackBackTrace() below.

Return Value:

    USHORT - Always 0.

--*/
{

    return 0;

}   // DummyRtlCaptureStackBackTrace


USHORT
NTAPI
IISCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    )
/*++

Routine Description:

    Wrapper around RtlCaptureStackBackTrace(). Attempts to capture the
    stack backtrace leading up to the current instruction counter.
    Doesn't work very well on RISC platforms, and is often confused on
    X86 when FPO is enabled.

Arguments:

    FramesToSkip - The number of stack frames to skip before capturing.

    FramesToCapture - The number of stack frames to capture.

    BackTrace - Receives the captured frames.

    BackTraceHash - Some kind of hash thingie.

Return Value:

    USHORT - The number of frames captured.

--*/
{

    //
    // Initialize if necessary.
    //

    if( g_pfnRtlCaptureStackBackTrace == NULL ) {

        HMODULE mod;
        PFN_RTL_CAPTURE_STACK_BACK_TRACE proc = NULL;

        //
        // Note that it is perfectly safe to use GetModuleHandle() here
        // rather than LoadLibrary(), for the following reasons:
        //
        //     1. Under NT, NTDLL.DLL is a "well known" DLL that *never*
        //        gets detached from the process. It's very special.
        //
        //     2. Under Win95, NTDLL.DLL doesn't export the
        //        RtlCaptureStackBackTrace() function, so we will not be
        //        referencing any routines within the DLL.
        //
        // Also note that we retrieve the function pointer into a local
        // variable, not directly into the global. This prevents a nasty
        // race condition that can occur when two threads try to
        // initialize g_pfnRtlCaptureStackBackTrace simultaneously.
        //

        mod = GetModuleHandle( "ntdll.dll" );

        if( mod != NULL ) {
            proc = (PFN_RTL_CAPTURE_STACK_BACK_TRACE)
                GetProcAddress( mod, "RtlCaptureStackBackTrace" );
        }

        if( proc == NULL ) {
            g_pfnRtlCaptureStackBackTrace = &DummyCaptureStackBackTrace;
        } else {
            g_pfnRtlCaptureStackBackTrace = proc;
        }

    }

    return (g_pfnRtlCaptureStackBackTrace)(
               FramesToSkip,
               FramesToCapture,
               BackTrace,
               BackTraceHash
               );

}   // IISCaptureStackBackTrace
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\stringau.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    string.cxx

    This module contains a light weight string class


    FILE HISTORY:
    4/8/97      michth      created

*/

#include "precomp.hxx"
#include "aucommon.hxx"


/*******************************************************************

    NAME:       STRAU::STR

    SYNOPSIS:   Construct a string object

    ENTRY:      Optional object initializer

    NOTES:      If the object is not valid (i.e. !IsValid()) then GetLastError
                should be called.

                The object is guaranteed to construct successfully if nothing
                or NULL is passed as the initializer.

********************************************************************/

// Inlined in stringau.hxx


VOID
STRAU::AuxInit( const LPSTR pInit )
{
    BOOL fRet;

    if ( pInit && (*pInit != '\0') )
    {
        INT cbCopy = (::strlen( pInit ) + 1) * sizeof(CHAR);
        fRet = m_bufAnsi.Resize( cbCopy );

        if ( fRet ) {
            CopyMemory( m_bufAnsi.QueryPtr(), pInit, cbCopy );
            m_cbMultiByteLen = (cbCopy)/sizeof(CHAR) - 1;
            m_bUnicode = FALSE;
            m_bInSync = FALSE;
        } else {
            m_bIsValid = FALSE;
        }

    } else {
        Reset();
    }

    return;
} // STRAU::AuxInit()


VOID
STRAU::AuxInit( const LPWSTR pInit )
{
    BOOL fRet;

    if ( pInit && (*pInit != (WCHAR)'\0'))
    {
        INT cbCopy = (::wcslen( pInit) + 1) * sizeof(WCHAR);
        fRet = m_bufUnicode.Resize( cbCopy );

        if ( fRet ) {
            CopyMemory( m_bufUnicode.QueryPtr(), pInit, cbCopy );
            m_cchUnicodeLen = (cbCopy)/sizeof(WCHAR) - 1;
            m_bUnicode = TRUE;
            m_bInSync = FALSE;
        } else {
            m_bIsValid = FALSE;
        }

    } else {
        Reset();
    }

    return;
} // STRAU::AuxInit()


/*******************************************************************

    NAME:       STRAU::AuxAppend

    SYNOPSIS:   Appends the string onto this one.

    ENTRY:      Object to append
********************************************************************/


BOOL STRAU::AuxAppend( const LPSTR pStr, UINT cbStr, BOOL fAddSlop )
{
    DBG_ASSERT( pStr != NULL );

    BOOL bReturn = m_bIsValid;

    if (m_bIsValid) {
        if (!m_bUnicode || (m_cchUnicodeLen == 0)) {
            //
            // Just append the ANSI string
            //
            //
            //  Only resize when we have to.  When we do resize, we tack on
            //  some extra space to avoid extra reallocations.
            //
            //  Note: QuerySize returns the requested size of the string buffer,
            //        *not* the strlen of the buffer
            //

            if ( m_bufAnsi.QuerySize() < ((m_cbMultiByteLen + cbStr + 1) * sizeof(CHAR)) )
            {
                bReturn = m_bufAnsi.Resize( ((m_cbMultiByteLen + cbStr + 1) * sizeof(CHAR)) + ((fAddSlop) ? STR_SLOP : 0) );
            }

            if (bReturn) {
                // copy the exact string and append a null character
                memcpy( (BYTE *) (((LPSTR)m_bufAnsi.QueryPtr()) + m_cbMultiByteLen),
                        pStr,
                        cbStr * sizeof(char));
                m_cbMultiByteLen += cbStr;
                *((CHAR *) m_bufAnsi.QueryPtr() + m_cbMultiByteLen) = '\0';  // append an explicit null char
                m_bUnicode = FALSE;
                m_bInSync = FALSE;
            }
            else {
                m_bIsValid = FALSE;
            }
        }
        else {
            //
            // Currently have a UNICODE string
            // Need to convert to UNICODE and copy
            // Use the ANSI buffer as temporary space
            //
            int iUnicodeLen = ConvertMultiByteToUnicode(pStr, &m_bufAnsi, cbStr);
            if (STR_CONVERSION_SUCCEEDED(iUnicodeLen)) {
                if ( m_bufUnicode.QuerySize() < ((m_cchUnicodeLen + iUnicodeLen + 1) * sizeof(WCHAR)) )
                {
                    bReturn = m_bufUnicode.Resize( ((m_cchUnicodeLen + iUnicodeLen + 1) * sizeof(WCHAR)) + ((fAddSlop) ? STR_SLOP : 0) );
                }

                if (bReturn) {
                    // copy the exact string and append a null character
                    memcpy( (BYTE *) ((LPWSTR)(m_bufUnicode.QueryPtr()) + m_cchUnicodeLen),
                            m_bufAnsi.QueryPtr(),
                            (iUnicodeLen * sizeof(WCHAR)));
                    m_cchUnicodeLen += iUnicodeLen;
                    *((LPWSTR)m_bufUnicode.QueryPtr() + m_cchUnicodeLen) = (WCHAR)'\0';  // append an explicit null char
                    m_bInSync = FALSE;
                }
                else {
                    m_bIsValid = FALSE;
                }
            }
            else {
                m_bIsValid = FALSE;
            }
        }
    }
    return bReturn;
} // STRAU::AuxAppend()


BOOL STRAU::AuxAppend( const LPWSTR pStr, UINT cchStr, BOOL fAddSlop )
{
    DBG_ASSERT( pStr != NULL );

    BOOL bReturn = m_bIsValid;
    int iUnicodeLen;

    if (m_bIsValid) {
        if (!m_bUnicode && !m_bInSync && (m_cbMultiByteLen != 0)) {

            // Currently have an ANSI string
            // Need to convert ANSI string to UNICODE before copy
            //
            iUnicodeLen = ConvertMultiByteToUnicode((LPSTR)m_bufAnsi.QueryPtr(), &m_bufUnicode, m_cbMultiByteLen);
            if (STR_CONVERSION_SUCCEEDED(iUnicodeLen)) {
                m_cchUnicodeLen = iUnicodeLen;
            }
            else {
                bReturn = FALSE;
                m_bIsValid = FALSE;
            }
        }
        if (bReturn) {
            //
            //  Only resize when we have to.  When we do resize, we tack on
            //  some extra space to avoid extra reallocations.
            //
            //  Note: QuerySize returns the requested size of the string buffer,
            //        *not* the strlen of the buffer
            //
            if ( m_bufUnicode.QuerySize() < ((m_cchUnicodeLen + cchStr + 1) * sizeof(WCHAR)) )
            {
                bReturn = m_bufUnicode.Resize( ((m_cchUnicodeLen + cchStr + 1) * sizeof(WCHAR)) + ((fAddSlop) ? STR_SLOP : 0) );
            }

            if (bReturn) {
                // copy the exact string and append a null character
                memcpy( (BYTE *) (((LPWSTR)m_bufUnicode.QueryPtr()) + m_cchUnicodeLen),
                        pStr,
                        (cchStr * sizeof(WCHAR)));
                m_cchUnicodeLen += cchStr;
                *((LPWSTR)m_bufUnicode.QueryPtr() + m_cchUnicodeLen) = (WCHAR)'\0';  // append an explicit null char
                m_bInSync = FALSE;
                m_bUnicode = TRUE;
            }
            else {
                m_bIsValid = FALSE;
            }
        }
    }
    return bReturn;
} // STRAU::AuxAppend()


BOOL
STRAU::SetLen( IN DWORD cchLen)
{
    BOOL bReturn = FALSE;
    if (cchLen <= QueryCCH()) {
        if (m_bUnicode || m_bInSync) {
            *((LPWSTR)m_bufUnicode.QueryPtr() + cchLen) = (WCHAR)'\0';
            m_cchUnicodeLen = cchLen;
        }
        if (!m_bUnicode || m_bInSync) {
            LPSTR pszTerminateByte = (LPSTR)m_bufAnsi.QueryPtr();
            WORD wPrimaryLangID = PRIMARYLANGID(GetSystemDefaultLangID());
            if (wPrimaryLangID == LANG_JAPANESE ||
                wPrimaryLangID == LANG_CHINESE  ||
                wPrimaryLangID == LANG_KOREAN)
            {
                char *pszTop = pszTerminateByte;
                for (DWORD i = 0; i < QueryCCH(); i++) {
                    pszTerminateByte = CharNextExA(CP_ACP,
                                                   pszTerminateByte,
                                                   0);
                }
                m_cbMultiByteLen = DIFF(pszTerminateByte - pszTop);
            }
            else
            {
                pszTerminateByte += cchLen;
                m_cbMultiByteLen = cchLen;
            }
            *pszTerminateByte = '\0';
        }
        bReturn = TRUE;
    }

    return bReturn;
}


LPTSTR
STRAU::QueryStr(BOOL bUnicode)
{

    //
    // This can fail. Return a null string for either UNICODE or ANSI
    // So that clients expecting a valid pointer actually get one.
    //
    LPTSTR pszReturn = NULL;
    int iNewStrLen;

    if (m_bIsValid) {
        if ((bUnicode != m_bUnicode) && (!m_bInSync)) {
            //
            // Need to Convert First
            //
            if (bUnicode) {
                //
                // Convert current string to UNICODE
                //
                iNewStrLen = ConvertMultiByteToUnicode((LPSTR)m_bufAnsi.QueryPtr(), &m_bufUnicode, m_cbMultiByteLen);
                if (STR_CONVERSION_SUCCEEDED(iNewStrLen)) {
                    m_cchUnicodeLen = iNewStrLen;
                    m_bInSync = TRUE;
                }
                else {
                    m_bIsValid = FALSE;
                }
            }
            else {
                //
                // Convert current string to Ansi
                //
                iNewStrLen = ConvertUnicodeToMultiByte((LPWSTR)m_bufUnicode.QueryPtr(), &m_bufAnsi, m_cchUnicodeLen);
                if (STR_CONVERSION_SUCCEEDED(iNewStrLen)) {
                    m_cbMultiByteLen = iNewStrLen;
                    m_bInSync = TRUE;
                }
                else {
                    m_bIsValid = FALSE;
                }
            }
        }

        if (m_bIsValid) {
            if (bUnicode) {
                pszReturn = (LPTSTR)m_bufUnicode.QueryPtr();
            }
            else {
                pszReturn = (LPTSTR)m_bufAnsi.QueryPtr();
            }

        }
    }

    return pszReturn;
}

BOOL
STRAU::SafeCopy( const LPSTR pchInit )
{
    BOOL bReturn = TRUE;
    SaveState();
    Reset();
    if (pchInit != NULL) {
        bReturn  = AuxAppend(pchInit, ::strlen( pchInit ), FALSE );
        if (!bReturn) {
            RestoreState();
        }
    }
    return bReturn;
}


BOOL
STRAU::SafeCopy( const LPWSTR pchInit )
{
    BOOL bReturn = TRUE;
    SaveState();
    Reset();
    if (pchInit != NULL) {
        bReturn  = AuxAppend( pchInit, ::wcslen( pchInit ), FALSE );
        if (!bReturn) {
            RestoreState();
        }
    }
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\string.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    string.cxx

    This module contains a light weight string class


    FILE HISTORY:
        Johnl       15-Aug-1994 Created
        MuraliK     27-Feb-1995 Modified to be a standalone module with buffer.
        MuraliK     2-June-1995 Made into separate library

*/

#include "precomp.hxx"


//
// Normal includes only for this module to be active
//

# include <opt_time.h>

extern "C" {
 # include <nt.h>
 # include <ntrtl.h>
 # include <nturtl.h>
 # include <windows.h>
};

# include "dbgutil.h"
# include <string.hxx>
# include <auxctrs.h>

# include <tchar.h>
# include <mbstring.h>

//
// String globals
//

typedef UCHAR * ( __cdecl * PFNSTRCASE ) ( UCHAR * );
typedef INT ( __cdecl * PFNSTRNICMP ) ( const UCHAR *, const UCHAR *, size_t );
typedef INT ( __cdecl * PFNSTRICMP ) ( const UCHAR *, const UCHAR * );
typedef size_t ( __cdecl * PFNSTRLEN ) ( const UCHAR * );
typedef UCHAR * (__cdecl * PFNSTRRCHR) (const UCHAR *, UINT);

PFNSTRCASE  g_pfnStrupr     = _mbsupr;
PFNSTRCASE  g_pfnStrlwr     = _mbslwr;
PFNSTRNICMP g_pfnStrnicmp   = _mbsnicmp;
PFNSTRICMP  g_pfnStricmp    = _mbsicmp;
PFNSTRLEN   g_pfnStrlen     = _mbslen;
PFNSTRRCHR  g_pfnStrrchr    = _mbsrchr;

BOOL        g_fFavorDBCS    = FALSE;

#define UTF8_HACK_KEY "System\\CurrentControlSet\\Services\\InetInfo\\Parameters"
#define UTF8_HACK_VALUE "FavorDBCS"

//
//  Private Definations
//

//
//  When appending data, this is the extra amount we request to avoid
//  reallocations
//
#define STR_SLOP        128

//
//  Converts a value between zero and fifteen to the appropriate hex digit
//
#define HEXDIGIT( nDigit )                              \
    (TCHAR)((nDigit) > 9 ?                              \
          (nDigit) - 10 + 'A'                           \
        : (nDigit) + '0')

//
//  Converts a single hex digit to its decimal equivalent
//
#define TOHEX( ch )                                     \
    ((ch) > '9' ?                                       \
        (ch) >= 'a' ?                                   \
            (ch) - 'a' + 10 :                           \
            (ch) - 'A' + 10                             \
        : (ch) - '0')


/*******************************************************************

    NAME:       STR::STR

    SYNOPSIS:   Construct a string object

    ENTRY:      Optional object initializer

    NOTES:      If the object is not valid (i.e. !IsValid()) then GetLastError
                should be called.

                The object is guaranteed to construct successfully if nothing
                or NULL is passed as the initializer.

********************************************************************/

// Inlined in string.hxx


VOID
STR::AuxInit( const BYTE * pInit )
{
    BOOL fRet;

    if ( pInit )
    {
        INT cbCopy = (::strlen( (const CHAR * ) pInit ) + 1) * sizeof(CHAR);
        fRet = Resize( cbCopy );

        if ( fRet ) {
            CopyMemory( QueryPtr(), pInit, cbCopy );
            m_cchLen = (cbCopy)/sizeof(CHAR) - 1;
        } else {
            BUFFER::SetValid( FALSE);
        }

    } else {

        *((CHAR *) QueryPtr()) = '\0';
        m_cchLen = 0;
    }

    return;
} // STR::AuxInit()



/*******************************************************************

    NAME:       STR::AuxAppend

    SYNOPSIS:   Appends the string onto this one.

    ENTRY:      Object to append
********************************************************************/

BOOL STR::AuxAppend( const BYTE * pStr, UINT cbStr, BOOL fAddSlop )
{
    DBG_ASSERT( pStr != NULL );

    UINT cbThis = QueryCB();

    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //

    AcIncrement( CacStringAppend);
    if ( QuerySize() < cbThis + cbStr + sizeof(CHAR) )
    {
        if ( !Resize( cbThis + cbStr + (fAddSlop ? STR_SLOP : sizeof(CHAR) )) )
            return FALSE;
    }

    // copy the exact string and append a null character
    memcpy( (BYTE *) QueryPtr() + cbThis,
            pStr,
            cbStr);
    m_cchLen += cbStr/sizeof(CHAR);
    *((CHAR *) QueryPtr() + m_cchLen) = '\0';  // append an explicit null char

    return TRUE;
} // STR::AuxAppend()


#if 0
// STR::SetLen() is inlined now
BOOL
STR::SetLen( IN DWORD cchLen)
/*++
  Truncates the length of the string stored in this buffer
   to specified value.

--*/
{
    if ( cchLen >= QuerySize()) {

        // the buffer itself is not sufficient for this length. return error.
        return ( FALSE);
    }

    // null terminate the string at specified location
    *((CHAR *) QueryPtr() + cchLen) = '\0';
    m_cchLen = cchLen;

    return ( TRUE);
} // STR::SetLen()

#endif // 0


/*******************************************************************

    NAME:       STR::LoadString

    SYNOPSIS:   Loads a string resource from this module's string table
                or from the system string table

    ENTRY:      dwResID - System error or module string ID
                lpszModuleName - name of the module from which to load.
                 If NULL, then load the string from system table.

********************************************************************/

BOOL STR::LoadString( IN DWORD dwResID,
                      IN LPCTSTR lpszModuleName, // Optional
                      IN DWORD dwLangID          // Optional
                     )
{
    BOOL fReturn = FALSE;
    INT  cch;

    //
    //  If lpszModuleName is NULL, load the string from system's string table.
    //

    if ( lpszModuleName == NULL) {

        BYTE * pchBuff = NULL;

        //
        //  Call the appropriate function so we don't have to do the Unicode
        //  conversion
        //

        cch = ::FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_IGNORE_INSERTS  |
                                FORMAT_MESSAGE_MAX_WIDTH_MASK  |
                                FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                dwResID,
                                dwLangID,
                                (LPSTR) &pchBuff,
                                1024,
                                NULL );

        if ( cch ) {

          fReturn = Copy( (LPCSTR) pchBuff, cch );
        }

        //
        //  Free the buffer FormatMessage allocated
        //

        if ( cch )
        {
            ::LocalFree( (VOID*) pchBuff );
        }

    } else   {

        CHAR ach[STR_MAX_RES_SIZE];
        cch = ::LoadStringA( GetModuleHandle( lpszModuleName),
                             dwResID,
                             (CHAR *) ach,
                             sizeof(ach));
        if ( cch )
          {
            fReturn =  Copy( (LPSTR) ach, cch );
          }
    }

    return ( fReturn);

} // STR::LoadString()




BOOL STR::LoadString( IN DWORD  dwResID,
                      IN HMODULE hModule
                     )
{
    DBG_ASSERT( hModule != NULL );

    BOOL fReturn = FALSE;
    INT  cch;
    CHAR ach[STR_MAX_RES_SIZE];

    cch = ::LoadStringA(hModule,
                        dwResID,
                        (CHAR *) ach,
                        sizeof(ach));
    if ( cch ) {

      fReturn =  Copy( (LPSTR) ach, cch );
    }

    return ( fReturn);

} // STR::LoadString()



BOOL
STR::FormatString(
    IN DWORD   dwResID,
    IN LPCTSTR apszInsertParams[],
    IN LPCTSTR lpszModuleName,
    IN DWORD   cbMaxMsg
    )
{
    DWORD cch;
    LPSTR pchBuff;
    BOOL  fRet = FALSE;

    cch = ::FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY  |
                            FORMAT_MESSAGE_FROM_HMODULE,
                            GetModuleHandle( lpszModuleName ),
                            dwResID,
                            0,
                            (LPSTR) &pchBuff,
                            cbMaxMsg * sizeof(WCHAR),
                            (va_list *) apszInsertParams );

    if ( cch )
    {
        fRet = Copy( (LPCSTR) pchBuff, cch );

        ::LocalFree( (VOID*) pchBuff );
    }

    /* INTRINSA suppress = uninitialized */
    return fRet;
}



/*******************************************************************

    NAME:       STR::Escape

    SYNOPSIS:   Replaces non-ASCII characters with their hex equivalent

    NOTES:

    HISTORY:
        Johnl   17-Aug-1994     Created

********************************************************************/

BOOL STR::Escape( VOID )
{
    CHAR * pch      = QueryStr();
    int     i       = 0;
    CHAR    ch;

    DBG_ASSERT( pch );

    while ( ch = pch[i] )
    {
        //
        //  Escape characters that are in the non-printable range
        //  but ignore CR and LF
        //

        if ( (((ch >= 0)   && (ch <= 32)) ||
              ((ch >= 128) && (ch <= 159))||
              (ch == '%') || (ch == '?') || (ch == '+') || (ch == '&') ||
              (ch == '#')) &&
             !(ch == '\n' || ch == '\r')  )
        {
            if ( !Resize( QuerySize() + 2 * sizeof(CHAR) ))
                return FALSE;

            //
            //  Resize can change the base pointer
            //

            pch = QueryStr();

            //
            //  Insert the escape character
            //

            pch[i] = '%';

            //
            //  Insert a space for the two hex digits (memory can overlap)
            //
            
            /* INTRINSA suppress = uninitialized */

            ::memmove( &pch[i+3],
                       &pch[i+1],
                       (::strlen( &pch[i+1] ) + 1) * sizeof(CHAR));

            //
            //  Convert the low then the high character to hex
            //

            UINT nDigit = (UINT)(ch % 16);

            pch[i+2] = HEXDIGIT( nDigit );

            ch /= 16;
            nDigit = (UINT)(ch % 16);

            pch[i+1] = HEXDIGIT( nDigit );

            i += 3;
        }
        else
            i++;
    }

    m_cchLen = ::strlen( QueryStr());  // to be safe recalc the new length
    return TRUE;
} // STR::Escape()


/*******************************************************************

    NAME:       STR::EscapeSpaces

    SYNOPSIS:   Replaces all spaces with their hex equivalent

    NOTES:

    HISTORY:
        Johnl   17-Aug-1994     Created

********************************************************************/

BOOL STR::EscapeSpaces( VOID )
{
    CHAR * pch      = QueryStr();
    CHAR * pchTmp;
    int    i = 0;

    DBG_ASSERT( pch );

    while ( pchTmp = strchr( pch + i, ' ' ))
    {
        i = DIFF( pchTmp - QueryStr() );

        if ( !Resize( QuerySize() + 2 * sizeof(CHAR) ))
            return FALSE;

        //
        //  Resize can change the base pointer
        //

        pch = QueryStr();

        //
        //  Insert the escape character
        //

        pch[i] = '%';

        //
        //  Insert a space for the two hex digits (memory can overlap)
        //

        ::memmove( &pch[i+3],
                   &pch[i+1],
                   (::strlen( &pch[i+1] ) + 1) * sizeof(CHAR));

        //
        //  This routine only replaces spaces
        //

        pch[i+1] = '2';
        pch[i+2] = '0';
    }

    //
    //  If i is zero then no spaces were found
    //

    if ( i != 0 )
    {
        m_cchLen = ::strlen( QueryStr());  // to be safe recalc the new length
    }

    return TRUE;

} // STR::EscapeSpaces()



/*******************************************************************

    NAME:       STR::Unescape

    SYNOPSIS:   Replaces hex escapes with the Latin-1 equivalent

    NOTES:      This is a Unicode only method

    HISTORY:
        Johnl   17-Aug-1994     Created

********************************************************************/

BOOL STR::Unescape( VOID )
{
        CHAR    *pScan;
        CHAR    *pDest;
        CHAR    *pNextScan;
        wchar_t wch;
        DWORD   dwLen;
    BOOL        fChanged = FALSE;

        pDest = pScan = strchr( QueryStr(), '%');

        while (pScan)
        {
                if ( (pScan[1] == 'u' || pScan[1] == 'U') &&
                        ::isxdigit( (UCHAR)pScan[2] ) &&
                        ::isxdigit( (UCHAR)pScan[3] ) &&
                        ::isxdigit( (UCHAR)pScan[4] ) &&
                        ::isxdigit( (UCHAR)pScan[5] ) )
                {
                        wch = TOHEX(pScan[2]) * 4096 + TOHEX(pScan[3]) * 256;
                        wch += TOHEX(pScan[4]) * 16 + TOHEX(pScan[5]);

                        dwLen = WideCharToMultiByte( CP_ACP,
                                                                        0,
                                                                        &wch,
                                                                        1,
                                                                        (LPSTR) pDest,
                                                                        2,
                                                                        NULL,
                                                                        NULL );

                        pDest += dwLen;
                        pScan += 6;
                        fChanged = TRUE;
                }
                else if ( ::isxdigit( (UCHAR)pScan[1] ) && // WinSE 4944
                                ::isxdigit( (UCHAR)pScan[2] ))
                {
                        *pDest = TOHEX(pScan[1]) * 16 + TOHEX(pScan[2]);

                        pDest ++;
                        pScan += 3;
                        fChanged = TRUE;
                }
                else   // Not an escaped char, just a '%'
                {
                        if (fChanged)
                                *pDest = *pScan;

                        pDest++;
                        pScan++;
                }

                //
                // Copy all the information between this and the next escaped char
                //
                pNextScan = strchr( pScan, '%');

                if (fChanged)                                   // pScan!=pDest, so we have to copy the char's
                {
                        if (!pNextScan)                         // That was the last '%' in the string
                        {                       
                                ::memmove( pDest,
                                                        pScan,
                                                        (::strlen( pScan ) + 1) * sizeof(CHAR));  // +1 to copy '\0'
                        }
                        else                                            // There is another '%', and it is not back to back with this one
                                if (dwLen = DIFF(pNextScan - pScan))    
                                {
                                        ::memmove( pDest,
                                                                pScan,
                                                                dwLen * sizeof(CHAR));
                                        pDest += dwLen;
                                }
                }

                pScan = pNextScan;
        }

    if ( fChanged )
    {
        m_cchLen = ::strlen( QueryStr());  // for safety recalc the length
    }

    return TRUE;
}



BOOL
STR::CopyToBuffer( WCHAR * lpszBuffer, LPDWORD lpcch) const
/*++
    Description:
        Copies the string into the WCHAR buffer passed in if the buffer
        is sufficient to hold the translated string.
        If the buffer is small, the function returns small and sets *lpcch
        to contain the required number of characters.

    Arguments:
        lpszBuffer      pointer to WCHAR buffer which on return contains
                        the UNICODE version of string on success.
        lpcch           pointer to DWORD containing the length of the buffer.
                        If *lpcch == 0 then the function returns TRUE with
                        the count of characters required stored in *lpcch.
                        Also in this case lpszBuffer is not affected.
    Returns:
        TRUE on success.
        FALSE on failure.  Use GetLastError() for further details.

    History:
        MuraliK         11-30-94
--*/
{
   BOOL fReturn = TRUE;

    if ( lpcch == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    if ( *lpcch == 0) {

      //
      //  Inquiring the size of buffer alone
      //
      *lpcch = QueryCCH() + 1;    // add one character for terminating null
    } else {

        //
        // Copy after conversion from ANSI to Unicode
        //
        int  iRet;
        iRet = MultiByteToWideChar( CP_ACP,   MB_PRECOMPOSED,
                                    QueryStrA(),  QueryCCH() + 1,
                                    lpszBuffer, (int )*lpcch);

        if ( iRet == 0 || iRet != (int ) *lpcch) {

            //
            // Error in conversion.
            //
            fReturn = FALSE;
        }
    }

    return ( fReturn);
} // STR::CopyToBuffer()


BOOL
STR::CopyToBuffer( CHAR * lpszBuffer, LPDWORD lpcch) const
/*++
    Description:
        Copies the string into the CHAR buffer passed in if the buffer
          is sufficient to hold the translated string.
        If the buffer is small, the function returns small and sets *lpcch
          to contain the required number of characters.

    Arguments:
        lpszBuffer      pointer to CHAR buffer which on return contains
                        the string on success.
        lpcch           pointer to DWORD containing the length of the buffer.
                        If *lpcch == 0 then the function returns TRUE with
                        the count of characters required stored in *lpcch.
                        Also in this case lpszBuffer is not affected.
    Returns:
        TRUE on success.
        FALSE on failure.  Use GetLastError() for further details.

    History:
        MuraliK         20-Nov-1996
--*/
{
   BOOL fReturn = TRUE;

    if ( lpcch == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    register DWORD cch = QueryCCH() + 1;

    if ( (*lpcch >= cch) && ( NULL != lpszBuffer)) {

        DBG_ASSERT( lpszBuffer);
        CopyMemory( lpszBuffer, QueryStrA(), cch);
    } else {
        DBG_ASSERT( (NULL == lpszBuffer) || (*lpcch < cch));
        SetLastError( ERROR_INSUFFICIENT_BUFFER);
        fReturn = FALSE;
    }

    *lpcch = cch;

    return ( fReturn);
} // STR::CopyToBuffer()

BOOL
STR::SafeCopy( const CHAR  * pchInit )
{
    DWORD cchLen = 0;
    char cFirstByte = '\0';
    BOOL bReturn = TRUE;
    if ( QueryPtr() ) {
        cFirstByte = *(QueryStr());
        cchLen = m_cchLen;
        *(QueryStr()) = '\0';
        m_cchLen = 0;
    }
    if (pchInit != NULL) {
        bReturn  = AuxAppend( (const BYTE *) pchInit, ::strlen( pchInit ), FALSE );
        if (!bReturn && QueryPtr()) {
            *(QueryStr()) = cFirstByte;
            m_cchLen = cchLen;
        }
    }
    return bReturn;
}


/*******************************************************************

    NAME:       ::CollapseWhite

    SYNOPSIS:   Collapses white space starting at the passed pointer.

    RETURNS:    Returns a pointer to the next chunk of white space or the
                end of the string.

    NOTES:      This is a Unicode only method

    HISTORY:
        Johnl   24-Aug-1994     Created

********************************************************************/

WCHAR * CollapseWhite( WCHAR * pch )
{
    LPWSTR pchStart = pch;

    while ( ISWHITE( *pch ) )
        pch++;

    ::memmove( pchStart,
               pch,
               DIFF(pch - pchStart) );

    while ( *pch && !ISWHITE( *pch ))
        pch++;

    return pch;
} // CollapseWhite()





//
//  Private constants.
//

#define ACTION_NOTHING              0x00000000
#define ACTION_EMIT_CH              0x00010000
#define ACTION_EMIT_DOT_CH          0x00020000
#define ACTION_EMIT_DOT_DOT_CH      0x00030000
#define ACTION_BACKUP               0x00040000
#define ACTION_MASK                 0xFFFF0000


//
//  Private globals.
//

INT p_StateTable[16] =
    {
        // state 0
        0 ,             // other
        0 ,             // "."
        4 ,             // EOS
        1 ,             // "\"

        //  state 1
        0 ,              // other
        2 ,             // "."
        4 ,             // EOS
        1 ,             // "\"

        // state 2
        0 ,             // other
        3 ,             // "."
        4 ,             // EOS
        1 ,             // "\"

        // state 3
        0 ,             // other
        0 ,             // "."
        4 ,             // EOS
        1               // "\"
    };



INT p_ActionTable[16] =
    {
        // state 0
            ACTION_EMIT_CH,             // other
            ACTION_EMIT_CH,             // "."
            ACTION_EMIT_CH,             // EOS
            ACTION_EMIT_CH,             // "\"

        // state 1
            ACTION_EMIT_CH,             // other
            ACTION_NOTHING,             // "."
            ACTION_EMIT_CH,             // EOS
            ACTION_NOTHING,             // "\"

        // state 2
            ACTION_EMIT_DOT_CH,         // other
            ACTION_NOTHING,             // "."
            ACTION_EMIT_CH,             // EOS
            ACTION_NOTHING,             // "\"

        // state 3
            ACTION_EMIT_DOT_DOT_CH,     // other
            ACTION_EMIT_DOT_DOT_CH,     // "."
            ACTION_BACKUP,              // EOS
            ACTION_BACKUP               // "\"
    };

// since max states = 4, we calculat the index by multiplying with 4.
# define IndexFromState( st)   ( (st) * 4)


// the following table provides the index for various ISA Latin1 characters
//  in the incoming URL.
// It assumes that the URL is ISO Latin1 == ASCII
INT  p_rgIndexForChar[] = {

    2,   // null char
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 1 thru 10
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 11 thru 20
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 21 thru 30
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 31 thru 40
    0, 0, 0, 0, 0, 1, 3, 0, 0, 0,  // 41 thru 50  46 = '.' 47 = '/'
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 51 thru 60
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 61 thru 70
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 71 thru 80
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 81 thru 90
    0, 3, 0, 0, 0, 0, 0, 0, 0, 0,  // 91 thru 100  92 = '\\'
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 101 thru 110
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 111 thru 120
    0, 0, 0, 0, 0, 0, 0, 0         // 121 thru 128
};

#define IS_UTF8_TRAILBYTE(ch)      (((ch) & 0xc0) == 0x80)


/*******************************************************************

    NAME:       IsUTF8URL

    ENTRY:      pszPath - The path to sanitize.

    HISTORY:
        atsusk     06-Jan-1998 Created.

********************************************************************/

BOOL IsUTF8URL(CHAR * pszPath)
{
    CHAR    ch;

    if ( g_fFavorDBCS )
    {
        return ( MultiByteToWideChar( CP_ACP, 
                                      MB_ERR_INVALID_CHARS, 
                                      pszPath, 
                                      -1,
                                      NULL, 
                                      0) == 0);
    }

    while (ch = *pszPath++) {

        if (ch & 0x80) {
            wchar_t wch;
            int     iLen;
            BOOL    bDefault = FALSE;
            char    chTrail1;
            char    chTrail2;

            chTrail1 = *pszPath++;
            if (chTrail1) {
                chTrail2 = *pszPath;
            } else {
                chTrail2 = 0;
            }

            if ( ((ch & 0xF0) == 0xE0) &&
              IS_UTF8_TRAILBYTE(chTrail1) &&
              IS_UTF8_TRAILBYTE(chTrail2) ) {

                // handle three byte case
                // 1110xxxx 10xxxxxx 10xxxxxx
                wch = (wchar_t) (((ch & 0x0f) << 12) |
                                ((chTrail1 & 0x3f) << 6) |
                                (chTrail2 & 0x3f));
                pszPath++;

            } else
            if ( ((ch & 0xE0) == 0xC0) &&
              IS_UTF8_TRAILBYTE(chTrail1) ) {

                // handle two byte case
                // 110xxxxx 10xxxxxx

                wch = (wchar_t) (((ch & 0x1f) << 6) | (chTrail1 & 0x3f));

            } else
                return FALSE;

            iLen = WideCharToMultiByte( CP_ACP,
                                        0,
                                        &wch,
                                        1,
                                        NULL,
                                        0,
                                        NULL,
                                        &bDefault );

            if (bDefault == TRUE || iLen == 0 || iLen > 2)
                return FALSE;
        }
    }

    return TRUE;
}   // IsUTF8URL()


/*******************************************************************

    NAME:       CanonURL

    SYNOPSIS:   Sanitizes a path by removing bogus path elements.

                As expected, "/./" entries are simply removed, and
                "/../" entries are removed along with the previous
                path element.

                To maintain compatibility with URL path semantics
                 additional transformations are required. All backward
                 slashes "\\" are converted to forward slashes. Any
                 repeated forward slashes (such as "///") are mapped to
                 single backslashes.

                A state table (see the p_StateTable global at the
                beginning of this file) is used to perform most of
                the transformations.  The table's rows are indexed
                by current state, and the columns are indexed by
                the current character's "class" (either slash, dot,
                NULL, or other).  Each entry in the table consists
                of the new state tagged with an action to perform.
                See the ACTION_* constants for the valid action
                codes.

    ENTRY:      pszPath - The path to sanitize.
                fIsDBCSLocale - Indicates the server is in a
                    locale that uses DBCS.

    HISTORY:
        KeithMo     07-Sep-1994 Created.
        MuraliK     28-Apr-1995 Adopted this for symbolic paths

********************************************************************/
INT
CanonURL(
    CHAR * pszPath,
    BOOL   fIsDBCSLocale
    )
{
    UCHAR * pszSrc;
    UCHAR * pszDest;
    DWORD ch;
    INT   index;
    BOOL  fDBCS = FALSE;
    DWORD cchMultiByte = 0;

    DBG_ASSERT( pszPath != NULL );

    //
    // Always look for UTF8 except when DBCS characters are detected
    //
    BOOL fScanForUTF8 = IsUTF8URL(pszPath);

    // If fScanForUTF8 is true, this URL is UTF8. don't recognize DBCS.
    if (fIsDBCSLocale && fScanForUTF8) {
        fIsDBCSLocale = FALSE;
    }

    //
    //  Start our scan at the first character
    //

    pszSrc = pszDest = (UCHAR *) pszPath;

    //
    //  State 0 is the initial state.
    //
    index = 0; // State = 0

    //
    //  Loop until we enter state 4 (the final, accepting state).
    //

    do {

        //
        //  Grab the next character from the path and compute its
        //  next state.  While we're at it, map any forward
        //  slashes to backward slashes.
        //

        index = IndexFromState( p_StateTable[index]); // 4 = # states
        ch = (DWORD ) *pszSrc++;

        //
        //  If this is a DBCS trailing byte - skip it
        //

        if ( !fIsDBCSLocale )
        {
            index += (( ch >= 0x80) ? 0 : p_rgIndexForChar[ch]);
        }
        else
        {
            if ( fDBCS )
            {
                //
                // If this is a 0 terminator, we need to set next 
                // state accordingly
                //
                
                if ( ch == 0 )
                {
                    index += p_rgIndexForChar[ ch ];
                }
                
                //
                // fDBCS == TRUE means this byte was a trail byte.
                // index is implicitly set to zero.
                //
                fDBCS = FALSE;
            }
            else
            {
                index += (( ch >= 0x80) ? 0 : p_rgIndexForChar[ch]);

                if ( IsDBCSLeadByte( (UCHAR)ch ) )
                {
                    //
                    // This is a lead byte, so the next is a trail.
                    //
                    fDBCS = TRUE;
                }
            }
        }

        //
        //  Interesting UTF8 characters always have the top bit set
        //

        if ( (ch & 0x80) && fScanForUTF8 )
        {
            wchar_t wch;
            UCHAR mbstr[2];

            //
            //  This is a UTF8 character, convert it here.
            //  index is implicitly set to zero.
            //
            if ( cchMultiByte < 2 )
            {
                char chTrail1;
                char chTrail2;

                chTrail1 = *pszSrc;
                if (chTrail1) {
                    chTrail2 = *(pszSrc+1);
                } else {
                    chTrail2 = 0;
                }
                wch = 0;

                if ((ch & 0xf0) == 0xe0)
                {
                    // handle three byte case
                    // 1110xxxx 10xxxxxx 10xxxxxx

                    wch = (wchar_t) (((ch & 0x0f) << 12) |
                                     ((chTrail1 & 0x3f) << 6) |
                                     (chTrail2 & 0x3f));

                    cchMultiByte = WideCharToMultiByte( CP_ACP,
                                                        0,
                                                        &wch,
                                                        1,
                                                        (LPSTR) mbstr,
                                                        2,
                                                        NULL,
                                                        NULL );

                    ch = mbstr[0];
                    pszSrc += (3 - cchMultiByte);

                    // WinSE 12843: Security Fix, Index should be updated for this character
                    index += (( ch >= 0x80) ? 0 : p_rgIndexForChar[ch]);

                } else if ((ch & 0xe0) == 0xc0)
                {
                    // handle two byte case
                    // 110xxxxx 10xxxxxx

                    wch = (wchar_t) (((ch & 0x1f) << 6) | (chTrail1 & 0x3f));

                    cchMultiByte = WideCharToMultiByte( CP_ACP,
                                                        0,
                                                        &wch,
                                                        1,
                                                        (LPSTR) mbstr,
                                                        2,
                                                        NULL,
                                                        NULL );

                    ch = mbstr[0];
                    pszSrc += (2 - cchMultiByte);

                    // WinSE 12843: Security Fix, Index should be updated for this character
                    index += (( ch >= 0x80) ? 0 : p_rgIndexForChar[ch]);
                }

            } else {
                //
                // get ready to emit 2nd byte of converted character
                //
                ch = mbstr[1];
                cchMultiByte = 0;
            }
        }


        //
        //  Perform the action associated with the state.
        //

        switch( p_ActionTable[index] )
        {
        case ACTION_EMIT_DOT_DOT_CH :
            *pszDest++ = '.';
            /* fall through */

        case ACTION_EMIT_DOT_CH :
            *pszDest++ = '.';
            /* fall through */

        case ACTION_EMIT_CH :
            *pszDest++ = (CHAR ) ch;
            /* fall through */

        case ACTION_NOTHING :
            break;

        case ACTION_BACKUP :
            if( (pszDest > ( (UCHAR *) pszPath + 1 ) ) && (*pszPath == '/'))
            {
                pszDest--;
                DBG_ASSERT( *pszDest == '/' );

                *pszDest = '\0';
                pszDest = (UCHAR *) strrchr( pszPath, '/') + 1;
            }

            *pszDest = '\0';
            break;

        default :
            DBG_ASSERT( !"Invalid action code in state table!" );
            index = IndexFromState(0) + 2;    // move to invalid state
            DBG_ASSERT( p_StateTable[index] == 4);
            *pszDest++ = '\0';
            break;
        }

    } while( p_StateTable[index] != 4 );

    //
    // point to terminating nul
    //
    if (p_ActionTable[index] == ACTION_EMIT_CH) {
        pszDest--;
    }
    
    DBG_ASSERT(*pszDest == '\0' && pszDest > (UCHAR*) pszPath);

    return DIFF(pszDest - (UCHAR*)pszPath);
}   // CanonURL()



DWORD
InitializeStringFunctions(
    VOID
)
/*++
  Initializes the string function pointers depending on the system code page.
  If the code page doesn't have multi-byte characters, then pointers 
  resolve to regular single byte functions.  Otherwise, they resolve to more
  expense multi-byte functions.

  Arguments:
     None

  Returns:
     0 if successful, else Win32 Error

--*/
{
    CPINFO          CodePageInfo;
    BOOL            bRet;
    HKEY            hKey;
    DWORD           dwRet;
   
    bRet = GetCPInfo( CP_ACP, &CodePageInfo );
    
    if ( bRet && CodePageInfo.MaxCharSize == 1 )
    {
        g_pfnStrlwr     = (PFNSTRCASE)  _strlwr;
        g_pfnStrupr     = (PFNSTRCASE)  _strupr;
        g_pfnStrnicmp   = (PFNSTRNICMP) _strnicmp;
        g_pfnStricmp    = (PFNSTRICMP)  _stricmp;
        g_pfnStrlen     = (PFNSTRLEN)   strlen;
        g_pfnStrrchr    = (PFNSTRRCHR)  strrchr;
    }

    // 
    // Do we need to hack for Korean?
    //
    
    dwRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          UTF8_HACK_KEY,
                          0,
                          KEY_READ,
                          &hKey );
    if ( dwRet == ERROR_SUCCESS )
    {
        DWORD               dwValue = 0;
        DWORD               cbValue = sizeof( dwValue );
        
        dwRet = RegQueryValueEx( hKey,
                                 UTF8_HACK_VALUE,
                                 NULL,
                                 NULL,
                                 (LPBYTE) &dwValue,
                                 &cbValue );
        if ( dwRet == ERROR_SUCCESS )
        {
            g_fFavorDBCS = !!dwValue;
        }
        
        DBG_REQUIRE( RegCloseKey( hKey ) == ERROR_SUCCESS );
    }

    return ERROR_SUCCESS;
}

UCHAR *
IISstrupr(
    UCHAR *             pszString
)
/*++
  Wrapper for strupr() call.

  Arguments:
     pszString - String to uppercase

  Returns:
     Pointer to string uppercased

--*/
{
    DBG_ASSERT( g_pfnStrupr != NULL );

    return g_pfnStrupr( pszString );
}

UCHAR *
IISstrlwr(
    UCHAR *             pszString
)
/*++
  Wrapper for strlwr() call.

  Arguments:
     pszString - String to lowercase

  Returns:
     Pointer to string lowercased

--*/
{
    DBG_ASSERT( g_pfnStrlwr != NULL );

    return g_pfnStrlwr( pszString );
}

size_t
IISstrlen(
    UCHAR *             pszString
)
/*++
  Wrapper for strlen() call.

  Arguments:
     pszString - String to check

  Returns:
     Length of string

--*/
{
    DBG_ASSERT( g_pfnStrlen != NULL );
    
    return g_pfnStrlen( pszString );
}

INT
IISstrnicmp(
    UCHAR *             pszString1,
    UCHAR *             pszString2,
    size_t              size
)
/*++
  Wrapper for strnicmp() call.

  Arguments:
     pszString1 - String1
     pszString2 - String2
     size - # characters to compare upto

  Returns:
     0 if equal, -1 if pszString1 < pszString2, else 1

--*/
{
    DBG_ASSERT( g_pfnStrnicmp != NULL );
    
    return g_pfnStrnicmp( pszString1, pszString2, size );
}

    
INT
IISstricmp(
    UCHAR *             pszString1,
    UCHAR *             pszString2
)
/*++
  Wrapper for stricmp() call.

  Arguments:
     pszString1 - String1
     pszString2 - String2

  Returns:
     0 if equal, -1 if pszString1 < pszString2, else 1

--*/
{
    DBG_ASSERT( g_pfnStricmp != NULL );
    
    return g_pfnStricmp( pszString1, pszString2 );
}


// like strncpy, but doesn't pad the end of the string with zeroes, which
// is expensive when `source' is short and `count' is large
char *
IISstrncpy(
    char * dest,
    const char * source,
    size_t count)
{
    char *start = dest;
    
    while (count && (*dest++ = *source++))    /* copy string */
        count--;
    
    if (count)                              /* append one zero */
        *dest = '\0';
    
    return(start);
}

UCHAR *
IISstrrchr(
    const UCHAR *       pszString,
    UINT                c
)
/*++
  Wrapper for strrchr() call.

  Arguments:
     pszString - String
     c         - Character to find.

  Returns:
     pointer to the char or NULL.

--*/
{
    DBG_ASSERT( g_pfnStrrchr != NULL );
    
    return g_pfnStrrchr( pszString, c );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\strings.cpp ===
#include "precomp.hxx"

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <irtlmisc.h>


// stristr (stolen from fts.c, wickn)
//
// case-insensitive version of strstr.
// stristr returns a pointer to the first occurrence of
// pszSubString in pszString.  The search does not include
// terminating nul characters.
//
// NOTE: This routine is NOT DBCS-safe?

const char*
stristr(const char* pszString, const char* pszSubString)
{
    const char *cp1 = (const char*) pszString, *cp2, *cp1a;
    char first;

    // get the first char in string to find
    first = pszSubString[0];

    // first char often won't be alpha
    if (isalpha((UCHAR)first))
    {
        first = (char) tolower(first);
        for ( ; *cp1  != '\0'; cp1++)
        {
            if (tolower(*cp1) == first)
            {
                for (cp1a = &cp1[1], cp2 = (const char*) &pszSubString[1];
                     ;
                     cp1a++, cp2++)
                {
                    if (*cp2 == '\0')
                        return cp1;
                    if (tolower(*cp1a) != tolower(*cp2))
                        break;
                }
            }
        }
    }
    else
    {
        for ( ; *cp1 != '\0' ; cp1++)
        {
            if (*cp1 == first)
            {
                for (cp1a = &cp1[1], cp2 = (const char*) &pszSubString[1];
                     ;
                     cp1a++, cp2++)
                {
                    if (*cp2 == '\0')
                        return cp1;
                    if (tolower(*cp1a) != tolower(*cp2))
                        break;
                }
            }
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\timer.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    timer.c

Abstract:

    Wrap-proof timer routines.

    The purpose of this module is to create a timer function which
    returns a time in seconds and eliminates all timer wrapping issues.

    These routines are non-DNS specific and may be picked up
    cleanly by any module.

    For DNS the added instructions are well worth the cost in that it
    eliminates any issue involving cleaning packet queues or resetting
    cache timeouts when millisecond timer (GetCurrentTime) wraps.

Author:

    Jim Gilroy (jamesg)     9-Sep-1995

Environment:

    Win32 User Mode

Project:

    Common Code for Internet Services

Functions Exported:

    InitializeSecondsTimer()
    TerminateSecondsTimer()
    GetCurrentTimeInSeconds()
    GetCurrentTimeInMilliseconds()

Revision History:
    MuraliK  14-Nov-1995 Made multi thread safe.
    
--*/


#include "precomp.hxx"


//
//  Timer globals
//

CRITICAL_SECTION    g_csTimerWrap;



VOID
InitializeSecondsTimer(
    VOID
    )
/*++

Routine Description:

    Initialize DNS timer.

Arguments:

    None.

Return Value:

    None.

--*/
{
    INITIALIZE_CRITICAL_SECTION( &g_csTimerWrap );

} // InitializeSecondsTimer()

VOID
TerminateSecondsTimer(
    VOID
    )
/*++

Routine Description:

    Terminate DNS timer.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DeleteCriticalSection( &g_csTimerWrap );

} // TerminateSecondsTimer()



DWORD
GetCurrentTimeInSeconds(
    VOID
    )
/*++

Routine Description:

    Get current time in seconds.

Arguments:

    None.

Return Value:

    Time since boot in seconds.

--*/
{
    DWORD   dwCurrentTime;
    static DWORD    dwPreviousTime = 0;     // previous GetCurrentTime()
    static DWORD    dwWrapTime = 0;         // accumulated time (s) from timer
                                            //  wraps

    dwCurrentTime = GetCurrentTime();

    //
    //  check for timer wrap
    //
    //  Check that previous time is bigger, but since multi-threaded,
    //  occasionally preempted before making test and another thread
    //  may reset dwPreviousTime.  So we also explicitly verify the
    //  switch from a very large DWORD to a small one.
    //
    //  Note:  that we completely avoid using the CS, except right at
    //  an actual timer wrap.   Hence the cost for this function
    //  remains low.
    //

    if ( dwPreviousTime > dwCurrentTime
            &&
         (LONG)dwPreviousTime < 0
            &&
         (LONG)dwCurrentTime > 0 )
    {
        //
        //  detected timer wrap
        //
        //  inside CS, verify actual wrap and reset dwPreviousTime
        //  so other waiting threads will NOT count wrap
        //

        EnterCriticalSection( &g_csTimerWrap );

        if ( (LONG)dwPreviousTime < 0
                &&
            (LONG)dwCurrentTime > 0 )
        {
            dwPreviousTime = dwCurrentTime;
            dwWrapTime += (0xffffffff / 1000);
        }
        LeaveCriticalSection( &g_csTimerWrap );
    }
    dwPreviousTime = dwCurrentTime;

    return (dwCurrentTime / 1000 + dwWrapTime);
}


__int64
GetCurrentTimeInMilliseconds(
    VOID
    )
/*++

Routine Description:

    Get current time in milliseconds.

Arguments:

    None.

Return Value:

    Time since boot in seconds.

--*/
{
    DWORD   dwCurrentTime;
    static DWORD    dwPreviousTime = 0;     // previous GetCurrentTime()
    static DWORD    dwWrapTime = 0;         // accumulated time (s) from timer
                                            //  wraps

    dwCurrentTime = GetTickCount();

    //
    //  check for timer wrap
    //
    //  Check that previous time is bigger, but since multi-threaded,
    //  occasionally preempted before making test and another thread
    //  may reset dwPreviousTime.  So we also explicitly verify the
    //  switch from a very large DWORD to a small one.
    //
    //  Note:  that we completely avoid using the CS, except right at
    //  an actual timer wrap.   Hence the cost for this function
    //  remains low.
    //

    if ( dwPreviousTime > dwCurrentTime
            &&
         (LONG)dwPreviousTime < 0
            &&
         (LONG)dwCurrentTime > 0 )
    {
        //
        //  detected timer wrap
        //
        //  inside CS, verify actual wrap and reset dwPreviousTime
        //  so other waiting threads will NOT count wrap
        //

        EnterCriticalSection( &g_csTimerWrap );

        if ( (LONG)dwPreviousTime < 0
                &&
            (LONG)dwCurrentTime > 0 )
        {
            dwPreviousTime = dwCurrentTime;
            ++dwWrapTime;
        }
        LeaveCriticalSection( &g_csTimerWrap );
    }
    dwPreviousTime = dwCurrentTime;

    return (((__int64)dwWrapTime)<<32) |  dwCurrentTime;
}


//
//  End of timer.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\strlog.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    strlog.cxx

Abstract:

    This module implements printing strings to a tracelog.

Author:

    George V. Reilly (GeorgeRe)        22-Jun-1998

Revision History:

--*/


#include "precomp.hxx"
#include <strlog.hxx>
#include <stdio.h>
#include <stdarg.h>



CStringTraceLog::CStringTraceLog(
    UINT cchEntrySize /* = 80 */,
    UINT cLogSize /* = 100 */)
{
    m_Signature = SIGNATURE;
    m_cch = min(max(cchEntrySize, MIN_CCH), MAX_CCH);
    m_cch = (m_cch + sizeof(DWORD) - 1) & ~sizeof(DWORD);
    m_ptlog = CreateTraceLog(cLogSize, 0,
                             sizeof(CLogEntry) - MAX_CCH + m_cch);
}



CStringTraceLog::~CStringTraceLog()
{
    DestroyTraceLog(m_ptlog);
    m_Signature = SIGNATURE_X;
}



LONG __cdecl
CStringTraceLog::Printf(
    LPCSTR pszFormat,
        ...)
{
    DBG_ASSERT(this->m_Signature == SIGNATURE);
    DBG_ASSERT(this->m_ptlog != NULL);
    
    CLogEntry le;
    va_list argsList;

    va_start(argsList, pszFormat);
    INT cchOutput = _vsnprintf(le.m_ach, m_cch, pszFormat, argsList);
    va_end(argsList);

    //
    // The string length is long, we get back -1.
    //   so we get the string length for partial data.
    //

    if ( cchOutput == -1 ) {
        
        //
        // terminate the string properly,
        //   since _vsnprintf() does not terminate properly on failure.
        //
        cchOutput = m_cch - 1;
        le.m_ach[cchOutput] = '\0';
    }

    return WriteTraceLog(m_ptlog, &le);
}



LONG
CStringTraceLog::Puts(
    LPCSTR psz)
{
    DBG_ASSERT(this->m_Signature == SIGNATURE);
    DBG_ASSERT(this->m_ptlog != NULL);
    
    CLogEntry le;

    strncpy(le.m_ach, psz, m_cch);
    le.m_ach[m_cch - 1] = '\0';
    return WriteTraceLog(m_ptlog, &le);
}


    
void
CStringTraceLog::ResetLog()
{
    DBG_ASSERT(this->m_Signature == SIGNATURE);
    DBG_ASSERT(this->m_ptlog != NULL);
    
    ResetTraceLog(m_ptlog);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\tracelog.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tracelog.c

Abstract:

    This module implements a trace log.

    A trace log is a fast, in-memory, thread safe activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <pudebug.h>
#include <tracelog.h>


#define ALLOC_MEM(cb) (PVOID)LocalAlloc( LPTR, (cb) )
#define FREE_MEM(ptr) (VOID)LocalFree( (HLOCAL)(ptr) )



PTRACE_LOG
CreateTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader,
    IN LONG EntrySize
    )
/*++

Routine Description:

    Creates a new (empty) trace log buffer.

Arguments:

    LogSize - The number of entries in the log.

    ExtraBytesInHeader - The number of extra bytes to include in the
        log header. This is useful for adding application-specific
        data to the log.

    EntrySize - The size (in bytes) of each entry.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--*/
{

    LONG totalSize;
    PTRACE_LOG log;

    //
    // Sanity check the parameters.
    //

    DBG_ASSERT( LogSize > 0 );
    DBG_ASSERT( EntrySize > 0 );
    DBG_ASSERT( ( EntrySize & 3 ) == 0 );

    //
    // Allocate & initialize the log structure.
    //

    totalSize = sizeof(*log) + ( LogSize * EntrySize ) + ExtraBytesInHeader;
    DBG_ASSERT( totalSize > 0 );

    log = (PTRACE_LOG)ALLOC_MEM( totalSize );

    //
    // Initialize it.
    //

    if( log != NULL ) {

        RtlZeroMemory( log, totalSize );

        log->Signature = TRACE_LOG_SIGNATURE;
        log->LogSize = LogSize;
        log->NextEntry = -1;
        log->EntrySize = EntrySize;
        log->LogBuffer = (PUCHAR)( log + 1 ) + ExtraBytesInHeader;
    }

    return log;

}   // CreateTraceLog


VOID
DestroyTraceLog(
    IN PTRACE_LOG Log
    )
/*++

Routine Description:

    Destroys a trace log buffer created with CreateTraceLog().

Arguments:

    Log - The trace log buffer to destroy.

Return Value:

    None.

--*/
{
	if ( Log != NULL ) {
        DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );

        Log->Signature = TRACE_LOG_SIGNATURE_X;
        FREE_MEM( Log );
    }

}   // DestroyTraceLog


LONG
WriteTraceLog(
    IN PTRACE_LOG Log,
    IN PVOID Entry
    )
/*++

Routine Description:

    Writes a new entry to the specified trace log.

Arguments:

    Log - The log to write to.

    Entry - Pointer to the data to write. This buffer is assumed to be
        Log->EntrySize bytes long.

Return Value:

    Index of entry in log.  This is useful for correlating the output
    of !inetdbg.ref to a particular point in the output debug stream

--*/
{

    PUCHAR target;
    LONG index;

    DBG_ASSERT( Log != NULL );
    DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );
    DBG_ASSERT( Entry != NULL );

    //
    // Find the next slot, copy the entry to the slot.
    //

    index = InterlockedIncrement( &Log->NextEntry ) % Log->LogSize;
    target = Log->LogBuffer + ( index * Log->EntrySize );

    RtlCopyMemory(
        target,
        Entry,
        Log->EntrySize
        );

    return index;
}   // WriteTraceLog


VOID
ResetTraceLog(
    IN PTRACE_LOG Log
    )
{

    DBG_ASSERT( Log != NULL );
    DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );

    RtlZeroMemory(
        ( Log + 1 ),
        Log->LogSize * Log->EntrySize
        );

    Log->NextEntry = -1;

}   // ResetTraceLog
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\win32obj.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    win32obj.c

Abstract:

    This module contains helper functions for creating debug-specific
    named Win32 objects. Functions are included for named events,
    semaphores, and mutexes.

    Object names created by these routines have the following format:

        filename.ext:line_number member:address PID:pid

    Where:

        filename.ext = The file name where the object was created.

        line_number = The line number within the file.

        member = The member/global variable name where the handle is
            stored. This name is provided by the caller, but is usually
            of the form "g_Global" for globals and "CLASS::m_Member" for
            class members.

        address = An address, used to guarantee uniqueness of the objects
            created. This is provided by the caller. For global variables,
            this is typically the address of the global. For class members,
            this is typically the address of the containing class.

        pid = The current process ID. This ensures uniqueness across all
            processes.

    Here are a couple of examples:

        main.cxx:796 g_hShutdownEvent:683a42bc PID:373

        resource.cxx:136 RTL_RESOURCE::SharedSemaphore:00250970 PID:373

Author:

    Keith Moore (keithmo)        23-Sep-1997

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <pudebug.h>


#define MAX_OBJECT_NAME 256 // chars


LONG g_PuDbgEventsCreated = 0;
LONG g_PuDbgSemaphoresCreated = 0;
LONG g_PuDbgMutexesCreated = 0;



LPSTR
PuDbgpBuildObjectName(
    IN LPSTR ObjectNameBuffer,
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address
    )

/*++

Routine Description:

    Internal routine that builds an appropriate object name based on
    the file name, line number, member name, address, and process ID.

Arguments:

    ObjectNameBuffer - Pointer to the target buffer for the name.

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

Return Value:

    LPSTR - Pointer to ObjectNameBuffer if successful, NULL otherwise.

    N.B. This routine always returns NULL when running under Win9x.

--*/

{

    PLATFORM_TYPE platformType;
    LPSTR fileNamePart;
    LPSTR result;

    //
    // We have no convenient way to dump objects w/ names from
    // Win9x, so we'll only enable this functionality under NT.
    //

    platformType = IISGetPlatformType();
    result = NULL;

    if( platformType == PtNtServer ||
        platformType == PtNtWorkstation ) {

        //
        // Find the filename part of the incoming source file name.
        //

        fileNamePart = strrchr( FileName, '\\' );

        if( fileNamePart == NULL ) {
            fileNamePart = strrchr( FileName, '/' );
        }

        if( fileNamePart == NULL ) {
            fileNamePart = strrchr( FileName, ':' );
        }

        if( fileNamePart == NULL ) {
            fileNamePart = FileName;
        } else {
            fileNamePart++;
        }

        //
        // Ensure we don't overwrite our object name buffer.
        //

        if( ( sizeof(":1234567890 :12345678 PID:1234567890") +
              strlen( fileNamePart ) +
              strlen( MemberName ) ) < MAX_OBJECT_NAME ) {

            wsprintfA(
                ObjectNameBuffer,
                "%s:%lu %s:%08lx PID:%lu",
                fileNamePart,
                LineNumber,
                MemberName,
                Address,
                GetCurrentProcessId()
                );

            result = ObjectNameBuffer;

        }

    }

    return result;

}   // PuDbgpBuildObjectName


HANDLE
PuDbgCreateEvent(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL ManualReset,
    IN BOOL InitialState
    )

/*++

Routine Description:

    Creates a new event object.

Arguments:

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

    ManualReset - TRUE to create a manual reset event, FALSE to create
        an automatic reset event.

    InitialState - The intitial state of the event object.

Return Value:

    HANDLE - Handle to the object if successful, NULL otherwise.

--*/

{

    LPSTR objName;
    HANDLE objHandle;
    CHAR objNameBuffer[MAX_OBJECT_NAME];

    objName = PuDbgpBuildObjectName(
                  objNameBuffer,
                  FileName,
                  LineNumber,
                  MemberName,
                  Address
                  );

    objHandle = CreateEventA(
                    NULL,                       // lpEventAttributes
                    ManualReset,                // bManualReset
                    InitialState,               // bInitialState
                    objName                     // lpName
                    );

    if( objHandle != NULL ) {
        InterlockedIncrement( &g_PuDbgEventsCreated );
    }

    return objHandle;

}   // PuDbgCreateEvent


HANDLE
PuDbgCreateSemaphore(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN LONG InitialCount,
    IN LONG MaximumCount
    )

/*++

Routine Description:

    Creates a new semaphore object.

Arguments:

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

    InitialCount - The initial count of the semaphore.

    MaximumCount - The maximum count of the semaphore.

Return Value:

    HANDLE - Handle to the object if successful, NULL otherwise.

--*/

{

    LPSTR objName;
    HANDLE objHandle;
    CHAR objNameBuffer[MAX_OBJECT_NAME];

    objName = PuDbgpBuildObjectName(
                  objNameBuffer,
                  FileName,
                  LineNumber,
                  MemberName,
                  Address
                  );

    objHandle = CreateSemaphoreA(
                    NULL,                       // lpSemaphoreAttributes
                    InitialCount,               // lInitialCount
                    MaximumCount,               // lMaximumCount
                    objName                     // lpName
                    );

    if( objHandle != NULL ) {
        InterlockedIncrement( &g_PuDbgSemaphoresCreated );
    }

    return objHandle;

}   // PuDbgCreateSemaphore


HANDLE
PuDbgCreateMutex(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL InitialOwner
    )

/*++

Routine Description:

    Creates a new mutex object.

Arguments:

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

    InitialOwner - TRUE if the mutex should be created "owned".

Return Value:

    HANDLE - Handle to the object if successful, NULL otherwise.

--*/

{

    LPSTR objName;
    HANDLE objHandle;
    CHAR objNameBuffer[MAX_OBJECT_NAME];

    objName = PuDbgpBuildObjectName(
                  objNameBuffer,
                  FileName,
                  LineNumber,
                  MemberName,
                  Address
                  );

    objHandle = CreateMutexA(
                    NULL,                       // lpMutexAttributes
                    InitialOwner,               // bInitialOwner,
                    objName                     // lpName
                    );

    if( objHandle != NULL ) {
        InterlockedIncrement( &g_PuDbgMutexesCreated );
    }

    return objHandle;

}   // PuDbgCreateMutex
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl2\aucommon.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\aucommon.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\sched-test\sched-test.cpp ===
/*++

   Copyright    (c)    1999     Microsoft Corporation

   Module Name:

       sched-test.cpp

   Abstract:

        This module tests the IIS Scheduler code


   Author:

       George V. Reilly      (GeorgeRe)        May-1999

   Project:

        Internet Servers Common Server DLL

   Revisions:
--*/


#include <acache.hxx>
#include <issched.hxx>
#include <irtlmisc.h>
#include <dbgutil.h>

#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(SchedTestGuid,
0x7a09df80, 0x2dbf, 0x11d3, 0x88, 0x84, 0x00, 0x50, 0x04, 0x60, 0x50, 0x4c);
#else
DECLARE_DEBUG_VARIABLE();
#endif

DECLARE_DEBUG_PRINTS_OBJECT();


#define MAX_WORK_ITEMS 10
#define MAX_TESTS       5

class CCookie
{
public:
    CCookie()
        : m_dwCookie(0),
          m_dwSleep(0)
    {}

    DWORD   m_dwCookie;
    DWORD   m_dwSleep;
};

CCookie g_aCookies[MAX_TESTS][MAX_WORK_ITEMS];

VOID
Callback(
    void* pvContext)
{
    CCookie* pc = (CCookie*) pvContext;
    DBG_ASSERT(pc != NULL  &&  pc >= &g_aCookies[0][0]);

    int nRow = (pc - &g_aCookies[0][0]) / MAX_WORK_ITEMS;
    int nCol = (pc - &g_aCookies[0][0]) % MAX_WORK_ITEMS;

    printf("\tCallback [%d][%d] starting, sleeping for %d ms\n",
           nRow, nCol, pc->m_dwSleep);

    Sleep(pc->m_dwSleep);

    printf("\tCallback [%d][%d] finishing\n", nRow, nCol);
}

void
TestScheduler(
    int n,
    bool fFlush)
{
    printf("Initializing TestScheduler %d, %sflush\n",
           n, fFlush ? "" : "no ");

    // Initialize the Scheduler
    InitializeIISRTL();

#ifdef _NO_TRACING_
    SET_DEBUG_FLAGS(DEBUG_ERROR);
    CREATE_DEBUG_PRINT_OBJECT("sched-test");
#else
    CREATE_DEBUG_PRINT_OBJECT("sched-test", SchedTestGuid);
#endif

    int i;

    for (i = 0;  i < MAX_WORK_ITEMS;  i++)
    {
        g_aCookies[n][i].m_dwSleep = (i * 500 + 1);
        g_aCookies[n][i].m_dwCookie =
            ScheduleWorkItem(Callback, &g_aCookies[n][i], 100*i);
        DBG_ASSERT(g_aCookies[n][i].m_dwCookie != 0);
        printf("TestScheduler %d: ScheduleWorkItem(%d) = %u\n",
               n, i, g_aCookies[n][i].m_dwCookie);
    }

    Sleep(2000);

    if (fFlush)
    {
        for (i = MAX_WORK_ITEMS;  --i >= 0;  )
            RemoveWorkItem(g_aCookies[n][i].m_dwCookie);
    }

    DELETE_DEBUG_PRINT_OBJECT();

    TerminateIISRTL();

    printf("Terminated TestScheduler %d\n", n);
}



int __cdecl
main(
    int argc,
    char **argv)
{
    for (int n = 0;  n < MAX_TESTS;  ++n)
        TestScheduler(n, true);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl2\alloc.cpp ===
#include "precomp.hxx"
#include "..\iisrtl\alloc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl2\datetime.cxx ===
#include "..\iisrtl\datetime.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\hashtest\hashtest.cpp ===
/* Test driver for class HashTable             */
/* Author: Paul Larson, palarson@microsoft.com */
/* Much hacked upon by George V. Reilly, georgere@microsoft.com */

#include <acache.hxx>
#include <windows.h>
#include <dbgutil.h>

#include <process.h>
#include <stdlib.h>
#include <stdio.h>
#include <io.h> 
#include <stddef.h>
#include <conio.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <malloc.h> 

#define SAMPLE_LKRHASH_TESTCLASS

// disable warning messages about truncating extremly long identifiers
// #pragma warning (disable : 4786)
#include <lkrhash.h>


#define MAXKEYS      1000000
#define MAX_THREADS  MAXIMUM_WAIT_OBJECTS

DECLARE_DEBUG_PRINTS_OBJECT();

void test_iterators(double highload, int initsize, int nsubtbls);
void print_table_statistics(const CLKRHashTableStats& stats);
#ifdef LOCK_INSTRUMENTATION
void print_lock_statistics(const CLKRHashTableStats &stats);
#endif
int  expand_key_set(int maxkeys, int numkeys, bool fVerbose) ;
void __cdecl exercise_table(void *pinput) ;


// A string wrapper class that keeps track of the length of the string data.
// A more useful string class would refcount the data and have copy-on-write
// semantics (or use MFC's CString or STL's string classes).

class CStr
{
public:
    const char* m_psz;
    int         m_cch;
    
    static int sm_cchMax;

    CStr()
        :  m_psz(NULL),
           m_cch(0)
    { 
    }
    
    void Set(const char* psz)
    { 
        free((void*) m_psz);
        m_psz = _strdup(psz);
        m_cch = strlen(m_psz);
        sm_cchMax = max(m_cch, sm_cchMax);
    }

    ~CStr()
    {
        free((void*) m_psz);
    }
};

// length of longest string seen
int CStr::sm_cchMax = 0;


// a word from the data file, which contains one 'word' per line (may
// include spaces).

class CWord
{
public:
    int    m_cNotFound;
    CStr   m_str;
    bool   m_fInserted;
    bool   m_fIterated;
    LONG   m_cRefs;
    
    CWord()
        : m_cNotFound(0),
          m_fInserted(false),
          m_fIterated(false),
          m_cRefs(0)
    { 
    }
    
    ~CWord()
    {
        IRTLASSERT(m_cRefs == 0);
#ifdef _DEBUG
        if (m_cRefs != 0)
            TRACE("%s: %d\n", m_str.m_psz, m_cRefs);
#endif
    }
};



// A hash table of CWords, indexed by CStr*s.
class CWordHash
    : public CTypedHashTable<CWordHash, CWord, const CStr*>
{
public:
    static bool sm_fCaseInsensitive;
    static int  sm_nLastChars;
    
    static const CStr*
    ExtractKey(const CWord* pKey)
    {
        return &pKey->m_str;
    }

    static DWORD
    CalcKeyHash(const CStr* pstrKey)
    {
        const char* psz = pstrKey->m_psz;

        // use only the last few chars instead of whole string?
        if (sm_nLastChars > 0  &&  pstrKey->m_cch >= sm_nLastChars)
            psz = pstrKey->m_psz + pstrKey->m_cch - sm_nLastChars;

        IRTLASSERT(pstrKey->m_psz <= psz
                   &&  psz < pstrKey->m_psz + pstrKey->m_cch);

        if (sm_fCaseInsensitive)
            return HashStringNoCase(psz, pstrKey->m_cch);
        else
            return HashString(psz, pstrKey->m_cch);
    }

    static bool
    EqualKeys(const CStr* pstrKey1, const CStr* pstrKey2)
    {
        if (pstrKey1->m_cch != pstrKey2->m_cch)
            return false;
        else if (sm_fCaseInsensitive)
            return ((pstrKey1->m_psz[0] & 0xDF) == (pstrKey2->m_psz[0] & 0xDF)
                    &&  _stricmp(pstrKey1->m_psz, pstrKey2->m_psz) == 0);
        else
            return (pstrKey1->m_psz[0] == pstrKey2->m_psz[0]
                    &&  strcmp(pstrKey1->m_psz, pstrKey2->m_psz) == 0);
    }

    static void
    AddRefRecord(CWord* pKey, int nIncr)
    {
        pKey->m_cRefs += nIncr;
    }

    CWordHash(
        double          maxload,    // Bound on avg chain length
        size_t          initsize,   // Initial size of hash table.
        size_t          num_subtbls // #subordinate hash tables.
        )
        : CTypedHashTable<CWordHash, CWord, const CStr*>
            ("wordhash", maxload, initsize, num_subtbls)
    {}


    static const char*
    HashMethod()
    {
        char szLast[20];
        static char s_sz[50];

        if (sm_nLastChars > 0)
            sprintf(szLast, "last %d", sm_nLastChars);
        else
            strcpy(szLast, "all");

        sprintf(s_sz, "case-%ssensitive, %s chars",
                sm_fCaseInsensitive ? "in" : "", szLast);

        return s_sz;
    }
};


bool CWordHash::sm_fCaseInsensitive = true;
int  CWordHash::sm_nLastChars = 16;


// globals
int        g_nokeys=0 ;
CWord      g_wordtable[MAXKEYS];


struct thread_data
{
    CWordHash* ptbl ;

    int    threadno ;
    int    first_key ;
    int    last_key ;
    int    rounds ;
    int    lookup_freq ;
    float  highload ;

    int    cinserts ;
    int    cdeletes ;
    int    clookups ;
    int    cfailures ;

    double duration ;
    HANDLE hevFinished;
} ;


class CFoo {
public:
    BYTE  m_b;
    char sz[12];
};

class CFooHashTable
    : public CTypedHashTable<CFooHashTable, const CFoo, BYTE>
{
public:
    CFooHashTable()
        : CTypedHashTable<CFooHashTable, const CFoo, BYTE>("foo") {}
    static BYTE  ExtractKey(const CFoo* pFoo)        {return pFoo->m_b;}
    static DWORD CalcKeyHash(BYTE nKey)                 {return nKey;}
    static bool  EqualKeys(BYTE nKey1, BYTE nKey2)       {return nKey1 == nKey2;}
    static void  AddRefRecord(const CFoo* pFoo, int nIncr) {/* do nothing*/}
};

void
InsertFoo()
{
    CFoo foo;
    const CFoo *pfoo;
    CFooHashTable foohash;

    foohash.InsertRecord(&foo);
    foohash.FindKey(7, &pfoo);

    void* pv = &foohash;
    BYTE b = reinterpret_cast<BYTE>(pv);
}


class CIniFileSettings
{
public:
    CHAR    m_szIniFile[MAX_PATH]; // the .ini file
    CHAR    m_szDataFile[MAX_PATH]; // where string data table lives
    int     m_nMaxKeys;         // maximum number of keys
    double  m_dblHighLoad;      // maximum load of table (avg. bucket length)
    DWORD   m_nInitSize;        // initsize (1 => "small", 2 => "medium",
                                //   3 => "large", other => exact)
    int     m_nSubTables;       // num subtables (0 => heuristic)
    int     m_nLookupFreq;      // lookup frequency
    int     m_nMaxThreads;      // max threads
    int     m_nRounds;          // num rounds
    int     m_nSeed;            // random seed
    bool    m_fCaseInsensitive; // case-insensitive
    int     m_nLastChars;       // num last chars (0 => all chars)
    WORD    m_wTableSpin;       // table lock spin count (0 => no spinning on
                                //   MP machines)
    WORD    m_wBucketSpin;      // bucket lock spin count (0 => no MP spinning)
    double  m_dblSpinAdjFctr;   // spin adjustment factor
    bool    m_fTestIterators;   // run test_iterators?

    void    ReadIniFile(LPCSTR pszIniFile);
};

void
CIniFileSettings::ReadIniFile(
	LPCSTR pszIniFile)
{
    strncpy(m_szIniFile, pszIniFile, MAX_PATH);
    TRACE("ReadIniFile(%s)\n", m_szIniFile);
    
	char szTemp[100];
    DWORD dwSize;
    const char szInvalidDefault[] = "??";

    dwSize = ::GetPrivateProfileString("HashTest", "DataFile",
                                       szInvalidDefault,
                                       m_szDataFile, MAX_PATH,
                                       m_szIniFile);
    TRACE("size = %d\n", dwSize);

    m_nMaxKeys = ::GetPrivateProfileInt("HashTest", "MaxKeys",
                                        MAXKEYS, m_szIniFile);
    m_nMaxKeys = max(1, m_nMaxKeys);
    m_nMaxKeys = min(m_nMaxKeys, MAXKEYS);

    dwSize = ::GetPrivateProfileString("HashTest", "MaxLoadFactor",
                                       "4", szTemp, sizeof(szTemp),
                                       m_szIniFile);
    sscanf(szTemp, "%lf", &m_dblHighLoad);
    m_dblHighLoad = max(1, m_dblHighLoad);

    m_nInitSize = ::GetPrivateProfileInt("HashTest", "InitSize",
                                         DFLT_LK_INITSIZE, m_szIniFile);

    m_nSubTables = ::GetPrivateProfileInt("HashTest", "NumSubtables",
                                          DFLT_LK_NUM_SUBTBLS, m_szIniFile);

    m_nLookupFreq = ::GetPrivateProfileInt("HashTest", "LookupFrequency",
                                           5, m_szIniFile);

    m_nMaxThreads = ::GetPrivateProfileInt("HashTest", "MaxThreads",
                                           1, m_szIniFile);
    m_nMaxThreads = min(MAX_THREADS, max(1, m_nMaxThreads));

    m_nRounds = ::GetPrivateProfileInt("HashTest", "NumRounds",
                                       1, m_szIniFile);
    m_nRounds = max(1, m_nRounds);

    m_nSeed = ::GetPrivateProfileInt("HashTest", "RandomSeed",
                                     1234, m_szIniFile);

    m_fCaseInsensitive = (::GetPrivateProfileInt("HashTest", "CaseInsensitive",
                                                0, m_szIniFile) != 0);
    CWordHash::sm_fCaseInsensitive = m_fCaseInsensitive;

    m_nLastChars = ::GetPrivateProfileInt("HashTest", "NumLastChars",
                                          0, m_szIniFile);
    CWordHash::sm_nLastChars = m_nLastChars;

    m_wTableSpin = (WORD) ::GetPrivateProfileInt("HashTest",
                                                 "TableLockSpinCount",
                                          LOCK_DEFAULT_SPINS, m_szIniFile);

    m_wBucketSpin = (WORD) ::GetPrivateProfileInt("HashTest",
                                                  "BucketLockSpinCount",
                                           LOCK_DEFAULT_SPINS, m_szIniFile);

    dwSize = ::GetPrivateProfileString("HashTest", "SpinAdjustmentFactor",
                                       "1.0", szTemp, sizeof(szTemp),
                                       m_szIniFile);
    sscanf(szTemp, "%lf", &m_dblSpinAdjFctr);
#ifdef LKRHASH_GLOBAL_LOCK
    CWordHash::GlobalLock::SetDefaultSpinAdjustmentFactor(m_dblSpinAdjFctr);
#endif
    CWordHash::TableLock::SetDefaultSpinAdjustmentFactor(m_dblSpinAdjFctr);
    CWordHash::BucketLock::SetDefaultSpinAdjustmentFactor(m_dblSpinAdjFctr);

    m_fTestIterators = (::GetPrivateProfileInt("HashTest", "TestIterators",
                                                0, m_szIniFile) != 0);
}


const char*
CommaNumber(
    int n,
    char* pszBuff)
{
    char* psz = pszBuff;
    char chComma = '\0';

    int aThousands[4];
    int iThousands = 0;
    unsigned int u = n;

    if (n < 0)
    {
        *psz++ = '-';
        u = -n;
    }

    do {
        aThousands[iThousands++] = u % 1000;
        u /= 1000;
    } while (u != 0);

    while (--iThousands >= 0)
    {
        u = aThousands[iThousands];

        if (chComma)
            *psz++ = chComma;

        int d = u % 10;
        u /= 10;
        int t = u % 10;
        u /= 10;
        int h = u;

        if (h > 0  ||  chComma)
            *psz++ = h + '0';
        if (t > 0  ||  h > 0  ||  chComma)
            *psz++ = t + '0';
        *psz++ = d + '0';

        chComma = ',';
    }

    *psz = '\0';
        
    return pszBuff;
}



int __cdecl
main(
    int argc,
    char **argv)
{
    CWordHash    *pTbl ;
    int          num_threads ;
    thread_data  de_area[MAX_THREADS] ;
    HANDLE       ahEvents[MAX_THREADS];
    CIniFileSettings ifs;
    char         sz[1024] ;
    FILE        *fp ;
    int          nodel=0;
    int          keys_per_thread ;
    int          i ;
    int          sum_ins, sum_dels, sum_lookups ;
    int          failures = 0, total_failures = 0;
    LARGE_INTEGER liFrequency, liT1, liT2;
    double       duration ;
    bool         fVerbose = false;
    CHAR         szIniFile[MAX_PATH];

    InitializeIISRTL();

#ifdef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT("hashtest");
#endif

    printf("\nTest driver for LKRhash"
#ifdef _DEBUG
           " (Debug)"
#endif
#ifdef LKR_COMPACT_DELETE
           ". (CompactDelete)"
#endif
#ifdef LKR_NEWCODE
           ". (NewCode)"
#endif
#ifdef LKR_FIND_FIRST
           ". (FindFirst)"
#endif
#ifdef LKR_SUBTABLE
           ". (Subtable)"
#endif
#ifdef LKR_MASK
           ". (Mask)"
#endif
           ".\n\n"
           ) ;

#if defined(LKRHASH_ACACHE)
    const char szAllocator[] = "ACache";
#elif defined(LKRHASH_MANODEL)
    const char szAllocator[] = "MANoDel";
#elif defined(LKRHASH_MADEL)
    const char szAllocator[] = "MADel";
#else
    const char szAllocator[] = "Default allocator (global operator new)";
#endif

    printf("%s version, memory alignment = %d bytes.\n",
           szAllocator, LKRHASH_MEM_DEFAULT_ALIGN);

    if (argc == 2)
    {
        GetFullPathName(argv[1], MAX_PATH, szIniFile, NULL);
        ifs.ReadIniFile(szIniFile);
    }
    else
    {
        fprintf(stderr, "Usage: %s ini-file\n", argv[0]);
        exit(1);
    }

#ifdef SAMPLE_LKRHASH_TESTCLASS
    Test(fVerbose);
    if (fVerbose) printf("Test succeeded\n");
#endif // SAMPLE_LKRHASH_TESTCLASS

    fp = fopen(ifs.m_szDataFile, "r" ) ;
    if (fp == NULL)
    {
        printf("Can't open file `%s'.\n", ifs.m_szDataFile) ;
        exit(1) ;
    }

    printf("Reading `%s' ", ifs.m_szDataFile);
    for (g_nokeys = 0;  g_nokeys < ifs.m_nMaxKeys;  )
    {
        if (fgets(sz, sizeof sz, fp) == NULL)
            break;
        int cch = strlen(sz);
        if (cch > 0  &&  sz[cch-1] == '\n')
            sz[--cch] = '\0';
        if (cch > 0)
            g_wordtable[g_nokeys++].m_str.Set(sz);
        if (g_nokeys % 10000 == 0)
            putchar('.');
    }

    fclose(fp) ;

    printf("\nLoaded %d keys from `%s', ",g_nokeys, ifs.m_szDataFile ) ;
    g_nokeys = expand_key_set(ifs.m_nMaxKeys, g_nokeys, true) ;
    printf(" expanded to %d keys.\n\n", g_nokeys) ;

    int cchTotal = 0, cchMin = INT_MAX, cchMax = 0;
    for (i = 0;  i < g_nokeys;  ++i)
    {
        cchTotal += g_wordtable[i].m_str.m_cch;
        cchMin    = min(cchMin, g_wordtable[i].m_str.m_cch);
        cchMax    = max(cchMax, g_wordtable[i].m_str.m_cch);
    }

    srand(ifs.m_nSeed) ;

    sprintf(sz, "%d", ifs.m_nInitSize);
    if (ifs.m_nInitSize == LK_SMALL_TABLESIZE)
        strcpy(sz, "small");
    else if (ifs.m_nInitSize == LK_MEDIUM_TABLESIZE)
        strcpy(sz, "medium");
    else if (ifs.m_nInitSize == LK_LARGE_TABLESIZE)
        strcpy(sz, "large");

    DWORD initsize2 = ifs.m_nInitSize;
    DWORD nsubtbls2 = ifs.m_nSubTables;
    LK_TABLESIZE lkts = CWordHash::NumSubTables(ifs.m_nInitSize, nsubtbls2);
    
    printf("Max load = %.1f, initsize = %s, "
           "%d subtables (%d tables, size = %d, lkts = %d).\n",
           ifs.m_dblHighLoad, sz,
           ifs.m_nSubTables, nsubtbls2, initsize2, lkts);
    printf("Lookup freq = %d, %d threads, "
           "%d round%s.\n",
           ifs.m_nLookupFreq, ifs.m_nMaxThreads,
           ifs.m_nRounds, (ifs.m_nRounds==1 ? "" : "s"));
    printf("%d keys from `%s'. Key length: avg = %d, min = %d, max = %d.\n",
           g_nokeys, ifs.m_szDataFile, cchTotal / g_nokeys, cchMin, cchMax);
    printf("Base Table = %s.  "
           "Hash method = %s.\n",
           CWordHash::BaseHashTable::ClassName(),
           CWordHash::HashMethod());
#ifdef LKRHASH_GLOBAL_LOCK
    printf("GlobalLock = %s, "
           "%d bytes, "
           "Spin Count = %hd, "
           "Adj Factor = %.1f.\n",
           CWordHash::GlobalLock::ClassName(),
           sizeof(CWordHash::GlobalLock),
           ifs.m_wTableSpin,
           CWordHash::GlobalLock::GetDefaultSpinAdjustmentFactor());
#endif
    printf("TableLock = %s, "
           "%d bytes, "
           "Spin Count = %hd, "
           "Adj Factor = %.1f.\n",
           CWordHash::TableLock::ClassName(),
           sizeof(CWordHash::TableLock),
           ifs.m_wTableSpin,
           CWordHash::TableLock::GetDefaultSpinAdjustmentFactor());

    printf("BucketLock = %s, "
           "%d bytes, "
           "Spin Count = %hd, "
           "Adj Factor = %.1f.\n",
           CWordHash::BucketLock::ClassName(),
           sizeof(CWordHash::BucketLock),
           ifs.m_wBucketSpin,
           CWordHash::BucketLock::GetDefaultSpinAdjustmentFactor());

#ifdef LOCK_PER_LOCK_SPINCOUNTS
    printf("Per");
#else
    printf("No per");
#endif
    printf("-lock spincounts.  #CPUs = %d.  Random seed = %d.  "
           "Nodes/Clump = %d.\n",
           NumProcessors(), ifs.m_nSeed,
#ifdef LKR_NEWCODE
           CWordHash::NODES_PER_CLUMP
#else
           6
#endif
           );

	time_t tmNow;
	time(&tmNow);

    printf("\nRun: %s\n\n", ctime(&tmNow));

    if (ifs.m_fTestIterators)
        test_iterators(ifs.m_dblHighLoad, ifs.m_nInitSize, ifs.m_nSubTables);

    printf("Starting threads...\n\n");

    IRTLVERIFY(QueryPerformanceFrequency(&liFrequency));
    printf("QueryPerformanceFrequency = %f\n", (double) liFrequency.QuadPart);

    int nTotalOps = 0;

    for (num_threads = 1; num_threads <= ifs.m_nMaxThreads; num_threads++ )
    {
        TRACE("\nStarting %8d\n", num_threads);

        IRTLVERIFY(QueryPerformanceCounter(&liT1));

        pTbl = new CWordHash(ifs.m_dblHighLoad, ifs.m_nInitSize,
                             ifs.m_nSubTables) ;
        pTbl->SetTableLockSpinCount(ifs.m_wTableSpin);
        pTbl->SetBucketLockSpinCount(ifs.m_wBucketSpin);

        keys_per_thread = g_nokeys/num_threads ;
        for (i = 0; i < num_threads; i++)
        {
            de_area[i].ptbl        = pTbl ;
            de_area[i].threadno    = i+1 ;
            de_area[i].first_key   = i*keys_per_thread ;
            de_area[i].last_key    = ((i == num_threads - 1)
                                      ? g_nokeys
                                      : (i+1)*keys_per_thread) ;
            de_area[i].rounds      = ifs.m_nRounds ;
            de_area[i].highload    = (float) ifs.m_dblHighLoad ;
            de_area[i].lookup_freq = ifs.m_nLookupFreq ;
            de_area[i].hevFinished =
                CreateEvent(NULL,     // no security attributes
                            FALSE,    // auto reset
                            FALSE,    // not signalled
                            NULL);    // no name
            IRTLASSERT(de_area[i].hevFinished != NULL);
            ahEvents[i] = de_area[i].hevFinished;

            _beginthread(exercise_table, 0, &de_area[i]) ;  
        }
        
        DWORD dw = WaitForMultipleObjects(num_threads, ahEvents,
                                          TRUE, INFINITE);

        for (i = 0; i < num_threads; i++)
            CloseHandle(ahEvents[i]);
        
        IRTLVERIFY(QueryPerformanceCounter(&liT2));
        duration = (liT2.QuadPart-liT1.QuadPart) /(double)liFrequency.QuadPart;

        sum_ins = sum_dels = sum_lookups = 0 ;

        for (i = 0; i < num_threads; i++)
        {
            sum_ins     += de_area[i].cinserts ;
            sum_dels    += de_area[i].cdeletes ;
            sum_lookups += de_area[i].clookups ;
            failures    += de_area[i].cfailures ;
        }
        int nOps = (int)((sum_ins + sum_dels + sum_lookups) / duration);
        total_failures += failures;

        nTotalOps += nOps;  // TODO: weight?

        char szSumIns[16], szSumDels[16], szSumLookups[16], szNOps[16];

#ifndef LOCK_INSTRUMENTATION
        if (num_threads == 1)
#endif // LOCK_INSTRUMENTATION
        {
            printf("%8s %11s %11s "
                   "%11s %11s %11s\n",
                   "#Threads", "Ops/sec", "Duration",
                   "Inserts", "Deletes", "Lookups");
        }

        char szSummary[200];

        sprintf(szSummary, "%8d %11s %11.3f "
                "%11s %11s %11s\n",
                num_threads,
                CommaNumber(nOps, szNOps),
                duration,
                CommaNumber(sum_ins, szSumIns),
                CommaNumber(sum_dels, szSumDels),
                CommaNumber(sum_lookups, szSumLookups)
                );
        printf(szSummary);
        TRACE(szSummary);

        if (failures != 0)
            printf("%d failed operations!\n", failures);

#ifdef LOCK_INSTRUMENTATION
        print_lock_statistics(pTbl->GetStatistics());
 #ifdef LKRHASH_GLOBAL_LOCK
        CWordHash::GlobalLock::ResetGlobalStatistics();
 #endif
        CWordHash::BucketLock::ResetGlobalStatistics();
        CWordHash::TableLock::ResetGlobalStatistics();
        printf("\n");
#endif

        delete pTbl ;
    }

    char szNTotalOps[16];
    printf("\nAverage Ops = %s.\n",
           CommaNumber(nTotalOps / ifs.m_nMaxThreads, szNTotalOps));

    if (total_failures != 0)
        printf("%d total failed operations!\n", total_failures);


#if defined(MANODEL) && defined(MANODEL_INSTRUMENTATION)
    MEMORY_ALLOC_NO_DELETE::PrintStatistics();
#endif

#ifdef _NO_TRACING_
    DELETE_DEBUG_PRINT_OBJECT();
#endif

    TerminateIISRTL();

    LKRHashTableUninit();
#if defined(LKRHASH_ACACHE)
    DBG_REQUIRE(ALLOC_CACHE_HANDLER::Cleanup());
#endif

    return(0) ;

} /* main */



void test_iterators(
    double highload,
    int    initsize,
    int    nsubtbls)
{
    printf("Testing iterators...\n");

    int i;
    CWordHash *pTbl = new CWordHash(highload, initsize, nsubtbls) ;
    LK_RETCODE lkrc;

    IRTLASSERT(0 == pTbl->Size());
    IRTLASSERT(pTbl->CheckTable() == 0);

    TRACE("Table is empty.  Building...\n");
    
    for (i = 0 ; i < g_nokeys ; i++ )
    {
        lkrc = pTbl->InsertRecord(&g_wordtable[i], false);
        if (lkrc != LK_SUCCESS)
            TRACE("i = %d, word = `%s', lkrc = %d\n", i, g_wordtable[i], lkrc);
        IRTLASSERT(lkrc == LK_SUCCESS);
    }
    
    pTbl->ReadLock();

    TRACE("Checking that table has %d records (size = %d)\n",
          g_nokeys, pTbl->Size());
    IRTLASSERT(g_nokeys == (int) pTbl->Size());
    IRTLASSERT(pTbl->CheckTable() == 0);

    pTbl->ReadUnlock();

    TRACE("Clearing the table\n");
    pTbl->Clear();
    IRTLASSERT(0 == pTbl->Size());
    IRTLASSERT(pTbl->CheckTable() == 0);

    TRACE("Seeing what crud is left in the table\n");
    size_t cRec = 0;

    for (i = 0 ; i < g_nokeys ; i++ )
    {
        CStr*  pstrKey  = &g_wordtable[i].m_str;
        CWord* pkey     = NULL;
        LK_RETCODE lkrc = pTbl->FindKey(pstrKey, &pkey);

        if (pkey != NULL)
        {
            IRTLASSERT(pkey == &g_wordtable[i]);
            --pkey->m_cRefs;
            TRACE("%s\n", g_wordtable[i]);
            ++cRec;
        }
    }
    TRACE("Found %d records that shouldn't have been there\n", cRec);


    TRACE("Rebuilding the table\n");
    for (i = 0 ; i < g_nokeys ; i++ )
        IRTLVERIFY(pTbl->InsertRecord(&g_wordtable[i]) == LK_SUCCESS);

    IRTLASSERT(g_nokeys == (int) pTbl->Size());
    IRTLASSERT(pTbl->CheckTable() == 0);


    TRACE("Checking iterators\n");
    cRec = 0;
    CWordHash::CIterator iter(LKL_READLOCK);
    
    for (lkrc = pTbl->InitializeIterator(&iter);
         lkrc == LK_SUCCESS;
         lkrc = pTbl->IncrementIterator(&iter))
    {
        ++cRec;
        const CStr* pstrKey = iter.Key();
        CWord*      pRec    = iter.Record();
        
        IRTLASSERT(&g_wordtable[0] <= pRec  &&  pRec < &g_wordtable[g_nokeys]);
        IRTLASSERT(!pRec->m_fIterated);
        pRec->m_fIterated = true;

#ifdef LKR_NEWCODE
        if (CWordHash::TableLock::Recursion() != LOCK_NON_RECURSIVE
            &&  CWordHash::BucketLock::Recursion() != LOCK_NON_RECURSIVE)
#endif
        {
            // Check that the lock can be safely acquired recursively
            // (the table is already locked by the iterator).
            int x = rand() % g_nokeys;
            CStr*  pstrKey2 = &g_wordtable[x].m_str;
            CWord* pkey2    = NULL;
            LK_RETCODE lkrc2= pTbl->FindKey(pstrKey2, &pkey2);
            IRTLASSERT(lkrc2 == LK_SUCCESS  &&  pkey2 == &g_wordtable[x]);
            if (pkey2 != NULL)
                --pkey2->m_cRefs;
        }
    }
    
    IRTLASSERT(lkrc == LK_NO_MORE_ELEMENTS);
    IRTLASSERT((int) cRec == g_nokeys);

    lkrc = pTbl->CloseIterator(&iter);
    IRTLASSERT(lkrc == LK_SUCCESS);

    for (i = 0 ; i < g_nokeys ; i++ )
    {
        IRTLASSERT(g_wordtable[i].m_fIterated);
        g_wordtable[i].m_fIterated = false;
    }


    do {
        cRec = rand() % (g_nokeys - 1);
    } while (cRec == 0);
    TRACE("Checking abandoning of const iterators after %d iterations\n",
          cRec);

    const CWordHash *pTblConst = pTbl;
    CWordHash::CConstIterator iterConst;

    for (lkrc = pTblConst->InitializeIterator(&iterConst);
         lkrc == LK_SUCCESS;
         lkrc = pTblConst->IncrementIterator(&iterConst))
    {
        if (--cRec == 0)
            break;
        const CStr*  pszKey = iterConst.Key();
        const CWord* pRec   = iterConst.Record();
        
        IRTLASSERT(&g_wordtable[0] <= pRec  &&  pRec < &g_wordtable[g_nokeys]);
    }
    
    IRTLASSERT(lkrc != LK_NO_MORE_ELEMENTS);

    lkrc = pTblConst->CloseIterator(&iterConst);
    IRTLASSERT(lkrc == LK_SUCCESS);

    
    TRACE("Gathering statistics\n");
    CLKRHashTableStats stats = pTbl->GetStatistics();
    print_table_statistics(stats);

#ifdef LOCK_INSTRUMENTATION
    print_lock_statistics(stats);
    CWordHash::BucketLock::ResetGlobalStatistics();
    CWordHash::TableLock::ResetGlobalStatistics();
#endif
    printf("\n");

    TRACE("Cleaning up by hand\n");
    for (i = 0 ; i < g_nokeys ; i++ )
    {
        IRTLVERIFY(pTbl->DeleteKey(&g_wordtable[i].m_str) == LK_SUCCESS);
    }
    
    IRTLASSERT(0 == pTbl->Size());

    delete pTbl ;
}


void print_table_statistics(const CLKRHashTableStats& stats)
{
    printf("#Records=%d, #BucketChains=%d, "
           "DirSize=%d, LongestChain=%3d,\n",
           stats.RecordCount, stats.TableSize,
           stats.DirectorySize, stats.LongestChain);
           
    printf("#Empty Buckets=%d, Split Factor=%.2f, "
           "AvgSrchLen=%.2f, Expected SL=%.2f,\n",
           stats.EmptySlots, stats.SplitFactor,
           stats.AvgSearchLength, stats.ExpSearchLength);

    printf("Avg Unsuccessful SrchLen=%.2f, ExpUSL=%.2f.\n",
           stats.AvgUSearchLength, stats.ExpUSearchLength);

    printf("\nBucket Chain Lengths "
           "(node clump size = %d, bucket size = %d bytes):\n",
           stats.NodeClumpSize, stats.CBucketSize);
    for (int j = 0;  j < CLKRHashTableStats::MAX_BUCKETS;  ++j)
    {
        if (stats.m_aBucketLenHistogram[j] == 0)
        {
            printf("\n");
            break;
        }
        printf(" %10d: %6d",
               stats.BucketSize(j), stats.m_aBucketLenHistogram[j]);
        if (j % 4 == 3)
            printf("\n");
    }

    printf("\n");
}


#ifdef LOCK_INSTRUMENTATION

void print_lock_statistics(const CLKRHashTableStats& stats)
{
    printf("Global Locks Statistics:"
           "\n   total locks created = %ld, "
           "total contentions = %ld, "
           "#sleeps = %ld,"
           "\n   total spins = %I64d, "
           "av spins/contention = %.1f, "
           "\n   #readlocks = %d, "
           "#writelocks=%d\n",
           stats.m_gls.m_cTotalLocks,
           stats.m_gls.m_cContendedLocks,
           stats.m_gls.m_nSleeps,
           stats.m_gls.m_cTotalSpins,
           stats.m_gls.m_nAverageSpins,
           stats.m_gls.m_nReadLocks,
           stats.m_gls.m_nWriteLocks
           );

    printf("Averaged SubTable Locks Statistics:"
           "\n   Total locks = %d, "
           "#contentions = %.1f, "
           "sleeps = %.1f; "
           "\n   total spins = %.1f, "
           "avg spins = %.1f, "
           "\n   #readlocks = %.1f, "
           "#writelocks=%.1f\n",
           stats.m_alsTable.m_nItems,
           stats.m_alsTable.m_nContentions,
           stats.m_alsTable.m_nSleeps,
           stats.m_alsTable.m_nContentionSpins,
           stats.m_alsTable.m_nAverageSpins,
           stats.m_alsTable.m_nReadLocks,
           stats.m_alsTable.m_nWriteLocks);

    printf("Averaged Bucket Locks Statistics:"
           "\n   Total locks = %d, "
           "#contentions = %.1f, "
           "sleeps = %.1f; "
           "\n   total spins = %.1f, "
           "avg spins = %.1f, "
           "\n   #readlocks = %.1f, "
           "#writelocks=%.1f\n",
           stats.m_alsBucketsAvg.m_nItems,
           stats.m_alsBucketsAvg.m_nContentions,
           stats.m_alsBucketsAvg.m_nSleeps,
           stats.m_alsBucketsAvg.m_nContentionSpins,
           stats.m_alsBucketsAvg.m_nAverageSpins,
           stats.m_alsBucketsAvg.m_nReadLocks,
           stats.m_alsBucketsAvg.m_nWriteLocks);

    printf("\n");
}

#endif // LOCK_INSTRUMENTATION

    
int expand_key_set(int maxkeys, int numkeys, bool fVerbose)
{
    int totkeys = numkeys ;
    if (totkeys > maxkeys)
        return maxkeys;

    char* pszTemp = (char*) _alloca(20 + CStr::sm_cchMax);

    for(int k = 0; TRUE; k++)
    {
        for(int i = 0; i < numkeys; i++)
        {
            if (totkeys == maxkeys)
                return(totkeys) ;

            sprintf(pszTemp, "%d%s", k, g_wordtable[i].m_str.m_psz);
            g_wordtable[totkeys++].m_str.Set(pszTemp);
        }

        if (fVerbose) putchar('.');
    }
}


void __cdecl exercise_table(void* pinput)
{
    CWordHash*    pTbl;
    thread_data*  pdea = (thread_data*) pinput ;
    int           cfailed_ins=0 ;
    int           cfailed_dels=0 ;
    int           cFoundSuccesses=0, cFoundFails=0 ;
    int           x, i ;
    LARGE_INTEGER liFreq, liT1, liT2;

    SetThreadIdealProcessor(GetCurrentThread(),
                            pdea->threadno % NumProcessors());

    IRTLVERIFY(QueryPerformanceFrequency(&liFreq));
    IRTLVERIFY(QueryPerformanceCounter(&liT1));

    pdea->cinserts = 0 ;
    pdea->cdeletes = 0 ;
    pdea->clookups = 0 ;
    pTbl = pdea->ptbl ;

    for (int rnd = 0; rnd < pdea->rounds; rnd++)
    {
        IRTLASSERT(pTbl->CheckTable() == 0);

        // Insert all the keys, randomly searching after each insertion
        for (i = pdea->first_key ; i < pdea->last_key ; i++ )
        {
#ifdef _DEBUG
            CStr*  pstrKey = &g_wordtable[i].m_str;
            CWord* pkey     = NULL;
            LK_RETCODE lkrc = pTbl->FindKey(pstrKey, &pkey);
            IRTLASSERT(lkrc == LK_NO_SUCH_KEY  &&  pkey == NULL);
#endif // _DEBUG

            if (pTbl->InsertRecord(&g_wordtable[i] ) != LK_SUCCESS )
            {
                cfailed_ins++ ;
            }
            else
            {
#ifdef _DEBUG
                pstrKey = &g_wordtable[i].m_str;
                lkrc = pTbl->FindKey(pstrKey, &pkey);
                IRTLASSERT(lkrc == LK_SUCCESS  &&  pkey == &g_wordtable[i]);
                --pkey->m_cRefs;
#endif // _DEBUG

                g_wordtable[i].m_fInserted = true;
            }

            pdea->cinserts++ ;

            for (int lu = 0; lu < pdea->lookup_freq; lu++)
            {
                x = rand() % (pdea->last_key - pdea->first_key)
                    + pdea->first_key;
                bool fPresent = (x <= i); // should it be found?
                CWord* pkey     = NULL;
                LK_RETCODE lkrc = pTbl->FindKey(&g_wordtable[x].m_str, &pkey);

                if (fPresent)
                {
                    if (lkrc != LK_SUCCESS  ||  pkey != &g_wordtable[x] )
                    {
                        ++g_wordtable[x].m_cNotFound;
                        TRACE("%d: Not found (%s): x = %d, i = %d, "
                              "cnf = %d, rnd = %d, lkrc = %d, pkey(%s), %d\n",
                              pdea->threadno, g_wordtable[x].m_str.m_psz, x, i,
                              g_wordtable[x].m_cNotFound, rnd, lkrc,
                              pkey != NULL ? pkey->m_str.m_psz : "<null>",
                              pkey != NULL ? (pkey - g_wordtable) / sizeof(CWord) : -1);
                        cFoundFails++ ;
                    }
                    else
                    {
                        --g_wordtable[x].m_cRefs;
                        cFoundSuccesses++ ;
                    }
                }
                else // not fPresent
                {
                    IRTLASSERT(lkrc != LK_SUCCESS  &&  pkey == NULL);
                    if (lkrc == LK_SUCCESS  ||  pkey != NULL)
                    {
                        TRACE("%d: found when not present (%s): "
                              "x = %d, i = %d, "
                              "cnf = %d, rnd = %d, lkrc = %d, pkey(%s), %d\n",
                              pdea->threadno, g_wordtable[x].m_str.m_psz,
                              x, i,
                              g_wordtable[x].m_cNotFound, rnd, lkrc,
                              pkey != NULL ? pkey->m_str.m_psz : "<null>",
                              pkey != NULL ? (pkey - g_wordtable) / sizeof(CWord) : -1);
                        cFoundFails++ ;
                    }
                    else
                    {
                        // wasn't found, but it wasn't present, so this is good
                        cFoundSuccesses++ ;
                    }
                }
            }

            pdea->clookups += pdea->lookup_freq ;
        }

        IRTLASSERT(cfailed_ins == 0) ;
        IRTLASSERT(cFoundFails == 0) ;
        IRTLASSERT(cFoundSuccesses == ((2 * rnd + 1) * pdea->lookup_freq
                              * (pdea->last_key - pdea->first_key)));

        TRACE("Thrd %u, rnd %d: %d inserts done, not found %d, "
              "f=%d, l=%d\n", 
              pdea->threadno, rnd, pdea->cinserts, cFoundFails,
              pdea->first_key, pdea->last_key) ;
        IRTLASSERT(pTbl->CheckTable() == 0);

        // Delete all the keys, randomly searching before each deletion
        for (i = pdea->first_key ; i < pdea->last_key ; i++ )
        {
            for (int lu = 0; lu < pdea->lookup_freq; lu++)
            {
                x = rand() % (pdea->last_key - pdea->first_key)
                    + pdea->first_key;
                bool fPresent = (x >= i); // should it be found?
                CWord* pkey     = NULL;
                LK_RETCODE lkrc = pTbl->FindKey(&g_wordtable[x].m_str, &pkey);

                if (fPresent)
                {
                    if (lkrc != LK_SUCCESS  ||  pkey != &g_wordtable[x] )
                    {
                        ++g_wordtable[x].m_cNotFound;
                        TRACE("%d: Not found (%s): x = %d, i = %d, "
                              "cnf = %d, rnd = %d, lkrc = %d, pkey(%s), %d\n",
                              pdea->threadno, g_wordtable[x].m_str.m_psz, x, i,
                              g_wordtable[x].m_cNotFound, rnd, lkrc,
                              pkey != NULL ? pkey->m_str.m_psz : "<null>",
                              pkey != NULL ? (pkey - g_wordtable) / sizeof(CWord) : -1);
                        cFoundFails++ ;
                    }
                    else
                    {
                        --g_wordtable[x].m_cRefs;
                        cFoundSuccesses++ ;
                    }
                }
                else // !fPresent
                {
                    IRTLASSERT(lkrc != LK_SUCCESS  &&  pkey == NULL);
                    if (lkrc == LK_SUCCESS  ||  pkey != NULL)
                    {
                        TRACE("%d: found when not present (%s): "
                              "x = %d, i = %d, "
                              "cnf = %d, rnd = %d, lkrc = %d, pkey(%s), %d\n",
                              pdea->threadno, g_wordtable[x].m_str.m_psz,
                              x, i,
                              g_wordtable[x].m_cNotFound, rnd, lkrc,
                              pkey != NULL ? pkey->m_str.m_psz : "<null>",
                              pkey != NULL ? (pkey - g_wordtable) / sizeof(CWord) : -1);
                        cFoundFails++ ;
                    }
                    else
                    {
                        // wasn't found, but it wasn't present, so this is good
                        cFoundSuccesses++ ;
                    }
                }
            }
            pdea->clookups += pdea->lookup_freq ;

#ifdef _DEBUG
            CStr*  pstrKey  = &g_wordtable[i].m_str;
            CWord* pkey     = NULL;
            LK_RETCODE lkrc = pTbl->FindKey(pstrKey, &pkey);
            IRTLASSERT(lkrc == LK_SUCCESS  &&  pkey == &g_wordtable[i]);
            --pkey->m_cRefs;
#endif // _DEBUG

            if (pTbl->DeleteKey(&g_wordtable[i].m_str) != LK_SUCCESS )
            {
                cfailed_dels++ ;
            }
            else
            {
#ifdef _DEBUG
                pstrKey = &g_wordtable[i].m_str;
                lkrc = pTbl->FindKey(pstrKey, &pkey);
                IRTLASSERT(lkrc == LK_NO_SUCH_KEY  &&  pkey == NULL);
#endif // _DEBUG

                g_wordtable[i].m_fInserted = false;
            }
            pdea->cdeletes++ ;
        }

#ifdef _DEBUG
        int cBadKeys = 0;
        for (i = pdea->first_key ; i < pdea->last_key ; i++ )
        {
            if (g_wordtable[i].m_cNotFound > 0)
            {
                ++cBadKeys;
                TRACE("%-20s: #not found = %d, hash = %d, %08x\n",
                      g_wordtable[i].m_str.m_psz,
                      g_wordtable[i].m_cNotFound,
                      CWordHash::CalcKeyHash(CWordHash::ExtractKey(
                                             &g_wordtable[i])),
                      CWordHash::CalcKeyHash(CWordHash::ExtractKey(
                                             &g_wordtable[i])));
            }
        }
        if (cBadKeys > 0)
            TRACE("%d bad keys\n", cBadKeys);
        IRTLASSERT(cBadKeys == 0);
#endif // _DEBUG

        IRTLASSERT(cfailed_dels == 0 ) ;
        IRTLASSERT(cFoundFails == 0 ) ;
        IRTLASSERT(cFoundSuccesses == ((2 * rnd + 2) * pdea->lookup_freq
                              * (pdea->last_key - pdea->first_key)));
        TRACE("Thrd %u, rnd %d: %d deletes done, not found %d, "
              "f=%d, l=%d\n", 
              pdea->threadno, rnd, pdea->cdeletes, cFoundFails,
              pdea->first_key, pdea->last_key) ;
    } // (for rnd)

    IRTLVERIFY(QueryPerformanceCounter(&liT2));
    pdea->duration = (liT2.QuadPart-liT1.QuadPart) / (double) liFreq.QuadPart;

    IRTLASSERT(pTbl->CheckTable() == 0);

    TRACE("Thread %u terminating: %d found, %d not found\n",
          pdea->threadno, cFoundSuccesses, cFoundFails) ;

    if (cFoundSuccesses != (2 * pdea->rounds * pdea->lookup_freq
                   * (pdea->last_key - pdea->first_key))
        ||  cFoundFails != 0  ||  cfailed_ins != 0  ||  cfailed_dels != 0)
    {
        printf("Thread %u: found = %d, not found = %d, "
               "\nfailed inserts = %d, failed deletes = %d\n",
               pdea->threadno, cFoundSuccesses, cFoundFails,
               cfailed_ins, cfailed_dels);
    }

    pdea->cfailures = cfailed_ins + cfailed_dels + cFoundFails;

    if (pdea->hevFinished != NULL)
        SetEvent(pdea->hevFinished);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\i386\xcptmisc.asm ===
title   "Miscellaneous Exception Handling"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    xcptmisc.asm
;
; Abstract:
;
;    This module implements miscellaneous routines that are required to
;    support exception handling. Functions are provided to call an exception
;    handler for an exception, call an exception handler for unwinding, get
;    the caller's stack pointer, get the caller's frame pointer, get the
;    caller's floating status, get the caller's processor state, get the
;    caller's extended processor status, and get the current stack limits.
;
; Author:
;
;    David N. Cutler (davec) 14-Aug-1989
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;    Keith Moore (keithmo) 12-Sep-1997
;
;        Stolen from ntdll for use in IIS.
;
;--
.386p

        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

_TEXT$01   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page
        subttl  "Capture Context"
;++
;
; VOID
; PuDbgCaptureContext (PCONTEXT ContextRecord)
;
; Routine Description:
;
;   This fucntion fills in the specified context record with the
;   current state of the machine, except that the values of EBP
;   and ESP are computed to be those of the caller's caller.
;
;   N.B.  This function assumes it is called from a 'C' procedure with
;         the old ebp at [ebp], the return address at [ebp+4], and
;         old esp = ebp + 8.
;
;         Certain 'C' optimizations may cause this to not be true.
;
;   N.B.  This function does NOT adjust ESP to pop the arguments off
;         the caller's stack.  In other words, it provides a __cdecl ESP,
;         NOT a __stdcall ESP.  This is mainly because we can't figure
;         out how many arguments the caller takes.
;
;   N.B.  Floating point state is NOT captured.
;
; Arguments:
;
;    ContextRecord  (esp+4) - Address of context record to fill in.
;
; Return Value:
;
;    The caller's return address.
;
;--

cPublicProc _PuDbgCaptureContext ,1

        push    ebx
        mov     ebx,[esp+8]         ; (ebx) -> ContextRecord

        mov     dword ptr [ebx.CsEax],eax
        mov     dword ptr [ebx.CsEcx],ecx
        mov     dword ptr [ebx.CsEdx],edx
        mov     eax, [esp]
        mov     dword ptr [ebx.CsEbx],eax

        mov     dword ptr [ebx.CsEsi],esi
        mov     dword ptr [ebx.CsEdi],edi

        mov     [ebx.CsSegCs],cs
        mov     [ebx.CsSegDs],ds
        mov     [ebx.CsSegEs],es
        mov     [ebx.CsSegFs],fs
        mov     [ebx.CsSegGs],gs
        mov     [ebx.CsSegSs],ss

        pushfd
        pop     [ebx.CsEflags]

        mov     eax,[ebp+4]
        mov     [ebx.CsEip],eax

        mov     eax,[ebp]
        mov     [ebx.CsEbp],eax

        lea     eax,[ebp+8]
        mov     [ebx.CsEsp],eax

        pop     ebx
        stdRET    _PuDbgCaptureContext

stdENDP _PuDbgCaptureContext

_TEXT$01   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl2\buffer.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\buffer.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl2\eventlog.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\eventlog.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl2\string.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\string.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl2\mlszau.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\mlszau.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl2\pudebug.c ===
#include "..\iisrtl\pudebug.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl2\stktrace.c ===
#include "..\iisrtl\stktrace.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl2\multisz.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\multisz.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl2\reftrace.c ===
#include "..\iisrtl\reftrace.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl2\main.cxx ===
#include "precomp.hxx"
#include <irtldbg.h>
#include "alloc.h"

/////////////////////////////////////////////////////////////////////////////
// Globals

// We always define these variables so that they exist in both free and
// checked versions of iisrtl2.lib

#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisRtlGuid, 
0x784d8900, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
DECLARE_DEBUG_PRINTS_OBJECT()
DECLARE_PLATFORM_TYPE()

// NOTE: Anything that is initialized in IISRTLs DLLMAIN needs to be done here
// too, the same for terminates.
extern "C" CRITICAL_SECTION g_csGuidList;
extern "C" LIST_ENTRY g_pGuidList;
extern "C" DWORD g_dwSequenceNumber;

// NOTE: It is mandatory that any program using the IISRTL2 calls the
// initialize and terminate functions below at program startup and shutdown.
extern "C" void InitializeIISRTL2()
{
    InitializeCriticalSection(&g_csGuidList);
    InitializeListHead(&g_pGuidList);
    IisHeapInitialize();
    InitializeStringFunctions();
}

extern "C" void TerminateIISRTL2()
{
    IisHeapTerminate();
    DeleteCriticalSection(&g_csGuidList);
}

#else

// DECLARE_DEBUG_VARIABLE();
extern "C" DWORD           g_dwDebugFlags = DEBUG_ERROR;

// DECLARE_DEBUG_PRINTS_OBJECT();
extern "C" DEBUG_PRINTS*   g_pDebug = NULL;

// DECLARE_PLATFORM_TYPE();
extern "C" PLATFORM_TYPE   g_PlatformType = PtInvalid;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl2\stringau.cxx ===
#include "precomp.hxx"
#include "..\iisrtl\stringau.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl2\isplat.cxx ===
/*++

    Copyright (c) 1996  Microsoft Corporation

    Module  Name :
        isplat.cxx

    Abstract:

        This module defines functions for determining platform types

    Author:

        Johnson Apacible    (johnsona)      19-Nov-1996

        Murali Krishnan     (MuraliK)       17-Apr-1997
                   Added CriticalSectionWith SpinCount stuff
--*/

#include "precomp.hxx"

#include <inetsvcs.h>


typedef
BOOLEAN
(NTAPI *GET_PRODUCT_TYPE)(
            PNT_PRODUCT_TYPE
            );

extern "C"
PLATFORM_TYPE
IISGetPlatformType(
        VOID
        )
/*++

  This function consults the registry and determines the platform type
   for this machine.

  Arguments:

    None

  Returns:
    Platform type

--*/
{
    PLATFORM_TYPE pt;
    LONG result;
    HKEY keyHandle;
    WCHAR productType[30];
    DWORD type;
    BOOL isNt = TRUE;

    OSVERSIONINFO osInfo;

    //
    // See if the platform type has already been discovered.
    //

    if ( g_PlatformType != PtInvalid ) {
        return(g_PlatformType);
    }

    //
    // see if this is win95
    //

    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( GetVersionEx( &osInfo ) ) {
        isNt = (osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
    } else {
        IIS_PRINTF((buff,"GetVersionEx failed with %d\n",
                    GetLastError()));
    }

    if ( isNt ) {

        HINSTANCE hNtdll;
        NT_PRODUCT_TYPE ntType;
        GET_PRODUCT_TYPE pfnGetProductType;

        //
        // Get the product type from the system
        //

        pt = PtNtWorkstation;
        hNtdll = LoadLibrary("ntdll.dll");
        if ( hNtdll != NULL ) {

            pfnGetProductType = (GET_PRODUCT_TYPE)
                GetProcAddress(hNtdll, "RtlGetNtProductType");

            if ( (pfnGetProductType != NULL) &&
                  pfnGetProductType( &ntType ) ) {

                if ( (ntType == NtProductLanManNt) ||
                     (ntType == NtProductServer) ) {

                    pt = PtNtServer;
                }
            }

            FreeLibrary( hNtdll );
        }

    } else {
        pt = PtWindows95;
    }

    g_PlatformType = pt;
    return(pt);

} // IISGetPlatformType




//------------------------------------------------------------------------
// SetCriticalSectionSpinCount hackery


typedef
DWORD
(WINAPI * PFN_SET_CRITICAL_SECTION_SPIN_COUNT)(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
   );

static PFN_SET_CRITICAL_SECTION_SPIN_COUNT  g_pfnSetCSSpinCount = NULL;


//------------------------------------------------------------------------
// Function: FakeSetCriticalSectionSpinCount
// Synopsis: This function fakes setting critical section spin count.
//           See CCritSec::SetSpinCount() for details
// Returns:  0 - since we are faking the set of cs with spin count
//------------------------------------------------------------------------

static DWORD
FakeSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION /*lpCriticalSection*/,
    DWORD              /*dwSpinCount*/)
{
    // For faked critical sections, the previous spin count is just ZERO!
    return 0;
}


//------------------------------------------------------------------------
// Function: CCritSec::SetSpinCount
// Synopsis: This function is used to call the appropriate underlying
//           functions to set the spin count for the supplied critical
//           section. The original function is supposed to be exported out
//           of kernel32.dll from NT 4.0 SP3. If the func is not available
//           from the dll, we will use a fake function.
//
// Arguments:
//   lpCriticalSection
//      Points to the critical section object.
//
//   dwSpinCount
//      Supplies the spin count for the critical section object. For UP
//      systems, the spin count is ignored and the critical section spin
//      count is set to 0. For MP systems, if contention occurs, instead of
//      waiting on a semaphore associated with the critical section, the
//      calling thread will spin for spin count iterations before doing the
//      hard wait. If the critical section becomes free during the spin, a
//      wait is avoided.
//
// Returns:
//      The previous spin count for the critical section is returned.
//------------------------------------------------------------------------

DWORD
IISSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount)
{
    if ( g_pfnSetCSSpinCount == NULL )
    {
        HINSTANCE tmpInstance;

        //
        // load kernel32 and get NT specific entry points
        //

        tmpInstance = LoadLibrary("kernel32.dll");
        if ( tmpInstance != NULL )
        {
            g_pfnSetCSSpinCount = (PFN_SET_CRITICAL_SECTION_SPIN_COUNT )
                GetProcAddress( tmpInstance, "SetCriticalSectionSpinCount");

            if ( g_pfnSetCSSpinCount == NULL ) {
                // the set CS Spincount function is not availble.
                //  Just thunk it.
                g_pfnSetCSSpinCount = FakeSetCriticalSectionSpinCount;
            }

            //
            // We can free this because we are statically linked to it
            //

            FreeLibrary(tmpInstance);
        }
    }

    // Pass the inputs to the global function pointer which is already setup.
    return ( g_pfnSetCSSpinCount( lpCriticalSection, dwSpinCount));
}


VOID
IISInitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection)
{
    InitializeCriticalSection(lpCriticalSection);
    IISSetCriticalSectionSpinCount(lpCriticalSection, IIS_DEFAULT_CS_SPIN_COUNT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl2\i386\xcptmisc.asm ===
include ..\iisrtl\i386\xcptmisc.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl2\win32obj.c ===
#include "..\iisrtl\win32obj.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl2\tracelog.c ===
#include "..\iisrtl\tracelog.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iissuba\md5.h ===
/*
 ***********************************************************************
 ** md5.h -- Header file for implementation of MD5                    **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
 ** Revised (for MD5): RLR 4/27/91                                    **
 **   -- G modified to have y&~z instead of y&z                       **
 **   -- FF, GG, HH modified to add in last register done             **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **
 **   -- distinct additive constant for each step                     **
 **   -- round 4 added, working mod 7                                 **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

/* Data structure for MD5 (Message-Digest) computation */
typedef struct {
  ULONG i[2];                          /* number of _bits_ handled mod 2^64 */
  ULONG buf[4];                                           /* scratch buffer */
  unsigned char in[64];                                     /* input buffer */
  unsigned char digest[16];            /* actual digest after MD5Final call */
} MD5_CTX;

#define MD5_LEN 16

#define PROTO_LIST(list)    list


void MD5Init PROTO_LIST ((MD5_CTX *));
void MD5Update PROTO_LIST ((MD5_CTX *, unsigned char *, unsigned int));
void MD5Final PROTO_LIST ((MD5_CTX *));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iissuba\subauth.c ===
/*++


Copyright (c) 1987-1996  Microsoft Corporation

Module Name:

    subauth.c

Abstract:

    Sample SubAuthentication Package.

Author:

    Cliff Van Dyke (cliffv) 23-May-1994

Revisions:

    Andy Herron (andyhe)    21-Jun-1994  Added code to read domain/user info
    Philippe Choquier (phillich) 6-Jun-1996 Adapted for IIS

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

--*/


#if ( _MSC_VER >= 800 )
#pragma warning ( 3 : 4100 ) // enable "Unreferenced formal parameter"
#pragma warning ( 3 : 4219 ) // enable "trailing ',' used for variable argument list"
#pragma warning ( disable : 4005 )
#endif

# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
#define WIN32_NO_STATUS
#include <windef.h>
#undef WIN32_NO_STATUS
# include <windows.h>

#include <lmcons.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lsarpc.h>
#include <samrpc.h>
#include <crypt.h>
#include <sspi.h>
#include <secpkg.h>
#include <samisrv.h>
#include "subauth.h"        // local copy :(
#include "md5.h"

UNICODE_STRING EmptyString = { 0, 0, NULL };

BOOLEAN
EqualComputerName(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2
    );

NTSTATUS
QuerySystemTime (
    OUT PLARGE_INTEGER SystemTime
    );


BOOL
GetPasswordExpired(
    IN LARGE_INTEGER PasswordLastSet,
    IN LARGE_INTEGER MaxPasswordAge
    );

NTSTATUS
AccountRestrictions(
    IN ULONG UserRid,
    IN PUNICODE_STRING LogonWorkStation,
    IN PUNICODE_STRING WorkStations,
    IN PLOGON_HOURS LogonHours,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    );

LARGE_INTEGER
NetpSecondsToDeltaTime(
    IN ULONG Seconds
    );

VOID
InitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    );

VOID
CopyUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString OPTIONAL
    );

BOOL
SubaAllocateString(
    STRING *pS,
    UINT cS
    )
{
    if ( pS->Buffer = (CHAR*)RtlAllocateHeap( RtlProcessHeap(),
                                  HEAP_ZERO_MEMORY,
                                  cS ) )
    {
        pS->MaximumLength = (USHORT)cS;
        pS->Length = 0;

        return TRUE;
    }

    pS->MaximumLength = 0;
    pS->Length = 0;

    return FALSE;
}



NTSTATUS
ToHex16(
    LPBYTE       pSrc,
    PANSI_STRING pDst
    )
{
    char achH[16*2+1];
    UINT x,y;

#define TOAHEX(a) ((a)>=10 ? 'a'+(a)-10 : '0'+(a))

    for ( x = 0, y = 0 ; x < 16 ; ++x )
    {
        UINT v;
        v = pSrc[x]>>4;
        achH[y++] = TOAHEX( v );
        v = pSrc[x]&0x0f;
        achH[y++] = TOAHEX( v );
    }
    achH[y] = '\0';

    return RtlAppendAsciizToString( (PSTRING)pDst, achH );
}


BOOL Extract(
    CHAR **ppch,
    LPSTR* ppszTok
    )
{
    CHAR *pch = *ppch;

    if ( *pch )
    {
        *ppszTok = pch;
        while ( *pch && *pch != '"' )
        {
            ++pch;
        }
        if ( *pch == '"' )
        {
            *pch++ = '\0';
        }

        *ppch = pch;

        return TRUE;
    }

    return FALSE;
}


BOOL
WINAPI
NetUserCookieW(
    LPWSTR      lpwszUserName,
    UINT        cNameLen,
    DWORD       dwSeed,
    LPWSTR      lpwszCookieBuff,
    DWORD       dwBuffSize
    )
/*++

Routine Description:

    Compute logon validator ( to be used as password )
    for IISSuba

Arguments:

    lpszUsername -- user name
    dwSeed -- start value of cookie

Returns:

    TRUE if success, FALSE if error

--*/
{
    UINT x,y,v;
#define TOHEX(a) ((a)>=10 ? L'a'+(a)-10 : L'0'+(a))


    if ( dwBuffSize < sizeof(dwSeed)*2*sizeof(WCHAR) + sizeof(WCHAR) )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    while ( cNameLen-- )
    {
        dwSeed = ((dwSeed << 5) | ( dwSeed >> 27 )) ^ ((*lpwszUserName++)&0xff);
    }

    for ( x = 0, y = 0 ; x < sizeof(dwSeed) ; ++x )
    {
        v = ((LPBYTE)&dwSeed)[x]>>4;
        lpwszCookieBuff[y++] = TOHEX( v );
        v = ((LPBYTE)&dwSeed)[x]&0x0f;
        lpwszCookieBuff[y++] = TOHEX( v );
    }
    lpwszCookieBuff[y] = '\0';

    return TRUE;
}

NTSTATUS
Msv1_0SubAuthenticationRoutineEx(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    IN SAM_HANDLE UserHandle,
    IN OUT PMSV1_0_VALIDATION_INFO ValidationInfo,
    OUT PULONG ActionsPerformed
)
/*++

Routine Description:

    The subauthentication routine does client/server specific authentication
    of a user. The credentials of the user are passed in addition to all the
    information from SAM defining the user. This routine decides whether to
    let the user log on.


Arguments:

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.  The LogonDomainName field should be ignored.

    Flags - Flags describing the circumstances of the logon.

        MSV1_0_PASSTHRU -- This is a PassThru authenication.  (i.e., the
            user isn't connecting to this machine.)
        MSV1_0_GUEST_LOGON -- This is a retry of the logon using the GUEST
            user account.

    UserAll -- The description of the user as returned from SAM.

    WhichFields -- Returns which fields from UserAllInfo are to be written
        back to SAM.  The fields will only be written if MSV returns success
        to it's caller.  Only the following bits are valid.

        USER_ALL_PARAMETERS - Write UserAllInfo->Parameters back to SAM.  If
            the size of the buffer is changed, Msv1_0SubAuthenticationRoutine
            must delete the old buffer using MIDL_user_free() and reallocate the
            buffer using MIDL_user_allocate().

    UserFlags -- Returns UserFlags to be returned from LsaLogonUser in the
        LogonProfile.  The following bits are currently defined:


            LOGON_GUEST -- This was a guest logon
            LOGON_NOENCRYPTION -- The caller didn't specify encrypted credentials

        SubAuthentication packages should restrict themselves to returning
        bits in the high order byte of UserFlags.  However, this convention
        isn't enforced giving the SubAuthentication package more flexibility.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.

    LogoffTime - Receives the time at which the user should log off the
        system.  This time is specified as a GMT relative NT system time.

    KickoffTime - Receives the time at which the user should be kicked
        off the system. This time is specified as a GMT relative system
        time.  Specify, a full scale positive number if the user isn't to
        be kicked off.

Return Value:

    STATUS_SUCCESS: if there was no error.

    STATUS_NO_SUCH_USER: The specified user has no account.
    STATUS_WRONG_PASSWORD: The password was invalid.

    STATUS_INVALID_INFO_CLASS: LogonLevel is invalid.
    STATUS_ACCOUNT_LOCKED_OUT: The account is locked out
    STATUS_ACCOUNT_DISABLED: The account is disabled
    STATUS_ACCOUNT_EXPIRED: The account has expired.
    STATUS_PASSWORD_MUST_CHANGE: Account is marked as Password must change
        on next logon.
    STATUS_PASSWORD_EXPIRED: The Password is expired.
    STATUS_INVALID_LOGON_HOURS - The user is not authorized to log on at
        this time.
    STATUS_INVALID_WORKSTATION - The user is not authorized to log on to
        the specified workstation.

--*/
{
    NTSTATUS Status;
    ULONG UserAccountControl;
    LARGE_INTEGER LogonTime;
    LARGE_INTEGER PasswordDateSet;
    UNICODE_STRING LocalWorkstation;
    WCHAR achCookie[64];
    ANSI_STRING strA1;
    ANSI_STRING strA2;
    ANSI_STRING strDigest;
    ANSI_STRING AnsiPwd;
    MD5_CTX md5;
    CHAR *pch;
    LPSTR pszRealm;
    LPSTR pszUri;
    LPSTR pszMethod;
    LPSTR pszNonce;
    LPSTR pszServerNonce;
    LPSTR pszDigest;
    LPSTR pszDigestUsername;
    LPSTR pszQOP;
    LPSTR pszCNonce;
    LPSTR pszNC;
    PNETLOGON_NETWORK_INFO LogonNetworkInfo;
    UINT l;
    PUNICODE_STRING pPwd = NULL;
    UNICODE_STRING PackageName;
    UNICODE_STRING UserPwd;
    VOID *pvPlainPwd = NULL;
    ULONG ulLength = 0;
    BOOL fNTDigest = FALSE;
    CHAR achAnsiPwdBuffer[MAX_PASSWD_LEN + 1];
    strA1.Buffer = NULL;
    strA2.Buffer = NULL;
    strDigest.Buffer = NULL;

    AnsiPwd.Buffer = achAnsiPwdBuffer;
    AnsiPwd.Length = AnsiPwd.MaximumLength = MAX_PASSWD_LEN;

    //
    // Check whether the SubAuthentication package supports this type
    //  of logon.
    //

    (VOID) QuerySystemTime( &LogonTime );

    switch ( LogonLevel ) {
    case NetlogonInteractiveInformation:
    case NetlogonServiceInformation:

        //
        // This SubAuthentication package only supports network logons.
        //

        return STATUS_INVALID_INFO_CLASS;

    case NetlogonNetworkInformation:

        //
        // This SubAuthentication package doesn't support access via machine
        // accounts.
        //

        UserAccountControl = USER_NORMAL_ACCOUNT;

        //
        // Local user (Temp Duplicate) accounts are only used on the machine
        // being directly logged onto.
        // (Nor are interactive or service logons allowed to them.)
        //

        if ( (Flags & MSV1_0_PASSTHRU) == 0 ) {
            UserAccountControl |= USER_TEMP_DUPLICATE_ACCOUNT;
        }

        LogonNetworkInfo = (PNETLOGON_NETWORK_INFO) LogonInformation;

        break;

    default:
        return STATUS_INVALID_INFO_CLASS;
    }


    //
    // Check the password.
    //

#define IIS_SUBAUTH_SEED    0x8467fd31

    switch( ((WCHAR*)(LogonNetworkInfo->NtChallengeResponse.Buffer))[0] )
    {
        case L'0':
            if ( !NetUserCookieW( LogonNetworkInfo->Identity.UserName.Buffer,
                                  LogonNetworkInfo->Identity.UserName.Length/sizeof(WCHAR),
                                  IIS_SUBAUTH_SEED,
                                  achCookie,
                                  sizeof(achCookie ))
                 || memcmp( (LPBYTE)achCookie,
                            ((WCHAR*)LogonNetworkInfo->NtChallengeResponse.Buffer)+2,
                            wcslen(achCookie)*sizeof(WCHAR)
                            ) )
            {
wrong_pwd:
                Status = STATUS_WRONG_PASSWORD;

            }
            else
            {
                Status = STATUS_SUCCESS;
            }

            goto Cleanup;

            break;

        case L'1':
            // NTLM digest authentication
            fNTDigest = TRUE;

            //fall through

        case L'2':
            //"Normal" digest authentication

            // break fields

            pch = LogonNetworkInfo->LmChallengeResponse.Buffer;

            if ( !Extract( &pch, &pszRealm ) || // skip 1st field
                 !Extract( &pch, &pszRealm ) ||
                 !Extract( &pch, &pszUri ) ||
                 !Extract( &pch, &pszMethod ) ||
                 !Extract( &pch, &pszNonce ) ||
                 !Extract( &pch, &pszServerNonce ) ||
                 !Extract( &pch, &pszDigest ) ||
                 !Extract( &pch, &pszDigestUsername ) ||
                 !Extract( &pch, &pszQOP ) ||
                 !Extract( &pch, &pszCNonce ) ||
                 !Extract( &pch, &pszNC ) )
            {
                Status = STATUS_ACCESS_DENIED;
                goto Cleanup;
            }

            //
            // For NTLM Digest, use the NT hash of the password passed in
            // For 'normal' Digest, use the cleartext
            //
            if ( fNTDigest )
            {
                if ( UserAll->NtPasswordPresent )
                {
                    pPwd = &UserAll->NtPassword;
                }
                else if ( UserAll->LmPasswordPresent )
                {
                    pPwd = &UserAll->LmPassword;
                }
                else
                {
                    pPwd = &EmptyString;
                }
            }
            else
            {
                //
                // Retrieve the plaintext password
                //
                // NOTE : On NT 5, this API only works on Domain Controllers !!
                //
                PackageName.Buffer = SAM_CLEARTEXT_CREDENTIAL_NAME;
                PackageName.Length = PackageName.MaximumLength = (USHORT)
                    wcslen( SAM_CLEARTEXT_CREDENTIAL_NAME ) * sizeof(WCHAR);

                Status = SamIRetrievePrimaryCredentials( (SAMPR_HANDLE) UserHandle,
                                                         &PackageName,
                                                         &pvPlainPwd,
                                                         &ulLength );


                if ( !NT_SUCCESS( Status ) )
                {
#if DBG
                    CHAR achErrorString[256];
                    wsprintf(achErrorString, "Failed to retrieve plaintext password, error 0x%x\n",
                             Status);
                    OutputDebugString(achErrorString);
#endif //DBG
                    //
                    // Explicitly set the status to be "wrong password" instead of whatever
                    // is returned by SamIRetrievePrimaryCredentials
                    //
                    Status = STATUS_WRONG_PASSWORD;
                    goto Cleanup;
                }
                else
                {
                    PSAMPR_USER_INFO_BUFFER             pUserInfo = NULL;
                    
                    //
                    // Need to differentiate between an empty password and
                    // a non-existant/unaccessible password
                    //

                    if ( ulLength == 0 )
                    {
                        Status = SamrQueryInformationUser( UserHandle,
                                                           UserAllInformation,
                                                           &pUserInfo );
                        if ( !NT_SUCCESS( Status ) )
                        {
                            Status = STATUS_ACCESS_DENIED;
                            goto Cleanup;
                        }
                        
                        if ( pUserInfo->All.LmPasswordPresent ||
                             pUserInfo->All.NtPasswordPresent )
                        {
                            Status = STATUS_WRONG_PASSWORD;

                            SamIFree_SAMPR_USER_INFO_BUFFER( pUserInfo,
                                                             UserAllInformation );
                            goto Cleanup;
                        }

                        SamIFree_SAMPR_USER_INFO_BUFFER( pUserInfo,
                                                         UserAllInformation );
                    }
                        
                    UserPwd.Buffer = (USHORT *) pvPlainPwd;
                    UserPwd.Length = UserPwd.MaximumLength = (USHORT) ulLength;
                }
                //
                // The unicode password has to be converted to ANSI
                //
                if ( !NT_SUCCESS( Status = RtlUnicodeStringToAnsiString( &AnsiPwd,
                                                                         &UserPwd,
                                                                         FALSE ) ) )
                {
                    goto Cleanup;
                }
            }

            //
            // A1 = username:realm:password
            //
            SubaAllocateString( &strA1, strlen( pszDigestUsername ) +
                                //wcslen(UserAll->UserName.Buffer) +
                                strlen(pszRealm) +
                                ( fNTDigest ? 32 : AnsiPwd.Length ) +
                                +2 +1 +32 );

            if ( !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA1, pszDigestUsername ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA1, ":" ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA1, pszRealm ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA1, ":" )) ||
                 (fNTDigest ? !NT_SUCCESS( Status = ToHex16( (LPBYTE)(pPwd->Buffer), &strA1 ) ) :
                              !NT_SUCCESS( Status = RtlAppendAsciizToString( &strA1, AnsiPwd.Buffer ) ) ) )
            {
                goto Cleanup;
            }

            //
            // A2 = Method:URI
            //

            if ( !SubaAllocateString( &strA2, strlen(pszMethod)+1+strlen(pszUri)+1+32 ) )
            {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }
                                
            if ( !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA2, pszMethod ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA2, ":" ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA2, pszUri ) ) )
            {
                goto Cleanup;
            }

            if ( !SubaAllocateString( &strDigest, 32 + 1 + strlen(pszNonce) + 1 + 32 +1 +32 + strlen(pszCNonce) + 32) )
            {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            //
            // build response digest as per Digest Auth spec
            // Response Digest = KD( H(A1), nonce : H(A2) )
            //                 = H( H(A1) : nonce : H(A2) )
            // In our case, the hash function is MD5
            //

            // H(A1)

            MD5Init( &md5 );
            MD5Update( &md5, (LPBYTE)strA1.Buffer, strA1.Length );
            MD5Final( &md5 );
            if ( !NT_SUCCESS( Status = ToHex16( md5.digest, &strDigest ) ) )
            {
                goto Cleanup;
            }

            // ":" nonce ":"

            if ( !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strDigest, ":" ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strDigest, pszNonce ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strDigest, ":" ) ) )
            {
                goto Cleanup;
            }

            if ( strcmp( pszQOP, "none" ) )
            {
                if ( strcmp( pszQOP, "auth" ) )
                {
                    Status = STATUS_ACCESS_DENIED;
                    goto Cleanup;
                }

                if ( !NT_SUCCESS( Status = RtlAppendAsciizToString( &strDigest, pszNC ) ) ||
                     !NT_SUCCESS( Status = RtlAppendAsciizToString( &strDigest, ":" ) ) ||
                     !NT_SUCCESS( Status = RtlAppendAsciizToString( &strDigest, pszCNonce ) ) ||
                     !NT_SUCCESS( Status = RtlAppendAsciizToString( &strDigest, ":" ) ) ||
                     !NT_SUCCESS( Status = RtlAppendAsciizToString( &strDigest, pszQOP ) ) ||
                     !NT_SUCCESS( Status = RtlAppendAsciizToString( &strDigest, ":" ) ) )
                {
                    goto Cleanup;
                }
            }

            // H(A2)

            MD5Init( &md5 );
            MD5Update( &md5, (LPBYTE)strA2.Buffer, strA2.Length );
            MD5Final( &md5 );
            if ( !NT_SUCCESS( ToHex16( md5.digest, &strDigest ) ) )
            {
                goto Cleanup;
            }

            // H( H(A1) ":" nonce ":" H(A2) ) if QOP not set
            // H( H(A1) ":" nonce ":" nc ":" cnonce ":" qop ":" H(A2) if set

            MD5Init( &md5 );
            MD5Update( &md5, (LPBYTE)strDigest.Buffer, strDigest.Length );
            MD5Final( &md5 );

            strDigest.Length = 0;
            if ( !NT_SUCCESS( Status = ToHex16( md5.digest, &strDigest ) ) )
            {
                goto Cleanup;
            }

            if ( memcmp( strDigest.Buffer, pszDigest, strDigest.Length ) )
            {
                Status = STATUS_WRONG_PASSWORD;
                goto Cleanup;
            }
            else
            {
                Status = STATUS_SUCCESS;
                goto Cleanup;
            }

            // checking for stalled nonce must be made by caller

            break;

        default:
            goto wrong_pwd;
    }

    //
    // Cleanup up before returning.
    //

Cleanup:

    if ( strA1.Buffer )
    {
        RtlFreeHeap(RtlProcessHeap(), 0, strA1.Buffer );
    }
    if ( strA2.Buffer )
    {
        RtlFreeHeap(RtlProcessHeap(), 0, strA2.Buffer );
    }
    if ( strDigest.Buffer )
    {
        RtlFreeHeap(RtlProcessHeap(), 0, strDigest.Buffer );
    }
    if ( pvPlainPwd )
    {
        RtlFreeHeap(RtlProcessHeap(), 0, pvPlainPwd);
    }


    //
    // the only thing we did was check the password
    //

    ValidationInfo;
    UserHandle;

    *ActionsPerformed = MSV1_0_SUBAUTH_PASSWORD;

    return Status;

}  // Msv1_0SubAuthenticationRoutineEx




BOOL
GetPasswordExpired (
    IN LARGE_INTEGER PasswordLastSet,
    IN LARGE_INTEGER MaxPasswordAge
    )

/*++

Routine Description:

    This routine returns true if the password is expired, false otherwise.

Arguments:

    PasswordLastSet - Time when the password was last set for this user.

    MaxPasswordAge - Maximum password age for any password in the domain.

Return Value:

    Returns true if password is expired.  False if not expired.

--*/
{
    LARGE_INTEGER PasswordMustChange;
    NTSTATUS Status;
    BOOLEAN rc;
    LARGE_INTEGER TimeNow;

    //
    // Compute the expiration time as the time the password was
    // last set plus the maximum age.
    //

    if ( PasswordLastSet.QuadPart < 0 || MaxPasswordAge.QuadPart > 0 ) {

        rc = TRUE;      // default for invalid times is that it is expired.

    } else {

        __try {

            PasswordMustChange.QuadPart =
                PasswordLastSet.QuadPart - MaxPasswordAge.QuadPart;
            //
            // Limit the resultant time to the maximum valid absolute time
            //

            if ( PasswordMustChange.QuadPart < 0 ) {

                rc = FALSE;

            } else {

                Status = QuerySystemTime( &TimeNow );
                if (NT_SUCCESS(Status)) {

                    if ( TimeNow.QuadPart >= PasswordMustChange.QuadPart ) {
                        rc = TRUE;

                    } else {

                        rc = FALSE;
                    }
                } else {
                    rc = FALSE;     // won't fail if QuerySystemTime failed.
                }
            }

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            rc = TRUE;
        }
    }

    return rc;

}  // GetPasswordExpired


NTSTATUS
QuerySystemTime (
    OUT PLARGE_INTEGER SystemTime
    )

/*++

Routine Description:

    This function returns the absolute system time. The time is in units of
    100nsec ticks since the base time which is midnight January 1, 1601.

Arguments:

    SystemTime - Supplies the address of a variable that will receive the
        current system time.

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_ACCESS_VIOLATION is returned if the output parameter for the
        system time cannot be written.

--*/

{
    SYSTEMTIME CurrentTime;

    GetSystemTime( &CurrentTime );

    if ( !SystemTimeToFileTime( &CurrentTime, (LPFILETIME) SystemTime ) ) {
        return STATUS_ACCESS_VIOLATION;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SampMatchworkstation(
    IN PUNICODE_STRING LogonWorkStation,
    IN PUNICODE_STRING WorkStations
    )

/*++

Routine Description:

    Check if the given workstation is a member of the list of workstations
    given.


Arguments:

    LogonWorkStations - UNICODE name of the workstation that the user is
        trying to log into.

    WorkStations - API list of workstations that the user is allowed to
        log into.


Return Value:


    STATUS_SUCCESS - The user is allowed to log into the workstation.



--*/
{
    PWCHAR          WorkStationName;
    UNICODE_STRING  Unicode;
    NTSTATUS        NtStatus;
    WCHAR           Buffer[256];
    USHORT          LocalBufferLength = 256;
    UNICODE_STRING  WorkStationsListCopy;
    BOOLEAN         BufferAllocated = FALSE;
    PWCHAR          TmpBuffer;

    //
    // Local workstation is always allowed
    // If WorkStations field is 0 everybody is allowed
    //

    if ( ( LogonWorkStation == NULL ) ||
        ( LogonWorkStation->Length == 0 ) ||
        ( WorkStations->Length == 0 ) ) {

        return( STATUS_SUCCESS );
    }

    //
    // Assume failure; change status only if we find the string.
    //

    NtStatus = STATUS_INVALID_WORKSTATION;

    //
    // WorkStationApiList points to our current location in the list of
    // WorkStations.
    //

    if ( WorkStations->Length > LocalBufferLength ) {

        WorkStationsListCopy.Buffer = LocalAlloc( 0, WorkStations->Length );
        BufferAllocated = TRUE;

        if ( WorkStationsListCopy.Buffer == NULL ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            return( NtStatus );
        }

        WorkStationsListCopy.MaximumLength = WorkStations->Length;

    } else {

        WorkStationsListCopy.Buffer = Buffer;
        WorkStationsListCopy.MaximumLength = LocalBufferLength;
    }

    CopyUnicodeString( &WorkStationsListCopy, WorkStations );

    //
    // wcstok requires a string the first time it's called, and NULL
    // for all subsequent calls.  Use a temporary variable so we
    // can do this.
    //

    TmpBuffer = WorkStationsListCopy.Buffer;

    while( WorkStationName = wcstok(TmpBuffer, L",") ) {

        TmpBuffer = NULL;
        InitUnicodeString( &Unicode, WorkStationName );
        if (EqualComputerName( &Unicode, LogonWorkStation )) {
            NtStatus = STATUS_SUCCESS;
            break;
        }
    }

    if ( BufferAllocated ) {
        LocalFree( WorkStationsListCopy.Buffer );
    }

    return( NtStatus );
}

NTSTATUS
AccountRestrictions(
    IN ULONG UserRid,
    IN PUNICODE_STRING LogonWorkStation,
    IN PUNICODE_STRING WorkStations,
    IN PLOGON_HOURS LogonHours,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    )

/*++

Routine Description:

    Validate a user's ability to log on at this time and at the workstation
    being logged onto.


Arguments:

    UserRid - The user id of the user to operate on.

    LogonWorkStation - The name of the workstation the logon is being
        attempted at.

    WorkStations - The list of workstations the user may log on to.  This
        information comes from the user's account information.  It must
        be in API list format.

    LogonHours - The times the user may logon.  This information comes
        from the user's account information.

    LogoffTime - Receives the time at which the user should log off the
        system.

    KickoffTime - Receives the time at which the user should be kicked
        off the system.


Return Value:


    STATUS_SUCCESS - Logon is permitted.

    STATUS_INVALID_LOGON_HOURS - The user is not authorized to log on at
        this time.

    STATUS_INVALID_WORKSTATION - The user is not authorized to log on to
        the specified workstation.


--*/
{

    static BOOLEAN GetForceLogoff = TRUE;
    static LARGE_INTEGER ForceLogoff = { 0x7fffffff, 0xFFFFFFF};

#define MILLISECONDS_PER_WEEK 7 * 24 * 60 * 60 * 1000

    SYSTEMTIME              CurrentTimeFields;
    LARGE_INTEGER           CurrentTime, CurrentUTCTime;
    LARGE_INTEGER           MillisecondsIntoWeekXUnitsPerWeek;
    LARGE_INTEGER           LargeUnitsIntoWeek;
    LARGE_INTEGER           Delta100Ns;
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    ULONG                   CurrentMsIntoWeek;
    ULONG                   LogoffMsIntoWeek;
    ULONG                   DeltaMs;
    ULONG                   MillisecondsPerUnit;
    ULONG                   CurrentUnitsIntoWeek;
    ULONG                   LogoffUnitsIntoWeek;
    USHORT                  i;
    TIME_ZONE_INFORMATION   TimeZoneInformation;
    DWORD TimeZoneId;
    LARGE_INTEGER           BiasIn100NsUnits;
    LONG                    BiasInMinutes;



    //
    // Only check for users other than the builtin ADMIN
    //

    if ( UserRid != DOMAIN_USER_RID_ADMIN) {

        //
        // Scan to make sure the workstation being logged into is in the
        // list of valid workstations - or if the list of valid workstations
        // is null, which means that all are valid.
        //

        NtStatus = SampMatchworkstation( LogonWorkStation, WorkStations );

        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // Check to make sure that the current time is a valid time to log
            // on in the LogonHours.
            //
            // We need to validate the time taking into account whether we are
            // in daylight savings time or standard time.  Thus, if the logon
            // hours specify that we are able to log on between 9am and 5pm,
            // this means 9am to 5pm standard time during the standard time
            // period, and 9am to 5pm daylight savings time when in the
            // daylight savings time.  Since the logon hours stored by SAM are
            // independent of daylight savings time, we need to add in the
            // difference between standard time and daylight savings time to
            // the current time before checking whether this time is a valid
            // time to log on.  Since this difference (or bias as it is called)
            // is actually held in the form
            //
            // Standard time = Daylight savings time + Bias
            //
            // the Bias is a negative number.  Thus we actually subtract the
            // signed Bias from the Current Time.

            //
            // First, get the Time Zone Information.
            //

            TimeZoneId = GetTimeZoneInformation(
                             (LPTIME_ZONE_INFORMATION) &TimeZoneInformation
                             );

            //
            // Next, get the appropriate bias (signed integer in minutes) to subtract from
            // the Universal Time Convention (UTC) time returned by NtQuerySystemTime
            // to get the local time.  The bias to be used depends whether we're
            // in Daylight Savings time or Standard Time as indicated by the
            // TimeZoneId parameter.
            //
            // local time  = UTC time - bias in 100Ns units
            //

            switch (TimeZoneId) {

            case TIME_ZONE_ID_UNKNOWN:

                //
                // There is no differentiation between standard and
                // daylight savings time.  Proceed as for Standard Time
                //

                BiasInMinutes = TimeZoneInformation.StandardBias;
                break;

            case TIME_ZONE_ID_STANDARD:

                BiasInMinutes = TimeZoneInformation.StandardBias;
                break;

            case TIME_ZONE_ID_DAYLIGHT:

                BiasInMinutes = TimeZoneInformation.DaylightBias;
                break;

            default:

                //
                // Something is wrong with the time zone information.  Fail
                // the logon request.
                //

                NtStatus = STATUS_INVALID_LOGON_HOURS;
                break;
            }

            if (NT_SUCCESS(NtStatus)) {

                //
                // Convert the Bias from minutes to 100ns units
                //

                BiasIn100NsUnits.QuadPart = ((LONGLONG)BiasInMinutes)
                                            * 60 * 10000000;

                //
                // Get the UTC time in 100Ns units used by Windows Nt.  This
                // time is GMT.
                //

                NtStatus = QuerySystemTime( &CurrentUTCTime );
            }

            if ( NT_SUCCESS( NtStatus ) ) {

                CurrentTime.QuadPart = CurrentUTCTime.QuadPart -
                              BiasIn100NsUnits.QuadPart;

                FileTimeToSystemTime( (PFILETIME)&CurrentTime, &CurrentTimeFields );

                CurrentMsIntoWeek = (((( CurrentTimeFields.wDayOfWeek * 24 ) +
                                       CurrentTimeFields.wHour ) * 60 +
                                       CurrentTimeFields.wMinute ) * 60 +
                                       CurrentTimeFields.wSecond ) * 1000 +
                                       CurrentTimeFields.wMilliseconds;

                MillisecondsIntoWeekXUnitsPerWeek.QuadPart =
                    ((LONGLONG)CurrentMsIntoWeek) *
                    ((LONGLONG)LogonHours->UnitsPerWeek);

                LargeUnitsIntoWeek.QuadPart =
                    MillisecondsIntoWeekXUnitsPerWeek.QuadPart / ((ULONG) MILLISECONDS_PER_WEEK);

                CurrentUnitsIntoWeek = LargeUnitsIntoWeek.LowPart;

                if ( !( LogonHours->LogonHours[ CurrentUnitsIntoWeek / 8] &
                    ( 0x01 << ( CurrentUnitsIntoWeek % 8 ) ) ) ) {

                    NtStatus = STATUS_INVALID_LOGON_HOURS;

                } else {

                    //
                    // Determine the next time that the user is NOT supposed to be logged
                    // in, and return that as LogoffTime.
                    //

                    i = 0;
                    LogoffUnitsIntoWeek = CurrentUnitsIntoWeek;

                    do {

                        i++;

                        LogoffUnitsIntoWeek = ( LogoffUnitsIntoWeek + 1 ) % LogonHours->UnitsPerWeek;

                    } while ( ( i <= LogonHours->UnitsPerWeek ) &&
                        ( LogonHours->LogonHours[ LogoffUnitsIntoWeek / 8 ] &
                        ( 0x01 << ( LogoffUnitsIntoWeek % 8 ) ) ) );

                    if ( i > LogonHours->UnitsPerWeek ) {

                        //
                        // All times are allowed, so there's no logoff
                        // time.  Return forever for both LogoffTime and
                        // KickoffTime.
                        //

                        LogoffTime->HighPart = 0x7FFFFFFF;
                        LogoffTime->LowPart = 0xFFFFFFFF;

                        KickoffTime->HighPart = 0x7FFFFFFF;
                        KickoffTime->LowPart = 0xFFFFFFFF;

                    } else {

                        //
                        // LogoffUnitsIntoWeek points at which time unit the
                        // user is to log off.  Calculate actual time from
                        // the unit, and return it.
                        //
                        // CurrentTimeFields already holds the current
                        // time for some time during this week; just adjust
                        // to the logoff time during this week and convert
                        // to time format.
                        //

                        MillisecondsPerUnit = MILLISECONDS_PER_WEEK / LogonHours->UnitsPerWeek;

                        LogoffMsIntoWeek = MillisecondsPerUnit * LogoffUnitsIntoWeek;

                        if ( LogoffMsIntoWeek < CurrentMsIntoWeek ) {

                            DeltaMs = MILLISECONDS_PER_WEEK - ( CurrentMsIntoWeek - LogoffMsIntoWeek );

                        } else {

                            DeltaMs = LogoffMsIntoWeek - CurrentMsIntoWeek;
                        }

                        Delta100Ns.QuadPart = (LONGLONG) DeltaMs * 10000;

                        LogoffTime->QuadPart = CurrentUTCTime.QuadPart +
                                      Delta100Ns.QuadPart;

                        //
                        // Grab the domain's ForceLogoff time.
                        //

                        if ( GetForceLogoff ) {
                            NET_API_STATUS NetStatus;
                            LPUSER_MODALS_INFO_0 UserModals0;

                            NetStatus = NetUserModalsGet( NULL,
                                                          0,
                                                          (LPBYTE *)&UserModals0 );

                            if ( NetStatus == 0 ) {
                                GetForceLogoff = FALSE;

                                ForceLogoff = NetpSecondsToDeltaTime( UserModals0->usrmod0_force_logoff );

                                NetApiBufferFree( UserModals0 );
                            }
                        }
                        //
                        // Subtract Domain->ForceLogoff from LogoffTime, and return
                        // that as KickoffTime.  Note that Domain->ForceLogoff is a
                        // negative delta.  If its magnitude is sufficiently large
                        // (in fact, larger than the difference between LogoffTime
                        // and the largest positive large integer), we'll get overflow
                        // resulting in a KickOffTime that is negative.  In this
                        // case, reset the KickOffTime to this largest positive
                        // large integer (i.e. "never") value.
                        //


                        KickoffTime->QuadPart = LogoffTime->QuadPart - ForceLogoff.QuadPart;

                        if (KickoffTime->QuadPart < 0) {

                            KickoffTime->HighPart = 0x7FFFFFFF;
                            KickoffTime->LowPart = 0xFFFFFFFF;
                        }
                    }
                }
            }
        }

    } else {

        //
        // Never kick administrators off
        //

        LogoffTime->HighPart  = 0x7FFFFFFF;
        LogoffTime->LowPart   = 0xFFFFFFFF;
        KickoffTime->HighPart = 0x7FFFFFFF;
        KickoffTime->LowPart  = 0xFFFFFFFF;
    }


    return( NtStatus );
}

LARGE_INTEGER
NetpSecondsToDeltaTime(
    IN ULONG Seconds
    )

/*++

Routine Description:

    Convert a number of seconds to an NT delta time specification

Arguments:

    Seconds - a positive number of seconds

Return Value:

    Returns the NT Delta time.  NT delta time is a negative number
        of 100ns units.

--*/

{
    LARGE_INTEGER DeltaTime;
    LARGE_INTEGER LargeSeconds;
    LARGE_INTEGER Answer;

    //
    // Special case TIMEQ_FOREVER (return a full scale negative)
    //

    if ( Seconds == TIMEQ_FOREVER ) {
        DeltaTime.LowPart = 0;
        DeltaTime.HighPart = (LONG) 0x80000000;

    //
    // Convert seconds to 100ns units simply by multiplying by 10000000.
    //
    // Convert to delta time by negating.
    //

    } else {

        LargeSeconds.LowPart = Seconds;
        LargeSeconds.HighPart = 0;

        Answer.QuadPart = LargeSeconds.QuadPart * 10000000;

          if ( Answer.QuadPart < 0 ) {
            DeltaTime.LowPart = 0;
            DeltaTime.HighPart = (LONG) 0x80000000;
        } else {
            DeltaTime.QuadPart = -Answer.QuadPart;
        }

    }

    return DeltaTime;

} // NetpSecondsToDeltaTime


BOOLEAN
EqualComputerName(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2
    )
/*++

Routine Description:

    Compare two computer names for equality.

Arguments:

    String1 - Name of first computer.
    String2 - Name of second computer.

Return Value:

    TRUE if the names, converted to OEM, compare case-insensitively,
    FALSE if they don't compare or can't be converted to OEM.

--*/
{
    WCHAR Computer1[CNLEN+1];
    WCHAR Computer2[CNLEN+1];
    CHAR OemComputer1[CNLEN+1];
    CHAR OemComputer2[CNLEN+1];

    //
    // Make sure the names are not too long
    //

    if ((String1->Length > CNLEN*sizeof(WCHAR)) ||
        (String2->Length > CNLEN*sizeof(WCHAR))) {
        return(FALSE);

    }

    //
    // Copy them to null terminated strings
    //

    CopyMemory(
        Computer1,
        String1->Buffer,
        String1->Length
        );
    Computer1[String1->Length/sizeof(WCHAR)] = L'\0';

    CopyMemory(
        Computer2,
        String2->Buffer,
        String2->Length
        );
    Computer2[String2->Length/sizeof(WCHAR)] = L'\0';

    //
    // Convert the computer names to OEM
    //

    if (!CharToOemW(
            Computer1,
            OemComputer1
            )) {
        return(FALSE);
    }

    if (!CharToOemW(
            Computer2,
            OemComputer2
            )) {
        return(FALSE);
    }

    //
    // Do a case insensitive comparison of the oem computer names.
    //

    if (lstrcmpiA(OemComputer1, OemComputer2) == 0)
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

VOID
InitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The InitUnicodeString function initializes an NT counted
    unicode string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated unicode string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PWSTR)SourceString;
    if (SourceString != NULL) {
        Length = wcslen( SourceString ) * sizeof( WCHAR );
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
        }
    else {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
        }
}

VOID
CopyUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString OPTIONAL
    )

/*++

Routine Description:

    The CopyString function copies the SourceString to the
    DestinationString.  If SourceString is not specified, then
    the Length field of DestinationString is set to zero.  The
    MaximumLength and Buffer fields of DestinationString are not
    modified by this function.

    The number of bytes copied from the SourceString is either the
    Length of SourceString or the MaximumLength of DestinationString,
    whichever is smaller.

Arguments:

    DestinationString - Pointer to the destination string.

    SourceString - Optional pointer to the source string.

Return Value:

    None.

--*/

{
    UNALIGNED WCHAR *src, *dst;
    ULONG n;

    if (SourceString != NULL) {
        dst = DestinationString->Buffer;
        src = SourceString->Buffer;
        n = SourceString->Length;
        if ((USHORT)n > DestinationString->MaximumLength) {
            n = DestinationString->MaximumLength;
        }

        DestinationString->Length = (USHORT)n;
        CopyMemory(dst, src, n);
        if (DestinationString->Length < DestinationString->MaximumLength) {
            dst[n / sizeof(WCHAR)] = UNICODE_NULL;
        }

    } else {
        DestinationString->Length = 0;
    }

    return;
}

#if 0

NTSTATUS
Msv1_0SubAuthenticationRoutine (
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
)
/*++

Routine Description:

    The subauthentication routine does client/server specific authentication
    of a user. The credentials of the user are passed in addition to all the
    information from SAM defining the user. This routine decides whether to
    let the user log on.


Arguments:

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.  The LogonDomainName field should be ignored.

    Flags - Flags describing the circumstances of the logon.

        MSV1_0_PASSTHRU -- This is a PassThru authenication.  (i.e., the
            user isn't connecting to this machine.)
        MSV1_0_GUEST_LOGON -- This is a retry of the logon using the GUEST
            user account.

    UserAll -- The description of the user as returned from SAM.

    WhichFields -- Returns which fields from UserAllInfo are to be written
        back to SAM.  The fields will only be written if MSV returns success
        to it's caller.  Only the following bits are valid.

        USER_ALL_PARAMETERS - Write UserAllInfo->Parameters back to SAM.  If
            the size of the buffer is changed, Msv1_0SubAuthenticationRoutine
            must delete the old buffer using MIDL_user_free() and reallocate the
            buffer using MIDL_user_allocate().

    UserFlags -- Returns UserFlags to be returned from LsaLogonUser in the
        LogonProfile.  The following bits are currently defined:


            LOGON_GUEST -- This was a guest logon
            LOGON_NOENCRYPTION -- The caller didn't specify encrypted credentials

        SubAuthentication packages should restrict themselves to returning
        bits in the high order byte of UserFlags.  However, this convention
        isn't enforced giving the SubAuthentication package more flexibility.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.

    LogoffTime - Receives the time at which the user should log off the
        system.  This time is specified as a GMT relative NT system time.

    KickoffTime - Receives the time at which the user should be kicked
        off the system. This time is specified as a GMT relative system
        time.  Specify, a full scale positive number if the user isn't to
        be kicked off.

Return Value:

    STATUS_SUCCESS: if there was no error.

    STATUS_NO_SUCH_USER: The specified user has no account.
    STATUS_WRONG_PASSWORD: The password was invalid.

    STATUS_INVALID_INFO_CLASS: LogonLevel is invalid.
    STATUS_ACCOUNT_LOCKED_OUT: The account is locked out
    STATUS_ACCOUNT_DISABLED: The account is disabled
    STATUS_ACCOUNT_EXPIRED: The account has expired.
    STATUS_PASSWORD_MUST_CHANGE: Account is marked as Password must change
        on next logon.
    STATUS_PASSWORD_EXPIRED: The Password is expired.
    STATUS_INVALID_LOGON_HOURS - The user is not authorized to log on at
        this time.
    STATUS_INVALID_WORKSTATION - The user is not authorized to log on to
        the specified workstation.

--*/
{
    NTSTATUS Status;
    ULONG UserAccountControl;
    LARGE_INTEGER LogonTime;
    LARGE_INTEGER PasswordDateSet;
    UNICODE_STRING LocalWorkstation;
    WCHAR achCookie[64];
    ANSI_STRING strA1;
    ANSI_STRING strA2;
    ANSI_STRING strDigest;
    ANSI_STRING strPassword;
    MD5_CTX md5;
    CHAR *pch;
    LPSTR pszRealm;
    LPSTR pszUri;
    LPSTR pszMethod;
    LPSTR pszNonce;
    LPSTR pszServerNonce;
    LPSTR pszDigest;
    LPSTR pszDigestUsername;
    PNETLOGON_NETWORK_INFO LogonNetworkInfo;
    UINT l;
    PUNICODE_STRING pPwd;

    strA1.Buffer = NULL;
    strA2.Buffer = NULL;
    strDigest.Buffer = NULL;
    strPassword.Buffer = NULL;

    //
    // Check whether the SubAuthentication package supports this type
    //  of logon.
    //

    *Authoritative = TRUE;
    *UserFlags = 0;
    *WhichFields = 0;

    (VOID) QuerySystemTime( &LogonTime );

    switch ( LogonLevel ) {
    case NetlogonInteractiveInformation:
    case NetlogonServiceInformation:

        //
        // This SubAuthentication package only supports network logons.
        //

        return STATUS_INVALID_INFO_CLASS;

    case NetlogonNetworkInformation:

        //
        // This SubAuthentication package doesn't support access via machine
        // accounts.
        //

        UserAccountControl = USER_NORMAL_ACCOUNT;

        //
        // Local user (Temp Duplicate) accounts are only used on the machine
        // being directly logged onto.
        // (Nor are interactive or service logons allowed to them.)
        //

        if ( (Flags & MSV1_0_PASSTHRU) == 0 ) {
            UserAccountControl |= USER_TEMP_DUPLICATE_ACCOUNT;
        }

        LogonNetworkInfo = (PNETLOGON_NETWORK_INFO) LogonInformation;

        break;

    default:
        *Authoritative = TRUE;
        return STATUS_INVALID_INFO_CLASS;
    }




    //
    // If the account type isn't allowed,
    //  Treat this as though the User Account doesn't exist.
    //

    if ( (UserAccountControl & UserAll->UserAccountControl) == 0 ) {
        *Authoritative = FALSE;
        Status = STATUS_NO_SUCH_USER;
        goto Cleanup;
    }

    //
    // This SubAuthentication package doesn't allow guest logons.
    //
    if ( Flags & MSV1_0_GUEST_LOGON ) {
        *Authoritative = FALSE;
        Status = STATUS_NO_SUCH_USER;
        goto Cleanup;
    }



    //
    // Ensure the account isn't locked out.
    //

    if ( UserAll->UserId != DOMAIN_USER_RID_ADMIN &&
         (UserAll->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED) ) {

        //
        // Since the UI strongly encourages admins to disable user
        // accounts rather than delete them.  Treat disabled acccount as
        // non-authoritative allowing the search to continue for other
        // accounts by the same name.
        //
        if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED ) {
            *Authoritative = FALSE;
        } else {
            *Authoritative = TRUE;
        }
        Status = STATUS_ACCOUNT_LOCKED_OUT;
        goto Cleanup;
    }


    //
    // Check the password.
    //

#define IIS_SUBAUTH_SEED    0x8467fd31

    switch( ((WCHAR*)(LogonNetworkInfo->NtChallengeResponse.Buffer))[0] )
    {
        case L'0':
            if ( !NetUserCookieW( LogonNetworkInfo->Identity.UserName.Buffer,
                                  LogonNetworkInfo->Identity.UserName.Length/sizeof(WCHAR),
                                  IIS_SUBAUTH_SEED,
                                  achCookie,
                                  sizeof(achCookie ))
                 || memcmp( (LPBYTE)achCookie,
                            ((WCHAR*)LogonNetworkInfo->NtChallengeResponse.Buffer)+2,
                            wcslen(achCookie)*sizeof(WCHAR)
                            ) )
            {
wrong_pwd:
                Status = STATUS_WRONG_PASSWORD;

                //
                // Since the UI strongly encourages admins to disable user
                // accounts rather than delete them.  Treat disabled acccount as
                // non-authoritative allowing the search to continue for other
                // accounts by the same name.
                //
                if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED ) {
                    *Authoritative = FALSE;
                } else {
                    *Authoritative = TRUE;
                }

                goto Cleanup;
            }
            break;

        case L'1':
            // digest NTLM authentication

            // break fields

            pch = LogonNetworkInfo->LmChallengeResponse.Buffer;

            if ( !Extract( &pch, &pszRealm ) || // skip 1st field
                 !Extract( &pch, &pszRealm ) ||
                 !Extract( &pch, &pszUri ) ||
                 !Extract( &pch, &pszMethod ) ||
                 !Extract( &pch, &pszNonce ) ||
                 !Extract( &pch, &pszServerNonce ) ||
                 !Extract( &pch, &pszDigest ) ||
                 !Extract( &pch, &pszDigestUsername ) )
            {
                Status = STATUS_INVALID_INFO_CLASS;
                goto Cleanup;
            }

            if ( UserAll->NtPasswordPresent )
            {
                pPwd = &UserAll->NtPassword;
            }
            else if ( UserAll->LmPasswordPresent )
            {
                pPwd = &UserAll->LmPassword;
            }
            else
            {
                pPwd = &EmptyString;
            }

            // build A1 & A2 as per Digest-NTLM auth spec

            SubaAllocateString( &strA1, strlen( pszDigestUsername ) +
                    //wcslen(UserAll->UserName.Buffer) +
                    strlen(pszRealm) +
                    32 //wcslen(pPwd)
                    +2 +1 +32
                    );

            if ( !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA1, pszDigestUsername ) ) ||
                 //!NT_SUCCESS( Status = RtlUnicodeStringToAnsiString( &strA1, &UserAll->UserName, FALSE )) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA1, ":" ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA1, pszRealm ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA1, ":" )) ||
                 !NT_SUCCESS( ToHex16( (LPBYTE)(pPwd->Buffer), &strA1 ) ) )
                 //!NT_SUCCESS( Status = RtlUnicodeStringToAnsiString( &strPassword, pPwd, TRUE ) ) ||
                 //!NT_SUCCESS( Status = RtlAppendStringToString( (PSTRING)&strA1, (PSTRING)&strPassword ) ) )
            {
                goto Cleanup;
            }

            SubaAllocateString( &strA2, strlen(pszMethod)+1+strlen(pszUri)+1+32 );
            if ( !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA2, pszMethod ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA2, ":" ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA2, pszUri ) ) )
            {
                goto Cleanup;
            }

            SubaAllocateString( &strDigest, 32 + 1 + strlen(pszNonce) + 1 + 32 +1 +32 );

            // build response digest as per Digest Auth spec

            // H(A1)

            MD5Init( &md5 );
            MD5Update( &md5, (LPBYTE)strA1.Buffer, strA1.Length );
            MD5Final( &md5 );
            if ( !NT_SUCCESS( ToHex16( md5.digest, &strDigest ) ) )
            {
                goto Cleanup;
            }

            // ":" nonce ":"

            if ( !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strDigest, ":" ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strDigest, pszNonce ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strDigest, ":" ) ) )
            {
                goto Cleanup;
            }

            // H(A2)

            MD5Init( &md5 );
            MD5Update( &md5, (LPBYTE)strA2.Buffer, strA2.Length );
            MD5Final( &md5 );
            if ( !NT_SUCCESS( ToHex16( md5.digest, &strDigest ) ) )
            {
                goto Cleanup;
            }

            // H( H(A1) ":" nonce ":" H(A2) )

            MD5Init( &md5 );
            MD5Update( &md5, (LPBYTE)strDigest.Buffer, strDigest.Length );
            MD5Final( &md5 );

            strDigest.Length = 0;
            if ( !NT_SUCCESS( ToHex16( md5.digest, &strDigest ) ) )
            {
                goto Cleanup;
            }

            if ( memcmp( strDigest.Buffer, pszDigest, strDigest.Length ) )
            {
                goto wrong_pwd;
            }

            // checking for stalled nonce must be made by caller

            break;

        default:
            goto wrong_pwd;
    }

    //
    // Prevent some things from effecting the Administrator user
    //

    if (UserAll->UserId == DOMAIN_USER_RID_ADMIN) {

        //
        //  The administrator account doesn't have a forced logoff time.
        //

        LogoffTime->HighPart = 0x7FFFFFFF;
        LogoffTime->LowPart = 0xFFFFFFFF;

        KickoffTime->HighPart = 0x7FFFFFFF;
        KickoffTime->LowPart = 0xFFFFFFFF;

    } else {

        //
        // Check if the account is disabled.
        //

        if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED ) {
            //
            // Since the UI strongly encourages admins to disable user
            // accounts rather than delete them.  Treat disabled acccount as
            // non-authoritative allowing the search to continue for other
            // accounts by the same name.
            //
            *Authoritative = FALSE;
            Status = STATUS_ACCOUNT_DISABLED;
            goto Cleanup;
        }

        //
        // Check if the account has expired.
        //

        if ( UserAll->AccountExpires.QuadPart != 0 &&
             LogonTime.QuadPart >= UserAll->AccountExpires.QuadPart ) {
            *Authoritative = TRUE;
            Status = STATUS_ACCOUNT_EXPIRED;
            goto Cleanup;
        }

        //
        //  If your using SAM's password expiration date, use this code, otherwise
        //  use the code below and supply your own password set date...
        //
#if 1
        //
        // The password is valid, check to see if the password is expired.
        //  (SAM will have appropriately set PasswordMustChange to reflect
        //  USER_DONT_EXPIRE_PASSWORD)
        //
        // If the password checked above is not the SAM password, you may
        // want to consider not checking the SAM password expiration times here.
        //

        if ( LogonTime.QuadPart >= UserAll->PasswordMustChange.QuadPart ) {

            if ( UserAll->PasswordLastSet.QuadPart == 0 ) {
                Status = STATUS_PASSWORD_MUST_CHANGE;
            } else {
                Status = STATUS_PASSWORD_EXPIRED;
            }
            *Authoritative = TRUE;
            goto Cleanup;
        }

#elif 0

        //
        // Response is correct. So, check if the password has expired or not
        //

        if (! (UserAll->UserAccountControl & USER_DONT_EXPIRE_PASSWORD)) {
            LARGE_INTEGER MaxPasswordAge;
            MaxPasswordAge.HighPart = 0x7FFFFFFF;
            MaxPasswordAge.LowPart = 0xFFFFFFFF;

            //
            // PasswordDateSet should be modified to hold the last date the
            // user's password was set.
            //

            PasswordDateSet.LowPart = 0;
            PasswordDateSet.HighPart = 0;

            if ( GetPasswordExpired( PasswordDateSet,
                        MaxPasswordAge )) {

                Status = STATUS_PASSWORD_EXPIRED;
                goto Cleanup;
            }
        }

#endif


#if 1

        //
        // Validate the workstation the user logged on from.
        //
        // Ditch leading \\ on workstation name before passing it to SAM.
        //

        LocalWorkstation = LogonNetworkInfo->Identity.Workstation;
        if ( LocalWorkstation.Length > 0 &&
             LocalWorkstation.Buffer[0] == L'\\' &&
             LocalWorkstation.Buffer[1] == L'\\' ) {
            LocalWorkstation.Buffer += 2;
            LocalWorkstation.Length -= 2*sizeof(WCHAR);
            LocalWorkstation.MaximumLength -= 2*sizeof(WCHAR);
        }


        //
        //  To validate the user's logon hours as SAM does it, use this code,
        //  otherwise, supply your own checks below this code.
        //

        Status = AccountRestrictions( UserAll->UserId,
                                      &LocalWorkstation,
                                      (PUNICODE_STRING) &UserAll->WorkStations,
                                      &UserAll->LogonHours,
                                      LogoffTime,
                                      KickoffTime );

        if ( !NT_SUCCESS( Status )) {
            goto Cleanup;
        }

#elif 0

        //
        // Validate the user's logon hours.
        //

        if ( TRUE /* VALIDATE THE LOGON HOURS */ ) {


            //
            // All times are allowed, so there's no logoff
            // time.  Return forever for both logofftime and
            // kickofftime.
            //

            LogoffTime->HighPart = 0x7FFFFFFF;
            LogoffTime->LowPart = 0xFFFFFFFF;

            KickoffTime->HighPart = 0x7FFFFFFF;
            KickoffTime->LowPart = 0xFFFFFFFF;
        } else {
            Status = STATUS_INVALID_LOGON_HOURS;
            *Authoritative = TRUE;
            goto Cleanup;
        }
#endif
#if 0
        //
        // Validate if the user can log on from this workstation.
        //  (Supply subauthentication package specific code here.)

        if ( LogonNetworkInfo->Identity.Workstation.Buffer == NULL ) {
            Status = STATUS_INVALID_WORKSTATION;
            *Authoritative = TRUE;
            goto Cleanup;
        }
#endif
    }


    //
    // The user is valid.
    //

    *Authoritative = TRUE;
    Status = STATUS_SUCCESS;

    //
    // Cleanup up before returning.
    //

Cleanup:

    if ( strA1.Buffer )
    {
        RtlFreeHeap(RtlProcessHeap(), 0, strA1.Buffer );
    }
    if ( strA2.Buffer )
    {
        RtlFreeHeap(RtlProcessHeap(), 0, strA2.Buffer );
    }
    if ( strDigest.Buffer )
    {
        RtlFreeHeap(RtlProcessHeap(), 0, strDigest.Buffer );
    }
    if ( strPassword.Buffer )
    {
        RtlFreeAnsiString( &strPassword );
    }

    return Status;

}  // Msv1_0SubAuthenticationRoutine


NTSTATUS
Msv1_0SubAuthenticationFilter (
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
)
{
    return( Msv1_0SubAuthenticationRoutine(
                LogonLevel,
                LogonInformation,
                Flags,
                UserAll,
                WhichFields,
                UserFlags,
                Authoritative,
                LogoffTime,
                KickoffTime
                ) );
}
#endif





// subauth.c eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iissuba\md5c.c ===
/*
 ***********************************************************************
 ** md5.c                                                             **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

//  Portions copyright (c) 1992 Microsoft Corp.
//  All rights reserved



#include <nt.h>
#define UINT4   ULONG

#include "md5.h"


/* Constants for Transform routine.
 */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static void TransformMD5 PROTO_LIST ((UINT4 *, UINT4 *));

static unsigned char PADDING[64] = {
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* F, G and H are basic MD5 functions */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

/* ROTATE_LEFT rotates x left n bits.
 */
#if CT_COMPILER == CT_MPW

/* MPW doesn't compile the macro correctly, so use a procedure. */
static UINT4 RotateLeft (UINT4, unsigned int);
#define ROTATE_LEFT RotateLeft

#else
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
#endif

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
  {(a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) \
  {(a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) \
  {(a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) \
  {(a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }

void MD5Init (mdContext)
MD5_CTX *mdContext;
{
  mdContext->i[0] = mdContext->i[1] = (UINT4)0;

  /* Load magic initialization constants.
   */
  mdContext->buf[0] = (UINT4)0x67452301;
  mdContext->buf[1] = (UINT4)0xefcdab89;
  mdContext->buf[2] = (UINT4)0x98badcfe;
  mdContext->buf[3] = (UINT4)0x10325476;
}

void MD5Update (mdContext, inBuf, inLen)
MD5_CTX *mdContext;
unsigned char *inBuf;
unsigned int inLen;
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* update number of bits */
  if ((mdContext->i[0] + ((UINT4)inLen << 3)) < mdContext->i[0])
    mdContext->i[1]++;
  mdContext->i[0] += ((UINT4)inLen << 3);
  mdContext->i[1] += ((UINT4)inLen >> 29);

  while (inLen--) {
    /* add new character to buffer, increment mdi */
    mdContext->in[mdi++] = *inBuf++;

    /* transform if necessary */
    if (mdi == 0x40) {
      for (i = 0, ii = 0; i < 16; i++, ii += 4)
        in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
                (((UINT4)mdContext->in[ii+2]) << 16) |
                (((UINT4)mdContext->in[ii+1]) << 8) |
                ((UINT4)mdContext->in[ii]);
      TransformMD5 (mdContext->buf, in);
      mdi = 0;
    }
  }
}

void MD5Final (mdContext)
MD5_CTX *mdContext;
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;
  unsigned int padLen;

  /* save number of bits */
  in[14] = mdContext->i[0];
  in[15] = mdContext->i[1];

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* pad out to 56 mod 64 */
  padLen = (mdi < 56) ? (56 - mdi) : (120 - mdi);
  MD5Update (mdContext, PADDING, padLen);

  /* append length in bits and transform */
  for (i = 0, ii = 0; i < 14; i++, ii += 4)
    in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
            (((UINT4)mdContext->in[ii+2]) << 16) |
            (((UINT4)mdContext->in[ii+1]) << 8) |
            ((UINT4)mdContext->in[ii]);
  TransformMD5 (mdContext->buf, in);

  /* store buffer in digest */
  for (i = 0, ii = 0; i < 4; i++, ii += 4) {
    mdContext->digest[ii] = (unsigned char)(mdContext->buf[i] & 0xff);
    mdContext->digest[ii+1] =
      (unsigned char)((mdContext->buf[i] >> 8) & 0xff);
    mdContext->digest[ii+2] =
      (unsigned char)((mdContext->buf[i] >> 16) & 0xff);
    mdContext->digest[ii+3] =
      (unsigned char)((mdContext->buf[i] >> 24) & 0xff);
  }
}

/* Basic MD5 step. Transforms buf based on in.
 */
static void TransformMD5 (buf, in)
UINT4 *buf;
UINT4 *in;
{
  UINT4 a = buf[0], b = buf[1], c = buf[2], d = buf[3];

  /* Round 1 */
  FF ( a, b, c, d, in[ 0], S11, 0xd76aa478); /* 1 */
  FF ( d, a, b, c, in[ 1], S12, 0xe8c7b756); /* 2 */
  FF ( c, d, a, b, in[ 2], S13, 0x242070db); /* 3 */
  FF ( b, c, d, a, in[ 3], S14, 0xc1bdceee); /* 4 */
  FF ( a, b, c, d, in[ 4], S11, 0xf57c0faf); /* 5 */
  FF ( d, a, b, c, in[ 5], S12, 0x4787c62a); /* 6 */
  FF ( c, d, a, b, in[ 6], S13, 0xa8304613); /* 7 */
  FF ( b, c, d, a, in[ 7], S14, 0xfd469501); /* 8 */
  FF ( a, b, c, d, in[ 8], S11, 0x698098d8); /* 9 */
  FF ( d, a, b, c, in[ 9], S12, 0x8b44f7af); /* 10 */
  FF ( c, d, a, b, in[10], S13, 0xffff5bb1); /* 11 */
  FF ( b, c, d, a, in[11], S14, 0x895cd7be); /* 12 */
  FF ( a, b, c, d, in[12], S11, 0x6b901122); /* 13 */
  FF ( d, a, b, c, in[13], S12, 0xfd987193); /* 14 */
  FF ( c, d, a, b, in[14], S13, 0xa679438e); /* 15 */
  FF ( b, c, d, a, in[15], S14, 0x49b40821); /* 16 */

  /* Round 2 */
  GG ( a, b, c, d, in[ 1], S21, 0xf61e2562); /* 17 */
  GG ( d, a, b, c, in[ 6], S22, 0xc040b340); /* 18 */
  GG ( c, d, a, b, in[11], S23, 0x265e5a51); /* 19 */
  GG ( b, c, d, a, in[ 0], S24, 0xe9b6c7aa); /* 20 */
  GG ( a, b, c, d, in[ 5], S21, 0xd62f105d); /* 21 */
  GG ( d, a, b, c, in[10], S22,  0x2441453); /* 22 */
  GG ( c, d, a, b, in[15], S23, 0xd8a1e681); /* 23 */
  GG ( b, c, d, a, in[ 4], S24, 0xe7d3fbc8); /* 24 */
  GG ( a, b, c, d, in[ 9], S21, 0x21e1cde6); /* 25 */
  GG ( d, a, b, c, in[14], S22, 0xc33707d6); /* 26 */
  GG ( c, d, a, b, in[ 3], S23, 0xf4d50d87); /* 27 */
  GG ( b, c, d, a, in[ 8], S24, 0x455a14ed); /* 28 */
  GG ( a, b, c, d, in[13], S21, 0xa9e3e905); /* 29 */
  GG ( d, a, b, c, in[ 2], S22, 0xfcefa3f8); /* 30 */
  GG ( c, d, a, b, in[ 7], S23, 0x676f02d9); /* 31 */
  GG ( b, c, d, a, in[12], S24, 0x8d2a4c8a); /* 32 */

  /* Round 3 */
  HH ( a, b, c, d, in[ 5], S31, 0xfffa3942); /* 33 */
  HH ( d, a, b, c, in[ 8], S32, 0x8771f681); /* 34 */
  HH ( c, d, a, b, in[11], S33, 0x6d9d6122); /* 35 */
  HH ( b, c, d, a, in[14], S34, 0xfde5380c); /* 36 */
  HH ( a, b, c, d, in[ 1], S31, 0xa4beea44); /* 37 */
  HH ( d, a, b, c, in[ 4], S32, 0x4bdecfa9); /* 38 */
  HH ( c, d, a, b, in[ 7], S33, 0xf6bb4b60); /* 39 */
  HH ( b, c, d, a, in[10], S34, 0xbebfbc70); /* 40 */
  HH ( a, b, c, d, in[13], S31, 0x289b7ec6); /* 41 */
  HH ( d, a, b, c, in[ 0], S32, 0xeaa127fa); /* 42 */
  HH ( c, d, a, b, in[ 3], S33, 0xd4ef3085); /* 43 */
  HH ( b, c, d, a, in[ 6], S34,  0x4881d05); /* 44 */
  HH ( a, b, c, d, in[ 9], S31, 0xd9d4d039); /* 45 */
  HH ( d, a, b, c, in[12], S32, 0xe6db99e5); /* 46 */
  HH ( c, d, a, b, in[15], S33, 0x1fa27cf8); /* 47 */
  HH ( b, c, d, a, in[ 2], S34, 0xc4ac5665); /* 48 */

  /* Round 4 */
  II ( a, b, c, d, in[ 0], S41, 0xf4292244); /* 49 */
  II ( d, a, b, c, in[ 7], S42, 0x432aff97); /* 50 */
  II ( c, d, a, b, in[14], S43, 0xab9423a7); /* 51 */
  II ( b, c, d, a, in[ 5], S44, 0xfc93a039); /* 52 */
  II ( a, b, c, d, in[12], S41, 0x655b59c3); /* 53 */
  II ( d, a, b, c, in[ 3], S42, 0x8f0ccc92); /* 54 */
  II ( c, d, a, b, in[10], S43, 0xffeff47d); /* 55 */
  II ( b, c, d, a, in[ 1], S44, 0x85845dd1); /* 56 */
  II ( a, b, c, d, in[ 8], S41, 0x6fa87e4f); /* 57 */
  II ( d, a, b, c, in[15], S42, 0xfe2ce6e0); /* 58 */
  II ( c, d, a, b, in[ 6], S43, 0xa3014314); /* 59 */
  II ( b, c, d, a, in[13], S44, 0x4e0811a1); /* 60 */
  II ( a, b, c, d, in[ 4], S41, 0xf7537e82); /* 61 */
  II ( d, a, b, c, in[11], S42, 0xbd3af235); /* 62 */
  II ( c, d, a, b, in[ 2], S43, 0x2ad7d2bb); /* 63 */
  II ( b, c, d, a, in[ 9], S44, 0xeb86d391); /* 64 */

  buf[0] += a;
  buf[1] += b;
  buf[2] += c;
  buf[3] += d;
}

#if CT_COMPILER == CT_MPW
static UINT4 RotateLeft (x, n)
UINT4 x;
unsigned int n;
{
  return (((x) << (n)) | ((x) >> (32-(n))));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\abw.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

      abw2.cxx

   Abstract:
      This module implements functions required for bandwidth throttling
       of network usage by ATQ module.

   Author:

       Murali R. Krishnan    ( MuraliK )     1-June-1995
       Bilal Alam            ( t-bilala )    7-March-1997

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Asynchronous Thread Queue DLL

--*/

#include "isatq.hxx"

//
// Global variables
//

extern PBANDWIDTH_INFO       g_pBandwidthInfo;

//
// Bandwidth Info shared variables
//

CRITICAL_SECTION        BANDWIDTH_INFO::sm_csSharedLock;
LIST_ENTRY              BANDWIDTH_INFO::sm_BornListHead;
LIST_ENTRY              BANDWIDTH_INFO::sm_ActiveListHead;
DWORD                   BANDWIDTH_INFO::sm_cBornList;
DWORD                   BANDWIDTH_INFO::sm_cActiveList;
ALLOC_CACHE_HANDLER*    BANDWIDTH_INFO::sm_pachBWInfos;
BOOL                    BANDWIDTH_INFO::sm_fGlobalEnabled;
BOOL                    BANDWIDTH_INFO::sm_fGlobalActive;
DWORD                   BANDWIDTH_INFO::sm_cNonInfinite;
DWORD                   BANDWIDTH_INFO::sm_cSamplesForTimeout;

//
// BANDWIDTH_INFO methods
//

VOID
BANDWIDTH_INFO::Initialize(
    IN BOOL             fPersistent
)
/*++
  Initialize bandwidth info object.  This is a pseudo-constructor for the
  class.

  Arguments:
    fPersistent - TRUE if this object is destroyed explicitly
                  FALSE if destroyed when refcount hits 0

  Returns:
    None

--*/
{
    _fMemberOfActiveList        = FALSE;
    _bandwidth.dwSpecifiedLevel = INFINITE;
    _bandwidth.dwLowThreshold   = INFINITE;
    _bandwidth.dwHighThreshold  = INFINITE;
    _cMaxBlockedList            = INFINITE;
    _fEnabled                   = FALSE;
    _Signature                  = ATQ_BW_INFO_SIGNATURE;
    _fIsFreed                   = FALSE;
    _fPersistent                = fPersistent;
    _cReference                 = 1;

    INITIALIZE_CRITICAL_SECTION( &_csPrivateLock );
    InitializeListHead( &_BlockedListHead );

    ZeroMemory( _rgBytesXfered, sizeof( _rgBytesXfered ) );

    _pBytesXferCur = _rgBytesXfered;  // points to start of array
    _cbXfered.QuadPart = 0;

    _pStatus = &sm_rgStatus[ ZoneLevelLow ][ 0 ];

    ClearStatistics();

    AddToBornList();

    SetDescription( "Default" );
}

VOID
BANDWIDTH_INFO::Terminate( VOID )
/*++
  Destroys bandwidth info object.  This is a pseudo-destructor.

  Arguments:
    None

  Returns:
    None

--*/
{
    Lock();

    // first prevent any new requests from getting blocked

    InterlockedExchangePointer( (PVOID *) &_pStatus,
                                (PVOID) &sm_rgStatus[ZoneLevelLow][0] );

    // disable the descriptor

    InterlockedExchange( (LPLONG) &_fEnabled, FALSE );

    // now remove any blocked requests

    ATQ_REQUIRE( CheckAndUnblockRequests() );
    ATQ_ASSERT( _cCurrentBlockedRequests == 0 );
    ATQ_ASSERT( IsListEmpty( &_BlockedListHead ) );

    Unlock();

    DeleteCriticalSection( &_csPrivateLock );

    // remove self from shared bandwidth info list

    SharedLock();

    RemoveFromBornList();

    SharedUnlock();

    _Signature = ATQ_BW_INFO_SIGNATURE_FREE;
}

BOOL
BANDWIDTH_INFO::PrepareToFree( VOID )
{
    InterlockedExchange( (LPLONG) &_fIsFreed, TRUE );
    Dereference();
    return TRUE;
}

BOOL
BANDWIDTH_INFO::BlockRequest(
    IN OUT PATQ_CONT        pAtqContext
)
/*++
  Block this request on the queue of requests waiting to be processed.

  Arguments:
    pAtqContext   pointer to ATQ context information for request that needs
                  to be blocked.

  Returns:
    TRUE on success. FALSE if there are any errors.
    (Use GetLastError() for details)

--*/
{
    BOOL            fRet = TRUE;

    ATQ_ASSERT( pAtqContext != NULL);
    ATQ_ASSERT( pAtqContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( IsValidAtqOp( pAtqContext->arInfo.atqOp ) );

    Lock();

    if ( _cCurrentBlockedRequests == _cMaxBlockedList )
    {
        fRet = FALSE;
    }
    else
    {
        pAtqContext->SetFlag( ACF_BLOCKED );

        InsertTailList( &_BlockedListHead, &pAtqContext->BlockedListEntry );

        IncCurrentBlockedRequests();
    }

    Unlock();

    return fRet;
}

BOOL
BANDWIDTH_INFO::RemoveFromBlockedList(
    IN PATQ_CONT            pAtqContext
)
/*++
  This function forcibly removes an ATQ context from blocked list of requests.

  Argument:
   pAtqContext    pointer to ATQ context whose request is in blocked list.

  Returns:
   TRUE on success and FALSE if there is any error.
--*/
{
    if ( !pAtqContext->IsBlocked() ) {

        // some other thread just removed this request from waiting list.
        return TRUE;
    }

    Lock();

    RemoveEntryList(&pAtqContext->BlockedListEntry);

    DecCurrentBlockedRequests();

    pAtqContext->ResetFlag( ACF_BLOCKED);

    Unlock();

    //
    // On such a forcible removal, we may have to make a callback indicating
    //   failure. Ignored!  To be done by the caller of this API.
    //

    return TRUE;
}

BOOL
BANDWIDTH_INFO::UnblockRequest(
    IN OUT PATQ_CONT        pAtqContext
)
/*++
  Unblocks this request from the queue of requests waiting to be processed.
  Call this function only when
       _pStatus[pAtqContext->atqOp] != StatusBlockOperation.
  First, this function removes the request from queue of requests and processes
   it according to status and operation to be performed.
  If the status is AllowRequest ==> this function restarts the operation.
  If the status is reject operation ==> rejects operation and invokes
                        call back function indicating the error status.

  Call this function after lock()ing


  Arguments:
    pAtqContext   pointer to ATQ context information for request that needs
                     to be unblocked.

  Returns:
    TRUE on success. FALSE if there are any errors.
    (Use GetLastError() for details)

--*/
{
    BOOL fRet = FALSE;

    ATQ_ASSERT( pAtqContext != NULL);
    ATQ_ASSERT( pAtqContext->Signature == ATQ_CONTEXT_SIGNATURE );

    // Remove the request from the blocked list entry
    RemoveEntryList( &pAtqContext->BlockedListEntry);
    DecCurrentBlockedRequests();
    pAtqContext->ResetFlag( ACF_BLOCKED );

    // Check and re enable the operation of pAtqContext

    switch ( _pStatus[ pAtqContext->arInfo.atqOp ] ) {

      case StatusAllowOperation:

        IncTotalAllowedRequests();
        switch ( pAtqContext->arInfo.atqOp) {

          case AtqIoRead:
            {
                DWORD cbRead;  // Discard after calling ReadFile()
                DWORD dwFlags = 0;

                // assume that this is a socket operation!
                if ( pAtqContext->arInfo.uop.opReadWrite.dwBufferCount > 1) {
                    ATQ_ASSERT( NULL !=
                                pAtqContext->arInfo.uop.opReadWrite.pBufAll);
                    fRet =
                        ((WSARecv( HANDLE_TO_SOCKET(pAtqContext->hAsyncIO),
                                   pAtqContext->arInfo.uop.opReadWrite.pBufAll,
                                   pAtqContext->arInfo.uop.opReadWrite.dwBufferCount,
                                   &cbRead,
                                   &dwFlags,
                                   pAtqContext->arInfo.lpOverlapped,
                                   NULL
                                   ) == 0)||
                         (WSAGetLastError() == WSA_IO_PENDING)
                         );

                    // free up the socket buffers
                    ::LocalFree( pAtqContext->arInfo.uop.opReadWrite.pBufAll);
                    pAtqContext->arInfo.uop.opReadWrite.pBufAll = NULL;
                } else {
                    WSABUF wsaBuf =
                    { pAtqContext->arInfo.uop.opReadWrite.buf1.len,
                      pAtqContext->arInfo.uop.opReadWrite.buf1.buf
                    };
                    fRet = (( WSARecv( HANDLE_TO_SOCKET(pAtqContext->hAsyncIO),
                                       &wsaBuf,
                                       1,
                                       &cbRead,
                                       &dwFlags,
                                       pAtqContext->arInfo.lpOverlapped,
                                       NULL
                                       ) == 0)||
                            (WSAGetLastError() == WSA_IO_PENDING)
                            );
                }
                break;
            }

          case AtqIoWrite:
            {
                DWORD cbWrite;  // Discard after calling WriteFile()

                // assume that this is a socket operation!
                if ( pAtqContext->arInfo.uop.opReadWrite.dwBufferCount > 1) {
                    ATQ_ASSERT( NULL !=
                                pAtqContext->arInfo.uop.opReadWrite.pBufAll);
                    fRet =
                        ((WSASend( HANDLE_TO_SOCKET(pAtqContext->hAsyncIO),
                                   pAtqContext->arInfo.uop.opReadWrite.pBufAll,
                                   pAtqContext->arInfo.uop.opReadWrite.dwBufferCount,
                                   &cbWrite,
                                   0,
                                   pAtqContext->arInfo.lpOverlapped,
                                   NULL
                                   ) == 0)||
                         (WSAGetLastError() == WSA_IO_PENDING)
                         );

                    // free up the socket buffers
                    ::LocalFree( pAtqContext->arInfo.uop.opReadWrite.pBufAll);
                    pAtqContext->arInfo.uop.opReadWrite.pBufAll = NULL;
                } else {
                    WSABUF wsaBuf =
                    { pAtqContext->arInfo.uop.opReadWrite.buf1.len,
                      pAtqContext->arInfo.uop.opReadWrite.buf1.buf
                    };
                    fRet = (( WSASend( HANDLE_TO_SOCKET(pAtqContext->hAsyncIO),
                                       &wsaBuf,
                                       1,
                                       &cbWrite,
                                       0,
                                       pAtqContext->arInfo.lpOverlapped,
                                       NULL
                                       ) == 0)||
                            (WSAGetLastError() == WSA_IO_PENDING)
                            );
                }
                break;
            }

          case AtqIoXmitFile:
            {
                fRet = g_pfnTransmitFile( HANDLE_TO_SOCKET(pAtqContext->hAsyncIO),
                                     pAtqContext->arInfo.uop.opXmit.hFile,
                                     pAtqContext->arInfo.uop.opXmit.
                                         dwBytesInFile,
                                     0,
                                     pAtqContext->arInfo.lpOverlapped,
                                     pAtqContext->arInfo.uop.
                                           opXmit.lpXmitBuffers,
                                     pAtqContext->arInfo.uop.
                                           opXmit.dwFlags );

                if ( !fRet && (GetLastError() == ERROR_IO_PENDING) ) {
                    fRet = TRUE;
                }
                break;
            }

          case AtqIoXmitFileRecv:
            {
                DWORD cbRead;

                // assume that this is a socket operation!
                if ( pAtqContext->arInfo.uop.opXmitRecv.dwBufferCount > 1) {
                    ATQ_ASSERT( NULL !=
                                pAtqContext->arInfo.uop.opXmitRecv.pBufAll);
                    fRet = I_AtqTransmitFileAndRecv
                               ( (PATQ_CONTEXT) pAtqContext,
                                 pAtqContext->arInfo.uop.opXmitRecv.hFile,
                                 pAtqContext->arInfo.uop.opXmitRecv.dwBytesInFile,
                                 pAtqContext->arInfo.uop.opXmitRecv.lpXmitBuffers,
                                 pAtqContext->arInfo.uop.opXmitRecv.dwTFFlags,
                                 pAtqContext->arInfo.uop.opXmitRecv.pBufAll,
                                 pAtqContext->arInfo.uop.opXmitRecv.dwBufferCount
                                );
                    // free up the socket buffers
                    ::LocalFree( pAtqContext->arInfo.uop.opXmitRecv.pBufAll);
                    pAtqContext->arInfo.uop.opXmitRecv.pBufAll = NULL;
                }
                else
                {
                    WSABUF wsaBuf =
                    { pAtqContext->arInfo.uop.opXmitRecv.buf1.len,
                      pAtqContext->arInfo.uop.opXmitRecv.buf1.buf
                    };
                    fRet = I_AtqTransmitFileAndRecv
                               ( (PATQ_CONTEXT) pAtqContext,
                                 pAtqContext->arInfo.uop.opXmitRecv.hFile,
                                 pAtqContext->arInfo.uop.opXmitRecv.dwBytesInFile,
                                 pAtqContext->arInfo.uop.opXmitRecv.lpXmitBuffers,
                                 pAtqContext->arInfo.uop.opXmitRecv.dwTFFlags,
                                 &wsaBuf,
                                 1 );
                }

                if ( !fRet && GetLastError() == ERROR_IO_PENDING )
                {
                    fRet = TRUE;
                }
                break;
            }

          case AtqIoSendRecv:
            {
                WSABUF wsaSendBuf =
                { pAtqContext->arInfo.uop.opSendRecv.sendbuf1.len,
                  pAtqContext->arInfo.uop.opSendRecv.sendbuf1.buf
                };

                WSABUF wsaRecvBuf =
                {
                  pAtqContext->arInfo.uop.opSendRecv.recvbuf1.len,
                  pAtqContext->arInfo.uop.opSendRecv.recvbuf1.buf
                };

                LPWSABUF     pSendBuf = &wsaSendBuf;
                LPWSABUF     pRecvBuf = &wsaRecvBuf;

                if ( pAtqContext->arInfo.uop.opSendRecv.dwSendBufferCount > 1 )
                {
                    pSendBuf = pAtqContext->arInfo.uop.opSendRecv.pSendBufAll;
                }

                if ( pAtqContext->arInfo.uop.opSendRecv.dwRecvBufferCount > 1 )
                {
                    pRecvBuf = pAtqContext->arInfo.uop.opSendRecv.pRecvBufAll;
                }

                ATQ_ASSERT( pSendBuf != NULL );
                ATQ_ASSERT( pRecvBuf != NULL );

                fRet = I_AtqSendAndRecv
                                    ( (PATQ_CONTEXT) pAtqContext,
                                      pSendBuf,
                                      pAtqContext->arInfo.uop.opSendRecv.
                                        dwSendBufferCount,
                                      pRecvBuf,
                                      pAtqContext->arInfo.uop.opSendRecv.
                                        dwRecvBufferCount );

                if ( pAtqContext->arInfo.uop.opSendRecv.pSendBufAll != NULL )
                {
                    ::LocalFree( pAtqContext->arInfo.uop.opSendRecv.pSendBufAll );
                }

                if ( pAtqContext->arInfo.uop.opSendRecv.pRecvBufAll != NULL )
                {
                    ::LocalFree( pAtqContext->arInfo.uop.opSendRecv.pSendBufAll );
                }

                if ( !fRet && (GetLastError() == ERROR_IO_PENDING ) ) {
                    fRet = TRUE;
                }

                break;
            }

          default:
            ATQ_ASSERT( FALSE);
            break;
        } // switch

        pAtqContext->arInfo.atqOp = AtqIoNone; // reset since operation done.
        break;

      case StatusRejectOperation:

        IncTotalRejectedRequests();
        if ( ((pAtqContext->arInfo.atqOp == AtqIoRead) ||
             (pAtqContext->arInfo.atqOp == AtqIoRead)) &&
             (pAtqContext->arInfo.uop.opReadWrite.pBufAll != NULL)
             ) {
            ::LocalFree( pAtqContext->arInfo.uop.opReadWrite.pBufAll);
            pAtqContext->arInfo.uop.opReadWrite.pBufAll = NULL;
        }
        pAtqContext->arInfo.atqOp = AtqIoNone; // reset since op rejected.
        SetLastError( ERROR_NETWORK_BUSY);
        fRet = FALSE;
        break;

      case StatusBlockOperation:
        // do nothing. we cannot unblock
        ATQ_ASSERT(FALSE);
        return (TRUE);

      default:
        ATQ_ASSERT( FALSE);
        break;
    } // switch

    if (!fRet) {

        // Call the completion function to signify the error in operation.

        //
        //  Reset the timeout value so requests don't
        //  timeout multiple times
        //

        InterlockedExchange(
                    (LPLONG ) &pAtqContext->NextTimeout,
                    ATQ_INFINITE
                    );

        InterlockedDecrement( &pAtqContext->m_nIO);

        pAtqContext->IOCompletion( 0,
                                   GetLastError(),
                                   pAtqContext->arInfo.lpOverlapped );
    } // on failure.

    return (fRet);
}

BOOL
BANDWIDTH_INFO::CheckAndUnblockRequests( VOID )
/*++
  Checks the list of blocked requests and identifies all operations
  that needs to be unblocked. This function unblocks those requests and
  removes them from blocked list.

  Always call this function after lock()ing

  Returns:
    TRUE on success and FALSE on failure.

--*/
{
    BOOL fRet = TRUE;

    //
    //  If the list is not empty, then check and process blocked requests.
    //

    if ( !IsListEmpty( &_BlockedListHead ) ) {

        PLIST_ENTRY pentry;

        //
        //  Scan the blocked requests list looking for pending requests
        //   that needs to be unblocked and unblock these requests.
        //

        for (pentry  = _BlockedListHead.Flink;
             pentry != &_BlockedListHead;
             pentry  = pentry->Flink )
          {
              PATQ_CONT pContext = CONTAINING_RECORD(pentry,
                                                     ATQ_CONTEXT,
                                                     BlockedListEntry );

              if ( pContext->Signature != ATQ_CONTEXT_SIGNATURE)
                {
                    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                    fRet = FALSE;
                    break;
                }

              if ( !pContext->IsBlocked()) {

                  // This should not happen.
                  ATQ_ASSERT( !pContext->IsBlocked());
                  fRet = FALSE;
                  continue;
              }

              //
              //  Check to see if the status for operation has changed.
              //  If so, unblock the request.
              //

              if ( _pStatus[pContext->arInfo.atqOp] !=
                  StatusBlockOperation) {

                  fRet &= UnblockRequest( pContext );
              }

          } // scan list
    }

    return (fRet);
}

BOOL
BANDWIDTH_INFO::UpdateBandwidth(
    VOID
)
/*++
  This function updates the current bandwidth value using the histogram
   of bytes transferred.
  The histogram maintains a history of bytes transferred over different sample
   periods of a single minute. Each entry in the histogram corresponds to one
   interval of sample. The sum of all entries gives the total bytes transferred
   in a single minute. We divide this measure by 60 to obtain the count of
   bytes transferred over a second. This update bandwidth is used to
   reevalute the tuner of bandwidth throttle based on our throttling policy
   (specified in throttling algorithm). The updated action information is
   used by subsequent requests.
  In addition the _pcbXfered pointer is advanced forward using the
   histogram entries as a circular buffer, to obtain the count of bytes
   for next interval.

  Arguments:
    pdwPrivateBw - Filled with bandwidth for this descriptor

  Returns:
    TRUE on success. FALSE otherwise.

  Note:
   It is recommended that this function be called as infrequently as
    possible, using reasonable sample intervals.

--*/
{
    BOOL fRet = TRUE;
    ZoneLevel zonelevel;

    Lock();

    // accumulate current byte count to global counter, to minimize computation
    _cbXfered.QuadPart = _cbXfered.QuadPart + _pBytesXferCur->QuadPart;

    //
    // Current n/ws support a max of 1 to 100 MB/s. We can represent
    //  4GB/s in a DWORD. Hence the cast is used. This may need revision later.
    // Better yet, later we should store bandwidth as KB/seconds.
    //
    _dwMeasuredBw = (DWORD ) (_cbXfered.QuadPart/ATQ_AVERAGING_PERIOD);

    CIRCULAR_INCREMENT( _pBytesXferCur, _rgBytesXfered, ATQ_HISTOGRAM_SIZE);
    // Adjust the global cumulative bytes sent after increment.
    _cbXfered .QuadPart = _cbXfered.QuadPart - _pBytesXferCur->QuadPart;
    // Reset the counter to start with the new counter value.
    _pBytesXferCur->QuadPart = 0;

    //
    // update the operation status depending upon the bandwidth comparisons.
    // we use band/zone calculations to split the result into 3 zones.
    // Depending upon the zone we update the global status pointer to
    //   appropriate row.
    //

    if ( _dwMeasuredBw < ATQ_LOW_BAND_THRESHOLD(_bandwidth)) {

        //
        // Lower zone. Modify the pointer to OPERATION_STATUS accordingly.
        //

        zonelevel = ZoneLevelLow;

    } else if ( _dwMeasuredBw > ATQ_HIGH_BAND_THRESHOLD(_bandwidth)) {

        //
        // Higher zone. Modify the pointer to OPERATION_STATUS accordingly.
        //

        zonelevel = ZoneLevelHigh;

    } else {

        zonelevel = ZoneLevelMedium;
    }

    /*++
      Above calculation can be implemented as:
      zonelevel = (( sm_dwMeasuredBw > ATQ_LOW_BAND_THRESHOLD( sm_bandwidth)) +
                   ( sm_dwMeasuredBw > ATQ_HIGH_BAND_THRESHOLD( sm_bandwidth)));

      This is based on implicit dependence of ordering of ZoneLevel entries.
      So avoided for present now.
    --*/

    if ( _pStatus != &sm_rgStatus[zonelevel][0]) {

        // Status needs to be changed.
        _pStatus = &sm_rgStatus[zonelevel][0];

        // Examine and reenable blocked operations if any.
        fRet &= CheckAndUnblockRequests();
    }

    // remove the bandwidth info object from the list if it is
    // "inactive" (bandwidth = 0)

    if ( !_dwMeasuredBw )
    {
        // there should be no requests in the blocked queue!

        ATQ_ASSERT( _cCurrentBlockedRequests == 0 );

        RemoveFromActiveList();
    }

    Unlock();

    return fRet;
}

DWORD
BANDWIDTH_INFO::SetBandwidthLevel(
    IN DWORD                    Data
)
/*++
   Sets the bandwidth threshold

   Arguments:
      Data - Bandwidth threshold

   Returns:
      Old bandwidth threshold (DWORD)
--*/
{
    DWORD dwOldVal;
    INT iListDelta = 0;

    Lock();

    dwOldVal = _bandwidth.dwSpecifiedLevel;

    if ( Data != INFINITE) {

        DWORD dwTemp;

        _bandwidth.dwSpecifiedLevel  = ATQ_ROUNDUP_BANDWIDTH( Data );
        dwTemp = ( Data *9)/10;               //low threshold = 0.9*specified
        _bandwidth.dwLowThreshold    = ATQ_ROUNDUP_BANDWIDTH( dwTemp);
        dwTemp = ( Data *11)/10;              //high threshold= 1.1*specified
        _bandwidth.dwHighThreshold   = ATQ_ROUNDUP_BANDWIDTH( dwTemp);

        _fEnabled = TRUE;
        // we should recheck the throttling and blocked requests
        // Will be done when the next timeout occurs in the ATQ Timeout Thread

        if ( dwOldVal == INFINITE )
        {
            iListDelta = 1;
        }

    } else {

        _bandwidth.dwSpecifiedLevel = INFINITE;
        _bandwidth.dwLowThreshold   = INFINITE;
        _bandwidth.dwHighThreshold  = INFINITE;

        _fEnabled = FALSE;

        // enable all operations, since we are in low zone
        _pStatus = &sm_rgStatus[ZoneLevelLow][0];

        // we should recheck and enable all blocked requests.
        if ( _cCurrentBlockedRequests > 0) {
            ATQ_REQUIRE( CheckAndUnblockRequests());
        }

        if ( dwOldVal != INFINITE )
        {
            iListDelta = -1;
        }
    }

    Unlock();

    // update the static counter of how many non-infinite throttles we have

    if ( iListDelta )
    {
        SharedLock();

        if ( iListDelta > 0 )
        {
            sm_cNonInfinite++;
        }
        else
        {
            sm_cNonInfinite--;
        }
        sm_fGlobalEnabled = !!sm_cNonInfinite;

        SharedUnlock();
    }

    return dwOldVal;

}

DWORD
BANDWIDTH_INFO::SetMaxBlockedListSize(
    IN DWORD                    cMaxSize
)
/*++
   Sets the maximum size of blocked request list

   Arguments:
      cMaxSize - maximum size of list

   Returns:
      Old max size (DWORD)
--*/
{
    DWORD           cOldMax;

    Lock();

    cOldMax = _cMaxBlockedList;
    _cMaxBlockedList = cMaxSize;

    Unlock();

    return cOldMax;
}

DWORD
BANDWIDTH_INFO::QueryBandwidthLevel( VOID )
/*++
   Retrieve the current bandwidth level

   Arguments:
      None

   Returns:
      Set Bandwidth level (DWORD)
--*/
{
    DWORD dwBw;

    Lock();

    dwBw = _bandwidth.dwSpecifiedLevel;

    Unlock();

    return dwBw;
}

BOOL
BANDWIDTH_INFO::ClearStatistics( VOID )
{
    Lock();

    _cTotalAllowedRequests = 0;
    _cTotalBlockedRequests = 0;
    _cTotalRejectedRequests = 0;

    Unlock();

    return TRUE;
}

BOOL
BANDWIDTH_INFO::GetStatistics( OUT ATQ_STATISTICS * pAtqStats )
{
    ATQ_ASSERT( pAtqStats != NULL );

    pAtqStats->cRejectedRequests = _cTotalRejectedRequests;
    pAtqStats->cBlockedRequests = _cTotalBlockedRequests;
    pAtqStats->cAllowedRequests = _cTotalAllowedRequests;
    pAtqStats->cCurrentBlockedRequests = _cCurrentBlockedRequests;
    pAtqStats->MeasuredBandwidth = _dwMeasuredBw;

    return TRUE;
}

BOOL
BANDWIDTH_INFO::UpdateAllBandwidths( VOID )
{
    PLIST_ENTRY             pEntry;
    BOOL                    fRet = TRUE;
    DWORD                   dwCounter = 0;

    SharedLock();

    for ( pEntry = sm_ActiveListHead.Flink;
          pEntry != &sm_ActiveListHead; )
    {
        BANDWIDTH_INFO *pBandwidthInfo = CONTAINING_RECORD( pEntry,
                                                            BANDWIDTH_INFO,
                                                            _ActiveListEntry );

        ATQ_ASSERT( pBandwidthInfo != NULL );

        // we might be deleting this entry from the list.  Grab the next
        // link now before we do so the traversal can happen smoothly

        pEntry = pEntry->Flink;

        if ( !pBandwidthInfo->Enabled() )
        {
            continue;
        }

        if ( !pBandwidthInfo->UpdateBandwidth() )
        {
            fRet = FALSE;
            break;
        }

#ifndef _NO_TRACING_
        CHKINFO(( DBG_CONTEXT, "pBWInfo =  %p (%s), Bandwidth = %u, Threshold = %d\n",
                     pBandwidthInfo,
                     pBandwidthInfo->_achDescription,
                     pBandwidthInfo->QueryMeasuredBw(),
                     pBandwidthInfo->QueryBandwidthLevel() ) );
#else
        ATQ_PRINTF(( DBG_CONTEXT, "pBWInfo =  %p (%s), Bandwidth = %u, Threshold = %d\n",
                     pBandwidthInfo,
                     pBandwidthInfo->_achDescription,
                     pBandwidthInfo->QueryMeasuredBw(),
                     pBandwidthInfo->QueryBandwidthLevel() ) );
#endif
    }

    SharedUnlock();

    return fRet;
}

BOOL
BANDWIDTH_INFO::AbwInitialize( VOID )
{
    ALLOC_CACHE_CONFIGURATION  acConfig = { 1, 10, sizeof(BANDWIDTH_INFO)};

    ATQ_ASSERT( sm_pachBWInfos == NULL );

    sm_pachBWInfos = new ALLOC_CACHE_HANDLER( "BandwidthInfos",
                                              &acConfig );

    if ( sm_pachBWInfos == NULL )
    {
        return FALSE;
    }

    InitializeListHead( &sm_ActiveListHead );
    InitializeListHead( &sm_BornListHead );
    INITIALIZE_CRITICAL_SECTION( &sm_csSharedLock );

    sm_cActiveList          = 0;
    sm_cBornList            = 0;
    sm_fGlobalEnabled       = FALSE;
    sm_fGlobalActive        = FALSE;
    sm_cNonInfinite         = 0;
    sm_cSamplesForTimeout   = 1;

    g_pBandwidthInfo = new BANDWIDTH_INFO( TRUE );

    if ( !g_pBandwidthInfo )
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
BANDWIDTH_INFO::AbwTerminate( VOID )
{
    PBANDWIDTH_INFO         pBandwidthInfo;

    ATQ_PRINTF(( DBG_CONTEXT,
                 "AbwTerminate() called.  Born List Size = %d\n",
                 sm_cBornList ));

    SharedLock();

    while( !IsListEmpty( &sm_BornListHead ) )
    {
        pBandwidthInfo = CONTAINING_RECORD( sm_BornListHead.Flink,
                                            BANDWIDTH_INFO,
                                            _BornListEntry );

        ATQ_ASSERT( pBandwidthInfo != NULL );

        delete pBandwidthInfo;
    }

    ATQ_ASSERT( sm_cBornList == 0 );
    ATQ_ASSERT( sm_cActiveList == 0 );
    ATQ_ASSERT( IsListEmpty( &sm_BornListHead ) );
    ATQ_ASSERT( IsListEmpty( &sm_ActiveListHead ) );

    SharedUnlock();

    DeleteCriticalSection( &sm_csSharedLock );

    if ( sm_pachBWInfos != NULL )
    {
        delete sm_pachBWInfos;
        sm_pachBWInfos = NULL;
    }

    return TRUE;
}


PVOID
AtqCreateBandwidthInfo( VOID )
/*++

Routine Description:

    Allocate a bandwidth throttling descriptor

Arguments:

    none

Return Value:

    If successful, pointer to allocated descriptor.  Otherwise NULL.

--*/
{
    PBANDWIDTH_INFO         pBandwidthInfo;

    pBandwidthInfo = new BANDWIDTH_INFO( FALSE );
    if ( pBandwidthInfo == NULL )
    {
        return NULL;
    }
    else
    {
        ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );
        return pBandwidthInfo;
    }
}


BOOL
AtqFreeBandwidthInfo(
    IN PVOID        pvBandwidthInfo
)
/*++

Routine Description:

    Free bandwidth throttling descriptor

Arguments:

    pBandwidthInfo - Descriptor to destroy

Return Value:

    TRUE If successful, else FALSE.

--*/
{
    PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) pvBandwidthInfo;

    ATQ_ASSERT( pBandwidthInfo );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    return pBandwidthInfo->PrepareToFree();
}


ULONG_PTR
AtqBandwidthSetInfo(
      IN PVOID                 pvBandwidthInfo,
      IN ATQ_BANDWIDTH_INFO    BwInfo,
      IN ULONG_PTR              Data
)
/*++

Routine Description:

    Set member of bandwidth descriptor

Arguments:

    pBandwidthInfo - Descriptor to change
    BwInfo - Value of descriptor to set
    Data - Data to set to

Return Value:

    Previous value of descriptor

--*/
{
    ULONG_PTR        oldVal = 0;
    PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) pvBandwidthInfo;

    ATQ_ASSERT( pBandwidthInfo );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    if ( pBandwidthInfo &&
         pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE )
    {
        switch ( BwInfo )
        {
        case ATQ_BW_BANDWIDTH_LEVEL:
            oldVal = (ULONG_PTR)pBandwidthInfo->QueryBandwidthLevel();
            pBandwidthInfo->SetBandwidthLevel( (DWORD) Data );
            break;
        case ATQ_BW_MAX_BLOCKED:
            oldVal = (ULONG_PTR)pBandwidthInfo->QueryMaxBlockedSize();
            pBandwidthInfo->SetMaxBlockedListSize( (DWORD) Data );
            break;
        case ATQ_BW_DESCRIPTION:
            oldVal = (ULONG_PTR)Data;
            pBandwidthInfo->SetDescription( (CHAR*) Data );
            break;
        default:
            SetLastError( ERROR_INVALID_PARAMETER );
            ATQ_ASSERT( FALSE );
            break;
        }
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
    }

    return oldVal;

}


BOOL
AtqBandwidthGetInfo(
      IN PVOID                 pvBandwidthInfo,
      IN ATQ_BANDWIDTH_INFO    BwInfo,
      OUT ULONG_PTR *           pData
)
/*++

Routine Description:

    Get member of bandwidth descriptor

Arguments:

    pvBandwidthInfo - Descriptor to change
    BwInfo - Value of descriptor to set
    pData - Output here

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    BOOL            fRet = TRUE;
    PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) pvBandwidthInfo;

    ATQ_ASSERT( pBandwidthInfo );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );
    ATQ_ASSERT( pData );

    if ( pBandwidthInfo &&
         pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE &&
         pData )
    {
        switch ( BwInfo )
        {
        case ATQ_BW_BANDWIDTH_LEVEL:
            *pData = (ULONG_PTR)pBandwidthInfo->QueryBandwidthLevel();
            break;
        case ATQ_BW_MAX_BLOCKED:
            *pData = (ULONG_PTR)pBandwidthInfo->QueryMaxBlockedSize();
            break;
        case ATQ_BW_STATISTICS:
            fRet = pBandwidthInfo->GetStatistics( (ATQ_STATISTICS*) pData );
            break;
        case ATQ_BW_DESCRIPTION:
            *pData = (ULONG_PTR)pBandwidthInfo->QueryDescription();
            break;
        default:
            SetLastError( ERROR_INVALID_PARAMETER );
            ATQ_ASSERT( FALSE );
            fRet = FALSE;
            break;
        }
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        fRet = FALSE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iissuba\subauth.h ===
/*++ BUILD Version: 0005     Increment this if a change has global effects

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    subauth.h

Abstract:

    This module defines types and macros for Subauthentication Packages.

    *******************************NOTE*********************************

    This file is a copy of \nt\public\sdk\inc\subauth.h with a few
    definitions removed?  Why?  Because we need to use some SAM internal
    calls defined with SAMRPC.H, LSARPC.H, SAMISRV.H, etc. and these define
    some types which are redefined in \nt\public\sdk\inc\subauth.h causing
    compile errors.  This hack is temporary until post B3 when SAM adds the
    necessary semantics we need to avoid calling into SamrQueryInformationUser.

    ********************************************************************

Revision History:

--*/

#ifndef _NTSUBAUTH_
#define _NTSUBAUTH_

#ifdef __cplusplus
extern "C" {
#endif

#if (!defined(_NTDEF_)) && (!defined(_NTSECAPI_))
typedef LONG NTSTATUS, *PNTSTATUS;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} STRING, *PSTRING;
#endif

#ifndef _NTDEF_

typedef struct _OLD_LARGE_INTEGER {
    ULONG LowPart;
    LONG HighPart;
} OLD_LARGE_INTEGER, *POLD_LARGE_INTEGER;

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

#endif

#ifndef _NTSAM_SAM_HANDLE_
typedef PVOID SAM_HANDLE, *PSAM_HANDLE;
#define _NTSAM_SAM_HANDLE_
#endif
#ifndef _NTSAM_USER_ACCOUNT_FLAGS_

//
// User account control flags...
//

#define USER_ACCOUNT_DISABLED                (0x00000001)
#define USER_HOME_DIRECTORY_REQUIRED         (0x00000002)
#define USER_PASSWORD_NOT_REQUIRED           (0x00000004)
#define USER_TEMP_DUPLICATE_ACCOUNT          (0x00000008)
#define USER_NORMAL_ACCOUNT                  (0x00000010)
#define USER_MNS_LOGON_ACCOUNT               (0x00000020)
#define USER_INTERDOMAIN_TRUST_ACCOUNT       (0x00000040)
#define USER_WORKSTATION_TRUST_ACCOUNT       (0x00000080)
#define USER_SERVER_TRUST_ACCOUNT            (0x00000100)
#define USER_DONT_EXPIRE_PASSWORD            (0x00000200)
#define USER_ACCOUNT_AUTO_LOCKED             (0x00000400)
#define USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED (0x00000800)
#define USER_SMARTCARD_REQUIRED              (0x00001000)
#define USER_TRUSTED_FOR_DELEGATION          (0x00002000)
#define USER_NOT_DELEGATED                   (0x00004000)
#define USER_USE_DES_KEY_ONLY                (0x00008000)
#define USER_DONT_REQUIRE_PREAUTH            (0x00010000)
#define NEXT_FREE_ACCOUNT_CONTROL_BIT (USER_DONT_REQUIRE_PREAUTH << 1)


#define USER_MACHINE_ACCOUNT_MASK      \
            ( USER_INTERDOMAIN_TRUST_ACCOUNT |\
              USER_WORKSTATION_TRUST_ACCOUNT |\
              USER_SERVER_TRUST_ACCOUNT)

#define USER_ACCOUNT_TYPE_MASK         \
            ( USER_TEMP_DUPLICATE_ACCOUNT |\
              USER_NORMAL_ACCOUNT |\
              USER_MACHINE_ACCOUNT_MASK )


//
// Logon times may be expressed in day, hour, or minute granularity.
//
//              Days per week    = 7
//              Hours per week   = 168
//              Minutes per week = 10080
//

#define SAM_DAYS_PER_WEEK    (7)
#define SAM_HOURS_PER_WEEK   (24 * SAM_DAYS_PER_WEEK)
#define SAM_MINUTES_PER_WEEK (60 * SAM_HOURS_PER_WEEK)

#define _NTSAM_USER_ACCOUNT_FLAG_
#endif
#ifndef _NTSAM_USER_ALL_INFO_
#include "pshpack4.h"
typedef struct _USER_ALL_INFORMATION {
    LARGE_INTEGER LastLogon;
    LARGE_INTEGER LastLogoff;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER AccountExpires;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;
    UNICODE_STRING UserName;
    UNICODE_STRING FullName;
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING HomeDirectoryDrive;
    UNICODE_STRING ScriptPath;
    UNICODE_STRING ProfilePath;
    UNICODE_STRING AdminComment;
    UNICODE_STRING WorkStations;
    UNICODE_STRING UserComment;
    UNICODE_STRING Parameters;
    UNICODE_STRING LmPassword;
    UNICODE_STRING NtPassword;
    UNICODE_STRING PrivateData;
    SR_SECURITY_DESCRIPTOR SecurityDescriptor;
    ULONG UserId;
    ULONG PrimaryGroupId;
    ULONG UserAccountControl;
    ULONG WhichFields;
    LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    USHORT CountryCode;
    USHORT CodePage;
    BOOLEAN LmPasswordPresent;
    BOOLEAN NtPasswordPresent;
    BOOLEAN PasswordExpired;
    BOOLEAN PrivateDataSensitive;
} USER_ALL_INFORMATION,  *PUSER_ALL_INFORMATION;
#include "poppack.h"
#define _NTSAM_USER_ALL_INFO_
#endif
#ifndef _NTSAM_SAM_USER_PARMS_
#define USER_ALL_PARAMETERS         0x00200000
#define _NTSAM_SAM_USER_PARMS_
#endif

#define CLEAR_BLOCK_LENGTH          8

typedef CYPHER_BLOCK *              PCYPHER_BLOCK;
typedef LM_OWF_PASSWORD *           PLM_OWF_PASSWORD;
typedef CLEAR_BLOCK                 LM_CHALLENGE;
typedef LM_CHALLENGE *              PLM_CHALLENGE;
typedef LM_OWF_PASSWORD             NT_OWF_PASSWORD;
typedef NT_OWF_PASSWORD *           PNT_OWF_PASSWORD;
typedef LM_CHALLENGE                NT_CHALLENGE;
typedef NT_CHALLENGE *              PNT_CHALLENGE;
#define USER_SESSION_KEY_LENGTH     (CYPHER_BLOCK_LENGTH * 2)

typedef USER_SESSION_KEY          * PUSER_SESSION_KEY;

typedef enum _NETLOGON_LOGON_INFO_CLASS {
    NetlogonInteractiveInformation = 1,
    NetlogonNetworkInformation,
    NetlogonServiceInformation,
    NetlogonGenericInformation,
    NetlogonInteractiveTransitiveInformation,
    NetlogonNetworkTransitiveInformation,
    NetlogonServiceTransitiveInformation
} NETLOGON_LOGON_INFO_CLASS;

typedef struct _NETLOGON_LOGON_IDENTITY_INFO {
    UNICODE_STRING LogonDomainName;
    ULONG ParameterControl;
    OLD_LARGE_INTEGER  LogonId;
    UNICODE_STRING UserName;
    UNICODE_STRING Workstation;
} NETLOGON_LOGON_IDENTITY_INFO,
 *PNETLOGON_LOGON_IDENTITY_INFO;

typedef struct _NETLOGON_INTERACTIVE_INFO {
    NETLOGON_LOGON_IDENTITY_INFO Identity;
    LM_OWF_PASSWORD LmOwfPassword;
    NT_OWF_PASSWORD NtOwfPassword;
} NETLOGON_INTERACTIVE_INFO,
 *PNETLOGON_INTERACTIVE_INFO;

typedef struct _NETLOGON_SERVICE_INFO {
    NETLOGON_LOGON_IDENTITY_INFO Identity;
    LM_OWF_PASSWORD LmOwfPassword;
    NT_OWF_PASSWORD NtOwfPassword;
} NETLOGON_SERVICE_INFO, *PNETLOGON_SERVICE_INFO;

typedef struct _NETLOGON_NETWORK_INFO {
    NETLOGON_LOGON_IDENTITY_INFO Identity;
    LM_CHALLENGE LmChallenge;
    STRING NtChallengeResponse;
    STRING LmChallengeResponse;
} NETLOGON_NETWORK_INFO, *PNETLOGON_NETWORK_INFO;

typedef struct _NETLOGON_GENERIC_INFO {
    NETLOGON_LOGON_IDENTITY_INFO Identity;
    UNICODE_STRING PackageName;
    ULONG DataLength;
#ifdef MIDL_PASS
    [size_is(DataLength)]
#endif
    PUCHAR LogonData;
} NETLOGON_GENERIC_INFO, *PNETLOGON_GENERIC_INFO;


// Values for Flags
#define MSV1_0_PASSTHRU     0x01
#define MSV1_0_GUEST_LOGON  0x02

NTSTATUS NTAPI
Msv1_0SubAuthenticationRoutine(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
);

typedef struct _MSV1_0_VALIDATION_INFO {
    LARGE_INTEGER LogoffTime;
    LARGE_INTEGER KickoffTime;
    UNICODE_STRING LogonServer;
    UNICODE_STRING LogonDomainName;
    USER_SESSION_KEY SessionKey;
    BOOLEAN Authoritative;
    ULONG UserFlags;
    ULONG WhichFields;
    ULONG UserId;
} MSV1_0_VALIDATION_INFO, *PMSV1_0_VALIDATION_INFO;

// values for WhichFields

#define MSV1_0_VALIDATION_LOGOFF_TIME          0x00000001
#define MSV1_0_VALIDATION_KICKOFF_TIME         0x00000002
#define MSV1_0_VALIDATION_LOGON_SERVER         0x00000004
#define MSV1_0_VALIDATION_LOGON_DOMAIN         0x00000008
#define MSV1_0_VALIDATION_SESSION_KEY          0x00000010
#define MSV1_0_VALIDATION_USER_FLAGS           0x00000020
#define MSV1_0_VALIDATION_USER_ID              0x00000040

// legal values for ActionsPerformed
#define MSV1_0_SUBAUTH_ACCOUNT_DISABLED        0x00000001
#define MSV1_0_SUBAUTH_PASSWORD                0x00000002
#define MSV1_0_SUBAUTH_WORKSTATIONS            0x00000004
#define MSV1_0_SUBAUTH_LOGON_HOURS             0x00000008
#define MSV1_0_SUBAUTH_ACCOUNT_EXPIRY          0x00000010
#define MSV1_0_SUBAUTH_PASSWORD_EXPIRY         0x00000020
#define MSV1_0_SUBAUTH_ACCOUNT_TYPE            0x00000040
#define MSV1_0_SUBAUTH_LOCKOUT                 0x00000080

NTSTATUS NTAPI
Msv1_0SubAuthenticationRoutineEx(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    IN SAM_HANDLE UserHandle,
    IN OUT PMSV1_0_VALIDATION_INFO ValidationInfo,
    OUT PULONG ActionsPerformed
);

NTSTATUS NTAPI
Msv1_0SubAuthenticationRoutineGeneric(
    IN PVOID SubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PULONG ReturnBufferLength,
    OUT PVOID *ReturnBuffer
);

NTSTATUS NTAPI
Msv1_0SubAuthenticationFilter(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
);

#define STATUS_SUCCESS                          ((NTSTATUS)0x00000000L)
#define STATUS_INVALID_INFO_CLASS        ((NTSTATUS)0xC0000003L)
#define STATUS_NO_SUCH_USER              ((NTSTATUS)0xC0000064L)
#define STATUS_WRONG_PASSWORD            ((NTSTATUS)0xC000006AL)
#define STATUS_PASSWORD_RESTRICTION      ((NTSTATUS)0xC000006CL)
#define STATUS_LOGON_FAILURE             ((NTSTATUS)0xC000006DL)
#define STATUS_ACCOUNT_RESTRICTION       ((NTSTATUS)0xC000006EL)
#define STATUS_INVALID_LOGON_HOURS       ((NTSTATUS)0xC000006FL)
#define STATUS_INVALID_WORKSTATION       ((NTSTATUS)0xC0000070L)
#define STATUS_PASSWORD_EXPIRED          ((NTSTATUS)0xC0000071L)
#define STATUS_ACCOUNT_DISABLED          ((NTSTATUS)0xC0000072L)
#define STATUS_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC000009AL)
#define STATUS_ACCOUNT_EXPIRED           ((NTSTATUS)0xC0000193L)
#define STATUS_PASSWORD_MUST_CHANGE      ((NTSTATUS)0xC0000224L)
#define STATUS_ACCOUNT_LOCKED_OUT        ((NTSTATUS)0xC0000234L)
#ifdef __cplusplus
}
#endif

#endif /* _NTSUBAUTH_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\atqbmon.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    atqbmon.cxx

Abstract:

    ATQ Backlog Monitor

Author:

    01-Dec-1998  MCourage

Revision History:

--*/

#include "isatq.hxx"

#include "atqbmon.hxx"

ATQ_BACKLOG_MONITOR * g_pAtqBacklogMonitor = NULL;



ATQ_BACKLOG_MONITOR::ATQ_BACKLOG_MONITOR(
    VOID
    )
/*++

Routine Description:

    Constructor sets up the list and the lock.

Arguments:

    None
--*/
{
    INITIALIZE_CRITICAL_SECTION( &m_csLock );
    InitializeListHead( &m_ListHead );
}


ATQ_BACKLOG_MONITOR::~ATQ_BACKLOG_MONITOR(
    VOID
    )
/*++

Routine Description:

    Destructor cleans up the list and the lock.

Arguments:

    None
--*/
{
    LIST_ENTRY *   pEntry;
    ATQ_BMON_SET * pBmonSet;

    //
    // traverse the list and remove all sets
    //
    while (!IsListEmpty( &m_ListHead )) {

        pEntry = RemoveHeadList( &m_ListHead );

        pBmonSet = CONTAINING_RECORD( pEntry, ATQ_BMON_SET, m_SetList );

        DBG_ASSERT( pBmonSet->IsEmpty() );
        DBG_REQUIRE( pBmonSet->Cleanup() );
    }

    DeleteCriticalSection( &m_csLock );
}


BOOL
ATQ_BACKLOG_MONITOR::AddEntry(
    ATQ_BMON_ENTRY * pBmonEntry
    )
/*++

Routine Description:

    Adds an entry to the next available ATQ_BMON_SET. 
    Makes a new set if all current sets are full.

Arguments:

    pBmonEntry - The entry to be added

Return Values:

    TRUE on success
--*/
{
    LIST_ENTRY *   pCurrent;
    ATQ_BMON_SET * pBmonSet;
    BOOL           bRetval;

    if (!pBmonEntry) {
        return TRUE;
    }

    bRetval = FALSE;

    Lock();

    for (pCurrent = m_ListHead.Flink;
         pCurrent != &m_ListHead;
         pCurrent = pCurrent->Flink) {

        pBmonSet = CONTAINING_RECORD( pCurrent, ATQ_BMON_SET, m_SetList );

        if (pBmonSet->IsNotFull() && pBmonSet->AddEntry(pBmonEntry)) {
            bRetval = TRUE;
            break;
        }
    }

    if (!bRetval) {
        //
        // Couldn't find a set with space
        // so try to make a new one.
        //
        pBmonSet = new ATQ_BMON_SET;

        if (pBmonSet && pBmonSet->Initialize()) {
            InsertHeadList( &m_ListHead, &pBmonSet->m_SetList );
            bRetval = pBmonSet->AddEntry(pBmonEntry);
        }
    }       

    Unlock();

    return bRetval;
}


BOOL
ATQ_BACKLOG_MONITOR::RemoveEntry(
    ATQ_BMON_ENTRY * pBmonEntry
    )
/*++

Routine Description:

    Removes an entry from its containing ATQ_BMON_SET.
    If the set is empty it is removed from the list
    of sets.

Arguments:

    pBmonEntry - The entry to be removed

Return Values:

    TRUE on success
--*/
{
    ATQ_BMON_SET * pBmonSet;

    if (!pBmonEntry) {
        return TRUE;
    }

    DBG_ASSERT( pBmonEntry && pBmonEntry->CheckSignature() );

    pBmonSet = pBmonEntry->GetContainingBmonSet();

    DBG_ASSERT( pBmonSet );

    return pBmonSet->RemoveEntry(pBmonEntry);
}


BOOL
ATQ_BACKLOG_MONITOR::PauseEntry(
    ATQ_BMON_ENTRY * pBmonEntry
    )
/*++

Routine Description:

    Pauses an entry in its containing ATQ_BMON_SET.
    The entry will remain in the set, but will
    not send notifications.

Arguments:

    pBmonEntry - The entry to be paused

Return Values:

    TRUE on success
--*/
{
    ATQ_BMON_SET * pBmonSet;

    if (!pBmonEntry) {
        return TRUE;
    }

    DBG_ASSERT( pBmonEntry && pBmonEntry->CheckSignature() );

    pBmonSet = pBmonEntry->GetContainingBmonSet();

    DBG_ASSERT( pBmonSet );

    return pBmonSet->PauseEntry(pBmonEntry);
}


BOOL
ATQ_BACKLOG_MONITOR::ResumeEntry(
    ATQ_BMON_ENTRY * pBmonEntry
    )
/*++

Routine Description:

    Undoes PauseEntry. The entry in question
    will get notifications again

Arguments:

    pBmonEntry - The entry to be resumed

Return Values:

    TRUE on success
--*/
{
    ATQ_BMON_SET * pBmonSet;

    if (!pBmonEntry) {
        return TRUE;
    }

    DBG_ASSERT( pBmonEntry && pBmonEntry->CheckSignature() );

    pBmonSet = pBmonEntry->GetContainingBmonSet();

    DBG_ASSERT( pBmonSet );

    return pBmonSet->ResumeEntry(pBmonEntry);
}



ATQ_BMON_ENTRY::ATQ_BMON_ENTRY(
    SOCKET s
    )
/*++

Routine Description:

    Constructor sets up signature etc.

Arguments:

    None
--*/
{
    DBG_ASSERT( s );

    m_Signature       = ATQ_BMON_ENTRY_SIGNATURE;
    m_Socket          = s;
    m_hAddRemoveEvent = NULL;
    m_BmonOpcode      = BMON_INVALID;
    m_pBmonSet        = NULL;
    m_dwErr           = NO_ERROR;
}    


ATQ_BMON_ENTRY::~ATQ_BMON_ENTRY(
    VOID
    )
/*++

Routine Description:

    Destructor sets up signature and closes event.

Arguments:

    None
--*/
{
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( m_Socket );

    m_Signature = ATQ_FREE_BMON_ENTRY_SIGNATURE;

    DBG_REQUIRE( CloseHandle( m_hAddRemoveEvent ) );
}    


BOOL
ATQ_BMON_ENTRY::InitEvent(
    VOID
    )
/*++

Routine Description:

    Sets up the AddRemove event that we use
    to synchronise adding and removing of entries.

Arguments:

    None

Return Values:

    TRUE on success    
--*/
{
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( m_hAddRemoveEvent == NULL );

    m_hAddRemoveEvent = CreateEvent(
                            NULL,    // default security
                            FALSE,   // do auto-reset
                            FALSE,   // init state false
                            NULL     // no name
                            );

    if (m_hAddRemoveEvent == NULL) {
        m_dwErr = GetLastError();
    }

    return (m_hAddRemoveEvent != NULL);
}


VOID
ATQ_BMON_ENTRY::SignalAddRemove(
    DWORD dwError
    )
/*++

Routine Description:

    Signals the AddRemove event. Clients adding or
    removing the entry will be blocked on its event.

Arguments:

    None

Return Values:

    None    
--*/
{
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( m_hAddRemoveEvent != NULL );

    m_dwErr = dwError;
    DBG_REQUIRE( SetEvent(m_hAddRemoveEvent) );
}



BOOL
ATQ_BMON_ENTRY::WaitForAddRemove(
    VOID
    )
/*++

Routine Description:

    Call this function while waiting for
    the entry to be added to or removed from a set.

Arguments:

    None

Return Values:

    TRUE on success
--*/
{
    DWORD dwResult;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( m_hAddRemoveEvent != NULL );

    //
    // If the monitor thread dies, don't bother waiting for notification from
    // it regarding add/removal.
    //

Retry:
    
    if ( m_pBmonSet && !m_pBmonSet->ThreadFinished() )
    {
        dwResult = WaitForSingleObject(m_hAddRemoveEvent, 10000 );
        if ( dwResult == WAIT_TIMEOUT )
        {
            goto Retry;
        }
    }
    else
    {
        dwResult = WAIT_OBJECT_0;
    }

    DBG_ASSERT( dwResult == WAIT_OBJECT_0 );

    return (dwResult == WAIT_OBJECT_0);
}



BOOL
BMON_WAKEUP_ENTRY::Callback(
    VOID
    )
/*++

Routine Description:

    The sole purpose of the BMON_WAKEUP_ENTRY is to
    get the main thread to wake up and call
    SynchronizeSets. All we have to do here is
    do a read so that we can wake up again in
    the future.

Arguments:

    None

Return Values:

    TRUE if successful, else FALSE
--*/
{
    INT            err;
    DWORD          dwBuff;
    ATQ_BMON_SET * pBmonSet;

    DBG_ASSERT( CheckSignature() );

    //
    // do a read to clear the wakeup signal
    //
    err = recvfrom(
                GetSocket(),     // our socket
                (PCHAR) &dwBuff, // read buffer
                sizeof(dwBuff),  // buffer len
                0,               // flags
                NULL,            // src addr
                NULL             // src addr len
                );
                
    if ( err == SOCKET_ERROR ) {
    
        DBGPRINTF((DBG_CONTEXT,
            "Error %d in recvfrom\n", WSAGetLastError()));
        
        return FALSE;
        
    } else {
        DBG_ASSERT(dwBuff == ATQ_BMON_WAKEUP_MESSAGE);
        
        return TRUE;
    }
}



ATQ_BMON_SET::ATQ_BMON_SET(
    VOID
    )
/*++

Routine Description:

    Constructor sets up critsec and sets.

Arguments:

    None
--*/
{
    INITIALIZE_CRITICAL_SECTION( &m_csLock );

    memset(m_apEntrySet, 0, sizeof(m_apEntrySet));
    FD_ZERO( &m_ListenSet );

    m_SetSize      = 0;
    m_pWakeupEntry = NULL;
    m_fCleanup     = FALSE;
    m_fDoSleep     = FALSE;
    m_fThreadFinished = FALSE;
    m_dwError      = NO_ERROR;
}


ATQ_BMON_SET::~ATQ_BMON_SET(
    VOID
    )
/*++

Routine Description:

    Destructor cleans up critsec.

Arguments:

    None
--*/
{
    DBG_ASSERT( m_SetSize == 0 );

    //
    // get rid of the wakeup entry
    //
    DBG_REQUIRE( 0 == closesocket(m_pWakeupEntry->GetSocket()) );
    delete m_pWakeupEntry;

    DeleteCriticalSection(&m_csLock);   
}


BOOL
ATQ_BMON_SET::Initialize(
    VOID
    )
/*++

Routine Description:

    Sets up the Wakeup entry and starts
    our thread.

Arguments:

    None

Return Values:

    TRUE on success    
--*/
{
    BOOL                bRetval;
    SOCKET              s;
    SOCKADDR_IN         sockAddr;
    INT                 err;
    BMON_WAKEUP_ENTRY * pWakeup;
    HANDLE              hThread;
    DWORD               dwError = NO_ERROR;
    WORD                wPort = ATQ_BMON_WAKEUP_PORT;

    bRetval = FALSE;

    //
    // set up wakeup entry
    //
    s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

    if (s == INVALID_SOCKET) {
        dwError = WSAGetLastError();
        goto exit;
    }

    ZeroMemory(&sockAddr, sizeof(sockAddr));
    sockAddr.sin_family = AF_INET;
    sockAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    sockAddr.sin_port = htons(wPort);

    err = bind(s, (PSOCKADDR)&sockAddr, sizeof(sockAddr));

    while ((err == SOCKET_ERROR)
            && (WSAGetLastError() == WSAEADDRINUSE)
            && (wPort < ATQ_BMON_WAKEUP_PORT_MAX)) {
        //
        // try another port
        //
        wPort++;
        sockAddr.sin_port = htons(wPort);

        err = bind(s, (PSOCKADDR)&sockAddr, sizeof(sockAddr));
    }


    if ( err == SOCKET_ERROR ) {
        DBGERROR((DBG_CONTEXT,"Error %d in bind\n", WSAGetLastError()));
        dwError = WSAGetLastError();
        closesocket(s);
        goto exit;
    }

    pWakeup = new BMON_WAKEUP_ENTRY(s);
    if ( pWakeup == NULL )
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    if (!pWakeup->InitEvent()) {
        delete pWakeup;
        pWakeup = NULL;
        goto exit;
    }

    pWakeup->SetContainingBmonSet(this);
    pWakeup->SetOpcode(BMON_WAIT);

    m_pWakeupEntry = pWakeup;
    m_Port         = wPort;

    //
    // just jam this entry into the lists
    //
    DBG_ASSERT(m_SetSize == 0);
    
    m_SetSize = 1;
    m_apEntrySet[0] = pWakeup;
    FD_SET(pWakeup->GetSocket(), &m_ListenSet);

    //
    // now set up our thread. from now on you
    // have to Lock before manipulating the
    // lists
    //
    m_hThread = CreateThread(
                    NULL,               // defualt security
                    0,                  // default stack
                    ::BmonThreadFunc,   // thread func
                    this,               // func parameter
                    0,                  // flags
                    NULL                // discard tid
                    );

    if (m_hThread) {
        //
        // it worked!
        //
        bRetval = TRUE;

    } else {
        //
        // doh! clean up the wakeup entry
        //
        dwError = GetLastError();
        
        closesocket( pWakeup->GetSocket() );
        delete pWakeup;

        m_SetSize = 0;
    }
    
exit:
    if (dwError != NO_ERROR) {
        SetLastError(dwError);
    }

    return bRetval;
}


BOOL
ATQ_BMON_SET::Cleanup(
    VOID
    )
/*++

Routine Description:

    Tells the select thread to clean up by
    removing the wakeup entry.
    
Arguments:

    None

Return Values:

    TRUE on success    
--*/
{
    //
    // Cleanup is done when wakup entry
    // is removed.
    //
    // Don't use RemoveEntry, because the
    // other thread will delete the wakeup
    // entry.
    //
    DBG_ASSERT( m_pWakeupEntry && m_pWakeupEntry->CheckSignature() );

    m_pWakeupEntry->SetOpcode(BMON_REMOVE);
    Wakeup();
   
    //
    // Wait a reasonable amount of time for the thread to go away.  
    //
    
    WaitForSingleObject( m_hThread, 10000 );
    CloseHandle( m_hThread );
    m_hThread = NULL;

    delete this;

    return TRUE;
}


BOOL
ATQ_BMON_SET::IsEmpty(
    VOID
    )
/*++

Routine Description:

    This tells you if there are sockets in the
    set. Note that one socket is the wakeup
    socket, so a count of one means we're empty.

Arguments:

    None

Return Values:

    TRUE on empty
--*/
{
    BOOL bRetval;

    Lock();
    bRetval = (m_SetSize <= 1);
    DBG_ASSERT( m_SetSize <= FD_SETSIZE );
    Unlock();

    return bRetval;
}


BOOL
ATQ_BMON_SET::IsNotFull(
    VOID
    )
/*++

Routine Description:

    This tells you if there is room for more sockets
    in the set. Note that one socket is the wakeup
    socket.

Arguments:

    None

Return Values:

    TRUE when space is available
--*/
{
    BOOL bRetval;

    Lock();
    bRetval = (m_SetSize < FD_SETSIZE);
    DBG_ASSERT( m_SetSize <= FD_SETSIZE );
    Unlock();
 
    return bRetval;
}


BOOL
ATQ_BMON_SET::AddEntry(
    ATQ_BMON_ENTRY * pBmonEntry
    )
/*++

Routine Description:

    Add an entry to the set

Arguments:

    pBmonEntry - the entry to be added

Return Values:

    TRUE on success
--*/
{
    DWORD i;
    BOOL  bAdded = FALSE;
    DWORD dwError;

    pBmonEntry->SetOpcode(BMON_ADD);

    Lock();

    for (i = 0; i < FD_SETSIZE; i++) {
        if (!m_apEntrySet[i]) {
            m_apEntrySet[i] = pBmonEntry;
            pBmonEntry->SetContainingBmonSet(this);
            bAdded = TRUE;

            m_SetSize++;
            DBG_ASSERT( m_SetSize <= FD_SETSIZE );
            break;
        }
    }

    Unlock();

    if (bAdded) {
        Wakeup();
        pBmonEntry->WaitForAddRemove();

        dwError = pBmonEntry->GetError();

        if (dwError) {
            //
            // other thread will remove from list
            //
            SetLastError(dwError);
            bAdded = FALSE;
        }
    }

    return bAdded;
}


BOOL
ATQ_BMON_SET::RemoveEntry(
    ATQ_BMON_ENTRY * pBmonEntry
    )
/*++

Routine Description:

    Remove an entry from the set

Arguments:

    pBmonEntry - the entry to be removed

Return Values:

    TRUE on success
--*/
{
    DWORD i;
    BOOL  bRemoved = FALSE;

    pBmonEntry->SetOpcode(BMON_REMOVE);
    Wakeup();

    pBmonEntry->WaitForAddRemove();

    return (pBmonEntry->GetError() == NO_ERROR);
}


BOOL
ATQ_BMON_SET::PauseEntry(
    ATQ_BMON_ENTRY * pBmonEntry
    )
/*++

Routine Description:

    Pause an entry in the set. The entry's
    socket will be removed from the FD_SET,
    but the entry will stay.

Arguments:

    pBmonEntry - the entry to be paused

Return Values:

    TRUE on success
--*/
{
    DWORD i;
    BOOL  bRemoved = FALSE;

    DBGPRINTF((DBG_CONTEXT,
               "Pausing backlog monitor entry %p\n",
               pBmonEntry));

    pBmonEntry->SetOpcode(BMON_PAUSE);
    Wakeup();

    //
    // We don't do the event stuff for pause and
    // resume. It's a pain because the client will
    // want to pause from within the callback
    // function.
    //
    return (TRUE);
}


BOOL
ATQ_BMON_SET::ResumeEntry(
    ATQ_BMON_ENTRY * pBmonEntry
    )
/*++

Routine Description:

    Resume an entry in the set. The entry's
    socket will be added back to the FD_SET.

Arguments:

    pBmonEntry - the entry to be resumed

Return Values:

    TRUE on success
--*/
{
    DWORD i;
    BOOL  bRemoved = FALSE;


    if (pBmonEntry->GetOpcode() == BMON_NOWAIT) {
        DBGPRINTF((DBG_CONTEXT,
                   "Resuming backlog monitor entry %p\n",
                   pBmonEntry));
                   
        pBmonEntry->SetOpcode(BMON_RESUME);
        Wakeup();
    }
    
    //
    // We don't do the event stuff for pause and
    // resume. It's a pain because the client will
    // want to pause from within the callback
    // function.
    //
    return (TRUE);
}



VOID
ATQ_BMON_SET::BmonThreadFunc(
    VOID
    )
/*++

Routine Description:

    This function is for the set's select thread.
    It calls accept with the listen set, and calls
    notification functions for all sockets that
    are ready.

    SynchronizeSets returns false when it's time
    to shut down.

Arguments:

    None

Return Values:

    None   
--*/
{
    INT   err;

    while (SynchronizeSets()) {

        err = select(
                    0,              // junk
                    &m_ListenSet,   // readfds
                    NULL,           // writefds
                    NULL,           // exceptfds
                    NULL            // want to block
                    );

        if (err != SOCKET_ERROR) {
            DBG_ASSERT(err > 0);

            if ( !NotifyEntries() )
            {
                //
                // If we couldn't notify the entries, stop doing our thing
                //
                
                m_dwError = GetLastError();
                m_dwError |= BMON_NOTIFY_ERROR;
                break;
            }
        } else {
            //
            // Actually let's take the general approach that the moment the
            // Backlog monitor sees trouble, it should stop.  This avoids 
            // low memory situations where the backlog monitor just spins, 
            // thus becoming it's own denial of service attack.  
            //
            
            m_dwError = WSAGetLastError();
            m_dwError |= BMON_SELECT_ERROR;
            break;
        
            DBGPRINTF(( DBG_CONTEXT,
                        "Select failed with error %d\n",
                        WSAGetLastError()
                        ));
                        
                
        }
        
        if ( m_fDoSleep )
        {
            //
            // Now sleep for a while.  It will take time for unconnected to go away.
            // We don't want to spin
            //
            // Of course, this means we don't do useful work on any other endpoints 
            // which may also be in trouble.  Oh well.  
            //
    
            Sleep( 5000 );    
            m_fDoSleep = FALSE;
        }
    }
    
    m_fThreadFinished = TRUE;
}


VOID
ATQ_BMON_SET::Wakeup(
    VOID
    )
/*++

Routine Description:

    We call this function when adding or removing
    an entry. Writing to the wakeup socket wakes
    up the select thread.

Arguments:

    None

Return Values:

    None   
--*/
{
    SOCKADDR_IN sockAddr;
    INT         err;
    DWORD       dwBuf;

    sockAddr.sin_family = AF_INET;
    sockAddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    sockAddr.sin_port = htons(m_Port);

    dwBuf = ATQ_BMON_WAKEUP_MESSAGE;

    err = sendto(
            m_pWakeupEntry->GetSocket(),
            (PCHAR)&dwBuf,
            sizeof(dwBuf),
            0,
            (PSOCKADDR)&sockAddr,
            sizeof(sockAddr)
            );

    if ( err == SOCKET_ERROR ) {
        
        m_dwError = WSAGetLastError();
        m_dwError |= BMON_SENDTO_ERROR;
    
        DBGPRINTF((DBG_CONTEXT,
            "Error %d in sendto\n",WSAGetLastError()));
    } 
}


BOOL
ATQ_BMON_SET::SynchronizeSets(
    VOID
    )
/*++

Routine Description:

    This function updates our FD_SET to reflect
    what's in the entry set, and also notifies
    entries which have been added or removed.

    We also check to see if it's time to shut
    down (as indicated by the removal of the
    wakeup entry.

Arguments:

    None

Return Values:

    TRUE  to continue operating
    FALSE on shutdown
--*/
{
    DWORD            i;
    ATQ_BMON_ENTRY * pBmonEntry;
    BOOL             bRetval;

    bRetval = TRUE;

    Lock();

    //
    // clear out whatever is there now
    //
    FD_ZERO(&m_ListenSet);
    
    //
    // put in everything we want
    //
    for (i = 0; i < FD_SETSIZE; i++) {
        pBmonEntry = m_apEntrySet[i];

        if (pBmonEntry) {
            DBG_ASSERT( pBmonEntry->CheckSignature() );

            switch(pBmonEntry->GetOpcode()) {
            case BMON_ADD:
                FD_SET(pBmonEntry->GetSocket(), &m_ListenSet);
                pBmonEntry->SetOpcode(BMON_WAIT);
                pBmonEntry->SignalAddRemove(NO_ERROR);
                break;

            case BMON_RESUME:
                FD_SET(pBmonEntry->GetSocket(), &m_ListenSet);
                pBmonEntry->SetOpcode(BMON_WAIT);
                break;

            case BMON_PAUSE:
                pBmonEntry->SetOpcode(BMON_NOWAIT);
                pBmonEntry->SignalAddRemove(NO_ERROR);
                break;
                
            case BMON_REMOVE:
                if (pBmonEntry == m_pWakeupEntry) {
                    //
                    // this means it's time to shut down
                    //
                    bRetval = FALSE;
                }
            
                m_apEntrySet[i] = NULL;
                m_SetSize--;
                pBmonEntry->SetContainingBmonSet(NULL);
                pBmonEntry->SignalAddRemove(NO_ERROR);
                break;
                
            case BMON_WAIT:
                FD_SET(pBmonEntry->GetSocket(), &m_ListenSet);
                break;

            case BMON_NOWAIT:
                //
                // this entry is paused, so don't do
                // anything
                //
                break;


            default:
                //
                // should never get here
                // remove the bad entry
                //
                DBGPRINTF((DBG_CONTEXT,
                           "Invalid opcode in ATQ_BMON_ENTRY %p, %d\n",
                           pBmonEntry, pBmonEntry->GetOpcode()));
                
                DBG_ASSERT(FALSE);
                m_apEntrySet[i] = NULL;
                break;
            }
            
        }
        
    }

    Unlock();

    return bRetval;
}


BOOL
ATQ_BMON_SET::NotifyEntries(
    VOID
    )
/*++

Routine Description:

    This function looks through the entries
    to see who needs to be notified and calls
    their callback function.

Arguments:

    None

Return Values:

    TRUE if successful, else FALSE
--*/
{
    DWORD            i;
    ATQ_BMON_ENTRY * pBmonEntry;
    BOOL             fRet = TRUE;

    Lock();

    for (i = 0; i < FD_SETSIZE; i++) {
        pBmonEntry = m_apEntrySet[i];

        if (pBmonEntry) {
            if (!pBmonEntry->CheckSignature()) {
                DBGPRINTF(( DBG_CONTEXT,
                            "ATQ_BMON_ENTRY(%p)::CheckSignature() failed. index = %d\n",
                            pBmonEntry, i));
                            
                DBG_ASSERT( pBmonEntry->CheckSignature() );
            }

            if ((pBmonEntry->GetOpcode() == BMON_WAIT)
                && (FD_ISSET(pBmonEntry->GetSocket(), &m_ListenSet))) {

                if ( !pBmonEntry->Callback() )
                {
                    fRet = FALSE;
                    break;
                }
            }
        }
    }

    Unlock();
    
    return fRet;
}


DWORD WINAPI
BmonThreadFunc(
    LPVOID lpBmonSet
    )
/*++

Routine Description:

    This function starts the select thread
    of an ATQ_BMON_SET.

Arguments:

    pBmonSet - the set to call

Return Values:

    0
--*/
{
    ATQ_BMON_SET * pBmonSet = (ATQ_BMON_SET *) lpBmonSet;
    pBmonSet->BmonThreadFunc();
    return 0;
}


//
// atqbmon.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\atqendp.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

      atqendp.cxx

   Abstract:
      This module implements ATQ endpoints

   Author:

       Johnson Apacible    (JohnsonA)     13-May-1996

   Environment:

       User Mode -- Win32

--*/

#include "isatq.hxx"

//
// Forward declarations
//

BOOL
I_CreateListenSocket(
    IN PATQ_ENDPOINT Endpoint
    );

BOOL
I_CloseListenSocket(
    IN PATQ_ENDPOINT Endpoint
    );

BOOL
StartListenThread(
    IN PATQ_ENDPOINT Endpoint
    );


# define ATQ_MIN_ACCEPTEX_TIMEOUT    (120)  // 2 minutes = 120 seconds

#define ATQ_CLOSE_ENDPOINT_SLEEP_TIME (200) // 200ms = 1/5 second
#define ATQ_CLOSE_ENDPOINT_TIMEOUT    ((100*1000) / ATQ_CLOSE_ENDPOINT_SLEEP_TIME)
                                            // 100 seconds


PVOID
AtqCreateEndpoint(
    IN PATQ_ENDPOINT_CONFIGURATION Configuration,
    IN PVOID EndpointContext
    )

/*++

Routine Description:

    Creates a server instance.

Arguments:

    Context - Context value returned

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/

{

    DWORD timeout = Configuration->AcceptExTimeout;
    PATQ_ENDPOINT endpoint;
    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF((DBG_CONTEXT,"AtqCreateEndpoint entered\n"));
    }

    //
    // Allocate list
    //

    endpoint = (PATQ_ENDPOINT)LocalAlloc(0,sizeof(ATQ_ENDPOINT));
    if ( endpoint == NULL ) {
        ATQ_PRINTF(( DBG_CONTEXT,"Unable to allocate ATQ Endpoint\n"));
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        goto error;
    }

    //
    // Initialize
    //

    ZeroMemory(endpoint,sizeof(ATQ_ENDPOINT));
    endpoint->Signature = ATQ_ENDPOINT_SIGNATURE;
    endpoint->m_refCount = 1;
    SET_BLOCK_STATE(endpoint, AtqStateActive);

    endpoint->EnableBw = FALSE;
    endpoint->ConnectCompletion = Configuration->pfnConnect;
    endpoint->ConnectExCompletion = Configuration->pfnConnectEx;
    endpoint->UseAcceptEx = (g_fUseAcceptEx) && (endpoint->ConnectExCompletion);
    endpoint->IoCompletion = Configuration->pfnIoCompletion;
    endpoint->ListenSocket = INVALID_SOCKET;
    endpoint->pListenAtqContext = NULL;
    endpoint->nAvailDuringTimeOut = 0;
    endpoint->nSocketsAvail = 0;
    endpoint->Context = EndpointContext;
    endpoint->pBacklogMon = NULL;

    endpoint->InitialRecvSize = Configuration->cbAcceptExRecvBuffer;

    // we need to maintain at least 5 outstanding accept ex sockets
    // for our auto-tune algo to work.
    endpoint->nAcceptExOutstanding =
        ( (Configuration->nAcceptExOutstanding > 4) ?
          Configuration->nAcceptExOutstanding : 5);


    //
    // fAddingSockets prevents two threads from adding AcceptEx sockets
    // at the same time. Since the endpoint isn't ready to have sockets
    // added we'll set this to TRUE until the endpoint is fully initialized
    // in ActivateEndpoint.
    //
    endpoint->fAddingSockets = TRUE;

    //
    // Check and set the timeout to be atleast minimum timeout for AcceptEx
    //
    if ( timeout <= ATQ_MIN_ACCEPTEX_TIMEOUT)  {
        timeout = ATQ_MIN_ACCEPTEX_TIMEOUT;
    }

    endpoint->AcceptExTimeout = CanonTimeout( timeout);

    endpoint->Port = Configuration->ListenPort;
    endpoint->IpAddress = Configuration->IpAddress;

    //endpoint->ContextList.Initialize( );

#if DBG
    endpoint->RefTraceLog = CreateRefTraceLog( TRACE_LOG_SIZE, 0 );
#endif

#if 0
    ATQ_PRINTF(( DBG_CONTEXT,"port %d nAX %d nAT %d nLB %d\n",
        endpoint->Port, endpoint->nAcceptExOutstanding,
        endpoint->AcceptExTimeout, g_cListenBacklog));
#endif

    //
    // Create the socket
    //

    if (!I_CreateListenSocket(endpoint) ) {

        goto error;
    }

    return((PVOID)endpoint);

error:

    if ( endpoint != NULL ) {
#if DBG
        if( endpoint->RefTraceLog != NULL ) {
            DestroyRefTraceLog( endpoint->RefTraceLog );
        }
#endif
        LocalFree( endpoint );
    }

    return(NULL);

} // AtqCreateEndpoint



BOOL
AtqStartEndpoint(
    IN PVOID Endpoint
    )
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    BOOL          fReturn;
    DWORD         dwError = NO_ERROR;

    ATQ_ASSERT(IS_BLOCK_ACTIVE(pEndpoint));

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF((DBG_CONTEXT,"AtqStartEndpoint called. UseAcceptEx[%d]\n",
            pEndpoint->UseAcceptEx));
    }

    //
    // if AcceptEx is supported, create AcceptEx contexts
    //

    if ( pEndpoint->UseAcceptEx ) {

        //
        // Add AcceptEx sockets
        //

        fReturn = pEndpoint->ActivateEndpoint();

        if ( !fReturn ) {
            dwError = GetLastError();
            
            DBGERROR(( DBG_CONTEXT,"Error %d in %08x::ActivateEndpoint()\n",
                GetLastError(), pEndpoint));
        }

    } else {

        //
        // We need to start a listen thread
        //

        fReturn = StartListenThread( pEndpoint );

        if ( !fReturn ) {
            dwError = GetLastError();
            
            DBGERROR(( DBG_CONTEXT,"Error %d in %08x::StartListenThread()\n",
                GetLastError(), pEndpoint));
        }
    }

    if (!fReturn) {
        AtqStopEndpoint(pEndpoint);
    }

    SetLastError(dwError);

    return (fReturn);

} // AtqStartEndpoint



ULONG_PTR
AtqEndpointGetInfo(
    IN PVOID Endpoint,
    IN ATQ_ENDPOINT_INFO EndpointInfo
    )
/*++

Routine Description:

    Gets various bits of information for the ATQ endpoint

Arguments:

    Endpoint    - endpoint to get data from
    EndpointInfo - type of info to get

Return Value:

    The old value of the parameter

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD_PTR     dwVal = 0;

    switch ( EndpointInfo ) {

      case EndpointInfoListenPort:
        dwVal = pEndpoint->Port;
        break;

      case EndpointInfoListenSocket:
        dwVal = pEndpoint->ListenSocket;
        break;

      default:
        ATQ_ASSERT( FALSE );
    }

    return dwVal;
} // AtqEndpointGetInfo()



ULONG_PTR
AtqEndpointSetInfo(
    IN PVOID                Endpoint,
    IN ATQ_ENDPOINT_INFO    EndpointInfo,
    IN ULONG_PTR             Info
    )
/*++

Routine Description:

    Gets various bits of information for the ATQ module

Arguments:

    Endpoint     - endpoint to set info on
    EndpointInfo - type of info to set
    Info         - info to set

Return Value:

    The old value of the parameter

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    ULONG_PTR  Val = 0;

    switch ( EndpointInfo ) {

        case EndpointInfoAcceptExOutstanding:

        Val = (ULONG_PTR)pEndpoint->nAcceptExOutstanding;

        if ( Val < Info ) {

            //
            // Make up for increased limit
            //

            if ( (DWORD ) pEndpoint->nSocketsAvail < (DWORD)(Info >> 2) ) {
                (VOID ) I_AtqPrepareAcceptExSockets(
                                        pEndpoint,
                                        (DWORD)(Info>>2) - pEndpoint->nSocketsAvail
                                        );
            }
            pEndpoint->nAcceptExOutstanding = (DWORD)Info;
        }
        break;

      default:
        ATQ_ASSERT( FALSE );
    }

    return Val;
} // AtqEndpointSetInfo()




BOOL
AtqStopEndpoint(
    IN PVOID     Endpoint
    )
/*++

Routine Description:

    Stops the endpoint - marks the Endpoint as to be shutdown and closes
    the listening socket -> forcing new connections to stop for this endpoint

Arguments:

    Endpoint - endpoint to be stopped

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD  nClosed;

    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqStopEndpoint( %08x)\n", pEndpoint));
    }

    //
    //  Find the listen socket info
    //

    AcquireLock( &AtqEndpointLock );

    if ( !IS_BLOCK_ACTIVE(pEndpoint) ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Attempt to Stop Endpoint (%08x) more than once",
                     pEndpoint
                     ));
        ReleaseLock( &AtqEndpointLock );
        return(FALSE);
    }

    //
    //  Mark the listen info as no longer accepting connections
    //

    SET_BLOCK_STATE(pEndpoint, AtqStateClosed);

    //
    //  Remove the entry from the end points list
    //

    RemoveEntryList(&pEndpoint->ListEntry);
    ReleaseLock( &AtqEndpointLock );

    //
    // Remove us from the Backlog Monitor
    //
    DBG_ASSERT( g_pAtqBacklogMonitor );

    if (pEndpoint->pBacklogMon) {
        DBG_REQUIRE( g_pAtqBacklogMonitor->RemoveEntry(pEndpoint->pBacklogMon) );
        delete pEndpoint->pBacklogMon;
        pEndpoint->pBacklogMon = NULL;
    }

    //
    // Close the listen socket which forces the cleanup for all the
    //  pending LISTEN ATQ contexts. We do this early on so that
    //  we can prevent any new entrant connections into the processing code.
    //

    I_CloseListenSocket( pEndpoint );

    //
    // Forcibly close all the pending LISTEN contexts tied to this endpoint
    //

    nClosed = pEndpoint->CloseAtqContexts( TRUE);

    DBGPRINTF(( DBG_CONTEXT,
                "ATQ_ENDPOINT(%08x)::Closed %d pending Listen sockets\n",
                pEndpoint, nClosed));

    //
    // if this is a non-acceptex socket, wait for the listen thread to die
    //

    if ( !pEndpoint->UseAcceptEx ) {
        WaitForSingleObject(pEndpoint->hListenThread, 10*1000);
    }

    return ( TRUE);

} // AtqStopEndpoint()


BOOL
AtqCloseEndpoint(
    IN PVOID     Endpoint
    )
/*++

Routine Description:

    Closes the endpoint - it forcefully fress up all references to the
    endpoint (held by ATQ Contexts) by shutting down the ATQ contexts.
    In the course of this operation if some context does not go away, this
    code will end up looping forever!

    Note: Should be called *after* AtqStopEndpoint()

Arguments:

    Endpoint - endpoint to be stopped

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD  nClosed;
    DWORD i;

    ASSERT( pEndpoint->Signature == ATQ_ENDPOINT_SIGNATURE );


    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqCloseEndpoint( %08x)\n", pEndpoint));
    }

    if ( pEndpoint->State != AtqStateClosed) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Attempt to Close Endpoint (%08x) when it is "
                     " not stopped yet!\n'",
                     pEndpoint
                     ));

        DBG_ASSERT(pEndpoint->State == AtqStateClosed);
        
        return(FALSE);
    }

    //
    // wait for all the contexts for this endpoint to go away
    // or for about two minutes
    //

    i = 0;
    while (( pEndpoint->m_refCount > 1) && (i < ATQ_CLOSE_ENDPOINT_TIMEOUT)) {

        ATQ_PRINTF(( DBG_CONTEXT, " Endpoint(%08x) has %d refs\n",
                     pEndpoint, pEndpoint->m_refCount));

        //
        // Forcibly close all the contexts tied to this endpoint again!
        // Sometimes for some random reasons ATQ contexts get left out
        //  during the first clean we did above. In such case it is important
        //  to retry again
        // THIS IS UGLY. But if we did not do this then the Endpoint
        //  structure might get freed => ATQ contexts will be hanging on to
        //  dead ATQ endpoint
        //

        nClosed = pEndpoint->CloseAtqContexts();

        DBGPRINTF(( DBG_CONTEXT, " ATQ_ENDPOINT(%08x)::Closed %d sockets\n",
                    pEndpoint, nClosed));

        //
        // NYI: I need to auto-tune this sleep function
        //
        Sleep( ATQ_CLOSE_ENDPOINT_SLEEP_TIME); // sleep and check again.

#if DBG
        //
        // loop forever for checked builds
        //
#else
        //
        // loop until timeout for retail
        //
        i++;
#endif

        // wake up and check again.
    } // while (busy wait)

    //
    //  Undo the reference for being on the listen info list.
    //    decr final ref count => the endpoint will be cleaned up & freed
    //
    //  If we timed out just leak the endpoints!
    //

    if ( pEndpoint->m_refCount == 1 ) {
        pEndpoint->Dereference();

        return TRUE;
    } else {
        return FALSE;
    }

} // AtqCloseEndpoint()



BOOL
AtqStopAndCloseEndpoint(
    IN PVOID                    Endpoint,
    IN LPTHREAD_START_ROUTINE   lpCompletion,
    IN PVOID                    lpCompletionContext
    )
/*++

Routine Description:

    Stops the endpoint and closes it after forcing close of
    associated ATQ contexts.

Arguments:

    Endpoint - endpoint to shutdown.
    lpCompletion - routine to be called when endpoint is completely shutdown.
    lpCompletionContext - Context to be returned with the routine

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    BOOL fReturn;

    //
    // Warn all the callers of this to be deprecated API and pray that
    // they will all switch over
    //
#ifndef _NO_TRACING_
    DBGPRINTF( (DBG_CONTEXT, "\n-----------------------------------------------\n"));
    DBGPRINTF( (DBG_CONTEXT, " AtqStopAndCloseEndpoint() should NOT be called\n"));
    DBGPRINTF( (DBG_CONTEXT, "         Call 1) AtqStopEndpoint()  and \n"));
    DBGPRINTF( (DBG_CONTEXT, "              2) AtqCloseEndpoint() instead\n"));
    DBGPRINTF( (DBG_CONTEXT, "   For Now, this call will simulate 1 & 2\n"));
    DBGPRINTF( (DBG_CONTEXT, "-----------------------------------------------\n"));
#else
    OutputDebugStringA( "\n-----------------------------------------------\n");
    OutputDebugStringA( " AtqStopAndCloseEndpoint() should NOT be called\n");
    OutputDebugStringA( "         Call 1) AtqStopEndpoint()  and \n");
    OutputDebugStringA( "              2) AtqCloseEndpoint() instead\n");
    OutputDebugStringA( "   For Now, this call will simulate 1 & 2\n");
    OutputDebugStringA( "-----------------------------------------------\n");
#endif


    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqStopAndCloseEndpoint( %08x)\n", pEndpoint));
    }

    fReturn = AtqStopEndpoint( Endpoint);

    if ( fReturn) {

        //
        // Call any custom shutdown function
        // NYI: Too Bad the Endpoint object is not a base class object
        //

        if ( lpCompletion != NULL ) {
            pEndpoint->ShutdownCallback = lpCompletion;
            pEndpoint->ShutdownCallbackContext = lpCompletionContext;
        }

        //
        // Now that the Endpoint is stopped and callback functions are called,
        //  Let us call the AtqCloseEndpoint() to cleanup the endpoint itself.
        //
        fReturn = AtqCloseEndpoint( Endpoint);
    }

    return (fReturn);

} // AtqStopAndCloseEndpoint()



BOOL
ATQ_ENDPOINT::ActivateEndpoint( VOID)
/*++

Routine Description:


    This function creates the initial listening socket & ATQ context for given
    endpoint. It also adds initial set of AcceptEx Sockets to the ATQ listening
    pool (if we are using the AcceptEx())

Arguments:
    None

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    PATQ_CONT   patqContext = NULL;
    BOOL        fReturn;
    DWORD       cInitial = this->nAcceptExOutstanding;

    //
    //  Add the listen socket
    //
    DBG_ASSERT( this->pListenAtqContext == NULL);

    fReturn =
        I_AtqAddListenEndpointToPort(
                                     (PATQ_CONT*)&this->pListenAtqContext,
                                     this
                                     );

    if ( !fReturn) {

        if ( this->pListenAtqContext ) {
            AtqFreeContext( this->pListenAtqContext, FALSE);
            this->pListenAtqContext = NULL;
        }

        return FALSE;
    }

    cInitial = max(cInitial, 1);

    if ( !TsIsNtServer( ) ) {

        //
        // Limit what a workstation can specify
        //

        cInitial = min(cInitial, ATQ_MIN_CTX_INC);
        this->nAcceptExOutstanding = cInitial;

    }

    //
    // start with 1/4 of the intended
    //

    cInitial = max( cInitial >> 2, 1);

    //
    // Now we're finally ready to add AcceptEx sockets, so we'll
    // reset the flag that was preventing it.
    //
    fAddingSockets = FALSE;

    //
    //  Now add the acceptex sockets for this ListenInfo object
    //

    fReturn = I_AtqPrepareAcceptExSockets(this, cInitial);

    if (fReturn && !g_fDisableBacklogMonitor ) { 
        //
        // Set up the Backlog monitor
        //
        DBG_ASSERT( pBacklogMon == NULL );
        DBG_ASSERT( g_pAtqBacklogMonitor );
        
        pBacklogMon = new ATQ_ENDPOINT_BMON(ListenSocket, this);

        if (pBacklogMon) {

            fReturn = (pBacklogMon->InitEvent()
                        && g_pAtqBacklogMonitor->AddEntry(pBacklogMon));

            if (!fReturn) {
                delete pBacklogMon;
                pBacklogMon = NULL;
            }
        } else {
            fReturn = FALSE;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return(fReturn);

} // ATQ_ENDPOINT::ActivateEndpoint()



DWORD
ATQ_ENDPOINT::CloseAtqContexts( IN BOOL fPendingOnly)
/*++
  Description:
    This function searches for all ATQ contexts associated
     with the given endpoint and forcibly closes them all.

  Arguments:
    fPendingOnly - close only the pending sockets

  Returns:
    DWORD containing the number of ATQ contexts closed.
--*/
{
    DWORD  nClosed = 0;
    DWORD  i;
    PLIST_ENTRY   pEntry;
    PATQ_CONT     pContext;

    //
    //  Force a close on all the connected sockets so that all the holders
    //   and use of such contexts will bail out of this endpoint entirely.
    // NYI: We need a way to tag on all these lists on per-endpoint basis
    //

    for ( i = 0; i < g_dwNumContextLists; i++) {

        PLIST_ENTRY pListHead;

        AtqActiveContextList[i].Lock();

        //
        // Hard close sockets in the pending list
        //

        pListHead = &AtqActiveContextList[i].PendingAcceptExListHead;
        for ( pEntry = pListHead->Flink;
             pEntry != pListHead;
             pEntry  = pEntry->Flink ) {

            pContext = CONTAINING_RECORD( pEntry, ATQ_CONTEXT, m_leTimeout );

            ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

            if ( (pContext->pEndpoint == this) &&
                 (pContext->IsState( ACS_SOCK_CONNECTED) ||
                  pContext->IsState( ACS_SOCK_LISTENING)
                  ) &&
                 (pContext->hAsyncIO  != NULL) ) {

                nClosed++;
                pContext->HardCloseSocket();
            }
        } // for items in pending list

        if ( !fPendingOnly) {
            //
            // Hard close sockets in the active list
            // Active list includes sockets in ACS_SOCK_CLOSED state
            //  that ought to be freed up, because we could have reached
            //  this through the optimizations for TransmitFile()
            //

            pListHead = &AtqActiveContextList[i].ActiveListHead;
            for ( pEntry = pListHead->Flink;
                  pEntry != pListHead;
                  pEntry  = pEntry->Flink ) {

                pContext = CONTAINING_RECORD( pEntry, ATQ_CONTEXT,
                                              m_leTimeout );

                ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

                if ( (pContext->pEndpoint == this)  &&
                     (pContext->IsState( ACS_SOCK_CONNECTED) ||
                      pContext->IsState( ACS_SOCK_LISTENING) ||
                      pContext->IsState( ACS_SOCK_CLOSED) ||
                      pContext->IsState( ACS_SOCK_UNCONNECTED)
                      ) &&
                     (pContext->hAsyncIO  != NULL) ) {

                    nClosed++;
                    pContext->HardCloseSocket();
                }
            } // for items in active list
        } // if (! fPendingOnly)

        AtqActiveContextList[i].Unlock();

    } // for

    return ( nClosed);

} // ATQ_ENDPOINT::CloseAtqContexts()


/************************************************************
 * Internal Functions
 ************************************************************/


BOOL
I_CreateListenSocket(
    IN PATQ_ENDPOINT pEndpoint
    )
/*++

    Creates a socket for listening to connections on given address.

    Arguments:

       lpSockAddress    pointer to local socket address structure used to bind
                           the given connection.
       lenSockAddress   length of the socket address structure.
       socketType       integer containing the type of the socket ( stream )
       socketProtocol   protocol to be used for the socket.
       nBackLog         Maximum length to which a queue of pending connections
                           may grow.

    Returns:
       NO_ERROR on success; otherwise returns Sockets error code.

--*/
{
    INT serr;
    SOCKET  sNew;
    BOOL  fReuseAddr = FALSE;
    SOCKADDR_IN inAddr;
    PSOCKADDR addr;
    INT addrLength;
    PLIST_ENTRY listEntry;
    PATQ_ENDPOINT scanEndpoint;

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF((DBG_CONTEXT,"I_CreateListenEndpoint called. \n"));
    }

    //
    // Since we'll be altering our behaviour based on the contents of
    // the endpoint list, we must acquire the endpoint list lock and
    // hold this lock throughout this routine.
    //

    AcquireLock( &AtqEndpointLock);

    //
    // If this is the first endpoint to be bound to this port, then
    // disable SO_REUSEADDR. Otherwise (there are other endpoints already
    // using this port), then enable SO_REUSEADDR.
    //
    // "Why are we doing this" you ask? Since we're binding our listening
    // sockets to specific IP addresses, we must enable SO_REUSEADDR
    // (otherwise, we'd get WSAEADDRINUSE errors). However, in an effort
    // to detect a port conflicts with other (non-IIS) software, we'll
    // disable SO_REUSEADDR the *first* time a particular port is used.
    //

    for( listEntry  = AtqEndpointList.Flink;
         listEntry != &AtqEndpointList;
         listEntry  = listEntry->Flink ) {

        scanEndpoint = CONTAINING_RECORD(
                           listEntry,
                           ATQ_ENDPOINT,
                           ListEntry
                           );

        ATQ_ASSERT( scanEndpoint->Signature == ATQ_ENDPOINT_SIGNATURE );

        if( scanEndpoint->Port == pEndpoint->Port ) {
            fReuseAddr = TRUE;
            break;
        }

    }

    //
    // Create a new socket
    //

#if WINSOCK11
    sNew =  socket(
                AF_INET,
                SOCK_STREAM,
                IPPROTO_TCP
                );
#else
    sNew = WSASocket(
                  AF_INET,
                  SOCK_STREAM,
                  IPPROTO_TCP,
                  NULL,  // protocol info
                  0,     // Group ID = 0 => no constraints
                  WSA_FLAG_OVERLAPPED    // completion port notifications
                  );
# endif // WINSOCK11

    if ( sNew == INVALID_SOCKET ) {
        serr = WSAGetLastError();
        ATQ_PRINTF(( DBG_CONTEXT,
                    "Error %d in socket( %d, %d, %d)\n",
                    serr,
                    AF_INET,
                    SOCK_STREAM,
                    IPPROTO_TCP
                    ));

        goto cleanup;
    }

    //
    // Set SO_REUSEADDR based on results of the endpoint scan above.
    //

    if ( setsockopt( sNew, SOL_SOCKET, SO_REUSEADDR,
                    (const CHAR *) &fReuseAddr,
                    sizeof( fReuseAddr)) != 0) {

        serr = WSAGetLastError();

        ATQ_PRINTF(( DBG_CONTEXT,
                    " setsockopt( %d, REUSE_ADDR, FALSE) failed."
                    " Error = %d\n",
                    sNew, serr));

        goto cleanup;
    }

    //
    // See which address family we're dealing with
    //

    addr = (PSOCKADDR)&inAddr;
    addrLength = sizeof(inAddr);
    ZeroMemory(addr, addrLength);

    inAddr.sin_family = AF_INET;
    inAddr.sin_port = htons(pEndpoint->Port);
    inAddr.sin_addr.s_addr = pEndpoint->IpAddress;

    //
    // Bind an address to socket
    //

    if ( bind( sNew, addr, addrLength) != 0) {

        serr = WSAGetLastError();

        ATQ_PRINTF(( DBG_CONTEXT,
                    "bind ( socket = %d, Address = %08x, len = %d) "
                    " returns error = %u\n",
                    sNew, addr, addrLength, serr));

        goto cleanup;
    }

    //
    // Put the socket in listen mode
    //

    if ( listen( sNew, g_cListenBacklog) != 0) {

        serr = WSAGetLastError();

        ATQ_PRINTF(( DBG_CONTEXT,
                    " listen( %d, %d) returned %d.\n",
                    sNew, g_cListenBacklog, serr));
        goto cleanup;
    }

    pEndpoint->ListenSocket = sNew;

    //
    // Link to server listen list
    //

    InsertTailList(
                &AtqEndpointList,
                &pEndpoint->ListEntry
                );

    ReleaseLock( &AtqEndpointLock);
    return(TRUE);

cleanup:

    if ( sNew != INVALID_SOCKET) {
        closesocket( sNew);
    }

    ReleaseLock( &AtqEndpointLock);
    SetLastError(serr);
    return(FALSE);

} // I_CreateListenSocket




BOOL
I_CloseListenSocket(
    IN PATQ_ENDPOINT Endpoint
    )
/*++

  Closes the socket on which a listen was possibly established.

  Returns:
    TRUE, if successful,
    FALSE, otherwise

--*/
{
    INT  serr = NO_ERROR;
    LINGER linger;
    SOCKET s;

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF((DBG_CONTEXT,"I_CloseListenSocket called.\n"));
    }

    s = (SOCKET)InterlockedExchangePointer(
                    (PVOID *)&Endpoint->ListenSocket,
                    (PVOID)INVALID_SOCKET
                    );

    if ( s == INVALID_SOCKET) {
        return(TRUE);
    }

    //
    //  Enable linger with timeout of ZERO for "hard" close
    //
    //  Error code from sock option is ignored, since we are
    //   anyway closing the socket
    //

    linger.l_onoff = TRUE;
    linger.l_linger = 0;
    setsockopt( s, SOL_SOCKET, SO_LINGER, (PCHAR)&linger,sizeof(linger));

    //
    // Close the socket
    //

    if (closesocket(s) != 0) {
        serr = WSAGetLastError();
        ATQ_PRINTF(( DBG_CONTEXT,"error %d in closesocket\n",serr));
    } else {

        // Remove the socket from the ListenAtq Context as well
        //  since the socket is now closed here in this function.
        PATQ_CONTEXT patqc = Endpoint->pListenAtqContext;
        if ( patqc != NULL) {
            patqc->hAsyncIO = NULL;
        }
    }

    return (TRUE);
} // I_CloseListenSocket()




DWORD
ListenThreadFunc(
        LPVOID Context
        )
/*++

    Main loop waiting for connections. ( The core of server)
    The thread loops around waiting on an accept() call on
     listenSocket.
    If there is a new message on socket, it invokes the
     callback function for connection.

    NEVER returns untill it is requested to stop by someother
      thread using a call to TS_CONNECTION_INFO::StopConnectionThread().

    Returns:

      0 on success and error code if there is a fatal error.


--*/
{

    INT serr;
    register SOCKET  sNewConnection;
    SOCKADDR_IN sockAddrRemote;
    PATQ_ENDPOINT endpoint = (PATQ_ENDPOINT)Context;

    IF_DEBUG(ENDPOINT) {
        ATQ_PRINTF((DBG_CONTEXT,"ListenThreadFunc() running.\n"));
    }

    //
    //  Loop Forever
    //

    for( ; ;) {

        int cbAddr = sizeof( sockAddrRemote);

        //
        //  Wait for a connection
        //

        IF_DEBUG(ENDPOINT) {
            ATQ_PRINTF((DBG_CONTEXT,"Listening for new connection\n"));
        }

        if ((sNewConnection = WSAAccept(
                                    endpoint->ListenSocket,
                                    (LPSOCKADDR ) &sockAddrRemote,
                                    &cbAddr,
                                    NULL,
                                    0)) != INVALID_SOCKET) {

            //
            // Valid Connection has been established.
            // Invoke the callback function to process this connection
            //   and then continue the loop
            //

            IF_DEBUG(ENDPOINT) {
                ATQ_PRINTF((DBG_CONTEXT,"Got new connection. sock[%d]\n",
                    sNewConnection));
            }

            (*endpoint->ConnectCompletion)(
                                sNewConnection,
                                &sockAddrRemote,
                                endpoint->Context,
                                (PVOID)endpoint
                                );

        } else {

            //
            // Some low level error has occured.
            //

            serr = WSAGetLastError();
            ATQ_PRINTF((DBG_CONTEXT,"Error %d in accept\n", serr));

            if ( serr == WSAEINTR) {

                //
                // Socket was closed by low-level call. Get out.
                //

                break;
            }

            //
            // Check if we are shutting down and if so QUIT
            //

            if (!IS_BLOCK_ACTIVE(endpoint)) {
                IF_DEBUG(ENDPOINT) {
                    ATQ_PRINTF((DBG_CONTEXT,"ListenThread shutting down\n"));
                }
                break;
            }

            //
            // Perform a graceful recovery from failure. NYI
            //  ( Tricky code). Both FTP and Web server are to test it!
            //    Will add this code later. ( MuraliK)
            //

            IF_DEBUG(ENDPOINT) {
                ATQ_PRINTF((DBG_CONTEXT,"Unexpected error %d on accept\n",
                    serr));
            }
        }
    }

    //
    // Cleanup & Exit. Cleanup is done by the code which called the shut down.
    //

    IF_DEBUG(ENDPOINT) {
        ATQ_PRINTF((DBG_CONTEXT,"ListenThread exiting.\n"));
    }
    return ( 0);  // No errors

} // ListenThreadFunc()



BOOL
StartListenThread(
    IN PATQ_ENDPOINT Endpoint
    )
{
    DWORD  id;

    Endpoint->hListenThread = CreateThread(
                                        NULL,
                                        0,
                                        ListenThreadFunc,
                                        (PVOID )Endpoint,
                                        0,
                                        &id
                                        );

    if ( Endpoint->hListenThread != NULL) {
        return(TRUE);
    }

    return(FALSE);

} // StartListenThread



VOID
ATQ_ENDPOINT::CleanupEndpoint(
    VOID
    )
/*++

  Description:
     This function cleansup the internal state of the object and prepares
     it for the deletion.
     All endpoints should pass through this function when the ref count
     this zero.

--*/
{
    DBG_ASSERT( this->m_refCount == 0);
    ATQ_ASSERT( !IS_BLOCK_ACTIVE( this) );
    ASSERT( this->Signature == ATQ_ENDPOINT_SIGNATURE );

    // the following free will throw away the listen atq context
    if ( this->pListenAtqContext != NULL) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "Endpoint(%08x) frees listen context %08x\n",
                     this, this->pListenAtqContext));
        AtqFreeContext( this->pListenAtqContext, FALSE);
        this->pListenAtqContext = NULL;
    }

    if ( this->ShutdownCallback != NULL ) {
        //
        // This only happens when someone calls AtqStopAndCloseEndpoint which should
        // never happen in K2.
        //
        ASSERT( FALSE );
        this->ShutdownCallback( this->ShutdownCallbackContext);
    }
    
    this->Signature = ATQ_ENDPOINT_SIGNATURE_FREE;

#if DBG
    if( this->RefTraceLog != NULL ) {
        DestroyRefTraceLog( this->RefTraceLog );
    }
#endif

    return;

} // ATQ_ENDPOINT::CleanupEndpoint()


VOID
ATQ_ENDPOINT_BMON::ForceCompletion(
    IN PVOID                pvContext
)
/*++

Routine Description:

    Scheduled timeout of all unconnected sockets
    
Arguments:

    pvContext - Context (ATQ_ENDPOINT_BMON *)

Return Values:

    None
    
--*/
{
    ATQ_ENDPOINT_BMON*          pEndpointBMon;
    PATQ_CONTEXT_LISTHEAD       pACL;
    DWORD                       cForcedTotal = 0;
    DWORD                       cForced = 0;
    
    if ( !pvContext )
    {
        DBG_ASSERT( FALSE );
        return;
    }
    
    pEndpointBMon = (ATQ_ENDPOINT_BMON*) pvContext;
    
    for ( pACL = AtqActiveContextList;
          pACL < (AtqActiveContextList + g_dwNumContextLists);
          pACL++ )
    {
        I_AtqProcessPendingListens( pACL, 
                                    pEndpointBMon->m_pEndpoint, 
                                    &cForced );

        cForcedTotal += cForced;
    }
   
    //
    // Add back any sockets we forced
    //
    
    if ( cForcedTotal )
    {
        I_AtqPrepareAcceptExSockets( pEndpointBMon->m_pEndpoint,
                                     cForcedTotal );
    }

    //
    // Update stats
    //
   
    pEndpointBMon->m_nSocketsReset += cForcedTotal;

    pEndpointBMon->m_dwForceCookie = 0;
}

BOOL
ATQ_ENDPOINT_BMON::Callback(
    VOID
    )
/*++

Routine Description:

    The ATQ_BACKLOG_MONITOR calls this function
    when our listen socket runs out of AccepEx
    sockets.
    
Arguments:

    None

Return Values:

    Return TRUE if successful, else FALSE
--*/
{
    PLIST_ENTRY         pListEntry;

    // How many times were we called?

    m_nActivations++;

    //
    // Inform the set thread to sleep after all notifications
    //
    
    GetContainingBmonSet()->DoSleep( TRUE );    

    //
    // Are there available threads?  If not, then this condition won't be
    // helped by creating more sockets.  Do nothing.
    //
    
    if ( g_cAvailableThreads )
    {
        DBG_ASSERT( m_pEndpoint );
        
        if ( !g_cForceTimeout )
        {
            //
            // No wait period before force.  Just do it.
            //
                
            ForceCompletion( this );
        }
        else if ( !m_dwForceCookie )
        {
            //
            // OK.  Let's do something.  Traverse the list of unconnected
            // sockets and set an <x> second timeout on each
            //
                
            m_dwForceCookie = ScheduleWorkItem( 
                                    ATQ_ENDPOINT_BMON::ForceCompletion,
                                    this,
                                    TimeToWait( g_cForceTimeout ),
                                    FALSE );
        }
    }
    
    return TRUE;
}

ATQ_ENDPOINT_BMON::~ATQ_ENDPOINT_BMON(
    VOID
)
/*++

Routine Description:

    ATQ_ENDPOINT_BMON destructor.  Kill the scheduled work item if there
    
Arguments:

    None

Return Values:

    None

--*/
{
    if ( m_dwForceCookie )
    {
        RemoveWorkItem( m_dwForceCookie );
        m_dwForceCookie = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\atqcport.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT - Windows 95          **/
/**                Copyright(c) Microsoft Corp., 1994-1996           **/
/**********************************************************************/


/*
    atqcport.cxx

    This module contains replacement code for completion port and TransmitFile APIs
    for Windows95 , where this functionality is absent.

    Code is tightly coupled with ATQ code, reusing some of the data structures and globals.
    Main ATQ processing code is left intact as much as possible , so that when we get real
    completion ports, amount of modications should be minimal

    One port per process currently supported.

    FILE HISTORY:
        VladS       05-Jan-1996 Created.

   Functions Exported:

        HANDLE  SIOCreateCompletionPort();
        DWORD   SIODestroyCompletionPort();

        DWORD   SIOStartAsyncOperation();
        BOOL    SIOGetQueuedCompletionStatus();
        DWORD   SIOPostCompletionStatus();

*/

#include "isatq.hxx"
#include "atqcport.hxx"
#include <inetsvcs.h>

/************************************************************
 * Private Globals
 ************************************************************/

W95CPORT *g_pCPort = NULL;

//
// Queues with ATQ contexts, being processed in completion port
//

LIST_ENTRY  g_SIOIncomingRequests ;     // Queue of incoming socket i/o
LIST_ENTRY  g_SIOCompletedIoRequests ;  // Queue with results of i/o

CRITICAL_SECTION g_SIOGlobalCriticalSection; // global sync variable.

HANDLE  g_hPendingCompletionSemaphore = NULL;

DWORD SIOPoolThread( LPDWORD param );

BOOL
SIO_Private_StartAsyncOperation(
    IN  HANDLE          hExistingPort,
    IN  PATQ_CONT       pAtqContext
    );

PATQ_CONT
SIO_Private_GetQueuedContext(
    LIST_ENTRY *pQueue
    );

BOOL
SIOCheckContext(
    IN  PATQ_CONTEXT pAtqC,
    IN  BOOL         fNew       /* = TRUE */
    );

PATQ_CONT
FindATQContextFromSocket(
    SOCKET          sc
    );

//
// Global synzronization calls
//

#define SIOLockGlobals()   EnterCriticalSection( &g_SIOGlobalCriticalSection )
#define SIOUnlockGlobals() LeaveCriticalSection( &g_SIOGlobalCriticalSection )

/************************************************************
*  Public functions.
************************************************************/

HANDLE
SIOCreateCompletionPort(
    IN  HANDLE  hAsyncIO,
    IN  HANDLE  hExistingPort,
    IN  ULONG_PTR dwCompletionKey,
    IN  DWORD   dwConcurrentThreads
    )
/*++

Routine Description:

    Initializes the ATQ completion port

Arguments:

Return Value:

    valid handle  if successful, NULL on error (call GetLastError)

--*/
{

    IF_DEBUG(SIO) {
        ATQ_PRINTF((DBG_CONTEXT,"SIOCreateCompletionPort entered\n"));
    }

    if (INVALID_HANDLE_VALUE != hAsyncIO) {

        //
        // Set up i/o handle to non-blocking mode
        //

        DWORD one = 1;
        ioctlsocket( HANDLE_TO_SOCKET(hAsyncIO), FIONBIO, &one );
    }

    //
    // If passed handle is not null - only initialize our parts of ATQ context
    // as completion port object has been created before
    //

    if ( (hExistingPort != NULL) && (g_pCPort != NULL) ) {

        PATQ_CONT   pAtqContext = (PATQ_CONT)dwCompletionKey;

        IF_DEBUG(SIO) {
            ATQ_PRINTF((DBG_CONTEXT,
               "[SIO_CreatePort(%lu)] Received  context=%x socket=%x\n",
                GetCurrentThreadId(),pAtqContext,hAsyncIO));
        }

        //
        // Set up SIO specific fields in ATQ context
        //

        pAtqContext->SIOListEntry.Flink =
        pAtqContext->SIOListEntry.Blink = NULL;

        pAtqContext->dwSIOFlags = 0;

        return (HANDLE)g_pCPort;
    }

    //
    // First time initialization
    //

    g_pCPort = new W95CPORT(dwConcurrentThreads);

    if ( (g_pCPort == NULL) ||
         (g_pCPort->QueryWakeupSocket() == INVALID_SOCKET) ) {

        ATQ_PRINTF((DBG_CONTEXT,
                    "[SIO]Could not create completion port"
                    ));

        delete g_pCPort;
        ATQ_ASSERT(FALSE);
        return NULL;
    }

    InitializeListHead( &g_SIOIncomingRequests );
    InitializeListHead( &g_SIOCompletedIoRequests );

    //
    // Prepare global syncronization mechanism
    //

    INITIALIZE_CRITICAL_SECTION( &g_SIOGlobalCriticalSection );

    g_hPendingCompletionSemaphore =
                        IIS_CREATE_SEMAPHORE(
                            "g_hPendingCompletionSemaphore",
                            &g_hPendingCompletionSemaphore,
                            0,                  // Initial count
                            0x7fffffff          // Maximum count
                            );

    return (HANDLE)g_pCPort;

} // SIOCreateCompletionPort


BOOL
SIODestroyCompletionPort(
    IN  HANDLE  hExistingPort
    )
/*++

Routine Description:

    Destroys ATQ completion port

Arguments:

Return Value:

    TRUE,  if successful,
    FALSE, otherwise

--*/
{

    PATQ_CONT   pAtqContext = NULL;
    W95CPORT    *pCPort = (W95CPORT *)hExistingPort;

    //
    // Queue completion indications to SIO thread and file I/O threads
    //

    if ( pCPort == NULL ) {

        //
        // Port already destroyed - return
        //

        return TRUE;
    }

    g_pCPort->Shutdown();

    delete g_pCPort;
    g_pCPort = NULL;

    return TRUE;

} // SIODestroyCompletionPort


BOOL
SIOStartAsyncOperation(
    IN  HANDLE          hExistingPort,
    IN  PATQ_CONTEXT    pAtqContext
    )
/*++

Routine Description:

    Queues ATQ context with requested i/o operation to the completion port.
    Values in context should be set by a caller , coompletion will be available
    by calling SIOGetQueuedCompletionStatus.

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{

    PATQ_CONT   pAtqFullContext = (PATQ_CONT)pAtqContext;
    W95CPORT    *pCPort = (W95CPORT *)hExistingPort;
    DWORD       dwErr;

    // Parameter validation

    if (!hExistingPort || !pAtqContext) {
        ATQ_ASSERT(FALSE);
        SetLastError(ERROR_INVALID_PARAMETER);
        InterlockedDecrement( &pAtqFullContext->m_nIO);
        return FALSE;
    }

    //
    // Add this context to the incoming queue
    //

    IF_DEBUG(SIO) {
        ATQ_PRINTF((DBG_CONTEXT,
           "[StartAsyncOperation(%lu)] AtqCtxt=%x  \n ",
            GetCurrentThreadId(),
            pAtqContext
            ));
    }

    //
    // Is this valid new context for completion port.
    //

    if(!SIOCheckContext(pAtqContext,TRUE)) {
        dwErr = ERROR_OPERATION_ABORTED;
        goto error_exit;
    }

    //
    // Check SIO thread status, if there are no thread , create one
    //

    if (!pCPort->SIOCheckCompletionThreadStatus()) {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    //
    // Validate file handle
    //

    if (!pAtqFullContext->hAsyncIO) {
        dwErr = WSAENOTSOCK;
        goto error_exit;
    }

    SIOLockGlobals();

    pAtqFullContext->dwSIOFlags &= ~ATQ_SIO_FLAG_STATE_MASK;
    pAtqFullContext->dwSIOFlags |= ATQ_SIO_FLAG_STATE_INCOMING;

    InsertTailList( &g_SIOIncomingRequests, &pAtqFullContext->SIOListEntry );

    SIOUnlockGlobals();

    //
    // Signal processing thread about scheduling new i/o operation
    //

    pCPort->Wakeup();

    return TRUE;

error_exit:

    ATQ_PRINTF((DBG_CONTEXT,"Error %d in SIOStartAsyncOperation\n", dwErr));

    //
    // Then no need to select, we can just fail this I/O
    //

    pAtqFullContext->arInfo.dwLastIOError =  dwErr;

    //
    // Immediately queue context as completed
    //

    SIOPostCompletionStatus(hExistingPort,
                            0,                                //Total dwBytesTransferred from arInfo
                            (ULONG_PTR)pAtqFullContext,
                            pAtqFullContext->arInfo.lpOverlapped);

    return TRUE;

} // SIOStartAsyncOperation


BOOL
SIOGetQueuedCompletionStatus(
    IN  HANDLE          hExistingPort,
    OUT LPDWORD         lpdwBytesTransferred,
    OUT PULONG_PTR       lpdwCompletionKey,
    OUT LPOVERLAPPED    *lplpOverlapped,
    IN  DWORD           msThreadTimeout
    )
/*++

Routine Description:

    Get next available completion or blocks
Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    //
    // Validate parameters
    //

    if (!lpdwBytesTransferred || !lpdwCompletionKey) {
        ATQ_ASSERT(FALSE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    PATQ_CONT   pAtqContext = NULL;

    DWORD       dwErr = NOERROR;
    BOOL        fRes = FALSE;

    //
    // Wait on completed queue semaphore
    //

#if 0
    dwErr = WaitForSingleObject(
                g_hPendingCompletionSemaphore,
                msThreadTimeout
                );

#else

    while ( TRUE ) {

        MSG msg;

        //
        // Need to do MsgWait instead of WaitForSingleObject
        // to process windows msgs.  We now have a window
        // because of COM.
        //

        dwErr = MsgWaitForMultipleObjects( 1,
                                         &g_hPendingCompletionSemaphore,
                                         FALSE,
                                         msThreadTimeout,
                                         QS_ALLINPUT );

        if ( (dwErr == WAIT_OBJECT_0) ||
             (dwErr == WAIT_TIMEOUT) ) {
            break;
        }

        while ( PeekMessage( &msg,
                             NULL,
                             0,
                             0,
                             PM_REMOVE ))
        {
            DispatchMessage( &msg );
        }
    }

#endif

    if (dwErr == WAIT_OBJECT_0 ) {

        pAtqContext  = SIO_Private_GetQueuedContext(&g_SIOCompletedIoRequests);

        //
        // Operation completed - reset IO command in ATQ context
        //

        IF_DEBUG(SIO) {
            ATQ_PRINTF((DBG_CONTEXT,
                "GetQueuedContext returns context = %x\n", pAtqContext));
        }
    } else {

        //
        // timed out
        //

        ATQ_PRINTF((DBG_CONTEXT,"SIOGetQueuedCompletionStatus timed out\n"));
    }

    if (pAtqContext != NULL) {

        //
        // Is this valid  context inside completion port ?
        //

        if(!SIOCheckContext((PATQ_CONTEXT)pAtqContext,FALSE)) {
            SetLastError(ERROR_OPERATION_ABORTED);
            return FALSE;
        }

        //
        // Get atq context and overlapped buffer pointer from
        // completion message
        //

        *lplpOverlapped = pAtqContext->arInfo.lpOverlapped;
        *lpdwCompletionKey = (ULONG_PTR)pAtqContext;
        *lpdwBytesTransferred = pAtqContext->arInfo.dwTotalBytesTransferred;

        IF_DEBUG(SIO) {
            ATQ_PRINTF((DBG_CONTEXT,
                "GetQueuedCompletion Returning %d bytes\n",
                *lpdwBytesTransferred));
        }

        //
        // Clear context fields
        //

        pAtqContext->arInfo.atqOp        = AtqIoNone;

        pAtqContext->dwSIOFlags &= ~ATQ_SIO_FLAG_STATE_MASK;

        fRes = TRUE;

        IF_DEBUG(SIO) {
            ATQ_PRINTF((DBG_CONTEXT,
                "[SIOGetCompletion(%lu)] ATQContext=%x to socket=%x\n",
                GetCurrentThreadId(),pAtqContext,pAtqContext->hAsyncIO));
        }

        // Johnson said that we should have following assert here....
        DBG_ASSERT( pAtqContext->Signature == ATQ_CONTEXT_SIGNATURE);

        //
        // Real context - check if i/o completed correctly
        //

        if ( pAtqContext->arInfo.dwLastIOError != NOERROR) {
            // Set last error again to prevent overwriting by other APIs
            SetLastError(pAtqContext->arInfo.dwLastIOError);
            fRes = FALSE;
        }

    } else {
        *lpdwBytesTransferred = 0;
        *lplpOverlapped = NULL;
        *lpdwCompletionKey = 0;
    }

    return fRes;

} // SIOGetQueuedCompletionStatus



BOOL
SIOPostCompletionStatus(
    IN  HANDLE      hExistingPort,
    IN  DWORD       dwBytesTransferred,
    IN  ULONG_PTR    dwCompletionKey,
    IN  LPOVERLAPPED    lpOverlapped
    )
/*++

Routine Description:

    Posts passed information as ATQ context to the queue of completed requests

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    PATQ_CONT   pAtqContext = (PATQ_CONT)dwCompletionKey;

    IF_DEBUG(SIO) {
        ATQ_PRINTF((DBG_CONTEXT,
           "[SIOPostCompletionStatus(%lu)] AtqCtxt=%x Bytes=%d Overlapped=%x\n ",
            GetCurrentThreadId(),
            pAtqContext,
            dwBytesTransferred,
            lpOverlapped
            ));
    }

    if ( pAtqContext != NULL ) {

        pAtqContext->arInfo.dwTotalBytesTransferred = dwBytesTransferred;
        pAtqContext->arInfo.lpOverlapped = lpOverlapped;

        if ( pAtqContext->dwSIOFlags & ATQ_SIO_FLAG_STATE_MASK) {
            ATQ_PRINTF((DBG_CONTEXT,
                   "[SIOPostCompletionStatus(%lu)] Context is inside SIO. AtqCtxt=%x SIOFlags = %x  \n ",
                    GetCurrentThreadId(),
                    pAtqContext,
                    pAtqContext->dwSIOFlags
                    ));
            ATQ_ASSERT(FALSE);
        }

        SIOLockGlobals();

        pAtqContext->dwSIOFlags &= ~ATQ_SIO_FLAG_STATE_MASK;
        pAtqContext->dwSIOFlags |= ATQ_SIO_FLAG_STATE_COMPLETED;

        //
        // This  should never happen if context is in right state.
        //

        if (pAtqContext->SIOListEntry.Flink) {

            ATQ_PRINTF((DBG_CONTEXT,
                   "[SIOPostCompletionStatus(%lu)] Context is in some other queue . AtqCtxt=%x SIOFlags = %x\n",
                    GetCurrentThreadId(),
                    pAtqContext,
                    pAtqContext->dwSIOFlags
                    ));

            ATQ_ASSERT(FALSE);
            RemoveEntryList(&pAtqContext->SIOListEntry );
        }

        InsertTailList( &g_SIOCompletedIoRequests, &pAtqContext->SIOListEntry );
    } else {

        SIOLockGlobals();
    }

    //
    // This context now counts as waiting for ATQ pool thread to pick it up
    //

    InterlockedIncrement( (PLONG)&g_AtqWaitingContextsCount );

    //
    // Wake up pool threads if they are waiting on the completion queue
    //

    ReleaseSemaphore(g_hPendingCompletionSemaphore, 1, NULL);

    SIOUnlockGlobals();

    //
    // Call internal postqueue routine for main outcoming queue
    //

    return TRUE;

}


DWORD
SIOPoolThread(
    LPDWORD param
    )
/*++

Routine Description:

    Thread routine for completion port thread
Arguments:

Return Value:


--*/
{
    ATQ_ASSERT(param != NULL);

    if (param == NULL) {
        return 0;
    }

    //
    // Cast passed parameter to pointer to completion port object and
    // invoke appropriate method
    //

    W95CPORT    *pCPort = (W95CPORT *)param;

    return pCPort->PoolThreadCallBack();

} // SIOPoolTread


/*

   Implementation of completion port class

*/


W95CPORT::W95CPORT(
    IN DWORD dwConcurrentThreads
    )
:
    m_Signature             (ATQ_SIO_CPORT_SIGNATURE),
    m_IsDestroying          (FALSE),
    m_IsThreadRunning       (0L),
    m_hThread               (INVALID_HANDLE_VALUE),
    m_fWakeupSignalled      (FALSE),
    m_scWakeup              (INVALID_SOCKET)
{
    INT err;
    SOCKADDR_IN     sockAddr;
    DWORD   i = 0;

    FD_ZERO(&m_ReadfdsStore);
    FD_ZERO(&m_WritefdsStore);

    do {

        m_scWakeup = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

        if ( m_scWakeup == INVALID_SOCKET) {
            if ( (WSAGetLastError() != WSAESOCKTNOSUPPORT)
                 || ( i > 10 ) ) {

                ATQ_PRINTF((DBG_CONTEXT,"socket creation failed with %d\n",
                    WSAGetLastError()));
                goto exit;
            }

            ATQ_PRINTF((DBG_CONTEXT,"socket failed with %d retrying...\n",
                WSAGetLastError()));
            Sleep(1000);
            i++;
        }

    } while ( m_scWakeup == INVALID_SOCKET );

    ZeroMemory(&sockAddr, sizeof(sockAddr));
    sockAddr.sin_family = AF_INET;
    sockAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    sockAddr.sin_port = htons(CPORT_WAKEUP_PORT);

    err = bind(m_scWakeup, (PSOCKADDR)&sockAddr, sizeof(sockAddr));

    if ( err == SOCKET_ERROR ) {
        ATQ_PRINTF((DBG_CONTEXT,"Error %d in bind\n", WSAGetLastError()));
        closesocket(m_scWakeup);
        m_scWakeup = INVALID_SOCKET;
    }

exit:
    //
    // Set select timeout value
    //

    INITIALIZE_CRITICAL_SECTION( &m_csLock );

} // W95CPORT::W95CPORT



W95CPORT::~W95CPORT(
                VOID
                )
{

    ATQ_PRINTF((DBG_CONTEXT,"Win95 Cport %x being freed\n", this));

    ATQ_ASSERT(m_IsDestroying);

    DeleteCriticalSection( &m_csLock );

    if ( m_scWakeup != INVALID_SOCKET ) {
        closesocket(m_scWakeup);
        m_scWakeup = INVALID_SOCKET;
    }

} // W95CPORT::~W95CPORT()


BOOL
W95CPORT::Shutdown(VOID)
{
    DWORD   dwErr;

    m_IsDestroying = TRUE;

    Wakeup();

    dwErr = WaitForSingleObject( m_hThread,100);
    CloseHandle(m_hThread);

    return TRUE;

} // W95CPORT::Shutdown(VOID)


VOID
W95CPORT::Wakeup(VOID)
{
    SOCKADDR_IN sockAddr;
    INT err;
    DWORD dwBuf = ATQ_WAKEUP_SIGNATURE;

    IF_DEBUG(SIO) {
        ATQ_PRINTF((DBG_CONTEXT,
            "[WakeUp(%lu)] Trying to signal wakeup socket=%x \n",
            GetCurrentThreadId(), m_scWakeup));
    }

    Lock( );
    if ( !m_fWakeupSignalled ) {

        sockAddr.sin_family = AF_INET;
        sockAddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
        sockAddr.sin_port = htons(CPORT_WAKEUP_PORT);

        err = sendto(
                m_scWakeup,
                (PCHAR)&dwBuf,
                sizeof(dwBuf),
                0,
                (PSOCKADDR)&sockAddr,
                sizeof(sockAddr)
                );

        if ( err == SOCKET_ERROR ) {
            ATQ_PRINTF((DBG_CONTEXT,
                "Error %d in sendto\n",WSAGetLastError()));
        } else {
            m_fWakeupSignalled = TRUE;
        }
    }
    Unlock( );

    return;

} // W95CPORT::Wakeup


DWORD
W95CPORT::PoolThreadCallBack(
            VOID
            )
/*++

Routine Description:

    This is routine, handling all events associated with socket i/o .

Arguments:

Return Value:

--*/
{

    TIMEVAL             tvTimeout;

    FD_SET              readfds;
    FD_SET              writefds;

    DWORD   dwErr = NOERROR;

    //
    // Initialize array of events for socket i/o
    //

    FD_ZERO(&m_ReadfdsStore);
    FD_ZERO(&m_WritefdsStore);

    //
    // Set select timeout value
    //

    tvTimeout.tv_sec = (SIO_THREAD_TIMEOUT*3)/100;            // 30 sec
    tvTimeout.tv_usec = 0;

    //
    // Main loop
    //

    while (!m_IsDestroying) {

        //
        // Prepare  socket arrays for select
        //

        PrepareDescriptorArrays( &readfds, &writefds);

        IF_DEBUG(SIO) {
            ATQ_PRINTF((DBG_CONTEXT,
               "[SIOThread(%lu)]Before select: Readcnt=%d WriteCnt=%d \n",
                GetCurrentThreadId(), readfds.fd_count, writefds.fd_count
                ));
        }

        //
        // Wait for first completed i/o or timeout
        //

        dwErr = select(0,&readfds,&writefds,NULL,&tvTimeout);

        //
        // If we are shutting down - stop processing and exit
        //

        if (m_IsDestroying) {
            break;
        }

        //
        // Figure out what triggered an event and act accordingly
        //

        if (SOCKET_ERROR == dwErr ) {

            DWORD   dwLastErr = WSAGetLastError();

            //
            // if we get WSANOTINITIALISED, then either something bad
            // happened or we are being cleaned up
            //

            if ( dwLastErr == WSANOTINITIALISED ) {
                ATQ_PRINTF((DBG_CONTEXT,
                    "SIO_Thread: select detects shutdown\n"));
                break;
            }

            //
            // Select failed - most probably because wakeup socket was closed
            // after we checked for it but before calling select. If this is the case
            // just continuing will be the right thing.
            //

            ATQ_PRINTF((DBG_CONTEXT,
                "SIO_Thread: Select failed with %d\n", dwLastErr));

            //
            // Select failed , we need to go through list of sockets currently set up
            // and remove those , which do not have associated ATQ contexts.
            // That will happen if another thread removed context and closed socket
            // when we were busy processing completion. In this case socket handle is
            // already invalid when we came to select.

            CleanupDescriptorList();

        } else if (0L == dwErr) {

            //ATQ_PRINTF((DBG_CONTEXT,"select timed out\n"));
            CleanupDescriptorList();

        } else {

            //
            // This is socket completion. Walk all out sets and for each signalled socket
            // process it's completion
            //

            ProcessSocketCompletion(dwErr, &readfds, &writefds);
        }
    }

    ATQ_PRINTF((DBG_CONTEXT,"Exiting SIOPoolThread\n"));
    return 0;

} // SIOPoolTread




BOOL
W95CPORT::PrepareDescriptorArrays(
                IN PFD_SET  ReadFds,
                IN PFD_SET  WriteFds
                )
/*++

Routine Description:

    Prepares sockets array for select call.

    Nb: Object is not locked when arrays are processed, so if any other method will
    be modifying arrays directly , locking should become more agressive. Global
    critical section is taken when checking incoming queue.

Arguments:

Return Value:

--*/
{

    PATQ_CONT   pAtqContext = NULL;

    FD_ZERO(ReadFds);
    FD_ZERO(WriteFds);

    //
    // We should remove as many as possible from incoming
    // queue, because if semaphore signalled but there were not
    // free event handles available, we will leave incoming request
    // in the queue.
    //

    BOOL        fReadRequest;

    PLIST_ENTRY listEntry;
    PLIST_ENTRY nextEntry;

    SIOLockGlobals();

    for ( listEntry  = g_SIOIncomingRequests.Flink;
          listEntry != &g_SIOIncomingRequests;
          listEntry  = nextEntry ) {

        nextEntry = listEntry->Flink;

        pAtqContext = CONTAINING_RECORD(
                                listEntry,
                                ATQ_CONTEXT,
                                SIOListEntry );

        //
        // Is this valid new context for completion port. if not skip it
        //

        if(!SIOCheckContext((PATQ_CONTEXT)pAtqContext,FALSE)) {
            continue;
        }

        fReadRequest = (pAtqContext->arInfo.atqOp == AtqIoRead) ;

        if ( ( fReadRequest && (m_ReadfdsStore.fd_count >= (FD_SETSIZE-1) )) ||
             (!fReadRequest && (m_WritefdsStore.fd_count >= FD_SETSIZE))) {

            //
            // Skip this context as appropriate array is full
            //

            ATQ_PRINTF((DBG_CONTEXT,"Full array!\n"));
            continue;
        }

        //
        // Add socket to appropriate queue
        //

        IF_DEBUG(SIO) {
            ATQ_PRINTF((DBG_CONTEXT,
               "[SIOPrepareArray(%lu)] Received  i/o request context=%x to socket=%x I/O OpCode=%d .\n",
                GetCurrentThreadId(),
                pAtqContext,
                pAtqContext->hAsyncIO,
                pAtqContext->arInfo.atqOp));
        }

        if((pAtqContext->dwSIOFlags & ATQ_SIO_FLAG_STATE_MASK) != ATQ_SIO_FLAG_STATE_INCOMING) {

            ATQ_PRINTF((DBG_CONTEXT,
                   "[SIO: PDA (%lu)] Not in incoming state AtqCtxt=%x SIOFlags = %x  \n ",
                    GetCurrentThreadId(),
                    pAtqContext,
                    pAtqContext->dwSIOFlags
                    ));
            ATQ_ASSERT(FALSE);
        }

        //
        // Remove context from incoming queue
        //

        RemoveEntryList(listEntry);
        listEntry->Flink = listEntry->Blink = NULL;

        pAtqContext->dwSIOFlags &= ~ATQ_SIO_FLAG_STATE_MASK;
        pAtqContext->dwSIOFlags |= ATQ_SIO_FLAG_STATE_WAITING;

        //
        // Indicate socket as waiting for the ready state
        //

        switch (pAtqContext->arInfo.atqOp) {
            case AtqIoRead:
                FD_SET(HANDLE_TO_SOCKET(pAtqContext->hAsyncIO),&m_ReadfdsStore);
                break;

            case AtqIoWrite:
            case AtqIoXmitFile:
                FD_SET(HANDLE_TO_SOCKET(pAtqContext->hAsyncIO),&m_WritefdsStore);
                break;

            default:
                ATQ_PRINTF((DBG_CONTEXT,
                       "[PrepareDescriptors(%lu)] Context=%x has invalid type of IO op\n",
                        GetCurrentThreadId(),pAtqContext));
                break;
        }
    }

    SIOUnlockGlobals();

    CopyMemory( ReadFds, &m_ReadfdsStore, sizeof(fd_set));
    CopyMemory( WriteFds, &m_WritefdsStore, sizeof(fd_set));

    //
    // Add wakeup socket to read list
    //

    FD_SET(m_scWakeup,ReadFds);

    IF_DEBUG(SIO) {
        ATQ_PRINTF((DBG_CONTEXT,"[SIOPrepareArray Added Wakeup socket=%x ReadCount=%d WriteCOunt=%d \n",
                m_scWakeup,ReadFds->fd_count,WriteFds->fd_count));
    }

    return TRUE;

} // W95CPORT::PrepareDescriptorArrays



BOOL
W95CPORT::ProcessSocketCompletion(
    IN DWORD dwCompletedCount,
    IN PFD_SET  ReadFds,
    IN PFD_SET  WriteFds
    )
/*++

Routine Description:

    Handling i/o completion for sockets in select descriptor array

Arguments:

Return Value:

--*/
{
    UINT    Count;
    UINT    i = 0;
    INT     dwErr;
    DWORD   cbBytesTransferred;
    DWORD   nBytes;

    PFD_SET pCurrentSet = ReadFds;
    PFD_SET pCurrentStoreSet = &m_ReadfdsStore;

    ATQ_ASSERT(dwCompletedCount == (ReadFds->fd_count + WriteFds->fd_count));

    //
    // First process read set,then write set
    //

    for (i=0;i<2;i++) {

        //
        // Walk through completed sockets in current descriptor set
        //

        for (Count=0;Count < pCurrentSet->fd_count;Count++) {

            PATQ_CONT   pAtqContext = NULL;

            //
            // If this is wakeup socket - skip iteration
            //

            if ((pCurrentSet == ReadFds) &&
                (m_scWakeup == pCurrentSet->fd_array[Count]) ) {

                DWORD dwBuf;
                INT err;

                Lock( );

                ATQ_ASSERT(m_fWakeupSignalled);

                err = recvfrom(
                            m_scWakeup,
                            (PCHAR)&dwBuf,
                            sizeof(dwBuf),
                            0,
                            NULL,
                            NULL
                            );

                if ( err == SOCKET_ERROR ) {
                    ATQ_PRINTF((DBG_CONTEXT,
                        "Error %d in recvfrom\n", WSAGetLastError()));
                } else {
                    ATQ_ASSERT(dwBuf == ATQ_WAKEUP_SIGNATURE);
                }

                m_fWakeupSignalled = FALSE;
                Unlock( );

                continue;
            }

            //
            // Find ATQ context associated with signaled socket
            //

            pAtqContext = FindATQContextFromSocket(
                                        pCurrentSet->fd_array[Count]
                                        );

            ATQ_ASSERT(pAtqContext != NULL);

            if (pAtqContext == NULL) {

                //
                // Did not locate context - go to next one, most probably
                // we are shutting down. In any case remove this socket from
                // stored list, as there is no use in it
                //

                FD_CLR(pCurrentSet->fd_array[Count],pCurrentStoreSet);

                //
                // Socket should be really closed do we need to close
                // it again ?

                closesocket(pCurrentSet->fd_array[Count]);
                continue;
            }

            IF_DEBUG(SIO) {
                ATQ_PRINTF((DBG_CONTEXT,
                   "[ProcessCompletion(%lu)] Completion signal AtqCtxt=%x Socket=%x I/O OpCode=%d SioFlags=%x  \n ",
                    GetCurrentThreadId(),
                    pAtqContext,
                    pAtqContext->hAsyncIO,
                    pAtqContext->arInfo.atqOp,
                    pAtqContext->dwSIOFlags
                    ));
            }

            //
            // Is context in right state
            //

            if( (pAtqContext->dwSIOFlags & ATQ_SIO_FLAG_STATE_MASK) !=
                    ATQ_SIO_FLAG_STATE_WAITING ) {

                dwErr = SOCKET_ERROR;
                WSASetLastError(WSAECONNABORTED);
                ATQ_PRINTF((DBG_CONTEXT,"AtqContext %x has invalid state %x\n",
                    pAtqContext, pAtqContext->dwSIOFlags));
                pAtqContext->Print();
                ATQ_ASSERT(FALSE);

            } else {

                //
                // Perform selected i/o operation on ready socket
                //

                nBytes = 0;
                switch(pAtqContext->arInfo.atqOp ) {

                case AtqIoRead: {

                        DWORD dwFlags = 0;
                        LPWSABUF  pBuf =
                                pAtqContext->arInfo.uop.opReadWrite.pBufAll;

                        dwErr = WSARecv(
                                pCurrentSet->fd_array[Count],
                                pBuf,
                                pAtqContext->arInfo.uop.opReadWrite.dwBufferCount,
                                &nBytes,
                                &dwFlags,
                                NULL,       // no lpo
                                NULL
                                );

                        if ( (dwErr != SOCKET_ERROR) ||
                             (WSAGetLastError() != WSAEWOULDBLOCK) ) {

                            if ( pBuf != &pAtqContext->arInfo.uop.opReadWrite.buf1 ) {
                                LocalFree(pBuf);
                            }

                            pAtqContext->arInfo.uop.opReadWrite.pBufAll = NULL;
                        }
                    }

                    break;

                case AtqIoWrite: {

                        LPWSABUF  pBuf =
                                pAtqContext->arInfo.uop.opReadWrite.pBufAll;

                        dwErr = WSASend(
                                pCurrentSet->fd_array[Count],
                                pBuf,
                                pAtqContext->arInfo.uop.opReadWrite.dwBufferCount,
                                &nBytes,
                                0,      // no flags
                                NULL,   // no lpo
                                NULL
                                );

                        if ( (dwErr != SOCKET_ERROR) ||
                             (WSAGetLastError() != WSAEWOULDBLOCK) ) {

                            if ( pBuf != &pAtqContext->arInfo.uop.opReadWrite.buf1 ) {
                                LocalFree(pBuf);
                            }

                            pAtqContext->arInfo.uop.opReadWrite.pBufAll = NULL;

                            if ( pAtqContext->arInfo.uop.opReadWrite.pWin95CopyBuffer != NULL ) {
                                LocalFree(pAtqContext->arInfo.uop.opReadWrite.pWin95CopyBuffer);

                                pAtqContext->arInfo.uop.opReadWrite.pWin95CopyBuffer = NULL;
                            }
                        }
                    }
                    break;

                case AtqIoXmitFile: {

                        DWORD cbWritten = 0;
                        WSABUF wsaBuf = {
                            pAtqContext->arInfo.uop.opFakeXmit.cbBuffer,
                            (PCHAR)pAtqContext->arInfo.uop.opFakeXmit.pvLastSent
                            };

                        dwErr = WSASend(
                                pCurrentSet->fd_array[Count],
                                &wsaBuf,
                                1,
                                &nBytes,
                                0,      // no flags
                                NULL,   // no lpo
                                NULL
                                );
                    }
                    break;

                default:

                    dwErr = SOCKET_ERROR;
                    WSASetLastError(WSAECONNABORTED);

                    ATQ_PRINTF((DBG_CONTEXT,
                           "[ProcessCompletion(%lu)] Context=%x has invalid type of IO op[%x]\n",
                            GetCurrentThreadId(),pAtqContext,
                            pAtqContext->arInfo.atqOp));
                    DBG_ASSERT(FALSE);
                    break;
                }
            }

            //
            // Set the last error code in context
            //

            if (SOCKET_ERROR == dwErr) {

                pAtqContext->arInfo.dwLastIOError = WSAGetLastError();

                //
                // If this operation would be blocked - retry it again
                //

                if ( WSAEWOULDBLOCK == pAtqContext->arInfo.dwLastIOError) {
                    continue;
                }

                ATQ_PRINTF((DBG_CONTEXT,
                        "Error %d in socket operation[%d]\n",
                        WSAGetLastError(),
                        pAtqContext->arInfo.atqOp
                        ));

                cbBytesTransferred = 0;
            } else {

                IF_DEBUG(SIO) {
                    ATQ_PRINTF((DBG_CONTEXT,
                        "SIO operation[%d] returns %d bytes\n",
                        pAtqContext->arInfo.atqOp,
                        nBytes));
                }

                pAtqContext->arInfo.dwLastIOError = NOERROR;
                cbBytesTransferred = nBytes;
            }

            //
            // Set parameters in ATQ context I/O request block
            //

            pAtqContext->arInfo.dwTotalBytesTransferred = cbBytesTransferred;

            //
            // Clean up SIO state
            //

            pAtqContext->dwSIOFlags &= ~ATQ_SIO_FLAG_STATE_MASK;

            //
            // Queue this context to completed queue
            //

            SIOPostCompletionStatus((HANDLE)this,
                                    cbBytesTransferred,
                                    (ULONG_PTR)pAtqContext,
                                    pAtqContext->arInfo.lpOverlapped
                                    );

            //
            // Remove socket from the set where it is now
            //

            FD_CLR(pCurrentSet->fd_array[Count],pCurrentStoreSet);
        }

        pCurrentSet = WriteFds;
        pCurrentStoreSet = &m_WritefdsStore;
    }

    return TRUE;

} // ProcessSocketCompletion


VOID
W95CPORT::CleanupDescriptorList(
    VOID
    )
/*++

Routine Description:

    Prepares sockets array for select call.

Arguments:

Return Value:

--*/
{
    UINT    i = 0;
    UINT    Count;

    int     sErr;
    int     iSocketType ;
    int     iOptLen = sizeof(iSocketType);

    PFD_SET pCurrentStoreSet = &m_ReadfdsStore;
    FD_SET  fdsMarked;

    //
    // First process read set,then write set
    //

    for (i=0;i<2;i++) {

        FD_ZERO(&fdsMarked);

        //
        // Walk scheduled sockets in current descriptor set
        //

        for (Count=0;Count < pCurrentStoreSet->fd_count;Count++) {

            PATQ_CONT   pAtqContext = NULL;

            //
            // If this is wakeup socket - skip iteration
            //

            if ((m_scWakeup == pCurrentStoreSet->fd_array[Count]) &&
                (pCurrentStoreSet == &m_ReadfdsStore) ) {

                continue;
            }

            //
            // Find ATQ context associated with signalled socket
            //

            pAtqContext = FindATQContextFromSocket(
                                    pCurrentStoreSet->fd_array[Count]
                                    );

            if ( pAtqContext == NULL ) {

                //
                // Did not locate context - remove socket from the set where it is now
                // Socket should be really closed do we need to close  it again ?
                //

                ATQ_PRINTF((DBG_CONTEXT,
                       "[CleanupDLists(%lu)] Context not found for socket=%x.Cleaning record\n",
                        GetCurrentThreadId(),pCurrentStoreSet->fd_array[Count]));

                FD_SET(pCurrentStoreSet->fd_array[Count],&fdsMarked);
                closesocket(pCurrentStoreSet->fd_array[Count]);

            } else {

                //
                // Found ATQ context, validate if socket handle is still valid.
                // Reason for this check is that it is possible that socket will be closed by one
                // thread , while "select" pump thread is not waiting on select. It would be better
                // to communicate this event by using thread message , for now we just use
                // more brute force approach. If socked handle is not valid after select failed
                // with NOSOCKET error code, we signal i/o completion failure for this context and
                // remove socket from waiting list
                //

                sErr = getsockopt(pCurrentStoreSet->fd_array[Count],
                                  SOL_SOCKET,
                                  SO_TYPE,
                                  (char *)&iSocketType,&iOptLen);

                if (sErr != NO_ERROR) {

                    ATQ_PRINTF((DBG_CONTEXT,"Error %d in getsockopt[s %d]\n",
                        WSAGetLastError(),
                        pCurrentStoreSet->fd_array[Count]));

                    //
                    // Found invalid socket in store list, signal it's context with failure
                    // error code
                    //
                    // Set parameters in ATQ context I/O request block
                    //

                    pAtqContext->arInfo.dwTotalBytesTransferred = 0;

                    pAtqContext->arInfo.dwLastIOError = ERROR_OPERATION_ABORTED;

                    //
                    // Clean up SIO state
                    //

                    pAtqContext->dwSIOFlags &= ~ATQ_SIO_FLAG_STATE_MASK;

                    //
                    // Queue this context to completed queue
                    //

                    SIOPostCompletionStatus((HANDLE)this,
                                            0,
                                            (ULONG_PTR)pAtqContext,
                                            pAtqContext->arInfo.lpOverlapped
                                            );

                    //
                    // Remove socket from the set where it is now
                    //

                    FD_SET(pCurrentStoreSet->fd_array[Count],&fdsMarked);

                }
            }
        }

        //
        // Now remove all sockets marked from current set
        //

        for (Count=0;Count < fdsMarked.fd_count;Count++) {
            FD_CLR(fdsMarked.fd_array[Count],pCurrentStoreSet);
        }

        pCurrentStoreSet = &m_WritefdsStore;
    }

} // W95CPORT::CleanupDescriptorList



BOOL
W95CPORT::SIOCheckCompletionThreadStatus(
    VOID
    )
/*++

Routine Description:

    This routine makes sure there is at least one thread in
    the thread pool.

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    BOOL    fRet = TRUE;

    //
    //  If no threads are available, kick a new one off up to the limit
    //

    if (!InterlockedExchange(&m_IsThreadRunning,1)) {

        DWORD dwId;

        ATQ_PRINTF((DBG_CONTEXT,"Starting a new SIO Pool Thread\n"));

        m_hThread = CreateThread(
                                NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)SIOPoolThread,
                                this,
                                0,
                                &dwId
                                );

        if ( !m_hThread ) {
            fRet = FALSE;
        }
    }

    return fRet;

} // SIOCheckCompletionThreadStatus()


BOOL
SIOWSARecv(
    IN PATQ_CONT    pContext,
    IN LPWSABUF     pwsaBuffers,
    IN DWORD        dwBufferCount,
    IN OVERLAPPED * lpo OPTIONAL
    )
/*++

Routine Description:

    This routine does WSARecv+fake completion port

Arguments:
    pContext - pointer to ATQ context
    lpBuffer - Buffer to put read data in
    BytesToRead - number of bytes to read
    lpo - Overlapped structure to use

Return Value:
    TRUE on success and FALSE if there is a failure.

--*/
{
    pContext->arInfo.atqOp = AtqIoRead;
    pContext->arInfo.lpOverlapped = lpo;
    pContext->arInfo.uop.opReadWrite.dwBufferCount = dwBufferCount;

    if ( dwBufferCount == 1) {
        pContext->arInfo.uop.opReadWrite.buf1.len = pwsaBuffers->len;
        pContext->arInfo.uop.opReadWrite.buf1.buf = pwsaBuffers->buf;
        pContext->arInfo.uop.opReadWrite.pBufAll  =
            &pContext->arInfo.uop.opReadWrite.buf1;

    } else {

        DBG_ASSERT( dwBufferCount > 1);

        WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwBufferCount * sizeof (WSABUF));

        if ( pBuf != NULL) {

            pContext->arInfo.uop.opReadWrite.pBufAll = pBuf;
            CopyMemory( pBuf, pwsaBuffers,
                        dwBufferCount * sizeof(WSABUF));
        } else {
            ATQ_PRINTF((DBG_CONTEXT,
                "Failed to allocate buffer[%d] for WSARecv\n",
                dwBufferCount));
            return ( FALSE);
        }
    }

    return(SIOStartAsyncOperation(
                        g_hCompPort,
                        (PATQ_CONTEXT)pContext
                        ));

} // SIOWSARecv


BOOL
SIOWSASend(
    IN PATQ_CONT    pContext,
    IN LPWSABUF     pwsaBuffers,
    IN DWORD        dwBufferCount,
    IN OVERLAPPED * lpo OPTIONAL
    )
/*++

Routine Description:

    This routine does WSASend+fake completion port

Arguments:
    pContext - pointer to ATQ context
    lpBuffer - Buffer to put read data in
    BytesToRead - number of bytes to read
    lpo - Overlapped structure to use

Return Value:
    TRUE on success and FALSE if there is a failure.

--*/
{
    pContext->arInfo.atqOp = AtqIoWrite;
    pContext->arInfo.lpOverlapped = lpo;
    pContext->arInfo.uop.opReadWrite.dwBufferCount = dwBufferCount;
    pContext->arInfo.uop.opReadWrite.pWin95CopyBuffer = NULL;

    if ( dwBufferCount == 1) {

        pContext->arInfo.uop.opReadWrite.buf1.len = pwsaBuffers->len;
        pContext->arInfo.uop.opReadWrite.buf1.buf = pwsaBuffers->buf;
        pContext->arInfo.uop.opReadWrite.pBufAll  =
            &pContext->arInfo.uop.opReadWrite.buf1;

        if ( (pwsaBuffers->len > 0) && IsBadWritePtr(pwsaBuffers->buf, 1) ) {

            ATQ_PRINTF((DBG_CONTEXT,"cport: Bad ptr %x\n", pwsaBuffers->buf));

            //
            // try to allocate a temp buffer.  This is a workaround for a
            // win95 bug where .text pages are erroneosly being marked
            // dirty.  If allocation failed, try our luck with the old
            // path.
            //

            pContext->arInfo.uop.opReadWrite.pWin95CopyBuffer =
                (PCHAR)LocalAlloc(LMEM_FIXED, pwsaBuffers->len);

            if ( pContext->arInfo.uop.opReadWrite.pWin95CopyBuffer != NULL ) {

                CopyMemory(
                    pContext->arInfo.uop.opReadWrite.pWin95CopyBuffer,
                    pwsaBuffers->buf,
                    pwsaBuffers->len
                    );

                pContext->arInfo.uop.opReadWrite.buf1.buf =
                    pContext->arInfo.uop.opReadWrite.pWin95CopyBuffer;
            } else {

                ATQ_PRINTF((DBG_CONTEXT,
                    "WSASend: Unable to allocate copy buffer [err %d]\n",
                    GetLastError()));
            }
        }

    } else {
        DBG_ASSERT( dwBufferCount > 1);

        WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwBufferCount * sizeof (WSABUF));

        if ( pBuf != NULL) {
            pContext->arInfo.uop.opReadWrite.pBufAll = pBuf;
            CopyMemory( pBuf, pwsaBuffers,
                        dwBufferCount * sizeof(WSABUF));

        } else {
            ATQ_PRINTF((DBG_CONTEXT,
                "Failed to allocate buffer[%d] for WSARecv\n",
                dwBufferCount));
            return ( FALSE);
        }
    }

    return(SIOStartAsyncOperation(
                        g_hCompPort,
                        (PATQ_CONTEXT)pContext
                        ));

} // SIOWSASend

/************************************************************
*  Private functions.
************************************************************/

PATQ_CONT
SIO_Private_GetQueuedContext(
    IN PLIST_ENTRY pQueue
    )
{

    PATQ_CONT   pAtqContext = NULL;
    PLIST_ENTRY pEntry;

    //
    // We may have something in the queue
    //

    SIOLockGlobals();

    //
    // Remove first event from queue
    //

    if ( !IsListEmpty(pQueue)) {

        pEntry = RemoveHeadList( pQueue );
        pAtqContext = CONTAINING_RECORD(
                                pEntry,
                                ATQ_CONTEXT,
                                SIOListEntry
                                );

        pEntry->Flink = pEntry->Blink = NULL;
    }

    SIOUnlockGlobals();

    return pAtqContext;
} // SIO_Private_GetQueuedContext


BOOL
SIOCheckContext(
    IN  PATQ_CONTEXT pAtqC,
    IN  BOOL         fNew       /* = TRUE */
    )
/*++

Routine Description:

   Tries to validate that context can enter completion port.
   If context is already in, signal error condition.

Arguments:

    patqContext - pointer to ATQ context

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{

    PATQ_CONT   pAtqContext = (PATQ_CONT)pAtqC;

    if (!pAtqC || !pAtqC->hAsyncIO) {
        return TRUE;
    }

    if (fNew) {

        //
        // Verify this context is not in SIO yet
        //

        if (( pAtqContext->dwSIOFlags & ATQ_SIO_FLAG_STATE_MASK) ||
            (pAtqContext->SIOListEntry.Flink)) {

            ATQ_PRINTF((DBG_CONTEXT,
                   "[SIOCheckContext(%lu)] Context is already in SIO state = %x  \n ",
                    GetCurrentThreadId(),
                    pAtqContext->dwSIOFlags
                    ));
            ATQ_ASSERT(FALSE);
            return FALSE;
        }

    } else {

        if ( (pAtqContext->dwSIOFlags & ATQ_SIO_FLAG_STATE_MASK) == 0 ) {

            ATQ_PRINTF((DBG_CONTEXT,
                   "[SIOCheckContext(%lu)] Context is not in SIO state = %x while should be\n ",
                    GetCurrentThreadId(),
                    pAtqContext->dwSIOFlags
                    ));
            ATQ_ASSERT(FALSE);
            return FALSE;
        }
    }

    return TRUE;
} // SIOCheckContext


PATQ_CONT
FindATQContextFromSocket(
    SOCKET          sc
    )
{
    LIST_ENTRY * pentry;
    PATQ_CONT   pAtqContext;
    DWORD   FakeSocket = (DWORD)sc | 0x80000000;

    //
    // If socket is obviously invalid - fail
    //

    if (!sc) {

        ATQ_PRINTF((DBG_CONTEXT,"Invalid socket[%d] on find\n",
            sc));
        return NULL;
    }

    ATQ_ASSERT(g_dwNumContextLists == ATQ_NUM_CONTEXT_LIST_W95);

    AtqActiveContextList[0].Lock( );

    for ( pentry  = AtqActiveContextList[0].ActiveListHead.Flink;
          pentry != &AtqActiveContextList[0].ActiveListHead;
          pentry  = pentry->Flink )
    {

        pAtqContext = CONTAINING_RECORD(
                                    pentry,
                                    ATQ_CONTEXT,
                                    m_leTimeout );

        if ( pAtqContext->Signature != ATQ_CONTEXT_SIGNATURE ) {

            ATQ_PRINTF((DBG_CONTEXT,"Invalid signature[%x] on context %x\n",
                pAtqContext->Signature, pAtqContext));

            ATQ_ASSERT( pAtqContext->Signature == ATQ_CONTEXT_SIGNATURE );
            break;
        }

        if ( (SOCKET_TO_HANDLE(sc) == pAtqContext->hAsyncIO)

                            ||

             ((pAtqContext->hJraAsyncIO == FakeSocket) &&
              (pAtqContext->arInfo.atqOp != 0)) ) {

            //
            // We found our context
            //

            if ( SOCKET_TO_HANDLE(sc) != pAtqContext->hAsyncIO ) {
                ATQ_PRINTF((DBG_CONTEXT,
                        "Processing leftover context %x[op %x][sock %d]\n",
                            pAtqContext,
                            pAtqContext->arInfo.atqOp,
                            sc));

                pAtqContext->hJraAsyncIO = 0;

            }

            AtqActiveContextList[0].Unlock( );

            IF_DEBUG(SIO) {
                ATQ_PRINTF((DBG_CONTEXT,
                    "Found atq context %x[%x]\n", pAtqContext, sc));
            }
            return pAtqContext;
        }
    }

    AtqActiveContextList[0].Unlock( );

    IF_DEBUG(SIO) {
        ATQ_PRINTF((DBG_CONTEXT,
            "Cannot find atq context for socket %d\n", sc));
    }
    return NULL;

} // FindATQContextFromSocket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\atqmain.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      atqmain.cxx

   Abstract:
      This module implements entry points for ATQ - Asynchronous Thread Queue.

   Author:

       Murali R. Krishnan    ( MuraliK )     8-Apr-1996

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Common DLL

   Functions Exported:

       BOOL  AtqInitialize();
       BOOL  AtqTerminate();
       BOOL  AtqGetCompletionPort();

       DWORD AtqSetInfo();
       DWORD AtqGetInfo();
       BOOL  AtqGetStatistics();
       BOOL  AtqClearStatistics();

       BOOL  AtqAddAcceptExSockets();
       BOOL  AtqAddAsyncHandle();
       DWORD AtqContextSetInfo();
       VOID  AtqCloseSocket();
       VOID  AtqFreeContext();

       BOOL  AtqReadFile();
       BOOL  AtqWriteFile();
       BOOL  AtqTransmitFile();
       BOOL  AtqPostCompletionStatus();

       PVOID AtqAllocateBandwidthInfo();
       BOOL  AtqFreeBandwidthInfo();
       DWORD AtqBandwidthSetInfo();
--*/

#include "isatq.hxx"
#include <iscaptrc.h>

# define ATQ_REG_DEF_THREAD_TIMEOUT_PWS    (30*60)  // 30 minutes

/************************************************************
 * Globals
 ************************************************************/

//
// specifies the registry location to use for getting the ATQ Configuration
//   (Global overrides)
//
CHAR g_PSZ_ATQ_CONFIG_PARAMS_REG_KEY[] =
 TEXT("System\\CurrentControlSet\\Services\\InetInfo\\Parameters");

// ----------------------------------------
// # of CPUs in machine (for thread-tuning)
// ----------------------------------------

DWORD g_cCPU = 0;

//
// concurrent # of threads to run per processor
//

DWORD g_cConcurrency = ATQ_REG_DEF_PER_PROCESSOR_CONCURRENCY;

//
//  Amount of time (in ms) a worker thread will be idle before suicide
//

DWORD g_msThreadTimeout = ATQ_REG_DEF_THREAD_TIMEOUT * 1000;

BOOL  g_fUseAcceptEx = TRUE;    // Use AcceptEx if available

//
// The absolute thread limit
//

LONG   g_cMaxThreadLimit = ATQ_REG_DEF_POOL_THREAD_LIMIT;

//
// Should we use fake completion port
//

BOOL g_fUseFakeCompletionPort =  FALSE;

//
// Assumed minimum file transfer rate
//

DWORD g_cbMinKbSec = ATQ_REG_DEF_MIN_KB_SEC;

//
// Size of buffers for fake xmits
//

DWORD g_cbXmitBufferSize = ATQ_REG_DEF_NONTF_BUFFER_SIZE;

//
// number of active context list
//

DWORD g_dwNumContextLists = ATQ_NUM_CONTEXT_LIST;

/*
   g_pfnExitThreadCallback()
    This routine sets the callback routine to be called when one of the
    Atq threads exit so that thread state data can be cleaned up. Currently
    support is for a single routine. One way to support multiple routines would
    be for the caller to save the return value. Such an application would not
    be able to delete the "saved" callback routine.
 */
ATQ_THREAD_EXIT_CALLBACK g_pfnExitThreadCallback = NULL;

// ----------------------------------
// Fake Completion port
// -----------------------------------
//
// Used to gauge pool thread creation. This variable shows number of
// ATQ contexts // ready to be processed by ATQ pool thread. Basically
// this is length of outcoming queue in SIO module and is modified by
// routines there
//

DWORD   g_AtqWaitingContextsCount = 0;

//
// mswsock entry points
//

HINSTANCE g_hMSWsock = NULL;
PFN_ACCEPTEX g_pfnAcceptEx = NULL;
PFN_GETACCEPTEXSOCKADDRS g_pfnGetAcceptExSockaddrs = NULL;
PFN_TRANSMITFILE g_pfnTransmitFile = NULL;
PFN_GET_QUEUED_COMPLETION_STATUS g_pfnGetQueuedCompletionStatus = NULL;
PFN_CREATE_COMPLETION_PORT g_pfnCreateCompletionPort = NULL;
PFN_CLOSE_COMPLETION_PORT  g_pfnCloseCompletionPort = NULL;
PFN_POST_COMPLETION_STATUS g_pfnPostCompletionStatus = NULL;

HINSTANCE   g_hNtdll = NULL;
PFN_RTL_INIT_UNICODE_STRING g_pfnRtlInitUnicodeString = NULL;
PFN_NT_LOAD_DRIVER          g_pfnNtLoadDriver = NULL;
PFN_RTL_NTSTATUS_TO_DOSERR  g_pfnRtlNtStatusToDosError = NULL;
PFN_RTL_INIT_ANSI_STRING    g_pfnRtlInitAnsiString = NULL;
PFN_RTL_ANSI_STRING_TO_UNICODE_STRING g_pfnRtlAnsiStringToUnicodeString = NULL;
PFN_RTL_DOS_PATHNAME_TO_NT_PATHNAME g_pfnRtlDosPathNameToNtPathName_U = NULL;
PFN_RTL_FREE_HEAP g_pfnRtlFreeHeap = NULL;

//
// NT specific
//

PFN_READ_DIR_CHANGES_W g_pfnReadDirChangesW = NULL;

// ------------------------------
// Current State Information
// ------------------------------


HANDLE  g_hCompPort = NULL;      // Handle for completion port
LONG    g_cThreads = 0;          // number of thread in the pool
LONG    g_cAvailableThreads = 0; // # of threads waiting on the port.

//
// Is the NTS driver in use
//

BOOL    g_fUseDriver = FALSE;

//
// Should we use the TF_USE_KERNEL_APC flag for TransmitFile
//

BOOL    g_fUseKernelApc = ATQ_REG_DEF_USE_KERNEL_APC;

//
// Current thread limit
//

LONG    g_cMaxThreads = ATQ_REG_DEF_PER_PROCESSOR_ATQ_THREADS;

DWORD   g_cListenBacklog = ATQ_REG_DEF_LISTEN_BACKLOG;

BOOL    g_fShutdown = FALSE;   // if set, indicates that we are shutting down
                               // in that case, all threads should exit.

HANDLE  g_hShutdownEvent = NULL; // set when all running threads shutdown

BOOL    g_fEnableDebugThreads = FALSE;  // if TRUE, debug IO threads can be
                                       // created

BOOL    g_fCreateDebugThread = FALSE;  // set to TRUE to create a debug thread

// ------------------------------
// Bandwidth Throttling Info
// ------------------------------

PBANDWIDTH_INFO     g_pBandwidthInfo = NULL;

// ------------------------------
// Various State/Object Lists
// ------------------------------

//
// Used to switch context between lists
//

DWORD AtqGlobalContextCount = 0;

//
// List of active context
//

ATQ_CONTEXT_LISTHEAD AtqActiveContextList[ATQ_NUM_CONTEXT_LIST];

//
// List of Endpoints in ATQ - one per listen socket
//

LIST_ENTRY AtqEndpointList;
CRITICAL_SECTION AtqEndpointLock;

PALLOC_CACHE_HANDLER  g_pachAtqContexts;

#ifdef IIS_AUX_COUNTERS

LONG g_AuxCounters[NUM_AUX_COUNTERS];

#endif // IIS_AUX_COUNTERS

//
// Timeout before closing pending listens in case backlog is full
//

DWORD g_cForceTimeout;

//
// Flag enabling/disabling the backlog monitor
//

BOOL g_fDisableBacklogMonitor = FALSE;

// ------------------------------
// local to this module
// ------------------------------

LONG  sg_AtqInitializeCount = -1;
BOOL  g_fSpudInitialized = FALSE;
HANDLE g_hCapThread = NULL;

DWORD
I_AtqGetGlobalConfiguration(VOID);

DWORD
I_NumAtqEndpointsOpen(VOID);

DWORD 
AtqDebugCreatorThread(
    LPDWORD                 param
);

//
// Capacity Planning variables
//

extern TRACEHANDLE      IISCapTraceRegistrationHandle;

//
// Ensure that initialization/termination don't happen at the same time
//

CRITICAL_SECTION        g_csInitTermLock;

/************************************************************
 * Functions
 ************************************************************/

BOOL
AtqInitialize(
    IN DWORD   dwFlags
    )
/*++
Routine Description:

    Initializes the ATQ package

Arguments:
    dwFlags - DWORD containing the flags for use to initialize ATQ library.
    Notably in many cases one may not need the SPUD driver initialized
      for processes other than the IIS main process. This dword helps
      to shut off the unwanted flags.

    This is an ugly way to initialize/shutdown SPUD, but that is what we
    will do. SPUD supports only ONE completion port and hence when we use
    ATQ in multiple processes we should be careful to initialize SPUD only
    once and hopefully in the IIS main process!

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

Note:
    As of 4/16/97 the pszRegKey that is sent is no more utilized.
    We always load the internal configuration parameters from
     one single registry entry specified by PSZ_ATQ_CONFIG_PARAMS_REG_KEY
    The parameter is left in the command line for compatibility
      with old callers :( - NYI: Need to change this.
--*/
{
    DWORD       i;
    DWORD       dwThreadID;

    DBGPRINTF(( DBG_CONTEXT, "AtqInitialize, %d, %x\n",
                sg_AtqInitializeCount, dwFlags));

    if ( InterlockedIncrement( &sg_AtqInitializeCount) != 0) {

        IF_DEBUG( API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqInitialize( %08x). ATQ is already initialized.\n",
                         dwFlags));
        }

        //
        // we are already initialized. Ignore the new registry settings
        //

        return ( TRUE);
    }
    
    EnterCriticalSection( &g_csInitTermLock );

    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqInitialize[%08x]. Initializing....\n",
                     dwFlags));
    }

    // get the number of processors for this machine
    // do it only for NT Server only (don't scale workstation)
    if ( TsIsNtServer() ) {
        SYSTEM_INFO si;
        GetSystemInfo( &si );
        g_cCPU = si.dwNumberOfProcessors;
    } else {
        g_cCPU = 1;
    }

    //
    // Initialize context lists and crit sects
    //

    ATQ_CONTEXT_LISTHEAD * pacl;

    for ( pacl = AtqActiveContextList;
          pacl < (AtqActiveContextList + g_dwNumContextLists);
          pacl++) {
        pacl->Initialize();
    }

    InitializeListHead( &AtqEndpointList );
    INITIALIZE_CRITICAL_SECTION( &AtqEndpointLock );

    //
    // init bandwidth throttling
    //

    ATQ_REQUIRE( BANDWIDTH_INFO::AbwInitialize() );

    //
    //  Read registry configurable Atq options.  We have to read these now
    //  because concurrency is set for the completion port at creation time.
    //

    DWORD dwError = I_AtqGetGlobalConfiguration();

    if ( NO_ERROR != dwError) {
        SetLastError( dwError );
        goto cleanup;
    }

    //
    // Setup an allocation cache for the ATQ Contexts
    // NYI: Auto-tune the threshold limit
    //

    {
        ALLOC_CACHE_CONFIGURATION acConfig;

        DWORD nCachedAtq = ATQ_CACHE_LIMIT_NTS;

        if ( TsIsWindows95()) { nCachedAtq = ATQ_CACHE_LIMIT_W95; }

        acConfig.nConcurrency = 1;
        acConfig.nThreshold = nCachedAtq;
        acConfig.cbSize = sizeof(ATQ_CONTEXT);

        g_pachAtqContexts = new ALLOC_CACHE_HANDLER( "ATQ", &acConfig);

        if ( NULL == g_pachAtqContexts) {
            goto cleanup;
        }
    }


    //
    //  Create the shutdown event
    //

    g_hShutdownEvent = IIS_CREATE_EVENT(
                           "g_hShutdownEvent",
                           &g_hShutdownEvent,
                           TRUE,        // Manual reset
                           FALSE        // Not signalled
                           );

    if ( !g_hShutdownEvent ) {

        DBGERROR(( DBG_CONTEXT, "Create Shutdown event failed. Last Error = 0x%x\n",
                    GetLastError()
                  ));

        goto cleanup;
    }

    //
    //  Create the completion port
    //

    g_hCompPort = g_pfnCreateCompletionPort(INVALID_HANDLE_VALUE,
                                            NULL,
                                            0,
                                            g_cConcurrency
                                            );

    if ( !g_hCompPort ) {

        DBGERROR(( DBG_CONTEXT, "Create IoComp port failed. Last Error = 0x%x\n",
                    GetLastError()
                  ));
        goto cleanup;
    }

    //
    // initialize spud driver
    //

    if ( (dwFlags & ATQ_INIT_SPUD_FLAG) && g_fUseDriver ) {
        if (! I_AtqSpudInitialize() ) {
            goto cleanup;
        }
        g_fSpudInitialized = TRUE;
    }

    //
    // Initialize Backlog Monitor
    //
    
    if ( !g_fDisableBacklogMonitor )
    {
        DBG_ASSERT( g_pAtqBacklogMonitor == NULL );
        g_pAtqBacklogMonitor = new ATQ_BACKLOG_MONITOR;
        if (!g_pAtqBacklogMonitor) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto cleanup;
        }
    }

    //
    // Ensure all other initializations also are done
    //

    g_cThreads  = 0;
    g_fShutdown = FALSE;
    g_cAvailableThreads = 0;

    if ( !I_AtqStartTimeoutProcessing( NULL ) ) {
        goto cleanup;
    }

    IF_DEBUG(INIT_CLEAN) {
        DBGPRINTF(( DBG_CONTEXT,
                    "fUseAcceptEx[%d] NT CompPort[%d] Platform[%d]"
                    " fUseDriver[%d]\n",
                    g_fUseAcceptEx,  !g_fUseFakeCompletionPort,
                    IISPlatformType(),
                    g_fUseDriver
                    ));
    }

    //
    // Create the initial ATQ thread.
    //

    (VOID)I_AtqCheckThreadStatus( (PVOID)ATQ_INITIAL_THREAD );

    //
    // Create a second thread if we are NTS
    //

    if ( TsIsNtServer() ) {
        (VOID)I_AtqCheckThreadStatus( (PVOID)ATQ_INITIAL_THREAD );
    }

    //
    // Initialize Capacity Planning Trace
    //
    // Spawn another thread to do this since IISInitializeCapTrace() can
    // take a while and we are not in a state where SCM is getting 
    // SERVICE_STARTING messages
    //
    
    g_hCapThread = CreateThread( NULL,
                                 0,
                                 IISInitializeCapTrace,
                                 NULL,
                                 0,
                                 &dwThreadID
                                 );
    
    IF_DEBUG( API_EXIT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqInitialize( %08x) returns %d.\n",
                     dwFlags, TRUE));
    }

    //
    // Create the debug thread starter if necessary
    //
    
    if ( g_fEnableDebugThreads )
    {
        DWORD                   dwError;
        DWORD                   dwThreadID;
        HANDLE                  hThread;
        
        hThread = CreateThread( NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)AtqDebugCreatorThread,
                                NULL,
                                0,
                                &dwThreadID );
        if ( !hThread )
        {
            goto cleanup;
        }
        CloseHandle( hThread );
    }

    LeaveCriticalSection( &g_csInitTermLock );

    return TRUE;

cleanup:
    DWORD dwSaveError = GetLastError();

    for (i=0; i<g_dwNumContextLists; i++) {

        AtqActiveContextList[i].Cleanup();
    }

    DeleteCriticalSection( &AtqEndpointLock);

    if ( g_hShutdownEvent != NULL ) {
        CloseHandle( g_hShutdownEvent );
        g_hShutdownEvent = NULL;
    }

    if ( g_hCompPort != NULL ) {
        g_pfnCloseCompletionPort( g_hCompPort );
        g_hCompPort = NULL;
    }

    if ( NULL != g_pachAtqContexts) {
        delete g_pachAtqContexts;
        g_pachAtqContexts = NULL;
    }

    if ( NULL != g_pAtqBacklogMonitor ) {
        delete g_pAtqBacklogMonitor;
        g_pAtqBacklogMonitor = NULL;
    }

    ATQ_REQUIRE( BANDWIDTH_INFO::AbwTerminate());

    IF_DEBUG( API_EXIT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqInitialize( %08x) returns %d.\n",
                     dwFlags, FALSE));
    }

    sg_AtqInitializeCount = -1;

    SetLastError(dwSaveError);

    LeaveCriticalSection( &g_csInitTermLock );

    return(FALSE);

} // AtqInitialize()





BOOL
AtqTerminate(
    VOID
    )
/*++

Routine Description:

    Cleans up the ATQ package.  Should only be called after all of the
    clients of ATQ have been shutdown.

Arguments:

    None.

Return Value:

    TRUE, if ATQ was shutdown properly
    FALSE, otherwise

--*/
{
    DBGPRINTF(( DBG_CONTEXT, "AtqTerminate, %d\n", sg_AtqInitializeCount));

    DWORD       currentThreadCount;
    ATQ_CONTEXT_LISTHEAD * pacl;
    BOOL        fRet = TRUE;
    DWORD       dwErr;

    // there are outstanding users, don't fully terminate
    if ( InterlockedDecrement( &sg_AtqInitializeCount) >= 0) {

        /*IF_DEBUG( API_ENTRY)*/ {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqTerminate() - there are other users."
                         " Not terminating now\n"
                         ));
        }
        return (TRUE);
    }
    
    EnterCriticalSection( &g_csInitTermLock );

    /*IF_DEBUG( API_ENTRY)*/ {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqTerminate() - Terminating ATQ ...\n"
                     ));
    }


    //
    // All the ATQ endpoints should have been terminated before calling
    //  this ATQTerminate() function. If not, sorry return failure.
    //
    DWORD nEndpointsToBeClosed = I_NumAtqEndpointsOpen();

    if ( nEndpointsToBeClosed > 0) {

        DBGPRINTF(( DBG_CONTEXT,
                    " There are %d endpoints remaining to be closed."
                    " Somebody above stream did not close endpoints."
                    " BUG IN CODE ABOVE ATQ\n"
                    ,
                    nEndpointsToBeClosed
                    ));
        SetLastError( ERROR_NETWORK_BUSY);
        fRet = FALSE;
        goto Finished;
    }


    if ( (g_hShutdownEvent == NULL) || g_fShutdown ) {

        //
        // We have not been intialized or have already terminated.
        //
        SetLastError( ERROR_NOT_READY );
        fRet = FALSE;
        goto Finished;
    }

    //
    // All clients should have cleaned themselves up before calling us.
    //

    for ( pacl = AtqActiveContextList;
          pacl < (AtqActiveContextList + g_dwNumContextLists);
          pacl++) {

        pacl->Lock();

        if ( !IsListEmpty(&pacl->ActiveListHead)) {

            ATQ_ASSERT( IsListEmpty( &pacl->ActiveListHead));
            pacl->Unlock();

            IF_DEBUG( API_EXIT) {
                ATQ_PRINTF(( DBG_CONTEXT,
                             "AtqTerminate() - ContextList(%08x) has "
                             "Active Contexts. Failed Termination.\n",
                             pacl
                             ));
            }
            
            fRet = FALSE;
            goto Finished;
        }

        pacl->Unlock();
    } // for

    //
    // Note that we are shutting down and prevent any more handles from
    // being added to the completion port.
    //

    g_fShutdown = TRUE;

    //
    // Attempt and remove the TimeOut Context from scheduler queue
    //
    DBG_REQUIRE( I_AtqStopTimeoutProcessing());

    currentThreadCount = g_cThreads;
    if (currentThreadCount > 0) {

        DWORD       i;
        BOOL        fRes;
        OVERLAPPED  overlapped;

        //
        // Post a message to the completion port for each worker thread
        // telling it to exit. The indicator is a NULL context in the
        // completion.
        //

        ZeroMemory( &overlapped, sizeof(OVERLAPPED) );

        for (i=0; i<currentThreadCount; i++) {

            fRes = g_pfnPostCompletionStatus( g_hCompPort,
                                              0,
                                              0,
                                              &overlapped );

            ATQ_ASSERT( (fRes == TRUE) ||
                       ( (fRes == FALSE) &&
                        (GetLastError() == ERROR_IO_PENDING) )
                       );
        }
    }

    //
    // Now wait for the pool threads to shutdown.
    //

    dwErr = WaitForSingleObject( g_hShutdownEvent, ATQ_WAIT_FOR_THREAD_DEATH);
#if 0
    DWORD dwWaitCount = 0;
    while ( dwErr == WAIT_TIMEOUT) {

        dwWaitCount++;
        DebugBreak();
        Sleep( 10*1000);  // sleep for some time
        dwErr =
            WaitForSingleObject( g_hShutdownEvent, ATQ_WAIT_FOR_THREAD_DEATH);
    } // while
# endif // 0

    //
    // At this point, no other threads should be left running.
    //
    //
    //  g_cThreads counter is decremented by AtqPoolThread().
    //  AtqTerminate() is called during the DLL termination
    //  But at DLL termination, all ATQ pool threads are killed =>
    //    no one is decrementing the count. Hence this assert will always fail.
    //

    // ATQ_ASSERT( !g_cThreads );

    ATQ_REQUIRE( CloseHandle( g_hShutdownEvent ) );
    g_pfnCloseCompletionPort( g_hCompPort );

    g_hShutdownEvent = NULL;
    g_hCompPort = NULL;

    //
    // Cleanup our synchronization resources
    //

    for ( pacl = AtqActiveContextList;
          pacl < (AtqActiveContextList + g_dwNumContextLists);
          pacl++) {
        PLIST_ENTRY pEntry;

        pacl->Lock();

        if ( !IsListEmpty( &pacl->PendingAcceptExListHead)) {
            for ( pEntry = pacl->PendingAcceptExListHead.Flink;
                  pEntry != &pacl->PendingAcceptExListHead;
                  pEntry  = pEntry->Flink ) {

                PATQ_CONT pContext =
                    CONTAINING_RECORD( pEntry, ATQ_CONTEXT, m_leTimeout );

                ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                pContext->Print();
            } // for
        }

        pacl->Unlock();
        pacl->Cleanup();
    }


    //
    // Free all the elements in the Allocation caching list
    //
    if ( NULL != g_pachAtqContexts) {
        delete g_pachAtqContexts;
        g_pachAtqContexts = NULL;
    }

    if ( g_hCapThread )
    {
        WaitForSingleObject( g_hCapThread, INFINITE );
        CloseHandle( g_hCapThread );
        g_hCapThread = NULL;
        
        if (IISCapTraceRegistrationHandle != (TRACEHANDLE)0)
        {
            UnregisterTraceGuids( IISCapTraceRegistrationHandle );
        }
        
    }

    DeleteCriticalSection( &AtqEndpointLock);

    //
    // cleanup backlog monitor
    //
    delete g_pAtqBacklogMonitor;
    g_pAtqBacklogMonitor = NULL;

    // Cleanup variables in ATQ Bandwidth throttle module
    if ( !BANDWIDTH_INFO::AbwTerminate()) {

        // there may be a few blocked IO. We should avoid them all.
        // All clients should have cleaned themselves up before coming here.

        fRet = FALSE;
        goto Finished;
    }

    //
    // cleanup driver
    //

    if ( g_fSpudInitialized ) {
        (VOID)I_AtqSpudTerminate();
        g_fSpudInitialized = FALSE;
    }

    if ( g_hNtdll != NULL ) {
        FreeLibrary(g_hNtdll);
        g_hNtdll = NULL;
    }

    if ( g_hMSWsock != NULL ) {
        FreeLibrary(g_hMSWsock);
        g_hMSWsock = NULL;
    }

    IF_DEBUG( API_EXIT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqTerminate() - Successfully cleaned up.\n"
                     ));
    }

Finished:

    LeaveCriticalSection( &g_csInitTermLock );

    return fRet;
} // AtqTerminate()



HANDLE
AtqGetCompletionPort()
/*++

Routine Description:

    Return the completion port created by ATQ

Arguments:

Return Value:

    Handle to ATQ completion port

--*/
{
    return g_hCompPort;
} // AtqGetCompletionPort()


ULONG_PTR
AtqSetInfo(
    IN ATQ_INFO         atqInfo,
    IN ULONG_PTR         Data
    )
/*++

Routine Description:

    Sets various bits of information for the ATQ module

Arguments:

    atqInfo     - Data item to set
    data        - New value for item

Return Value:

    The old value of the parameter

--*/
{
    ULONG_PTR oldVal = 0;

    switch ( atqInfo ) {

    case AtqBandwidthThrottle:

        ATQ_ASSERT( g_pBandwidthInfo != NULL );
        oldVal = (ULONG_PTR)g_pBandwidthInfo->SetBandwidthLevel( (DWORD)Data );
        break;

    case AtqBandwidthThrottleMaxBlocked:

        ATQ_ASSERT( g_pBandwidthInfo != NULL );
        oldVal = (ULONG_PTR)g_pBandwidthInfo->SetMaxBlockedListSize( (DWORD)Data );
        break;

    case AtqExitThreadCallback:

        oldVal = (ULONG_PTR)g_pfnExitThreadCallback;
        g_pfnExitThreadCallback =  (ATQ_THREAD_EXIT_CALLBACK ) Data;
        break;

    case AtqMaxPoolThreads:
          // the value is per processor values
        // internally we maintain value for all processors
        oldVal = (ULONG_PTR)( g_cMaxThreads/g_cCPU );
        g_cMaxThreads = (DWORD)Data * g_cCPU;
        break;

      //
      //  Increment or decrement the max thread count.  In this instance, we
      //  do not scale by the number of CPUs
      //

      case AtqIncMaxPoolThreads:
        InterlockedIncrement( (LONG *) &g_cMaxThreads );
        oldVal = TRUE;
        break;

      case AtqDecMaxPoolThreads:
        InterlockedDecrement( (LONG *) &g_cMaxThreads );
        oldVal = TRUE;
        break;

      case AtqMaxConcurrency:
        oldVal = (ULONG_PTR)g_cConcurrency;
        g_cConcurrency = (DWORD)Data;
        break;

      case AtqThreadTimeout:
        oldVal = (ULONG_PTR)(g_msThreadTimeout/1000); // convert back to seconds
        g_msThreadTimeout = (DWORD)Data * 1000;      // convert value to millisecs
        break;

      case AtqUseAcceptEx:
        oldVal = (ULONG_PTR)g_fUseAcceptEx;
        if ( !TsIsWindows95() ) {
            g_fUseAcceptEx = (DWORD)Data;
        }
        break;

      case AtqMinKbSec:

        //
        //  Ignore it if the value is zero
        //

        if ( Data ) {
            oldVal = (ULONG_PTR)g_cbMinKbSec;
            g_cbMinKbSec = (DWORD)Data;
        }
        break;

      default:
        ATQ_ASSERT( FALSE );
        break;
    }

    return oldVal;

} // AtqSetInfo()





ULONG_PTR
AtqGetInfo(
    IN ATQ_INFO  atqInfo
    )
/*++

Routine Description:

    Gets various bits of information for the ATQ module

Arguments:

    atqInfo     - Data item to set

Return Value:

    The old value of the parameter

--*/
{
    ULONG_PTR dwVal = 0;

    switch ( atqInfo ) {

      case AtqBandwidthThrottle:
        ATQ_ASSERT( g_pBandwidthInfo != NULL );
        dwVal = (ULONG_PTR ) g_pBandwidthInfo->QueryBandwidthLevel();
        break;

      case AtqExitThreadCallback:

        dwVal = (ULONG_PTR ) g_pfnExitThreadCallback;
        break;

      case AtqMaxPoolThreads:
        dwVal = (ULONG_PTR ) (g_cMaxThreads/g_cCPU);
        break;

      case AtqMaxConcurrency:
        dwVal = (ULONG_PTR ) g_cConcurrency;
        break;

      case AtqThreadTimeout:
        dwVal = (ULONG_PTR ) (g_msThreadTimeout/1000); // convert back to seconds
        break;

      case AtqUseAcceptEx:
        dwVal = (ULONG_PTR ) g_fUseAcceptEx;
        break;

      case AtqMinKbSec:
        dwVal = (ULONG_PTR ) g_cbMinKbSec;
        break;

      case AtqMaxThreadLimit:
        dwVal = (ULONG_PTR ) g_cMaxThreadLimit;
        break;
        
      case AtqAvailableThreads:
        dwVal = (ULONG_PTR)  g_cAvailableThreads;
        break;

      default:
        ATQ_ASSERT( FALSE );
        break;
    } // switch

    return dwVal;
} // AtqGetInfo()





BOOL
AtqGetStatistics(IN OUT ATQ_STATISTICS * pAtqStats)
{
    if ( pAtqStats != NULL) {

        return g_pBandwidthInfo->GetStatistics( pAtqStats );

    } else {

        SetLastError( ERROR_INVALID_PARAMETER);
        return (FALSE);
    }
} // AtqGetStatistics()





BOOL
AtqClearStatistics( VOID)
{
    return g_pBandwidthInfo->ClearStatistics();

} // AtqClearStatistics()





ULONG_PTR
AtqContextSetInfo(
    PATQ_CONTEXT           patqContext,
    enum ATQ_CONTEXT_INFO  atqInfo,
    ULONG_PTR               Data
    )
/*++

Routine Description:

    Sets various bits of information for this context

Arguments:

    patqContext - pointer to ATQ context
    atqInfo     - Data item to set
    data        - New value for item

Return Value:

    The old value of the parameter

--*/
{
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    ULONG_PTR  OldVal = 0;

    ATQ_ASSERT( pContext );
    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

    if ( pContext && pContext->Signature == ATQ_CONTEXT_SIGNATURE )
    {
        switch ( atqInfo ) {

        case ATQ_INFO_TIMEOUT:
            OldVal = (ULONG_PTR)pContext->TimeOut;
            pContext->TimeOut = CanonTimeout( (DWORD)Data );
            break;

        case ATQ_INFO_RESUME_IO:

            //
            // set back the max timeout from pContext->TimeOut
            // This will ensure that timeout processing can go on
            //   peacefully.
            //

            {
                DWORD currentTime = AtqGetCurrentTick( );
                DWORD timeout;
                OldVal = (ULONG_PTR)pContext->NextTimeout;
                timeout = pContext->TimeOut;

                //
                // Set the new timeout
                //

                I_SetNextTimeout(pContext);

                //
                // Return the old
                //

                if ( currentTime >= (DWORD)OldVal ) {
                    ATQ_ASSERT((OldVal & ATQ_INFINITE) == 0);
                    OldVal = 0;
                } else if ( (OldVal & ATQ_INFINITE) == 0 ) {
                    OldVal -= currentTime;
                }

                // return correct units
                OldVal = (ULONG_PTR)UndoCanonTimeout( (DWORD)OldVal );
            }
            break;

        case ATQ_INFO_COMPLETION:
            OldVal = (ULONG_PTR)pContext->pfnCompletion;
            pContext->pfnCompletion = (ATQ_COMPLETION) Data;
            break;

        case ATQ_INFO_COMPLETION_CONTEXT:

            ATQ_ASSERT( Data != 0 );        // NULL context not allowed

            OldVal = (ULONG_PTR)pContext->ClientContext;
            pContext->ClientContext = (void *) Data;
            break;

        case ATQ_INFO_BANDWIDTH_INFO:
        {
            ATQ_ASSERT( Data != 0 );

            PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) Data;

            ATQ_ASSERT( pBandwidthInfo->QuerySignature() ==
                                                ATQ_BW_INFO_SIGNATURE );

            if ( !pBandwidthInfo->IsFreed() )
            {
                pContext->m_pBandwidthInfo = (PBANDWIDTH_INFO) Data;
                pContext->m_pBandwidthInfo->Reference();
            }
            break;
        }

        case ATQ_INFO_ABORTIVE_CLOSE:
            OldVal = (ULONG_PTR)pContext->IsFlag( ACF_ABORTIVE_CLOSE );
            if ( Data )
            {
                pContext->SetFlag( ACF_ABORTIVE_CLOSE );
            }
            else
            {
                pContext->ResetFlag( ACF_ABORTIVE_CLOSE );
            }
            break;

        case ATQ_INFO_FORCE_CLOSE:
            OldVal = (ULONG_PTR)pContext->ForceClose();
            pContext->SetForceClose( Data ? TRUE : FALSE );
            break;

        default:
            ATQ_ASSERT( FALSE );
        }
    }

    return OldVal;

} // AtqContextSetInfo()



BOOL
AtqAddAsyncHandle(
    PATQ_CONTEXT * ppatqContext,
    PVOID          EndpointObject,
    PVOID          ClientContext,
    ATQ_COMPLETION pfnCompletion,
    DWORD          TimeOut,
    HANDLE         hAsyncIO
    )
/*++

Routine Description:

    Adds a handle to the thread queue

    The client should call this after the IO handle is opened
    and before the first IO request is made

    Even in the case of failure, client should call AtqFreeContext() and
     free the memory associated with this object.

Arguments:

    ppatqContext - Receives allocated ATQ Context
    Context - Context to call client with
    pfnCompletion - Completion to call when IO completes
    TimeOut - Time to wait (sec) for IO completion (INFINITE is valid)
    hAsyncIO - Handle with pending read or write

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    return ( I_AtqAddAsyncHandle( (PATQ_CONT *) ppatqContext,
                                  (PATQ_ENDPOINT) EndpointObject,
                                  ClientContext,
                                  pfnCompletion,
                                  TimeOut,
                                  hAsyncIO)
             &&
             I_AddAtqContextToPort( *((PATQ_CONT *) ppatqContext))
            );

} // AtqAddAsyncHandle()




VOID
AtqGetAcceptExAddrs(
    IN  PATQ_CONTEXT patqContext,
    OUT SOCKET *     pSock,
    OUT PVOID *      ppvBuff,
    OUT PVOID *      pEndpointContext,
    OUT SOCKADDR * * ppsockaddrLocal,
    OUT SOCKADDR * * ppsockaddrRemote
    )
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    INT       cbsockaddrLocal;
    INT       cbsockaddrRemote;
    DWORD     cb;

    ATQ_ASSERT( g_fUseAcceptEx);
    ATQ_ASSERT( pContext->pEndpoint);

    *pSock   = HANDLE_TO_SOCKET(pContext->hAsyncIO);
    *pEndpointContext = pContext->pEndpoint->Context;

    //
    //  The buffer not only receives the initial received data, it also
    //  gets the sock addrs, which must be at least sockaddr_in + 16 bytes
    //  large
    //

    g_pfnGetAcceptExSockaddrs( pContext->pvBuff,
                               (cb = pContext->pEndpoint->InitialRecvSize),
                               MIN_SOCKADDR_SIZE,
                               MIN_SOCKADDR_SIZE,
                               ppsockaddrLocal,
                               &cbsockaddrLocal,
                               ppsockaddrRemote,
                               &cbsockaddrRemote );

    *ppvBuff = ( ( cb == 0) ? NULL : pContext->pvBuff);

    return;
} // AtqGetAcceptExAddrs()




BOOL
AtqCloseSocket(
    PATQ_CONTEXT patqContext,
    BOOL         fShutdown
    )
/*++

  Routine Description:

    Closes the socket in this atq structure if it wasn't
    closed by transmitfile. This function should be called only
    if the embedded handle in AtqContext is a Socket.

  Arguments:

    patqContext - Context whose socket should be closed.
    fShutdown - If TRUE, means we call shutdown and always close the socket.
        Note that if TransmitFile closed the socket, it will have done the
        shutdown for us

  Returns:
    TRUE on success and FALSE if there is a failure.
--*/
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    if ( pContext ) {

        ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

        BOOL fAbortiveClose;

        fAbortiveClose = pContext->IsFlag( ACF_ABORTIVE_CLOSE );
        pContext->ResetFlag( ACF_ABORTIVE_CLOSE );

        //
        //  Don't delete the socket if we don't have to
        //

        if ( pContext->IsState( ACS_SOCK_UNCONNECTED |
                                ACS_SOCK_CLOSED) &&
             !pContext->ForceClose()
             ) {

            //
            //  Do nothing
            //

        } else {

            // default:
            // case ACS_SOCK_LISTENING:
            // case ACS_SOCK_CONNECTED: {

            HANDLE hIO;
            PATQ_ENDPOINT pEndpoint;

            pEndpoint = pContext->pEndpoint;

            pContext->MoveState( ACS_SOCK_CLOSED);

            //
            //  During shutdown, the socket may be closed while this thread
            //  is doing processing, so only give a warning if any of the
            //  following fail
            //

            hIO = (HANDLE )InterlockedExchangePointer(
                               (PVOID *)&pContext->hAsyncIO,
                               NULL
                               );

            if ( hIO == NULL ) {

                //
                // No socket - it is already closed - do nothing.
                //

            } else {

                if (fAbortiveClose || fShutdown ) {

                    //
                    //  If this is an AcceptEx socket, we must first force a
                    //  user mode context update before we can call shutdown
                    //

                    if ( (pEndpoint != NULL) && (pEndpoint->UseAcceptEx) ) {

                        if ( setsockopt( HANDLE_TO_SOCKET(hIO),
                                         SOL_SOCKET,
                                         SO_UPDATE_ACCEPT_CONTEXT,
                                         (char *) &pEndpoint->ListenSocket,
                                         sizeof(SOCKET) ) == SOCKET_ERROR ) {

                            ATQ_PRINTF(( DBG_CONTEXT,
                                         "[AtqCloseSocket] Warning- setsockopt "
                                         "failed, error %d, socket = %x,"
                                         " Context= %08x, Listen = %lx\n",
                                         GetLastError(),
                                         hIO,
                                         pContext,
                                         pEndpoint->ListenSocket ));
                        }
                    }
                } // setsock-opt call

                if ( fAbortiveClose ) {
                    LINGER  linger;

                    linger.l_onoff = TRUE;
                    linger.l_linger = 0;

                    if ( setsockopt( HANDLE_TO_SOCKET(hIO),
                                     SOL_SOCKET,
                                     SO_LINGER,
                                     (char *) &linger,
                                     sizeof(linger) ) == SOCKET_ERROR
                         ) {
                        ATQ_PRINTF(( DBG_CONTEXT,
                                     "[AtqCloseSocket] Warning- setsockopt "
                                     "failed, error %d, socket = %x,"
                                     " Context= %08x, Listen = %lx\n",
                                     GetLastError(),
                                     hIO,
                                     pContext,
                                     pEndpoint->ListenSocket ));
                    }
                    else {
                        ATQ_PRINTF(( DBG_CONTEXT,
                                     "[AtqCloseSocket(%08x)] requested"
                                     " abortive close\n",
                                     pContext));
                    }
                } // set up linger

                if ( fShutdown ) {

                    //
                    //  Note that shutdown can fail in instances where the
                    //  client aborts in the middle of a TransmitFile.
                    //  This is an acceptable failure case
                    //

                    shutdown( HANDLE_TO_SOCKET(hIO), 1 );
                }

                DBG_ASSERT( hIO != NULL);

                if ( closesocket( HANDLE_TO_SOCKET(hIO) ) ) {

                    ATQ_PRINTF(( DBG_CONTEXT,
                                 "[AtqCloseSocket] Warning- closesocket "
                                 " failed, Context = %08x, error %d,"
                                 " socket = %x\n",
                                 pContext,
                                 GetLastError(),
                                 hIO ));
                }
            } // if (hIO != NULL)
        }

        return TRUE;
    }

    DBGPRINTF(( DBG_CONTEXT, "[AtqCloseSocket] Warning - NULL Atq context\n"));
    SetLastError( ERROR_INVALID_PARAMETER );
    return FALSE;
} // AtqCloseSocket()



BOOL
AtqCloseFileHandle(
    PATQ_CONTEXT patqContext
    )
/*++

  Routine Description:

    Closes the file handle in this atq structure.
    This function should be called only if the embedded handle
    in AtqContext is a file handle.

  Arguments:

    patqContext - Context whose file handle should be closed.

  Returns:
    TRUE on success and FALSE if there is a failure.

  Note:
   THIS FUNCTIONALITY IS ADDED TO SERVE A SPECIAL REQUEST!!!
   Most of the ATQ code thinks that the handle here is a socket.
   Except of course this function...
--*/
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    if ( pContext != NULL ) {

        HANDLE hIO;

        ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
        ATQ_ASSERT( !pContext->IsAcceptExRootContext());
        ATQ_ASSERT( !TsIsWindows95() );  // NYI

        hIO =
          (HANDLE ) InterlockedExchangePointer(
                        (PVOID *)&pContext->hAsyncIO,
                        NULL
                        );

        if ( (hIO == NULL) || !CloseHandle( hIO ) ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                        "[AtqCloseFileHandle] Warning- CloseHandle failed, "
                        " Context = %08x, error %d, handle = %x\n",
                        pContext,
                        GetLastError(),
                        hIO ));
        }

        return TRUE;
    }

    DBGPRINTF(( DBG_CONTEXT, "[AtqCloseSocket] Warning - NULL Atq context\n"));
    SetLastError( ERROR_INVALID_PARAMETER );
    return FALSE;
} // AtqCloseFileHandle()





VOID
AtqFreeContext(
    PATQ_CONTEXT patqContext,
    BOOL         fReuseContext
    )
/*++

Routine Description:

    Frees the context created in AtqAddAsyncHandle.
    Call this after the async handle has been closed and all outstanding
    IO operations have been completed. The context is invalid after this call.
    Call AtqFreeContext() for same context only ONCE.

Arguments:

    patqContext - Context to free
    fReuseContext - TRUE if this can context can be reused in the context of
        the calling thread.  Should be FALSE if the calling thread will exit
        soon (i.e., isn't an AtqPoolThread).

--*/
{
    PATQ_CONT pContext = (PATQ_CONT)patqContext;

    ATQ_ASSERT( pContext != NULL );

    IF_DEBUG( API_ENTRY) {

        ATQ_PRINTF(( DBG_CONTEXT, "AtqFreeContext( %08x (handle=%08x,"
                     " nIOs = %d), fReuse=%d)\n",
                     patqContext, patqContext->hAsyncIO,
                     pContext->m_nIO,
                     fReuseContext));
    }

    if ( pContext ) {

        ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

        if ( fReuseContext ) {
            pContext->SetFlag( ACF_REUSE_CONTEXT);
        } else {
            pContext->ResetFlag( ACF_REUSE_CONTEXT);
        }

        if ( InterlockedDecrement(  &pContext->m_nIO) == 0) {

            //
            // The number of outstanding ref holders is ZERO.
            // Free up this ATQ context.
            //
            // We really do not free up the context - but try to reuse
            //  it if possible
            //

            DBG_ASSERT( pContext->lSyncTimeout == 0);
            AtqpReuseOrFreeContext( pContext, fReuseContext);
        }
    }

    return;
} // AtqFreeContext()



BOOL
AtqReadFile(
        IN PATQ_CONTEXT patqContext,
        IN LPVOID       lpBuffer,
        IN DWORD        BytesToRead,
        IN OVERLAPPED * lpo OPTIONAL
        )
/*++

  Routine Description:

    Does an async read using the handle defined in the context.

  Arguments:

    patqContext - pointer to ATQ context
    lpBuffer - Buffer to put read data in
    BytesToRead - number of bytes to read
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbRead;     // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( !TsIsWindows95() );  // NYI
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    InterlockedIncrement( &pContext->m_nIO);

    I_SetNextTimeout(pContext);
    pContext->BytesSent = 0;

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    switch ( pBandwidthInfo->QueryStatus( AtqIoRead ) ) {

      case StatusAllowOperation:

        pBandwidthInfo->IncTotalAllowedRequests();
        fRes = ( ReadFile( pContext->hAsyncIO,
                          lpBuffer,
                          BytesToRead,
                          &cbRead,
                          lpo ) ||
                GetLastError() == ERROR_IO_PENDING);

        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

        break;

      case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoRead;
        pContext->arInfo.lpOverlapped = lpo;
        pContext->arInfo.uop.opReadWrite.buf1.len = BytesToRead;
        pContext->arInfo.uop.opReadWrite.buf1.buf = (CHAR * ) lpBuffer;
        pContext->arInfo.uop.opReadWrite.dwBufferCount = 1;
        pContext->arInfo.uop.opReadWrite.pBufAll  = NULL;

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext );
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

      default:
        ATQ_ASSERT( FALSE);
        InterlockedDecrement( &pContext->m_nIO);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;

    } // switch()

    return fRes;
} // AtqReadFile()



BOOL
AtqReadSocket(
        IN PATQ_CONTEXT  patqContext,
        IN LPWSABUF     pwsaBuffers,
        IN DWORD        dwBufferCount,
        IN OVERLAPPED *  lpo OPTIONAL
        )
/*++

  Routine Description:

    Does an async recv using the handle defined in the context
     as a socket.

  Arguments:

    patqContext - pointer to ATQ context
    lpBuffer - Buffer to put read data in
    BytesToRead - number of bytes to read
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbRead;     // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                 "AtqReadSocket(%08lx) called.\n", pContext));
    }

    if (pContext->IsFlag( ACF_RECV_ISSUED)) {
        IF_DEBUG( SPUD ) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqReadSocket -> WSARecv bypassed.\n"));
        }
        pContext->BytesSent = 0;
        pContext->SetFlag( ACF_RECV_CALLED);

#if CC_REF_TRACKING
            //
            // ATQ notification trace
            //
            // Notify client context of all non-oplock notification.
            // This is for debugging purpose only.
            //
            // Code 0xf9f9f9f9 indicates a ACF_RECV_CALLED is set in the flags field
            //

            pContext->NotifyIOCompletion( (ULONG_PTR)pContext, pContext->m_acFlags, 0xf9f9f9f9 );
#endif

        return TRUE;
    }

    I_SetNextTimeout(pContext);


    // count the number of bytes
    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent = 0;

    InterlockedIncrement( &pContext->m_nIO);

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    //
    // NYI: Create an optimal function table
    //

    if ( !g_fUseFakeCompletionPort &&
         (StatusAllowOperation == pBandwidthInfo->QueryStatus( AtqIoRead ) ) ) {

        DWORD  lpFlags = 0;

        fRes = ( (WSARecv( HANDLE_TO_SOCKET(pContext->hAsyncIO),
                           pwsaBuffers,
                           dwBufferCount,
                           &cbRead,
                           &lpFlags,  // no flags
                           lpo,
                           NULL       // no completion routine
                           ) == 0) ||
                 (WSAGetLastError() == WSA_IO_PENDING));
        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    } else {

        switch ( pBandwidthInfo->QueryStatus( AtqIoRead ) ) {

        case StatusAllowOperation:

            DBG_ASSERT(g_fUseFakeCompletionPort);

            fRes = SIOWSARecv(
                        pContext,
                        pwsaBuffers,
                        dwBufferCount,
                        lpo
                        );

            break;

        case StatusBlockOperation:

            // store data for restarting the operation.
            pContext->arInfo.atqOp        = AtqIoRead;
            pContext->arInfo.lpOverlapped = lpo;

            pContext->arInfo.uop.opReadWrite.dwBufferCount = dwBufferCount;
            if ( dwBufferCount == 1) {
                pContext->arInfo.uop.opReadWrite.buf1.len = pwsaBuffers->len;
                pContext->arInfo.uop.opReadWrite.buf1.buf = pwsaBuffers->buf;
                pContext->arInfo.uop.opReadWrite.pBufAll  = NULL;
            } else {
                DBG_ASSERT( dwBufferCount > 1);

                //
                // Inefficient: But we will burn CPU for b/w throttling.
                //
                WSABUF * pBuf = (WSABUF *)
                    ::LocalAlloc( LPTR, dwBufferCount * sizeof (WSABUF));
                if ( NULL != pBuf) {
                    pContext->arInfo.uop.opReadWrite.pBufAll = pBuf;
                    CopyMemory( pBuf, pwsaBuffers,
                                dwBufferCount * sizeof(WSABUF));
                } else {
                    InterlockedDecrement( &pContext->m_nIO);
                    fRes = FALSE;
                    break;
                }
            }

            // Put this request in queue of blocked requests.
            fRes = pBandwidthInfo->BlockRequest( pContext );
            if ( fRes )
            {
                pBandwidthInfo->IncTotalBlockedRequests();
                break;
            }
            // fall through

        case StatusRejectOperation:
            InterlockedDecrement( &pContext->m_nIO);
            pBandwidthInfo->IncTotalRejectedRequests();
            SetLastError( ERROR_NETWORK_BUSY);
            fRes = FALSE;
            break;

        default:
            ATQ_ASSERT( FALSE);
            InterlockedDecrement( &pContext->m_nIO);
            SetLastError( ERROR_INVALID_PARAMETER);
            fRes = FALSE;
            break;
        } // switch()
    }

    return fRes;
} // AtqReadSocket()



BOOL
AtqWriteFile(
    IN PATQ_CONTEXT patqContext,
    IN LPCVOID      lpBuffer,
    IN DWORD        BytesToWrite,
    IN OVERLAPPED * lpo OPTIONAL
    )
/*++

  Routine Description:

    Does an async write using the handle defined in the context.

  Arguments:

    patqContext - pointer to ATQ context
    lpBuffer - Buffer to write
    BytesToWrite - number of bytes to write
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbWritten; // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( !TsIsWindows95() );  // NYI
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    I_SetNextTimeout(pContext);
    pContext->BytesSent = BytesToWrite;

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    InterlockedIncrement( &pContext->m_nIO);

    switch ( pBandwidthInfo->QueryStatus( AtqIoWrite) ) {

      case StatusAllowOperation:

        pBandwidthInfo->IncTotalAllowedRequests();
        fRes = ( WriteFile( pContext->hAsyncIO,
                            lpBuffer,
                            BytesToWrite,
                            &cbWritten,
                            lpo ) ||
                 GetLastError() == ERROR_IO_PENDING);
        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

        break;

      case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoWrite;
        pContext->arInfo.lpOverlapped = lpo;

        pContext->arInfo.uop.opReadWrite.buf1.len = BytesToWrite;
        pContext->arInfo.uop.opReadWrite.buf1.buf = (CHAR * ) lpBuffer;
        pContext->arInfo.uop.opReadWrite.dwBufferCount = 1;
        pContext->arInfo.uop.opReadWrite.pBufAll  = NULL;

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext );
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

    default:
        ATQ_ASSERT( FALSE);
        InterlockedDecrement( &pContext->m_nIO);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;

    } // switch()

    return fRes;
} // AtqWriteFile()



BOOL
AtqWriteSocket(
    IN PATQ_CONTEXT  patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    IN OVERLAPPED *  lpo OPTIONAL
    )
/*++

  Routine Description:

    Does an async write using the handle defined in the context as a socket.

  Arguments:

    patqContext - pointer to ATQ context
    pwsaBuffer  - pointer to Winsock Buffers for scatter/gather
    dwBufferCount - DWORD containing the count of buffers pointed
                   to by pwsaBuffer
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbWritten; // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    I_SetNextTimeout(pContext);

    //
    // count the number of bytes
    //

    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent = pwsaBuffers->len;
    if ( dwBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaBuffers + 1;
              pWsaBuf < (pwsaBuffers + dwBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    if ( lpo == NULL ) {
        lpo = &pContext->Overlapped;
    }

    InterlockedIncrement( &pContext->m_nIO);

    if ( !g_fUseFakeCompletionPort &&
         (StatusAllowOperation ==
          pBandwidthInfo->QueryStatus( AtqIoWrite ) ) ) {

        pBandwidthInfo->IncTotalAllowedRequests();
        fRes = ( (WSASend( HANDLE_TO_SOCKET(pContext->hAsyncIO),
                           pwsaBuffers,
                           dwBufferCount,
                           &cbWritten,
                           0,               // no flags
                           lpo,
                           NULL             // no completion routine
                           ) == 0) ||
                 (WSAGetLastError() == WSA_IO_PENDING));
        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    } else {
        switch ( pBandwidthInfo->QueryStatus( AtqIoWrite ) ) {

        case StatusAllowOperation:

            pBandwidthInfo->IncTotalAllowedRequests();
            DBG_ASSERT(g_fUseFakeCompletionPort);

            fRes = SIOWSASend(
                        pContext,
                        pwsaBuffers,
                        dwBufferCount,
                        lpo
                        );
            break;

        case StatusBlockOperation:

            // store data for restarting the operation.
            pContext->arInfo.atqOp        = AtqIoWrite;
            pContext->arInfo.lpOverlapped = lpo;

            pContext->arInfo.uop.opReadWrite.dwBufferCount = dwBufferCount;
            if ( dwBufferCount == 1) {
                pContext->arInfo.uop.opReadWrite.buf1.len = pwsaBuffers->len;
                pContext->arInfo.uop.opReadWrite.buf1.buf = pwsaBuffers->buf;
                pContext->arInfo.uop.opReadWrite.pBufAll  = NULL;
            } else {
                DBG_ASSERT( dwBufferCount > 1);

                //
                // Inefficient: But we will burn CPU for b/w throttling.
                //
                WSABUF * pBuf = (WSABUF *)
                    ::LocalAlloc( LPTR, dwBufferCount * sizeof (WSABUF));
                if ( NULL != pBuf) {
                    pContext->arInfo.uop.opReadWrite.pBufAll = pBuf;
                    CopyMemory( pBuf, pwsaBuffers,
                                dwBufferCount * sizeof(WSABUF));
                } else {
                    InterlockedDecrement( &pContext->m_nIO);
                    fRes = FALSE;
                    break;
                }
            }

            // Put this request in queue of blocked requests.
            fRes = pBandwidthInfo->BlockRequest( pContext );
            if ( fRes )
            {
                pBandwidthInfo->IncTotalBlockedRequests();
                break;
            }
            // fall through

        case StatusRejectOperation:
            InterlockedDecrement( &pContext->m_nIO);
            pBandwidthInfo->IncTotalRejectedRequests();
            SetLastError( ERROR_NETWORK_BUSY);
            fRes = FALSE;
            break;

        default:
            ATQ_ASSERT( FALSE);
            InterlockedDecrement( &pContext->m_nIO);
            SetLastError( ERROR_INVALID_PARAMETER);
            fRes = FALSE;
            break;

        } // switch()
    }

    return fRes;
} // AtqWriteSocket()




BOOL
AtqSyncWsaSend(
    IN  PATQ_CONTEXT patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    OUT LPDWORD      pcbWritten
    )
/*++

  Routine Description:

    Does a sync write of an array of wsa buffers using WSASend.

  Arguments:

    patqContext - pointer to ATQ context
    pwsaBuffer  - pointer to Winsock Buffers for scatter/gather
    dwBufferCount - DWORD containing the count of buffers pointed
                   to by pwsaBuffer
    pcbWritten - ptr to count of bytes written

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{

    BOOL fRes = FALSE;
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);

    fRes = ( WSASend(  HANDLE_TO_SOCKET(pContext->hAsyncIO),
                       pwsaBuffers,
                       dwBufferCount,
                       pcbWritten,
                       0,               // no flags
                       NULL,            // lpo == NULL for sync write
                       NULL             // no completion routine
                       ) == 0);

    return fRes;

} // AtqSyncWsaSend()




BOOL
AtqTransmitFile(
    IN PATQ_CONTEXT            patqContext,
    IN HANDLE                  hFile,
    IN DWORD                   dwBytesInFile,
    IN LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
    IN DWORD                   dwFlags
    )
/*++

  Routine Description:

    Does a TransmitFile  using the handle defined in the context.

  Arguments:

    patqContext - pointer to ATQ context
    hFile - handle of file to read from
    dwBytesInFile - Bytes to transmit
    lpTransmitBuffers - transmit buffer structure
    dwFlags - Transmit file flags

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    //
    //  For large file sends, the client's default timeout may not be
    //  adequte for slow links.  Scale based on bytes being sent
    //

    I_SetNextTimeout(pContext);
    pContext->BytesSent = dwBytesInFile;

    if ( dwFlags == 0 ) {

        //
        // If no flags are set, then we can attempt to use the special
        // write-behind flag.  This flag can cause the TransmitFile to
        // complete immediately, before the send actually completes.
        // This can be a significant performance improvement inside the
        // system.
        //

        dwFlags = TF_WRITE_BEHIND;

    } else if ( dwFlags & TF_DISCONNECT ) {

        //
        //  If the socket is getting disconnected, mark it appropriately
        //

        pContext->MoveState( ( ( dwFlags & TF_REUSE_SOCKET )?
                               ACS_SOCK_UNCONNECTED:
                               ACS_SOCK_CLOSED
                               )
                             );
    }

    //
    // Use kernel apc flag unless configured not to
    //
    if ( g_fUseKernelApc ) {
        dwFlags |= TF_USE_KERNEL_APC;
    }


    InterlockedIncrement( &pContext->m_nIO);

    if ( !g_fUseFakeCompletionPort &&
         (StatusAllowOperation == pBandwidthInfo->QueryStatus( AtqIoXmitFile ) ) ) {

        pBandwidthInfo->IncTotalAllowedRequests();
        fRes = (g_pfnTransmitFile( HANDLE_TO_SOCKET(pContext->hAsyncIO),
                                hFile,
                                dwBytesInFile,
                                0,
                                &pContext->Overlapped,
                                lpTransmitBuffers,
                                dwFlags ) ||
                (GetLastError() == ERROR_IO_PENDING));
        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    } else {
        switch ( pBandwidthInfo->QueryStatus( AtqIoXmitFile ) ) {

        case StatusAllowOperation:

            DBG_ASSERT(g_fUseFakeCompletionPort);
            pBandwidthInfo->IncTotalAllowedRequests();

            fRes = SIOTransmitFile(
                            pContext,
                            hFile,
                            dwBytesInFile,
                            lpTransmitBuffers
                            );
            break;

        case StatusBlockOperation:

            // store data for restarting the operation.
            pContext->arInfo.atqOp        = AtqIoXmitFile;
            pContext->arInfo.lpOverlapped = &pContext->Overlapped;
            pContext->arInfo.uop.opXmit.hFile = hFile;
            pContext->arInfo.uop.opXmit.dwBytesInFile = dwBytesInFile;
            pContext->arInfo.uop.opXmit.lpXmitBuffers = lpTransmitBuffers;
            pContext->arInfo.uop.opXmit.dwFlags       = dwFlags;

            // Put this request in queue of blocked requests.
            fRes = pBandwidthInfo->BlockRequest( pContext);
            if ( fRes )
            {
                pBandwidthInfo->IncTotalBlockedRequests();
                break;
            }
            // fall through

        case StatusRejectOperation:
            InterlockedDecrement( &pContext->m_nIO);
            pBandwidthInfo->IncTotalRejectedRequests();
            SetLastError( ERROR_NETWORK_BUSY);
            fRes = FALSE;
            break;

        default:
            ATQ_ASSERT( FALSE);
            InterlockedDecrement( &pContext->m_nIO);
            SetLastError( ERROR_INVALID_PARAMETER);
            fRes = FALSE;
            break;

        } // switch()
    }

    //
    //  Restore the socket state if we failed so that the handle gets freed
    //

    if ( !fRes )
    {
        pContext->MoveState( ACS_SOCK_CONNECTED);
    }

    return fRes;

} // AtqTransmitFile()


BOOL
AtqTransmitFileEx(
    IN PATQ_CONTEXT            patqContext,
    IN HANDLE                  hFile,
    IN DWORD                   dwBytesInFile,
    IN LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
    IN DWORD                   dwFlags,
    IN OVERLAPPED *            lpo
    )
/*++

  Routine Description:

    Does a TransmitFile  using the handle defined in the context.
    Uses the parameter lpo instead of the structure in the context.

  Arguments:

    patqContext - pointer to ATQ context
    hFile - handle of file to read from
    dwBytesInFile - Bytes to transmit
    lpTransmitBuffers - transmit buffer structure
    dwFlags - Transmit file flags
    lpo - overlapped structure

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes = TRUE;
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    //
    //  For large file sends, the client's default timeout may not be
    //  adequte for slow links.  Scale based on bytes being sent
    //

    I_SetNextTimeout(pContext);
    pContext->BytesSent = dwBytesInFile;

    if ( dwFlags == 0 ) {

        //
        // If no flags are set, then we can attempt to use the special
        // write-behind flag.  This flag can cause the TransmitFile to
        // complete immediately, before the send actually completes.
        // This can be a significant performance improvement inside the
        // system.
        //

        dwFlags = TF_WRITE_BEHIND;

    } else if ( dwFlags & TF_DISCONNECT ) {

        //
        //  If the socket is getting disconnected, mark it appropriately
        //

        pContext->MoveState( ( ( dwFlags & TF_REUSE_SOCKET )?
                               ACS_SOCK_UNCONNECTED:
                               ACS_SOCK_CLOSED
                               )
                             );
    }

    InterlockedIncrement( &pContext->m_nIO);

    if ( !g_fUseFakeCompletionPort &&
         (StatusAllowOperation == pBandwidthInfo->QueryStatus( AtqIoXmitFile ) ) ) {

        pBandwidthInfo->IncTotalAllowedRequests();
        fRes = (g_pfnTransmitFile( HANDLE_TO_SOCKET(pContext->hAsyncIO),
                                hFile,
                                dwBytesInFile,
                                0,
                                (lpo == NULL) ? &pContext->Overlapped : lpo,
                                lpTransmitBuffers,
                                dwFlags ) ||
                (GetLastError() == ERROR_IO_PENDING));
        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    } else {
        ASSERT(FALSE);
        fRes = FALSE;
    }

    //
    //  Restore the socket state if we failed so that the handle gets freed
    //

    if ( !fRes )
    {
        pContext->MoveState( ACS_SOCK_CONNECTED);
    }

    return fRes;

} // AtqTransmitFileEx()


BOOL
AtqReadDirChanges(IN PATQ_CONTEXT patqContext,
                  IN LPVOID       lpBuffer,
                  IN DWORD        BytesToRead,
                  IN BOOL         fWatchSubDir,
                  IN DWORD        dwNotifyFilter,
                  IN OVERLAPPED * lpo
                  )
/*++
  AtqReadDirChanges()

  Description:
    This function submits an Async ReadDirectoryChanges() call for
    the Async handle in the ATQ context supplied.
    It always requires a non-NULL overlapped pointer for processing
    this call.

  Arguments:
    patqContext  - pointer to ATQ Context
    lpBuffer     - buffer for the data to be read from ReadDirectoryChanges()
    BytesToRead  - count of bytes to read into buffer
    fWatchSubDir - should we watch for sub directory changes
    dwNotifyFilter - DWORD containing the flags for Notification
    lpo          - pointer to overlapped structure.

  Returns:
    TRUE if ReadDirectoryChanges() is successfully submitted.
    FALSE if there is any failure in submitting IO.
--*/
{
    BOOL fRes;
    DWORD cbRead;     // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);

    if ( g_pfnReadDirChangesW == NULL ) {
        ATQ_PRINTF((DBG_CONTEXT,"ReadDirChanges entry point NULL\n"));
        SetLastError(ERROR_NOT_SUPPORTED);
        return(FALSE);
    }

    if ( lpo == NULL ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    I_SetNextTimeout(pContext);
    pContext->BytesSent = 0;

    InterlockedIncrement( &pContext->m_nIO);
    fRes = g_pfnReadDirChangesW( pContext->hAsyncIO,
                          lpBuffer,
                          BytesToRead,
                          fWatchSubDir,
                          dwNotifyFilter,
                          &cbRead,
                          lpo,
                          NULL);
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    return fRes;
} // AtqReadDirChanges()



BOOL
AtqPostCompletionStatus(
        IN PATQ_CONTEXT patqContext,
        IN DWORD        BytesTransferred
        )
/*++

Routine Description:

    Posts a completion status on the completion port queue

    An IO pending error code is treated as a success error code

Arguments:

    patqContext - pointer to ATQ context
    Everything else as in the Win32 API

    NOTES:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/

{
    BOOL fRes;
    PATQ_CONT  pAtqContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pAtqContext->m_pBandwidthInfo;

    ATQ_ASSERT( (pAtqContext)->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    if ( !pAtqContext->IsBlocked()) {

        InterlockedIncrement( &pAtqContext->m_nIO);

        fRes = ( g_pfnPostCompletionStatus( g_hCompPort,
                                          BytesTransferred,
                                          (ULONG_PTR)patqContext,
                                          &pAtqContext->Overlapped ) ||
                (GetLastError() == ERROR_IO_PENDING));
        if (!fRes) { InterlockedDecrement( &pAtqContext->m_nIO); };
    } else {

        //
        // Forcibly remove the context from blocking list.
        //

        fRes = pBandwidthInfo->RemoveFromBlockedList(pAtqContext);

        // There is a possibility of race conditions!
        //  If we cant remove an item from blocking list before
        //         its IO operation is scheduled.
        // there wont be any call back generated for this case!
    }

    return fRes;

} // AtqPostCompletionStatus



DWORD
I_AtqGetGlobalConfiguration(VOID)
/*++
Description:
   This function sets several global config params for the ATQ package.
   It also reads the global configuration from registry for ATQ.
   The values if present will override the defaults

Returns:
   Win32 Errorcode - NO_ERROR on success and anything else for error
--*/
{
    DWORD       dwError = NO_ERROR;
    DWORD       dwDefaultThreadTimeout = ATQ_REG_DEF_THREAD_TIMEOUT;

    //
    // If this is a NTW, do the right thing
    //

    if ( !TsIsNtServer() ) {
        g_cMaxThreadLimit = ATQ_REG_MIN_POOL_THREAD_LIMIT;

        //
        // chicago does not have transmitfile/acceptex support
        //

        if ( TsIsWindows95() ) {

            g_fUseAcceptEx = FALSE;
            g_fUseFakeCompletionPort = TRUE;
            g_dwNumContextLists = ATQ_NUM_CONTEXT_LIST_W95;
            dwDefaultThreadTimeout = ATQ_REG_DEF_THREAD_TIMEOUT_PWS;
            g_cMaxThreadLimit = ATQ_MAX_THREAD_LIMIT_W95;
            g_cMaxThreads = ATQ_MAX_THREAD_LIMIT_W95;
        }

    } else {

        MEMORYSTATUS ms;

        //
        // get the memory size
        //

        ms.dwLength = sizeof(MEMORYSTATUS);
        GlobalMemoryStatus( &ms );

        //
        // attempt to use driver
        //

        g_fUseDriver = TRUE;

        //
        // Alloc two threads per MB of memory.
        //

        g_cMaxThreadLimit = (LONG)((ms.dwTotalPhys >> 19) + 2);

        if ( g_cMaxThreadLimit < ATQ_REG_MIN_POOL_THREAD_LIMIT ) {
            g_cMaxThreadLimit = ATQ_REG_MIN_POOL_THREAD_LIMIT;
        } else if ( g_cMaxThreadLimit > ATQ_REG_MAX_POOL_THREAD_LIMIT ) {
            g_cMaxThreadLimit = ATQ_REG_MAX_POOL_THREAD_LIMIT;
        }
    }

    //
    // Get entry points for NT
    //

    if ( !TsIsWindows95() ) {

        if ( !I_AtqInitializeNtEntryPoints( ) ) {
            dwError = ERROR_MOD_NOT_FOUND;
            return ( dwError);
        }

        g_pfnCreateCompletionPort = CreateIoCompletionPort;
        g_pfnGetQueuedCompletionStatus = GetQueuedCompletionStatus;
        g_pfnCloseCompletionPort = CloseHandle;
        g_pfnPostCompletionStatus = PostQueuedCompletionStatus;

    } else {

        //
        // win95 entry points
        //

        g_pfnCreateCompletionPort = SIOCreateCompletionPort;
        g_pfnGetQueuedCompletionStatus = SIOGetQueuedCompletionStatus;
        g_pfnCloseCompletionPort = SIODestroyCompletionPort;
        g_pfnPostCompletionStatus = SIOPostCompletionStatus;
    }

    if ( !TsIsWindows95() ) {

        HKEY        hkey = NULL;
        DWORD       dwVal;

        dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                g_PSZ_ATQ_CONFIG_PARAMS_REG_KEY,
                                0,
                                KEY_READ,
                                &hkey);

        if ( dwError == NO_ERROR ) {

            //
            // Read the Concurrency factor per processor
            //

            dwVal = I_AtqReadRegDword( hkey,
                                       ATQ_REG_PER_PROCESSOR_CONCURRENCY,
                                       ATQ_REG_DEF_PER_PROCESSOR_CONCURRENCY);

            AtqSetInfo( AtqMaxConcurrency, (ULONG_PTR)dwVal);


            //
            // Read the count of threads to be allowed per processor
            //

            dwVal = I_AtqReadRegDword( hkey,
                                       ATQ_REG_PER_PROCESSOR_ATQ_THREADS,
                                       ATQ_REG_DEF_PER_PROCESSOR_ATQ_THREADS
                                       );

            if ( dwVal != 0 ) {
                AtqSetInfo( AtqMaxPoolThreads, (ULONG_PTR)dwVal);
            }


            //
            // Read the Data transfer rate value for our calculations
            //

            dwVal = I_AtqReadRegDword( hkey,
                                       ATQ_REG_MIN_KB_SEC,
                                       ATQ_REG_DEF_MIN_KB_SEC );

            AtqSetInfo( AtqMinKbSec, (ULONG_PTR)dwVal);


            //
            // read the max thread limit
            //

            g_cMaxThreadLimit = I_AtqReadRegDword( hkey,
                                                   ATQ_REG_POOL_THREAD_LIMIT,
                                                   g_cMaxThreadLimit);

            //
            // read the listen backlog
            //

            g_cListenBacklog = I_AtqReadRegDword( hkey,
                                                  ATQ_REG_LISTEN_BACKLOG,
                                                  g_cListenBacklog);


            //
            // Read the time (in seconds) of how long the threads
            //   can stay alive when there is no IO operation happening on
            //   that thread.
            //

            dwVal = I_AtqReadRegDword( hkey,
                                       ATQ_REG_THREAD_TIMEOUT,
                                       dwDefaultThreadTimeout
                                       );

            AtqSetInfo( AtqThreadTimeout, (ULONG_PTR)dwVal);

            //
            // See if we need to turn off TF_USE_KERNEL_APC flag for
            // TransmitFile
            //
            dwVal = I_AtqReadRegDword( hkey,
                                       ATQ_REG_USE_KERNEL_APC,
                                       ATQ_REG_DEF_USE_KERNEL_APC );
            g_fUseKernelApc = dwVal;

            //
            // Whether or not to enable debug thread creator
            //

            dwVal = I_AtqReadRegDword( hkey,
                                       ATQ_REG_ENABLE_DEBUG_THREADS,
                                       g_fEnableDebugThreads );
            g_fEnableDebugThreads = !!dwVal;

            //
            // Do we want to run this backlog monitor at all?
            //
            
            dwVal = I_AtqReadRegDword( hkey,
                                       ATQ_REG_DISABLE_BACKLOG_MONITOR,
                                       g_fDisableBacklogMonitor );
            g_fDisableBacklogMonitor = !!dwVal;

            //
            // Read timeout for backlog monitor
            //
            
            dwVal = I_AtqReadRegDword( hkey,
                                       ATQ_REG_FORCE_TIMEOUT,
                                       g_cForceTimeout );
            g_cForceTimeout = dwVal;


            ATQ_REQUIRE( !RegCloseKey( hkey ) );
            hkey = NULL;
        }

        DBG_ASSERT( NULL == hkey);

    } else {

        g_cListenBacklog = 5;
        AtqSetInfo( AtqMaxConcurrency, ATQ_REG_DEF_PER_PROCESSOR_CONCURRENCY);
        AtqSetInfo( AtqUseAcceptEx, ATQ_REG_DEF_USE_ACCEPTEX);
    }

    return ( dwError);
} // I_AtqGetGlobalConfiguration()



DWORD
I_NumAtqEndpointsOpen(VOID)
/*++
  Description:
    This function counts the number of Enpoints that remain open.

  Arguments:
     None

  Returns:
     DWORD containing the number of endpoints that are open.
--*/
{
    DWORD nEPOpen = 0;
    AcquireLock( &AtqEndpointLock);

    PLIST_ENTRY plEP;
    for( plEP  = AtqEndpointList.Flink;
         plEP != &AtqEndpointList;
         plEP  = plEP->Flink ) {

        nEPOpen++;
    } // for

    ReleaseLock( &AtqEndpointLock);
    return ( nEPOpen);
} // I_NumAtqEndpointsOpen()



//
// Global functions
//


DWORD
I_AtqReadRegDword(
   IN HKEY     hkey,
   IN LPCSTR   pszValueName,
   IN DWORD    dwDefaultValue )
/*++

    NAME:       I_AtqReadRegDword

    SYNOPSIS:   Reads a DWORD value from the registry.

    ENTRY:      hkey - Openned registry key to read

                pszValueName - The name of the value.

                dwDefaultValue - The default value to use if the
                    value cannot be read.

    RETURNS     DWORD - The value from the registry, or dwDefaultValue.

--*/
{
    DWORD  err;
    DWORD  dwBuffer;

    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;

    if( hkey != NULL ) {
        err = RegQueryValueExA( hkey,
                               pszValueName,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

        if( ( err == NO_ERROR ) && ( dwType == REG_DWORD ) ) {
            dwDefaultValue = dwBuffer;
        }
    }

    return dwDefaultValue;

} // I_AtqReadRegDword()

BOOL
AtqSetSocketOption(
    IN     PATQ_CONTEXT     patqContext,
    IN     INT              optName,
    IN     INT              optValue
    )
/*++

  AtqSetSocketOption()

  Routine Description:

    Set socket options. Presently only handles TCP_NODELAY

  Arguments:

    patqContext - pointer to ATQ context
    optName     - name of property to change
    optValue    - value of property to set

  Return Value:

    TRUE if successful, else FALSE

--*/
{
    if (TCP_NODELAY != optName)
    {
        return FALSE;
    }

    PATQ_CONT pContext = (PATQ_CONT)patqContext;

    ATQ_ASSERT( pContext != NULL );

    IF_DEBUG( API_ENTRY) {

        ATQ_PRINTF(( DBG_CONTEXT, "AtqSetSocketOption( %08x (handle=%08x,"
                     " nIOs = %d), optName=%d, optValue=%d)\n",
                     patqContext, patqContext->hAsyncIO,
                     pContext->m_nIO, optName, optValue));
    }

    if ( pContext ) {

        ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

        if ( ((BOOL)pContext->IsFlag(ACF_TCP_NODELAY)) == ((BOOL)optValue))
        {
            //
            // The flag is already enabled. Return success.
            //

            return TRUE;
        }
        else
        {
            if (NO_ERROR ==  setsockopt( HANDLE_TO_SOCKET(pContext->hAsyncIO),
                                         IPPROTO_TCP,
                                         TCP_NODELAY,
                                         (char *)&optValue,
                                         sizeof(INT)))
            {
                if ( optValue)
                {
                    pContext->SetFlag(ACF_TCP_NODELAY);
                }
                else
                {
                    pContext->ResetFlag(ACF_TCP_NODELAY);
                }
                return TRUE;
            }
        }
    }

    return FALSE;
}

PIIS_CAP_TRACE_INFO
AtqGetCapTraceInfo(
    IN     PATQ_CONTEXT     patqContext
)
{
    PATQ_CONT pContext = (PATQ_CONT)patqContext;

    ATQ_ASSERT( pContext != NULL );

    return pContext->GetCapTraceInfo();

}

DWORD 
AtqDebugCreatorThread(
    LPDWORD                 param
)
/*++

Routine Description:

    For debugging purpose.
    
    This function will cause another IO thread to be created (regardless of
    the max thread limit).  This IO thread will only serve new connections.  
    
    To trigger the creation of a new thread, set isatq!g_fCreateDebugThread=1

Arguments:

    param - Unused

Return Value:

    ERROR_SUCCESS

--*/
{
    for ( ; !g_fShutdown ; )
    {
        Sleep( 5000 );
        
        if ( g_fCreateDebugThread )
        {
            OutputDebugString( "Creating DEBUG thread." \
                               "Reseting isatq!g_fCreateDebugThread\n" );
        
            I_AtqCheckThreadStatus( (VOID*) ATQ_DEBUG_THREAD );
            
            g_fCreateDebugThread = FALSE;
        }
    }
    
    return ERROR_SUCCESS;
}

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\captrc.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    iscaptrc.cpp

Abstract:

    Source file to contain variables required for capacity planning tracing 
    of IIS.

Author:

    07-Nov-1998  SaurabN

Revision History:

--*/

//
//
//

#include "isatq.hxx"

#include <objbase.h>
#include <initguid.h>
#include <iscaptrc.h>

#define ResourceName L"MofResource"
#define ImagePath L"inetinfo.exe"

DWORD           IISCapTraceFlag = 0;
TRACEHANDLE     IISCapTraceRegistrationHandle = (TRACEHANDLE) 0;
TRACEHANDLE     IISCapTraceLoggerHandle = (TRACEHANDLE) 0;

ULONG
IISCapTraceControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    );

TRACE_GUID_REGISTRATION IISCapTraceGuids[] =
{
    { (LPGUID) &IISCapTraceGuid,
      NULL
    },
};

ULONG
_stdcall
IISInitializeCapTrace(
    PVOID Param
    )
{
    ULONG status;
  
    status = RegisterTraceGuidsW(
                IISCapTraceControlCallback,
                NULL,
                (LPGUID) &IISCapControlGuid,
                1,
                IISCapTraceGuids,
                NULL,
                NULL,
                &IISCapTraceRegistrationHandle);


    if (status != ERROR_SUCCESS) {
        DBGPRINTF((DBG_CONTEXT,"Capacity Planning Trace registration failed with %x\n",status));
    }
    return status;
}


ULONG
IISCapTraceControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
{
    PWNODE_HEADER Wnode = (PWNODE_HEADER)Buffer;
    ULONG Status;
    ULONG RetSize;

    Status = ERROR_SUCCESS;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
            IISCapTraceLoggerHandle =
                GetTraceLoggerHandle(Buffer);
            IISCapTraceFlag = 1;
            RetSize = 0;
            break;
        }

        case WMI_DISABLE_EVENTS:
        {
            IISCapTraceFlag = 0;
            RetSize = 0;
            IISCapTraceLoggerHandle = (TRACEHANDLE) 0;
            break;
        }
        default:
        {
            RetSize = 0;
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

    }

    *InOutBufferSize = RetSize;
    return Status;
} // IISCapTraceControlCallback

DWORD GetIISCapTraceFlag()
{
    return IISCapTraceFlag;
}

TRACEHANDLE GetIISCapTraceLoggerHandle()
{
    return IISCapTraceLoggerHandle;
}

VOID SetIISCapTraceFlag(DWORD dwFlag)
{
    IISCapTraceFlag = dwFlag;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\dbgutil.h ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to
      modify for each application the accompanying pgmutils.dll is used.

   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable
// begin_user_unmodifiable



/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants
//

#define DEBUG_SIO                   0x10000000
#define DEBUG_TIMEOUT               0x20000000
#define DEBUG_ENDPOINT              0x40000000
#define DEBUG_SPUD                  0x80000000

#define DEBUG_ALLOC_CACHE           0x01000000
#define DEBUG_NOTIFICATION          0x02000000


// Use the default constants from pudebug.h

# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\auxctrs.h ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       auxctrs.h

   Abstract:
       This module defines the auxiliary counters for Internet Common Services.

   Author:

       Murali R. Krishnan    ( MuraliK )    02-Apr-1996

   Environment:

       Windows NT - User Mode

   Project:

       Internet Services Common DLL

   Revision History:

--*/

# ifndef _IIS_AUX_COUNTERS_HXX_
# define _IIS_AUX_COUNTERS_HXX_

/************************************************************
 *     Include Headers
 ************************************************************/


/************************************************************
 *   Symbolic Definitions
 ************************************************************/

/*++
  Counters belong to two categories
  1. Active Counter - one that counts up and down
      It is expected that this counter consists of the current
      active items and hence this should not be wildly high, unless
      there are large # of counted objects.

  2. Cumulative Counters - counts values up and up
      This count value is used to measure the # of times event(s)
      related to this counter occurred.

  Naming Conventions:
   prefixes used are: Aac & Cac
   Aac - Active Auxiliary Counter
   Cac - Cumulative Auxiliary Counter
   Ac  - Auxiliar Counter

--*/

typedef enum  {   // Ac - stands for Aux Counters.

    AacAtqContextsAlloced = 0,

    CacAtqContextsReused,
    CacAtqContextsCleanedup,
    CacAtqPrepareContexts,
    CacAtqPendingAcceptExScans,

    CacAtqContextsTimedOut,
    CacAtqWaitsForTimeout,
    CacAtqProcWhenTimeout,           // in processing when timeout occurred.

    AacIISMaxCounters                // sentinel counter
} ENUM_IIS_AUX_COUNTER;



#ifdef IIS_AUX_COUNTERS

# define NUM_AUX_COUNTERS    (AacIISMaxCounters)

//
// Macros for operating on these counters
//

# define AcIncrement( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ?  \
   g_AuxCounters[acCounter]++ : \
  0)

# define AcDecrement( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ?  \
  g_AuxCounters[acCounter]-- : \
  0)

# define AcCounter( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ? g_AuxCounters[acCounter] : 0)


extern LONG g_AuxCounters[];


# else // IIS_AUX_COUNTERS

# define NUM_AUX_COUNTERS              (0)

# define AcIncrement( acCounter)       (0)    /* do nothing */
# define AcDecrement( acCounter)       (0)    /* do nothing */
# define AcCounter  ( acCounter)       (0)    /* do nothing */

#endif // IIS_AUX_COUNTERS


# endif // _IIS_AUX_COUNTERS_HXX_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\dirmon.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       dirmon.cpp

   Abstract:
       This module includes definitions of functions and variables
        for CDirMonitor and CDirMonitorEntry object

   Author:

       Charles Grant       ( cgrant   )     April-1997

   Revision History:

        Changed to abstract classes to share code between core IIS and ASP

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "isatq.hxx"
#include "malloc.h"
#include "except.h"

#define IATQ_DLL_IMPLEMENTATION
#define IATQ_IMPLEMENTATION_EXPORT

#include "dirmon.h"


//
// CDirMonitorEntry
//

#define DEFAULT_BUFFER_SIZE 512

CDirMonitorEntry::CDirMonitorEntry() :
                    m_cDirRefCount(0),
                    m_cIORefCount(0),
                    m_hDir(INVALID_HANDLE_VALUE),
                    m_pAtqCtxt(NULL),
                    m_dwNotificationFlags(0),
                    m_pszPath(NULL),
                    m_cPathLength(0),
                    m_pDirMonitor(NULL),
                    m_cBufferSize(0),
                    m_pbBuffer(NULL),
                    m_fInCleanup(FALSE),
                    m_fWatchSubdirectories(FALSE)
/*++

Routine Description:

    CDirMonitorEntry constructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
}


CDirMonitorEntry::~CDirMonitorEntry(
    VOID
    )
/*++

Routine Description:

    CDirMonitorEntry destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{

    IF_DEBUG( NOTIFICATION ) {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitorEntry] Destructor\n"));
    }

    // We should only be destroyed when
    // our ref counts have gone to 0

    DBG_ASSERT(m_cDirRefCount == 0);
    DBG_ASSERT(m_cIORefCount == 0);

    //
    // We really ought to have closed the handle by now
    //
    if (m_hDir != INVALID_HANDLE_VALUE) {
        DBGPRINTF(( DBG_CONTEXT, "~CDirMonitorEntry: open handle %p : %p\n",
                    m_hDir, m_pAtqCtxt ));

        m_hDir = INVALID_HANDLE_VALUE;
        AtqCloseFileHandle(m_pAtqCtxt);
    }

    if (m_pDirMonitor != NULL)
    {
        m_pDirMonitor->RemoveEntry(this);
        m_pDirMonitor = NULL;
    }

    m_cPathLength = 0;

    if ( m_pszPath != NULL )
    {
        free( m_pszPath );
        m_pszPath = NULL;
    }

    if (m_pAtqCtxt)
    {
        AtqFreeContext(m_pAtqCtxt, FALSE);
        m_pAtqCtxt = NULL;
    }

    if (m_pbBuffer != NULL)
    {
        free(m_pbBuffer);
        m_cBufferSize = 0;
    }
}

BOOL
CDirMonitorEntry::Init(
    DWORD cBufferSize = DEFAULT_BUFFER_SIZE
)
/*++

Routine Description:

    Initialize the dir montior entry.

Arguments:

    cBufferSize  - Initial size of buffer used to store change notifications

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
        // Don't allow a 0 length buffer
        if (cBufferSize == 0)
        {
                return FALSE;
        }

    DBG_ASSERT( m_pbBuffer == NULL );

        m_pbBuffer = (BYTE *) malloc(cBufferSize);

        if (m_pbBuffer != NULL)
        {
                m_cBufferSize = cBufferSize;
                return TRUE;
        }
        else
        {
                // Unable to allocate buffer
        return FALSE;
    }
}

BOOL
CDirMonitorEntry::RequestNotification(
    VOID
)
/*++

Routine Description:

    Request ATQ to monitor directory changes for the directory handle
    associated with this entry

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    IF_DEBUG( NOTIFICATION ) {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitorEntry] Request change notification\n"));
    }

    BOOL fResult = FALSE;

    DBG_ASSERT(m_pDirMonitor);

    // Reset the overlapped io structure

    memset(&m_ovr, 0, sizeof(m_ovr));

    // Increase the ref count in advance

    IOAddRef();

    // Request notification of directory changes

    fResult = AtqReadDirChanges( m_pAtqCtxt,              // Atq context handle
                            m_pbBuffer,                // Buffer for change notifications
                            m_cBufferSize,          // Size of buffer
                            m_fWatchSubdirectories,  // Monitor subdirectories?
                            m_dwNotificationFlags,   // Which changes should we be notified of
                            &m_ovr );                // Overlapped IO structure

    if (!fResult)
    {
        // ReadDirChanges failed so
        // release the ref count we did in advance
        // Might cause IO ref count to go to 0

        IORelease();
    }

    return fResult;

}

BOOL
CDirMonitorEntry::Cleanup(
    VOID
    )
/*++

Routine Description:

    Cleans up resource and determines if the caller need to delete
    the Directory Monitor Entry instance.

Arguments:

    None

Return Value:

    TRUE if the caller is responsible for deleting the object
    This will be the case if there are no pending Asynch IO requests

--*/
{
    DBG_ASSERT(m_cDirRefCount == 0);

    BOOL fDeleteNeeded = FALSE;
    BOOL fHandleClosed = FALSE;

    BOOL fInCleanup = (BOOL) InterlockedExchange((long *) &m_fInCleanup, TRUE);

    if (!fInCleanup)
    {
        // Get the IO ref count BEFORE we close the handle

        DWORD cIORefCount = m_cIORefCount;

        if (m_hDir != INVALID_HANDLE_VALUE)
        {
            // If we have a pending AtqReadDirectoryChanges,
            // closing the directory handle will cause a call back from ATQ.
            // The call back should relase the final refcount on the object
            // which should result in its deletion

            m_hDir = INVALID_HANDLE_VALUE;
            fHandleClosed = AtqCloseFileHandle( m_pAtqCtxt );
        }

        // If there were no pending Asynch IO operations or if we failed
        // to close the handle, then the caller will be responsible for
        // deleting this object.

        if (cIORefCount == 0 || fHandleClosed == FALSE)
        {
            fDeleteNeeded = TRUE;
        }
    }

    return fDeleteNeeded;
}

BOOL
CDirMonitorEntry::ResetDirectoryHandle(
    VOID
    )
/*++

Routine Description:

    Opens a new directory handle and ATQ context for the path,
    and closes the old ones. We want to be able to do this so we
    can change the size of the buffer passed in ReadDirectoryChangesW.
    If we are unable to get a new handle or a new ATQ context, we leave
    the existing ones in place.

Arguments:

    None

Return Value:

    TRUE if the handles were succesfully reopened
    FALSE otherwise

--*/
{
        // We'd better have a directory path available to try this
        
        if (m_pszPath == NULL)
        {
                return FALSE;
        }
        
    // Get a new handle to the directory

    HANDLE hDir = CreateFile(
                           m_pszPath,
                           FILE_LIST_DIRECTORY,
                                FILE_SHARE_READ |
                                FILE_SHARE_WRITE |
                                FILE_SHARE_DELETE,
                           NULL,
                           OPEN_EXISTING,
                           FILE_FLAG_BACKUP_SEMANTICS |
                                FILE_FLAG_OVERLAPPED,
                           NULL );

    if ( hDir == INVALID_HANDLE_VALUE )
    {
        // We couldn't open another handle on the directory,
        // leave the current handle and ATQ context alone

        return FALSE;
    }

    // Get a new ATQ context for our new handle

    PATQ_CONTEXT pAtqCtxt = NULL;
    if ( !AtqAddAsyncHandle(&pAtqCtxt,
                                NULL,
                                (LPVOID) this,
                                (ATQ_COMPLETION) CDirMonitor::DirMonitorCompletionFunction,
                                INFINITE,
                                hDir ) )
    {
        // We couldn't get a new ATQ context. Close our new handle.
        // We leave the objects current handle and ATQ context alone
        CloseHandle(hDir);
        return FALSE;
    }

    // We have the new handle and ATQ context so we close
    // and replace the old ones.

    AtqCloseFileHandle(m_pAtqCtxt);
        AtqFreeContext(m_pAtqCtxt, FALSE);
        m_pAtqCtxt = pAtqCtxt;
        m_hDir = hDir;

        return TRUE;
}

BOOL
CDirMonitorEntry::SetBufferSize(
    DWORD cBufferSize
    )
/*++

Routine Description:

    Sets the size of the buffer used for storing change notification records

Arguments:

    cBufferSize         new size for the buffer.

Return Value:

    TRUE        if the size of the buffer was succesfully set
    FALSE       otherwise

Note

        When a call to ReadDirectoryChangesW is made, the size of the buffer is set in
        the data associated with the directory handle and is not changed on subsequent
        calls to ReadDirectoryChangesW. To make use of the new buffer size the directory
        handle must be closed and a new handle opened (see ResetDirectoryHandle())
        
--*/
{
        // We should never be called if the buffer doesn't already exist
        
        ASSERT(m_pbBuffer);
        
        // Don't allow the buffer to be set to 0
        
        if (cBufferSize == 0)
        {
                return FALSE;
        }

        VOID *pbBuffer = realloc(m_pbBuffer, cBufferSize);

        if (pbBuffer == NULL)
        {
                // Re-allocation failed, stuck with the same size buffer
                
                return FALSE;
        }
        else
        {
                // Re-allocation succeded, update the member variables
                
                m_pbBuffer = (BYTE *) pbBuffer;
                m_cBufferSize = cBufferSize;
                return TRUE;
        }
}

//
// CDirMonitor
//

CDirMonitor::CDirMonitor()
    : CTypedHashTable<CDirMonitor, CDirMonitorEntry, const char*>("DirMon")
/*++

Routine Description:

    CDirMonitor constructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    INITIALIZE_CRITICAL_SECTION( &m_csLock );
    INITIALIZE_CRITICAL_SECTION( &m_csSerialComplLock );
    m_cRefs = 1;
}


CDirMonitor::~CDirMonitor()
/*++

Routine Description:

    CDirMonitor destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    DeleteCriticalSection(&m_csLock);
    DeleteCriticalSection(&m_csSerialComplLock);
}

BOOL
CDirMonitor::Monitor(
    CDirMonitorEntry *pDME,
    LPCSTR pszDirectory,
    BOOL fWatchSubDirectories,
    DWORD dwNotificationFlags
    )
/*++

Routine Description:

    Create a monitor entry for the specified path

Arguments:

    pszDirectory - directory to monitor
    pCtxt - Context of path is being monitored
    pszDirectory - name of directory to monitor
    fWatchSubDirectories - whether to get notifications for subdirectories
    dwNotificationFlags - which activities to be notified of

Return Value:

    TRUE if success, otherwise FALSE

Remarks:

    Caller should have a lock on the CDirMonitor
    Not compatible with WIN95

--*/
{
    LIST_ENTRY  *pEntry;
    HANDLE      hDirectoryFile = INVALID_HANDLE_VALUE;
    BOOL        fRet = TRUE;
    DWORD       dwDirLength = 0;

    IF_DEBUG( NOTIFICATION ) {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitor] Monitoring new CDirMonitorEntry\n"));
    }

    // Must have a directory monitor entry and a string
    // containing the directory path

    if (!pDME || !pszDirectory)\
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // Make copy of pszDirectory for the entry to hang on to


    pDME->m_cPathLength = strlen(pszDirectory);
    if ( !(pDME->m_pszPath = (LPSTR)malloc( pDME->m_cPathLength + 1 )) )
    {
        pDME->m_cPathLength = 0;
        return FALSE;
    }
    memcpy( pDME->m_pszPath, pszDirectory, pDME->m_cPathLength + 1 );

    pDME->Init();

    // Open the directory handle

    hDirectoryFile = CreateFile(
                           pszDirectory,
                           FILE_LIST_DIRECTORY,
                                FILE_SHARE_READ |
                                FILE_SHARE_WRITE |
                                FILE_SHARE_DELETE,
                           NULL,
                           OPEN_EXISTING,
                           FILE_FLAG_BACKUP_SEMANTICS |
                                FILE_FLAG_OVERLAPPED,
                           NULL );

    if ( hDirectoryFile == INVALID_HANDLE_VALUE )
    {
        // Cleanup
        free(pDME->m_pszPath);
        pDME->m_pszPath = NULL;
        pDME->m_cPathLength = 0;
        return FALSE;
    }
    else
    {
        // Store the handle so we can close it on cleanup

        pDME->m_hDir = hDirectoryFile;

        // Set the flags for the type of notifications we want
        // and if we should watch subdirectories or just the root

        pDME->m_dwNotificationFlags = dwNotificationFlags;
        pDME->m_fWatchSubdirectories = fWatchSubDirectories;

        // Get an ATQ context for this handle
        // and register our completion call back function

        if ( AtqAddAsyncHandle( &pDME->m_pAtqCtxt,
                                NULL,
                                (LPVOID) pDME,
                                (ATQ_COMPLETION) DirMonitorCompletionFunction,
                                INFINITE,
                                hDirectoryFile ) )
        {
            // Insert this entry into the list of active entries

            if (InsertEntry(pDME) == LK_SUCCESS)
            {

                // Ask for notification if this directory has changes

                if (!pDME->RequestNotification())
                {
                        // Couldn't register for change notification
                        // Clean up resources
                    RemoveEntry(pDME);
                        pDME->m_hDir = INVALID_HANDLE_VALUE;
                        AtqCloseFileHandle(pDME->m_pAtqCtxt);
                        free(pDME->m_pszPath);
                        pDME->m_pszPath = NULL;
                        pDME->m_cPathLength = 0;
                        return FALSE;
                }
            }
        }
        else
        {
           
            // Failed to add handle to ATQ, clean up

            CloseHandle(hDirectoryFile);
            pDME->m_hDir = INVALID_HANDLE_VALUE;
            free(pDME->m_pszPath);
            pDME->m_pszPath = NULL;
            pDME->m_cPathLength = 0;
            return FALSE;
        }

    }

    return TRUE;
}

VOID
CDirMonitor::DirMonitorCompletionFunction(
    PVOID pCtxt,
    DWORD dwBytesWritten,
    DWORD dwCompletionStatus,
    OVERLAPPED *pOvr
    )
/*++

Routine Description:

Static member function called by ATQ to signal directory changes

Arguments:

    pCtxt - CDirMonitorEntry*
    dwBytesWritten - # bytes returned by ReadDirectoryChanges
    dwCompletionStatus - status of request to ReadDirectoryChanges
    pOvr - OVERLAPPED as specified in call to ReadDirectoryChanges

Return Value:

    Nothing

--*/
{
    IF_DEBUG( NOTIFICATION ) {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitor] Notification call-back begining. Status %d\n", dwCompletionStatus));
    }

    CDirMonitorEntry*  pDirMonitorEntry = reinterpret_cast<CDirMonitorEntry*>(pCtxt);

    DBG_ASSERT(pDirMonitorEntry);

    // Safety add ref, this should guarentee that the DME is not deleted
    // while we are still processing the callback

    pDirMonitorEntry->IOAddRef();

    // Release for the current Asynch operation
    // Should not send IO ref count to 0

    DBG_REQUIRE(pDirMonitorEntry->IORelease());

    BOOL fRequestNotification = FALSE;

    // There has been a change in the directory we were monitoring
    // carry out whatever work we need to do.

    if (!pDirMonitorEntry->m_fInCleanup)
    {
        pDirMonitorEntry->m_pDirMonitor->SerialComplLock();
        // BUG Under stress ActOnNotification has been initiating a chain of events
        // leading to an AV. For Beta 3 we think we can ignore these AV. For the final
        // product we need to rework the critical sections for the template manager and
        // the include file table.
        TRY
            fRequestNotification = pDirMonitorEntry->ActOnNotification(dwCompletionStatus, dwBytesWritten);
        CATCH(nExcept)
            // We should never get here
            DBG_ASSERT(FALSE);
        END_TRY
        pDirMonitorEntry->m_pDirMonitor->SerialComplUnlock();
    }

    // If we aren't cleaning up and ActOnNotification returned TRUE
    // then make another Asynch notification request. We check m_fInCleanup
    // again because ActOnNotification may have caused it to change

    if (!pDirMonitorEntry->m_fInCleanup && fRequestNotification)
    {
       fRequestNotification = pDirMonitorEntry->RequestNotification();
    }

    // Remove safety ref count, may cause IO ref count to go to 0

    pDirMonitorEntry->IORelease();

    IF_DEBUG( NOTIFICATION ) {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitor] Notification call-back ending\n"));
    }
}


CDirMonitorEntry *
CDirMonitor::FindEntry(
    LPCSTR pszPath
    )
/*++

Routine Description:

    Searches the list of entries for the specified path

Arguments:

    pszPath - file path, including file name

Return Value:

    pointer to the entry, allready addref'd

--*/
{
    DBG_ASSERT(pszPath);

    CDirMonitorEntry *pDME = NULL;
    FindKey(pszPath, &pDME);

    if (pDME)
    {
        if (pDME->m_fInCleanup)
        {
                // Don't hand back a DME that is being shutdown
                pDME = NULL;
        }
        else
        {
                // We found a valid DME which we are going to hand to the caller
                pDME->AddRef();
        }
    }

    return pDME;
}

LK_RETCODE
CDirMonitor::InsertEntry(
    CDirMonitorEntry *pDME
    )
/*++

Routine Description:

    Insert an entry into the list of entries for the monitor

Arguments:

    pDME - entry to insert

Return Value:

    nothing

--*/
{
    DBG_ASSERT(pDME);
    LK_RETCODE  lkResult;

    IF_DEBUG( NOTIFICATION ) {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitor] Inserting directory (DME %08x) %s\n", pDME, pDME->m_pszPath));
    }

    pDME->m_pDirMonitor = this;

    // pass a true value for the fOverwrite flag.  This allows the new entry
    // to replace the previous entry.  The previous entry should only be there
    // if the app it is associated with is being shutdown and the cleanup of
    // the DME records has yet to happen.

    lkResult = InsertRecord(pDME, true);
    
    if (lkResult == LK_SUCCESS) {
        // AddRef on the DirMonitor object to allow Cleanup to wait for all
        // DirMonitorEntries to be removed.  The problem arises when duplicates
        // are added to the hash table.  In this case, only the last entry is
        // kept so checking the size of the hash table during shutdown is not
        // good enough since the DMEs that were bounced may not have been freed
        // yet.
        AddRef();
    }
       
    return lkResult;
}

LK_RETCODE
CDirMonitor::RemoveEntry(
    CDirMonitorEntry *pDME
    )
/*++

Routine Description:

    Deletes an entry from the list of entries for the monitor

Arguments:

    pDME - entry to delete

Return Value:

    None

--*/
{
    DBG_ASSERT(pDME);

    // Release the DME's reference on the DirMonitor object.

    Release();

    LK_RETCODE lkResult = DeleteKey(pDME->m_pszPath);
    pDME->m_pDirMonitor = NULL;

    IF_DEBUG( NOTIFICATION ) {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitor] Removed DME(%08x), directory %s\n", pDME, pDME->m_pszPath));
    }

    return lkResult;
}

BOOL
CDirMonitor::Cleanup(
    VOID
    )
/*++

Routine Description:

    Pauses while all entries are cleaned up

Arguments:

    None

Return Value:

    None

--*/
{
    //BOOL fProperShutdown = FALSE;

    // Check that all DME have been released before shutting down
    // Sleep a maximum of 30 seconds before shutting down anyway

        while (Size() > 0 || m_cRefs != 1)
    {
                // At least one DME is still active, sleep and try again
                Sleep(200);
    }

    DBGPRINTF((DBG_CONTEXT, "CDirMonitor(%08x): Cleanup, entries remaining %d (Refs = %d)\n", this, Size(),m_cRefs));

    #ifdef _DEBUG
    // TODO: Use LKHASH iterator
    /*if (CHashTable::m_Count)
        {
        Lock();
        CLinkElem *pLink = CHashTable::Head();
        DBGPRINTF((DBG_CONTEXT, "Remaining CDirMonitorEntry objects:\n"));
        while (pLink)
            {
            CDirMonitorEntry *pDME = reinterpret_cast<CDirMonitorEntry *>(pLink);
            DBGPRINTF((DBG_CONTEXT, "CDirMonitorEntry(%08x), ref count = %d, io refcount = %d", pDME, pDME->m_cDirRefCount, pDME->m_cIORefCount));
            pLink = pLink->m_pNext;
            }
        Unlock();
        }
    */
    #endif //_DEBUG

    //DBG_ASSERT(fProperShutdown );


    return TRUE;
}

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\atqsupp.cxx ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

       atqsupp.cxx

   Abstract:

        Contains internal support routines for the ATQ package
        From atqnew.c

   Author:
        Murali R. Krishnan     (MuraliK)     02-Apr-1996

   Project:
        Internet Server Common DLL
--*/

#include "isatq.hxx"
#include <iscaptrc.h>

DWORD AtqPoolThread( LPDWORD param );

extern PBANDWIDTH_INFO g_pBandwidthInfo;
extern DWORD            IISCapTraceFlag;
extern TRACEHANDLE      IISCapTraceLoggerHandle;


DWORD g_fAlwaysReuseSockets = FALSE;


/************************************************************
 * Functions for ATQ_CONTEXT
 ************************************************************/


PATQ_CONT
I_AtqAllocContextFromCache( VOID);

VOID
I_AtqFreeContextToCache(
            IN PATQ_CONT pAtqContext,
            IN BOOL UnlinkContext
            );



PATQ_CONT
I_AtqAllocContextFromCache( VOID)
/*++
  This function attempts to allocate an ATQ context from the allocation cache.
  It then initializes the state information in the ATQ context object and
    returns the context on success.

  Arguments:
    None

  Returns:
    On success a valid pointer to ATQ_CONT. Otherwise NULL.

--*/
{
    PATQ_CONT  pAtqContext;

    DBG_ASSERT( NULL != g_pachAtqContexts);

    pAtqContext = (ATQ_CONTEXT * ) g_pachAtqContexts->Alloc();

    if ( NULL != pAtqContext ) {

        //
        // Make sure everything is zeroed out so there is
        // no crud from previous use.
        //
        memset(pAtqContext, 0, sizeof(ATQ_CONTEXT));

        pAtqContext->ContextList =
            &AtqActiveContextList[(++AtqGlobalContextCount %
                                   g_dwNumContextLists)];

        pAtqContext->Signature = ATQ_CONTEXT_SIGNATURE;
    }

    return (pAtqContext);
} // I_AtqAllocContextFromCache()




VOID
I_AtqFreeContextToCache(
        IN PATQ_CONT pAtqContext
        )
/*++
  This function releases the given context to the allocation cache.

  Arguments:
    pAtqContext  pointer to the ATQ_CONTEXT that is being freed.

  Returns:
    None

  Issues:
    This function also performs some other cleanup specific to AtqContexts.
--*/
{

#if 0
      ATQ_PRINTF(( DBG_CONTEXT,
                 "[I_AtqFreeCtxtToCache] Freed up %08x\n",
                 pAtqContext
                 ));
#endif

    DBG_ASSERT( pAtqContext->Signature == ATQ_FREE_CONTEXT_SIGNATURE);
    DBG_ASSERT( pAtqContext->lSyncTimeout ==0);
    DBG_ASSERT( pAtqContext->m_nIO ==0);
    DBG_ASSERT( pAtqContext->m_acFlags == 0);
    DBG_ASSERT( pAtqContext->m_acState == 0);
    DBG_ASSERT( pAtqContext->m_leTimeout.Flink == NULL);
    DBG_ASSERT( pAtqContext->m_leTimeout.Blink == NULL);
    DBG_ASSERT( pAtqContext->pvBuff == NULL);
    DBG_ASSERT( pAtqContext->pEndpoint == NULL);
    DBG_ASSERT( pAtqContext->hAsyncIO == NULL);

    DBG_REQUIRE( g_pachAtqContexts->Free( pAtqContext));

    return;

} // I_AtqFreeContextToCache



void
ATQ_CONTEXT::Print( void) const
{
    DBGPRINTF(( DBG_CONTEXT,
                " ATQ_CONTEXT (%08x)\n"
                "\thAsyncIO            = %p   Signature        = %08lx\n"
                "\tOverlapped.Internal = %p   Overlapped.Offset= %08lx\n"
                "\tm_leTimeout.Flink   = %p   m_leTimeout.Blink= %p\n"
                "\tClientContext       = %p   ContextList      = %p\n"
                "\tpfnCompletion       = %p ()\n"
                "\tpEndPoint           = %p   fAcceptExContext = %s\n"
                "\tlSyncTimeout        = %8d     fInTimeout       = %s\n"

                "\tTimeOut             = %08lx   NextTimeout      = %08lx\n"
                "\tBytesSent           = %d (0x%08lx)\n"

                "\tpvBuff              = %p   JraAsyncIo       = %p\n"
                "\tfConnectionIndicated= %s      fBlocked         = %8lx\n"

                "\tState               = %8lx    Flags            = %8lx\n",
                this,
                hAsyncIO,
                Signature,
                Overlapped.Internal,
                Overlapped.Offset,
                m_leTimeout.Flink,
                m_leTimeout.Blink,
                ClientContext,
                ContextList,
                pfnCompletion,
                pEndpoint,
                (IsAcceptExRootContext() ? "TRUE" : "FALSE"),
                lSyncTimeout,
                (IsFlag( ACF_IN_TIMEOUT) ? "TRUE" : "FALSE"),
                TimeOut,
                NextTimeout,
                BytesSent,
                BytesSent,
                pvBuff,
                hJraAsyncIO,
                (IsFlag( ACF_CONN_INDICATED) ? "TRUE" : "FALSE"),
                IsBlocked(),
                m_acState, m_acFlags
                ));

    // Print the buffer if necessary.

    return;
} // ATQ_CONTEXT::Print()




VOID
ATQ_CONTEXT::HardCloseSocket( VOID)
/*++
  Description:
     This socket closes the socket by forcibly calling closesocket() on
     the socket. This function is used during the endpoint shutdown
     stage for an atq context

  Arguments:
     None

  Returns:
     None

--*/
{
    HANDLE haio = (HANDLE )
        InterlockedExchangePointer( (PVOID *)&hAsyncIO, NULL );

    DBG_ASSERT( IsState( ACS_SOCK_LISTENING) ||
                IsState( ACS_SOCK_CONNECTED) ||
                IsState( ACS_SOCK_CLOSED) ||
                IsState( ACS_SOCK_UNCONNECTED)
                );

    MoveState( ACS_SOCK_CLOSED);


    //
    //  Let us do a hard close on the socket (handle).
    //  This should generate an IO completion which will free this
    //     ATQ context
    //

    if ( (haio != NULL) &&
         (closesocket( HANDLE_TO_SOCKET(haio) ) == SOCKET_ERROR)
         ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Warning - "
                     " Context=%08x closesocket failed,"
                     " error %d, socket = %x\n",
                     this,
                     GetLastError(),
                     haio ));
        Print();
    }

    return;
} // ATQ_CONTEXT::HardCloseSocket()



VOID
ATQ_CONTEXT::InitWithDefaults(
    IN ATQ_COMPLETION pfnCompletion,
    IN DWORD TimeOut,
    IN HANDLE hAsyncIO
    )
{
    DBG_ASSERT( this->Signature == ATQ_CONTEXT_SIGNATURE);

    this->InitTimeoutListEntry();

    this->Signature    = ATQ_CONTEXT_SIGNATURE;

     // start life at 1. This ref count will be freed up by AtqFreeContext()
    this->m_nIO = 1;

    this->pfnCompletion   = pfnCompletion;

    this->TimeOut         = TimeOut;
    this->TimeOutScanID   = 0;
    this->lSyncTimeout    = 0;

    this->hAsyncIO        = hAsyncIO;
    this->hJraAsyncIO     = (ULONG_PTR)hAsyncIO | 0x80000000;

    this->m_acState       = 0;
    this->m_acFlags       = 0;

    // Initialize pbandwidthinfo to point to global object

    this->m_pBandwidthInfo  = g_pBandwidthInfo;

    ZeroMemory(
               &this->Overlapped,
               sizeof( this->Overlapped )
               );

    DBG_ASSERT( this->lSyncTimeout == 0);

    //
    // Following added for bandwidth throttling purposes
    //

    DBG_ASSERT( !this->IsBlocked());
    this->arInfo.atqOp    = AtqIoNone;
    this->arInfo.lpOverlapped = NULL;
    // bandwidth throttling initialization ends here.

    //
    // Should we force socket closure?
    //
    
    this->m_fForceClose = FALSE;

} // ATQ_CONTEXT::InitWithDefaults()




VOID
ATQ_CONTEXT::InitNonAcceptExState(
    IN PVOID pClientContext
    )
{
    //
    //  Note that if we're not using AcceptEx, then we consider the client
    //  to have been notified externally (thus ACF_CONN_INDICATED is set).
    //  Also we set the next timeout to be infinite, which may be reset
    //   when the next IO is submitted.
    //

    this->NextTimeout          = ATQ_INFINITE;
    this->ClientContext        = pClientContext;
    this->pEndpoint            = NULL;
    this->SetFlag( ACF_CONN_INDICATED);
    this->SetState( ACS_SOCK_CONNECTED);
    this->ResetFlag( ACF_ACCEPTEX_ROOT_CONTEXT);

    //
    // Insert this into the active list - since this is a non-acceptex socket
    //

    DBG_ASSERT( this->ContextList != NULL);
    this->ContextList->InsertIntoActiveList( &this->m_leTimeout );

    return;

} // ATQ_CONTEXT::InitNonAcceptExState()



VOID
ATQ_CONTEXT::InitAcceptExState(
            IN DWORD NextTimeOut
            )
{
    this->NextTimeout          = NextTimeOut;
    this->ClientContext        = NULL;
    this->lSyncTimeout         = 0;

    this->ResetFlag( ACF_CONN_INDICATED);
    this->SetState( ACS_SOCK_LISTENING);

    //
    //  Add it to the pending accept ex list
    //
    DBG_ASSERT( this->ContextList != NULL);

    this->ContextList->InsertIntoPendingList( &this->m_leTimeout);

    return;
} // ATQ_CONTEXT::InitAcceptExState()



BOOL
ATQ_CONTEXT::PrepareAcceptExContext(
    PATQ_ENDPOINT          pEndpoint
    )
/*++

Routine Description:

    Initializes the state for completely initializing the state and
    hence prepares the context for AcceptEx

    It expects the caller to send a AtqContext with certain characteristics
      1) this is not NULL
      2) this->pvBuff has valid values

    In the case of failure, caller should call
     pAtqContext->CleanupAndRelese() to free the memory associated with
     this object.

Arguments:

    pEndpoint     - pointer to endpoint object for this context

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

    The caller should free the object on a failure.

--*/
{
    DBG_ASSERT( g_fUseAcceptEx); // only support AcceptEx() cases
    DBG_ASSERT( pEndpoint != NULL);
    DBG_ASSERT( this != NULL);
    DBG_ASSERT( this->pvBuff != NULL);

    //
    //  Make sure that we are adding a AcceptEx() version of AtqContext
    //

    DBG_ASSERT( pEndpoint->ConnectExCompletion != NULL);
    DBG_ASSERT( pEndpoint->UseAcceptEx);

    //
    //  Fill out the context.  We set NextTimeout to INFINITE
    //  so the timeout thread will ignore this entry until an IO
    //  request is made unless this is an AcceptEx socket, that means
    //  we're about to submit the IO.
    //

    this->
        InitWithDefaults(
                         pEndpoint->IoCompletion,
                         pEndpoint->AcceptExTimeout, // canonical Timeout
                         this->hAsyncIO
                         );


    //
    // TBD: What is the circumstance in which this->pEndpoint!= NULL?
    //

    if ( this->pEndpoint == NULL ) {

        pEndpoint->Reference();
        this->pEndpoint  = pEndpoint;
    }

    this->ResetFlag( ACF_ACCEPTEX_ROOT_CONTEXT );

    this->InitAcceptExState( AtqGetCurrentTick() + TimeOut);

    DBG_ASSERT( this->pvBuff != NULL);

    //
    // Initialize capacity planning trace info
    //

    m_CapTraceInfo.IISCapTraceHeader.TraceHeader.Guid         = IISCapTraceGuid;
    m_CapTraceInfo.IISCapTraceHeader.TraceHeader.Class.Type   = EVENT_TRACE_TYPE_START;
    m_CapTraceInfo.IISCapTraceHeader.TraceHeader.Flags        = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;
    m_CapTraceInfo.IISCapTraceHeader.TraceHeader.Size         = sizeof (IIS_CAP_TRACE_HEADER);
    m_CapTraceInfo.IISCapTraceHeader.TraceContext.Length      = sizeof(ULONGLONG);
    // Will get over-written
    m_CapTraceInfo.IISCapTraceHeader.TraceContext.DataPtr     = (ULONGLONG) 
                                                                (&m_CapTraceInfo.IISCapTraceHeader.TraceContext.DataPtr);
    return (TRUE);

} // ATQ_CONTEXT::PrepareAcceptExContext()




VOID
ATQ_CONTEXT::CleanupAndRelease( VOID)
/*++
  Routine Description:
     This function does the cleanup of the ATQ context. It does not
     attempt to do any reuse of the atq context. After cleanup
     the context is freed to the ATQ pool. Supplied context
     is not valid after calling this function.

  Arguments:
     None

  Returns:
     None
--*/
{
    DBG_ASSERT( this->m_nIO == 0);

    //
    //  Cleanup and free the ATQ Context entirely
    //

    if ( this->hAsyncIO != NULL ) {

        // It is too dangerous to assume that the handle is a socket!
        // But we will do that for fast-pathing IIS operations.

        HANDLE hTmp =
            (HANDLE)InterlockedExchangePointer( (PVOID *)&this->hAsyncIO,
                                                NULL );

        SOCKET hIO = HANDLE_TO_SOCKET(hTmp);

        if ( hIO != NULL &&
             (closesocket( hIO ) == SOCKET_ERROR ) ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                         "ATQ_CONTEXT(%08x)::CleanupAndRelease() : Warning"
                         " - Context=%08x, "
                         " closesocket failed, error %d, socket = %x\n",
                         this,
                         GetLastError(),
                         hIO ));
            this->Print();
        }
    }

    DBG_ASSERT( this->hAsyncIO == NULL);

    if ( this->pvBuff != NULL ) {
        LocalFree( this->pvBuff );
        this->pvBuff = NULL;
    }

    //
    // Unlink from the list
    //

    DBG_ASSERT( this->ContextList != NULL);

    // NYI: Can I avoid this comparison?
    //
    // Check if this context is part of a timeout list.
    // If it is then remove it from the list
    // Only during shutdown code path, we will see trouble here.
    //
    if ( this->m_leTimeout.Flink != NULL ) {
        this->ContextList->RemoveFromList( &this->m_leTimeout);
    }

    //
    //  Deref the listen info if this context is associated with one
    //

    if ( this->pEndpoint != NULL ) {
        this->pEndpoint->Dereference();
        this->pEndpoint = NULL;
    }

    this->Signature    = ATQ_FREE_CONTEXT_SIGNATURE;
    this->lSyncTimeout = 0;
    this->m_acState    = 0;
    this->m_acFlags    = 0;

    I_AtqFreeContextToCache( this);

    return;
} // ATQ_CONTEXT::CleanupAndRelease()





inline VOID
DBG_PRINT_ATQ_SPUDCONTEXT( IN PATQ_CONT  pAtqContext,
                           IN PSPUD_REQ_CONTEXT reqContext)
{
    ATQ_PRINTF(( DBG_CONTEXT,
                 "[AtqPoolThread] pAtqContext = %08lx\n"
                 "[AtqPoolThread] IoStatus1.Status = %08lx\n"
                 "[AtqPoolThread] IoStatus1.Information = %08lx\n"
                 "[AtqPoolThread] IoStatus2.Status = %08lx\n"
                 "[AtqPoolThread] IoStatus2.Information = %08lx\n"
                 ,
                 pAtqContext,
                 reqContext->IoStatus1.Status,
                 reqContext->IoStatus1.Information,
                 reqContext->IoStatus2.Status,
                 reqContext->IoStatus2.Information
                 ));
    return;
} // DBG_PRINT_ATQ_SPUDCONTEXT()


VOID
AtqpUpdateBandwidth( IN PATQ_CONT  pAtqContext,
                    IN DWORD      cbWritten)
{
    PBANDWIDTH_INFO pBandwidthInfo = pAtqContext->m_pBandwidthInfo;

    DBG_ASSERT( pBandwidthInfo != NULL );
    DBG_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    // add the bandwidth info to active list if necessary

    pBandwidthInfo->AddToActiveList();

    //this will have problems when we use XmitFile for large files.

    pBandwidthInfo->UpdateBytesXfered( pAtqContext, cbWritten );
} // AtqpUpdateBandwidth()


VOID
AtqpCallOplockCompletion( IN PATQ_CONT pAtqContext,
                          IN DWORD cbWritten)
{
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion;
    PVOID OplockContext;
    POPLOCK_INFO pOplock;

    IF_DEBUG( SPUD) {
        DBGPRINTF(( DBG_CONTEXT,
                    "CallOplockCompletion on OpLockInfo=%08x.cbWritten = %d\n",
                    (POPLOCK_INFO ) pAtqContext, cbWritten));
    }

    //
    // The ATQ context object received is a fake one. We actually get
    //  back POPLOCK_INFO object that is used to extract the callback
    //  function & context for the callback
    //

    pOplock = (POPLOCK_INFO)pAtqContext;
    pfnOplockCompletion = (ATQ_OPLOCK_COMPLETION)pOplock->pfnOplockCompletion;
    OplockContext = (PVOID)pOplock->Context;

    LocalFree(pOplock);


    (*pfnOplockCompletion)(OplockContext, (DWORD)cbWritten);
    return;

} // AtqpCallOplockCompletion()



VOID
AtqpProcessContext( IN PATQ_CONT  pAtqContext,
                    IN DWORD      cbWritten,
                    IN LPOVERLAPPED lpo,
                    IN BOOL       fRet)
{
    BOOL fDriverCall = FALSE;
    BOOL fRecvCalled = FALSE;
    PSPUD_REQ_CONTEXT  reqContext;
    DWORD dwError;

    DBG_ASSERT( pAtqContext != NULL);

    //
    // Check to see if this is a completion request from the
    // NTS kernel driver.
    //

    if ( lpo == NULL ) {

        if ( cbWritten == 0xffffffff ) {

            //
            // One of the SPUD's IO completion. Handle it appropriately.
            //

            reqContext = (PSPUD_REQ_CONTEXT)pAtqContext;

            pAtqContext = CONTAINING_RECORD( reqContext, ATQ_CONTEXT,
                                             spudContext );

            IF_DEBUG( SPUD) {
                DBG_PRINT_ATQ_SPUDCONTEXT( pAtqContext, reqContext);
            }
#if CC_REF_TRACKING
            //
            // ATQ notification trace
            //
            // Notify client context of all non-oplock notification.
            // This is for debugging purpose only.
            //
            // Code 0xfcfcfcfc indicates a SPUD I/O Completion
            //

            pAtqContext->NotifyIOCompletion( (ULONG_PTR)pAtqContext, reqContext->IoStatus1.Status, 0xfcfcfcfc );
#endif

            cbWritten = (DWORD)reqContext->IoStatus1.Information;
            fRet = (reqContext->IoStatus1.Status == STATUS_SUCCESS);
            SetLastError(g_pfnRtlNtStatusToDosError(reqContext->IoStatus1.Status));

            lpo = &pAtqContext->Overlapped;

            //
            // If the TransmitFile fails then the receive is not issued.
            //

            if ( fRet ) {
                fDriverCall = TRUE;
            } else {
                DBG_ASSERT( fDriverCall == FALSE);
                pAtqContext->ResetFlag( ACF_RECV_ISSUED);
            }
        } else {

            //
            // An Oplock notification - handle it via oplock path.
            //

            AtqpCallOplockCompletion( pAtqContext, cbWritten);
            return;
        }
    }

    dwError = (fRet) ? NO_ERROR: GetLastError();

    //
    //  If this is an AcceptEx listen socket atq completion, then the
    //  client Atq context we really want is keyed from the overlapped
    //  structure that is stored in the client's Atq context.
    //

    if ( pAtqContext->IsAcceptExRootContext() ) {

        pAtqContext = CONTAINING_RECORD( lpo, ATQ_CONTEXT, Overlapped );
    }

#if CC_REF_TRACKING
    //
    // ATQ notification trace
    //
    // Notify client context of all non-oplock notification.
    // This is for debugging purpose only.
    //

    pAtqContext->NotifyIOCompletion( cbWritten, (fRet) ? NO_ERROR: GetLastError(), 0xfefefefe );
#endif

    DBG_CODE(
             if ( ATQ_CONTEXT_SIGNATURE != pAtqContext->Signature) {
                 pAtqContext->Print();
                 DBG_ASSERT( FALSE);
             });


    //
    //  m_nIO also acts as the reference count for the atq contexts
    //  So, increment the count now, so that there is no other thread
    //   that will free up this ATQ context accidentally.
    //

    InterlockedIncrement( &pAtqContext->m_nIO);

    //
    // Busy wait for timeout processing to complete!
    //  This is ugly :( A fix in time for IIS 2.0/Catapult 1.0 release
    //

    InterlockedIncrement(  &pAtqContext->lSyncTimeout);
    while ( pAtqContext->IsFlag( ACF_IN_TIMEOUT)) {

        AcIncrement( CacAtqWaitsForTimeout);

        Sleep( ATQ_WAIT_FOR_TIMEOUT_PROCESSING);
    };

    //
    //  We need to make sure the timeout thread doesn't time this
    //  request out so reset the timeout value
    //

    InterlockedExchange( (LPLONG )&pAtqContext->NextTimeout,
                         (LONG ) ATQ_INFINITE);

    //
    // Update Bandwidth information on successful completion, if needed
    //

    if ( BANDWIDTH_INFO::GlobalEnabled() && fRet && cbWritten > 0)
    {
        AtqpUpdateBandwidth( pAtqContext, cbWritten);
    }

    //
    // Since the IO completion means that one of the async operation finished
    //  decrement our internal ref count appropriately to balance the addition
    //  when the IO operation was submitted.
    //
    InterlockedDecrement( &pAtqContext->m_nIO);

    //
    //  Is this a connection indication?
    //

    if ( !pAtqContext->IsFlag( ACF_CONN_INDICATED) ) {

        PATQ_ENDPOINT pEndpoint = pAtqContext->pEndpoint;

        if ( NULL == pEndpoint) {
            pAtqContext->Print();
            OutputDebugString( "Found an ATQ context with bad Endpoint\n");
            DBG_ASSERT( FALSE);
            DBG_REQUIRE( InterlockedDecrement(  &pAtqContext->lSyncTimeout) == 0);
            InterlockedDecrement( &pAtqContext->m_nIO); // balance entry count
            return;
        }

        DBG_ASSERT( pEndpoint != NULL );

        //
        // If the endpoint isn't active it may not be safe to call
        // the connection completion function. Setting an error
        // state will close the connection below.
        //
        if ( fRet && !IS_BLOCK_ACTIVE( pEndpoint ) ) {
            fRet = FALSE;
            dwError = ERROR_OPERATION_ABORTED;
        }

        //
        //  Indicate this socket is in use
        //

        InterlockedDecrement( &pEndpoint->nSocketsAvail );

        //
        //  If we're running low on sockets, add some more now
        //

        if ( pEndpoint->nSocketsAvail <
             (LONG )(pEndpoint->nAcceptExOutstanding >> 2) ) {

            AcIncrement( CacAtqPrepareContexts);

            (VOID ) I_AtqPrepareAcceptExSockets(pEndpoint,
                                                pEndpoint->nAcceptExOutstanding
                                                );
        }

        //
        //  If an error occurred on this completion,
        //    shutdown the socket
        //

        if ( !fRet ) {

            IF_DEBUG( ERROR) {
                if ( dwError != ERROR_OPERATION_ABORTED &&
                     dwError != ERROR_NETNAME_DELETED ) {
                    ATQ_PRINTF(( DBG_CONTEXT,
                                 " Free Context(%08x, EP=%08x) to cache. "
                                 "Err=%d, sock=%08x\n",
                                 pAtqContext, pEndpoint,
                                 dwError,
                                 pAtqContext->hAsyncIO));
                }
            }

            DBG_REQUIRE( InterlockedDecrement(  &pAtqContext->lSyncTimeout) == 0);

            InterlockedDecrement( &pAtqContext->m_nIO); // balance entry count

            // balance original count
            InterlockedDecrement( &pAtqContext->m_nIO);
            // Free up the atq context without Reuse
            pAtqContext->CleanupAndRelease();
            return;
        }

        //
        //  Shutdown may close the socket from underneath us so don't
        //  assert, just warn.
        //

        if ( !pAtqContext->IsState( ACS_SOCK_LISTENING) ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                         "[AtqPoolThread] Warning-Socket state not listening\n"
                         ));
            DBG_CODE( pAtqContext->Print());
        }

        pAtqContext->MoveState( ACS_SOCK_CONNECTED);

        //
        // Remove the context from the pending list and put
        // it on the active list
        //

        DBG_ASSERT( pAtqContext->ContextList != NULL);
        pAtqContext->ContextList->MoveToActiveList( &pAtqContext->m_leTimeout);

        //
        //  Set the connection indicated flag.  After we return from
        //  the connection completion routine we assume it's
        //  safe to call the IO completion routine
        //  (or the connection indication routine should do cleanup
        //  and never issue an IO request).  This is primarily for
        //  the timeout thread.
        //

        pAtqContext->ConnectionCompletion( cbWritten, lpo);
    } else {


        //
        //  Not a connection completion indication. I/O completion.
        //

        //
        //  If an error occurred on a TransmitFile (or other IO),
        //  set the state to connected so the socket will get
        //  closed on cleanup
        //

        if ( !fRet &&
             pAtqContext->IsState( ACS_SOCK_UNCONNECTED)
             ){
            pAtqContext->MoveState( ACS_SOCK_CONNECTED);
        }

#if 0
        if (fDriverCall) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "[AtqPoolThread] pfnCompletion1(%08lx)\n",
                         pAtqContext ));
        }
#endif

        pAtqContext->IOCompletion( cbWritten, dwError, lpo);

        if (fDriverCall) {
            pAtqContext->ResetFlag( ACF_RECV_ISSUED);
            fRet = (reqContext->IoStatus2.Status == STATUS_SUCCESS);
            SetLastError( g_pfnRtlNtStatusToDosError(
                                         reqContext->IoStatus2.Status));

            //
            //  If an error occurred on a TransmitFile (or other IO),
            //  set the state to connected so the socket will get
            //  closed on cleanup
            //

            if ( !fRet &&
                 pAtqContext->IsState( ACS_SOCK_UNCONNECTED) ) {
                pAtqContext->MoveState( ACS_SOCK_CONNECTED);
            }

#if CC_REF_TRACKING
            //
            // ATQ notification trace
            //
            // Notify client context of status after 1st notification
            // This is for debugging purpose only.
            //
            // Code 0xfafafafa means we're processing a recv that
            // SPUD combined with another notification
            //

//            pAtqContext->NotifyIOCompletion( pAtqContext->m_acFlags, reqContext->IoStatus1.Status, 0xfafafafa );
#endif
            if ( pAtqContext->IsFlag( ACF_RECV_CALLED ) ) {
                fRecvCalled = TRUE;
                pAtqContext->ResetFlag( ACF_RECV_CALLED);
            }

            if ((reqContext->IoStatus1.Status == STATUS_SUCCESS) &&
                (pAtqContext->ClientContext != NULL) &&
                fRecvCalled ) {

#if CC_REF_TRACKING
                //
                // ATQ notification trace
                //
                // Notify client context of all non-oplock notification.
                // This is for debugging purpose only.
                //
                // Code 0xfdfdfdfd means we're processing a recv that
                // SPUD combined with another notification
                //

                pAtqContext->NotifyIOCompletion( cbWritten, (fRet) ? NO_ERROR: GetLastError(), 0xfdfdfdfd );
#endif


                IF_DEBUG( SPUD) {

                    ATQ_PRINTF(( DBG_CONTEXT,
                                 "[AtqPoolThread] pfnCompletion2(%08lx)\n",
                                 pAtqContext ));
                };

                pAtqContext->IOCompletion(
                                        (DWORD)reqContext->IoStatus2.Information,
                                        (fRet) ? NO_ERROR : GetLastError(),
                                        lpo
                                        );
            }
        }
    }

    DBG_ASSERT( pAtqContext->lSyncTimeout > 0);
    InterlockedDecrement( &pAtqContext->lSyncTimeout);

    //
    // We do an interlocked decrement on m_nIO to sync up state
    //  so that the context is not prematurely deleted.
    //

    if ( InterlockedDecrement(  &pAtqContext->m_nIO) == 0) {

        //
        // The number of outstanding ref holders is ZERO.
        // Free up this ATQ context.
        //
        // We really do not free up the context - but try to reuse
        //  it if possible
        //

        // free the atq context now or reuse if possible.
        AtqpReuseOrFreeContext( pAtqContext,
                                (pAtqContext->
                                 IsFlag( ACF_REUSE_CONTEXT) != 0)
                                );
    }

    return;
} // AtqpProcessContext()



DWORD
AtqPoolThread(
    LPDWORD param
    )
/*++

Routine Description:

    This is the pool thread wait and dispatch routine

  Arguments:
    param : unused.

  Return Value:

    Thread return value (ignored)

--*/
{
    PATQ_CONT    pAtqContext = NULL;
    BOOL         fRet;
    LPOVERLAPPED lpo;
    DWORD        cbWritten;
    DWORD        returnValue;
    DWORD        availThreads;

    for(;;) {

        pAtqContext = NULL;
        InterlockedIncrement( &g_cAvailableThreads );
        
        fRet = g_pfnGetQueuedCompletionStatus( g_hCompPort,
                                               &cbWritten,
                                               (PULONG_PTR)&pAtqContext,
                                               &lpo,
                                               g_msThreadTimeout );
                                               
        availThreads = InterlockedDecrement( &g_cAvailableThreads );

        if ( fRet || lpo ) {

            if ( pAtqContext == NULL) {
                if ( g_fShutdown ) {

                    //
                    // This is our signal to exit.
                    //

                    returnValue = NO_ERROR;
                    break;
                }

                OutputDebugString( "A null context received\n");
                continue;  // some error in the context has occured.
            }

            //
            // Make sure we're not running out of threads
            //

            if ( availThreads == 0 ) {

                //
                //  Make sure there are pool threads to service the request
                //

                (VOID)I_AtqCheckThreadStatus();
            }

            if ( (ULONG_PTR) param == ATQ_DEBUG_THREAD )
            {
                //
                // If this is a DEBUG thread, we are only concerned with new
                // connections.  Anything else we ignore. 
                //
                
                if ( pAtqContext->IsFlag( ACF_CONN_INDICATED ) )
                {
                    continue;
                } 
            }

            //
            // Capacity planning log
            //
            
            if (IISCapTraceFlag && pAtqContext)
            {
                PIIS_CAP_TRACE_INFO pCapTraceInfo = pAtqContext->GetCapTraceInfo();

                pCapTraceInfo->IISCapTraceHeader.TraceHeader.Class.Type = EVENT_TRACE_TYPE_START;
                pCapTraceInfo->IISCapTraceHeader.TraceHeader.Size       = sizeof (IIS_CAP_TRACE_HEADER);
                pCapTraceInfo->IISCapTraceHeader.TraceContext.DataPtr = (ULONGLONG) &pAtqContext;
                pCapTraceInfo->IISCapTraceHeader.TraceContext.Length  = sizeof(ULONG_PTR);
            
                pCapTraceInfo->IISCapTraceHeader.TraceHeader.Flags       = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;
                pCapTraceInfo->IISCapTraceHeader.TraceHeader.Guid        = IISCapTraceGuid;
                if ( ERROR_INVALID_HANDLE == TraceEvent ( IISCapTraceLoggerHandle,
                                               (PEVENT_TRACE_HEADER) pCapTraceInfo))            
                {
                    IISCapTraceFlag = FALSE;            
                }
            }

            AtqpProcessContext( pAtqContext, cbWritten, lpo, fRet);

            //
            // Capacity planning log
            //

            if (IISCapTraceFlag && pAtqContext)
            {
                PIIS_CAP_TRACE_INFO pCapTraceInfo = pAtqContext->GetCapTraceInfo();

                pCapTraceInfo->IISCapTraceHeader.TraceHeader.Class.Type = EVENT_TRACE_TYPE_END;
                pCapTraceInfo->IISCapTraceHeader.TraceHeader.Size       = sizeof (IIS_CAP_TRACE_HEADER);
                pCapTraceInfo->IISCapTraceHeader.TraceContext.DataPtr = (ULONGLONG) &pAtqContext;
                pCapTraceInfo->IISCapTraceHeader.TraceContext.Length  = sizeof(ULONG_PTR);
                pCapTraceInfo->IISCapTraceHeader.TraceHeader.Guid        = IISCapTraceGuid;
                pCapTraceInfo->IISCapTraceHeader.TraceHeader.Flags       = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;
            
                if ( ERROR_INVALID_HANDLE == TraceEvent ( IISCapTraceLoggerHandle,
                                                   (PEVENT_TRACE_HEADER) pCapTraceInfo))            
                {
                    IISCapTraceFlag = FALSE;            
                }
            }

        } else {

            //
            // don't kill the initial thread - any thread that doesn't have
            // pending I/Os go ahead and allow to die
            //

            if ( ((ULONG_PTR)param == ATQ_INITIAL_THREAD) && !g_fShutdown ) {
                continue;
            }

            if ( !g_fShutdown && GetLastError() == WAIT_TIMEOUT ) {

                NTSTATUS status;
                ULONG flag;

                status = NtQueryInformationThread(
                               NtCurrentThread(),
                               ThreadIsIoPending,
                               &flag,
                               sizeof(flag),
                               NULL );

                IF_DEBUG( TIMEOUT ) {
                    ATQ_PRINTF(( DBG_CONTEXT,
                                 "[ATQ Pool Thread] NtQueryInformationThread() returned 0x%08x, flag = %d\n",
                                 status,
                                 flag ));
                }

                if ( NT_SUCCESS( status ) && flag ) {

                    //
                    //  There are pending I/Os on this thread so don't exit
                    //

                    continue;
                }
            }

            IF_DEBUG( TIMEOUT ) {
                ATQ_PRINTF(( DBG_CONTEXT,
                             "[ATQ Pool Thread] Exiting thread 0x%x\n",
                             GetCurrentThread() ));
            }

            //
            //  An error occurred.  Either the thread timed out, the handle
            //  is going away or something bad happened.  Let the thread exit.
            //

            returnValue = GetLastError();

            break;
        }

    } // for

    if ( NULL != g_pfnExitThreadCallback) {

        //
        //  Client wishes to be told when ATQ threads terminate.
        //

        g_pfnExitThreadCallback();
    }

    if ( InterlockedDecrement( &g_cThreads ) == 0 ) {

        //
        // Wake up ATQTerminate()
        //
        IF_DEBUG( ERROR) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqPoolThread() - setting shutdown event %08x."
                         " g_cThreads = %d\n",
                         g_hShutdownEvent, g_cThreads
                         ));
        }

        SetEvent( g_hShutdownEvent );
    }

    return returnValue;
} // AtqPoolThread




BOOL
I_AtqCheckThreadStatus(
    PVOID Context
    )
/*++

Routine Description:

    This routine makes sure there is at least one thread in
    the thread pool.  We're fast and loose so a couple of extra
    threads may be created.

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    BOOL fRet = TRUE;
    BOOL fIsDebugThread = ( (ULONG_PTR) Context == ( ATQ_DEBUG_THREAD ) );

    //
    //  If no threads are available, kick a new one off up to the limit
    //
    //  WE NEED TO CHANGE THE CONDITIONS FOR STARTING ANOTHER THREAD
    //  IT SHOULD NOT BE VERY EASY TO START A THREAD ....
    //

    if ( ( (g_cAvailableThreads == 0) &&
           (g_cThreads < g_cMaxThreads) &&
           (g_cThreads < g_cMaxThreadLimit) ) ||
         fIsDebugThread )
    {
        HANDLE hThread;
        DWORD  dwThreadID;

        if ( !fIsDebugThread )
        { 
            InterlockedIncrement( &g_cThreads );
        }

        hThread = CreateThread( NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)AtqPoolThread,
                                Context,
                                0,
                                &dwThreadID );

        if ( hThread ) {
            CloseHandle( hThread );     // Free system resources
        } else if ( !fIsDebugThread ) {

            //
            // We fail if there are no threads running
            //

            if ( InterlockedDecrement( &g_cThreads ) == 0) {
                ATQ_PRINTF(( DBG_CONTEXT,
                    "AtqCheckThread: Cannot create ATQ threads\n"));
                fRet = FALSE;
            }
        }
    }

    return fRet;
} // I_AtqCheckThreadStatus()


/************************************************************
 *  Functions to Add/Delete Atq Contexts
 ************************************************************/


BOOL
I_AtqAddAsyncHandle(
    IN OUT PATQ_CONT  *    ppAtqContext,
    IN PATQ_ENDPOINT       pEndpoint,
    PVOID                  ClientContext,
    ATQ_COMPLETION         pfnCompletion,
    DWORD                  TimeOut,
    HANDLE                 hAsyncIO
    )
/*++

  Description:
    This functio adds creates a new NON-AcceptEx() based Atq Context,
     and includes it in proper lists fo ATQ Context management.


  Note:
    The client should call this after the IO handle is openned
    and before the first IO request is made

    Even in the case of failure, client should call AtqFreeContext() and
     free the memory associated with this object.

--*/
{
    BOOL         fReturn = TRUE;

    DBG_ASSERT( ppAtqContext != NULL);
    DBG_ASSERT( ClientContext != NULL);

    *ppAtqContext = NULL; // initialize

    if ( g_fShutdown) {

        SetLastError( ERROR_NOT_READY);
        return (FALSE);

    } else {

        PATQ_CONT    pAtqContext;

        //
        //  Note we take and release the lock here as we're
        //  optimizing for the reuseable context case
        //

        pAtqContext = I_AtqAllocContextFromCache();
        if ( pAtqContext == NULL) {

            return (FALSE);
        }

        //
        //  Fill out the context.  We set NextTimeout to INFINITE
        //  so the timeout thread will ignore this entry until an IO
        //  request is made unless this is an AcceptEx socket, that means
        //  we're about to submit the IO.
        //


        pAtqContext->InitWithDefaults(pfnCompletion,
                                      CanonTimeout( TimeOut ), hAsyncIO);

        //
        //  These data members are used if we're doing AcceptEx processing
        //

        pAtqContext->SetAcceptExBuffer( NULL);

        pAtqContext->InitNonAcceptExState(ClientContext);

        //
        // If an endpoint is provided, reference it
        //

        if ( pEndpoint != NULL ) {
            pEndpoint->Reference();
            pAtqContext->pEndpoint = pEndpoint;
        }

        *ppAtqContext = pAtqContext;
    }

    return (TRUE);

} // I_AtqAddAsyncHandle()




BOOL
I_AtqAddListenEndpointToPort(
    IN OUT PATQ_CONT    * ppAtqContext,
    IN PATQ_ENDPOINT    pEndpoint
    )
/*++

  Description:
    This function creates a new AtqContext for the given ListenSocket.
    It uses the listen socket as the AcceptEx() socket too for adding
     the atq context to the completion port.
    It assumes
      TimeOut to be INFINITE, with no Endpoint structure.

  Arguments:
    ppAtqContext - pointer to location that will contain the atq context
                   on successful return.
    pEndpoint - pointer to the endpoint.

  Returns:
    TRUE on success
    FALSE if there is a failure.

  Note:
    The caller should free the *ppAtqContext if there is a failure.

--*/
{
    BOOL         fReturn = TRUE;
    PATQ_CONT    pAtqContext;

    DBG_ASSERT( g_fUseAcceptEx); // only support AcceptEx() cases

    *ppAtqContext = NULL; // initialize

    if ( g_fShutdown) {

        SetLastError( ERROR_NOT_READY);
        return (FALSE);

    } else {

        //
        //  Note we take and release the lock here as we're
        //  optimizing for the reuseable context case
        //

        pAtqContext = I_AtqAllocContextFromCache();

        if ( pAtqContext == NULL) {

            return (FALSE);
        }

        //
        //  Fill out the context.
        //  We set the TimeOut for this object to be ATQ_INFINITE,
        //   since we do not want any interference from the Timeout loop.
        //

        pAtqContext->InitWithDefaults(
                                      pEndpoint->IoCompletion,
                                      ATQ_INFINITE,
                                      SOCKET_TO_HANDLE(pEndpoint->ListenSocket)
                                      );

        //
        //  These data members are used if we're doing AcceptEx processing
        //


        pAtqContext->SetAcceptExBuffer( NULL);

        //
        // Among AcceptEx ATQ Contexts,
        //  only the listen ATQ context will have the Endpoint field as NULL
        //
        pAtqContext->pEndpoint       = NULL;
        pAtqContext->SetFlag( ACF_ACCEPTEX_ROOT_CONTEXT );

        //
        // We set NextTimeout to INFINITE
        //  so the timeout thread will ignore this entry until an IO
        //  request is made unless this is an AcceptEx socket, that means
        //  we're about to submit the IO.

        DBG_ASSERT( g_fUseAcceptEx && pEndpoint->ConnectExCompletion != NULL);

        pAtqContext->InitAcceptExState( ATQ_INFINITE);

        *ppAtqContext = pAtqContext;
    }

    fReturn = I_AddAtqContextToPort( pAtqContext);

    return (fReturn);

} // I_AtqAddListenEndpointToPort()



BOOL
I_AtqAddAcceptExSocket(
    IN PATQ_ENDPOINT          pEndpoint,
    IN PATQ_CONT              pAtqContext
    )
/*++

Routine Description:

    Adds the AtqContext to the AcceptEx() waiters list,
    after allocating a new socket, since pAtqContext->hAsyncIO = NULL.

Arguments:

    pEndpoint - Information about this listenning socket
    patqReusedContext - optional context to use

Return Value:

    TRUE on success, FALSE on failure.
    On failure the caller should free the pAtqContext

--*/
{
    BOOL   fAddToPort = FALSE;
    BOOL   fSuccess = TRUE;

    DBG_ASSERT( pAtqContext != NULL);
    DBG_ASSERT( g_pfnAcceptEx != NULL);
    DBG_ASSERT( pAtqContext->pvBuff != NULL);
    DBG_ASSERT( !TsIsWindows95() );

    //
    //  If this listen socket isn't accepting new connections, just return
    //

    if ( !IS_BLOCK_ACTIVE(pEndpoint) ) {

        SetLastError( ERROR_NOT_READY );
        return ( FALSE);
    }

    //
    //  Use the supplied socket if any.
    //  Otherwise create a new socket
    //

    if ( pAtqContext->hAsyncIO == NULL) {

        SOCKET sAcceptSocket;

#if WINSOCK11
        sAcceptSocket = socket(
                            AF_INET,
                            SOCK_STREAM,
                            IPPROTO_TCP
                            );
#else
        sAcceptSocket = WSASocketW(
                            AF_INET,
                            SOCK_STREAM,
                            IPPROTO_TCP,
                            NULL,  // protocol info
                            0,     // Group ID = 0 => no constraints
                            (g_fUseFakeCompletionPort ?
                             0:
                             WSA_FLAG_OVERLAPPED // completion port notifications
                            )
                            );
#endif // WINSOCK11

        if ( sAcceptSocket == INVALID_SOCKET ) {

            fSuccess = FALSE;
            sAcceptSocket = NULL;

            //
            // no need to unlink from any list, since we did not add it to any
            //

        } else {

            //
            // Setup the accept ex socket in the atq context.
            //

            pAtqContext->hAsyncIO = SOCKET_TO_HANDLE(sAcceptSocket);
            pAtqContext->hJraAsyncIO  = (ULONG_PTR)sAcceptSocket | 0x80000000;
            fAddToPort = TRUE;
            DBG_ASSERT( fSuccess);
        }
    }

    if ( fSuccess) {

        DWORD        cbRecvd;

        if ( g_fShutdown) {

            //
            // no need to unlink from any list, since we did not add it to any
            //

            SetLastError( ERROR_NOT_READY);
            return (FALSE);
        }

        DBG_ASSERT( pAtqContext->hAsyncIO != NULL);

        //
        // 1. Call I_AtqAddAsyncHandleEx() to establish the links with
        //  proper AcceptEx & AtqContext processing lists.
        //
        //  After 1, the atqcontext will be in the lists, so
        //    cleanup should remove the context from proper lists.
        //
        // 2. Add the socket to Completion Port (if new),
        //    i.e. if fAddToPort is true)
        //
        // 3. Submit the new socket to AcceptEx() so that it may be
        //  used for processing about the new connections.
        //

        // 1.

        DBG_REQUIRE( pAtqContext->PrepareAcceptExContext(pEndpoint));

        // increment outstanding async io operations before AcceptEx() call
        InterlockedIncrement( &pAtqContext->m_nIO);

        fSuccess = (// 2.
                    ( !fAddToPort || I_AddAtqContextToPort( pAtqContext))
                    &&
                    // 3.
                    (
                     g_pfnAcceptEx( pEndpoint->ListenSocket,
                               HANDLE_TO_SOCKET(pAtqContext->hAsyncIO),
                               pAtqContext->pvBuff,
                               pEndpoint->InitialRecvSize,
                               MIN_SOCKADDR_SIZE,
                               MIN_SOCKADDR_SIZE,
                               &cbRecvd,
                               &pAtqContext->Overlapped )
                     ||
                     (GetLastError() == ERROR_IO_PENDING)
                     )
                    );

        if ( fSuccess) {

            //
            //  We've successfully added this socket, increment the count
            //

            InterlockedIncrement( &pEndpoint->nSocketsAvail );

        } else {

            ATQ_PRINTF(( DBG_CONTEXT,
                        "[AtqAddAcceptExSocket] Reusing an old context (%08x)"
                        " failed; error %d:%d, sAcceptSocket = %x, "
                        " pEndpoint = %lx, parm4 = %d, parm7 = %lx,"
                        " parm8 = %lx\n",
                        pAtqContext,
                        GetLastError(),
                        WSAGetLastError(),
                        pAtqContext->hAsyncIO,
                        pEndpoint,
                        pEndpoint->InitialRecvSize,
                        &cbRecvd,
                        &pAtqContext->Overlapped ));

            //
            // Unlink from the current list, where it was added as a result of
            //  step 1 above.
            //
            DBG_ASSERT( pAtqContext->ContextList != NULL);

            // balance the increment of the async operations outstanding
            DBG_REQUIRE( InterlockedDecrement( &pAtqContext->m_nIO) > 0);

            DBG_ASSERT( pAtqContext->m_leTimeout.Flink != NULL);
            pAtqContext->ContextList->
                RemoveFromList( &pAtqContext->m_leTimeout);

            //
            // balance the increment done
            // by pAtqContext->PrepareAcceptExContext()
            //
            DBG_REQUIRE( InterlockedDecrement( &pAtqContext->m_nIO) == 0);
            DBG_ASSERT( !fSuccess);

            //
            // the caller will free the Atq context on failure
            //
        }
    }

    return ( fSuccess);
} // I_AtqAddAcceptExSocket()




VOID
AtqpReuseContext( PATQ_CONT  pAtqContext)
/*++
  Description:
     This function attempts to reuse the ATQ context.
     It first cleans up the state and then uses the function
      I_AtqAddAccetpEx() socket to re-add the context to acceptex pool

  Arguments:
     pAtqContext - pointer to ATQ context that can be reused

  Returns:
     None
--*/
{
    PATQ_ENDPOINT pEndpoint = pAtqContext->pEndpoint;

    DBG_ASSERT( pEndpoint != NULL);
    DBG_ASSERT( pEndpoint->UseAcceptEx);

    //
    // Complete connection has been processed prior to coming here
    //

    DBG_ASSERT(pAtqContext->IsFlag( ACF_CONN_INDICATED));

    //
    // Remove from the current active list
    //
    if ( pAtqContext->m_leTimeout.Flink != NULL ) {
        pAtqContext->ContextList->RemoveFromList( &pAtqContext->m_leTimeout );
    }

    DBG_ASSERT( pAtqContext->m_leTimeout.Flink == NULL);
    DBG_ASSERT( pAtqContext->m_leTimeout.Blink == NULL);

    DBG_ASSERT( pEndpoint->Signature == ATQ_ENDPOINT_SIGNATURE );

    //
    //  Either there is no socket or the socket must be in the
    //  unconnected state (meaning reused after TransmitFile)
    //

    if ( !(!pAtqContext->hAsyncIO ||
           (pAtqContext->hAsyncIO &&
            pAtqContext->IsState( ACS_SOCK_UNCONNECTED |
                                  ACS_SOCK_TOBE_FREED)
            )
           )) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "[AtqReuseContext] Warning:"
                     " state = %08x, socket = %x (context %lx), "
                     " was Free called w/o close?\n",
                     pAtqContext->m_acState,
                     pAtqContext->hAsyncIO,
                     pAtqContext ));
        DBG_ASSERT( FALSE);
    }

    //
    //  Need to make sure that the state information is cleaned up
    //  before re-adding the context to the list. Also reset socket options.
    //

    if ( pAtqContext->hAsyncIO && pAtqContext->IsFlag(ACF_TCP_NODELAY))
    {
        INT optValue = 0;
        
        setsockopt( HANDLE_TO_SOCKET(pAtqContext->hAsyncIO), 
                    IPPROTO_TCP, 
                    TCP_NODELAY, 
                    (char *)&optValue,
                    sizeof(INT)
                  );

        //
        // No need to reset the flag. It will be 0'd out during the Add
        //
    }
    
    if ( !I_AtqAddAcceptExSocket(pEndpoint, pAtqContext) ) {

        //
        //  Failed to add the socket, free up the context without reuse
        //

        ATQ_PRINTF(( DBG_CONTEXT,
                     "[AtqpReuseContext] for (%08x) failed with "
                     " Error = %d;  Now freeing the context ...\n",
                     pAtqContext, GetLastError()
                     ));

        DBG_ASSERT( pAtqContext->m_nIO == 0);

        // free without reuse
        pAtqContext->CleanupAndRelease();
    }

    return;
} // AtqpReuseContext()



VOID
AtqpReuseOrFreeContext(
    PATQ_CONT    pAtqContext,
    BOOL         fReuseContext
    )
/*++
  Routine Description:
     This function does a free-up of the ATQ contexts. During the free-up
     path, we also attempt to reuse the ATQ context if the fReuseContext is
     set.

  Arguments:
     pAtqContext - pointer to the ATQ context that needs to be freedup
     fReuseContext - BOOLEAN flag indicating if this context should be reused

  Returns:
     None
--*/
{
    //
    // Get this object out of the Blocked Requests List.
    //

    if ( pAtqContext->IsBlocked()) {
        ATQ_REQUIRE( pAtqContext->m_pBandwidthInfo
                      ->RemoveFromBlockedList( pAtqContext ));
        DBG_ASSERT( !pAtqContext->IsBlocked());
    }

    DBG_ASSERT( pAtqContext->m_pBandwidthInfo != NULL);
    pAtqContext->m_pBandwidthInfo->Dereference();

    //
    //  Conditions for Reuse:
    //   1) fReuseContext == TRUE => caller wants us to reuse context
    //   2) pAtqContext->pEndpoint != NULL => valid endpoint exists
    //   3)  pEndpoint->UseAcceptEx => AcceptEx is enabled
    //   4)  pEndpoint->nSocketsAvail < nAcceptExOutstanding * 2 =>
    //           We do not have lots of outstanding idle sockets
    //       Condition (4) ensures that we do not flood the system
    //         with too many AcceptEx sockets as a result of some spike.
    //       AcceptEx sockets once added to the pool are hard to
    //         remove, because of various timing problems.
    //       Hence we want to prevent arbitrarily adding AcceptEx sockets.
    //
    //    In condition (4) I use a fudge factor of "2", so that
    //     we do continue to prevent reuse of sockets prematurely.
    //

    if ( fReuseContext &&
         (pAtqContext->pEndpoint != NULL)  &&
         (pAtqContext->pEndpoint->UseAcceptEx)
         &&
         ( g_fAlwaysReuseSockets ||
           ((DWORD )pAtqContext->pEndpoint->nSocketsAvail <
            pAtqContext->pEndpoint->nAcceptExOutstanding * 2)
           )
         ) {

        //
        // Call the function to reuse context. On failure
        // the AtqpReuseContext will free up the context
        //

        AcIncrement( CacAtqContextsReused);

        AtqpReuseContext( pAtqContext);

    } else {

        AcIncrement( CacAtqContextsCleanedup);

        pAtqContext->CleanupAndRelease();

    }

    return;
} // AtqpReuseOrFreeContext()



BOOL
I_AtqPrepareAcceptExSockets(
    IN PATQ_ENDPOINT          pEndpoint,
    IN DWORD                  nSockets
    )
/*++

Routine Description:

    Prepare specified number of AcceptEx sockets for the given
      ListenSocket in [pEndpoint]

Arguments:

    pEndpoint - Information about this listenning socket
    nSockets    - number of AcceptEx() sockets to be created.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    BOOL   fReturn;
    DWORD  cbBuffer;
    DWORD  i;

    if ( !g_fUseAcceptEx ) {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }

    //
    //  If this listen socket isn't accepting new connections, just return
    //

    if ( pEndpoint->State != AtqStateActive ) {
        SetLastError( ERROR_NOT_READY );
        return(FALSE);
    }

    if ( pEndpoint->fAddingSockets) {
        //
        // Someone is already adding sockets. Do not add more
        // Just return success
        //
        return ( TRUE);
    }

    pEndpoint->fAddingSockets = TRUE;

    // calculate the buffer size
    cbBuffer = pEndpoint->InitialRecvSize + 2* MIN_SOCKADDR_SIZE;

    for ( fReturn = TRUE, i = 0 ; fReturn && i++ < nSockets; ) {

        PVOID        pvBuff;
        PATQ_CONT    pAtqContext = NULL;

        //
        //  Alloc a buffer for receive data
        //  TBD: Pool all these buffers into one large buffer.
        //

        pvBuff = LocalAlloc( LPTR, cbBuffer);

        //
        //  Get the ATQ context now because we need its overlapped structure
        //

        if (pvBuff != NULL)
            pAtqContext = I_AtqAllocContextFromCache();


        //
        // Now check if allocations are valid and do proper cleanup on failure
        //

        if ( pvBuff == NULL || pAtqContext == NULL) {

            if ( pvBuff ) {
                LocalFree( pvBuff );
                pvBuff = NULL;
            }

            if ( pAtqContext ) {
                pAtqContext->Signature = ATQ_FREE_CONTEXT_SIGNATURE;
                I_AtqFreeContextToCache( pAtqContext );
                pAtqContext = NULL;
            }

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            fReturn = FALSE;
            break;
        } else {

            //
            // Add this socket to AtqContext lists & completion ports
            // From now on the called function will take care of freeing up
            //  pAtqContext, if there is a failure.
            //

            pAtqContext->SetAcceptExBuffer( pvBuff);
            pAtqContext->hAsyncIO = NULL;
            pAtqContext->hJraAsyncIO = 0;

            if ( !I_AtqAddAcceptExSocket(pEndpoint, pAtqContext) ) {

                //
                //  Failed to add the socket, free up the context without reuse
                //

                ATQ_PRINTF(( DBG_CONTEXT,
                             "[I_AtqPrepareAcceptExSockets] for Endpoint %08x"
                             " and AtqContext (%08x) failed with "
                             " Error = %d;  Now freeing the context ...\n",
                             pEndpoint, pAtqContext, GetLastError()
                             ));

                DWORD dwError = GetLastError();

                // free without reuse
                DBG_ASSERT( pAtqContext->m_nIO == 0);
                pAtqContext->CleanupAndRelease();

                SetLastError(dwError);
                
                fReturn = FALSE;
            }
        }
    } // for

    //
    // Finished Adding sockets. Indicate that by resetting the flab
    //

    pEndpoint->fAddingSockets = FALSE;

    ATQ_PRINTF(( DBG_CONTEXT,
                "PrepareAcceptExSockets( Endpoint[%08x], nSockets = %d)==>"
                " avail = %d; Total Refs = %d.\n",
                pEndpoint,
                nSockets,
                pEndpoint->nSocketsAvail,
                pEndpoint->m_refCount
                ));

    return ( fReturn);

} // I_AtqPrepareAcceptExSockets()



BOOL
I_AtqInitializeNtEntryPoints(
    VOID
    )
{

    HINSTANCE tmpInstance;

    //
    // load kernel32 and get NT specific entry points
    //

    tmpInstance = LoadLibrary("kernel32.dll");
    if ( tmpInstance != NULL ) {

        g_pfnReadDirChangesW = (PFN_READ_DIR_CHANGES_W)
            GetProcAddress( tmpInstance, "ReadDirectoryChangesW");

        DBG_ASSERT(g_pfnReadDirChangesW != NULL);

        //
        // We can free this because we are statically linked to it
        //

        FreeLibrary(tmpInstance);
    }

    g_hMSWsock = LoadLibrary( "mswsock.dll" );

    if ( g_hMSWsock != NULL ) {
       
        SOCKET          sTempSocket = INVALID_SOCKET;
        GUID            guidTransmitFile = WSAID_TRANSMITFILE;
        GUID            guidAcceptEx = WSAID_ACCEPTEX;
        GUID            guidGetAcceptExSockAddrs = WSAID_GETACCEPTEXSOCKADDRS;
        DWORD           cbReturned;

        //
        // Lets create a temporary socket so that we can use WSAIoctl to
        // get the direct function pointers for AcceptEx(), TransmitFile(),
        // etc.
        //
        
        sTempSocket = WSASocketW( AF_INET,
                                  SOCK_STREAM,
                                  IPPROTO_TCP,
                                  NULL,
                                  0,
                                  0 );
                                  
        if ( sTempSocket == INVALID_SOCKET )
        {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "Failed to create temp socket "
                         "for determining WinSock provider.  Error = %d",
                         WSAGetLastError() ));
            goto cleanup;
        }
        
        WSAIoctl( sTempSocket,
                  SIO_GET_EXTENSION_FUNCTION_POINTER,
                  (LPVOID) &guidTransmitFile,
                  sizeof( guidTransmitFile ),
                  &g_pfnTransmitFile,
                  sizeof( g_pfnTransmitFile ),
                  &cbReturned,
                  NULL,
                  NULL );
        
        WSAIoctl( sTempSocket,
                  SIO_GET_EXTENSION_FUNCTION_POINTER,
                  (LPVOID) &guidAcceptEx,
                  sizeof( guidAcceptEx ),
                  &g_pfnAcceptEx,
                  sizeof( g_pfnAcceptEx ),
                  &cbReturned,
                  NULL,
                  NULL );
                         
        WSAIoctl( sTempSocket,
                  SIO_GET_EXTENSION_FUNCTION_POINTER,
                  (LPVOID) &guidGetAcceptExSockAddrs,
                  sizeof( guidGetAcceptExSockAddrs ),
                  &g_pfnGetAcceptExSockaddrs,
                  sizeof( g_pfnGetAcceptExSockaddrs ),
                  &cbReturned,
                  NULL,
                  NULL );

        //
        // Close temporary socket
        //

        closesocket( sTempSocket );

        if ( !g_pfnAcceptEx ||
             !g_pfnGetAcceptExSockaddrs ||
             !g_pfnTransmitFile ) {

            //
            // This is bad.
            //

            DBG_ASSERT(FALSE);

            ATQ_PRINTF(( DBG_CONTEXT,
                "Failed to get entry points AE %x TF %x GAE %x\n",
                g_pfnAcceptEx, g_pfnTransmitFile,
                g_pfnGetAcceptExSockaddrs));

            goto cleanup;
        }

    } else {

        ATQ_PRINTF((DBG_CONTEXT,
            "Error %d in LoadLibrary[mswsock.dll]\n",
            GetLastError()));
        goto cleanup;
    }

    //
    // load ntdll
    //

    if ( g_fUseDriver ) {

        g_hNtdll = LoadLibrary( "ntdll.dll" );

        if ( g_hNtdll != NULL ) {

            g_pfnNtLoadDriver = (PFN_NT_LOAD_DRIVER)
                    GetProcAddress( g_hNtdll, "NtLoadDriver" );

            g_pfnRtlInitUnicodeString = (PFN_RTL_INIT_UNICODE_STRING)
                    GetProcAddress( g_hNtdll, "RtlInitUnicodeString" );

            g_pfnRtlNtStatusToDosError = (PFN_RTL_NTSTATUS_TO_DOSERR)
                    GetProcAddress( g_hNtdll, "RtlNtStatusToDosError" );

            g_pfnRtlInitAnsiString = (PFN_RTL_INIT_ANSI_STRING)
                    GetProcAddress( g_hNtdll, "RtlInitAnsiString" );

            g_pfnRtlAnsiStringToUnicodeString =
                (PFN_RTL_ANSI_STRING_TO_UNICODE_STRING)
                    GetProcAddress( g_hNtdll, "RtlAnsiStringToUnicodeString" );

            g_pfnRtlFreeHeap = (PFN_RTL_FREE_HEAP)
                    GetProcAddress( g_hNtdll, "RtlFreeHeap" );

            g_pfnRtlDosPathNameToNtPathName_U =
                (PFN_RTL_DOS_PATHNAME_TO_NT_PATHNAME)
                    GetProcAddress( g_hNtdll, "RtlDosPathNameToNtPathName_U" );

            if ( !g_pfnNtLoadDriver ||
                 !g_pfnRtlInitUnicodeString ||
                 !g_pfnRtlNtStatusToDosError ||
                 !g_pfnRtlInitAnsiString ||
                 !g_pfnRtlAnsiStringToUnicodeString ||
                 !g_pfnRtlFreeHeap ||
                 !g_pfnRtlDosPathNameToNtPathName_U ) {

                //
                // This is bad.
                //

                ATQ_PRINTF(( DBG_CONTEXT,
                    "Failed to get entry points for ntdll.dll\n"));

                DBG_ASSERT(FALSE);
                goto cleanup;
            }

        } else {

            ATQ_PRINTF((DBG_CONTEXT,
                "Error %d in LoadLibrary[ntdll.dll]\n", GetLastError()));
            goto cleanup;
        }
    }

    return(TRUE);

cleanup:

    if ( g_hNtdll != NULL ) {
        FreeLibrary( g_hNtdll );
        g_hNtdll = NULL;
    }

    if ( g_hMSWsock != NULL ) {
        FreeLibrary( g_hMSWsock );
        g_hMSWsock = NULL;
    }

    return(FALSE);
} // I_AtqInitializeEntryPoints
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\atqxmit.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       atqxmit.cxx

   Abstract:

        Contains internal support routines for transmit file

   Author:
        Johnson Apacible     (johnsona)      26-Mar-1996

--*/

#include "isatq.hxx"
#include "atqcport.hxx"

//
// local
//

VOID
I_FakeTransmitFileCompletion(
            IN PVOID ClientContext,
            IN DWORD BytesWritten,
            IN DWORD CompletionStatus,
            IN OVERLAPPED * lpo
            );



VOID
I_CleanupFakeTransmitFile(
        IN PATQ_CONT pAtqContext
        )
{
    //
    // Put the old completion routine back and free allocated buffers
    //

    pAtqContext->arInfo.uop.opFakeXmit.CurrentState = ATQ_XMIT_NONE;

    pAtqContext->pfnCompletion = pAtqContext->arInfo.uop.opFakeXmit.pfnCompletion;
    pAtqContext->ClientContext = pAtqContext->arInfo.uop.opFakeXmit.ClientContext;

    if ( pAtqContext->arInfo.uop.opFakeXmit.pBuffer != NULL ) {
        LocalFree(pAtqContext->arInfo.uop.opFakeXmit.pBuffer);
        pAtqContext->arInfo.uop.opFakeXmit.pBuffer = NULL;
    }

    return;

} // I_CleanupFakeTransmitFile


BOOL
SIOTransmitFile(
    IN PATQ_CONT                pAtqContext,
    IN HANDLE                   hFile,
    IN DWORD                    dwBytesInFile,
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers
    )
/*++

Routine Description:

    Posts a completion status on the completion port queue

    An IO pending error code is treated as a success error code

Arguments:

    patqContext - pointer to ATQ context
    hFile - Handle to the file to be read.
    dwBytesInFile - Number of bytes to read in the file
    lpTransmitBuffers - the transmitfile structure

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{

    DWORD   nRead   = 0;
    DWORD   cBuffer = 0;

    ATQ_ASSERT( pAtqContext->m_pBandwidthInfo != NULL );

    pAtqContext->m_pBandwidthInfo->IncTotalAllowedRequests();

    //
    // Store data
    //

    pAtqContext->pvBuff = NULL;

    pAtqContext->arInfo.atqOp        = AtqIoXmitFile;
    pAtqContext->arInfo.lpOverlapped = &pAtqContext->Overlapped;
    pAtqContext->arInfo.uop.opFakeXmit.hFile = hFile;

    if( lpTransmitBuffers != NULL ) {

        CopyMemory(
                &pAtqContext->arInfo.uop.opFakeXmit.TransmitBuffers,
                lpTransmitBuffers,
                sizeof(TRANSMIT_FILE_BUFFERS)
                );
    } else {

        ZeroMemory(
            &pAtqContext->arInfo.uop.opFakeXmit.TransmitBuffers,
            sizeof(pAtqContext->arInfo.uop.opFakeXmit.TransmitBuffers)
            );
    }

    pAtqContext->arInfo.uop.opFakeXmit.CurrentState  = ATQ_XMIT_START;

    //
    // Set current file offset to requested
    //

    pAtqContext->arInfo.uop.opFakeXmit.FileOffset =
                            pAtqContext->Overlapped.Offset;

    pAtqContext->arInfo.dwLastIOError = NOERROR;

    pAtqContext->arInfo.uop.opFakeXmit.pBuffer = NULL;
    pAtqContext->arInfo.uop.opFakeXmit.hFile = hFile;
    pAtqContext->arInfo.uop.opFakeXmit.BytesWritten = 0;
    pAtqContext->arInfo.uop.opFakeXmit.pBuffer = NULL;
    pAtqContext->arInfo.uop.opFakeXmit.pvLastSent = NULL;

    //
    // Check the number of bytes from file to send
    //

    if ( dwBytesInFile == 0 ) {

        //
        // Send the whole file.
        //

        dwBytesInFile = GetFileSize( hFile, NULL );

        if (dwBytesInFile >= pAtqContext->Overlapped.Offset) {
            dwBytesInFile -= pAtqContext->Overlapped.Offset;
        } else {
            ATQ_ASSERT(NULL);
            dwBytesInFile = 0;
        }
    }

    pAtqContext->arInfo.uop.opFakeXmit.BytesLeft = dwBytesInFile;

    //
    // replace the completion function with our own
    //

    pAtqContext->arInfo.uop.opFakeXmit.pfnCompletion =
                                pAtqContext->pfnCompletion;

    pAtqContext->arInfo.uop.opFakeXmit.ClientContext =
                                pAtqContext->ClientContext ;

    pAtqContext->ClientContext = pAtqContext;

    pAtqContext->pfnCompletion = I_FakeTransmitFileCompletion;

    //
    // Set the timeout
    //

    I_SetNextTimeout(pAtqContext);

    //
    // Kick in transmission loop
    //

    I_FakeTransmitFileCompletion(pAtqContext,
                                 0,
                                 NO_ERROR,
                                 &pAtqContext->Overlapped
                                 );

    SetLastError(NO_ERROR);
    return(TRUE);

} // SIOTransmitFile



VOID
I_FakeTransmitFileCompletion(
            IN PVOID ClientContext,
            IN DWORD BytesWritten,
            IN DWORD CompletionStatus,
            IN OVERLAPPED * lpo
            )
{
    PATQ_CONT   pAtqContext = (PATQ_CONT)ClientContext;
    DWORD       nWrite = 0;
    INT         err = NOERROR;
    OVERLAPPED  ov;
    OVERLAPPED  *pov = &ov;

    LPVOID      lpBufferSend;
    BOOL        fRes = FALSE;

    //
    // We need to use saved context value because of reasons above
    //

    ATQ_ASSERT(pAtqContext != NULL);

    pAtqContext->arInfo.uop.opFakeXmit.BytesWritten += BytesWritten;

    if ( CompletionStatus != NO_ERROR ) {

        //
        // An error occured, call the completion routine
        //

        pAtqContext->arInfo.dwLastIOError = CompletionStatus;
        goto call_completion;
    }

    //
    // Calculate pointer and number of bytes to send , depending on
    // the current state of transmission
    //

    if (pAtqContext->arInfo.uop.opFakeXmit.CurrentState == ATQ_XMIT_START) {

        //
        // We are just starting transmission, check if there is any
        // header part to send
        //

        nWrite = pAtqContext->arInfo.uop.opFakeXmit.TransmitBuffers.HeadLength;
        pAtqContext->arInfo.uop.opFakeXmit.CurrentState = ATQ_XMIT_HEADR_SENT;
        lpBufferSend =  pAtqContext->arInfo.uop.opFakeXmit.TransmitBuffers.Head;

        if ( (nWrite != 0) && (lpBufferSend != NULL) ) {
            goto AtqXmitSendData;
        }
    }

    if (pAtqContext->arInfo.uop.opFakeXmit.CurrentState == ATQ_XMIT_HEADR_SENT) {

        //
        // Clear written bytes counter, as this is very first iteration
        //

        BytesWritten = 0;

        //
        // Check if the file was zero lenth ?
        // Check if we have temporary transmission buffer
        //

        if (pAtqContext->arInfo.uop.opFakeXmit.pBuffer == NULL) {
            pAtqContext->arInfo.uop.opFakeXmit.pBuffer =
                            (PCHAR)LocalAlloc(LPTR, g_cbXmitBufferSize);
        }

        //
        // Set starting offset for the opened file
        //

        SetFilePointer(
                pAtqContext->arInfo.uop.opFakeXmit.hFile,
                pAtqContext->arInfo.uop.opFakeXmit.FileOffset,
                NULL,
                FILE_BEGIN
                );

        pAtqContext->arInfo.uop.opFakeXmit.CurrentState =
                                    ATQ_XMIT_TRANSMITTING_FILE;
    }

    if (pAtqContext->arInfo.uop.opFakeXmit.CurrentState ==
                                    ATQ_XMIT_TRANSMITTING_FILE) {

        //
        // We are  sending file itself - do we have anything left to do ?
        //

        if (pAtqContext->arInfo.uop.opFakeXmit.BytesLeft != 0) {

            //
            // Calculate offset for the next read .
            // This would be previous offset plus number of
            // bytes written on last operation.
            //

            pAtqContext->arInfo.uop.opFakeXmit.FileOffset += BytesWritten;

            if (pAtqContext->arInfo.uop.opFakeXmit.pBuffer != NULL) {

                //
                // Read file from current offset
                //

                DWORD   nToRead = g_cbXmitBufferSize;
                nToRead = min(
                            g_cbXmitBufferSize,
                            pAtqContext->arInfo.uop.opFakeXmit.BytesLeft);

                nWrite = 0;

                fRes = ReadFile(pAtqContext->arInfo.uop.opFakeXmit.hFile,
                                 pAtqContext->arInfo.uop.opFakeXmit.pBuffer,
                                 nToRead,
                                 &nWrite,
                                 NULL);

                if ( !fRes ) {
                    ATQ_PRINTF((DBG_CONTEXT,
                        "Error %d in ReadFile\n", GetLastError()));
                }

                if (pAtqContext->arInfo.uop.opFakeXmit.BytesLeft >= nWrite) {

                    pAtqContext->arInfo.uop.opFakeXmit.BytesLeft -= nWrite;
                } else {

                    pAtqContext->arInfo.uop.opFakeXmit.BytesLeft = 0;
                }

                IF_DEBUG(SIO) {
                    ATQ_PRINTF((DBG_CONTEXT,
                    "[TransmitFile(%lu)] Got data from file: context=%x Offset=%x nWrite=%x  fRes=%d \n",
                        GetCurrentThreadId(),pAtqContext,
                        pAtqContext->arInfo.uop.opFakeXmit.FileOffset,
                        nWrite,fRes));
                }

                //
                // Read succeeded and we got the data - send it to the client
                //

                if (fRes && (nWrite != 0) ) {
                    lpBufferSend = pAtqContext->arInfo.uop.opFakeXmit.pBuffer;
                    goto AtqXmitSendData;
                }

                //
                // If ReadFile failed - get error code and analyze it
                //

                if (!fRes) {

                    pAtqContext->arInfo.dwLastIOError = GetLastError();

                    //
                    // If we really shipped the whole file and error is EOF - ignore it
                    //

                    if ((pAtqContext->arInfo.dwLastIOError == ERROR_HANDLE_EOF) &&
                        (!pAtqContext->arInfo.uop.opFakeXmit.BytesLeft)) {

                        pAtqContext->arInfo.dwLastIOError = NO_ERROR;
                        fRes = TRUE;
                    }
                } else {

                    //
                    // If by some reasons we did not send all data planned we need
                    // to report failure, causing close for socket. Otherwise client will wait
                    // for the rest of the data and we will wait for client read
                    // Nb: In some cases Read returns success but does not really get any data
                    // we will treat this as premature EOF
                    //

                    if (pAtqContext->arInfo.uop.opFakeXmit.BytesLeft != 0) {
                        pAtqContext->arInfo.dwLastIOError = ERROR_HANDLE_EOF;
                        fRes = FALSE;
                    }
                }

            } else {

                //
                // Buffer was not allocated - fail transmission
                //

                ATQ_PRINTF((DBG_CONTEXT,"Failed to allocate buffer\n"));
                pAtqContext->arInfo.dwLastIOError = ERROR_NOT_ENOUGH_MEMORY;
            }

            //
            // Failed read from file, terminate transmission
            //

            if (!fRes) {

                //
                // Abnormal termination of Read - reset the client socket
                //

                ATQ_PRINTF((DBG_CONTEXT,"Read failed. Shutdown called\n"));
                shutdown( HANDLE_TO_SOCKET(pAtqContext->hAsyncIO), 1 );

                goto call_completion;
            }

        }

        //
        // Free temporary buffer as we no longer need it
        //

        if (pAtqContext->arInfo.uop.opFakeXmit.pBuffer) {
            LocalFree(pAtqContext->arInfo.uop.opFakeXmit.pBuffer);
            pAtqContext->arInfo.uop.opFakeXmit.pBuffer = NULL;
        }

        //
        // We are finished with this file
        //

        pAtqContext->arInfo.uop.opFakeXmit.CurrentState = ATQ_XMIT_FILE_DONE;
    }

    if (pAtqContext->arInfo.uop.opFakeXmit.CurrentState == ATQ_XMIT_FILE_DONE) {

        //
        // Check if there is any tail part to send
        //

        pAtqContext->arInfo.uop.opFakeXmit.CurrentState = ATQ_XMIT_TAIL_SENT;

        nWrite = pAtqContext->arInfo.uop.opFakeXmit.TransmitBuffers.TailLength;
        lpBufferSend =  pAtqContext->arInfo.uop.opFakeXmit.TransmitBuffers.Tail;
    }

AtqXmitSendData:

    //
    // If we have something to send - start i/o operation
    //

    if ( (nWrite != 0) && (lpBufferSend != NULL) ) {

        pAtqContext->arInfo.atqOp = AtqIoXmitFile;

        pAtqContext->arInfo.uop.opFakeXmit.pvLastSent = lpBufferSend;
        pAtqContext->arInfo.uop.opFakeXmit.cbBuffer = nWrite;

        InterlockedIncrement( &pAtqContext->m_nIO);
        SIOStartAsyncOperation(g_hCompPort,(PATQ_CONTEXT)pAtqContext);
        return ;
    }

    //
    // If it was the last phase of transmission -
    // clean up and send successful notification
    //

    if (pAtqContext->arInfo.uop.opFakeXmit.CurrentState != ATQ_XMIT_TAIL_SENT) {

    }

    pAtqContext->arInfo.dwLastIOError = NOERROR;

call_completion:

    //
    // Indicate no transmission in progress
    //

    pAtqContext->arInfo.uop.opFakeXmit.CurrentState = ATQ_XMIT_NONE;

    I_CleanupFakeTransmitFile(pAtqContext);

    pAtqContext->arInfo.dwTotalBytesTransferred =
                pAtqContext->arInfo.uop.opFakeXmit.BytesWritten;

    //
    // Clean up SIO state
    //

    pAtqContext->dwSIOFlags &= ~ATQ_SIO_FLAG_STATE_MASK;

    //
    // Queue context as completed
    //

    SIOPostCompletionStatus(g_hCompPort,
                            pAtqContext->arInfo.uop.opFakeXmit.BytesWritten,
                            (ULONG_PTR)pAtqContext,
                            pAtqContext->arInfo.lpOverlapped);

    return ;

} // I_FakeTransmitFileCompletion
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\place.inc ===
#
#  Places all of the internet binaries into the inetsrv tree
#

# enable building legoizable binaries
NTBBT=1

# define CAP related options
CAP_LINK_OPTIONS=-debugtype:coff -debug:mapped,partial
CAP_LIBS=$(SDK_LIB_PATH)\cap.lib
CAP_FLAGS= -Zd -Gh

!IFDEF CAP_PROFILE
USER_C_FLAGS=$(USER_C_FLAGS) $(CAP_FLAGS)
LINK_OPTIONS=$(CAP_LINK_OPTIONS)
!ENDIF

# define ICE-CAP related options
ICAP_LINK_OPTIONS=-debugtype:coff -debug:mapped,partial
ICAP_LIBS=$(SDK_LIB_PATH)\icap.lib $(SDK_LIB_PATH)\penter.lib
ICAP_FLAGS= -Zi -Gh

!IFDEF ICAP_PROFILE
USER_C_FLAGS=$(USER_C_FLAGS) $(ICAP_FLAGS)
LINK_OPTIONS=$(ICAP_LINK_OPTIONS)
!ENDIF

!ifdef _NT386TREE
# ## _NT386TREE=$(_NT386TREE)\iis
!endif

!ifdef _NTALPHATREE
# ## _NTALPHATREE=$(_NTALPHATREE)\iis
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\dllmain.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1996           **/
/**********************************************************************/

/*
    dllmain.cxx

        Library initialization for isatq.dll  --
           Internet Information Services - ATQ dll.

    FILE HISTORY:

        MuraliK     08-Apr-1996  Created.
*/


#include "isatq.hxx"
#include <inetinfo.h>


/************************************************************
 * Globals
 ************************************************************/

#ifdef _NO_TRACING_
DECLARE_DEBUG_VARIABLE();
#else
#include <initguid.h>
#ifndef _EXEXPRESS
DEFINE_GUID(IisAtqGuid,
0x784d8904, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DEFINE_GUID(IisKAtqGuid,
0x784d8915, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#endif
#endif
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();

const CHAR g_pszAtqRegLocation[] =
    INET_INFO_PARAMETERS_KEY /* string concatenation */
#ifndef _EXEXPRESS
        TEXT("\\isatq");
#else
        TEXT("\\ksatq");
#endif

//
// is winsock initialized?
//

BOOL    g_fSocketsInitialized = FALSE;



/************************************************************
 * Functions
 ************************************************************/



extern "C"
BOOL WINAPI
DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    BOOL  fReturn = TRUE;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:  {

        RECT rect;

#ifdef _NO_TRACING_
#ifndef _EXEXPRESS
        CREATE_DEBUG_PRINT_OBJECT( "isatq");
#else
        CREATE_DEBUG_PRINT_OBJECT( "ksatq");
#endif
#else
#ifndef _EXEXPRESS
        CREATE_DEBUG_PRINT_OBJECT( "isatq", IisAtqGuid);
#else
        CREATE_DEBUG_PRINT_OBJECT( "ksatq", IisKAtqGuid);
#endif
#endif
        if ( !VALID_DEBUG_PRINT_OBJECT()) {
            return ( FALSE);
        }

#ifdef _NO_TRACING_
        LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszAtqRegLocation, DEBUG_ERROR );
#endif

        //
        // Initialize sockets
        //

        {
            DWORD dwError = NO_ERROR;

            WSADATA   wsaData;
            INT       serr;

            //
            //  Connect to WinSock 2.0
            //

            serr = WSAStartup( MAKEWORD( 2, 0), &wsaData);

            if( serr != 0 ) {
                DBGPRINTF((DBG_CONTEXT,"WSAStartup failed with %d\n",serr));
                return(FALSE);
            }
            g_fSocketsInitialized = TRUE;
        }


        //
        // Initialize the platform type
        //
        INITIALIZE_PLATFORM_TYPE();
        ATQ_ASSERT(IISIsValidPlatform());

        //
        // Call a windows API that will cause windows server side thread to
        // be created for tcpsvcs.exe. This prevents a severe winsrv memory
        // leak when spawning processes and
        // gives a perf boost so the windows
        // console isn't brought up and torn down each time.   :(
        //

        if ( !TsIsWindows95() ) {
            (VOID) AdjustWindowRectEx( &rect,
                                      0,
                                      FALSE,
                                      0 );
            // fReturn already init to TRUE

        }
        
        INITIALIZE_CRITICAL_SECTION( &g_csInitTermLock );

        DisableThreadLibraryCalls( hDll );
        break;
    }

    case DLL_PROCESS_DETACH:

        if ( lpvReserved != NULL) {

            //
            //  Only Cleanup if there is a FreeLibrary() call.
            //

            break;
        }
        
        DeleteCriticalSection( &g_csInitTermLock );

        //
        // Cleanup sockets
        //

        if ( g_fSocketsInitialized ) {

            INT serr = WSACleanup();

            if ( serr != 0) {
                DBGPRINTF((DBG_CONTEXT,"WSACleanup failed with %d\n",
                           WSAGetLastError()));
            }
            g_fSocketsInitialized = FALSE;
        }

        DELETE_DEBUG_PRINT_OBJECT();
        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    default:
        break ;
    }

    return ( fReturn);

} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\spud.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

      spud.cxx

   Abstract:
      This module implements the user mode entry points for SPUD.SYS.
      SPUD = Special Purpose Utility Driver.

   Author:

       John Ballard ( jballard )     22-Oct-1996

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Common DLL

   Functions Exported:

       BOOL  AtqTransmitFileAndRecv();
       BOOL  AtqSendAndRecv();
       BOOL  AtqBatchRequest();

--*/


#include "isatq.hxx"
#include <tdi.h>
#include <afd.h>
#include <uspud.h>

#define WAIT_FOR_OPLOCK_THREAD  (30 * 1000)

static HANDLE g_hOplockThread;
static HANDLE g_hOplockCompPort;

BOOL
I_AtqOplockThreadInitialize(
    VOID
    );

VOID
I_AtqOplockThreadTerminate(
    VOID
    );

DWORD
I_AtqOplockThreadFunc(
    PVOID pv
    );
    
VOID
EnableLoadDriverPrivilege(
    VOID
    );

#define SPUD_REG_PATH   \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Spud"

BOOL
I_AtqSpudInitialize(
            VOID
            )
{
    NTSTATUS    status = STATUS_SUCCESS;
    UNICODE_STRING  DriverName;
    DWORD   Version = SPUD_VERSION;

    if ( !g_fUseDriver ) {
        return(FALSE);
    }

    //
    //  Create the completion port
    //

    g_hOplockCompPort = g_pfnCreateCompletionPort(INVALID_HANDLE_VALUE,
                                                  NULL,
                                                  0,
                                                  g_cConcurrency
                                                  );

    if ( !g_hOplockCompPort ) {

        DBGERROR(( DBG_CONTEXT, "Create OplockComp port failed. Last Error = 0x%x\n",
                    GetLastError()
                  ));
        goto disable_driver;
    }

    //
    // set up the oplock completion thread
    //
    if ( !I_AtqOplockThreadInitialize() ) {

        DBGERROR(( DBG_CONTEXT, "Create OplockComp thread failed. Last Error = 0x%x\n",
                    GetLastError()
                  ));
                  
        goto disable_driver;
    }
    
    //
    // Try to initialize SPUD.
    //

    status = SPUDInitialize(Version, g_hOplockCompPort);

    if( status == STATUS_INVALID_SYSTEM_SERVICE ) {

        //
        // This is probably because SPUD.SYS is not loaded,
        // so load it now.
        //

        EnableLoadDriverPrivilege();

        g_pfnRtlInitUnicodeString( &DriverName, SPUD_REG_PATH );
        status = g_pfnNtLoadDriver( &DriverName );
        if ( ( status != STATUS_SUCCESS ) &&
             ( status != STATUS_IMAGE_ALREADY_LOADED ) ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                         "NtLoadDriver failed!!! status == %08lx\n",
                         status
                         ));
            goto disable_driver;
        }

        //
        // Now that we've successfully loaded SPUD.SYS, retry
        // the initialization.
        //

        status = SPUDInitialize(Version, g_hOplockCompPort);

    }

    if ( status != STATUS_SUCCESS ) {

        if ( status == STATUS_INVALID_DEVICE_REQUEST ) {
            SPUDTerminate();
            if ( SPUDInitialize(Version, g_hOplockCompPort) == STATUS_SUCCESS ) {
                return TRUE;
            }
        }

        ATQ_PRINTF(( DBG_CONTEXT,
                     "SPUDInitialize failed!!! status == %08lx\n",
                     status
                     ));
        goto disable_driver;
    }

    return TRUE;

disable_driver:

    g_fUseDriver = FALSE;
    if (status != STATUS_SUCCESS) {
        SetLastError(g_pfnRtlNtStatusToDosError(status));
    }

    ATQ_PRINTF((DBG_CONTEXT, "SPUDInitialize: Disabling driver\n"));
    return(FALSE);
} // I_AtqSpudInitialize


BOOL
I_AtqSpudTerminate()
{
    NTSTATUS    status;

    status = SPUDTerminate();
    if ( status != STATUS_SUCCESS ) {

        IF_DEBUG(ERROR) {
            ATQ_PRINTF(( DBG_CONTEXT,
                     "SPUDTerminate failed!!! status == %08lx\n",
                     status
                     ));
        }
        return FALSE;
    }

    I_AtqOplockThreadTerminate();

    DBG_REQUIRE( CloseHandle(g_hOplockCompPort) );

    return TRUE;
}



BOOL
I_AtqOplockThreadInitialize(
    VOID
    )
{
    DWORD idThread;

    //
    //  Create the Oplock Completion thread
    //

    g_hOplockThread = CreateThread( NULL,
                                    0,
                                    (LPTHREAD_START_ROUTINE) I_AtqOplockThreadFunc,
                                    NULL,
                                    0,
                                    &idThread );

    if ( !g_hOplockThread )
    {
        DWORD err = GetLastError();

        DBGPRINTF(( DBG_CONTEXT,
            "Unable to create Oplock thread[err %d]\n", err));

        SetLastError(err);
        return FALSE;
    }

    return TRUE;
}

VOID
I_AtqOplockThreadTerminate(
    VOID
    )
{
    //
    // tell the thread to exit by posting a completion with a NULL context
    //
    BOOL        fRes;
    OVERLAPPED  overlapped;

    //
    // Post a message to the completion port for the thread
    // telling it to exit. The indicator is a NULL context in the
    // completion.
    //

    ZeroMemory( &overlapped, sizeof(OVERLAPPED) );

    fRes = g_pfnPostCompletionStatus( g_hOplockCompPort,
                                      0,
                                      0,
                                      &overlapped );

    DBG_ASSERT( (fRes == TRUE) ||
               ( (fRes == FALSE) &&
                (GetLastError() == ERROR_IO_PENDING) )
               );


    //
    // Wait for the thread to exit
    //
        
    if ( WAIT_TIMEOUT == WaitForSingleObject( g_hOplockThread,
                                              WAIT_FOR_OPLOCK_THREAD ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[I_AtqOplockThreadTerminate] Warning - WaitForSingleObject timed out\n" ));
    }

    DBG_REQUIRE( CloseHandle( g_hOplockThread ));
}


DWORD
I_AtqOplockThreadFunc(
    PVOID pv
    )
{
    PATQ_CONT    pAtqContext;
    BOOL         fRet;
    LPOVERLAPPED lpo;
    DWORD        cbWritten;
    DWORD        availThreads;

    for(;;) {

        pAtqContext = NULL;

        fRet = g_pfnGetQueuedCompletionStatus( g_hOplockCompPort,
                                               &cbWritten,
                                               (PULONG_PTR)&pAtqContext,
                                               &lpo,
                                               g_msThreadTimeout );


        if ( fRet || lpo ) {

            if ( pAtqContext == NULL) {
                if ( g_fShutdown ) {

                    //
                    // This is our signal to exit. (Check for I/O first?)
                    //

                    break;
                }

                DBGPRINTF((DBG_CONTEXT, "OplockThread: A null context received\n"));
                continue;  // some error in the context has occured.
            }


            AtqpProcessContext( pAtqContext, cbWritten, lpo, fRet);
        }

    } // for

    return 0;
}



BOOL
I_AtqTransmitFileAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN HANDLE                   hFile,                  // handle of file to read
    IN DWORD                    dwBytesInFile,          // Bytes to transmit
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers,      // transmit buffer structure
    IN DWORD                    dwTFFlags,              // TF Flags
    IN LPWSABUF                 pwsaBuffers,            // Buffers for recv
    IN DWORD                    dwBufferCount
    )
/*++
Routine Description:

    Calls SPUDTransmitFileAndRecv().  Cannot be blocked by bandwidth throttler

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)
--*/
{
        ULONG   status;
        AFD_TRANSMIT_FILE_INFO transmitInfo;
        AFD_RECV_INFO          recvInfo;
        PATQ_CONT              patqCont = (PATQ_CONT)patqContext;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                     "I_AtqTransmitFileAndRecv(%08lx) called.\n", patqContext));
        }

        transmitInfo.WriteLength.QuadPart = dwBytesInFile;
        transmitInfo.SendPacketLength = 0;
        transmitInfo.FileHandle = hFile;
        transmitInfo.Flags = dwTFFlags;
        if ( lpTransmitBuffers != NULL ) {
            transmitInfo.Head = lpTransmitBuffers->Head;
            transmitInfo.HeadLength = lpTransmitBuffers->HeadLength;
            transmitInfo.Tail = lpTransmitBuffers->Tail;
            transmitInfo.TailLength = lpTransmitBuffers->TailLength;
        } else {
            transmitInfo.Head = NULL;
            transmitInfo.HeadLength = 0;
            transmitInfo.Tail = NULL;
            transmitInfo.TailLength = 0;
        }

        transmitInfo.Offset.LowPart = patqContext->Overlapped.Offset;
        transmitInfo.Offset.HighPart = 0;

        recvInfo.BufferArray = pwsaBuffers;
        recvInfo.BufferCount = dwBufferCount;
        recvInfo.AfdFlags = AFD_OVERLAPPED;
        recvInfo.TdiFlags = TDI_RECEIVE_NORMAL;
        patqCont->ResetFlag( ACF_RECV_CALLED);

        //
        // Set this flag here to avoid a race with completion handling code
        // Reset if SPUDTransmitFileAndRecv fails
        //
        patqCont->SetFlag( ACF_RECV_ISSUED);

        status = SPUDTransmitFileAndRecv( patqCont->hAsyncIO,
                                         &transmitInfo,
                                         &recvInfo,
                                         &patqCont->spudContext
                                         );

#if CC_REF_TRACKING
            //
            // ATQ notification trace
            //
            // Notify client context of all non-oplock notification.
            // This is for debugging purpose only.
            //
            // Code 0xfbfbfbfb indicates a SPUD TransmitFileAndRecv request
            //

            patqCont->NotifyIOCompletion( 0, status, 0xfbfbfbfb );
#endif

        if ( status != STATUS_SUCCESS &&
             status != STATUS_PENDING ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                         "SPUDTransmitFileAndRecv failed!!! status == %08lx\n",
                         status
                         ));
            SetLastError(g_pfnRtlNtStatusToDosError(status));
            patqCont->MoveState( ACS_SOCK_CONNECTED);
            patqCont->ResetFlag( ACF_RECV_ISSUED);
            return FALSE;
        }

        return TRUE;
}

BOOL
AtqTransmitFileAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN HANDLE                   hFile,                  // handle of file to read
    IN DWORD                    dwBytesInFile,          // Bytes to transmit
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers,      // transmit buffer structure
    IN DWORD                    dwTFFlags,              // TF Flags
    IN LPWSABUF                 pwsaBuffers,            // Buffers for recv
    IN DWORD                    dwBufferCount
    )
{
    BOOL fRes;
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    if ( !g_fUseDriver || pContext->IsFlag( ACF_RECV_ISSUED) ) {
        BOOL            fRes;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                "AtqTransmitFileAndRecv(%08lx) g_fUseDriver == FALSE\n Calling AtqTransmitFile.\n", patqContext));
        }

        return AtqTransmitFile( patqContext,
                                hFile,
                                dwBytesInFile,
                                lpTransmitBuffers,
                                dwTFFlags );
    }

    I_SetNextTimeout(pContext);

    pContext->BytesSent = dwBytesInFile;

    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent += pwsaBuffers->len;
    if ( dwBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaBuffers + 1;
              pWsaBuf <= (pwsaBuffers + dwBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    if ( dwTFFlags == 0 ) {

        //
        // If no flags are set, then we can attempt to use the special
        // write-behind flag.  This flag can cause the TransmitFile to
        // complete immediately, before the send actually completes.
        // This can be a significant performance improvement inside the
        // system.
        //

        dwTFFlags = TF_WRITE_BEHIND;

    }

    InterlockedIncrement( &pContext->m_nIO);

    switch ( pBandwidthInfo->QueryStatus( AtqIoXmitFileRecv ) )
    {
    case StatusAllowOperation:

        pBandwidthInfo->IncTotalAllowedRequests();

        fRes = I_AtqTransmitFileAndRecv( patqContext,
                                         hFile,
                                         dwBytesInFile,
                                         lpTransmitBuffers,
                                         dwTFFlags,
                                         pwsaBuffers,
                                         dwBufferCount ) ||
                (GetLastError() == ERROR_IO_PENDING);

        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

        break;

    case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoXmitFileRecv;
        pContext->arInfo.lpOverlapped = &pContext->Overlapped;

        pContext->arInfo.uop.opXmitRecv.hFile = hFile;
        pContext->arInfo.uop.opXmitRecv.dwBytesInFile = dwBytesInFile;
        pContext->arInfo.uop.opXmitRecv.lpXmitBuffers = lpTransmitBuffers;
        pContext->arInfo.uop.opXmitRecv.dwTFFlags     = dwTFFlags;
        pContext->arInfo.uop.opXmitRecv.dwBufferCount = dwBufferCount;

        if ( dwBufferCount == 1) {
            pContext->arInfo.uop.opXmitRecv.buf1.len = pwsaBuffers->len;
            pContext->arInfo.uop.opXmitRecv.buf1.buf = pwsaBuffers->buf;
            pContext->arInfo.uop.opXmitRecv.pBufAll  = NULL;
        } else {

            DBG_ASSERT( dwBufferCount > 1);

            WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwBufferCount * sizeof (WSABUF));
            if ( NULL != pBuf) {
                pContext->arInfo.uop.opXmitRecv.pBufAll = pBuf;
                CopyMemory( pBuf, pwsaBuffers,
                            dwBufferCount * sizeof(WSABUF));
            } else {
                InterlockedDecrement( &pContext->m_nIO);
                fRes = FALSE;
                break;
            }
        }

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext);
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

    default:
        ATQ_ASSERT( FALSE);
        InterlockedDecrement( &pContext->m_nIO);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;

    } // switch()

    return fRes;
} // AtqTransmitFileAndRecv()

BOOL
I_AtqSendAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN LPWSABUF                 pwsaSendBuffers,        // buffers for send
    IN DWORD                    dwSendBufferCount,      // count of buffers for send
    IN LPWSABUF                 pwsaRecvBuffers,        // Buffers for recv
    IN DWORD                    dwRecvBufferCount       // count of buffers for recv
    )
/*++
Routine Description:

    Calls SPUDSendAndRecv().  Cannot be blocked by bandwidth throttler.

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)
--*/
{
        ULONG   status;
        AFD_SEND_INFO          sendInfo;
        AFD_RECV_INFO          recvInfo;
        PATQ_CONT              patqCont = (PATQ_CONT)patqContext;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                 "I_AtqSendAndRecv(%08lx) called.\n", patqContext));
        }

        sendInfo.BufferArray = pwsaSendBuffers;
        sendInfo.BufferCount = dwSendBufferCount;
        sendInfo.AfdFlags = AFD_OVERLAPPED;
        sendInfo.TdiFlags = 0;

        recvInfo.BufferArray = pwsaRecvBuffers;
        recvInfo.BufferCount = dwRecvBufferCount;
        recvInfo.AfdFlags = AFD_OVERLAPPED;
        recvInfo.TdiFlags = TDI_RECEIVE_NORMAL;
        patqCont->ResetFlag( ACF_RECV_CALLED);

        //
        // Set this flag before SPUD call to avoid a race with completion
        // Reset if SPUDSendAndRecv fails
        //
        patqCont->SetFlag( ACF_RECV_ISSUED);

        status = SPUDSendAndRecv( patqCont->hAsyncIO,
                                 &sendInfo,
                                 &recvInfo,
                                 &patqCont->spudContext
                                 );

        if ( status != STATUS_SUCCESS &&
             status != STATUS_PENDING ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                     "SPUDSendAndRecv failed!!! status == %08lx\n",
                     status
                     ));
             SetLastError(g_pfnRtlNtStatusToDosError(status));
             patqCont->ResetFlag( ACF_RECV_ISSUED);
             return FALSE;
        }

        return TRUE;
}

BOOL
AtqSendAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN LPWSABUF                 pwsaSendBuffers,        // buffers for send
    IN DWORD                    dwSendBufferCount,      // count of buffers for send
    IN LPWSABUF                 pwsaRecvBuffers,        // Buffers for recv
    IN DWORD                    dwRecvBufferCount       // count of buffers for recv
    )
{
    BOOL fRes;
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
            "AtqSendAndRecv(%08lx) called.\n", patqContext));
    }

    if ( !g_fUseDriver || pContext->IsFlag( ACF_RECV_ISSUED) ) {

        BOOL            fRes;
        DWORD           cbWritten;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                 "AtqSendAndRecv(%08lx) g_fUseDriver == FALSE\n Calling AtqWriteSocket.\n", patqContext));
        }

        return AtqWriteSocket( patqContext,
                               pwsaSendBuffers,
                               dwSendBufferCount,
                               &patqContext->Overlapped );
    }

    InterlockedIncrement( &pContext->m_nIO);

    I_SetNextTimeout(pContext);

    //
    // count the number of bytes
    //

    DBG_ASSERT( dwSendBufferCount >= 1);
    pContext->BytesSent = pwsaSendBuffers->len;
    if ( dwSendBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaSendBuffers + 1;
            pWsaBuf <= (pwsaSendBuffers + dwSendBufferCount);
            pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }


    DBG_ASSERT( dwRecvBufferCount >= 1);
    pContext->BytesSent += pwsaRecvBuffers->len;
    if ( dwRecvBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaRecvBuffers + 1;
              pWsaBuf <= (pwsaRecvBuffers + dwRecvBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    switch ( pBandwidthInfo->QueryStatus( AtqIoSendRecv ) )
    {
    case StatusAllowOperation:

        pBandwidthInfo->IncTotalAllowedRequests();

        fRes = I_AtqSendAndRecv( patqContext,
                                 pwsaSendBuffers,
                                 dwSendBufferCount,
                                 pwsaRecvBuffers,
                                 dwRecvBufferCount ) ||
                (GetLastError() == ERROR_IO_PENDING);

        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

        break;

    case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoSendRecv;
        pContext->arInfo.lpOverlapped = &pContext->Overlapped;
        pContext->arInfo.uop.opSendRecv.dwSendBufferCount = dwSendBufferCount;
        pContext->arInfo.uop.opSendRecv.dwRecvBufferCount = dwRecvBufferCount;

        if ( dwSendBufferCount == 1) {
            pContext->arInfo.uop.opSendRecv.sendbuf1.len = pwsaSendBuffers->len;
            pContext->arInfo.uop.opSendRecv.sendbuf1.buf = pwsaSendBuffers->buf;
            pContext->arInfo.uop.opSendRecv.pSendBufAll  = NULL;
        } else {

            DBG_ASSERT( dwSendBufferCount > 1);

            WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwSendBufferCount * sizeof (WSABUF));
            if ( NULL != pBuf) {
                pContext->arInfo.uop.opSendRecv.pSendBufAll = pBuf;
                CopyMemory( pBuf, pwsaSendBuffers,
                            dwSendBufferCount * sizeof(WSABUF));
            } else {
                InterlockedDecrement( &pContext->m_nIO);
                fRes = FALSE;
                break;
            }
        }

        if ( dwRecvBufferCount == 1) {
            pContext->arInfo.uop.opSendRecv.recvbuf1.len = pwsaRecvBuffers->len;
            pContext->arInfo.uop.opSendRecv.recvbuf1.buf = pwsaRecvBuffers->buf;
            pContext->arInfo.uop.opSendRecv.pRecvBufAll = NULL;
        } else {

            DBG_ASSERT( dwRecvBufferCount > 1);

            WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwRecvBufferCount * sizeof (WSABUF));
            if ( NULL != pBuf) {
                pContext->arInfo.uop.opSendRecv.pRecvBufAll = pBuf;
                CopyMemory( pBuf, pwsaRecvBuffers,
                            dwRecvBufferCount * sizeof(WSABUF));
            } else {
                InterlockedDecrement( &pContext->m_nIO);
                fRes = FALSE;
                break;
            }
        }

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext);
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

    default:
        ATQ_ASSERT( FALSE);
        InterlockedDecrement( &pContext->m_nIO);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;

    } // switch()

    return fRes;
} // AtqSendAndRecv()




//
//  Short routine to enable the LoadDriverPrivilege for loading spud.sys
//

VOID EnableLoadDriverPrivilege(
    VOID
    )
{
    HANDLE ProcessHandle = NULL;
    HANDLE TokenHandle = NULL;
    BOOL Result;
    LUID LoadDriverValue;
    TOKEN_PRIVILEGES * TokenPrivileges;
    CHAR buf[ 5 * sizeof(TOKEN_PRIVILEGES) ];

    ProcessHandle = OpenProcess(
                        PROCESS_QUERY_INFORMATION,
                        FALSE,
                        GetCurrentProcessId()
                        );

    if ( ProcessHandle == NULL ) {

        //
        // This should not happen
        //

        goto Cleanup;
    }


    Result = OpenProcessToken (
                 ProcessHandle,
                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                 &TokenHandle
                 );

    if ( !Result ) {

        //
        // This should not happen
        //

        goto Cleanup;

    }

    //
    // Find out the value of LoadDriverPrivilege
    //


    Result = LookupPrivilegeValue(
                 NULL,
                 "SeLoadDriverPrivilege",
                 &LoadDriverValue
                 );

    if ( !Result ) {

        goto Cleanup;
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges = (TOKEN_PRIVILEGES *) buf;

    TokenPrivileges->PrivilegeCount = 1;
    TokenPrivileges->Privileges[0].Luid = LoadDriverValue;
    TokenPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    (VOID) AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                TokenPrivileges,
                sizeof(buf),
                NULL,
                NULL
                );
Cleanup:

    if ( TokenHandle )
    {
        CloseHandle( TokenHandle );
    }

    if ( ProcessHandle )
    {
        CloseHandle( ProcessHandle );
    }
}



HANDLE
AtqCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwFlagsAndAttributes,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR sd,
    ULONG Length,
    PULONG LengthNeeded,
    PSPUD_FILE_INFORMATION pFileInfo
    )
{

    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    ULONG CreateFlags;
    DWORD SQOSFlags;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    LARGE_INTEGER liZero;

    liZero.QuadPart = 0;

    CreateFlags = 0;

//    DbgPrint("AtqCreateFileW - %ws\n", lpFileName );


    TranslationStatus = g_pfnRtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS ? 0 : OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );


    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle ) {
            Obja.Attributes |= OBJ_INHERIT;
            }
        }

    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING ? FILE_NO_INTERMEDIATE_BUFFERING : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_SEQUENTIAL_SCAN ? FILE_SEQUENTIAL_ONLY : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_RANDOM_ACCESS ? FILE_RANDOM_ACCESS : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS ? FILE_OPEN_FOR_BACKUP_INTENT : 0 );


    Status = SPUDCreateFile(
                &Handle,
                &Obja,
                &IoStatusBlock,
                dwFlagsAndAttributes & (FILE_ATTRIBUTE_VALID_FLAGS), // & ~FILE_ATTRIBUTE_DIRECTORY),
                dwShareMode,
                CreateFlags,
                si,
                sd,
                Length,
                LengthNeeded,
                NULL,
                liZero,
                NULL,
                pFileInfo
                );

    g_pfnRtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ) {
             SetLastError(ERROR_INVALID_ACCESS);
             return Handle;
        }
        if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {
            SetLastError(ERROR_ACCESS_DENIED);
        } else {
            SetLastError(g_pfnRtlNtStatusToDosError(Status));
        }
        return INVALID_HANDLE_VALUE;
    }

    SetLastError(ERROR_SUCCESS);
    return Handle;
}

BOOL
AtqSpudInitialized(
    VOID
)
{
    return g_fUseDriver;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\xmitnt.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       atqxmit.cxx

   Abstract:

        Contains internal support routines for transmit file

   Author:
        Johnson Apacible     (johnsona)      26-Mar-1996

--*/

#include "isatq.hxx"


//
// Size of buffers for fake xmits
//

DWORD g_cbXmitBufferSize = ATQ_REG_DEF_NONTF_BUFFER_SIZE;

VOID
I_CleanupFakeTransmitFile(
        IN PATQ_CONT pContext
        )
{
    //
    // Put the old completion routine back and free allocated buffers
    //

    pContext->pfnCompletion = pContext->arInfo.uop.opFakeXmit.pfnCompletion;
    pContext->ClientContext = pContext->arInfo.uop.opFakeXmit.ClientContext;
    if ( pContext->arInfo.uop.opFakeXmit.pBuffer != NULL ) {
        LocalFree(pContext->arInfo.uop.opFakeXmit.pBuffer);
        pContext->arInfo.uop.opFakeXmit.pBuffer = NULL;
    }

    //
    // Clean up the event
    //

    if ( pContext->arInfo.uop.opFakeXmit.hOvEvent != NULL ) {
        CloseHandle( pContext->arInfo.uop.opFakeXmit.hOvEvent );
        pContext->arInfo.uop.opFakeXmit.hOvEvent = NULL;
    }
    return;

} // I_CleanupFakeTransmitFile

VOID
I_FakeTransmitFileCompletion(
            IN PVOID ClientContext,
            IN DWORD BytesWritten,
            IN DWORD CompletionStatus,
            IN OVERLAPPED * lpo
            )
{
    PATQ_CONT pContext;
    DWORD nWrite = 0;
    DWORD nRead;
    PCHAR buffer;
    INT err;
    PVOID tail;
    OVERLAPPED ov;
    OVERLAPPED *pov = &ov;

    pContext = (PATQ_CONT)ClientContext;
    pContext->arInfo.uop.opFakeXmit.BytesWritten += BytesWritten;

    if ( CompletionStatus != NO_ERROR ) {

        //
        // An error occured, call the completion routine
        //

        goto call_completion;
    }

    //
    // We already have a buffer of size g_cbXmitBufferSize
    //

    nRead = pContext->arInfo.uop.opFakeXmit.BytesLeft;
    buffer = pContext->arInfo.uop.opFakeXmit.pBuffer;
    ATQ_ASSERT(buffer != NULL);

    if ( nRead > 0 ) {

        //
        // Do the read at the specified offset
        //

        pov->OffsetHigh = 0;
        pov->Offset = pContext->arInfo.uop.opFakeXmit.FileOffset;
        pov->hEvent = pContext->arInfo.uop.opFakeXmit.hOvEvent;
        ATQ_ASSERT(pov->hEvent != NULL);
        ResetEvent(pov->hEvent);

        if (!ReadFile(
                    pContext->arInfo.uop.opFakeXmit.hFile,
                    buffer,
                    g_cbXmitBufferSize,
                    &nRead,
                    pov
                    ) ) {

            err = GetLastError();
            if ( (err != ERROR_IO_PENDING) ||
                 !GetOverlappedResult(
                        pContext->arInfo.uop.opFakeXmit.hFile,
                        pov,
                        &nRead,
                        TRUE )) {

                CompletionStatus = GetLastError();
                ATQ_PRINTF(( DBG_CONTEXT,"ReadFile error %d\n",CompletionStatus));
                goto call_completion;
            }
        }

        //
        // if nRead is zero, we reached the EOF.
        //

        if ( nRead > 0 ) {

            //
            // Update for next read
            //

            pContext->arInfo.uop.opFakeXmit.BytesLeft -= nRead;
            pContext->arInfo.uop.opFakeXmit.FileOffset += nRead;

            //
            // Do the write
            //

            I_SetNextTimeout(pContext);
            pContext->BytesSent = nRead;

            //
            // Write to the socket
            //

            if ( !WriteFile(
                    pContext->hAsyncIO,
                    buffer,
                    nRead,
                    &nWrite,
                    &pContext->Overlapped
                    ) &&
                (GetLastError() != ERROR_IO_PENDING) ) {

                CompletionStatus = GetLastError();
                ATQ_PRINTF(( DBG_CONTEXT,
                             "WriteFile error %d\n",CompletionStatus));
                goto call_completion;
            }

            return;
        }
    }

    //
    // Time for the tail.  If one exist, send it synchronously and then
    // call the completion routine
    //

    tail = pContext->arInfo.uop.opFakeXmit.Tail;
    if ( tail != NULL ) {

        DWORD tailLength = pContext->arInfo.uop.opFakeXmit.TailLength;

        ATQ_ASSERT(tailLength > 0);

        //
        // Send it synchronously
        //

        err = send(
                HANDLE_TO_SOCKET(pContext->hAsyncIO),
                (PCHAR)tail,
                tailLength,
                0
                );

        if ( err == SOCKET_ERROR ) {
            CompletionStatus = GetLastError();
        } else {
            pContext->arInfo.uop.opFakeXmit.BytesWritten += err;
        }
    }

call_completion:

    //
    // cleanup and call real completion routine
    //

    I_CleanupFakeTransmitFile( pContext );
    if ( pContext->pfnCompletion != NULL ) {

        pContext->pfnCompletion(
                    pContext->ClientContext,
                    pContext->arInfo.uop.opFakeXmit.BytesWritten,
                    CompletionStatus,
                    lpo
                    );
    }

    return;

} // I_FakeTransmitFileCompletion

BOOL
I_DoFakeTransmitFile(
    IN PATQ_CONT                pContext,
    IN HANDLE                   hFile,
    IN DWORD                    dwBytesInFile,
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers
    )
/*++

Routine Description:

    Posts a completion status on the completion port queue

    An IO pending error code is treated as a success error code

Arguments:

    patqContext - pointer to ATQ context
    hFile - Handle to the file to be read.
    dwBytesInFile - Number of bytes to read in the file
    lpTransmitBuffers - the transmitfile structure

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{

    PCHAR buffer = NULL;
    DWORD nWrite;
    DWORD nRead = 0;
    OVERLAPPED ov;
    INT err;
    DWORD cBuffer = 0;
    OVERLAPPED *pov = &ov;
    HANDLE hOvEvent = NULL;

    INC_ATQ_COUNTER( g_cTotalAllowedRequests);

    //
    // See if we need to send a header
    //

    pContext->arInfo.uop.opFakeXmit.BytesWritten = 0;
    if ( lpTransmitBuffers != NULL ) {

        //
        // Store the tail
        //

        pContext->arInfo.uop.opFakeXmit.Tail = lpTransmitBuffers->Tail;
        pContext->arInfo.uop.opFakeXmit.TailLength = lpTransmitBuffers->TailLength;

        if (lpTransmitBuffers->HeadLength > 0) {
            ATQ_ASSERT(lpTransmitBuffers->Head != NULL);

            //
            // Send it synchronously
            //

            err = send(
                    HANDLE_TO_SOCKET(pContext->hAsyncIO),
                    (PCHAR)lpTransmitBuffers->Head,
                    lpTransmitBuffers->HeadLength,
                    0
                    );

            if ( err == SOCKET_ERROR ) {
                ATQ_PRINTF(( DBG_CONTEXT, "Error %d in send.\n",err));
                return(FALSE);
            }
            pContext->arInfo.uop.opFakeXmit.BytesWritten += err;
        }
    }

    //
    // Check the number of bytes to send
    //

    if ( dwBytesInFile == 0 ) {

        //
        // Send the whole file.
        //

        dwBytesInFile = GetFileSize( hFile, NULL );
        ATQ_ASSERT(dwBytesInFile >= pContext->Overlapped.Offset);
        dwBytesInFile -= pContext->Overlapped.Offset;
    }

    //
    // Allocate the io buffer
    //

    cBuffer = min( dwBytesInFile, g_cbXmitBufferSize );
    if ( cBuffer > 0 ) {

        //
        // Read the first chunk of the body
        //

        buffer = (PCHAR)LocalAlloc( 0, cBuffer );
        if ( buffer == NULL ) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "Cannot allocate %d bytes for xmitfile\n",cBuffer));
            return(FALSE);
        }

        //
        // Do the read at the specified offset
        //

        hOvEvent = pov->hEvent = IIS_CREATE_EVENT(
                                     "OVERLAPPED::hEvent",
                                     pov,
                                     TRUE,
                                     FALSE
                                     );

        if ( hOvEvent == NULL ) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "Create event failed with %d\n",GetLastError()));
            LocalFree( buffer );
            return(FALSE);
        }

        pov->OffsetHigh = 0;
        pov->Offset = pContext->Overlapped.Offset;

        if (!ReadFile(
                    hFile,
                    buffer,
                    cBuffer,
                    &nRead,
                    pov
                    ) ) {

            err = GetLastError();
            if ( (err != ERROR_IO_PENDING) ||
                 !GetOverlappedResult( hFile, pov, &nRead, TRUE )) {

                err = GetLastError();
                CloseHandle( hOvEvent );
                LocalFree( buffer );
                SetLastError(err);
                ATQ_PRINTF(( DBG_CONTEXT,
                             "Error %d in readfile\n",err));
                return(FALSE);
            }
        }
    }

    //
    // are we done reading the body?
    //

    if ( nRead < g_cbXmitBufferSize ) {

        //
        // Done.
        //

        pContext->arInfo.uop.opFakeXmit.BytesLeft = 0;
    } else {

        pContext->arInfo.uop.opFakeXmit.BytesLeft = dwBytesInFile - nRead;
        pContext->arInfo.uop.opFakeXmit.FileOffset =
                                    pContext->Overlapped.Offset + nRead;
    }

    //
    // store data for restarting the operation.
    //

    pContext->arInfo.uop.opFakeXmit.pBuffer = buffer;
    pContext->arInfo.uop.opFakeXmit.hOvEvent = hOvEvent;
    pContext->arInfo.uop.opFakeXmit.hFile = hFile;

    //
    // replace the completion function with our own
    //

    pContext->arInfo.uop.opFakeXmit.pfnCompletion = pContext->pfnCompletion;
    pContext->arInfo.uop.opFakeXmit.ClientContext = pContext->ClientContext;
    pContext->pfnCompletion = I_FakeTransmitFileCompletion;
    pContext->ClientContext = pContext;

    //
    // Set the timeout
    //

    I_SetNextTimeout(pContext);
    pContext->BytesSent = nRead;

    //
    // Write to the socket
    //

    if ( !WriteFile(
            pContext->hAsyncIO,
            buffer,
            nRead,
            &nWrite,
            &pContext->Overlapped
            ) &&
        (GetLastError() != ERROR_IO_PENDING)) {

        err = GetLastError();
        I_CleanupFakeTransmitFile( pContext );
        SetLastError(err);
        return(FALSE);
    }

    SetLastError(NO_ERROR);
    return(TRUE);

} // I_DoFakeTransmitFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\oplock\atqcport.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT - Windows 95          **/
/**                Copyright(c) Microsoft Corp., 1994-1996           **/
/**********************************************************************/


/*
    atqcport.cxx

    This module contains replacement code for completion port and TransmitFile APIs
    for Windows95 , where this functionality is absent.

    Code is tightly coupled with ATQ code, reusing some of the data structures and globals.
    Main ATQ processing code is left intact as much as possible , so that when we get real
    completion ports, amount of modications should be minimal

    One port per process currently supported.

    FILE HISTORY:
        VladS       05-Jan-1996 Created.

   Functions Exported:

        HANDLE  SIOCreateCompletionPort();
        DWORD   SIODestroyCompletionPort();

        DWORD   SIOStartAsyncOperation();
        BOOL    SIOGetQueuedCompletionStatus();
        DWORD   SIOPostCompletionStatus();

*/

#include "isatq.hxx"
#include "atqcport.hxx"
#include <inetsvcs.h>

/************************************************************
 * Private Globals
 ************************************************************/

W95CPORT *g_pCPort = NULL;

//
// Queues with ATQ contexts, being processed in completion port
//

LIST_ENTRY  g_SIOIncomingRequests ;     // Queue of incoming socket i/o
LIST_ENTRY  g_SIOCompletedIoRequests ;  // Queue with results of i/o

CRITICAL_SECTION g_SIOGlobalCriticalSection; // global sync variable.

HANDLE  g_hPendingCompletionSemaphore = NULL;

DWORD SIOPoolThread( LPDWORD param );

BOOL
SIO_Private_StartAsyncOperation(
    IN  HANDLE          hExistingPort,
    IN  PATQ_CONT       pAtqContext
    );

PATQ_CONT
SIO_Private_GetQueuedContext(
    LIST_ENTRY *pQueue
    );

BOOL
SIOCheckContext(
    IN  PATQ_CONTEXT pAtqC,
    IN  BOOL         fNew       /* = TRUE */
    );

PATQ_CONT
FindATQContextFromSocket(
    SOCKET          sc
    );

//
// Global synzronization calls
//

#define SIOLockGlobals()   EnterCriticalSection( &g_SIOGlobalCriticalSection )
#define SIOUnlockGlobals() LeaveCriticalSection( &g_SIOGlobalCriticalSection )

/************************************************************
*  Public functions.
************************************************************/

HANDLE
SIOCreateCompletionPort(
    IN  HANDLE  hAsyncIO,
    IN  HANDLE  hExistingPort,
    IN  DWORD   dwCompletionKey,
    IN  DWORD   dwConcurrentThreads
    )
/*++

Routine Description:

    Initializes the ATQ completion port

Arguments:

Return Value:

    valid handle  if successful, NULL on error (call GetLastError)

--*/
{

    IF_DEBUG(SIO) {
        ATQ_PRINTF((DBG_CONTEXT,"SIOCreateCompletionPort entered\n"));
    }

    if (INVALID_HANDLE_VALUE != hAsyncIO) {

        //
        // Set up i/o handle to non-blocking mode
        //

        DWORD one = 1;
        ioctlsocket( (SOCKET)hAsyncIO, FIONBIO, &one );
    }

    //
    // If passed handle is not null - only initialize our parts of ATQ context
    // as completion port object has been created before
    //

    if ( (hExistingPort != NULL) && (g_pCPort != NULL) ) {

        PATQ_CONT   pAtqContext = (PATQ_CONT)dwCompletionKey;

        IF_DEBUG(SIO) {
            ATQ_PRINTF((DBG_CONTEXT,
               "[SIO_CreatePort(%lu)] Received  context=%x socket=%x\n",
                GetCurrentThreadId(),pAtqContext,hAsyncIO));
        }

        //
        // Set up SIO specific fields in ATQ context
        //

        pAtqContext->SIOListEntry.Flink =
        pAtqContext->SIOListEntry.Blink = NULL;

        pAtqContext->dwSIOFlags = 0;

        return (HANDLE)g_pCPort;
    }

    //
    // First time initialization
    // BUGBUG  Code assumes that there is only one completion port in use, as
    // incoming queue is initialized here . If we will support more than one
    // completion port object, queue initialization should be moved into ATQInitialize
    //

    g_pCPort = new W95CPORT(dwConcurrentThreads);

    if ( (g_pCPort == NULL) ||
         (g_pCPort->QueryWakeupSocket() == INVALID_SOCKET) ) {

        ATQ_PRINTF((DBG_CONTEXT,
                    "[SIO]Could not create completion port"
                    ));

        delete g_pCPort;
        ATQ_ASSERT(FALSE);
        return NULL;
    }

    InitializeListHead( &g_SIOIncomingRequests );
    InitializeListHead( &g_SIOCompletedIoRequests );

    //
    // Prepare global syncronization mechanism
    //

    InitializeCriticalSection( &g_SIOGlobalCriticalSection );

    g_hPendingCompletionSemaphore =
                        CreateSemaphore(NULL,// Security Attributes
                                        0,   // Initial count
                                        0x7fffffff, // Maximum count
                                        NULL);  // Name

    return (HANDLE)g_pCPort;

} // SIOCreateCompletionPort


BOOL
SIODestroyCompletionPort(
    IN  HANDLE  hExistingPort
    )
/*++

Routine Description:

    Destroys ATQ completion port

Arguments:

Return Value:

    TRUE,  if successful,
    FALSE, otherwise

--*/
{

    PATQ_CONT   pAtqContext = NULL;
    W95CPORT    *pCPort = (W95CPORT *)hExistingPort;

    //
    // Queue completion indications to SIO thread and file I/O threads
    //

    if ( pCPort == NULL ) {

        //
        // Port already destroyed - return
        //

        return TRUE;
    }

    g_pCPort->Shutdown();

    delete g_pCPort;
    g_pCPort = NULL;

    return TRUE;

} // SIODestroyCompletionPort


BOOL
SIOStartAsyncOperation(
    IN  HANDLE          hExistingPort,
    IN  PATQ_CONTEXT    pAtqContext
    )
/*++

Routine Description:

    Queues ATQ context with requested i/o operation to the completion port.
    Values in context should be set by a caller , coompletion will be available
    by calling SIOGetQueuedCompletionStatus.

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{

    PATQ_CONT   pAtqFullContext = (PATQ_CONT)pAtqContext;
    W95CPORT    *pCPort = (W95CPORT *)hExistingPort;
    DWORD       dwErr;

    // Parameter validation

    if (!hExistingPort || !pAtqContext) {
        ATQ_ASSERT(FALSE);
        SetLastError(ERROR_INVALID_PARAMETER);
        InterlockedDecrement( &pAtqFullContext->m_nIO);
        return FALSE;
    }

    //
    // Add this context to the incoming queue
    //

    IF_DEBUG(SIO) {
        ATQ_PRINTF((DBG_CONTEXT,
           "[StartAsyncOperation(%lu)] AtqCtxt=%x  \n ",
            GetCurrentThreadId(),
            pAtqContext
            ));
    }

    //
    // Is this valid new context for completion port.
    //

    if(!SIOCheckContext(pAtqContext,TRUE)) {
        dwErr = ERROR_OPERATION_ABORTED;
        goto error_exit;
    }

    //
    // Check SIO thread status, if there are no thread , create one
    //

    if (!pCPort->SIOCheckCompletionThreadStatus()) {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    //
    // Validate file handle
    //

    if (!pAtqFullContext->hAsyncIO) {
        dwErr = WSAENOTSOCK;
        goto error_exit;
    }

    SIOLockGlobals();

    pAtqFullContext->dwSIOFlags &= ~ATQ_SIO_FLAG_STATE_MASK;
    pAtqFullContext->dwSIOFlags |= ATQ_SIO_FLAG_STATE_INCOMING;

    InsertTailList( &g_SIOIncomingRequests, &pAtqFullContext->SIOListEntry );

    SIOUnlockGlobals();

    //
    // Signal processing thread about scheduling new i/o operation
    //

    pCPort->Wakeup();

    return TRUE;

error_exit:

    ATQ_PRINTF((DBG_CONTEXT,"Error %d in SIOStartAsyncOperation\n", dwErr));

    //
    // Then no need to select, we can just fail this I/O
    //

    pAtqFullContext->arInfo.dwLastIOError =  dwErr;

    //
    // Immediately queue context as completed
    //

    SIOPostCompletionStatus(hExistingPort,
                            0,                                //Total dwBytesTransferred from arInfo
                            (DWORD)pAtqFullContext,
                            pAtqFullContext->arInfo.lpOverlapped);

    return TRUE;

} // SIOStartAsyncOperation


BOOL
SIOGetQueuedCompletionStatus(
    IN  HANDLE          hExistingPort,
    OUT LPDWORD         lpdwBytesTransferred,
    OUT LPDWORD         lpdwCompletionKey,
    OUT LPOVERLAPPED    *lplpOverlapped,
    IN  DWORD           msThreadTimeout
    )
/*++

Routine Description:

    Get next available completion or blocks
Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    //
    // Validate parameters
    //

    if (!lpdwBytesTransferred || !lpdwCompletionKey) {
        ATQ_ASSERT(FALSE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    PATQ_CONT   pAtqContext = NULL;

    DWORD       dwErr = NOERROR;
    BOOL        fRes = FALSE;

    //
    // Wait on completed queue semaphore
    //

    dwErr = WaitForSingleObject(
                g_hPendingCompletionSemaphore,
                msThreadTimeout
                );

    if (dwErr == WAIT_OBJECT_0 ) {

        pAtqContext  = SIO_Private_GetQueuedContext(&g_SIOCompletedIoRequests);

        //
        // Operation completed - reset IO command in ATQ context
        //

        IF_DEBUG(SIO) {
            ATQ_PRINTF((DBG_CONTEXT,
                "GetQueuedContext returns context = %x\n", pAtqContext));
        }
    } else {

        //
        // timed out
        //

        ATQ_PRINTF((DBG_CONTEXT,"SIOGetQueuedCompletionStatus timed out\n"));
    }

    if (pAtqContext != NULL) {

        //
        // Is this valid  context inside completion port ?
        //

        if(!SIOCheckContext((PATQ_CONTEXT)pAtqContext,FALSE)) {
            SetLastError(ERROR_OPERATION_ABORTED);
            return FALSE;
        }

        //
        // Get atq context and overlapped buffer pointer from
        // completion message
        //

        *lplpOverlapped = pAtqContext->arInfo.lpOverlapped;
        *lpdwCompletionKey = (DWORD)pAtqContext;
        *lpdwBytesTransferred = pAtqContext->arInfo.dwTotalBytesTransferred;

        IF_DEBUG(SIO) {
            ATQ_PRINTF((DBG_CONTEXT,
                "GetQueuedCompletion Returning %d bytes\n",
                *lpdwBytesTransferred));
        }

        //
        // Clear context fields
        //

        pAtqContext->arInfo.atqOp        = AtqIoNone;

        pAtqContext->dwSIOFlags &= ~ATQ_SIO_FLAG_STATE_MASK;

        fRes = TRUE;

        IF_DEBUG(SIO) {
            ATQ_PRINTF((DBG_CONTEXT,
                "[SIOGetCompletion(%lu)] ATQContext=%x to socket=%x\n",
                GetCurrentThreadId(),pAtqContext,pAtqContext->hAsyncIO));
        }

        // Johnson said that we should have following assert here....
        DBG_ASSERT( pAtqContext->Signature == ATQ_CONTEXT_SIGNATURE);

        //
        // Real context - check if i/o completed correctly
        //

        if ( pAtqContext->arInfo.dwLastIOError != NOERROR) {
            // Set last error again to prevent overwriting by other APIs
            SetLastError(pAtqContext->arInfo.dwLastIOError);
            fRes = FALSE;
        }

    } else {
        *lpdwBytesTransferred = 0;
        *lplpOverlapped = NULL;
        *lpdwCompletionKey = 0;
    }

    return fRes;

} // SIOGetQueuedCompletionStatus



BOOL
SIOPostCompletionStatus(
    IN  HANDLE      hExistingPort,
    IN  DWORD       dwBytesTransferred,
    IN  DWORD       dwCompletionKey,
    IN  LPOVERLAPPED    lpOverlapped
    )
/*++

Routine Description:

    Posts passed information as ATQ context to the queue of completed requests

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    PATQ_CONT   pAtqContext = (PATQ_CONT)dwCompletionKey;

    IF_DEBUG(SIO) {
        ATQ_PRINTF((DBG_CONTEXT,
           "[SIOPostCompletionStatus(%lu)] AtqCtxt=%x Bytes=%d Overlapped=%x\n ",
            GetCurrentThreadId(),
            pAtqContext,
            dwBytesTransferred,
            lpOverlapped
            ));
    }

    if ( pAtqContext != NULL ) {

        pAtqContext->arInfo.dwTotalBytesTransferred = dwBytesTransferred;
        pAtqContext->arInfo.lpOverlapped = lpOverlapped;

        if ( pAtqContext->dwSIOFlags & ATQ_SIO_FLAG_STATE_MASK) {
            ATQ_PRINTF((DBG_CONTEXT,
                   "[SIOPostCompletionStatus(%lu)] Context is inside SIO. AtqCtxt=%x SIOFlags = %x  \n ",
                    GetCurrentThreadId(),
                    pAtqContext,
                    pAtqContext->dwSIOFlags
                    ));
            ATQ_ASSERT(FALSE);
        }

        SIOLockGlobals();

        pAtqContext->dwSIOFlags &= ~ATQ_SIO_FLAG_STATE_MASK;
        pAtqContext->dwSIOFlags |= ATQ_SIO_FLAG_STATE_COMPLETED;

        //
        // This  should never happen if context is in right state.
        //

        if (pAtqContext->SIOListEntry.Flink) {

            ATQ_PRINTF((DBG_CONTEXT,
                   "[SIOPostCompletionStatus(%lu)] Context is in some other queue . AtqCtxt=%x SIOFlags = %x\n",
                    GetCurrentThreadId(),
                    pAtqContext,
                    pAtqContext->dwSIOFlags
                    ));

            ATQ_ASSERT(FALSE);
            RemoveEntryList(&pAtqContext->SIOListEntry );
        }

        InsertTailList( &g_SIOCompletedIoRequests, &pAtqContext->SIOListEntry );
    } else {

        SIOLockGlobals();
    }

    //
    // This context now counts as waiting for ATQ pool thread to pick it up
    //

    InterlockedIncrement( (PLONG)&g_AtqWaitingContextsCount );

    //
    // Wake up pool threads if they are waiting on the completion queue
    //

    ReleaseSemaphore(g_hPendingCompletionSemaphore, 1, NULL);

    SIOUnlockGlobals();

    //
    // Call internal postqueue routine for main outcoming queue
    //

    return TRUE;

}


DWORD
SIOPoolThread(
    LPDWORD param
    )
/*++

Routine Description:

    Thread routine for completion port thread
Arguments:

Return Value:


--*/
{
    ATQ_ASSERT(param != NULL);

    if (param == NULL) {
        return 0;
    }

    //
    // Cast passed parameter to pointer to completion port object and
    // invoke appropriate method
    //

    W95CPORT    *pCPort = (W95CPORT *)param;

    return pCPort->PoolThreadCallBack();

} // SIOPoolTread


/*

   Implementation of completion port class

*/


W95CPORT::W95CPORT(
    IN DWORD dwConcurrentThreads
    )
:
    m_Signature             (ATQ_SIO_CPORT_SIGNATURE),
    m_IsDestroying          (FALSE),
    m_IsThreadRunning       (0L),
    m_hThread               (INVALID_HANDLE_VALUE),
    m_fWakeupSignalled      (FALSE),
    m_scWakeup              (INVALID_SOCKET)
{
    INT err;
    SOCKADDR_IN     sockAddr;
    DWORD   i = 0;

    FD_ZERO(&m_ReadfdsStore);
    FD_ZERO(&m_WritefdsStore);

    do {

        m_scWakeup = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

        if ( m_scWakeup == INVALID_SOCKET) {
            if ( (WSAGetLastError() != WSAESOCKTNOSUPPORT)
                 || ( i > 10 ) ) {

                ATQ_PRINTF((DBG_CONTEXT,"socket creation failed with %d\n",
                    WSAGetLastError()));
                goto exit;
            }

            ATQ_PRINTF((DBG_CONTEXT,"socket failed with %d retrying...\n",
                WSAGetLastError()));
            Sleep(1000);
            i++;
        }

    } while ( m_scWakeup == INVALID_SOCKET );

    ZeroMemory(&sockAddr, sizeof(sockAddr));
    sockAddr.sin_family = AF_INET;
    sockAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    sockAddr.sin_port = htons(CPORT_WAKEUP_PORT);

    err = bind(m_scWakeup, (PSOCKADDR)&sockAddr, sizeof(sockAddr));

    if ( err == SOCKET_ERROR ) {
        ATQ_PRINTF((DBG_CONTEXT,"Error %d in bind\n", WSAGetLastError()));
        closesocket(m_scWakeup);
        m_scWakeup = INVALID_SOCKET;
    }

exit:
    //
    // Set select timeout value
    //

    InitializeCriticalSection( &m_csLock );

} // W95CPORT::W95CPORT



W95CPORT::~W95CPORT(
                VOID
                )
{

    ATQ_PRINTF((DBG_CONTEXT,"Win95 Cport %x being freed\n", this));

    ATQ_ASSERT(m_IsDestroying);

    DeleteCriticalSection( &m_csLock );

    if ( m_scWakeup != INVALID_SOCKET ) {
        closesocket(m_scWakeup);
        m_scWakeup = INVALID_SOCKET;
    }

} // W95CPORT::~W95CPORT()


BOOL
W95CPORT::Shutdown(VOID)
{
    DWORD   dwErr;

    m_IsDestroying = TRUE;

    Wakeup();

    //
    // Wait for thread to shut down  BUGBUG
    //

    dwErr = WaitForSingleObject( m_hThread,100);
    CloseHandle(m_hThread);

    return TRUE;

} // W95CPORT::Shutdown(VOID)


VOID
W95CPORT::Wakeup(VOID)
{
    SOCKADDR_IN sockAddr;
    INT err;
    DWORD dwBuf = ATQ_WAKEUP_SIGNATURE;

    IF_DEBUG(SIO) {
        ATQ_PRINTF((DBG_CONTEXT,
            "[WakeUp(%lu)] Trying to signal wakeup socket=%x \n",
            GetCurrentThreadId(), m_scWakeup));
    }

    Lock( );
    if ( !m_fWakeupSignalled ) {

        sockAddr.sin_family = AF_INET;
        sockAddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
        sockAddr.sin_port = htons(CPORT_WAKEUP_PORT);

        err = sendto(
                m_scWakeup,
                (PCHAR)&dwBuf,
                sizeof(dwBuf),
                0,
                (PSOCKADDR)&sockAddr,
                sizeof(sockAddr)
                );

        if ( err == SOCKET_ERROR ) {
            ATQ_PRINTF((DBG_CONTEXT,
                "Error %d in sendto\n",WSAGetLastError()));
        } else {
            m_fWakeupSignalled = TRUE;
        }
    }
    Unlock( );

    return;

} // W95CPORT::Wakeup


DWORD
W95CPORT::PoolThreadCallBack(
            VOID
            )
/*++

Routine Description:

    This is routine, handling all events associated with socket i/o .

Arguments:

Return Value:

--*/
{

    TIMEVAL             tvTimeout;

    FD_SET              readfds;
    FD_SET              writefds;

    DWORD   dwErr = NOERROR;

    //
    // Initialize array of events for socket i/o
    //

    FD_ZERO(&m_ReadfdsStore);
    FD_ZERO(&m_WritefdsStore);

    //
    // Set select timeout value
    //

    tvTimeout.tv_sec = (SIO_THREAD_TIMEOUT*3)/100;            // 30 sec
    tvTimeout.tv_usec = 0;

    //
    // Main loop
    //

    while (!m_IsDestroying) {

        //
        // Prepare  socket arrays for select
        //

        PrepareDescriptorArrays( &readfds, &writefds);

        IF_DEBUG(SIO) {
            ATQ_PRINTF((DBG_CONTEXT,
               "[SIOThread(%lu)]Before select: Readcnt=%d WriteCnt=%d \n",
                GetCurrentThreadId(), readfds.fd_count, writefds.fd_count
                ));
        }

        //
        // Wait for first completed i/o or timeout
        //

        dwErr = select(0,&readfds,&writefds,NULL,&tvTimeout);

        //
        // If we are shutting down - stop processing and exit
        //

        if (m_IsDestroying) {
            break;
        }

        //
        // Figure out what triggered an event and act accordingly
        //

        if (SOCKET_ERROR == dwErr ) {

            DWORD   dwLastErr = WSAGetLastError();

            //
            // if we get WSANOTINITIALISED, then either something bad
            // happened or we are being cleaned up
            //

            if ( dwLastErr == WSANOTINITIALISED ) {
                ATQ_PRINTF((DBG_CONTEXT,
                    "SIO_Thread: select detects shutdown\n"));
                break;
            }

            //
            // Select failed - most probably because wakeup socket was closed
            // after we checked for it but before calling select. If this is the case
            // just continuing will be the right thing.
            //

            ATQ_PRINTF((DBG_CONTEXT,
                "SIO_Thread: Select failed with %d\n", dwLastErr));

            //
            // Select failed , we need to go through list of sockets currently set up
            // and remove those , which do not have associated ATQ contexts.
            // That will happen if another thread removed context and closed socket
            // when we were busy processing completion. In this case socket handle is
            // already invalid when we came to select.

            CleanupDescriptorList();
            continue;

        } else if (0L == dwErr) {

            //
            // Select timed out - BUGBUG close after number of timeouts
            // if there is no i/o activity scheduled
            //

            //ATQ_PRINTF((DBG_CONTEXT,"select timed out\n"));
            CleanupDescriptorList();

        } else {

            //
            // This is socket completion. Walk all out sets and for each signalled socket
            // process it's completion
            //

            ProcessSocketCompletion(dwErr, &readfds, &writefds);
        }

    }

    ATQ_PRINTF((DBG_CONTEXT,"Exiting SIOPoolThread\n"));
    return 0;

} // SIOPoolTread




BOOL
W95CPORT::PrepareDescriptorArrays(
                IN PFD_SET  ReadFds,
                IN PFD_SET  WriteFds
                )
/*++

Routine Description:

    Prepares sockets array for select call.

    Nb: Object is not locked when arrays are processed, so if any other method will
    be modifying arrays directly , locking should become more agressive. Global
    critical section is taken when checking incoming queue.

Arguments:

Return Value:

--*/
{

    PATQ_CONT   pAtqContext = NULL;

    FD_ZERO(ReadFds);
    FD_ZERO(WriteFds);

    //
    // We should remove as many as possible from incoming
    // queue, because if semaphore signalled but there were not
    // free event handles available, we will leave incoming request
    // in the queue.
    //

    BOOL        fReadRequest;

    PLIST_ENTRY listEntry;
    PLIST_ENTRY nextEntry;

    SIOLockGlobals();

    for ( listEntry  = g_SIOIncomingRequests.Flink;
          listEntry != &g_SIOIncomingRequests;
          listEntry  = nextEntry ) {

        nextEntry = listEntry->Flink;

        pAtqContext = CONTAINING_RECORD(
                                listEntry,
                                ATQ_CONTEXT,
                                SIOListEntry );

        //
        // Is this valid new context for completion port. if not skip it
        //

        if(!SIOCheckContext((PATQ_CONTEXT)pAtqContext,FALSE)) {
            continue;
        }

        fReadRequest = (pAtqContext->arInfo.atqOp == AtqIoRead) ;

        if ( ( fReadRequest && (m_ReadfdsStore.fd_count >= (FD_SETSIZE-1) )) ||
             (!fReadRequest && (m_WritefdsStore.fd_count >= FD_SETSIZE))) {

            //
            // Skip this context as appropriate array is full
            //

            ATQ_PRINTF((DBG_CONTEXT,"Full array!\n"));
            continue;
        }

        //
        // Add socket to appropriate queue
        //

        IF_DEBUG(SIO) {
            ATQ_PRINTF((DBG_CONTEXT,
               "[SIOPrepareArray(%lu)] Received  i/o request context=%x to socket=%x I/O OpCode=%d .\n",
                GetCurrentThreadId(),
                pAtqContext,
                pAtqContext->hAsyncIO,
                pAtqContext->arInfo.atqOp));
        }

        if((pAtqContext->dwSIOFlags & ATQ_SIO_FLAG_STATE_MASK) != ATQ_SIO_FLAG_STATE_INCOMING) {

            ATQ_PRINTF((DBG_CONTEXT,
                   "[SIO: PDA (%lu)] Not in incoming state AtqCtxt=%x SIOFlags = %x  \n ",
                    GetCurrentThreadId(),
                    pAtqContext,
                    pAtqContext->dwSIOFlags
                    ));
            ATQ_ASSERT(FALSE);
        }

        //
        // Remove context from incoming queue
        //

        RemoveEntryList(listEntry);
        listEntry->Flink = listEntry->Blink = NULL;

        pAtqContext->dwSIOFlags &= ~ATQ_SIO_FLAG_STATE_MASK;
        pAtqContext->dwSIOFlags |= ATQ_SIO_FLAG_STATE_WAITING;

        //
        // Indicate socket as waiting for the ready state
        //

        switch (pAtqContext->arInfo.atqOp) {
            case AtqIoRead:
                FD_SET((SOCKET)pAtqContext->hAsyncIO,&m_ReadfdsStore);
                break;

            case AtqIoWrite:
            case AtqIoXmitFile:
                FD_SET((SOCKET)pAtqContext->hAsyncIO,&m_WritefdsStore);
                break;

            default:
                ATQ_PRINTF((DBG_CONTEXT,
                       "[PrepareDescriptors(%lu)] Context=%x has invalid type of IO op\n",
                        GetCurrentThreadId(),pAtqContext));
                break;
        }
    }

    SIOUnlockGlobals();

    //
    // Initialize socket set for use with select .
    // BUGBUG  Is this memory operation platfrom independent ?

    CopyMemory( ReadFds, &m_ReadfdsStore, sizeof(fd_set));
    CopyMemory( WriteFds, &m_WritefdsStore, sizeof(fd_set));

    //
    // Add wakeup socket to read list
    //

    FD_SET(m_scWakeup,ReadFds);

    IF_DEBUG(SIO) {
        ATQ_PRINTF((DBG_CONTEXT,"[SIOPrepareArray Added Wakeup socket=%x ReadCount=%d WriteCOunt=%d \n",
                m_scWakeup,ReadFds->fd_count,WriteFds->fd_count));
    }

    return TRUE;

} // W95CPORT::PrepareDescriptorArrays



BOOL
W95CPORT::ProcessSocketCompletion(
    IN DWORD dwCompletedCount,
    IN PFD_SET  ReadFds,
    IN PFD_SET  WriteFds
    )
/*++

Routine Description:

    Handling i/o completion for sockets in select descriptor array

Arguments:

Return Value:

--*/
{
    UINT    Count;
    UINT    i = 0;
    INT     dwErr;
    DWORD   cbBytesTransferred;
    DWORD   nBytes;

    PFD_SET pCurrentSet = ReadFds;
    PFD_SET pCurrentStoreSet = &m_ReadfdsStore;

    ATQ_ASSERT(dwCompletedCount == (ReadFds->fd_count + WriteFds->fd_count));

    //
    // First process read set,then write set
    //

    for (i=0;i<2;i++) {

        //
        // Walk through completed sockets in current descriptor set
        //

        for (Count=0;Count < pCurrentSet->fd_count;Count++) {

            PATQ_CONT   pAtqContext = NULL;

            //
            // If this is wakeup socket - skip iteration
            //

            if ((pCurrentSet == ReadFds) &&
                 (m_scWakeup == pCurrentSet->fd_array[Count]) ) {

                DWORD dwBuf;
                INT err;

                Lock( );

                ATQ_ASSERT(m_fWakeupSignalled);

                err = recvfrom(
                            m_scWakeup,
                            (PCHAR)&dwBuf,
                            sizeof(dwBuf),
                            0,
                            NULL,
                            NULL
                            );

                if ( err == SOCKET_ERROR ) {
                    ATQ_PRINTF((DBG_CONTEXT,
                        "Error %d in recvfrom\n", WSAGetLastError()));
                } else {
                    ATQ_ASSERT(dwBuf == ATQ_WAKEUP_SIGNATURE);
                }

                m_fWakeupSignalled = FALSE;
                Unlock( );

                continue;
            }

            //
            // Find ATQ context associated with signalled socket
            //

            pAtqContext = FindATQContextFromSocket(
                                        pCurrentSet->fd_array[Count]
                                        );

            ATQ_ASSERT(pAtqContext != NULL);

            if (pAtqContext == NULL) {

                //
                // Did not locate context - go to next one, most probably
                // we are shutting down. In any case remove this socket from
                // stored list, as there is no use in it
                //

                FD_CLR(pCurrentSet->fd_array[Count],pCurrentStoreSet);

                //
                // Socket should be really closed do we need to close
                // it again ?

                closesocket(pCurrentSet->fd_array[Count]);
                continue;
            }

            IF_DEBUG(SIO) {
                ATQ_PRINTF((DBG_CONTEXT,
                   "[ProcessCompletion(%lu)] Completion signal AtqCtxt=%x Socket=%x I/O OpCode=%d SioFlags=%x  \n ",
                    GetCurrentThreadId(),
                    pAtqContext,
                    pAtqContext->hAsyncIO,
                    pAtqContext->arInfo.atqOp,
                    pAtqContext->dwSIOFlags
                    ));
            }

            //
            // Is context in right state
            //

            if( (pAtqContext->dwSIOFlags & ATQ_SIO_FLAG_STATE_MASK) != ATQ_SIO_FLAG_STATE_WAITING ) {

                dwErr = SOCKET_ERROR;
                WSASetLastError(WSAECONNABORTED);

                pAtqContext->Print();
                ATQ_PRINTF((DBG_CONTEXT,
                       "[ProcessCompletion(%x)] SIO state Ctxt=%x Flags=%x hAsync=%x hJra=%x\n ",
                        GetCurrentThreadId(),
                        pAtqContext,
                        pAtqContext->dwSIOFlags,
                        pAtqContext->hAsyncIO,
                        pAtqContext->hJraAsyncIO
                        ));
            } else {

                //
                // Perform selected i/o operation on ready socket
                //

                nBytes = 0;
                switch(pAtqContext->arInfo.atqOp ) {

                case AtqIoRead: {

                        DWORD dwFlags = 0;
                        LPWSABUF  pBuf =
                                pAtqContext->arInfo.uop.opReadWrite.pBufAll;

                        dwErr = WSARecv(
                                pCurrentSet->fd_array[Count],
                                pBuf,
                                pAtqContext->arInfo.uop.opReadWrite.dwBufferCount,
                                &nBytes,
                                &dwFlags,
                                NULL,       // no lpo
                                NULL
                                );

                        if ( pBuf != &pAtqContext->arInfo.uop.opReadWrite.buf1 ) {
                            LocalFree(pBuf);
                        }

                        pAtqContext->arInfo.uop.opReadWrite.pBufAll = NULL;
                    }

                    break;

                case AtqIoWrite: {

                        LPWSABUF  pBuf =
                                pAtqContext->arInfo.uop.opReadWrite.pBufAll;

                        dwErr = WSASend(
                                pCurrentSet->fd_array[Count],
                                pBuf,
                                pAtqContext->arInfo.uop.opReadWrite.dwBufferCount,
                                &nBytes,
                                0,      // no flags
                                NULL,   // no lpo
                                NULL
                                );

                        if ( pBuf != &pAtqContext->arInfo.uop.opReadWrite.buf1 ) {
                            LocalFree(pBuf);
                        }

                        pAtqContext->arInfo.uop.opReadWrite.pBufAll = NULL;
                    }
                    break;

                case AtqIoXmitFile: {

                        DWORD cbWritten = 0;
                        WSABUF wsaBuf = {
                            pAtqContext->arInfo.uop.opFakeXmit.cbBuffer,
                            (PCHAR)pAtqContext->arInfo.uop.opFakeXmit.pvLastSent
                            };

                        dwErr = WSASend(
                                pCurrentSet->fd_array[Count],
                                &wsaBuf,
                                1,
                                &nBytes,
                                0,      // no flags
                                NULL,   // no lpo
                                NULL
                                );
                    }
                    break;

                default:

                    dwErr = SOCKET_ERROR;
                    WSASetLastError(WSAECONNABORTED);

                    ATQ_PRINTF((DBG_CONTEXT,
                           "[ProcessCompletion(%lu)] Context=%x has invalid type of IO op[%x]\n",
                            GetCurrentThreadId(),pAtqContext,
                            pAtqContext->arInfo.atqOp));
                    DBG_ASSERT(FALSE);
                    break;
                }
            }

            //
            // Set the last error code in context
            //

            if (SOCKET_ERROR == dwErr) {

                ATQ_PRINTF((DBG_CONTEXT,
                        "Error %d in socket operation[%d]\n",
                        WSAGetLastError(),
                        pAtqContext->arInfo.atqOp
                        ));

                pAtqContext->arInfo.dwLastIOError = WSAGetLastError();

                //
                // If this operation would be blocked - retry it again
                //

                if ( WSAEWOULDBLOCK == pAtqContext->arInfo.dwLastIOError) {
                    continue;
                }
                cbBytesTransferred = 0;
            } else {

                IF_DEBUG(SIO) {
                    ATQ_PRINTF((DBG_CONTEXT,
                        "SIO operation[%d] returns %d bytes\n",
                        pAtqContext->arInfo.atqOp,
                        nBytes));
                }

                pAtqContext->arInfo.dwLastIOError = NOERROR;
                cbBytesTransferred = nBytes;
            }

            //
            // Set parameters in ATQ context I/O request block
            //

            pAtqContext->arInfo.dwTotalBytesTransferred = cbBytesTransferred;

            //
            // Clean up SIO state
            //

            pAtqContext->dwSIOFlags &= ~ATQ_SIO_FLAG_STATE_MASK;

            //
            // Queue this context to completed queue
            //

            SIOPostCompletionStatus((HANDLE)this,
                                    cbBytesTransferred,
                                    (DWORD)pAtqContext,
                                    pAtqContext->arInfo.lpOverlapped
                                    );

            //
            // Remove socket from the set where it is now
            //

            FD_CLR(pCurrentSet->fd_array[Count],pCurrentStoreSet);

        }

        pCurrentSet = WriteFds;
        pCurrentStoreSet = &m_WritefdsStore;

    }

    return TRUE;

} // ProcessSocketCompletion


VOID
W95CPORT::CleanupDescriptorList(
    VOID
    )
/*++

Routine Description:

    Prepares sockets array for select call.

Arguments:

Return Value:

--*/
{
    UINT    i = 0;
    UINT    Count;

    int     sErr;
    int     iSocketType ;
    int     iOptLen = sizeof(iSocketType);

    PFD_SET pCurrentStoreSet = &m_ReadfdsStore;
    FD_SET  fdsMarked;

    //
    // First process read set,then write set
    //

    for (i=0;i<2;i++) {

        FD_ZERO(&fdsMarked);

        //
        // Walk scheduled sockets in current descriptor set
        //

        for (Count=0;Count < pCurrentStoreSet->fd_count;Count++) {

            PATQ_CONT   pAtqContext = NULL;

            //
            // If this is wakeup socket - skip iteration
            //

            if ((m_scWakeup == pCurrentStoreSet->fd_array[Count]) &&
                (pCurrentStoreSet == &m_ReadfdsStore) ) {

                continue;
            }

            //
            // Find ATQ context associated with signalled socket
            //

            pAtqContext = FindATQContextFromSocket(
                                    pCurrentStoreSet->fd_array[Count]
                                    );

            if ( pAtqContext == NULL ) {

                //
                // Did not locate context - remove socket from the set where it is now
                // Socket should be really closed do we need to close  it again ?
                //

                ATQ_PRINTF((DBG_CONTEXT,
                       "[CleanupDLists(%lu)] Context not found for socket=%x.Cleaning record\n",
                        GetCurrentThreadId(),pCurrentStoreSet->fd_array[Count]));

                //FD_CLR(pCurrentStoreSet->fd_array[Count],pCurrentStoreSet);
                FD_SET((SOCKET)pCurrentStoreSet->fd_array[Count],&fdsMarked);
                closesocket(pCurrentStoreSet->fd_array[Count]);

            } else {

                //
                // Found ATQ context, validate if socket handle is still valid.
                // Reason for this check is that it is possible that socket will be closed by one
                // thread , while "select" pump thread is not waiting on select. It would be better
                // to communicate this event by using thread message , for now we just use
                // more brute force approach. If socked handle is not valid after select failed
                // with NOSOCKET error code, we signal i/o completion failure for this context and
                // remove socket from waiting list
                //

                sErr = getsockopt((SOCKET)pCurrentStoreSet->fd_array[Count],
                                  SOL_SOCKET,
                                  SO_TYPE,
                                  (char *)&iSocketType,&iOptLen);

                if (sErr != NO_ERROR) {

                    ATQ_PRINTF((DBG_CONTEXT,"Error %d in getsockopt\n",
                        WSAGetLastError()));

                    //
                    // Found invalid socket in store list, signal it's context with failure
                    // error code
                    // BUGBUG This code is identical to code used in completion processing
                    // routine, should be in separate method
                    //
                    // Set parameters in ATQ context I/O request block
                    //

                    pAtqContext->arInfo.dwTotalBytesTransferred = 0;

                    pAtqContext->arInfo.dwLastIOError = ERROR_OPERATION_ABORTED;

                    //
                    // Clean up SIO state
                    //

                    pAtqContext->dwSIOFlags &= ~ATQ_SIO_FLAG_STATE_MASK;

                    //
                    // Queue this context to completed queue
                    //

                    SIOPostCompletionStatus((HANDLE)this,
                                            0,
                                            (DWORD)pAtqContext,
                                            pAtqContext->arInfo.lpOverlapped
                                            );

                    //
                    // Remove socket from the set where it is now
                    //

                    FD_SET((SOCKET)pCurrentStoreSet->fd_array[Count],&fdsMarked);
                }
            }
        }

        //
        // Now remove all sockets marked from current set
        //

        for (Count=0;Count < fdsMarked.fd_count;Count++) {
            FD_CLR(fdsMarked.fd_array[Count],pCurrentStoreSet);
        }

        pCurrentStoreSet = &m_WritefdsStore;
    }

} // W95CPORT::CleanupDescriptorList



BOOL
W95CPORT::SIOCheckCompletionThreadStatus(
    VOID
    )
/*++

Routine Description:

    This routine makes sure there is at least one thread in
    the thread pool.

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    BOOL    fRet = TRUE;

    //
    //  If no threads are available, kick a new one off up to the limit
    //

    if (!InterlockedExchange(&m_IsThreadRunning,1)) {

        DWORD dwId;

        ATQ_PRINTF((DBG_CONTEXT,"Starting a new SIO Pool Thread\n"));

        m_hThread = CreateThread(
                                NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)SIOPoolThread,
                                this,
                                0,
                                &dwId
                                );

        if ( !m_hThread ) {
            fRet = FALSE;
        }
    }

    return fRet;

} // SIOCheckCompletionThreadStatus()


BOOL
SIOWSARecv(
    IN PATQ_CONT    pContext,
    IN LPWSABUF     pwsaBuffers,
    IN DWORD        dwBufferCount,
    IN OVERLAPPED * lpo OPTIONAL
    )
/*++

Routine Description:

    This routine does WSARecv+fake completion port

Arguments:
    pContext - pointer to ATQ context
    lpBuffer - Buffer to put read data in
    BytesToRead - number of bytes to read
    lpo - Overlapped structure to use

Return Value:
    TRUE on success and FALSE if there is a failure.

--*/
{
    pContext->arInfo.atqOp = AtqIoRead;
    pContext->arInfo.lpOverlapped = lpo;
    pContext->arInfo.uop.opReadWrite.dwBufferCount = dwBufferCount;

    if ( dwBufferCount == 1) {
        pContext->arInfo.uop.opReadWrite.buf1.len = pwsaBuffers->len;
        pContext->arInfo.uop.opReadWrite.buf1.buf = pwsaBuffers->buf;
        pContext->arInfo.uop.opReadWrite.pBufAll  =
            &pContext->arInfo.uop.opReadWrite.buf1;

    } else {

        DBG_ASSERT( dwBufferCount > 1);

        WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwBufferCount * sizeof (WSABUF));

        if ( pBuf != NULL) {

            pContext->arInfo.uop.opReadWrite.pBufAll = pBuf;
            CopyMemory( pBuf, pwsaBuffers,
                        dwBufferCount * sizeof(WSABUF));
        } else {
            ATQ_PRINTF((DBG_CONTEXT,
                "Failed to allocate buffer[%d] for WSARecv\n",
                dwBufferCount));
            return ( FALSE);
        }
    }

    return(SIOStartAsyncOperation(
                        g_hIoCompPort,
                        (PATQ_CONTEXT)pContext
                        ));

} // SIOWSARecv


BOOL
SIOWSASend(
    IN PATQ_CONT    pContext,
    IN LPWSABUF     pwsaBuffers,
    IN DWORD        dwBufferCount,
    IN OVERLAPPED * lpo OPTIONAL
    )
/*++

Routine Description:

    This routine does WSASend+fake completion port

Arguments:
    pContext - pointer to ATQ context
    lpBuffer - Buffer to put read data in
    BytesToRead - number of bytes to read
    lpo - Overlapped structure to use

Return Value:
    TRUE on success and FALSE if there is a failure.

--*/
{
    pContext->arInfo.atqOp = AtqIoWrite;
    pContext->arInfo.lpOverlapped = lpo;
    pContext->arInfo.uop.opReadWrite.dwBufferCount = dwBufferCount;

    if ( dwBufferCount == 1) {
        pContext->arInfo.uop.opReadWrite.buf1.len = pwsaBuffers->len;
        pContext->arInfo.uop.opReadWrite.buf1.buf = pwsaBuffers->buf;
        pContext->arInfo.uop.opReadWrite.pBufAll  =
            &pContext->arInfo.uop.opReadWrite.buf1;

    } else {
        DBG_ASSERT( dwBufferCount > 1);

        WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwBufferCount * sizeof (WSABUF));

        if ( pBuf != NULL) {
            pContext->arInfo.uop.opReadWrite.pBufAll = pBuf;
            CopyMemory( pBuf, pwsaBuffers,
                        dwBufferCount * sizeof(WSABUF));

        } else {
            ATQ_PRINTF((DBG_CONTEXT,
                "Failed to allocate buffer[%d] for WSARecv\n",
                dwBufferCount));
            return ( FALSE);
        }
    }

    return(SIOStartAsyncOperation(
                        g_hIoCompPort,
                        (PATQ_CONTEXT)pContext
                        ));

} // SIOWSASend

/************************************************************
*  Private functions.
************************************************************/

PATQ_CONT
SIO_Private_GetQueuedContext(
    IN PLIST_ENTRY pQueue
    )
{

    PATQ_CONT   pAtqContext = NULL;
    PLIST_ENTRY pEntry;

    //
    // We may have something in the queue
    //

    SIOLockGlobals();

    //
    // Remove first event from queue
    //

    if ( !IsListEmpty(pQueue)) {

        pEntry = RemoveHeadList( pQueue );
        pAtqContext = CONTAINING_RECORD(
                                pEntry,
                                ATQ_CONTEXT,
                                SIOListEntry
                                );

        pEntry->Flink = pEntry->Blink = NULL;
    }

    SIOUnlockGlobals();

    return pAtqContext;
} // SIO_Private_GetQueuedContext


BOOL
SIOCheckContext(
    IN  PATQ_CONTEXT pAtqC,
    IN  BOOL         fNew       /* = TRUE */
    )
/*++

Routine Description:

   Tries to validate that context can enter completion port.
   If context is already in, signal error condition.

Arguments:

    patqContext - pointer to ATQ context

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{

    PATQ_CONT   pAtqContext = (PATQ_CONT)pAtqC;

    if (!pAtqC || !pAtqC->hAsyncIO) {
        return TRUE;
    }

    if (fNew) {

        //
        // Verify this context is not in SIO yet
        //

        if (( pAtqContext->dwSIOFlags & ATQ_SIO_FLAG_STATE_MASK) ||
            (pAtqContext->SIOListEntry.Flink)) {

            ATQ_PRINTF((DBG_CONTEXT,
                   "[SIOCheckContext(%lu)] Context is already in SIO state = %x  \n ",
                    GetCurrentThreadId(),
                    pAtqContext->dwSIOFlags
                    ));
            ATQ_ASSERT(FALSE);
            return FALSE;
        }

    } else {

        if ( (pAtqContext->dwSIOFlags & ATQ_SIO_FLAG_STATE_MASK) == 0 ) {

            ATQ_PRINTF((DBG_CONTEXT,
                   "[SIOCheckContext(%lu)] Context is not in SIO state = %x while should be\n ",
                    GetCurrentThreadId(),
                    pAtqContext->dwSIOFlags
                    ));
            ATQ_ASSERT(FALSE);
            return FALSE;
        }
    }

    return TRUE;
} // SIOCheckContext


PATQ_CONT
FindATQContextFromSocket(
    SOCKET          sc
    )
{
    LIST_ENTRY * pentry;
    PATQ_CONT   pAtqContext;
    DWORD   FakeSocket = (DWORD)sc | 0x80000000;

    //
    // If socket is obviously invalid - fail
    //

    if (!sc) {

        ATQ_PRINTF((DBG_CONTEXT,"Invalid socket[%d] on find\n",
            sc));
        return NULL;
    }

    ATQ_ASSERT(g_dwNumContextLists == ATQ_NUM_CONTEXT_LIST_W95);

    AtqActiveContextList[0].Lock( );

    for ( pentry  = AtqActiveContextList[0].ActiveListHead.Flink;
          pentry != &AtqActiveContextList[0].ActiveListHead;
          pentry  = pentry->Flink )
    {

        pAtqContext = CONTAINING_RECORD(
                                    pentry,
                                    ATQ_CONTEXT,
                                    m_leTimeout );

        if ( pAtqContext->Signature != ATQ_CONTEXT_SIGNATURE ) {

            ATQ_PRINTF((DBG_CONTEXT,"Invalid signature[%x] on context %x\n",
                pAtqContext->Signature, pAtqContext));

            ATQ_ASSERT( pAtqContext->Signature == ATQ_CONTEXT_SIGNATURE );
            break;
        }

        if ( ((HANDLE)sc == pAtqContext->hAsyncIO)

                            ||

             ((pAtqContext->hJraAsyncIO == FakeSocket) &&
              (pAtqContext->arInfo.atqOp != 0)) ) {

            //
            // We found our context
            //

            AtqActiveContextList[0].Unlock( );

            if ( (HANDLE)sc != pAtqContext->hAsyncIO ) {
                ATQ_PRINTF((DBG_CONTEXT,
                        "Processing leftover context %x[%x]\n",
                            pAtqContext, pAtqContext->arInfo.atqOp));
            }

            IF_DEBUG(SIO) {
                ATQ_PRINTF((DBG_CONTEXT,
                    "Found atq context %x[%x]\n", pAtqContext, sc));
            }
            return pAtqContext;
        }
    }

    AtqActiveContextList[0].Unlock( );

    IF_DEBUG(SIO) {
        ATQ_PRINTF((DBG_CONTEXT,
            "Cannot find atq context for socket %d\n", sc));
    }
    return NULL;

} // FindATQContextFromSocket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\oplock\atqmain.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      atqmain.cxx

   Abstract:
      This module implements entry points for ATQ - Asynchronous Thread Queue.

   Author:

       Murali R. Krishnan    ( MuraliK )     8-Apr-1996

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Common DLL

   Functions Exported:

       BOOL  AtqInitialize();
       BOOL  AtqTerminate();

       DWORD AtqSetInfo();
       DWORD AtqGetInfo();
       BOOL  AtqGetStatistics();
       BOOL  AtqClearStatistics();

       BOOL  AtqAddAcceptExSockets();
       BOOL  AtqAddAsyncHandle();
       DWORD AtqContextSetInfo();
       VOID  AtqCloseSocket();
       VOID  AtqFreeContext();

       BOOL  AtqReadFile();
       BOOL  AtqWriteFile();
       BOOL  AtqTransmitFile();
       BOOL  AtqPostCompletionStatus();

       PVOID AtqAllocateBandwidthInfo();
       BOOL  AtqFreeBandwidthInfo();
       DWORD AtqBandwidthSetInfo();
--*/

#include "isatq.hxx"


# define ATQ_REG_DEF_THREAD_TIMEOUT_PWS    (30*60)  // 30 minutes

/************************************************************
 * Globals
 ************************************************************/

// ------------------------------
// Configuration for ATQ package
// ------------------------------

extern CHAR g_PSZ_ATQ_CONFIG_PARAMS_REG_KEY[];

//
// concurrent # of threads to run per processor
//

DWORD g_cConcurrency = ATQ_REG_DEF_PER_PROCESSOR_CONCURRENCY;

//
//  Amount of time (in ms) a worker thread will be idle before suicide
//

DWORD g_msThreadTimeout = ATQ_REG_DEF_THREAD_TIMEOUT * 1000;

DWORD g_cCPU = 0;               // # of CPUs in machine (for thread-tuning)
BOOL  g_fUseAcceptEx = TRUE;    // Use AcceptEx if available

//
// The absolute thread limit
//

LONG   g_cMaxThreadLimit = ATQ_REG_DEF_POOL_THREAD_LIMIT;

//
// Should we use fake completion port
//

BOOL g_fUseFakeCompletionPort =  FALSE;

//
// Assumed minimum file transfer rate
//

DWORD g_cbMinKbSec = ATQ_REG_DEF_MIN_KB_SEC;

//
// Size of buffers for fake xmits
//

DWORD g_cbXmitBufferSize = ATQ_REG_DEF_NONTF_BUFFER_SIZE;

//
// number of active context list
//

DWORD g_dwNumContextLists = ATQ_NUM_CONTEXT_LIST;

/*
   g_pfnExitThreadCallback()
    This routine sets the callback routine to be called when one of the
    Atq threads exit so that thread state data can be cleaned up. Currently
    support is for a single routine. One way to support multiple routines would
    be for the caller to save the return value. Such an application would not
    be able to delete the "saved" callback routine.
 */
ATQ_THREAD_EXIT_CALLBACK g_pfnExitThreadCallback = NULL;

// ----------------------------------
// Fake Completion port
// -----------------------------------
//
// Used to gauge pool thread creation. This variable shows number of
// ATQ contexts // ready to be processed by ATQ pool thread. Basically
// this is length of outcoming queue in SIO module and is modified by
// routines there
//

DWORD   g_AtqWaitingContextsCount = 0;

//
// mswsock entry points
//

HINSTANCE g_hMSWsock = NULL;
PFN_ACCEPTEX g_pfnAcceptEx = NULL;
PFN_GETACCEPTEXSOCKADDRS g_pfnGetAcceptExSockaddrs = NULL;
PFN_TRANSMITFILE g_pfnTransmitFile = NULL;
PFN_GET_QUEUED_COMPLETION_STATUS g_pfnGetQueuedCompletionStatus = NULL;
PFN_CREATE_COMPLETION_PORT g_pfnCreateCompletionPort = NULL;
PFN_CLOSE_COMPLETION_PORT  g_pfnCloseCompletionPort = NULL;
PFN_POST_COMPLETION_STATUS g_pfnPostCompletionStatus = NULL;

HINSTANCE   g_hNtdll = NULL;
PFN_RTL_INIT_UNICODE_STRING g_pfnRtlInitUnicodeString = NULL;
PFN_NT_LOAD_DRIVER          g_pfnNtLoadDriver = NULL;
PFN_RTL_NTSTATUS_TO_DOSERR  g_pfnRtlNtStatusToDosError = NULL;
PFN_RTL_INIT_ANSI_STRING    g_pfnRtlInitAnsiString = NULL;
PFN_RTL_ANSI_STRING_TO_UNICODE_STRING g_pfnRtlAnsiStringToUnicodeString = NULL;
PFN_RTL_DOS_PATHNAME_TO_NT_PATHNAME g_pfnRtlDosPathNameToNtPathName_U = NULL;
PFN_RTL_FREE_HEAP g_pfnRtlFreeHeap = NULL;

//
// NT specific
//

PFN_READ_DIR_CHANGES_W g_pfnReadDirChangesW = NULL;

// ------------------------------
// Current State Information
// ------------------------------


HANDLE  g_hIoCompPort = NULL;      // Handle for IO completion port
HANDLE  g_hOplockCompPort = NULL;  // Handle for oplock completion port
LONG    g_cThreads = 0;          // number of thread in the pool
LONG    g_cAvailableThreads = 0; // # of threads waiting on the port.

//
// Is the NTS driver in use
//

BOOL    g_fUseDriver = FALSE;

//
// Current thread limit
//

LONG    g_cMaxThreads = ATQ_REG_DEF_PER_PROCESSOR_ATQ_THREADS;

DWORD   g_cListenBacklog = ATQ_REG_DEF_LISTEN_BACKLOG;

BOOL    g_fShutdown = FALSE;   // if set, indicates that we are shutting down
                               // in that case, all threads should exit.

HANDLE  g_hShutdownEvent = NULL; // set when all running threads shutdown

// ------------------------------
// Bandwidth Throttling Info
// ------------------------------

PBANDWIDTH_INFO     g_pBandwidthInfo = NULL;

// ------------------------------
// Various State/Object Lists
// ------------------------------

//
// Used to switch context between lists
//

DWORD AtqGlobalContextCount = 0;

//
// List of active context
//

ATQ_CONTEXT_LISTHEAD AtqActiveContextList[ATQ_NUM_CONTEXT_LIST];

//
// List of Endpoints in ATQ - one per listen socket
//

LIST_ENTRY AtqEndpointList;
CRITICAL_SECTION AtqEndpointLock;

PALLOC_CACHE_HANDLER  g_pachAtqContexts;

#ifdef IIS_AUX_COUNTERS

LONG g_AuxCounters[NUM_AUX_COUNTERS];

#endif // IIS_AUX_COUNTERS

// ------------------------------
// local to this module
// ------------------------------

LONG  sg_AtqInitializeCount = -1;
BOOL  g_fSpudInitialized = FALSE;

DWORD
I_AtqGetGlobalConfiguration(VOID);

DWORD
I_NumAtqEndpointsOpen(VOID);


/************************************************************
 * Functions
 ************************************************************/

BOOL
AtqInitialize(
    IN DWORD   dwFlags
    )
/*++
Routine Description:

    Initializes the ATQ package

Arguments:
    dwFlags - DWORD containing the flags for use to initialize ATQ library.
    Notably in many cases one may not need the SPUD driver initialized
      for processes other than the IIS main process. This dword helps
      to shut off the unwanted flags.

    This is an ugly way to initialize/shutdown SPUD, but that is what we
    will do. SPUD supports only ONE completion port and hence when we use
    ATQ in multiple processes we should be careful to initialize SPUD only
    once and hopefully in the IIS main process!

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

Note:
    As of 4/16/97 the pszRegKey that is sent is no more utilized.
    We always load the internal configuration parameters from
     one single registry entry specified by PSZ_ATQ_CONFIG_PARAMS_REG_KEY
    The parameter is left in the command line for compatibility
      with old callers :( - NYI: Need to change this.
--*/
{
    DWORD       i;

    if ( InterlockedIncrement( &sg_AtqInitializeCount) != 0) {

        IF_DEBUG( API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqInitialize( %08x). ATQ is already initialized.\n",
                         dwFlags));
        }

        //
        // we are already initialized. Ignore the new registry settings
        //

        return ( TRUE);
    }

    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqInitialize[%08x]. Initializing....\n",
                     dwFlags));
    }

    //
    // Initialize context lists and crit sects
    //

    ATQ_CONTEXT_LISTHEAD * pacl;

    for ( pacl = AtqActiveContextList;
          pacl < (AtqActiveContextList + g_dwNumContextLists);
          pacl++) {
        pacl->Initialize();
    }

    InitializeListHead( &AtqEndpointList );
    InitializeCriticalSection( &AtqEndpointLock );

    //
    // init bandwidth throttling
    //

    ATQ_REQUIRE( BANDWIDTH_INFO::AbwInitialize() );

    //
    //  Read registry configurable Atq options.  We have to read these now
    //  because concurrency is set for the completion port at creation time.
    //

    DWORD dwError = I_AtqGetGlobalConfiguration();

    if ( NO_ERROR != dwError) {
        SetLastError( dwError);
        return ( FALSE);
    }

    //
    // Setup an allocation cache for the ATQ Contexts
    // NYI: Auto-tune the threshold limit
    //

    {
        ALLOC_CACHE_CONFIGURATION acConfig;

        DWORD nCachedAtq = ATQ_CACHE_LIMIT_NTS;

        if ( TsIsWindows95()) { nCachedAtq = ATQ_CACHE_LIMIT_W95; }

        acConfig.nConcurrency = 1;
        acConfig.nThreshold = nCachedAtq;
        acConfig.cbSize = sizeof(ATQ_CONTEXT);

        g_pachAtqContexts = new ALLOC_CACHE_HANDLER( "ATQ", &acConfig);

        if ( NULL == g_pachAtqContexts) {
            goto cleanup;
        }
    }


    //
    //  Create the shutdown event
    //

    g_hShutdownEvent = CreateEvent( NULL,    // lpsa (Security Attributes)
                                    TRUE,    // Manual reset
                                    FALSE,   // Not signalled
                                    NULL );  // Name for event.

    //
    //  Create the IO completion port
    //

    g_hIoCompPort = g_pfnCreateCompletionPort(INVALID_HANDLE_VALUE,
                                              g_hIoCompPort,
                                              (DWORD) NULL,
                                              g_cConcurrency
                                              );

    if ( !g_hShutdownEvent || !g_hIoCompPort ) {

        OutputDebugString( " Create IoComp port failed\n");
        goto cleanup;
    }

    //
    //  If we'll be using SPUD, then create the oplock completion port
    //  and start the oplock notification thread.
    //

    if( g_fUseDriver ) {
        g_hOplockCompPort = g_pfnCreateCompletionPort(INVALID_HANDLE_VALUE,
                                                      g_hOplockCompPort,
                                                      (DWORD) NULL,
                                                      1
                                                      );

        if( !g_hOplockCompPort ) {
            OutputDebugString( " Create OplockComp port failed\n" );
            goto cleanup;
        }

        if( !I_AtqStartOplockThread() ) {
            OutputDebugString( " Create oplock notification thread failed\n" );
            goto cleanup;
        }
    }

    //
    // initialize spud driver
    //

    if ( dwFlags & ATQ_INIT_SPUD_FLAG ) {
        (VOID) I_AtqSpudInitialize(g_hIoCompPort, g_hOplockCompPort);
        g_fSpudInitialized = TRUE;
    }

    //
    // Ensure all other initializations also are done
    //

    g_cThreads  = 0;
    g_fShutdown = FALSE;
    g_cAvailableThreads = 0;

    if ( !I_AtqStartTimeoutProcessing( NULL ) ) {
        goto cleanup;
    }

    IF_DEBUG(INIT_CLEAN) {
        DBGPRINTF(( DBG_CONTEXT,
                    "fUseAcceptEx[%d] NT CompPort[%d] Platform[%d]"
                    " fUseDriver[%d]\n",
                    g_fUseAcceptEx,  !g_fUseFakeCompletionPort,
                    IISPlatformType(),
                    g_fUseDriver
                    ));
    }

    //
    // Create the initial ATQ thread.
    //

    (VOID)I_AtqCheckThreadStatus( (PVOID)ATQ_INITIAL_THREAD );

    //
    // Create a second thread if we are NTS
    //

    if ( TsIsNtServer() ) {
        (VOID)I_AtqCheckThreadStatus( (PVOID)ATQ_INITIAL_THREAD );
    }

    IF_DEBUG( API_EXIT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqInitialize( %08x) returns %d.\n",
                     dwFlags, TRUE));
    }

    return TRUE;

cleanup:

    for (i=0; i<g_dwNumContextLists; i++) {

        AtqActiveContextList[i].Cleanup();
    }

    DeleteCriticalSection( &AtqEndpointLock);

    if ( g_hShutdownEvent != NULL ) {
        CloseHandle( g_hShutdownEvent );
        g_hShutdownEvent = NULL;
    }

    if ( g_hOplockCompPort != NULL ) {
        I_AtqKillOplockThread();
        g_pfnCloseCompletionPort( g_hOplockCompPort );
        g_hOplockCompPort = NULL;
    }

    if ( g_hIoCompPort != NULL ) {
        g_pfnCloseCompletionPort( g_hIoCompPort );
        g_hIoCompPort = NULL;
    }

    if ( NULL != g_pachAtqContexts) {
        delete g_pachAtqContexts;
        g_pachAtqContexts = NULL;
    }

    ATQ_REQUIRE( BANDWIDTH_INFO::AbwTerminate());

    IF_DEBUG( API_EXIT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqInitialize( %08x) returns %d.\n",
                     dwFlags, FALSE));
    }

    return(FALSE);

} // AtqInitialize()





BOOL
AtqTerminate(
    VOID
    )
/*++

Routine Description:

    Cleans up the ATQ package.  Should only be called after all of the
    clients of ATQ have been shutdown.

Arguments:

    None.

Return Value:

    TRUE, if ATQ was shutdown properly
    FALSE, otherwise

--*/
{
    DWORD       currentThreadCount;
    ATQ_CONTEXT_LISTHEAD * pacl;

    // there are outstanding users, don't fully terminate
    if ( InterlockedDecrement( &sg_AtqInitializeCount) >= 0) {

        IF_DEBUG( API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqTerminate() - there are other users."
                         " Not terminating now\n"
                         ));
        }
        return (TRUE);
    }

    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqTerminate() - Terminating ATQ ...\n"
                     ));
    }


    //
    // All the ATQ endpoints should have been terminated before calling
    //  this ATQTerminate() function. If not, sorry return failure.
    //
    DWORD nEndpointsToBeClosed = I_NumAtqEndpointsOpen();

    if ( nEndpointsToBeClosed > 0) {

        DBGPRINTF(( DBG_CONTEXT,
                    " There are %d endpoints remaining to be closed."
                    " Somebody above stream did not close endpoints."
                    " BUG IN CODE ABOVE ATQ\n"
                    ,
                    nEndpointsToBeClosed
                    ));
        SetLastError( ERROR_NETWORK_BUSY);
        return ( FALSE);
    }


    if ( (g_hShutdownEvent == NULL) || g_fShutdown ) {

        //
        // We have not been intialized or have already terminated.
        //
        SetLastError( ERROR_NOT_READY );
        return FALSE;
    }

    // Cleanup variables in ATQ Bandwidth throttle module
    if ( !BANDWIDTH_INFO::AbwTerminate()) {

        // there may be a few blocked IO. We should avoid them all.
        // All clients should have cleaned themselves up before coming here.
        return (FALSE);
    }

    //
    // All clients should have cleaned themselves up before calling us.
    //

    for ( pacl = AtqActiveContextList;
          pacl < (AtqActiveContextList + g_dwNumContextLists);
          pacl++) {

        pacl->Lock();

        if ( !IsListEmpty(&pacl->ActiveListHead)) {

            ATQ_ASSERT( IsListEmpty( &pacl->ActiveListHead));
            pacl->Unlock();

            IF_DEBUG( API_EXIT) {
                ATQ_PRINTF(( DBG_CONTEXT,
                             "AtqTerminate() - ContextList(%08x) has "
                             "Active Contexts. Failed Termination.\n",
                             pacl
                             ));
            }

            return FALSE;
        }

        pacl->Unlock();
    } // for

    //
    // Note that we are shutting down and prevent any more handles from
    // being added to the completion port.
    //

    g_fShutdown = TRUE;

    //
    // Attempt and remove the TimeOut Context from scheduler queue
    //
    DBG_REQUIRE( I_AtqStopTimeoutProcessing());

    currentThreadCount = g_cThreads;
    if (currentThreadCount > 0) {

        DWORD       i;
        BOOLEAN     fRes;
        OVERLAPPED  overlapped;

        //
        // Post a message to the completion port for each worker thread
        // telling it to exit. The indicator is a NULL context in the
        // completion.
        // BUGBUG: Each thread cannot exit with the first error received.
        //  Some thread has to loop until all contexts have gone away.
        //

        ZeroMemory( &overlapped, sizeof(OVERLAPPED) );

        for (i=0; i<currentThreadCount; i++) {

            fRes = g_pfnPostCompletionStatus( g_hIoCompPort,
                                               0,
                                               0,
                                               &overlapped );

            ATQ_ASSERT( (fRes == TRUE) ||
                       ( (fRes == FALSE) &&
                        (GetLastError() == ERROR_IO_PENDING) )
                       );
        }
    }

    //
    // Now wait for the pool threads to shutdown.
    //

    DWORD dwErr =
        WaitForSingleObject( g_hShutdownEvent, ATQ_WAIT_FOR_THREAD_DEATH);
#if 0
    DWORD dwWaitCount = 0;
    while ( dwErr == WAIT_TIMEOUT) {

        dwWaitCount++;
        DebugBreak();
        Sleep( 10*1000);  // sleep for some time
        dwErr =
            WaitForSingleObject( g_hShutdownEvent, ATQ_WAIT_FOR_THREAD_DEATH);
    } // while
# endif // 0

    //
    // At this point, no other threads should be left running.
    //
    //
    //  g_cThreads counter is decremented by AtqPoolThread().
    //  AtqTerminate() is called during the DLL termination
    //  But at DLL termination, all ATQ pool threads are killed =>
    //    no one is decrementing the count. Hence this assert will always fail.
    //

    // ATQ_ASSERT( !g_cThreads );

    if( g_hIoCompPort != NULL ) {
        I_AtqKillOplockThread();
        g_pfnCloseCompletionPort( g_hOplockCompPort );
        g_hOplockCompPort = NULL;
    }

    ATQ_REQUIRE( CloseHandle( g_hShutdownEvent ) );
    g_pfnCloseCompletionPort( g_hIoCompPort );

    g_hShutdownEvent = NULL;
    g_hIoCompPort = NULL;

    //
    // Cleanup our synchronization resources
    //

    for ( pacl = AtqActiveContextList;
          pacl < (AtqActiveContextList + g_dwNumContextLists);
          pacl++) {
        PLIST_ENTRY pEntry;

        pacl->Lock();

        if ( !IsListEmpty( &pacl->PendingAcceptExListHead)) {
            for ( pEntry = pacl->PendingAcceptExListHead.Flink;
                  pEntry != &pacl->PendingAcceptExListHead;
                  pEntry  = pEntry->Flink ) {

                PATQ_CONT pContext =
                    CONTAINING_RECORD( pEntry, ATQ_CONTEXT, m_leTimeout );

                ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                pContext->Print();
            } // for
        }

        pacl->Unlock();
        pacl->Cleanup();
    }


    //
    // Free all the elements in the Allocation caching list
    //
    if ( NULL != g_pachAtqContexts) {
        delete g_pachAtqContexts;
        g_pachAtqContexts = NULL;
    }

    DeleteCriticalSection( &AtqEndpointLock);

    //
    // cleanup driver
    //

    if ( g_fSpudInitialized ) {
        (VOID)I_AtqSpudTerminate();
        g_fSpudInitialized = FALSE;
    }

    if ( g_hNtdll != NULL ) {
        FreeLibrary(g_hNtdll);
        g_hNtdll = NULL;
    }

    if ( g_hMSWsock != NULL ) {
        FreeLibrary(g_hMSWsock);
        g_hMSWsock = NULL;
    }

    IF_DEBUG( API_EXIT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqTerminate() - Successfully cleaned up.\n"
                     ));
    }

    return TRUE;
} // AtqTerminate()





DWORD
AtqSetInfo(
    IN ATQ_INFO         atqInfo,
    IN DWORD            Data
    )
/*++

Routine Description:

    Sets various bits of information for the ATQ module

Arguments:

    atqInfo     - Data item to set
    data        - New value for item

Return Value:

    The old value of the parameter

--*/
{
    DWORD     dwOldVal = 0;

    switch ( atqInfo ) {

    case AtqBandwidthThrottle:

        ATQ_ASSERT( g_pBandwidthInfo != NULL );
        dwOldVal = g_pBandwidthInfo->SetBandwidthLevel( Data );
        break;

    case AtqBandwidthThrottleMaxBlocked:

        ATQ_ASSERT( g_pBandwidthInfo != NULL );
        dwOldVal = g_pBandwidthInfo->SetMaxBlockedListSize( Data );
        break;

    case AtqExitThreadCallback:

        dwOldVal = (DWORD ) g_pfnExitThreadCallback;
        g_pfnExitThreadCallback =  (ATQ_THREAD_EXIT_CALLBACK ) Data;
        break;

    case AtqMaxPoolThreads:
          // the value is per processor values
        // internally we maintain value for all processors
        dwOldVal = g_cMaxThreads/g_cCPU;
        g_cMaxThreads = Data * g_cCPU;
        break;

      //
      //  Increment or decrement the max thread count.  In this instance, we
      //  do not scale by the number of CPUs
      //

      case AtqIncMaxPoolThreads:
        InterlockedIncrement( (LONG *) &g_cMaxThreads );
        dwOldVal = TRUE;
        break;

      case AtqDecMaxPoolThreads:
        InterlockedDecrement( (LONG *) &g_cMaxThreads );
        dwOldVal = TRUE;
        break;


      case AtqMaxConcurrency:
        dwOldVal = g_cConcurrency;
        g_cConcurrency = Data;
        break;

      case AtqThreadTimeout:
        dwOldVal = g_msThreadTimeout/1000;  // convert back to seconds
        g_msThreadTimeout = Data * 1000;    // convert value to millisecs
        break;

      case AtqUseAcceptEx:
        dwOldVal = g_fUseAcceptEx;
        if ( !TsIsWindows95() ) {
            g_fUseAcceptEx = Data;
        }
        break;

      case AtqMinKbSec:

        //
        //  Ignore it if the value is zero
        //

        if ( Data ) {
            dwOldVal = g_cbMinKbSec;
            g_cbMinKbSec = Data;
        }
        break;

      default:
        ATQ_ASSERT( FALSE );
        break;
    }

    return dwOldVal;
} // AtqSetInfo()





DWORD
AtqGetInfo(
    IN ATQ_INFO  atqInfo
    )
/*++

Routine Description:

    Gets various bits of information for the ATQ module

Arguments:

    atqInfo     - Data item to set

Return Value:

    The old value of the parameter

--*/
{
    DWORD     dwVal = 0;

    switch ( atqInfo ) {

      case AtqBandwidthThrottle:
        ATQ_ASSERT( g_pBandwidthInfo != NULL );
        dwVal = g_pBandwidthInfo->QueryBandwidthLevel();
        break;

      case AtqExitThreadCallback:

        dwVal = (DWORD ) g_pfnExitThreadCallback;
        break;

      case AtqMaxPoolThreads:
        dwVal = g_cMaxThreads/g_cCPU;
        break;

      case AtqMaxConcurrency:
        dwVal = g_cConcurrency;
        break;

      case AtqThreadTimeout:
        dwVal = g_msThreadTimeout/1000; // convert back to seconds
        break;

      case AtqUseAcceptEx:
        dwVal = g_fUseAcceptEx;
        break;

      case AtqMinKbSec:
        dwVal = g_cbMinKbSec;
        break;

      default:
        ATQ_ASSERT( FALSE );
        break;
    } // switch

    return dwVal;
} // AtqGetInfo()





BOOL
AtqGetStatistics(IN OUT ATQ_STATISTICS * pAtqStats)
{
    if ( pAtqStats != NULL) {

        return g_pBandwidthInfo->GetStatistics( pAtqStats );

    } else {

        SetLastError( ERROR_INVALID_PARAMETER);
        return (FALSE);
    }
} // AtqGetStatistics()





BOOL
AtqClearStatistics( VOID)
{
    return g_pBandwidthInfo->ClearStatistics();

} // AtqClearStatistics()





DWORD
AtqContextSetInfo(
    PATQ_CONTEXT           patqContext,
    enum ATQ_CONTEXT_INFO  atqInfo,
    DWORD                  Data
    )
/*++

Routine Description:

    Sets various bits of information for this context

Arguments:

    patqContext - pointer to ATQ context
    atqInfo     - Data item to set
    data        - New value for item

Return Value:

    The old value of the parameter

--*/
{
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    DWORD     dwOldVal = 0;

    ATQ_ASSERT( pContext );
    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

    if ( pContext && pContext->Signature == ATQ_CONTEXT_SIGNATURE )
    {
        switch ( atqInfo ) {

        case ATQ_INFO_TIMEOUT:
            dwOldVal = pContext->TimeOut;
            pContext->TimeOut = CanonTimeout( Data );
            break;

        case ATQ_INFO_RESUME_IO:

            //
            // set back the max timeout from pContext->TimeOut
            // This will ensure that timeout processing can go on
            //   peacefully.
            //

            {
                DWORD currentTime = AtqGetCurrentTick( );
                DWORD timeout;
                dwOldVal = pContext->NextTimeout;
                timeout = pContext->TimeOut;

                //
                // Set the new timeout
                //

                I_SetNextTimeout(pContext);

                //
                // Return the old
                //

                if ( currentTime >= dwOldVal ) {
                    ATQ_ASSERT((dwOldVal & ATQ_INFINITE) == 0);
                    dwOldVal = 0;
                } else if ( (dwOldVal & ATQ_INFINITE) == 0 ) {
                    dwOldVal -= currentTime;
                }

                // return correct units
                dwOldVal = UndoCanonTimeout( dwOldVal );
            }
            break;

        case ATQ_INFO_COMPLETION:
            dwOldVal = (DWORD) pContext->pfnCompletion;
            pContext->pfnCompletion = (ATQ_COMPLETION) Data;
            break;

        case ATQ_INFO_COMPLETION_CONTEXT:

            ATQ_ASSERT( Data != 0 );        // NULL context not allowed

            dwOldVal = (DWORD) pContext->ClientContext;
            pContext->ClientContext = (void *) Data;
            break;

        case ATQ_INFO_BANDWIDTH_INFO:
        {
            ATQ_ASSERT( Data != 0 );

            PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) Data;

            ATQ_ASSERT( pBandwidthInfo->QuerySignature() ==
                                                ATQ_BW_INFO_SIGNATURE );

            if ( !pBandwidthInfo->IsFreed() )
            {
                pContext->m_pBandwidthInfo = (PBANDWIDTH_INFO) Data;
                pContext->m_pBandwidthInfo->Reference();
            }
            break;
        }

        case ATQ_INFO_ABORTIVE_CLOSE:
            dwOldVal = pContext->IsFlag( ACF_ABORTIVE_CLOSE );
            if ( Data )
            {
                pContext->SetFlag( ACF_ABORTIVE_CLOSE );
            }
            else
            {
                pContext->ResetFlag( ACF_ABORTIVE_CLOSE );
            }
            break;

        default:
            ATQ_ASSERT( FALSE );
        }
    }

    return dwOldVal;

} // AtqContextSetInfo()



BOOL
AtqAddAsyncHandle(
    PATQ_CONTEXT * ppatqContext,
    PVOID          EndpointObject,
    PVOID          ClientContext,
    ATQ_COMPLETION pfnCompletion,
    DWORD          TimeOut,
    HANDLE         hAsyncIO
    )
/*++

Routine Description:

    Adds a handle to the thread queue

    The client should call this after the IO handle is opened
    and before the first IO request is made

    Even in the case of failure, client should call AtqFreeContext() and
     free the memory associated with this object.

Arguments:

    ppatqContext - Receives allocated ATQ Context
    Context - Context to call client with
    pfnCompletion - Completion to call when IO completes
    TimeOut - Time to wait (sec) for IO completion (INFINITE is valid)
    hAsyncIO - Handle with pending read or write

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    return ( I_AtqAddAsyncHandle( (PATQ_CONT *) ppatqContext,
                                  (PATQ_ENDPOINT) EndpointObject,
                                  ClientContext,
                                  pfnCompletion,
                                  TimeOut,
                                  hAsyncIO)
             &&
             I_AddAtqContextToPort( *((PATQ_CONT *) ppatqContext))
            );

} // AtqAddAsyncHandle()




VOID
AtqGetAcceptExAddrs(
    IN  PATQ_CONTEXT patqContext,
    OUT SOCKET *     pSock,
    OUT PVOID *      ppvBuff,
    OUT PVOID *      pEndpointContext,
    OUT SOCKADDR * * ppsockaddrLocal,
    OUT SOCKADDR * * ppsockaddrRemote
    )
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    INT       cbsockaddrLocal;
    INT       cbsockaddrRemote;
    DWORD     cb;

    ATQ_ASSERT( g_fUseAcceptEx);
    ATQ_ASSERT( pContext->pEndpoint);

    *pSock   = (SOCKET) pContext->hAsyncIO;
    *pEndpointContext = pContext->pEndpoint->Context;

    //
    //  The buffer not only receives the initial received data, it also
    //  gets the sock addrs, which must be at least sockaddr_in + 16 bytes
    //  large
    //

    g_pfnGetAcceptExSockaddrs( pContext->pvBuff,
                               (cb = pContext->pEndpoint->InitialRecvSize),
                               MIN_SOCKADDR_SIZE,
                               MIN_SOCKADDR_SIZE,
                               ppsockaddrLocal,
                               &cbsockaddrLocal,
                               ppsockaddrRemote,
                               &cbsockaddrRemote );

    *ppvBuff = ( ( cb == 0) ? NULL : pContext->pvBuff);

    return;
} // AtqGetAcceptExAddrs()




BOOL
AtqCloseSocket(
    PATQ_CONTEXT patqContext,
    BOOL         fShutdown
    )
/*++

  Routine Description:

    Closes the socket in this atq structure if it wasn't
    closed by transmitfile. This function should be called only
    if the embedded handle in AtqContext is a Socket.

  Arguments:

    patqContext - Context whose socket should be closed.
    fShutdown - If TRUE, means we call shutdown and always close the socket.
        Note that if TransmitFile closed the socket, it will have done the
        shutdown for us

  Returns:
    TRUE on success and FALSE if there is a failure.
--*/
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    if ( pContext ) {

        ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

        BOOL fAbortiveClose;

        fAbortiveClose = pContext->IsFlag( ACF_ABORTIVE_CLOSE );
        pContext->ResetFlag( ACF_ABORTIVE_CLOSE );

        //
        //  Don't delete the socket if we don't have to
        //

        if ( pContext->IsState( ACS_SOCK_UNCONNECTED |
                                ACS_SOCK_CLOSED)
             ) {

            //
            //  Do nothing
            //

        } else {

            // default:
            // case ACS_SOCK_LISTENING:
            // case ACS_SOCK_CONNECTED: {

            HANDLE hIO;
            PATQ_ENDPOINT pEndpoint;

            pEndpoint = pContext->pEndpoint;

            pContext->MoveState( ACS_SOCK_CLOSED);

            //
            //  During shutdown, the socket may be closed while this thread
            //  is doing processing, so only give a warning if any of the
            //  following fail
            //

            hIO = (HANDLE )InterlockedExchange((LPLONG) &pContext->hAsyncIO,
                                               (LONG) NULL);

            if ( hIO == NULL ) {

                //
                // No socket - it is already closed - do nothing.
                //

            } else {

                if (fAbortiveClose || fShutdown ) {

                    //
                    //  If this is an AcceptEx socket, we must first force a
                    //  user mode context update before we can call shutdown
                    //

                    if ( (pEndpoint != NULL) && (pEndpoint->UseAcceptEx) ) {

                        if ( setsockopt( (SOCKET) hIO,
                                         SOL_SOCKET,
                                         SO_UPDATE_ACCEPT_CONTEXT,
                                         (char *) &pEndpoint->ListenSocket,
                                         sizeof(SOCKET) ) == SOCKET_ERROR ) {

                            ATQ_PRINTF(( DBG_CONTEXT,
                                         "[AtqCloseSocket] Warning- setsockopt "
                                         "failed, error %d, socket = %x,"
                                         " Context= %08x, Listen = %lx\n",
                                         GetLastError(),
                                         hIO,
                                         pContext,
                                         pEndpoint->ListenSocket ));
                        }
                    }
                } // setsock-opt call

                if ( fAbortiveClose ) {
                    LINGER  linger;

                    linger.l_onoff = TRUE;
                    linger.l_linger = 0;

                    if ( setsockopt( (SOCKET) hIO,
                                     SOL_SOCKET,
                                     SO_LINGER,
                                     (char *) &linger,
                                     sizeof(linger) ) == SOCKET_ERROR
                         ) {
                        ATQ_PRINTF(( DBG_CONTEXT,
                                     "[AtqCloseSocket] Warning- setsockopt "
                                     "failed, error %d, socket = %x,"
                                     " Context= %08x, Listen = %lx\n",
                                     GetLastError(),
                                     hIO,
                                     pContext,
                                     pEndpoint->ListenSocket ));
                    }
                    else {
                        ATQ_PRINTF(( DBG_CONTEXT,
                                     "[AtqCloseSocket(%08x)] requested"
                                     " abortive close\n",
                                     pContext));
                    }
                } // set up linger

                if ( fShutdown ) {

                    //
                    //  Note that shutdown can fail in instances where the
                    //  client aborts in the middle of a TransmitFile.
                    //  This is an acceptable failure case
                    //

                    shutdown( (int) hIO, 1 );
                }

                DBG_ASSERT( hIO != NULL);

                if ( closesocket( (int) hIO ) ) {

                    ATQ_PRINTF(( DBG_CONTEXT,
                                 "[AtqCloseSocket] Warning- closesocket "
                                 " failed, Context = %08x, error %d,"
                                 " socket = %x\n",
                                 pContext,
                                 GetLastError(),
                                 hIO ));
                }
            } // if (hIO != NULL)
        }

        return TRUE;
    }

    DBGPRINTF(( DBG_CONTEXT, "[AtqCloseSocket] Warning - NULL Atq context\n"));
    SetLastError( ERROR_INVALID_PARAMETER );
    return FALSE;
} // AtqCloseSocket()



BOOL
AtqCloseFileHandle(
    PATQ_CONTEXT patqContext
    )
/*++

  Routine Description:

    Closes the file handle in this atq structure.
    This function should be called only if the embedded handle
    in AtqContext is a file handle.

  Arguments:

    patqContext - Context whose file handle should be closed.

  Returns:
    TRUE on success and FALSE if there is a failure.

  Note:
   THIS FUNCTIONALITY IS ADDED TO SERVE A SPECIAL REQUEST!!!
   Most of the ATQ code thinks that the handle here is a socket.
   Except of course this function...
--*/
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    if ( pContext != NULL ) {

        HANDLE hIO;

        ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
        ATQ_ASSERT( !pContext->IsAcceptExRootContext());
        ATQ_ASSERT( !TsIsWindows95() );  // NYI

        hIO =
          (HANDLE ) InterlockedExchange((LPLONG ) &pContext->hAsyncIO,
                                        (LONG ) NULL);

        if ( (hIO == NULL) || !CloseHandle( hIO ) ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                        "[AtqCloseFileHandle] Warning- CloseHandle failed, "
                        " Context = %08x, error %d, handle = %x\n",
                        pContext,
                        GetLastError(),
                        hIO ));
        }

        return TRUE;
    }

    DBGPRINTF(( DBG_CONTEXT, "[AtqCloseSocket] Warning - NULL Atq context\n"));
    SetLastError( ERROR_INVALID_PARAMETER );
    return FALSE;
} // AtqCloseFileHandle()





VOID
AtqFreeContext(
    PATQ_CONTEXT patqContext,
    BOOL         fReuseContext
    )
/*++

Routine Description:

    Frees the context created in AtqAddAsyncHandle.
    Call this after the async handle has been closed and all outstanding
    IO operations have been completed. The context is invalid after this call.
    Call AtqFreeContext() for same context only ONCE.

Arguments:

    patqContext - Context to free
    fReuseContext - TRUE if this can context can be reused in the context of
        the calling thread.  Should be FALSE if the calling thread will exit
        soon (i.e., isn't an AtqPoolThread).

--*/
{
    PATQ_CONT pContext = (PATQ_CONT)patqContext;

    ATQ_ASSERT( pContext != NULL );

    IF_DEBUG( API_ENTRY) {

        ATQ_PRINTF(( DBG_CONTEXT, "AtqFreeContext( %08x (handle=%08x,"
                     " nIOs = %d), fReuse=%d)\n",
                     patqContext, patqContext->hAsyncIO,
                     pContext->m_nIO,
                     fReuseContext));
    }

    if ( pContext ) {

        ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

        if ( fReuseContext ) {
            pContext->SetFlag( ACF_REUSE_CONTEXT);
        } else {
            pContext->ResetFlag( ACF_REUSE_CONTEXT);
        }

        if ( InterlockedDecrement(  &pContext->m_nIO) == 0) {

            //
            // The number of outstanding ref holders is ZERO.
            // Free up this ATQ context.
            //
            // We really do not free up the context - but try to reuse
            //  it if possible
            //

            DBG_ASSERT( pContext->lSyncTimeout == 0);
            AtqpReuseOrFreeContext( pContext, fReuseContext);
        }
    }

    return;
} // AtqFreeContext()



BOOL
AtqReadFile(
        IN PATQ_CONTEXT patqContext,
        IN LPVOID       lpBuffer,
        IN DWORD        BytesToRead,
        IN OVERLAPPED * lpo OPTIONAL
        )
/*++

  Routine Description:

    Does an async read using the handle defined in the context.

  Arguments:

    patqContext - pointer to ATQ context
    lpBuffer - Buffer to put read data in
    BytesToRead - number of bytes to read
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbRead;     // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( !TsIsWindows95() );  // NYI
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    InterlockedIncrement( &pContext->m_nIO);

    I_SetNextTimeout(pContext);
    pContext->BytesSent = 0;

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    switch ( pBandwidthInfo->QueryStatus( AtqIoRead ) ) {

      case StatusAllowOperation:

        pBandwidthInfo->IncTotalAllowedRequests();
        fRes = ( ReadFile( pContext->hAsyncIO,
                          lpBuffer,
                          BytesToRead,
                          &cbRead,
                          lpo ) ||
                GetLastError() == ERROR_IO_PENDING);

        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

        break;

      case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoRead;
        pContext->arInfo.lpOverlapped = lpo;
        pContext->arInfo.uop.opReadWrite.buf1.len = BytesToRead;
        pContext->arInfo.uop.opReadWrite.buf1.buf = (CHAR * ) lpBuffer;
        pContext->arInfo.uop.opReadWrite.dwBufferCount = 1;
        pContext->arInfo.uop.opReadWrite.pBufAll  = NULL;

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext );
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

      default:
        ATQ_ASSERT( FALSE);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;

    } // switch()

    return fRes;
} // AtqReadFile()



BOOL
AtqReadSocket(
        IN PATQ_CONTEXT  patqContext,
        IN LPWSABUF     pwsaBuffers,
        IN DWORD        dwBufferCount,
        IN OVERLAPPED *  lpo OPTIONAL
        )
/*++

  Routine Description:

    Does an async recv using the handle defined in the context
     as a socket.

  Arguments:

    patqContext - pointer to ATQ context
    lpBuffer - Buffer to put read data in
    BytesToRead - number of bytes to read
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbRead;     // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                 "AtqReadSocket(%08lx) called.\n", pContext));
    }

    if (pContext->IsFlag( ACF_RECV_ISSUED)) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqReadSocket -> WSARecv bypassed.\n"));
        pContext->BytesSent = 0;
        pContext->SetFlag( ACF_RECV_CALLED);
        return TRUE;
    }

    I_SetNextTimeout(pContext);


    // count the number of bytes
    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent = 0;

    InterlockedIncrement( &pContext->m_nIO);

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    //
    // NYI: Create an optimal function table
    //

    if ( !g_fUseFakeCompletionPort &&
         (StatusAllowOperation == pBandwidthInfo->QueryStatus( AtqIoRead ) ) ) {

        DWORD  lpFlags = 0;

        fRes = ( (WSARecv( (SOCKET ) pContext->hAsyncIO,
                           pwsaBuffers,
                           dwBufferCount,
                           &cbRead,
                           &lpFlags,  // no flags
                           lpo,
                           NULL       // no completion routine
                           ) == 0) ||
                 (WSAGetLastError() == WSA_IO_PENDING));
        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    } else {

        switch ( pBandwidthInfo->QueryStatus( AtqIoRead ) ) {

        case StatusAllowOperation:

            DBG_ASSERT(g_fUseFakeCompletionPort);

            fRes = SIOWSARecv(
                        pContext,
                        pwsaBuffers,
                        dwBufferCount,
                        lpo
                        );

            break;

        case StatusBlockOperation:

            // store data for restarting the operation.
            pContext->arInfo.atqOp        = AtqIoRead;
            pContext->arInfo.lpOverlapped = lpo;

            pContext->arInfo.uop.opReadWrite.dwBufferCount = dwBufferCount;
            if ( dwBufferCount == 1) {
                pContext->arInfo.uop.opReadWrite.buf1.len = pwsaBuffers->len;
                pContext->arInfo.uop.opReadWrite.buf1.buf = pwsaBuffers->buf;
                pContext->arInfo.uop.opReadWrite.pBufAll  = NULL;
            } else {
                DBG_ASSERT( dwBufferCount > 1);

                //
                // Inefficient: But we will burn CPU for b/w throttling.
                //
                WSABUF * pBuf = (WSABUF *)
                    ::LocalAlloc( LPTR, dwBufferCount * sizeof (WSABUF));
                if ( NULL != pBuf) {
                    pContext->arInfo.uop.opReadWrite.pBufAll = pBuf;
                    CopyMemory( pBuf, pwsaBuffers,
                                dwBufferCount * sizeof(WSABUF));
                } else {
                    return ( FALSE);
                }
            }

            // Put this request in queue of blocked requests.
            fRes = pBandwidthInfo->BlockRequest( pContext );
            if ( fRes )
            {
                pBandwidthInfo->IncTotalBlockedRequests();
                break;
            }
            // fall through

        case StatusRejectOperation:
            InterlockedDecrement( &pContext->m_nIO);
            pBandwidthInfo->IncTotalRejectedRequests();
            SetLastError( ERROR_NETWORK_BUSY);
            fRes = FALSE;
            break;

        default:
            ATQ_ASSERT( FALSE);
            SetLastError( ERROR_INVALID_PARAMETER);
            fRes = FALSE;
            break;
        } // switch()
    }

    return fRes;
} // AtqReadSocket()



BOOL
AtqWriteFile(
    IN PATQ_CONTEXT patqContext,
    IN LPCVOID      lpBuffer,
    IN DWORD        BytesToWrite,
    IN OVERLAPPED * lpo OPTIONAL
    )
/*++

  Routine Description:

    Does an async write using the handle defined in the context.

  Arguments:

    patqContext - pointer to ATQ context
    lpBuffer - Buffer to write
    BytesToWrite - number of bytes to write
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbWritten; // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( !TsIsWindows95() );  // NYI
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    I_SetNextTimeout(pContext);
    pContext->BytesSent = BytesToWrite;

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    InterlockedIncrement( &pContext->m_nIO);

    switch ( pBandwidthInfo->QueryStatus( AtqIoWrite) ) {

      case StatusAllowOperation:

        pBandwidthInfo->IncTotalAllowedRequests();
        fRes = ( WriteFile( pContext->hAsyncIO,
                            lpBuffer,
                            BytesToWrite,
                            &cbWritten,
                            lpo ) ||
                 GetLastError() == ERROR_IO_PENDING);
        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

        break;

      case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoWrite;
        pContext->arInfo.lpOverlapped = lpo;

        pContext->arInfo.uop.opReadWrite.buf1.len = BytesToWrite;
        pContext->arInfo.uop.opReadWrite.buf1.buf = (CHAR * ) lpBuffer;
        pContext->arInfo.uop.opReadWrite.dwBufferCount = 1;
        pContext->arInfo.uop.opReadWrite.pBufAll  = NULL;

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext );
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

    default:
        ATQ_ASSERT( FALSE);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;

    } // switch()

    return fRes;
} // AtqWriteFile()



BOOL
AtqWriteSocket(
    IN PATQ_CONTEXT  patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    IN OVERLAPPED *  lpo OPTIONAL
    )
/*++

  Routine Description:

    Does an async write using the handle defined in the context as a socket.

  Arguments:

    patqContext - pointer to ATQ context
    pwsaBuffer  - pointer to Winsock Buffers for scatter/gather
    dwBufferCount - DWORD containing the count of buffers pointed
                   to by pwsaBuffer
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbWritten; // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    I_SetNextTimeout(pContext);

    //
    // count the number of bytes
    //

    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent = pwsaBuffers->len;
    if ( dwBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaBuffers + 1;
              pWsaBuf <= (pwsaBuffers + dwBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    if ( lpo == NULL ) {
        lpo = &pContext->Overlapped;
    }

    InterlockedIncrement( &pContext->m_nIO);

    if ( !g_fUseFakeCompletionPort &&
         (StatusAllowOperation ==
          pBandwidthInfo->QueryStatus( AtqIoWrite ) ) ) {

        pBandwidthInfo->IncTotalAllowedRequests();
        fRes = ( (WSASend( (SOCKET ) pContext->hAsyncIO,
                           pwsaBuffers,
                           dwBufferCount,
                           &cbWritten,
                           0,               // no flags
                           lpo,
                           NULL             // no completion routine
                           ) == 0) ||
                 (WSAGetLastError() == WSA_IO_PENDING));
        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    } else {
        switch ( pBandwidthInfo->QueryStatus( AtqIoWrite ) ) {

        case StatusAllowOperation:

            pBandwidthInfo->IncTotalAllowedRequests();
            DBG_ASSERT(g_fUseFakeCompletionPort);

            fRes = SIOWSASend(
                        pContext,
                        pwsaBuffers,
                        dwBufferCount,
                        lpo
                        );
            break;

        case StatusBlockOperation:

            // store data for restarting the operation.
            pContext->arInfo.atqOp        = AtqIoWrite;
            pContext->arInfo.lpOverlapped = lpo;

            pContext->arInfo.uop.opReadWrite.dwBufferCount = dwBufferCount;
            if ( dwBufferCount == 1) {
                pContext->arInfo.uop.opReadWrite.buf1.len = pwsaBuffers->len;
                pContext->arInfo.uop.opReadWrite.buf1.buf = pwsaBuffers->buf;
                pContext->arInfo.uop.opReadWrite.pBufAll  = NULL;
            } else {
                DBG_ASSERT( dwBufferCount > 1);

                //
                // Inefficient: But we will burn CPU for b/w throttling.
                //
                WSABUF * pBuf = (WSABUF *)
                    ::LocalAlloc( LPTR, dwBufferCount * sizeof (WSABUF));
                if ( NULL != pBuf) {
                    pContext->arInfo.uop.opReadWrite.pBufAll = pBuf;
                    CopyMemory( pBuf, pwsaBuffers,
                                dwBufferCount * sizeof(WSABUF));
                } else {
                    return ( FALSE);
                }
            }

            // Put this request in queue of blocked requests.
            fRes = pBandwidthInfo->BlockRequest( pContext );
            if ( fRes )
            {
                pBandwidthInfo->IncTotalBlockedRequests();
                break;
            }
            // fall through

        case StatusRejectOperation:
            InterlockedDecrement( &pContext->m_nIO);
            pBandwidthInfo->IncTotalRejectedRequests();
            SetLastError( ERROR_NETWORK_BUSY);
            fRes = FALSE;
            break;

        default:
            ATQ_ASSERT( FALSE);
            SetLastError( ERROR_INVALID_PARAMETER);
            fRes = FALSE;
            break;

        } // switch()
    }

    return fRes;
} // AtqWriteSocket()




BOOL
AtqSyncWsaSend(
    IN  PATQ_CONTEXT patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    OUT LPDWORD      pcbWritten
    )
/*++

  Routine Description:

    Does a sync write of an array of wsa buffers using WSASend.

  Arguments:

    patqContext - pointer to ATQ context
    pwsaBuffer  - pointer to Winsock Buffers for scatter/gather
    dwBufferCount - DWORD containing the count of buffers pointed
                   to by pwsaBuffer
    pcbWritten - ptr to count of bytes written

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{

    BOOL fRes = FALSE;
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);

    fRes = ( WSASend(  (SOCKET ) pContext->hAsyncIO,
                       pwsaBuffers,
                       dwBufferCount,
                       pcbWritten,
                       0,               // no flags
                       NULL,            // lpo == NULL for sync write
                       NULL             // no completion routine
                       ) == 0);

    return fRes;

} // AtqSyncWsaSend()




BOOL
AtqTransmitFile(
    IN PATQ_CONTEXT            patqContext,
    IN HANDLE                  hFile,
    IN DWORD                   dwBytesInFile,
    IN LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
    IN DWORD                   dwFlags
    )
/*++

  Routine Description:

    Does a TransmitFile  using the handle defined in the context.

  Arguments:

    patqContext - pointer to ATQ context
    hFile - handle of file to read from
    dwBytesInFile - Bytes to transmit
    lpTransmitBuffers - transmit buffer structure
    dwFlags - Transmit file flags

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    //
    //  For large file sends, the client's default timeout may not be
    //  adequte for slow links.  Scale based on bytes being sent
    //

    I_SetNextTimeout(pContext);
    pContext->BytesSent = dwBytesInFile;

    if ( dwFlags == 0 ) {

        //
        // If no flags are set, then we can attempt to use the special
        // write-behind flag.  This flag can cause the TransmitFile to
        // complete immediately, before the send actually completes.
        // This can be a significant performance improvement inside the
        // system.
        //

        dwFlags = TF_WRITE_BEHIND;

    } else if ( dwFlags & TF_DISCONNECT ) {

        //
        //  If the socket is getting disconnected, mark it appropriately
        //

        pContext->MoveState( ( ( dwFlags & TF_REUSE_SOCKET )?
                               ACS_SOCK_UNCONNECTED:
                               ACS_SOCK_CLOSED
                               )
                             );
    }

    InterlockedIncrement( &pContext->m_nIO);

    if ( !g_fUseFakeCompletionPort &&
         (StatusAllowOperation == pBandwidthInfo->QueryStatus( AtqIoXmitFile ) ) ) {

        pBandwidthInfo->IncTotalAllowedRequests();
        fRes = (g_pfnTransmitFile( (SOCKET ) pContext->hAsyncIO,
                                hFile,
                                dwBytesInFile,
                                0,
                                &pContext->Overlapped,
                                lpTransmitBuffers,
                                dwFlags ) ||
                (GetLastError() == ERROR_IO_PENDING));
        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    } else {
        switch ( pBandwidthInfo->QueryStatus( AtqIoXmitFile ) ) {

        case StatusAllowOperation:

            DBG_ASSERT(g_fUseFakeCompletionPort);
            pBandwidthInfo->IncTotalAllowedRequests();

            fRes = SIOTransmitFile(
                            pContext,
                            hFile,
                            dwBytesInFile,
                            lpTransmitBuffers
                            );
            break;

        case StatusBlockOperation:

            // store data for restarting the operation.
            pContext->arInfo.atqOp        = AtqIoXmitFile;
            pContext->arInfo.lpOverlapped = &pContext->Overlapped;
            pContext->arInfo.uop.opXmit.hFile = hFile;
            pContext->arInfo.uop.opXmit.dwBytesInFile = dwBytesInFile;
            pContext->arInfo.uop.opXmit.lpXmitBuffers = lpTransmitBuffers;
            pContext->arInfo.uop.opXmit.dwFlags       = dwFlags;

            // Put this request in queue of blocked requests.
            fRes = pBandwidthInfo->BlockRequest( pContext);
            if ( fRes )
            {
                pBandwidthInfo->IncTotalBlockedRequests();
                break;
            }
            // fall through

        case StatusRejectOperation:
            InterlockedDecrement( &pContext->m_nIO);
            pBandwidthInfo->IncTotalRejectedRequests();
            SetLastError( ERROR_NETWORK_BUSY);
            fRes = FALSE;
            break;

        default:
            ATQ_ASSERT( FALSE);
            SetLastError( ERROR_INVALID_PARAMETER);
            fRes = FALSE;
            break;

        } // switch()
    }

    //
    //  Restore the socket state if we failed so that the handle gets freed
    //

    if ( !fRes )
    {
        pContext->MoveState( ACS_SOCK_CONNECTED);
    }

    return fRes;

} // AtqTransmitFile()


BOOL
AtqReadDirChanges(IN PATQ_CONTEXT patqContext,
                  IN LPVOID       lpBuffer,
                  IN DWORD        BytesToRead,
                  IN BOOL         fWatchSubDir,
                  IN DWORD        dwNotifyFilter,
                  IN OVERLAPPED * lpo
                  )
/*++
  AtqReadDirChanges()

  Description:
    This function submits an Async ReadDirectoryChanges() call for
    the Async handle in the ATQ context supplied.
    It always requires a non-NULL overlapped pointer for processing
    this call.

  Arguments:
    patqContext  - pointer to ATQ Context
    lpBuffer     - buffer for the data to be read from ReadDirectoryChanges()
    BytesToRead  - count of bytes to read into buffer
    fWatchSubDir - should we watch for sub directory changes
    dwNotifyFilter - DWORD containing the flags for Notification
    lpo          - pointer to overlapped structure.

  Returns:
    TRUE if ReadDirectoryChanges() is successfully submitted.
    FALSE if there is any failure in submitting IO.
--*/
{
    BOOL fRes;
    DWORD cbRead;     // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);

    if ( g_pfnReadDirChangesW == NULL ) {
        ATQ_PRINTF((DBG_CONTEXT,"ReadDirChanges entry point NULL\n"));
        SetLastError(ERROR_NOT_SUPPORTED);
        return(FALSE);
    }

    if ( lpo == NULL ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    I_SetNextTimeout(pContext);
    pContext->BytesSent = 0;

    InterlockedIncrement( &pContext->m_nIO);
    fRes = g_pfnReadDirChangesW( pContext->hAsyncIO,
                          lpBuffer,
                          BytesToRead,
                          fWatchSubDir,
                          dwNotifyFilter,
                          &cbRead,
                          lpo,
                          NULL);
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    return fRes;
} // AtqReadDirChanges()



BOOL
AtqPostCompletionStatus(
        IN PATQ_CONTEXT patqContext,
        IN DWORD        BytesTransferred
        )
/*++

Routine Description:

    Posts a completion status on the completion port queue

    An IO pending error code is treated as a success error code

Arguments:

    patqContext - pointer to ATQ context
    Everything else as in the Win32 API

    NOTES:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/

{
    BOOL fRes;
    PATQ_CONT  pAtqContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pAtqContext->m_pBandwidthInfo;

    ATQ_ASSERT( (pAtqContext)->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    if ( !pAtqContext->IsBlocked()) {

        InterlockedIncrement( &pAtqContext->m_nIO);

        fRes = ( g_pfnPostCompletionStatus( g_hIoCompPort,
                                          BytesTransferred,
                                          (DWORD) patqContext,
                                          &pAtqContext->Overlapped ) ||
                (GetLastError() == ERROR_IO_PENDING));
        if (!fRes) { InterlockedDecrement( &pAtqContext->m_nIO); };
    } else {

        //
        // Forcibly remove the context from blocking list.
        //

        fRes = pBandwidthInfo->RemoveFromBlockedList(pAtqContext);

        // There is a possibility of race conditions!
        //  If we cant remove an item from blocking list before
        //         its IO operation is scheduled.
        // there wont be any call back generated for this case!
    }

    return fRes;

} // AtqPostCompletionStatus



DWORD
I_AtqGetGlobalConfiguration(VOID)
/*++
Description:
   This function sets several global config params for the ATQ package.
   It also reads the global configuration from registry for ATQ.
   The values if present will override the defaults

Returns:
   Win32 Errorcode - NO_ERROR on success and anything else for error
--*/
{
    DWORD       dwError = NO_ERROR;
    DWORD       dwDefaultThreadTimeout = ATQ_REG_DEF_THREAD_TIMEOUT;

    //
    // If this is a NTW, do the right thing
    //

    if ( !TsIsNtServer() ) {
        g_cCPU = 1;
        g_cMaxThreadLimit = ATQ_REG_MIN_POOL_THREAD_LIMIT;

        //
        // chicago does not have transmitfile/acceptex support
        //

        if ( TsIsWindows95() ) {

            g_fUseAcceptEx = FALSE;
            g_fUseFakeCompletionPort = TRUE;
            g_dwNumContextLists = ATQ_NUM_CONTEXT_LIST_W95;
            dwDefaultThreadTimeout = ATQ_REG_DEF_THREAD_TIMEOUT_PWS;
            g_cMaxThreadLimit = ATQ_MAX_THREAD_LIMIT_W95;
            g_cMaxThreads = ATQ_MAX_THREAD_LIMIT_W95;
        }

    } else {

        SYSTEM_INFO si;
        MEMORYSTATUS ms;

        //
        // get the count of CPUs for Thread Tuning.
        //

        GetSystemInfo( &si );
        g_cCPU = si.dwNumberOfProcessors;

        //
        // get the memory size
        //

        ms.dwLength = sizeof(MEMORYSTATUS);
        GlobalMemoryStatus( &ms );

        //
        // attempt to use driver
        //

        g_fUseDriver = TRUE;

        //
        // Alloc two threads per MB of memory.
        //

        g_cMaxThreadLimit = (ms.dwTotalPhys >> 19) + 2;

        if ( g_cMaxThreadLimit < ATQ_REG_MIN_POOL_THREAD_LIMIT ) {
            g_cMaxThreadLimit = ATQ_REG_MIN_POOL_THREAD_LIMIT;
        } else if ( g_cMaxThreadLimit > ATQ_REG_MAX_POOL_THREAD_LIMIT ) {
            g_cMaxThreadLimit = ATQ_REG_MAX_POOL_THREAD_LIMIT;
        }
    }

    //
    // Get entry points for NT
    //

    if ( !TsIsWindows95() ) {

        if ( !I_AtqInitializeNtEntryPoints( ) ) {
            dwError = ERROR_MOD_NOT_FOUND;
            return ( dwError);
        }

        g_pfnCreateCompletionPort = CreateIoCompletionPort;
        g_pfnGetQueuedCompletionStatus = GetQueuedCompletionStatus;
        g_pfnCloseCompletionPort = CloseHandle;
        g_pfnPostCompletionStatus = PostQueuedCompletionStatus;

    } else {

        //
        // win95 entry points
        //

        g_pfnCreateCompletionPort = SIOCreateCompletionPort;
        g_pfnGetQueuedCompletionStatus = SIOGetQueuedCompletionStatus;
        g_pfnCloseCompletionPort = SIODestroyCompletionPort;
        g_pfnPostCompletionStatus = SIOPostCompletionStatus;
    }

    if ( !TsIsWindows95() ) {

        HKEY        hkey = NULL;
        DWORD       dwVal;

        dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                g_PSZ_ATQ_CONFIG_PARAMS_REG_KEY,
                                0,
                                KEY_READ,
                                &hkey);

        if ( dwError == NO_ERROR ) {

            //
            // Read the Concurrency factor per processor
            //

            dwVal = I_AtqReadRegDword( hkey,
                                       ATQ_REG_PER_PROCESSOR_CONCURRENCY,
                                       ATQ_REG_DEF_PER_PROCESSOR_CONCURRENCY);

            AtqSetInfo( AtqMaxConcurrency, dwVal);


            //
            // Read the count of threads to be allowed per processor
            //

            dwVal = I_AtqReadRegDword( hkey,
                                       ATQ_REG_PER_PROCESSOR_ATQ_THREADS,
                                       ATQ_REG_DEF_PER_PROCESSOR_ATQ_THREADS
                                       );

            if ( dwVal != 0 ) {
                AtqSetInfo( AtqMaxPoolThreads, dwVal);
            }


            //
            // Read the Data transfer rate value for our calculations
            //

            dwVal = I_AtqReadRegDword( hkey,
                                       ATQ_REG_MIN_KB_SEC,
                                       ATQ_REG_DEF_MIN_KB_SEC );

            AtqSetInfo( AtqMinKbSec, dwVal);


            //
            // read the max thread limit
            //

            g_cMaxThreadLimit = I_AtqReadRegDword( hkey,
                                                   ATQ_REG_POOL_THREAD_LIMIT,
                                                   g_cMaxThreadLimit);

            //
            // read the listen backlog
            //

            g_cListenBacklog = I_AtqReadRegDword( hkey,
                                                  ATQ_REG_LISTEN_BACKLOG,
                                                  g_cListenBacklog);


            //
            // Read the time (in seconds) of how long the threads
            //   can stay alive when there is no IO operation happening on
            //   that thread.
            //

            dwVal = I_AtqReadRegDword( hkey,
                                       ATQ_REG_THREAD_TIMEOUT,
                                       dwDefaultThreadTimeout
                                       );

            AtqSetInfo( AtqThreadTimeout, dwVal);


            ATQ_REQUIRE( !RegCloseKey( hkey ) );
            hkey = NULL;
        }

        DBG_ASSERT( NULL == hkey);

    } else {

        g_cListenBacklog = 5;
        AtqSetInfo( AtqMaxConcurrency, ATQ_REG_DEF_PER_PROCESSOR_CONCURRENCY);
        AtqSetInfo( AtqUseAcceptEx, ATQ_REG_DEF_USE_ACCEPTEX);
    }

    return ( dwError);
} // I_AtqGetGlobalConfiguration()



DWORD
I_NumAtqEndpointsOpen(VOID)
/*++
  Description:
    This function counts the number of Enpoints that remain open.

  Arguments:
     None

  Returns:
     DWORD containing the number of endpoints that are open.
--*/
{
    DWORD nEPOpen = 0;
    AcquireLock( &AtqEndpointLock);

    PLIST_ENTRY plEP;
    for( plEP  = AtqEndpointList.Flink;
         plEP != &AtqEndpointList;
         plEP  = plEP->Flink ) {

        nEPOpen++;
    } // for

    ReleaseLock( &AtqEndpointLock);
    return ( nEPOpen);
} // I_NumAtqEndpointsOpen()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\timeout.cxx ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
        timeout.cxx

   Abstract:
        This module contains code for timeout processing of ATQ contexts

   Author:

       Murali R. Krishnan    ( MuraliK )     16-July-1997 

   Environment:
       Win32 - User Mode
       
   Project:
       Internet Server - Asynchronous Thread Queue Module

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "isatq.hxx"


/************************************************************
 * Globals
 ************************************************************/

DWORD   g_dwTimeoutCookie = 0; // Scheduler Cookie for timeout processing

DWORD   g_AtqCurrentTick = 1;

DWORD g_dwTimeout = ATQ_TIMEOUT_INTERVAL;  // active timeout value

/************************************************************
 *    Functions 
 ************************************************************/



BOOL
I_TimeOutContext(
    PATQ_CONT pAtqContext
    )
/*++

Routine Description:
    
    This function does the actual timeout for a particular context.
    Note: The Context list lock is held while processing this function

Arguments:

    Context - Pointer to the context to be timed out

Return value:

    TRUE, if the completion routine was called
    FALSE, otherwise

--*/
{

    DWORD timeout;

    //
    //  Call client after re-checking that this item
    //  really has timed out

    //
    // Fake timeout
    //

    if ( pAtqContext->TimeOut == ATQ_INFINITE ) {
        pAtqContext->NextTimeout = ATQ_INFINITE;
        return(FALSE);
    }

    //
    // Was our timeout long enough?
    //

    // NYI: Optimize: CanonTimeout should be called only once per IO submitted
    timeout = CanonTimeout( pAtqContext->BytesSent/g_cbMinKbSec);
    if ( timeout > pAtqContext->TimeOut ) {

        //
        // Reset the Timeout value based on the bytes to be sent
        // as well as update the time when this pAtqContext be timedout
        //

        pAtqContext->TimeOut = timeout;
        pAtqContext->NextTimeout = AtqGetCurrentTick( ) + timeout;
        return(FALSE);
    }

    //
    // If this is on blocked list, remove it.
    //

    if ( pAtqContext->IsBlocked()) {
        PBANDWIDTH_INFO pBandwidthInfo = pAtqContext->m_pBandwidthInfo;
        ATQ_ASSERT( pBandwidthInfo != NULL );
        ATQ_REQUIRE( pBandwidthInfo->RemoveFromBlockedList(pAtqContext));
    }

    //
    //  If we've already indicated this connection to the client,
    //  then we abort them by calling their IO completion routine
    //  and letting them cleanup.  Otherwise we close the socket
    //  which will generally cause an IO aborted completion that
    //  we will cleanup.  Note there is a window where we may
    //  close the socket out from under a client in their
    //  connection completion routine but that should be ok.
    //

    if ( pAtqContext->pfnCompletion &&
         pAtqContext->IsFlag( ACF_CONN_INDICATED)) {

        //
        //  TransmitFile socket state will be unconnected because
        //  we're expecting it to complete successfully.  Reset the
        //  state so the socket gets cleaned up properly
        //

        if ( pAtqContext->IsState( ACS_SOCK_UNCONNECTED) ) {
            pAtqContext->MoveState( ACS_SOCK_CONNECTED);
        }

        AcIncrement( CacAtqContextsTimedOut);

        pAtqContext->NextTimeout = ATQ_INFINITE;

        pAtqContext->IOCompletion( 0, ERROR_SEM_TIMEOUT, NULL);

        //
        //  We can't touch any items on the list after notifying
        //  the client as the client may have re-entered
        //  and freed some items from the list
        //

        return(TRUE);

    } else {

        HANDLE hIO;

        hIO = (HANDLE ) InterlockedExchangePointer(
                                    (PVOID *)&pAtqContext->hAsyncIO,
                                    NULL
                                    );

        IF_DEBUG( TIMEOUT) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "Timeout: closesocket(%d) Context=%08x\n",
                         hIO, pAtqContext));
        }
        closesocket( HANDLE_TO_SOCKET(hIO) );
    }

    return(FALSE); // we can touch the items on current list.

} // I_TimeOutContext




VOID
AtqProcessTimeoutOfRequests(
    PATQ_CONTEXT_LISTHEAD ContextList
    )
/*++

Routine Description:

    Walks the list of Atq clients looking for any item that has timed out and
    notifies the client if it has.

    TimeOutScanID is used as a serial number to prevent evaluating the same
    context twice.  We start from the beginning of the list everytime we
    notify a client an Atq context has timed out.  We do this because the
    client timeout processing may remove any number of Items from the
    list (including the next couple of items in the list).

    This routine also checks to make sure outstanding AcceptEx sockets
    haven't been exhausted (if less then 25% available, adds some more).

--*/
{
    DWORD                  newLatest = ATQ_INFINITE;
    BOOL                   fRescan;

    //
    // See if the latest one is timed-out
    //

    if ( ContextList->LatestTimeout > AtqGetCurrentTick( ) ) {

        return;
    }

    // set the latest timeout in the context list,
    // to avoid races with IO being started.
    ContextList->LatestTimeout = ATQ_INFINITE;

    //
    //  Scan the timeout list looking for items that have timed out
    //  and adjust the timeout values
    //

    do {

        LIST_ENTRY *           pentry;
        LIST_ENTRY *           pentryNext;
        DWORD                  scanId = AtqGetCurrentTick( );

        ContextList->Lock( );

        fRescan = FALSE;

        for ( pentry  = ContextList->ActiveListHead.Flink;
              pentry != &ContextList->ActiveListHead;
              pentry  = pentryNext ) {

            PATQ_CONT              pContext;

            pentryNext = pentry->Flink;

            pContext = CONTAINING_RECORD(
                                pentry,
                                ATQ_CONTEXT,
                                m_leTimeout
                                );

            if ( pContext->Signature != ATQ_CONTEXT_SIGNATURE ) {
                ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                break;
            }

            //
            //  Ignore items we've already processed
            //

            if ( pContext->TimeOutScanID == scanId ) {
                continue;
            }

            pContext->TimeOutScanID = scanId;

            //
            // If there is an IO which has popped up now,
            //  we have to do nothing. This code was added to protect catapult!
            //
            pContext->SetFlag( ACF_IN_TIMEOUT);

            if ( !pContext->lSyncTimeout) {

                // no body is using this context. Check and synchronize
                // the timeout state.

                //
                //  The client specifies the IO doesn't timeout if
                //  INFINITE is in the TimeOut field of the ATQ context
                //  If we've timed out, then notify the client.
                //

                DWORD nextTimeout = pContext->NextTimeout;
                if ( nextTimeout > AtqGetCurrentTick() ) {


                    // pick up the latest "low" value for
                    // firing next timeout thread
                    if ( nextTimeout < newLatest ) {
                        newLatest = nextTimeout;
                    }
                } else if ( I_TimeOutContext(pContext) ) {

                    // we are done checking and processing timeout.
                    // reset the In Timeout flag
                    pContext->ResetFlag( ACF_IN_TIMEOUT);
                    fRescan = TRUE;
                    break;
                } else {

                    //
                    // It is possible that the timeout got reset
                    // Check for the latest "low" value
                    //
                    nextTimeout = pContext->NextTimeout;
                    if ( nextTimeout < newLatest ) {
                        newLatest = nextTimeout;
                    }
                }

            } else {
                AcIncrement( CacAtqProcWhenTimeout);
            }

            // we are done checkin and processing timeouts.
            // reset the In Timeout flag
            pContext->ResetFlag( ACF_IN_TIMEOUT);

        } // scan list

        // let other system threads also run happily for a while
        ContextList->Unlock( );

    } while (fRescan);

    if ( newLatest != ATQ_INFINITE) {
        // We picked up the latest timeout. store it.
        ContextList->LatestTimeout = newLatest;
    }

    return;

} // AtqProcessTimeoutOfRequests




//
// ACCEPT_EX_TIMEOUT_STATS collects statistics for the 
//   timeout processing in the Pending AcceptEx List//  
//
struct ACCEPT_EX_TIMEOUT_STATS {

    DWORD  m_nScanned;
    DWORD  m_nTimedOut;
    DWORD  m_nSkipped;
    DWORD  m_nConnected;
    DWORD  m_nNotConnected;
};


BOOL
I_TimeOutPendingAcceptExContext(
    PATQ_CONT pAtqContext
    )
/*++

Routine Description:
    
    This function does the actual timeout for a pending AcceptEx context.
    Note: The Context list lock is held while processing this function

Arguments:

    pAtqContext - Pointer to the context to be timed out

Return value:

    TRUE, if a tmieout operation was conducted.
    FALSE, otherwise

--*/
{
    DBG_ASSERT( pAtqContext != NULL);

    //
    // in the shutdown case it is possible that someone closed this socket already
    // so don't worry about it.
    //
    if ( pAtqContext->hAsyncIO == NULL ) {
        return TRUE;
    }
    
    //
    // Validate our assumptions about this Pending AcceptEx Context
    // there is an endpoint => AcceptEx context
    DBG_ASSERT( pAtqContext->pEndpoint != NULL);
    DBG_ASSERT( pAtqContext->IsState( ACS_SOCK_LISTENING));
    DBG_ASSERT( !pAtqContext->IsFlag( ACF_CONN_INDICATED));
    DBG_ASSERT( pAtqContext->TimeOut != ATQ_INFINITE);
    

    //
    // We will obtain the socket handle stored inside the AcceptEx Context
    //    and free up the context.
    // Warning:
    //   The AcceptEx socket did not have a connection when this function
    //   was called. However now between the time when the state was checked 
    //   and the time this timeout operation completes, it is possible that
    //   a new connection is bound to this AcceptEx context => we can get IO completion.
    //   I need to handle this case
    //

    HANDLE hIO;

    hIO = (HANDLE ) InterlockedExchangePointer(
                       (PVOID *)&pAtqContext->hAsyncIO,
                       NULL
                       );

    IF_DEBUG( TIMEOUT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "TimeoutPendingAcceptExContext(%08x): closesocket(%d)\n",
                      pAtqContext, hIO));
    }

    closesocket( HANDLE_TO_SOCKET(hIO) );

    return ( TRUE);
} // I_TimeOutPendingAcceptExContext()


BOOL
I_IsTimeoutForAcceptExContext( 
    IN OUT PATQ_CONT                  pAtqContext, 
    IN OUT ACCEPT_EX_TIMEOUT_STATS  * pAetStats,
    OUT BOOL *                        pfIsConnected
    )
/*++

Routine Description:
    
    This function checks to see if timeout operation has to be performed
    for a given AtqContext. It bases the decision on the a variety of 
    details maintained in Atq Context and the Endpoint.
    Note: The Context list lock is held while processing this function

Arguments:

    pAtqContext - Pointer to the context to be timed out
    pAetStats   - pointer to AcceptEx Timeout Statistics structure
    pfIsConnected - Set to TRUE if socket is connected to, but we're still
                    waiting for data.  Such contexts are prime candidated
                    to be forcibly timed out by backlog monitor

Return value:

    TRUE, if a tmieout operation has to be conducted.
    FALSE, when no timeout is required.

--*/
{
    DBG_ASSERT( pAtqContext);
    DBG_ASSERT( pAetStats);
    
    PATQ_ENDPOINT  pEndpoint;
    pEndpoint = pAtqContext->pEndpoint;

    *pfIsConnected = FALSE;
    
    if ( pEndpoint != NULL) {
        
        //
        // We will use getsockopt() to query the connection status
        //  for the socket inside the Atq context.
        // If Socket is not connected => leave it in the pool
        // If Socket is connected and waiting for receive operation =>
        //        do timeout processing
        //
        // The goal is to maintain a pool of sockets in listening state
        //  so that any new connection will be picked up quickly.
        //
        // getsockopt() is a very costly function.
        // We check to see if we have enough sockets available
        //  for an endpoint. If they are, then we bypass calling getsockopt
        // "enough" is defined as # of available sockets is at least
        //   25% of the total # of accept ex sockets outstanding.
        // Optimize calling getsockopt() based on
        //   current count in pEndpoint->nAvailDuringTimeOut
        //
        
        if ( pEndpoint->nAvailDuringTimeOut >
             ( pEndpoint->nAcceptExOutstanding >> 2)
             ) {
            
            // Already enough Contexts are available.
            //  Do nothing
            pAetStats->m_nSkipped++;
            
            return (FALSE); // Do not timeout
        }

        DWORD dwConnect;
        int   cbOptLen = sizeof( dwConnect );
        
        //
        // Query the socket layer if the current socket has a valid connection
        // An AcceptEx socket can be connected and waiting for new request to 
        //   be read. If we are in such state we should not blow away context.
        //
        if ( getsockopt(HANDLE_TO_SOCKET(pAtqContext->hAsyncIO),
                        SOL_SOCKET,
                        SO_CONNECT_TIME,
                        (char *) &dwConnect,
                        &cbOptLen ) != SOCKET_ERROR
             ) {
            
            //
            //  A return value of 0xFFFFFFFF indicates that the given
            //   AcceptEx socket is not connected yet.
            //  Otherwise the socket is connected and is probably wating
            //   for request to be read or maybe a completion is already
            //   on its way.
            //
            
            if ( dwConnect == (DWORD) 0xFFFFFFFF ) {

                //
                //  Ignore the "Listen" socket context
                //
                
                pAetStats->m_nNotConnected++;
                
                DBG_ASSERT( NULL != pEndpoint);
                pEndpoint->nAvailDuringTimeOut++;

                // Update timeout values to give a breather interval
                pAtqContext->NextTimeout =
                    AtqGetCurrentTick() + pAtqContext->TimeOut;
                
                return ( FALSE);  // Do not timeout
            }
            else if ( !pAtqContext->IsFlag(ACF_WINSOCK_CONNECTED) ) {

                *pfIsConnected = TRUE;
                
                //
                // Mark that this context has connection indicated.
                // If this context waits around in connected state for
                //  long-time we need to blow the context away.
                //
                
                pAetStats->m_nConnected++;
                
                // Update timeout values to give a breather interval
                pAtqContext->NextTimeout =
                    AtqGetCurrentTick() + pAtqContext->TimeOut;
                
                pAtqContext->SetFlag(ACF_WINSOCK_CONNECTED);
                
                return (FALSE); // do not timeout now
            }
        }
    } // if Endpoint exists

    return (TRUE); // yes timeout this context
} // I_IsTimeoutForAcceptExContext()


VOID
I_AtqProcessPendingListens(
    IN PATQ_CONTEXT_LISTHEAD pContextList,
    IN PATQ_ENDPOINT         pEndpoint,
    OUT PDWORD               pcForced
    )
/*++

Routine Description:

    Walks the list of Pending accept ex and makes sure none has timed out.
    Also checks to see if we need to allocate more AcceptEx sockets.

  Arguments:
    pContextList - pointer to ATQ_CONTEXT_LISTHEAD object
    pEndpoint - pointer to ATQ_ENDPOINT object.  If set, then only those
                ATQ_CONTEXTs whose endpoint matches will be timed out.
                If pEndpoint=NULL, then all ATQ_CONTEXTs will be timed out.
    pcForced - If pEndpoint!=NULL, then this is set to # of forced sockets

  Returns:
    None

--*/
{
    BOOL                    fRescan;
    BOOL                    fForceTimeout = ( pEndpoint != NULL );
    BOOL                    fIsConnected = FALSE;

    if ( fForceTimeout )
    {
        *pcForced = 0;
    }

    ACCEPT_EX_TIMEOUT_STATS AetStats;

    //
    // Initialize Statistics block
    //
    AetStats.m_nScanned         = 0;
    AetStats.m_nTimedOut        = 0;
    AetStats.m_nSkipped         = 0;
    AetStats.m_nConnected       = 0;
    AetStats.m_nNotConnected    = 0;
   
    //
    //  Look through the listening sockets to make sure the AcceptEx sockets
    //  haven't been exhausted
    //

    do {

        LIST_ENTRY *           pentry;
        LIST_ENTRY *           pentryNext;
        DWORD                  scanId = AtqGetCurrentTick( );

        fRescan = FALSE;

        pContextList->Lock();

        for ( pentry  = pContextList->PendingAcceptExListHead.Flink;
              pentry != &pContextList->PendingAcceptExListHead;
              pentry  = pentryNext ) {

            PATQ_CONT      pContext;

            pentryNext = pentry->Flink;
            pContext = CONTAINING_RECORD(
                                pentry,
                                ATQ_CONTEXT,
                                m_leTimeout
                                );

            if ( pContext->Signature != ATQ_CONTEXT_SIGNATURE ) {
                DBG_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                break;
            }

            //
            //  Use PATQ_ENDPOINT filter if necessary
            //
            
            if ( pEndpoint && ( pEndpoint != pContext->pEndpoint ) )
            {
                continue;
            }

            //
            //  Ignore items we've already processed
            //

            if ( pContext->TimeOutScanID == scanId ) {
                continue;
            }

            AetStats.m_nScanned++;
            pContext->TimeOutScanID = scanId;

            //
            // If the context has Timeout value smaller than the one in our global tick
            //  then examine if this context can be timedout
            //

            DBG_CODE( if ( pContext->IsAcceptExRootContext()) 
                        { 
                            DBG_ASSERT( pContext->TimeOut == ATQ_INFINITE); 
                            DBG_ASSERT( pContext->NextTimeout == ATQ_INFINITE); 
                        }
                        );

            if ( pContext->NextTimeout <= AtqGetCurrentTick() ||
                 fForceTimeout ) {
                
                //
                // Protect against the race with the normal IO completion
                //
                pContext->SetFlag( ACF_IN_TIMEOUT);

                if ( !pContext->lSyncTimeout ) {
                    
                    if ( !I_IsTimeoutForAcceptExContext( pContext, 
                                                         &AetStats,
                                                         &fIsConnected )) {
                        
                        if ( !fForceTimeout || !fIsConnected )
                        { 
                            pContext->ResetFlag( ACF_IN_TIMEOUT);
                            continue;
                        }
                    }
                    
                    if ( I_TimeOutPendingAcceptExContext(pContext)) {
                        AetStats.m_nTimedOut++;
                        pContext->ResetFlag(ACF_IN_TIMEOUT);
                        
                        if ( fForceTimeout )
                        {
                            (*pcForced)++;
                        }
                        fRescan = TRUE;
                        break;
                    }
                } // if (!pContext->lSyncTimeout)

                pContext->ResetFlag( ACF_IN_TIMEOUT);
            } // if the context's timeout value <= CurrentTick
            else {
            
                //
                // Timeout value has not been reached. Skip this context
                //
                
                AetStats.m_nSkipped++;
           }
        } // scan list

        pContextList->Unlock();

    } while (fRescan);

    IF_DEBUG( TIMEOUT) {
       DBGPRINTF(( DBG_CONTEXT,
                   "TimeoutPendingListens( CtxtList[%d], AtqTick=%d)\n"
                   " Contexts Scanned=%d, Skipped=%d, TimedOut=%d,"
                   " Connected=%d, NotConnected=%d\n",
                   pContextList - AtqActiveContextList, AtqGetCurrentTick(), 
                   AetStats.m_nScanned, AetStats.m_nSkipped, 
                   AetStats.m_nTimedOut, AetStats.m_nConnected, 
                   AetStats.m_nNotConnected
                ));
    }    

# ifdef IIS_AUX_COUNTERS 
    g_AuxCounters[CacAtqPendingAcceptExScans] += AetStats.m_nScanned;
# endif // IIS_AUX_COUNTERS
                
    return;

} // I_AtqProcessPendingListens()




VOID
I_AtqCheckEndpoints(
            VOID
            )
/*++
  Description:
    This function checks all the listen info objects and adds appropriate
     number of accept ex sockets as necessary.

  Arguments:
    None

  Returns:
    None
--*/
{
    LIST_ENTRY *  pEntry;
    PATQ_ENDPOINT pEndpoint;

    AcquireLock( &AtqEndpointLock);

    for ( pEntry  = AtqEndpointList.Flink;
          pEntry != &AtqEndpointList;
          pEntry  = pEntry->Flink ) {

        pEndpoint = CONTAINING_RECORD(
                                    pEntry,
                                    ATQ_ENDPOINT,
                                    ListEntry
                                    );

        DBG_ASSERT( pEndpoint->Signature == ATQ_ENDPOINT_SIGNATURE );

        DBG_ASSERT( pEndpoint->nSocketsAvail >= 0);
        
        //
        // Check to make sure outstanding AcceptEx sockets
        // haven't been exhausted (if less then 25% available, adds some more).
        //

        if ( ((DWORD ) pEndpoint->nSocketsAvail) <
             (pEndpoint->nAcceptExOutstanding >> 2) ) {

            IF_DEBUG( TIMEOUT ) {
                DBGPRINTF(( DBG_CONTEXT,
                            "[Timeout] Adding AcceptEx Contexts for EP=%08x; nAvail = %d;\n",
                            pEndpoint, pEndpoint->nSocketsAvail));
            }

            (VOID ) I_AtqPrepareAcceptExSockets(pEndpoint,
                                                pEndpoint->nAcceptExOutstanding
                                                );
        }

        //
        // set to zero, so recount will be done during next timeout loop
        //

        pEndpoint->nAvailDuringTimeOut = 0;
    }

    ReleaseLock( &AtqEndpointLock);

    return;
} // I_AtqCheckEndpoints



VOID
I_AtqTimeOutWorker(VOID)
/*++
  Description:
    This function handles timeout processing using the simple
    clock algorithm, wherein partial set of lists are scanned
    during each timeout processing call.

  Arguments:
    None


  Returns:
    None
--*/
{
    DWORD start;
    PATQ_CONTEXT_LISTHEAD pContextList;

    IF_DEBUG(TIMEOUT) {
        DBGPRINTF((DBG_CONTEXT, "TimeoutWorker: entered\n"));
    }

    start = (AtqGetCurrentTick() & 0x1);

    for ( pContextList = AtqActiveContextList + start;
          pContextList < (AtqActiveContextList + g_dwNumContextLists) ;
          pContextList += 2 ) {

        IF_DEBUG(TIMEOUT) {
            DBGPRINTF((DBG_CONTEXT,
                       "TimeoutWorker: Processing list[%d] = %08x\n",
                       (pContextList - AtqActiveContextList),
                       pContextList));
        }

        AtqProcessTimeoutOfRequests( pContextList );
        I_AtqProcessPendingListens( pContextList, NULL, NULL );
    } // for

    if ( start != 0 ) {
        I_AtqCheckEndpoints( );
    }

    return;

} // I_AtqTimeOutWorker()




VOID
WINAPI
I_AtqTimeoutCompletion(
    IN PVOID Context
    )
/*++

Routine Description:

    Callback routine for the scheduled version of the timeout thread.

    The callback assumes timeouts are rounded to ATQ_TIMEOUT_INTERVAL

    In addition to timing out requests when necessary, the timeout thread
     also performs the job of bandwidth calculation and tuning the bandwidth
     throttle operation (which works on feedback mechanism).
    At every sampling interval the scheduled callback comes in and it updates
     the bandwidth.

Arguments:

    Context - Context returned by the scheduler thread.

Return Value:

    none.

--*/
{
    DWORD Timeout = ATQ_TIMEOUT_INTERVAL;
    BOOL  fDoContextTimeout = TRUE;

    if ( g_fShutdown ) {

        ATQ_PRINTF(( DBG_CONTEXT,
            "Detected a shutdown while entering timeout callback\n"));
        return;
    }

    InterlockedIncrement( (PLONG)&g_AtqCurrentTick );

    //
    //  Perform necessary steps to handle Bandwidth throttling.
    //

    ATQ_ASSERT( BANDWIDTH_INFO::sm_cSamplesForTimeout >= 1);

    IF_DEBUG(TIMEOUT) {
        DBGPRINTF((DBG_CONTEXT,
                 "Timeout: BANDWIDTH_INFO::cSamplesForTimeout=%d\n",
                 BANDWIDTH_INFO::sm_cSamplesForTimeout ));
    }

    if ( BANDWIDTH_INFO::GlobalActive() ) {

        --(BANDWIDTH_INFO::sm_cSamplesForTimeout);

        // Perform a sampling to update measured bandwidth +
        //  apply feedback policy

        BANDWIDTH_INFO::UpdateAllBandwidths();

        Timeout = ATQ_SAMPLE_INTERVAL_IN_SECS;
        if ( BANDWIDTH_INFO::sm_cSamplesForTimeout != 0) {

            // We have not reached timeout yet. So skip context timeouts

            fDoContextTimeout = FALSE;
        } else {

            // We had reached the timeout interval for requests.
            // Examine and release requests.
            ATQ_ASSERT( BANDWIDTH_INFO::sm_cSamplesForTimeout == 0);

            // reset the count of samples before proceeding.
            BANDWIDTH_INFO::sm_cSamplesForTimeout = NUM_SAMPLES_PER_TIMEOUT_INTERVAL;
        }
    } else {
        BANDWIDTH_INFO::sm_cSamplesForTimeout = 1;
    }

    //
    // We are at a Timeout Interval. Examine and timeout requests.
    //

    if ( fDoContextTimeout ) {
        I_AtqTimeOutWorker();
    }

    if ( Timeout != g_dwTimeout) {

        // the scheduled interval is different from this current interval
        // Inidicate the changed timeout value to the scheduler

        ScheduleAdjustTime( g_dwTimeoutCookie, TimeToWait(Timeout));
        g_dwTimeout = Timeout;
    }

    return;
} // I_AtqTimeoutCompletion




BOOL
I_AtqStartTimeoutProcessing(
    IN PVOID Context
    )
/*++

Routine Description:

    Starts the timeout processing. It always uses the scheduler to schedule
    a timeout operation.

    Note: The scheduler should be initialized before getting to this function.

Arguments:

    Context - Context passed to the thread creation or scheduler thread.

Return Value:

    TRUE, if ok
    FALSE, otherwise

--*/
{
    ATQ_ASSERT( ATQ_SAMPLE_INTERVAL_IN_SECS < ATQ_TIMEOUT_INTERVAL );

    if ( BANDWIDTH_INFO::GlobalEnabled() ) {
        g_dwTimeout = ATQ_SAMPLE_INTERVAL_IN_SECS;
        BANDWIDTH_INFO::sm_cSamplesForTimeout = 
            NUM_SAMPLES_PER_TIMEOUT_INTERVAL;
    } else {
        g_dwTimeout = ATQ_TIMEOUT_INTERVAL;
        BANDWIDTH_INFO::sm_cSamplesForTimeout = 1;
    }

    g_dwTimeoutCookie =
        ScheduleWorkItem(
                         I_AtqTimeoutCompletion,
                         Context,
                         TimeToWait(g_dwTimeout)
                         , TRUE  // ask for periodic timeout
                         );

    if ( g_dwTimeoutCookie == 0 ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Error %d scheduling timeout\n",GetLastError()));
        return(FALSE);
    }

    return(TRUE);

} // I_AtqStartTimeoutProcessing()



BOOL
I_AtqStopTimeoutProcessing(
    VOID
    )
/*++

Routine Description:

    Stops the timeout processing. It terminates the scheduled workitem and 
    cleans up any state.

    Note: The scheduler should be terminated only after this call

Arguments:

    Context - Context passed to the thread creation or scheduler thread.

Return Value:

    TRUE, if ok
    FALSE, otherwise

--*/
{
    DBGPRINTF(( DBG_CONTEXT, "I_AtqStopTimeoutProcessing\n"));

    if ( 0 != g_dwTimeoutCookie) {
        DBG_REQUIRE( RemoveWorkItem( g_dwTimeoutCookie ));
        g_dwTimeoutCookie = 0;
    }

    return ( TRUE);

} // I_AtqStopTimeoutProcessing()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\oplock\atqsupp.cxx ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

       atqsupp.cxx

   Abstract:

        Contains internal support routines for the ATQ package
        From atqnew.c

   Author:
        Murali R. Krishnan     (MuraliK)     02-Apr-1996

   Project:
        Internet Server Common DLL
--*/

#include "isatq.hxx"


DWORD AtqPoolThread( LPDWORD param );

extern PBANDWIDTH_INFO g_pBandwidthInfo;


/************************************************************
 * Functions for ATQ_CONTEXT
 ************************************************************/


PATQ_CONT
I_AtqAllocContextFromCache( VOID);

VOID
I_AtqFreeContextToCache(
            IN PATQ_CONT pAtqContext,
            IN BOOL UnlinkContext
            );



PATQ_CONT
I_AtqAllocContextFromCache( VOID)
/*++
  This function attempts to allocate an ATQ context from the allocation cache.
  It then initializes the state information in the ATQ context object and
    returns the context on success.

  Arguments:
    None

  Returns:
    On success a valid pointer to ATQ_CONT. Otherwise NULL.

--*/
{
    PATQ_CONT  pAtqContext;

    DBG_ASSERT( NULL != g_pachAtqContexts);

    pAtqContext = (ATQ_CONTEXT * ) g_pachAtqContexts->Alloc();

    if ( NULL != pAtqContext ) {


        pAtqContext->ContextList =
            &AtqActiveContextList[(++AtqGlobalContextCount %
                                   g_dwNumContextLists)];

        pAtqContext->Signature = ATQ_CONTEXT_SIGNATURE;
    }

    return (pAtqContext);
} // I_AtqAllocContextFromCache()




VOID
I_AtqFreeContextToCache(
        IN PATQ_CONT pAtqContext
        )
/*++
  This function releases the given context to the allocation cache.

  Arguments:
    pAtqContext  pointer to the ATQ_CONTEXT that is being freed.

  Returns:
    None

  Issues:
    This function also performs some other cleanup specific to AtqContexts.
--*/
{

#if 0
      ATQ_PRINTF(( DBG_CONTEXT,
                 "[I_AtqFreeCtxtToCache] Freed up %08x\n",
                 pAtqContext
                 ));
#endif

    DBG_ASSERT( pAtqContext->Signature == ATQ_FREE_CONTEXT_SIGNATURE);
    DBG_ASSERT( pAtqContext->lSyncTimeout ==0);
    DBG_ASSERT( pAtqContext->m_nIO ==0);
    DBG_ASSERT( pAtqContext->m_acFlags == 0);
    DBG_ASSERT( pAtqContext->m_acState == 0);
    DBG_ASSERT( pAtqContext->m_leTimeout.Flink == NULL);
    DBG_ASSERT( pAtqContext->m_leTimeout.Blink == NULL);
    DBG_ASSERT( pAtqContext->pvBuff == NULL);
    DBG_ASSERT( pAtqContext->pEndpoint == NULL);
    DBG_ASSERT( pAtqContext->hAsyncIO == NULL);

    DBG_REQUIRE( g_pachAtqContexts->Free( pAtqContext));

    return;

} // I_AtqFreeContextToCache



void
ATQ_CONTEXT::Print( void) const
{
    DBGPRINTF(( DBG_CONTEXT,
                " ATQ_CONTEXT (%08x)\n"
                "\thAsyncIO            = %08lx   Signature        = %08lx\n"
                "\tOverlapped.Internal = %08lx   Overlapped.Offset= %08lx\n"
                "\tm_leTimeout.Flink   = %08lx   m_leTimeout.Blink= %08lx\n"
                "\tClientContext       = %08lx   ContextList      = %08lx\n"
                "\tpfnCompletion       = %08lx ()\n"
                "\tpEndPoint           = %08lx   fAcceptExContext = %s\n"
                "\tlSyncTimeout        = %8d     fInTimeout       = %s\n"

                "\tTimeOut             = %08lx   NextTimeout      = %08lx\n"
                "\tBytesSent           = %d (0x%08lx)\n"

                "\tpvBuff              = %08lx   JraAsyncIo       = %08lx\n"
                "\tfConnectionIndicated= %s      fBlocked         = %8lx\n"

                "\tState               = %8lx    Flags            = %8lx\n",
                this,
                hAsyncIO,
                Signature,
                Overlapped.Internal,
                Overlapped.Offset,
                m_leTimeout.Flink,
                m_leTimeout.Blink,
                ClientContext,
                ContextList,
                pfnCompletion,
                pEndpoint,
                (IsAcceptExRootContext() ? "TRUE" : "FALSE"),
                lSyncTimeout,
                (IsFlag( ACF_IN_TIMEOUT) ? "TRUE" : "FALSE"),
                TimeOut,
                NextTimeout,
                BytesSent,
                BytesSent,
                pvBuff,
                hJraAsyncIO,
                (IsFlag( ACF_CONN_INDICATED) ? "TRUE" : "FALSE"),
                IsBlocked(),
                m_acState, m_acFlags
                ));

    // Print the buffer if necessary.

    return;
} // ATQ_CONTEXT::Print()




VOID
ATQ_CONTEXT::HardCloseSocket( VOID)
/*++
  Description:
     This socket closes the socket by forcibly calling closesocket() on
     the socket. This function is used during the endpoint shutdown
     stage for an atq context

  Arguments:
     None

  Returns:
     None

--*/
{
    HANDLE haio = (HANDLE )
        InterlockedExchange( (LPLONG ) &hAsyncIO, NULL);

    DBG_ASSERT( IsState( ACS_SOCK_LISTENING) ||
                IsState( ACS_SOCK_CONNECTED) ||
                IsState( ACS_SOCK_CLOSED) ||
                IsState( ACS_SOCK_UNCONNECTED)
                );

    MoveState( ACS_SOCK_CLOSED);


    //
    //  Let us do a hard close on the socket (handle).
    //  This should generate an IO completion which will free this
    //     ATQ context
    //

    if ( (haio != NULL) &&
         (closesocket((SOCKET) haio) == SOCKET_ERROR)
         ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Warning - "
                     " Context=%08x closesocket failed,"
                     " error %d, socket = %x\n",
                     this,
                     GetLastError(),
                     haio ));
        Print();
    }

    return;
} // ATQ_CONTEXT::HardCloseSocket()



VOID
ATQ_CONTEXT::InitWithDefaults(
    IN ATQ_COMPLETION pfnCompletion,
    IN DWORD TimeOut,
    IN HANDLE hAsyncIO
    )
{
    DBG_ASSERT( this->Signature == ATQ_CONTEXT_SIGNATURE);

    this->InitTimeoutListEntry();

    this->Signature    = ATQ_CONTEXT_SIGNATURE;

     // start life at 1. This ref count will be freed up by AtqFreeContext()
    this->m_nIO = 1;

    this->pfnCompletion   = pfnCompletion;

    this->TimeOut         = TimeOut;
    this->TimeOutScanID   = 0;
    this->lSyncTimeout    = 0;

    this->hAsyncIO        = hAsyncIO;
    this->hJraAsyncIO     = (DWORD)hAsyncIO | 0x80000000;

    this->m_acState       = 0;
    this->m_acFlags       = 0;

    // Initialize pbandwidthinfo to point to global object

    this->m_pBandwidthInfo  = g_pBandwidthInfo;

    ZeroMemory(
               &this->Overlapped,
               sizeof( this->Overlapped )
               );

    DBG_ASSERT( this->lSyncTimeout == 0);

    //
    // Following added for bandwidth throttling purposes
    //

    DBG_ASSERT( !this->IsBlocked());
    this->arInfo.atqOp    = AtqIoNone;
    this->arInfo.lpOverlapped = NULL;
    // bandwidth throttling initialization ends here.

} // ATQ_CONTEXT::InitWithDefaults()




VOID
ATQ_CONTEXT::InitNonAcceptExState(
    IN PVOID pClientContext
    )
{
    //
    //  Note that if we're not using AcceptEx, then we consider the client
    //  to have been notified externally (thus ACF_CONN_INDICATED is set).
    //  Also we set the next timeout to be infinite, which may be reset
    //   when the next IO is submitted.
    //

    this->NextTimeout          = ATQ_INFINITE;
    this->ClientContext        = pClientContext;
    this->pEndpoint            = NULL;
    this->SetFlag( ACF_CONN_INDICATED);
    this->SetState( ACS_SOCK_CONNECTED);
    this->ResetFlag( ACF_ACCEPTEX_ROOT_CONTEXT);

    //
    // Insert this into the active list - since this is a non-acceptex socket
    //

    DBG_ASSERT( this->ContextList != NULL);
    this->ContextList->InsertIntoActiveList( &this->m_leTimeout );

    return;

} // ATQ_CONTEXT::InitNonAcceptExState()



VOID
ATQ_CONTEXT::InitAcceptExState(
            IN DWORD NextTimeOut
            )
{
    this->NextTimeout          = NextTimeOut;
    this->ClientContext        = NULL;
    this->lSyncTimeout         = 0;

    this->ResetFlag( ACF_CONN_INDICATED);
    this->SetState( ACS_SOCK_LISTENING);

    //
    //  Add it to the pending accept ex list
    //
    DBG_ASSERT( this->ContextList != NULL);

    this->ContextList->InsertIntoPendingList( &this->m_leTimeout);

    return;
} // ATQ_CONTEXT::InitAcceptExState()



BOOL
ATQ_CONTEXT::PrepareAcceptExContext(
    PATQ_ENDPOINT          pEndpoint
    )
/*++

Routine Description:

    Initializes the state for completely initializing the state and
    hence prepares the context for AcceptEx

    It expects the caller to send a AtqContext with certain characteristics
      1) this is not NULL
      2) this->pvBuff has valid values

    In the case of failure, caller should call
     pAtqContext->CleanupAndRelese() to free the memory associated with
     this object.

Arguments:

    pEndpoint     - pointer to endpoint object for this context

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

    The caller should free the object on a failure.

--*/
{
    DBG_ASSERT( g_fUseAcceptEx); // only support AcceptEx() cases
    DBG_ASSERT( pEndpoint != NULL);
    DBG_ASSERT( this != NULL);
    DBG_ASSERT( this->pvBuff != NULL);

    //
    //  Make sure that we are adding a AcceptEx() version of AtqContext
    //

    DBG_ASSERT( pEndpoint->ConnectExCompletion != NULL);
    DBG_ASSERT( pEndpoint->UseAcceptEx);

    //
    //  Fill out the context.  We set NextTimeout to INFINITE
    //  so the timeout thread will ignore this entry until an IO
    //  request is made unless this is an AcceptEx socket, that means
    //  we're about to submit the IO.
    //

    this->
        InitWithDefaults(
                         pEndpoint->IoCompletion,
                         pEndpoint->AcceptExTimeout, // canonical Timeout
                         this->hAsyncIO
                         );


    //
    // TBD: What is the circumstance in which this->pEndpoint!= NULL?
    //

    if ( this->pEndpoint == NULL ) {

        pEndpoint->Reference();
        this->pEndpoint  = pEndpoint;
    }

    this->ResetFlag( ACF_ACCEPTEX_ROOT_CONTEXT );

    this->InitAcceptExState( AtqGetCurrentTick() + TimeOut);

    DBG_ASSERT( this->pvBuff != NULL);

    return (TRUE);

} // ATQ_CONTEXT::PrepareAcceptExContext()




VOID
ATQ_CONTEXT::CleanupAndRelease( VOID)
/*++
  Routine Description:
     This function does the cleanup of the ATQ context. It does not
     attempt to do any reuse of the atq context. After cleanup
     the context is freed to the ATQ pool. Supplied context
     is not valid after calling this function.

  Arguments:
     None

  Returns:
     None
--*/
{
    DBG_ASSERT( this->m_nIO == 0);

    //
    //  Cleanup and free the ATQ Context entirely
    //

    if ( this->hAsyncIO != NULL ) {

        // It is too dangerous to assume that the handle is a socket!
        // But we will do that for fast-pathing IIS operations.

        SOCKET hIO =
            (SOCKET ) InterlockedExchange( (LPLONG) &this->hAsyncIO,
                                           NULL);

        if ( hIO != NULL &&
             (closesocket( hIO ) == SOCKET_ERROR ) ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                         "ATQ_CONTEXT(%08x)::CleanupAndRelease() : Warning"
                         " - Context=%08x, "
                         " closesocket failed, error %d, socket = %x\n",
                         this,
                         GetLastError(),
                         hIO ));
            this->Print();
        }
    }

    DBG_ASSERT( this->hAsyncIO == NULL);

    if ( this->pvBuff != NULL ) {
        LocalFree( this->pvBuff );
        this->pvBuff = NULL;
    }

    //
    // Unlink from the list
    //

    DBG_ASSERT( this->ContextList != NULL);

    // NYI: Can I avoid this comparison?
    //
    // Check if this context is part of a timeout list.
    // If it is then remove it from the list
    // Only during shutdown code path, we will see trouble here.
    //
    if ( this->m_leTimeout.Flink != NULL ) {
        this->ContextList->RemoveFromList( &this->m_leTimeout);
    }

    //
    //  Deref the listen info if this context is associated with one
    //

    if ( this->pEndpoint != NULL ) {
        this->pEndpoint->Dereference();
        this->pEndpoint = NULL;
    }

    this->Signature    = ATQ_FREE_CONTEXT_SIGNATURE;
    this->lSyncTimeout = 0;
    this->m_acState    = 0;
    this->m_acFlags    = 0;

    I_AtqFreeContextToCache( this);

    return;
} // ATQ_CONTEXT::CleanupAndRelease()





inline VOID
DBG_PRINT_ATQ_SPUDCONTEXT( IN PATQ_CONT  pAtqContext,
                           IN PSPUD_REQ_CONTEXT reqContext)
{
    ATQ_PRINTF(( DBG_CONTEXT,
                 "[AtqPoolThread] pAtqContext = %08lx\n"
                 "[AtqPoolThread] IoStatus1.Status = %08lx\n"
                 "[AtqPoolThread] IoStatus1.Information = %08lx\n"
                 "[AtqPoolThread] IoStatus2.Status = %08lx\n"
                 "[AtqPoolThread] IoStatus2.Information = %08lx\n"
                 ,
                 pAtqContext,
                 reqContext->IoStatus1.Status,
                 reqContext->IoStatus1.Information,
                 reqContext->IoStatus2.Status,
                 reqContext->IoStatus2.Information
                 ));
    return;
} // DBG_PRINT_ATQ_SPUDCONTEXT()


VOID
AtqpUpdateBandwidth( IN PATQ_CONT  pAtqContext,
                    IN DWORD      cbWritten)
{
    PBANDWIDTH_INFO pBandwidthInfo = pAtqContext->m_pBandwidthInfo;

    DBG_ASSERT( pBandwidthInfo != NULL );
    DBG_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    // add the bandwidth info to active list if necessary

    pBandwidthInfo->AddToActiveList();

    //this will have problems when we use XmitFile for large files.

    pBandwidthInfo->UpdateBytesXfered( pAtqContext, cbWritten );
} // AtqpUpdateBandwidth()


VOID
AtqpProcessContext( IN PATQ_CONT  pAtqContext,
                    IN DWORD      cbWritten,
                    IN LPOVERLAPPED lpo,
                    IN BOOL       fRet)
{
    BOOL fDriverCall = FALSE;
    PSPUD_REQ_CONTEXT  reqContext;
    DWORD dwError;

    DBG_ASSERT( pAtqContext != NULL);

    //
    // Check to see if this is a completion request from the
    // NTS kernel driver.
    //

    if ( lpo == NULL ) {

        if ( cbWritten == 0xffffffff ) {

            //
            // One of the SPUD's IO completion. Handle it appropriately.
            //

            reqContext = (PSPUD_REQ_CONTEXT)pAtqContext;

            pAtqContext = CONTAINING_RECORD( reqContext, ATQ_CONTEXT,
                                             spudContext );

            IF_DEBUG( SPUD) {
                DBG_PRINT_ATQ_SPUDCONTEXT( pAtqContext, reqContext);
            }

            cbWritten = reqContext->IoStatus1.Information;
            fRet = (reqContext->IoStatus1.Status == STATUS_SUCCESS);
            SetLastError(g_pfnRtlNtStatusToDosError(reqContext->IoStatus1.Status));

            lpo = &pAtqContext->Overlapped;

            //
            // If the TransmitFile fails then the receive is not issued.
            //

            if ( fRet ) {
                fDriverCall = TRUE;
            } else {
                DBG_ASSERT( fDriverCall == FALSE);
                pAtqContext->ResetFlag( ACF_RECV_ISSUED);
            }
        } else {
            ATQ_ASSERT( !"Invalid oplock notification" );
            return;
        }
    }

    dwError = (fRet) ? NO_ERROR: GetLastError();

    //
    //  If this is an AcceptEx listen socket atq completion, then the
    //  client Atq context we really want is keyed from the overlapped
    //  structure that is stored in the client's Atq context.
    //

    if ( pAtqContext->IsAcceptExRootContext() ) {

        pAtqContext = CONTAINING_RECORD( lpo, ATQ_CONTEXT, Overlapped );
    }

    DBG_CODE(
             if ( ATQ_CONTEXT_SIGNATURE != pAtqContext->Signature) {
                 pAtqContext->Print();
                 DBG_ASSERT( FALSE);
             });


    //
    //  m_nIO also acts as the reference count for the atq contexts
    //  So, increment the count now, so that there is no other thread
    //   that will free up this ATQ context accidentally.
    //

    InterlockedIncrement( &pAtqContext->m_nIO);

    //
    // Busy wait for timeout processing to complete!
    //  This is ugly :( A fix in time for IIS 2.0/Catapult 1.0 release
    //

    InterlockedIncrement(  &pAtqContext->lSyncTimeout);
    while ( pAtqContext->IsFlag( ACF_IN_TIMEOUT)) {

        AcIncrement( CacAtqWaitsForTimeout);

        Sleep( ATQ_WAIT_FOR_TIMEOUT_PROCESSING);
    };

    //
    //  We need to make sure the timeout thread doesn't time this
    //  request out so reset the timeout value
    //

    InterlockedExchange( (LPLONG )&pAtqContext->NextTimeout,
                         (LONG ) ATQ_INFINITE);

    //
    // Update Bandwidth information on successful completion, if needed
    //

    if ( BANDWIDTH_INFO::GlobalEnabled() && fRet && cbWritten > 0)
    {
        AtqpUpdateBandwidth( pAtqContext, cbWritten);
    }

    //
    // Since the IO completion means that one of the async operation finished
    //  decrement our internal ref count appropriately to balance the addition
    //  when the IO operation was submitted.
    //
    InterlockedDecrement( &pAtqContext->m_nIO);

    //
    //  Is this a connection indication?
    //

    if ( !pAtqContext->IsFlag( ACF_CONN_INDICATED) ) {

        PATQ_ENDPOINT pEndpoint = pAtqContext->pEndpoint;

        if ( NULL == pEndpoint) {
            pAtqContext->Print();
            OutputDebugString( "Found an ATQ context with bad Endpoint\n");
            DBG_ASSERT( FALSE);
            DBG_REQUIRE( InterlockedDecrement(  &pAtqContext->lSyncTimeout) == 0);
            InterlockedDecrement( &pAtqContext->m_nIO); // balance entry count
            return;
        }

        DBG_ASSERT( pEndpoint != NULL );

        //
        //  Indicate this socket is in use
        //

        InterlockedDecrement( &pEndpoint->nSocketsAvail );

        //
        //  If we're running low on sockets, add some more now
        //

        if ( pEndpoint->nSocketsAvail <
             (LONG )(pEndpoint->nAcceptExOutstanding >> 2) ) {

            (VOID ) I_AtqPrepareAcceptExSockets(pEndpoint,
                                                pEndpoint->nAcceptExOutstanding
                                                        );
        }

        //
        //  If an error occurred on this completion,
        //    shutdown the socket
        //

        if ( !fRet ) {

            IF_DEBUG( ERROR) {
                if ( dwError != ERROR_OPERATION_ABORTED ) {
                    ATQ_PRINTF(( DBG_CONTEXT,
                                 " Free Context(%08x, EP=%08x) to cache. "
                                 "Err=%d, sock=%08x\n",
                             pAtqContext, pEndpoint,
                                 dwError,
                                 pAtqContext->hAsyncIO));
                }
            }

            DBG_REQUIRE( InterlockedDecrement(  &pAtqContext->lSyncTimeout) == 0);

            InterlockedDecrement( &pAtqContext->m_nIO); // balance entry count

            // balance original count
            InterlockedDecrement( &pAtqContext->m_nIO);
            // Free up the atq context without Reuse
            pAtqContext->CleanupAndRelease();
            return;
        }

        //
        //  Shutdown may close the socket from underneath us so don't
        //  assert, just warn.
        //

        if ( !pAtqContext->IsState( ACS_SOCK_LISTENING) ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                         "[AtqPoolThread] Warning-Socket state not listening\n"
                         ));
            DBG_CODE( pAtqContext->Print());
        }

        pAtqContext->MoveState( ACS_SOCK_CONNECTED);

        //
        // Remove the context from the pending list and put
        // it on the active list
        //

        DBG_ASSERT( pAtqContext->ContextList != NULL);
        pAtqContext->ContextList->MoveToActiveList( &pAtqContext->m_leTimeout);

        //
        //  Set the connection indicated flag.  After we return from
        //  the connection completion routine we assume it's
        //  safe to call the IO completion routine
        //  (or the connection indication routine should do cleanup
        //  and never issue an IO request).  This is primarily for
        //  the timeout thread.
        //

        pAtqContext->ConnectionCompletion( cbWritten, lpo);
    } else {


        //
        //  Not a connection completion indication. I/O completion.
        //

        //
        //  If an error occurred on a TransmitFile (or other IO),
        //  set the state to connected so the socket will get
        //  closed on cleanup
        //

        if ( !fRet &&
             pAtqContext->IsState( ACS_SOCK_UNCONNECTED)
             ){
            pAtqContext->MoveState( ACS_SOCK_CONNECTED);
        }

#if 0
        if (fDriverCall) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "[AtqPoolThread] pfnCompletion1(%08lx)\n",
                         pAtqContext ));
        }
#endif

        pAtqContext->IOCompletion( cbWritten, dwError, lpo);

        if (fDriverCall) {
            pAtqContext->ResetFlag( ACF_RECV_ISSUED);
            fRet = (reqContext->IoStatus2.Status == STATUS_SUCCESS);
            SetLastError( g_pfnRtlNtStatusToDosError(
                                         reqContext->IoStatus2.Status));

            //
            //  If an error occurred on a TransmitFile (or other IO),
            //  set the state to connected so the socket will get
            //  closed on cleanup
            //

            if ( !fRet &&
                 pAtqContext->IsState( ACS_SOCK_UNCONNECTED) ) {
                pAtqContext->MoveState( ACS_SOCK_CONNECTED);
            }

            if ((reqContext->IoStatus1.Status == STATUS_SUCCESS) &&
                (pAtqContext->ClientContext != NULL) &&
                (pAtqContext->IsFlag(ACF_RECV_CALLED)) ) {

                IF_DEBUG( SPUD) {

                    ATQ_PRINTF(( DBG_CONTEXT,
                                 "[AtqPoolThread] pfnCompletion2(%08lx)\n",
                                 pAtqContext ));
                };

                pAtqContext->IOCompletion( reqContext->IoStatus2.Information,
                                        (fRet) ? NO_ERROR : GetLastError(),
                                        lpo
                                        );
            }
            pAtqContext->ResetFlag( ACF_RECV_CALLED);
        }
    }

    DBG_ASSERT( pAtqContext->lSyncTimeout > 0);
    InterlockedDecrement( &pAtqContext->lSyncTimeout);

    //
    // We do an interlocked decrement on m_nIO to sync up state
    //  so that the context is not prematurely deleted.
    //

    if ( InterlockedDecrement(  &pAtqContext->m_nIO) == 0) {

        //
        // The number of outstanding ref holders is ZERO.
        // Free up this ATQ context.
        //
        // We really do not free up the context - but try to reuse
        //  it if possible
        //

        // free the atq context now or reuse if possible.
        AtqpReuseOrFreeContext( pAtqContext,
                                (pAtqContext->
                                 IsFlag( ACF_REUSE_CONTEXT) != 0)
                                );
    }

    return;
} // AtqpProcessContext()



DWORD
AtqPoolThread(
    LPDWORD param
    )
/*++

Routine Description:

    This is the pool thread wait and dispatch routine

  Arguments:
    param : unused.

  Return Value:

    Thread return value (ignored)

--*/
{
    PATQ_CONT    pAtqContext;
    BOOL         fRet;
    LPOVERLAPPED lpo;
    DWORD        cbWritten;
    DWORD        returnValue;
    DWORD        availThreads;

    for(;;) {

        pAtqContext = NULL;
        InterlockedIncrement( &g_cAvailableThreads );

        fRet = g_pfnGetQueuedCompletionStatus( g_hIoCompPort,
                                               &cbWritten,
                                               (LPDWORD)&pAtqContext,
                                               &lpo,
                                               g_msThreadTimeout );

        availThreads = InterlockedDecrement( &g_cAvailableThreads );

        if ( fRet || lpo ) {

            if ( pAtqContext == NULL) {
                if ( g_fShutdown ) {

                    //
                    // This is our signal to exit.
                    //

                    returnValue = NO_ERROR;
                    break;
                }

                OutputDebugString( "A null context received\n");
                continue;  // some error in the context has occured.
            }

            //
            // Make sure we're not running out of threads
            //

            if ( availThreads == 0 ) {

                //
                //  Make sure there are pool threads to service the request
                //

                (VOID)I_AtqCheckThreadStatus();
            }

            AtqpProcessContext( pAtqContext, cbWritten, lpo, fRet);
        } else {

            //
            // don't kill the initial thread
            //

            if ( ((DWORD)param == ATQ_INITIAL_THREAD) && !g_fShutdown ) {
                continue;
            }

            //
            //  An error occurred.  Either the thread timed out, the handle
            //  is going away or something bad happened.  Let the thread exit.
            //

            returnValue = GetLastError();

            break;
        }

    } // for

    if ( NULL != g_pfnExitThreadCallback) {

        //
        //  Client wishes to be told when ATQ threads terminate.
        //

        g_pfnExitThreadCallback();
    }

    if ( InterlockedDecrement( &g_cThreads ) == 0 ) {

        //
        // Wake up ATQTerminate()
        //
        IF_DEBUG( ERROR) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqPoolThread() - setting shutdown event %08x."
                         " g_cThreads = %d\n",
                         g_hShutdownEvent, g_cThreads
                         ));
        }

        SetEvent( g_hShutdownEvent );
    }

    return returnValue;
} // AtqPoolThread




BOOL
I_AtqCheckThreadStatus(
    PVOID Context
    )
/*++

Routine Description:

    This routine makes sure there is at least one thread in
    the thread pool.  We're fast and loose so a couple of extra
    threads may be created.

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    BOOL fRet = TRUE;

    //
    //  If no threads are available, kick a new one off up to the limit
    //
    //  WE NEED TO CHANGE THE CONDITIONS FOR STARTING ANOTHER THREAD
    //  IT SHOULD NOT BE VERY EASY TO START A THREAD ....
    //

    if ( (g_cAvailableThreads == 0) &&
         (g_cThreads < g_cMaxThreads) &&
         (g_cThreads < g_cMaxThreadLimit) ) {

        HANDLE hThread;
        DWORD  dwThreadID;

        InterlockedIncrement( &g_cThreads );

        hThread = CreateThread( NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)AtqPoolThread,
                                Context,
                                0,
                                &dwThreadID );

        if ( hThread ) {
            CloseHandle( hThread );     // Free system resources
        } else {

            //
            // We fail if there are no threads running
            //

            if ( InterlockedDecrement( &g_cThreads ) == 0) {
                ATQ_PRINTF(( DBG_CONTEXT,
                    "AtqCheckThread: Cannot create ATQ threads\n"));
                fRet = FALSE;
            }
        }
    }

    return fRet;
} // I_AtqCheckThreadStatus()



/************************************************************
 *  Functions to Add/Delete Atq Contexts
 ************************************************************/


BOOL
I_AtqAddAsyncHandle(
    IN OUT PATQ_CONT  *    ppAtqContext,
    IN PATQ_ENDPOINT       pEndpoint,
    PVOID                  ClientContext,
    ATQ_COMPLETION         pfnCompletion,
    DWORD                  TimeOut,
    HANDLE                 hAsyncIO
    )
/*++

  Description:
    This functio adds creates a new NON-AcceptEx() based Atq Context,
     and includes it in proper lists fo ATQ Context management.


  Note:
    The client should call this after the IO handle is openned
    and before the first IO request is made

    Even in the case of failure, client should call AtqFreeContext() and
     free the memory associated with this object.

--*/
{
    BOOL         fReturn = TRUE;

    DBG_ASSERT( ppAtqContext != NULL);
    DBG_ASSERT( ClientContext != NULL);

    *ppAtqContext = NULL; // initialize

    if ( g_fShutdown) {

        SetLastError( ERROR_NOT_READY);
        return (FALSE);

    } else {

        PATQ_CONT    pAtqContext;

        //
        //  Note we take and release the lock here as we're
        //  optimizing for the reuseable context case
        //

        pAtqContext = I_AtqAllocContextFromCache();
        if ( pAtqContext == NULL) {

            return (FALSE);
        }

        //
        //  Fill out the context.  We set NextTimeout to INFINITE
        //  so the timeout thread will ignore this entry until an IO
        //  request is made unless this is an AcceptEx socket, that means
        //  we're about to submit the IO.
        //


        pAtqContext->InitWithDefaults(pfnCompletion,
                                      CanonTimeout( TimeOut ), hAsyncIO);

        //
        //  These data members are used if we're doing AcceptEx processing
        //

        pAtqContext->SetAcceptExBuffer( NULL);

        pAtqContext->InitNonAcceptExState(ClientContext);

        //
        // If an endpoint is provided, reference it
        //

        if ( pEndpoint != NULL ) {
            pEndpoint->Reference();
            pAtqContext->pEndpoint = pEndpoint;
        }

        *ppAtqContext = pAtqContext;
    }

    return (TRUE);

} // I_AtqAddAsyncHandle()




BOOL
I_AtqAddListenEndpointToPort(
    IN OUT PATQ_CONT    * ppAtqContext,
    IN PATQ_ENDPOINT    pEndpoint
    )
/*++

  Description:
    This function creates a new AtqContext for the given ListenSocket.
    It uses the listen socket as the AcceptEx() socket too for adding
     the atq context to the completion port.
    It assumes
      TimeOut to be INFINITE, with no Endpoint structure.

  Arguments:
    ppAtqContext - pointer to location that will contain the atq context
                   on successful return.
    pEndpoint - pointer to the endpoint.

  Returns:
    TRUE on success
    FALSE if there is a failure.

  Note:
    The caller should free the *ppAtqContext if there is a failure.

--*/
{
    BOOL         fReturn = TRUE;
    PATQ_CONT    pAtqContext;

    DBG_ASSERT( g_fUseAcceptEx); // only support AcceptEx() cases

    *ppAtqContext = NULL; // initialize

    if ( g_fShutdown) {

        SetLastError( ERROR_NOT_READY);
        return (FALSE);

    } else {

        //
        //  Note we take and release the lock here as we're
        //  optimizing for the reuseable context case
        //

        pAtqContext = I_AtqAllocContextFromCache();

        if ( pAtqContext == NULL) {

            return (FALSE);
        }

        //
        //  Fill out the context.
        //  We set the TimeOut for this object to be ATQ_INFINITE,
        //   since we do not want any interference from the Timeout loop.
        //

        pAtqContext->InitWithDefaults(
                                      pEndpoint->IoCompletion,
                                      ATQ_INFINITE,
                                      (HANDLE)pEndpoint->ListenSocket
                                      );

        //
        //  These data members are used if we're doing AcceptEx processing
        //


        pAtqContext->SetAcceptExBuffer( NULL);

        pAtqContext->pEndpoint       = NULL;
        pAtqContext->SetFlag( ACF_ACCEPTEX_ROOT_CONTEXT );

        //
        // We set NextTimeout to INFINITE
        //  so the timeout thread will ignore this entry until an IO
        //  request is made unless this is an AcceptEx socket, that means
        //  we're about to submit the IO.

        DBG_ASSERT( g_fUseAcceptEx && pEndpoint->ConnectExCompletion != NULL);

        pAtqContext->InitAcceptExState( ATQ_INFINITE);

        *ppAtqContext = pAtqContext;
    }

    fReturn = I_AddAtqContextToPort( pAtqContext);

    return (fReturn);

} // I_AtqAddListenEndpointToPort()



BOOL
I_AtqAddAcceptExSocket(
    IN PATQ_ENDPOINT          pEndpoint,
    IN PATQ_CONT              pAtqContext
    )
/*++

Routine Description:

    Adds the AtqContext to the AcceptEx() waiters list,
    after allocating a new socket, since pAtqContext->hAsyncIO = NULL.

Arguments:

    pEndpoint - Information about this listenning socket
    patqReusedContext - optional context to use

Return Value:

    TRUE on success, FALSE on failure.
    On failure the caller should free the pAtqContext

--*/
{
    BOOL   fAddToPort = FALSE;
    BOOL   fSuccess = TRUE;

    DBG_ASSERT( pAtqContext != NULL);
    DBG_ASSERT( g_pfnAcceptEx != NULL);
    DBG_ASSERT( pAtqContext->pvBuff != NULL);
    DBG_ASSERT( !TsIsWindows95() );

    //
    //  If this listen socket isn't accepting new connections, just return
    //

    if ( !IS_BLOCK_ACTIVE(pEndpoint) ) {

        SetLastError( ERROR_NOT_READY );
        return ( FALSE);
    }

    //
    //  Use the supplied socket if any.
    //  Otherwise create a new socket
    //

    if ( pAtqContext->hAsyncIO == NULL) {

        HANDLE sAcceptSocket;

        sAcceptSocket = (HANDLE )
#if WINSOCK11
            socket(
                   AF_INET,
                   SOCK_STREAM,
                   IPPROTO_TCP
                   );
#else
        WSASocketW(
                   AF_INET,
                   SOCK_STREAM,
                   IPPROTO_TCP,
                   NULL,  // protocol info
                   0,     // Group ID = 0 => no constraints
                   (g_fUseFakeCompletionPort ?
                    0:
                    WSA_FLAG_OVERLAPPED // completion port notifications
                    )
                   );
#endif // WINSOCK11

        if ( (SOCKET ) sAcceptSocket == INVALID_SOCKET ) {

            fSuccess = FALSE;
            sAcceptSocket = NULL;

            //
            // no need to unlink from any list, since we did not add it to any
            //

        } else {

            //
            // Setup the accept ex socket in the atq context.
            //

            pAtqContext->hAsyncIO = sAcceptSocket;
            pAtqContext->hJraAsyncIO  = (DWORD)sAcceptSocket | 0x80000000;
            fAddToPort = TRUE;
            DBG_ASSERT( fSuccess);
        }
    }

    if ( fSuccess) {

        DWORD        cbRecvd;

        if ( g_fShutdown) {

            //
            // no need to unlink from any list, since we did not add it to any
            //

            SetLastError( ERROR_NOT_READY);
            return (FALSE);
        }

        DBG_ASSERT( pAtqContext->hAsyncIO != NULL);

        //
        // 1. Call I_AtqAddAsyncHandleEx() to establish the links with
        //  proper AcceptEx & AtqContext processing lists.
        //
        //  After 1, the atqcontext will be in the lists, so
        //    cleanup should remove the context from proper lists.
        //
        // 2. Add the socket to Completion Port (if new),
        //    i.e. if fAddToPort is true)
        //
        // 3. Submit the new socket to AcceptEx() so that it may be
        //  used for processing about the new connections.
        //

        // 1.
        DBG_ASSERT( pAtqContext->m_nIO == 0);
        DBG_REQUIRE( pAtqContext->PrepareAcceptExContext(pEndpoint));

        // increment outstanding async io operations before AcceptEx() call
        InterlockedIncrement( &pAtqContext->m_nIO);

        fSuccess = (// 2.
                    ( !fAddToPort || I_AddAtqContextToPort( pAtqContext))
                    &&
                    // 3.
                    (
                     g_pfnAcceptEx( (SOCKET ) pEndpoint->ListenSocket,
                               (SOCKET ) pAtqContext->hAsyncIO,
                               pAtqContext->pvBuff,
                               pEndpoint->InitialRecvSize,
                               MIN_SOCKADDR_SIZE,
                               MIN_SOCKADDR_SIZE,
                               &cbRecvd,
                               &pAtqContext->Overlapped )
                     ||
                     (GetLastError() == ERROR_IO_PENDING)
                     )
                    );

        if ( fSuccess) {

            //
            //  We've successfully added this socket, increment the count
            //

            InterlockedIncrement( &pEndpoint->nSocketsAvail );

        } else {

            ATQ_PRINTF(( DBG_CONTEXT,
                        "[AtqAddAcceptExSocket] Reusing an old context (%08x)"
                        " failed; error %d:%d, sAcceptSocket = %x, "
                        " pEndpoint = %lx, parm4 = %d, parm7 = %lx,"
                        " parm8 = %lx\n",
                        pAtqContext,
                        GetLastError(),
                        WSAGetLastError(),
                        pAtqContext->hAsyncIO,
                        pEndpoint,
                        pEndpoint->InitialRecvSize,
                        &cbRecvd,
                        &pAtqContext->Overlapped ));

            //
            // Unlink from the current list, where it was added as a result of
            //  step 1 above.
            //
            DBG_ASSERT( pAtqContext->ContextList != NULL);

            // balance the increment of the async operations outstanding
            DBG_REQUIRE( InterlockedDecrement( &pAtqContext->m_nIO) > 0);

            DBG_ASSERT( pAtqContext->m_leTimeout.Flink != NULL);
            pAtqContext->ContextList->
                RemoveFromList( &pAtqContext->m_leTimeout);

            //
            // balance the increment done
            // by pAtqContext->PrepareAcceptExContext()
            //
            DBG_REQUIRE( InterlockedDecrement( &pAtqContext->m_nIO) == 0);
            DBG_ASSERT( !fSuccess);

            //
            // the caller will free the Atq context on failure
            //
        }
    }

    return ( fSuccess);
} // I_AtqAddAcceptExSocket()




VOID
AtqpReuseContext( PATQ_CONT  pAtqContext)
/*++
  Description:
     This function attempts to reuse the ATQ context.
     It first cleans up the state and then uses the function
      I_AtqAddAccetpEx() socket to re-add the context to acceptex pool

  Arguments:
     pAtqContext - pointer to ATQ context that can be reused

  Returns:
     None
--*/
{
    PATQ_ENDPOINT pEndpoint = pAtqContext->pEndpoint;

    DBG_ASSERT( pEndpoint != NULL);
    DBG_ASSERT( pEndpoint->UseAcceptEx);

    //
    // Complete connection has been processed prior to coming here
    //

    DBG_ASSERT(pAtqContext->IsFlag( ACF_CONN_INDICATED));

    //
    // Remove from the current active list
    //
    if ( pAtqContext->m_leTimeout.Flink != NULL ) {
        pAtqContext->ContextList->RemoveFromList( &pAtqContext->m_leTimeout );
    }

    DBG_ASSERT( pAtqContext->m_leTimeout.Flink == NULL);
    DBG_ASSERT( pAtqContext->m_leTimeout.Blink == NULL);

    DBG_ASSERT( pEndpoint->Signature == ATQ_ENDPOINT_SIGNATURE );

        //
        //  Either there is no socket or the socket must be in the
        //  unconnected state (meaning reused after TransmitFile)
        //

        //
        //  BUGBUG - Debug code, don't assert until we figure out how
        //  we got in this state
        //

    if ( !(!pAtqContext->hAsyncIO ||
           (pAtqContext->hAsyncIO &&
            pAtqContext->IsState( ACS_SOCK_UNCONNECTED |
                                  ACS_SOCK_TOBE_FREED)
            )
           )) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "[AtqReuseContext] Warning:"
                     " state = %08x, socket = %x (context %lx), "
                     " was Free called w/o close?\n",
                     pAtqContext->m_acState,
                     pAtqContext->hAsyncIO,
                     pAtqContext ));
        DBG_ASSERT( FALSE);
    }

    //
    // I need to make sure that the state information is cleaned up
    //  before re-adding the context to the list
    //

    if ( !I_AtqAddAcceptExSocket(pEndpoint, pAtqContext) ) {

        //
        //  Failed to add the socket, free up the context without reuse
        //

        ATQ_PRINTF(( DBG_CONTEXT,
                     "[AtqpReuseContext] for (%08x) failed with "
                     " Error = %d;  Now freeing the context ...\n",
                     pAtqContext, GetLastError()
                     ));

        DBG_ASSERT( pAtqContext->m_nIO == 0);

        // free without reuse
        pAtqContext->CleanupAndRelease();
    }

    return;
} // AtqpReuseContext()



VOID
AtqpReuseOrFreeContext(
    PATQ_CONT    pAtqContext,
    BOOL         fReuseContext
    )
/*++
  Routine Description:
     This function does a free-up of the ATQ contexts. During the free-up
     path, we also attempt to reuse the ATQ context if the fReuseContext is
     set.

  Arguments:
     pAtqContext - pointer to the ATQ context that needs to be freedup
     fReuseContext - BOOLEAN flag indicating if this context should be reused

  Returns:
     None
--*/
{
    //
    // Get this object out of the Blocked Requests List.
    //

    if ( pAtqContext->IsBlocked()) {
        ATQ_REQUIRE( pAtqContext->m_pBandwidthInfo
                      ->RemoveFromBlockedList( pAtqContext ));
        DBG_ASSERT( !pAtqContext->IsBlocked());
    }

    DBG_ASSERT( pAtqContext->m_pBandwidthInfo != NULL);
    pAtqContext->m_pBandwidthInfo->Dereference();

    //
    //  If the socket is an AcceptEx socket and reuse is enabled,
    //   redo the AcceptEx and put it back on use
    //

    if ( fReuseContext &&
         (pAtqContext->pEndpoint != NULL)  &&
         (pAtqContext->pEndpoint->UseAcceptEx)
         ) {

        //
        // Call the function to reuse context. On failure
        // the AtqpReuseContext will free up the context
        //

        AtqpReuseContext( pAtqContext);

    } else {

        pAtqContext->CleanupAndRelease();

    }

    return;
} // AtqpReuseOrFreeContext()



BOOL
I_AtqPrepareAcceptExSockets(
    IN PATQ_ENDPOINT          pEndpoint,
    IN DWORD                  nSockets
    )
/*++

Routine Description:

    Prepare specified number of AcceptEx sockets for the given
      ListenSocket in [pEndpoint]

Arguments:

    pEndpoint - Information about this listenning socket
    nSockets    - number of AcceptEx() sockets to be created.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    BOOL   fReturn;
    DWORD  cbBuffer;
    DWORD  i;

    if ( !g_fUseAcceptEx ) {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }

    //
    //  If this listen socket isn't accepting new connections, just return
    //

    if ( pEndpoint->State != AtqStateActive ) {
        SetLastError( ERROR_NOT_READY );
        return(FALSE);
    }

    // calculate the buffer size
    cbBuffer = pEndpoint->InitialRecvSize + 2* MIN_SOCKADDR_SIZE;

    for ( fReturn = TRUE, i = 0 ; fReturn && i++ < nSockets; ) {

        PVOID        pvBuff;
        PATQ_CONT    pAtqContext;

        //
        //  Alloc a buffer for receive data
        //  TBD: Pool all these buffers into one large buffer.
        //

        pvBuff = LocalAlloc( LPTR, cbBuffer);

        //
        //  Get the ATQ context now because we need its overlapped structure
        //

        pAtqContext = I_AtqAllocContextFromCache();


        //
        // Now check if allocations are valid and do proper cleanup on failure
        //

        if ( pvBuff == NULL || pAtqContext == NULL) {

            if ( pvBuff ) {
                LocalFree( pvBuff );
                pvBuff = NULL;
            }

            if ( pAtqContext ) {
                I_AtqFreeContextToCache( pAtqContext );
                pAtqContext = NULL;
            }

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            fReturn = FALSE;
            break;
        } else {

            //
            // Add this socket to AtqContext lists & completion ports
            // From now on the called function will take care of freeing up
            //  pAtqContext, if there is a failure.
            //

            pAtqContext->SetAcceptExBuffer( pvBuff);
            pAtqContext->hAsyncIO = NULL;
            pAtqContext->hJraAsyncIO = 0;

            if ( !I_AtqAddAcceptExSocket(pEndpoint, pAtqContext) ) {

                //
                //  Failed to add the socket, free up the context without reuse
                //

                ATQ_PRINTF(( DBG_CONTEXT,
                             "[I_AtqPrepareAcceptExSockets] for Endpoint %08x"
                             " and AtqContext (%08x) failed with "
                             " Error = %d;  Now freeing the context ...",
                             pEndpoint, pAtqContext, GetLastError()
                             ));

                // free without reuse
                DBG_ASSERT( pAtqContext->m_nIO == 0);
                pAtqContext->CleanupAndRelease();
                fReturn = FALSE;
            }
        }
    } // for


    ATQ_PRINTF(( DBG_CONTEXT,
                "PrepareAcceptExSockets( Endpoint[%08x], nSockets = %d)==>"
                " avail = %d; Total Refs = %d.\n",
                pEndpoint,
                nSockets,
                pEndpoint->nSocketsAvail,
                pEndpoint->m_refCount
                ));

    return ( fReturn);

} // I_AtqPrepareAcceptExSockets()



BOOL
I_AtqInitializeNtEntryPoints(
    VOID
    )
{

    HINSTANCE tmpInstance;

    //
    // load kernel32 and get NT specific entry points
    //

    tmpInstance = LoadLibrary("kernel32.dll");
    if ( tmpInstance != NULL ) {

        g_pfnReadDirChangesW = (PFN_READ_DIR_CHANGES_W)
            GetProcAddress( tmpInstance, "ReadDirectoryChangesW");

        DBG_ASSERT(g_pfnReadDirChangesW != NULL);

        //
        // We can free this because we are statically linked to it
        //

        FreeLibrary(tmpInstance);
    }

    g_hMSWsock = LoadLibrary( "mswsock.dll" );

    if ( g_hMSWsock != NULL ) {

        g_pfnAcceptEx = (PFN_ACCEPTEX)
                GetProcAddress( g_hMSWsock, "AcceptEx" );

        g_pfnTransmitFile = (PFN_TRANSMITFILE)
                        GetProcAddress( g_hMSWsock,"TransmitFile" );

        g_pfnGetAcceptExSockaddrs = (PFN_GETACCEPTEXSOCKADDRS)
                GetProcAddress( g_hMSWsock,"GetAcceptExSockaddrs" );

        if ( !g_pfnAcceptEx ||
             !g_pfnGetAcceptExSockaddrs ||
             !g_pfnTransmitFile ) {

            //
            // This is bad.
            //

            DBG_ASSERT(FALSE);

            ATQ_PRINTF(( DBG_CONTEXT,
                "Failed to get entry points AE %x TF %x GAE %x\n",
                g_pfnAcceptEx, g_pfnTransmitFile,
                g_pfnGetAcceptExSockaddrs));

            goto cleanup;
        }

    } else {

        ATQ_PRINTF((DBG_CONTEXT,
            "Error %d in LoadLibrary[mswsock.dll]\n",
            GetLastError()));
        goto cleanup;
    }

    //
    // load ntdll
    //

    if ( g_fUseDriver ) {

        g_hNtdll = LoadLibrary( "ntdll.dll" );

        if ( g_hNtdll != NULL ) {

            g_pfnNtLoadDriver = (PFN_NT_LOAD_DRIVER)
                    GetProcAddress( g_hNtdll, "NtLoadDriver" );

            g_pfnRtlInitUnicodeString = (PFN_RTL_INIT_UNICODE_STRING)
                    GetProcAddress( g_hNtdll, "RtlInitUnicodeString" );

            g_pfnRtlNtStatusToDosError = (PFN_RTL_NTSTATUS_TO_DOSERR)
                    GetProcAddress( g_hNtdll, "RtlNtStatusToDosError" );

            g_pfnRtlInitAnsiString = (PFN_RTL_INIT_ANSI_STRING)
                    GetProcAddress( g_hNtdll, "RtlInitAnsiString" );

            g_pfnRtlAnsiStringToUnicodeString =
                (PFN_RTL_ANSI_STRING_TO_UNICODE_STRING)
                    GetProcAddress( g_hNtdll, "RtlAnsiStringToUnicodeString" );

            g_pfnRtlFreeHeap = (PFN_RTL_FREE_HEAP)
                    GetProcAddress( g_hNtdll, "RtlFreeHeap" );

            g_pfnRtlDosPathNameToNtPathName_U =
                (PFN_RTL_DOS_PATHNAME_TO_NT_PATHNAME)
                    GetProcAddress( g_hNtdll, "RtlDosPathNameToNtPathName_U" );

            if ( !g_pfnNtLoadDriver ||
                 !g_pfnRtlInitUnicodeString ||
                 !g_pfnRtlNtStatusToDosError ||
                 !g_pfnRtlInitAnsiString ||
                 !g_pfnRtlAnsiStringToUnicodeString ||
                 !g_pfnRtlFreeHeap ||
                 !g_pfnRtlDosPathNameToNtPathName_U ) {

                //
                // This is bad.
                //

                ATQ_PRINTF(( DBG_CONTEXT,
                    "Failed to get entry points for ntdll.dll\n"));

                DBG_ASSERT(FALSE);
                goto cleanup;
            }

        } else {

            ATQ_PRINTF((DBG_CONTEXT,
                "Error %d in LoadLibrary[ntdll.dll]\n", GetLastError()));
            goto cleanup;
        }
    }

    return(TRUE);

cleanup:

    if ( g_hNtdll != NULL ) {
        FreeLibrary( g_hNtdll );
        g_hNtdll = NULL;
    }

    if ( g_hMSWsock != NULL ) {
        FreeLibrary( g_hMSWsock );
        g_hMSWsock = NULL;
    }

    return(FALSE);
} // I_AtqInitializeEntryPoints
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\oplock\spud.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

      spud.cxx

   Abstract:
      This module implements the user mode entry points for SPUD.SYS.
      SPUD = Special Purpose Utility Driver.

   Author:

       John Ballard ( jballard )     22-Oct-1996

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Common DLL

   Functions Exported:

       BOOL  AtqTransmitFileAndRecv();
       BOOL  AtqSendAndRecv();
       BOOL  AtqBatchRequest();

--*/


#include "isatq.hxx"
#include <tdi.h>
#include <afd.h>
#include <spud.h>
#include "uspud.h"


// ------------------------------
// oplock notification thread stuff
// ------------------------------

#define KILL_OPLOCK_THREAD  ((LPOVERLAPPED)0xffeeffee)

HANDLE g_hOplockThread = NULL;

DWORD
WINAPI
I_AtqOplockThread(
    IN LPVOID Param
    );


VOID
EnableLoadDriverPrivilege(
    VOID
    );

#define SPUD_REG_PATH   \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Spud"

BOOL
I_AtqSpudInitialize(
            IN HANDLE hIoPort,
            IN HANDLE hOplockPort
            )
{
    NTSTATUS    status;
    UNICODE_STRING  DriverName;
    DWORD   Version = SPUD_VERSION;

    if ( !g_fUseDriver ) {
        return(FALSE);
    }

    EnableLoadDriverPrivilege();

    g_pfnRtlInitUnicodeString( &DriverName, SPUD_REG_PATH );
    status = g_pfnNtLoadDriver( &DriverName );
    if ( ( status != STATUS_SUCCESS ) &&
         ( status != STATUS_IMAGE_ALREADY_LOADED ) ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "NtLoadDriver failed!!! status == %08lx\n",
                     status
                     ));
        goto disable_driver;
    }

    status = SPUDInitialize(Version, hIoPort, hOplockPort);
    if ( status != STATUS_SUCCESS ) {

        if ( status == STATUS_INVALID_DEVICE_REQUEST ) {
            SPUDTerminate();
            if ( SPUDInitialize(Version, hIoPort, hOplockPort) == STATUS_SUCCESS ) {
                return TRUE;
            }
        }

        ATQ_PRINTF(( DBG_CONTEXT,
                     "SPUDInitialize failed!!! status == %08lx\n",
                     status
                     ));
        goto disable_driver;
    }

    return TRUE;

disable_driver:

    g_fUseDriver = FALSE;

    ATQ_PRINTF((DBG_CONTEXT, "SPUDInitialize: Disabling driver\n"));
    return(FALSE);
} // I_AtqSpudInitialize


BOOL
I_AtqSpudTerminate()
{
    NTSTATUS    status;

    status = SPUDTerminate();
    if ( status != STATUS_SUCCESS ) {

        IF_DEBUG(ERROR) {
            ATQ_PRINTF(( DBG_CONTEXT,
                     "SPUDTerminate failed!!! status == %08lx\n",
                     status
                     ));
        }
        return FALSE;
    }

    return TRUE;
}

BOOL
I_AtqSpudCheckStatus(
    IN PATQ_CONT                patqContext             // pointer to ATQ context
    )
{
        ULONG status;

        status = SPUDCheckStatus( &patqContext->spudContext );

        if ( status != STATUS_SUCCESS ) {
                return FALSE;
        }

        return TRUE;
}

BOOL
I_AtqTransmitFileAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN HANDLE                   hFile,                  // handle of file to read
    IN DWORD                    dwBytesInFile,          // Bytes to transmit
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers,      // transmit buffer structure
    IN DWORD                    dwTFFlags,              // TF Flags
    IN LPWSABUF                 pwsaBuffers,            // Buffers for recv
    IN DWORD                    dwBufferCount
    )
/*++
Routine Description:

    Calls SPUDTransmitFileAndRecv().  Cannot be blocked by bandwidth throttler

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)
--*/
{
        ULONG   status;
        AFD_TRANSMIT_FILE_INFO transmitInfo;
        AFD_RECV_INFO          recvInfo;
        PATQ_CONT              patqCont = (PATQ_CONT)patqContext;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                     "I_AtqTransmitFileAndRecv(%08lx) called.\n", patqContext));
        }

        transmitInfo.WriteLength.QuadPart = dwBytesInFile;
        transmitInfo.SendPacketLength = 0;
        transmitInfo.FileHandle = hFile;
        transmitInfo.Flags = dwTFFlags;
        if ( lpTransmitBuffers != NULL ) {
            transmitInfo.Head = lpTransmitBuffers->Head;
            transmitInfo.HeadLength = lpTransmitBuffers->HeadLength;
            transmitInfo.Tail = lpTransmitBuffers->Tail;
            transmitInfo.TailLength = lpTransmitBuffers->TailLength;
        } else {
            transmitInfo.Head = NULL;
            transmitInfo.HeadLength = 0;
            transmitInfo.Tail = NULL;
            transmitInfo.TailLength = 0;
        }

        transmitInfo.Offset.LowPart = patqContext->Overlapped.Offset;
        transmitInfo.Offset.HighPart = 0;

        recvInfo.BufferArray = pwsaBuffers;
        recvInfo.BufferCount = dwBufferCount;
        recvInfo.AfdFlags = AFD_OVERLAPPED;
        recvInfo.TdiFlags = TDI_RECEIVE_NORMAL;
        patqCont->ResetFlag( ACF_RECV_CALLED);

        status = SPUDTransmitFileAndRecv( patqCont->hAsyncIO,
                                         &transmitInfo,
                                         &recvInfo,
                                         &patqCont->spudContext
                                         );

        if ( status != STATUS_SUCCESS &&
             status != STATUS_PENDING ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                         "SPUDTransmitFileAndRecv failed!!! status == %08lx\n",
                         status
                         ));
            SetLastError(g_pfnRtlNtStatusToDosError(status));
            patqCont->MoveState( ACS_SOCK_CONNECTED);
            return FALSE;
        }

        patqCont->SetFlag( ACF_RECV_ISSUED);

        return TRUE;
}

BOOL
AtqTransmitFileAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN HANDLE                   hFile,                  // handle of file to read
    IN DWORD                    dwBytesInFile,          // Bytes to transmit
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers,      // transmit buffer structure
    IN DWORD                    dwTFFlags,              // TF Flags
    IN LPWSABUF                 pwsaBuffers,            // Buffers for recv
    IN DWORD                    dwBufferCount
    )
{
    BOOL fRes;
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    if ( !g_fUseDriver || pContext->IsFlag( ACF_RECV_ISSUED) ) {
        BOOL            fRes;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                "AtqTransmitFileAndRecv(%08lx) g_fUseDriver == FALSE\n Calling AtqTransmitFile.\n", patqContext));
        }

        return AtqTransmitFile( patqContext,
                                hFile,
                                dwBytesInFile,
                                lpTransmitBuffers,
                                dwTFFlags );
    }

    I_SetNextTimeout(pContext);

    pContext->BytesSent = dwBytesInFile;

    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent += pwsaBuffers->len;
    if ( dwBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaBuffers + 1;
              pWsaBuf <= (pwsaBuffers + dwBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    if ( dwTFFlags == 0 ) {

        //
        // If no flags are set, then we can attempt to use the special
        // write-behind flag.  This flag can cause the TransmitFile to
        // complete immediately, before the send actually completes.
        // This can be a significant performance improvement inside the
        // system.
        //

        dwTFFlags = TF_WRITE_BEHIND;

    }

    InterlockedIncrement( &pContext->m_nIO);

    switch ( pBandwidthInfo->QueryStatus( AtqIoXmitFileRecv ) )
    {
    case StatusAllowOperation:

        pBandwidthInfo->IncTotalAllowedRequests();

        fRes = I_AtqTransmitFileAndRecv( patqContext,
                                         hFile,
                                         dwBytesInFile,
                                         lpTransmitBuffers,
                                         dwTFFlags,
                                         pwsaBuffers,
                                         dwBufferCount ) ||
                (GetLastError() == ERROR_IO_PENDING);

        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

        break;

    case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoXmitFileRecv;
        pContext->arInfo.lpOverlapped = &pContext->Overlapped;

        pContext->arInfo.uop.opXmitRecv.hFile = hFile;
        pContext->arInfo.uop.opXmitRecv.dwBytesInFile = dwBytesInFile;
        pContext->arInfo.uop.opXmitRecv.lpXmitBuffers = lpTransmitBuffers;
        pContext->arInfo.uop.opXmitRecv.dwTFFlags     = dwTFFlags;
        pContext->arInfo.uop.opXmitRecv.dwBufferCount = dwBufferCount;

        if ( dwBufferCount == 1) {
            pContext->arInfo.uop.opXmitRecv.buf1.len = pwsaBuffers->len;
            pContext->arInfo.uop.opXmitRecv.buf1.buf = pwsaBuffers->buf;
            pContext->arInfo.uop.opXmitRecv.pBufAll  = NULL;
        } else {

            DBG_ASSERT( dwBufferCount > 1);

            WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwBufferCount * sizeof (WSABUF));
            if ( NULL != pBuf) {
                pContext->arInfo.uop.opXmitRecv.pBufAll = pBuf;
                CopyMemory( pBuf, pwsaBuffers,
                            dwBufferCount * sizeof(WSABUF));
            } else {
                return ( FALSE);
            }
        }

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext);
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

    default:
        ATQ_ASSERT( FALSE);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;

    } // switch()

    return fRes;
} // AtqTransmitFileAndRecv()

BOOL
I_AtqSendAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN LPWSABUF                 pwsaSendBuffers,        // buffers for send
    IN DWORD                    dwSendBufferCount,      // count of buffers for send
    IN LPWSABUF                 pwsaRecvBuffers,        // Buffers for recv
    IN DWORD                    dwRecvBufferCount       // count of buffers for recv
    )
/*++
Routine Description:

    Calls SPUDSendAndRecv().  Cannot be blocked by bandwidth throttler.

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)
--*/
{
        ULONG   status;
        AFD_SEND_INFO          sendInfo;
        AFD_RECV_INFO          recvInfo;
        PATQ_CONT              patqCont = (PATQ_CONT)patqContext;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                 "I_AtqSendAndRecv(%08lx) called.\n", patqContext));
        }

        sendInfo.BufferArray = pwsaSendBuffers;
        sendInfo.BufferCount = dwSendBufferCount;
        sendInfo.AfdFlags = AFD_OVERLAPPED;
        sendInfo.TdiFlags = 0;

        recvInfo.BufferArray = pwsaRecvBuffers;
        recvInfo.BufferCount = dwRecvBufferCount;
        recvInfo.AfdFlags = AFD_OVERLAPPED;
        recvInfo.TdiFlags = TDI_RECEIVE_NORMAL;
        patqCont->ResetFlag( ACF_RECV_CALLED);

        status = SPUDSendAndRecv( patqCont->hAsyncIO,
                                 &sendInfo,
                                 &recvInfo,
                                 &patqCont->spudContext
                                 );

        if ( status != STATUS_SUCCESS &&
             status != STATUS_PENDING ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                     "SPUDSendAndRecv failed!!! status == %08lx\n",
                     status
                     ));
             SetLastError(g_pfnRtlNtStatusToDosError(status));
             return FALSE;
        }

        patqCont->SetFlag( ACF_RECV_ISSUED);

        return TRUE;
}

BOOL
AtqSendAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN LPWSABUF                 pwsaSendBuffers,        // buffers for send
    IN DWORD                    dwSendBufferCount,      // count of buffers for send
    IN LPWSABUF                 pwsaRecvBuffers,        // Buffers for recv
    IN DWORD                    dwRecvBufferCount       // count of buffers for recv
    )
{
    BOOL fRes;
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
            "AtqSendAndRecv(%08lx) called.\n", patqContext));
    }

    if ( !g_fUseDriver || pContext->IsFlag( ACF_RECV_ISSUED) ) {

        BOOL            fRes;
        DWORD           cbWritten;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                 "AtqSendAndRecv(%08lx) g_fUseDriver == FALSE\n Calling AtqWriteSocket.\n", patqContext));
        }

        return AtqWriteSocket( patqContext,
                               pwsaSendBuffers,
                               dwSendBufferCount,
                               &patqContext->Overlapped );
    }

    InterlockedIncrement( &pContext->m_nIO);

    I_SetNextTimeout(pContext);

    //
    // count the number of bytes
    //

    DBG_ASSERT( dwSendBufferCount >= 1);
    pContext->BytesSent = pwsaSendBuffers->len;
    if ( dwSendBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaSendBuffers + 1;
            pWsaBuf <= (pwsaSendBuffers + dwSendBufferCount);
            pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }


    DBG_ASSERT( dwRecvBufferCount >= 1);
    pContext->BytesSent += pwsaRecvBuffers->len;
    if ( dwRecvBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaRecvBuffers + 1;
              pWsaBuf <= (pwsaRecvBuffers + dwRecvBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    switch ( pBandwidthInfo->QueryStatus( AtqIoSendRecv ) )
    {
    case StatusAllowOperation:

        pBandwidthInfo->IncTotalAllowedRequests();

        fRes = I_AtqSendAndRecv( patqContext,
                                 pwsaSendBuffers,
                                 dwSendBufferCount,
                                 pwsaRecvBuffers,
                                 dwRecvBufferCount ) ||
                (GetLastError() == ERROR_IO_PENDING);

        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

        break;

    case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoSendRecv;
        pContext->arInfo.lpOverlapped = &pContext->Overlapped;
        pContext->arInfo.uop.opSendRecv.dwSendBufferCount = dwSendBufferCount;
        pContext->arInfo.uop.opSendRecv.dwRecvBufferCount = dwRecvBufferCount;

        if ( dwSendBufferCount == 1) {
            pContext->arInfo.uop.opSendRecv.sendbuf1.len = pwsaSendBuffers->len;
            pContext->arInfo.uop.opSendRecv.sendbuf1.buf = pwsaSendBuffers->buf;
            pContext->arInfo.uop.opSendRecv.pSendBufAll  = NULL;
        } else {

            DBG_ASSERT( dwSendBufferCount > 1);

            WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwSendBufferCount * sizeof (WSABUF));
            if ( NULL != pBuf) {
                pContext->arInfo.uop.opSendRecv.pSendBufAll = pBuf;
                CopyMemory( pBuf, pwsaSendBuffers,
                            dwSendBufferCount * sizeof(WSABUF));
            } else {
                return ( FALSE);
            }
        }

        if ( dwRecvBufferCount == 1) {
            pContext->arInfo.uop.opSendRecv.recvbuf1.len = pwsaRecvBuffers->len;
            pContext->arInfo.uop.opSendRecv.recvbuf1.buf = pwsaRecvBuffers->buf;
            pContext->arInfo.uop.opSendRecv.pRecvBufAll = NULL;
        } else {

            DBG_ASSERT( dwRecvBufferCount > 1);

            WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwRecvBufferCount * sizeof (WSABUF));
            if ( NULL != pBuf) {
                pContext->arInfo.uop.opSendRecv.pRecvBufAll = pBuf;
                CopyMemory( pBuf, pwsaRecvBuffers,
                            dwRecvBufferCount * sizeof(WSABUF));
            } else {
                return ( FALSE);
            }
        }

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext);
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

    default:
        ATQ_ASSERT( FALSE);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;

    } // switch()

    return fRes;
} // AtqSendAndRecv()




//
//  Short routine to enable the LoadDriverPrivilege for loading spud.sys
//

VOID EnableLoadDriverPrivilege(
    VOID
    )
{
    HANDLE ProcessHandle;
    HANDLE TokenHandle;
    BOOL Result;
    LUID LoadDriverValue;
    TOKEN_PRIVILEGES * TokenPrivileges;
    CHAR buf[ 5 * sizeof(TOKEN_PRIVILEGES) ];

    ProcessHandle = OpenProcess(
                        PROCESS_QUERY_INFORMATION,
                        FALSE,
                        GetCurrentProcessId()
                        );

    if ( ProcessHandle == NULL ) {

        //
        // This should not happen
        //

        goto Cleanup;
    }


    Result = OpenProcessToken (
                 ProcessHandle,
                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                 &TokenHandle
                 );

    if ( !Result ) {

        //
        // This should not happen
        //

        goto Cleanup;

    }

    //
    // Find out the value of LoadDriverPrivilege
    //


    Result = LookupPrivilegeValue(
                 NULL,
                 "SeLoadDriverPrivilege",
                 &LoadDriverValue
                 );

    if ( !Result ) {

        goto Cleanup;
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges = (TOKEN_PRIVILEGES *) buf;

    TokenPrivileges->PrivilegeCount = 1;
    TokenPrivileges->Privileges[0].Luid = LoadDriverValue;
    TokenPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    (VOID) AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                TokenPrivileges,
                sizeof(buf),
                NULL,
                NULL
                );
Cleanup:

    if ( TokenHandle )
    {
        CloseHandle( TokenHandle );
    }

    if ( ProcessHandle )
    {
        CloseHandle( ProcessHandle );
    }
}

HANDLE
AtqCreateFile(
    LPCSTR lpAFileName,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwFlagsAndAttributes,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR sd,
    ULONG Length,
    PULONG LengthNeeded,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
    )
{

    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    LPCWSTR lpFileName;

    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    ULONG CreateFlags;
    DWORD SQOSFlags;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    POPLOCK_INFO pOplock;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    g_pfnRtlInitAnsiString(&AnsiString,lpAFileName);
    Status = g_pfnRtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            SetLastError(g_pfnRtlNtStatusToDosError(Status));
            }
        return INVALID_HANDLE_VALUE;
        }

    lpFileName = Unicode->Buffer;


    CreateFlags = 0;

    TranslationStatus = g_pfnRtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS ? 0 : OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );


    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle ) {
            Obja.Attributes |= OBJ_INHERIT;
            }
        }

    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING ? FILE_NO_INTERMEDIATE_BUFFERING : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_SEQUENTIAL_SCAN ? FILE_SEQUENTIAL_ONLY : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_RANDOM_ACCESS ? FILE_RANDOM_ACCESS : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS ? FILE_OPEN_FOR_BACKUP_INTENT : 0 );

    if ( pfnOplockCompletion != NULL ) {
        pOplock = (POPLOCK_INFO)
        ::LocalAlloc( LPTR, sizeof(OPLOCK_INFO));
        if ( pOplock ) {
            pOplock->pfnOplockCompletion = pfnOplockCompletion;
            pOplock->Context = Context;
        }
    } else {
        pOplock = NULL;
    }

    Status = SPUDCreateFile(
                &Handle,
                &Obja,
                &IoStatusBlock,
                dwFlagsAndAttributes & (FILE_ATTRIBUTE_VALID_FLAGS & ~FILE_ATTRIBUTE_DIRECTORY),
                dwShareMode,
                CreateFlags,
                si,
                sd,
                Length,
                LengthNeeded,
                pOplock
                );

    g_pfnRtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ||
             Status == STATUS_OPLOCK_NOT_GRANTED ) {
             SetLastError(ERROR_INVALID_ACCESS);
             return Handle;
        }
        if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {
            SetLastError(ERROR_ACCESS_DENIED);
        } else {
            SetLastError(g_pfnRtlNtStatusToDosError(Status));
        }
        return INVALID_HANDLE_VALUE;
    }

    SetLastError(ERROR_SUCCESS);
    return Handle;

}

HANDLE
AtqCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwFlagsAndAttributes,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR sd,
    ULONG Length,
    PULONG LengthNeeded,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
    )
{

    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    ULONG CreateFlags;
    DWORD SQOSFlags;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    POPLOCK_INFO pOplock;

    CreateFlags = 0;

//    DbgPrint("AtqCreateFileW - %ws\n", lpFileName );

    TranslationStatus = g_pfnRtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS ? 0 : OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );


    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle ) {
            Obja.Attributes |= OBJ_INHERIT;
            }
        }

    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING ? FILE_NO_INTERMEDIATE_BUFFERING : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_SEQUENTIAL_SCAN ? FILE_SEQUENTIAL_ONLY : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_RANDOM_ACCESS ? FILE_RANDOM_ACCESS : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS ? FILE_OPEN_FOR_BACKUP_INTENT : 0 );

    if ( pfnOplockCompletion != NULL ) {
        pOplock = (POPLOCK_INFO)
        ::LocalAlloc( LPTR, sizeof(OPLOCK_INFO));
        if ( pOplock ) {
            pOplock->pfnOplockCompletion = pfnOplockCompletion;
            pOplock->Context = Context;
        }
    } else {
        pOplock = NULL;
    }

    Status = SPUDCreateFile(
                &Handle,
                &Obja,
                &IoStatusBlock,
                dwFlagsAndAttributes & (FILE_ATTRIBUTE_VALID_FLAGS & ~FILE_ATTRIBUTE_DIRECTORY),
                dwShareMode,
                CreateFlags,
                si,
                sd,
                Length,
                LengthNeeded,
                pOplock
                );

    g_pfnRtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ||
             Status == STATUS_OPLOCK_NOT_GRANTED ) {
             SetLastError(ERROR_INVALID_ACCESS);
             return Handle;
        }
        if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {
            SetLastError(ERROR_ACCESS_DENIED);
        } else {
            SetLastError(g_pfnRtlNtStatusToDosError(Status));
        }
        return INVALID_HANDLE_VALUE;
    }

    SetLastError(ERROR_SUCCESS);
    return Handle;

}

BOOL
AtqOplockAcknowledge(
    IN HANDLE   FileHandle,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
)
{
    POPLOCK_INFO pOplock;
    NTSTATUS Status;

    if ( pfnOplockCompletion != NULL ) {
        pOplock = (POPLOCK_INFO)
        ::LocalAlloc( LPTR, sizeof(OPLOCK_INFO));
        if ( pOplock ) {
            pOplock->pfnOplockCompletion = pfnOplockCompletion;
            pOplock->Context = Context;
            Status = SPUDOplockAcknowledge(
                          FileHandle,
                          pOplock
                          );

            if ( Status == STATUS_SUCCESS ) {
                return TRUE;
            }

        }
    }
    return FALSE;

}

BOOL
AtqSpudInitialized(
    VOID
    )
{
    return g_fUseDriver;
}


BOOL
I_AtqStartOplockThread(
    VOID
    )
{

    //
    // Sanity check.
    //

    ATQ_ASSERT( g_fUseDriver );
    ATQ_ASSERT( g_hOplockCompPort != NULL );
    ATQ_ASSERT( g_hOplockThread == NULL );

    //
    // Create the thread. This thread will receive all oplock break
    // notifications from SPUD.
    //

    g_hOplockThread = CreateThread(
                          NULL,                 // lpThreadAttributes
                          0,                    // dwStackSize
                          &I_AtqOplockThread,   // lpStartAddress,
                          NULL,                 // lpParameter
                          0,                    // dwCreationFlags
                          NULL                  // lpThreadId
                          );

    if( g_hOplockThread == NULL ) {
        return FALSE;
    }

    return TRUE;

}   // I_AtqStartOplockThread


VOID
I_AtqKillOplockThread(
    VOID
    )
{

    BOOL result;

    //
    // Sanity check.
    //

    ATQ_ASSERT( g_fUseDriver );
    ATQ_ASSERT( g_hOplockCompPort != NULL );
    ATQ_ASSERT( g_hOplockThread != NULL );

    //
    // Post a special "kill yourself" notification to the oplock thread.
    //

    result = g_pfnPostCompletionStatus(
                 g_hOplockCompPort,
                 0,
                 0,
                 KILL_OPLOCK_THREAD
                 );

    if( result ) {

        //
        // Wait for the thread to die.
        //

        WaitForSingleObject( g_hOplockThread, INFINITE );

        CloseHandle( g_hOplockThread );
        g_hOplockThread = NULL;

    } else {
        ATQ_ASSERT( !"PostCompletionStatus() failed" );
    }

}   // I_AtqKillOplockThread


DWORD
WINAPI
I_AtqOplockThread(
    IN LPVOID Param
    )
{

    BOOL result;
    DWORD oplockStatus;
    LPOVERLAPPED overlapped;
    POPLOCK_INFO oplockInfo;
    OPLOCK_INFO capturedInfo;

    //
    // Sanity check.
    //

    ATQ_ASSERT( g_fUseDriver );
    ATQ_ASSERT( g_hOplockCompPort != NULL );
    ATQ_ASSERT( g_hOplockThread != NULL );

    //
    // Spin forever, or at least until we're shut down.
    //

    while( TRUE ) {

        //
        // Get the next entry from the queue.
        //

        result = g_pfnGetQueuedCompletionStatus(
                     g_hOplockCompPort,
                     &oplockStatus,
                     (LPDWORD)&oplockInfo,
                     &overlapped,
                     INFINITE
                     );

        if( result ) {

            //
            // Check for the special "kill yourself" notification.
            //

            if( overlapped == KILL_OPLOCK_THREAD ) {
                break;
            }

            //
            // Validate the return values.
            //

            ATQ_ASSERT( overlapped == NULL );
            ATQ_ASSERT( oplockInfo != NULL );
            ATQ_ASSERT( oplockStatus == OPLOCK_BREAK_NO_OPLOCK ||
                        oplockStatus == OPLOCK_BREAK_OPEN ||
                        oplockStatus == OPLOCK_BREAK_CLOSE );

            //
            // Capture the oplock info, then free the structure.
            //

            capturedInfo = *oplockInfo;
            LocalFree( oplockInfo );

            //
            // Call the oplock completion routine as specified in the
            // returned info structure.
            //

            (capturedInfo.pfnOplockCompletion)(
                capturedInfo.Context,
                oplockStatus
                );

        } else {

            //
            // GetQueuedCompletionStatus() failed. Bail.
            //

            DBGPRINTF((
                DBG_CONTEXT,
                "I_AtqOplockThread: GetQueuedCompletionStatus() failed, error %lu\n",
                GetLastError()
                ));

            ATQ_ASSERT( !"GetQueuedCompletionStatus() failed" );
            break;

        }

    }

    return 0;

}   // I_AtqOplockThread
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\auxctrs.h ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       auxctrs.h

   Abstract:
       This module defines the auxiliary counters for Internet Common Services.

   Author:

       Murali R. Krishnan    ( MuraliK )    02-Apr-1996

   Environment:

       Windows NT - User Mode

   Project:

       Internet Services Common DLL

   Revision History:

--*/

# ifndef _IIS_CACHE_COUNTERS_HXX_
# define _IIS_CACHE_COUNTERS_HXX_

/************************************************************
 *     Include Headers
 ************************************************************/


/************************************************************
 *   Symbolic Definitions
 ************************************************************/

/*++
  Counters belong to two categories
  1. Active Counter - one that counts up and down
      It is expected that this counter consists of the current
      active items and hence this should not be wildly high, unless
      there are large # of counted objects.

  2. Cumulative Counters - counts values up and up
      This count value is used to measure the # of times event(s)
      related to this counter occurred.

  Naming Conventions:
   prefixes used are: Aac & Cac
   Aac - Active Auxiliary Counter
   Cac - Cumulative Auxiliary Counter
   Ac  - Auxiliar Counter

--*/

typedef enum  {   // Ac - stands for Aux Counters.

    AacOpenURIFiles = 0,
    CacOpenURI,
    CacCloseURI,

    AacIISCacheMaxCounters                // sentinel counter
} ENUM_IIS_CACHE_COUNTER;



#ifdef IIS_AUX_COUNTERS

# define NUM_AUX_COUNTERS    (AacIISCacheMaxCounters)

extern LONG g_IISCacheAuxCounters[];

# define VAR_AUX_COUNTER     (g_IISCacheAuxCounters)

//
// Macros for operating on these counters
//

# define AcIncrement( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ?  \
  InterlockedIncrement( (VAR_AUX_COUNTER) + (acCounter)) : \
  0)

# define AcDecrement( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ?  \
  InterlockedDecrement( (VAR_AUX_COUNTER) + (acCounter)) : \
  0)

# define AcCounter( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ? (VAR_AUX_COUNTER)[acCounter] : 0)



# else // IIS_AUX_COUNTERS

# define NUM_AUX_COUNTERS              (0)

# define VAR_AUX_COUNTER               /* nothing */

# define AcIncrement( acCounter)       (0)    /* do nothing */
# define AcDecrement( acCounter)       (0)    /* do nothing */
# define AcCounter( acCounter)         (0)    /* do nothing */

#endif // IIS_AUX_COUNTERS


# endif // _IIS_CACHE_COUNTERS_HXX_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\atq\oplock\atqxmit.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       atqxmit.cxx

   Abstract:

        Contains internal support routines for transmit file

   Author:
        Johnson Apacible     (johnsona)      26-Mar-1996

--*/

#include "isatq.hxx"
#include "atqcport.hxx"

//
// local
//

VOID
I_FakeTransmitFileCompletion(
            IN PVOID ClientContext,
            IN DWORD BytesWritten,
            IN DWORD CompletionStatus,
            IN OVERLAPPED * lpo
            );



VOID
I_CleanupFakeTransmitFile(
        IN PATQ_CONT pAtqContext
        )
{
    //
    // Put the old completion routine back and free allocated buffers
    //

    pAtqContext->arInfo.uop.opFakeXmit.CurrentState = ATQ_XMIT_NONE;

    pAtqContext->pfnCompletion = pAtqContext->arInfo.uop.opFakeXmit.pfnCompletion;
    pAtqContext->ClientContext = pAtqContext->arInfo.uop.opFakeXmit.ClientContext;

    if ( pAtqContext->arInfo.uop.opFakeXmit.pBuffer != NULL ) {
        LocalFree(pAtqContext->arInfo.uop.opFakeXmit.pBuffer);
        pAtqContext->arInfo.uop.opFakeXmit.pBuffer = NULL;
    }

    return;

} // I_CleanupFakeTransmitFile


BOOL
SIOTransmitFile(
    IN PATQ_CONT                pAtqContext,
    IN HANDLE                   hFile,
    IN DWORD                    dwBytesInFile,
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers
    )
/*++

Routine Description:

    Posts a completion status on the completion port queue

    An IO pending error code is treated as a success error code

Arguments:

    patqContext - pointer to ATQ context
    hFile - Handle to the file to be read.
    dwBytesInFile - Number of bytes to read in the file
    lpTransmitBuffers - the transmitfile structure

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{

    DWORD   nRead   = 0;
    DWORD   cBuffer = 0;

    ATQ_ASSERT( pAtqContext->m_pBandwidthInfo != NULL );

    pAtqContext->m_pBandwidthInfo->IncTotalAllowedRequests();

    //
    // Store data
    //

    pAtqContext->pvBuff = NULL;

    pAtqContext->arInfo.atqOp        = AtqIoXmitFile;
    pAtqContext->arInfo.lpOverlapped = &pAtqContext->Overlapped;
    pAtqContext->arInfo.uop.opFakeXmit.hFile = hFile;

    if( lpTransmitBuffers != NULL ) {

        CopyMemory(
                &pAtqContext->arInfo.uop.opFakeXmit.TransmitBuffers,
                lpTransmitBuffers,
                sizeof(TRANSMIT_FILE_BUFFERS)
                );
    } else {

        ZeroMemory(
            &pAtqContext->arInfo.uop.opFakeXmit.TransmitBuffers,
            sizeof(pAtqContext->arInfo.uop.opFakeXmit.TransmitBuffers)
            );
    }

    pAtqContext->arInfo.uop.opFakeXmit.CurrentState  = ATQ_XMIT_START;

    //
    // Set current file offset to requested
    //

    pAtqContext->arInfo.uop.opFakeXmit.FileOffset =
                            pAtqContext->Overlapped.Offset;

    pAtqContext->arInfo.dwLastIOError = NOERROR;

    pAtqContext->arInfo.uop.opFakeXmit.pBuffer = NULL;
    pAtqContext->arInfo.uop.opFakeXmit.hFile = hFile;
    pAtqContext->arInfo.uop.opFakeXmit.BytesWritten = 0;
    pAtqContext->arInfo.uop.opFakeXmit.pBuffer = NULL;
    pAtqContext->arInfo.uop.opFakeXmit.pvLastSent = NULL;

    //
    // Check the number of bytes from file to send
    //

    if ( dwBytesInFile == 0 ) {

        //
        // Send the whole file.
        //

        dwBytesInFile = GetFileSize( hFile, NULL );

        if (dwBytesInFile >= pAtqContext->Overlapped.Offset) {
            dwBytesInFile -= pAtqContext->Overlapped.Offset;
        } else {
            ATQ_ASSERT(NULL);
            dwBytesInFile = 0;
        }
    }

    pAtqContext->arInfo.uop.opFakeXmit.BytesLeft = dwBytesInFile;

    //
    // replace the completion function with our own
    //

    pAtqContext->arInfo.uop.opFakeXmit.pfnCompletion =
                                pAtqContext->pfnCompletion;

    pAtqContext->arInfo.uop.opFakeXmit.ClientContext =
                                pAtqContext->ClientContext ;

    pAtqContext->ClientContext = pAtqContext;

    pAtqContext->pfnCompletion = I_FakeTransmitFileCompletion;

    //
    // Set the timeout
    //

    I_SetNextTimeout(pAtqContext);

    //
    // Kick in transmission loop
    //

    I_FakeTransmitFileCompletion(pAtqContext,
                                 0,
                                 NO_ERROR,
                                 &pAtqContext->Overlapped
                                 );

    SetLastError(NO_ERROR);
    return(TRUE);

} // SIOTransmitFile



VOID
I_FakeTransmitFileCompletion(
            IN PVOID ClientContext,
            IN DWORD BytesWritten,
            IN DWORD CompletionStatus,
            IN OVERLAPPED * lpo
            )
{
    PATQ_CONT   pAtqContext = (PATQ_CONT)ClientContext;
    DWORD       nWrite = 0;
    INT         err = NOERROR;
    OVERLAPPED  ov;
    OVERLAPPED  *pov = &ov;

    LPVOID      lpBufferSend;
    BOOL        fRes;

    //
    // We need to use saved context value because of reasons above
    //

    ATQ_ASSERT(pAtqContext != NULL);

    pAtqContext->arInfo.uop.opFakeXmit.BytesWritten += BytesWritten;

    if ( CompletionStatus != NO_ERROR ) {

        //
        // An error occured, call the completion routine
        //

        pAtqContext->arInfo.dwLastIOError = CompletionStatus;
        goto call_completion;
    }

    //
    // Calculate pointer and number of bytes to send , depending on
    // the current state of transmission
    //

    if (pAtqContext->arInfo.uop.opFakeXmit.CurrentState == ATQ_XMIT_START) {

        //
        // We are just starting transmission, check if there is any
        // header part to send
        //

        nWrite = pAtqContext->arInfo.uop.opFakeXmit.TransmitBuffers.HeadLength;
        pAtqContext->arInfo.uop.opFakeXmit.CurrentState = ATQ_XMIT_HEADR_SENT;
        lpBufferSend =  pAtqContext->arInfo.uop.opFakeXmit.TransmitBuffers.Head;

        if ( (nWrite != 0) && (lpBufferSend != NULL) ) {
            goto AtqXmitSendData;
        }
    }

    if (pAtqContext->arInfo.uop.opFakeXmit.CurrentState == ATQ_XMIT_HEADR_SENT) {

        //
        // Clear written bytes counter, as this is very first iteration
        //

        BytesWritten = 0;

        //
        // Check if the file was zero lenth ?
        // Check if we have temporary transmission buffer
        //

        if (pAtqContext->arInfo.uop.opFakeXmit.pBuffer == NULL) {
            pAtqContext->arInfo.uop.opFakeXmit.pBuffer =
                            (PCHAR)LocalAlloc(LPTR, g_cbXmitBufferSize);
        }

        //
        // Set starting offset for the opened file
        //

        SetFilePointer(
                pAtqContext->arInfo.uop.opFakeXmit.hFile,
                pAtqContext->arInfo.uop.opFakeXmit.FileOffset,
                NULL,
                FILE_BEGIN
                );

        pAtqContext->arInfo.uop.opFakeXmit.CurrentState =
                                    ATQ_XMIT_TRANSMITTING_FILE;
    }

    if (pAtqContext->arInfo.uop.opFakeXmit.CurrentState ==
                                    ATQ_XMIT_TRANSMITTING_FILE) {

        //
        // We are  sending file itself - do we have anything left to do ?
        //

        if (pAtqContext->arInfo.uop.opFakeXmit.BytesLeft != 0) {

            //
            // Calculate offset for the next read .
            // This would be previous offset plus number of
            // bytes written on last operation.
            //

            pAtqContext->arInfo.uop.opFakeXmit.FileOffset += BytesWritten;

            if (pAtqContext->arInfo.uop.opFakeXmit.pBuffer != NULL) {

                //
                // Read file from current offset
                //

                DWORD   nToRead = g_cbXmitBufferSize;
                nToRead = min(
                            g_cbXmitBufferSize,
                            pAtqContext->arInfo.uop.opFakeXmit.BytesLeft);

                nWrite = 0;

                fRes = ReadFile(pAtqContext->arInfo.uop.opFakeXmit.hFile,
                                 pAtqContext->arInfo.uop.opFakeXmit.pBuffer,
                                 nToRead,
                                 &nWrite,
                                 NULL);

                if ( !fRes ) {
                    ATQ_PRINTF((DBG_CONTEXT,
                        "Error %d in ReadFile\n", GetLastError()));
                }

                if (pAtqContext->arInfo.uop.opFakeXmit.BytesLeft >= nWrite) {

                    pAtqContext->arInfo.uop.opFakeXmit.BytesLeft -= nWrite;
                } else {

                    pAtqContext->arInfo.uop.opFakeXmit.BytesLeft = 0;
                }

                IF_DEBUG(SIO) {
                    ATQ_PRINTF((DBG_CONTEXT,
                    "[TransmitFile(%lu)] Got data from file: context=%x Offset=%x nWrite=%x  fRes=%d \n",
                        GetCurrentThreadId(),pAtqContext,
                        pAtqContext->arInfo.uop.opFakeXmit.FileOffset,
                        nWrite,fRes));
                }

                //
                // Read succeeded and we got the data - send it to the client
                //

                if (fRes && (nWrite != 0) ) {
                    lpBufferSend = pAtqContext->arInfo.uop.opFakeXmit.pBuffer;
                    goto AtqXmitSendData;
                }

                //
                // If ReadFile failed - get error code and analyze it
                //

                if (!fRes) {

                    pAtqContext->arInfo.dwLastIOError = GetLastError();

                    //
                    // If we really shipped the whole file and error is EOF - ignore it
                    //

                    if ((pAtqContext->arInfo.dwLastIOError == ERROR_HANDLE_EOF) &&
                        (!pAtqContext->arInfo.uop.opFakeXmit.BytesLeft)) {

                        pAtqContext->arInfo.dwLastIOError == NO_ERROR;
                        fRes = TRUE;
                    }
                } else {

                    //
                    // If by some reasons we did not send all data planned we need
                    // to report failure, causing close for socket. Otherwise client will wait
                    // for the rest of the data and we will wait for client read
                    // Nb: In some cases Read returns success but does not really get any data
                    // we will treat this as premature EOF
                    //

                    if (pAtqContext->arInfo.uop.opFakeXmit.BytesLeft != 0) {
                        pAtqContext->arInfo.dwLastIOError = ERROR_HANDLE_EOF;
                        fRes = FALSE;
                    }
                }

            } else {

                //
                // Buffer was not allocated - fail transmission
                //

                ATQ_PRINTF((DBG_CONTEXT,"Failed to allocate buffer\n"));
                pAtqContext->arInfo.dwLastIOError = ERROR_NOT_ENOUGH_MEMORY;
            }

            //
            // Failed read from file, terminate transmission
            //

            if (!fRes) {

                //
                // Abnormal termination of Read - reset the client socket
                // BUGBUG Is TransmitFile doing this on NT ?
                //

                ATQ_PRINTF((DBG_CONTEXT,"Read failed. Shutdown called\n"));
                shutdown( (int) pAtqContext->hAsyncIO, 1 );

                goto call_completion;
            }

        }

        //
        // Free temporary buffer as we no longer need it
        //

        if (pAtqContext->arInfo.uop.opFakeXmit.pBuffer) {
            LocalFree(pAtqContext->arInfo.uop.opFakeXmit.pBuffer);
            pAtqContext->arInfo.uop.opFakeXmit.pBuffer = NULL;
        }

        //
        // We are finished with this file
        //

        pAtqContext->arInfo.uop.opFakeXmit.CurrentState = ATQ_XMIT_FILE_DONE;
    }

    if (pAtqContext->arInfo.uop.opFakeXmit.CurrentState == ATQ_XMIT_FILE_DONE) {

        //
        // Check if there is any tail part to send
        //

        pAtqContext->arInfo.uop.opFakeXmit.CurrentState = ATQ_XMIT_TAIL_SENT;

        nWrite = pAtqContext->arInfo.uop.opFakeXmit.TransmitBuffers.TailLength;
        lpBufferSend =  pAtqContext->arInfo.uop.opFakeXmit.TransmitBuffers.Tail;
    }

AtqXmitSendData:

    //
    // If we have something to send - start i/o operation
    //

    if ( (nWrite != 0) && (lpBufferSend != NULL) ) {

        pAtqContext->arInfo.atqOp = AtqIoXmitFile;

        pAtqContext->arInfo.uop.opFakeXmit.pvLastSent = lpBufferSend;
        pAtqContext->arInfo.uop.opFakeXmit.cbBuffer = nWrite;

        InterlockedIncrement( &pAtqContext->m_nIO);
        SIOStartAsyncOperation(g_hIoCompPort,(PATQ_CONTEXT)pAtqContext);
        return ;
    }

    //
    // If it was the last phase of transmission -
    // clean up and send successful notification
    //

    if (pAtqContext->arInfo.uop.opFakeXmit.CurrentState != ATQ_XMIT_TAIL_SENT) {

    }

    pAtqContext->arInfo.dwLastIOError = NOERROR;

call_completion:

    //
    // Indicate no transmission in progress
    //

    pAtqContext->arInfo.uop.opFakeXmit.CurrentState = ATQ_XMIT_NONE;

    I_CleanupFakeTransmitFile(pAtqContext);

    pAtqContext->arInfo.dwTotalBytesTransferred =
                pAtqContext->arInfo.uop.opFakeXmit.BytesWritten;

    //
    // Clean up SIO state
    //

    pAtqContext->dwSIOFlags &= ~ATQ_SIO_FLAG_STATE_MASK;

    //
    // Queue context as completed
    //

    SIOPostCompletionStatus(g_hIoCompPort,
                            pAtqContext->arInfo.uop.opFakeXmit.BytesWritten,
                            (DWORD)pAtqContext,
                            pAtqContext->arInfo.lpOverlapped);

    return ;

} // I_FakeTransmitFileCompletion
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\cachep.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        cachep.cxx

   Abstract:
        This module contains the internal tsunami caching routines

   Author:
        Murali R. Krishnan    ( MuraliK )     16-Jan-1995

--*/

#include "TsunamiP.Hxx"
#pragma hdrstop

// specifies how many characters we will use for hashing string names
# define g_dwFastHashLength  (16)

HASH_TYPE
CalculateHashAndLengthOfPathName(
    LPCSTR pszPathName,
    PULONG pcbLength
    )
{
    HASH_TYPE hash = 0;
    CHAR      ch;

    DWORD     start;
    DWORD     index;

    ASSERT( pszPathName != NULL );
    ASSERT( pcbLength != NULL );

    *pcbLength = strlen(pszPathName);

    //
    // hash the last g_dwFastHashLength characters
    //

    if ( *pcbLength < g_dwFastHashLength ) {
        start = 0;
    } else {
        start = *pcbLength - g_dwFastHashLength;
    }

    for ( index = start; pszPathName[index] != '\0'; index++ ) {

        //
        // This is an extremely slimey way of getting upper case.
        // Kids, don't try this at home
        // -johnson
        //

        ch = pszPathName[index] & (CHAR)~0x20;

        hash <<= 1;
        hash ^= ch;
        hash <<= 1;
        hash += ch;
    }

    //
    // Multiply by length.  Murali said so.
    //

    return( hash * *pcbLength);

} // CalculateHashAndLengthOfPathName



BOOL
DeCache(
    PCACHE_OBJECT pCacheObject,
    BOOL          fLockCacheTable
    )
/*++
    Description:

        This function removes this cache object from any list it may be on.

        The cache table lock must be taken if fLockCacheTable is FALSE.

    Arguments:

        pCacheObject - Object to decache
        fLockCacheTable - FALSE if the cache table lock has already been taken

--*/
{
    ASSERT( pCacheObject->Signature == CACHE_OBJ_SIGNATURE );
    TSUNAMI_TRACE( TRACE_CACHE_DECACHE, pCacheObject );

    //
    //  Already decached if not on any cache lists
    //

    if ( !RemoveCacheObjFromLists( pCacheObject, fLockCacheTable ) )
    {
        return TRUE;
    }

    //
    //  This undoes the initial reference.  The last person to check in this
    //  cache object will cause it to be deleted after this point.
    //

    TsDereferenceCacheObj( pCacheObject, fLockCacheTable );

    return( TRUE );
}

BOOL
TsDeCacheCachedBlob(
    PVOID   pBlobPayload
    )
/*++
    Description:

        This function removes a blob payload object from the cache

    Arguments:

        pCacheObject - Object to decache

--*/
{
    return DeCache( (((PBLOB_HEADER)pBlobPayload)-1)->pCache, TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\alloc.cxx ===
#include "TsunamiP.Hxx"
#pragma hdrstop


BOOL
TsAllocate(
    IN const TSVC_CACHE &TSvcCache,
    IN      ULONG           cbSize,
    IN OUT  PVOID *         ppvNewBlock
    )
{
    return( TsAllocateEx(  TSvcCache,
                           cbSize,
                           ppvNewBlock,
                           NULL ) );
} // TsAllocate

BOOL
TsAllocateEx(
    IN const TSVC_CACHE &TSvcCache,
    IN      ULONG           cbSize,
    IN OUT  PVOID *         ppvNewBlock,
    OPTIONAL PUSER_FREE_ROUTINE pfnFreeRoutine
    )
/*++

  Routine Description:

      This function allocates a memory block for the calling server.

      The returned block is suitable for use as a parameter to
      TsCacheDirectoryBlob().  Blocks allocated by this function
      must either be cached or freed with TsFree().  Freeing of
      cached blocks will be handled by the cache manager.

  Arguments:

      pServiceInfo - An initialized SERVICE_INFO structure.

      cbSize       - Number of bytes to allocate.  (Must be strictly
                     greater than zero.)

      ppvNewBlock  - Address of a pointer to store the new block's
                     address in.

  Return Value:

      TRUE  - The allocation succeeded, and *ppvNewBlock points to
              at least cbSize accessable bytes.

      FALSE - The allocation failed.

--*/
{
    PBLOB_HEADER pbhNewBlock;

    ASSERT( cbSize > 0 );
    ASSERT( ppvNewBlock != NULL );

    //
    //  Set pbhNewBlock to NULL so that the exception-cleanup code
    //  can test against it to see if an allocation occurred before
    //  the exception.
    //

    pbhNewBlock = NULL;

    __try
    {
        //
        //  If asked to allocate zero bytes, we return FALSE and NULL,
        //  as if allocation failure had occurred.
        //

        if ( cbSize != 0 )
        {
            pbhNewBlock = ( PBLOB_HEADER )
                      ALLOC( cbSize + sizeof( BLOB_HEADER ) );

        }

        if ( pbhNewBlock != NULL )
        {
            //
            //  If the allocation succeeded, we return a pointer to the
            //  memory just following the BLOB_HEADER.
            //

            *ppvNewBlock = ( PVOID )( pbhNewBlock + 1 );

            //
            //  Set up the BLOB_HEADER: Normal flags and stored allocation
            //  size.
            //

            pbhNewBlock->IsCached        = FALSE;
            pbhNewBlock->pfnFreeRoutine  = pfnFreeRoutine;
            InitializeListHead( &pbhNewBlock->PFList );
        }
        else
        {
            //
            //  The allocation failed, and we need to return NULL
            //

            *ppvNewBlock = NULL;
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        //  An exception transpired.  The most likely causes are bogus input
        //  pointers for pServiceInfo and pbhNewBlock.  Whatever the case, we
        //  free up any memory that may have been allocated and return failure.
        //

        if ( pbhNewBlock != NULL )
        {

            FREE( pbhNewBlock );

            pbhNewBlock = NULL;
        }
    }

    //
    //  Return TRUE or FALSE, according to the result of the allocation.
    //

    if ( pbhNewBlock == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return( FALSE );
    }

    INC_COUNTER( TSvcCache.GetServiceId(),
                 CurrentObjects );

    return( TRUE );
} // TsAllocate

BOOL
TsReallocate(
    IN const TSVC_CACHE &TSvcCache,
    IN      ULONG           cbSize,
    IN      PVOID           pvOldBlock,
    IN OUT  PVOID *         ppvNewBlock
    )
/*++

  Routine Description:

    This function will resize a previously allocated memory Blob
    for the calling server, possibly moving it in the process.

  Arguments:

      pServiceInfo - An initialized SERVICE_INFO structure.

      cbSize       - Number of bytes to resize the block to.
                     (Must be strictly greater than zero.)

      pvOldBlock   - Address of a pointer to a previously-allocated
                     block.

      ppvNewBlock  - Address of a pointer to store the new block's
                     address in.  If the allocation fails, NULL is
                     stored here.  Note that in many cases,
                     pvOldBlock will be stored here.

  Return Value:

      TRUE  - The reallocation succeeded, and *ppvNewBlock points to
              at least cbSize accessable bytes.  pvOldBlock is no
              longer a valid pointer, if *ppvNewBlock!=pvOldBlock.

      FALSE - The allocation failed.  *ppvNewBlock = NULL.
              pvOldBlock is still a valid pointer to the block that
              we wished to resize.

--*/
{
    PBLOB_HEADER pbhNewBlock;
    PBLOB_HEADER pbhOldBlock;

    ASSERT( pvOldBlock != NULL );

    //
    //  Set pbhNewBlock to NULL so that the exception-cleanup code
    //  can test against it to see if an allocation occurred before
    //  the exception.
    //

    pbhNewBlock = NULL;

    __try
    {
        //
        //  Adjust the input pointer to refer to the BLOB_HEADER.
        //

        pbhOldBlock = (( PBLOB_HEADER )pvOldBlock ) - 1;

        //
        //  If the Blob is currently cached, we can't move it
        //  or change its size.  Check for this in the Blob's
        //  flags, and fail if it occurs.
        //

        if ( pbhOldBlock->IsCached )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "A service (%d) has attempted to TsRealloc a BLOB that is cached.",
                        TSvcCache.GetServiceId() ));
            BREAKPOINT();
            SetLastError( ERROR_INVALID_PARAMETER );
        }
        else
        {
            //
            //  The following assignment probes ppvNewBlock for writeability.
            //  Hopefully, this ensures that we get an AV from writing to it
            //  before we call REALLOC and potentially free the old block.
            //

            *ppvNewBlock = NULL;

            pbhNewBlock = ( PBLOB_HEADER )REALLOC( pbhOldBlock, cbSize );

            if ( pbhNewBlock != NULL )
            {
                //
                //  Store a pointer to the caller-usable part of the new Blob in
                //  the output parameter.
                //

                *ppvNewBlock = ( PVOID )( pbhNewBlock + 1 );
            }
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        //  An exception occured.  If this was caught after a block was
        //  allocated, we must free the new block.  Unfortunately, this
        //  means that we may end up returning FALSE in a case where
        //  pbhOldBlock is no longer valid.
        //
        //  if ( pbhOldBlock == pbhNewBlock ), which implies the old
        //  pointer is still valid, we do not free the new block, but
        //  hope that the caller will.  In any other case, we must
        //  free the new block to avoid a memory leak, and assume that
        //  TCPSVCs are going down soon...
        //
        //  ISSUE: It might be best to reflect the exception up to the
        //  caller, so they can handle it and bail out of the current
        //  operation.
        //

        if ( pbhNewBlock != NULL && pbhOldBlock != pbhNewBlock )
        {
            FREE( pbhNewBlock );

            pbhNewBlock = NULL;

            SetLastError( ERROR_INVALID_PARAMETER );
        }
    }

    //
    //  Return TRUE or FALSE, according to the result of the allocation.
    //

    if ( pbhNewBlock == NULL )
    {
        return( FALSE );
    }

    return( TRUE );
} // TsReallocate

BOOL
TsFree(
    IN const TSVC_CACHE &TSvcCache,
    IN      PVOID           pvOldBlock
    )
/*++

  Routine Description:

    This function frees a memory block allocated with TsAllocate().

    Blocks that are currently cached cannot be freed with this
    function.

  Arguments:

    pServiceInfo - An initialized SERVICE_INFO structure.

    pvOldBlock   - The address of the block to free.  (Must be
                   non-NULL.)

  Return Value:

    TRUE  - The block was freed.  The pointer pvOldBlock is no longer
            valid.

    FALSE - The block was not freed.  Possible reasons include:

             -  pvOldBlock does not point to a block allocated with
                TsAllocate().

             -  pvOldBlock points to a block that has been cached
                with CacheDirectoryBlob().

             -  pServiceInfo does not point to a valid SERVICE_INFO
                structure.

--*/
{
    BOOLEAN bSuccess;
    PBLOB_HEADER pbhOldBlock;

    ASSERT( pvOldBlock != NULL );

    __try
    {
        //
        //  Adjust the input pointer to refer to the BLOB_HEADER.
        //

        pbhOldBlock = (( PBLOB_HEADER )pvOldBlock ) - 1;

        if (!DisableSPUD) {
            EnterCriticalSection( &CacheTable.CriticalSection );
            if ( !IsListEmpty( &pbhOldBlock->PFList ) ) {
                RemoveEntryList( &pbhOldBlock->PFList );
            }
            LeaveCriticalSection( &CacheTable.CriticalSection );
        }

        //
        //  If the Blob is currently in the cache, we can't free it.
        //  Check for this in the Blob's flags, and fail if it
        //  occurs.
        //

        if ( pbhOldBlock->IsCached )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "A service (%d) has attempted to TsFree a BLOB that it put in the cache.",
                        TSvcCache.GetServiceId() ));
            BREAKPOINT();

            bSuccess = FALSE;
        }
        else
        {
            if ( pbhOldBlock->pfnFreeRoutine )
            {
                bSuccess = pbhOldBlock->pfnFreeRoutine( pvOldBlock );
            }
            else
            {
                bSuccess = TRUE;
            }

            if ( bSuccess )
            {
                //
                //  Free the memory used by the Blob.
                //

                bSuccess = !!FREE( pbhOldBlock );

                DEC_COUNTER( TSvcCache.GetServiceId(),
                             CurrentObjects );
            }

        }

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        //  Handle exception.  Obviously, it's time to return failure.
        //  It's hardly possible to get here after succefully freeing
        //  the block, so it's likely that an app will either:
        //     - not check the return value and leak some memory.
        //     - check the return value and try again, probably
        //       only to fail forever.
        //
        //  So, it is not advisable for callers to keep trying this
        //  call until it succeeds.
        //

        bSuccess = FALSE;
    }

    return( bSuccess );
} // TsFree


BOOL
TsCheckInOrFree(
    IN      PVOID           pvOldBlock
    )
/*++

  Routine Description:

    This function checks in a cached memory block or
    frees a non-cached memory block allocated with TsAllocate().

  Arguments:

    pServiceInfo - An initialized SERVICE_INFO structure.

    pvOldBlock   - The address of the block to free.  (Must be
                   non-NULL.)

  Return Value:

    TRUE  - The block was freed.  The pointer pvOldBlock is no longer
            valid.

    FALSE - The block was not freed.  Possible reasons include:

             -  pvOldBlock does not point to a block allocated with
                TsAllocate().

--*/
{
    BOOLEAN bSuccess;
    PBLOB_HEADER pbhOldBlock;

    ASSERT( pvOldBlock != NULL );

    __try
    {
        //
        //  Adjust the input pointer to refer to the BLOB_HEADER.
        //

        pbhOldBlock = (( PBLOB_HEADER )pvOldBlock ) - 1;

        if (!DisableSPUD) {
            EnterCriticalSection( &CacheTable.CriticalSection );
            if (!IsListEmpty( &pbhOldBlock->PFList ) ) {
                RemoveEntryList( &pbhOldBlock->PFList );
            }
            LeaveCriticalSection( &CacheTable.CriticalSection );
        }

        if (BLOB_IS_OR_WAS_CACHED(pvOldBlock)) {
            bSuccess = TsCheckInCachedBlob( pvOldBlock );
        } else {
            if ( pbhOldBlock->pfnFreeRoutine )
            {
                bSuccess = pbhOldBlock->pfnFreeRoutine( pvOldBlock );
            }
            else
            {
                bSuccess = TRUE;
            }

            if ( bSuccess )
            {
                //
                //  Free the memory used by the Blob.
                //

                bSuccess = !!FREE( pbhOldBlock );
            }
        }

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        //  Handle exception.  Obviously, it's time to return failure.
        //  It's hardly possible to get here after succefully freeing
        //  the block, so it's likely that an app will either:
        //     - not check the return value and leak some memory.
        //     - check the return value and try again, probably
        //       only to fail forever.
        //
        //  So, it is not advisable for callers to keep trying this
        //  call until it succeeds.
        //

        ASSERT(FALSE);
        bSuccess = FALSE;
    }

    return( bSuccess );
} // TsCheckInOrFree


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\dbgmacro.cxx ===
#include "TsunamiP.Hxx"
#pragma hdrstop
#include "DbgMacro.Hxx"

#ifdef DBG

VOID _AssertionFailed( PSTR pszExpression, PSTR pszFilename, ULONG LineNo )
{
    CHAR Message[ 1024 ];

    pszFilename = strrchr( pszFilename, '\\' ) + 1;

    sprintf( Message, "ASSERT(%s) failed.\n\nOccurred at %s line %d\n\nPress Ok to continue, Cancel to debug.", pszExpression, pszFilename, LineNo );

    if ( MessageBox( NULL, Message, "Assertion Failed:", MB_OKCANCEL | MB_ICONSTOP | MB_SETFOREGROUND ) != IDOK )
    {
        DebugBreak();
    }
}

#endif //DBG

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\creatflp.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        creatflp.cxx

   Abstract:
        This module contains internal create file caching routines.

   Author:
        ????

--*/

#include "TsunamiP.Hxx"
#pragma hdrstop

#include <ctype.h>

#include <iistypes.hxx>
#include <iisver.h>
#include <iiscnfg.h>
#include <imd.h>
#include <mb.hxx>

BOOL
DisposeOpenFileInfo(
    IN  PVOID   pvOldBlock
    )
/*++

    Routine Description

        Close open file handles

    Arguments

        pvOldBlock - pointer to the file information block.

    Returns

        TRUE if operation successful.

--*/
{
    LPTS_OPEN_FILE_INFO lpFileInfo;
    PVOID pvBlob;

    IF_DEBUG(OPLOCKS) {
        PBLOB_HEADER pbhBlob;
        PCACHE_OBJECT pCache;

        if (BLOB_IS_OR_WAS_CACHED( pvOldBlock ) ) {
            pbhBlob = (( PBLOB_HEADER )pvOldBlock ) - 1;
            pCache = pbhBlob->pCache;

            DBGPRINTF( (DBG_CONTEXT,"DisposeOpenFileInfo(%s) iDemux=%08lx, cache=%08lx, references=%d\n",
                pCache->szPath, pCache->iDemux, pCache, pCache->references ));
        }
    }

    lpFileInfo = (LPTS_OPEN_FILE_INFO ) pvOldBlock;
    pvBlob = ( PVOID )lpFileInfo->QueryPhysFileInfo();

#ifdef CHICAGO
    if (!(lpFileInfo->m_FileInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        TsCheckInOrFree( pvBlob );
    }
#else

    TsCheckInOrFree( pvBlob );

#endif

    //
    //  The item may never have been added to the cache, don't
    //  count it in this case
    //

    if ( BLOB_IS_OR_WAS_CACHED( pvOldBlock ) ) {

        if ( BLOB_IS_UNC( pvOldBlock )) {
            InterlockedDecrement( (LONG *) &cCachedUNCHandles );
        }
    }

    return( TRUE );
} // DisposeOpenFileInfo


BOOL
DisposePhysOpenFileInfo(
    IN  PVOID   pvOldBlock
    )
/*++

    Routine Description

        Close open file handles

    Arguments

        pvOldBlock - pointer to the file information block.

    Returns

        TRUE if operation successful.

--*/
{
    PPHYS_OPEN_FILE_INFO lpPhysFileInfo;
    BOOL bSuccess;
    LIST_ENTRY * pEntry;
    PBLOB_HEADER pbhBlob;
    BOOL fDeleted;


    IF_DEBUG(OPLOCKS) {

        PCACHE_OBJECT pCache;

        if (BLOB_IS_OR_WAS_CACHED( pvOldBlock ) ) {
            pbhBlob = (( PBLOB_HEADER )pvOldBlock ) - 1;
            pCache = pbhBlob->pCache;

        }

        DBGPRINTF( (DBG_CONTEXT,"DisposePhysOpenFileInfo(%08lx)\n", pvOldBlock ));
        DBGPRINTF( (DBG_CONTEXT,"DisposePhysOpenFileInfo(%s) iDemux=%08lx, cache=%08lx, references=%d\n",
            pCache->szPath, pCache->iDemux, pCache, pCache->references ));
    }

    lpPhysFileInfo = (PPHYS_OPEN_FILE_INFO ) pvOldBlock;
    ASSERT( lpPhysFileInfo->Signature == PHYS_OBJ_SIGNATURE );
    TSUNAMI_TRACE( TRACE_PHYS_DISPOSE, lpPhysFileInfo );

    if ( lpPhysFileInfo->abSecurityDescriptor != NULL ) {
        FREE( lpPhysFileInfo->abSecurityDescriptor );
    }

    if ( lpPhysFileInfo->hOpenFile != INVALID_HANDLE_VALUE ) {
        bSuccess = CloseHandle( lpPhysFileInfo->hOpenFile );
        ASSERT( bSuccess );
        lpPhysFileInfo->hOpenFile = INVALID_HANDLE_VALUE;

        if (BLOB_IS_OR_WAS_CACHED( pvOldBlock ))
        {
            DEC_COUNTER( BLOB_GET_SVC_ID( pvOldBlock ), CurrentOpenFileHandles );
        }
    }

    if (!DisableSPUD) {
        EnterCriticalSection( &CacheTable.CriticalSection );
        while ( !IsListEmpty( &lpPhysFileInfo->OpenReferenceList ) ) {
            pEntry = RemoveHeadList( &lpPhysFileInfo->OpenReferenceList );
            InitializeListHead( pEntry );
        }
        LeaveCriticalSection( &CacheTable.CriticalSection );
    }

#if 0
    if (BLOB_IS_OR_WAS_CACHED( pvOldBlock ) && lpPhysFileInfo->fDeleteOnClose ) {
        fDeleted = ::DeleteFile( pCache->szPath );
        ASSERT( fDeleted );
    }

    IF_DEBUG(OPLOCKS) {
        DBGPRINTF( (DBG_CONTEXT,"DisposePhysOpenFileInfo(%s) Deleted = %08lx\n",
            pCache->szPath, fDeleted ));
    }
#endif

    lpPhysFileInfo->Signature = PHYS_OBJ_SIGNATURE_X;
    return( TRUE );

} // DisposePhysOpenFileInfo



BOOL
TS_OPEN_FILE_INFO::SetHttpInfo(
    IN PSTR pszInfo,
    IN INT  InfoLength
    )
/*++

    Routine Description

        Set the "Last-Modified:" header field in the file structure.

    Arguments

        pszDate - pointer to the header value to save
        InfoLength - length of the header value to save

    Returns

        TRUE if information was cached,
        FALSE if not cached

--*/
{
    if ( !m_ETagIsWeak && InfoLength < sizeof(m_achHttpInfo)-1 ) {

        CopyMemory( m_achHttpInfo, pszInfo, InfoLength+1 );

        //
        // this MUST be set after updating the array,
        // as this is checked to know if the array content is valid.
        //

        m_cchHttpInfo = InfoLength;
        return TRUE;
    }

    return FALSE;
} // TS_OPEN_FILE_INFO::SetHttpInfo



BOOL
TS_OPEN_FILE_INFO::SetFileInfo(
    IN PPHYS_OPEN_FILE_INFO lpPhysFileInfo,
    IN HANDLE   hOpeningUser,
    IN BOOL     fAtRoot,
    IN DWORD    cbSecDescMaxCacheSize,
    IN DWORD    dwAttributes
    )
/*++

    Routine Description

        Gets the file information for a handle.

    Arguments

        hFile - Handle of the file to get information on.
        hOpeningUser - HANDLE of user opening the file
        fAtRoot - TRUE if this is the root directory
        cbSecDescMaxCacheSize - size of the memory allocated to
          cache the security descriptor for this file object
        dwAttributes - attributes of the file

    Returns

        TRUE if information was stored.
        FALSE otherwise.

--*/
{
    BOOL fReturn;
    FILETIME    ftNow;
    SYSTEMTIME  stNow;

    if ( lpPhysFileInfo == NULL) {

        SetLastError( ERROR_INVALID_PARAMETER);
        fReturn = FALSE;

    } else if ( lpPhysFileInfo->hOpenFile == BOGUS_WIN95_DIR_HANDLE) {

        ASSERT( lpPhysFileInfo->Signature == PHYS_OBJ_SIGNATURE );
        m_PhysFileInfo = lpPhysFileInfo;
        m_hOpeningUser = NULL;
        m_ETagIsWeak = TRUE;
        m_FileInfo.dwFileAttributes = dwAttributes;
        m_cchETag = 0;
        fReturn = TRUE;

    } else {

        MB      mb( (IMDCOM*) IIS_SERVICE::QueryMDObject()  );
        DWORD   dwChangeNumber;

        ASSERT( lpPhysFileInfo->Signature == PHYS_OBJ_SIGNATURE );
        ASSERT(dwAttributes == 0);

        m_PhysFileInfo = lpPhysFileInfo;
        m_hOpeningUser = hOpeningUser;
        m_ETagIsWeak = TRUE;


        fReturn  = GetFileInformationByHandle(
                                            m_PhysFileInfo->hOpenFile,
                                            &m_FileInfo
                                            );

        dwChangeNumber = 0;

        mb.GetSystemChangeNumber(&dwChangeNumber);

        m_cchETag = FORMAT_ETAG(m_achETag, m_FileInfo.ftLastWriteTime,
                                    dwChangeNumber);

        ::GetSystemTime(&stNow);

        if (::SystemTimeToFileTime((CONST SYSTEMTIME *)&stNow, &ftNow))
        {
            __int64 iNow, iFileTime;

            iNow = (__int64)*(__int64 UNALIGNED *)&ftNow;

            iFileTime =
                (__int64)*(__int64 UNALIGNED *)&m_FileInfo.ftLastWriteTime;

            if ((iNow - iFileTime) > STRONG_ETAG_DELTA )
            {
                m_ETagIsWeak = FALSE;
            }
        }

        *((__int64 UNALIGNED*)&m_CastratedLastWriteTime)
            = (*((__int64 UNALIGNED*)&m_FileInfo.ftLastWriteTime) / 10000000)
              * 10000000;

        //
        //  Turn off the hidden attribute if this is a root directory listing
        //  (root some times has the bit set for no apparent reason)
        //

        if ( fReturn && fAtRoot ) {
            m_FileInfo.dwFileAttributes &= ~FILE_ATTRIBUTE_HIDDEN;
        }
        m_PhysFileInfo->cbSecDescMaxSize = cbSecDescMaxCacheSize;

    }

    return ( fReturn);
} // TS_OPEN_FILE_INFO::SetFileInfo()


VOID
TS_OPEN_FILE_INFO::MakeStrongETag(
    VOID
    )
/*++

    Routine Description

        Try and make an ETag 'strong'. To do this we see if the difference
        between now and the last modified date is greater than our strong ETag
        delta - if so, we mark the ETag strong.

    Arguments

        None.

    Returns

        Nothing.

--*/
{
    FILETIME                    ftNow;
    SYSTEMTIME                  stNow;
    __int64                     iNow, iFileTime;

    if ( m_PhysFileInfo == NULL || m_PhysFileInfo->hOpenFile == INVALID_HANDLE_VALUE)
    {
        return;
    }

    ::GetSystemTime(&stNow);

    if (::SystemTimeToFileTime((CONST SYSTEMTIME *)&stNow, &ftNow))
    {

        iNow = (__int64)*(__int64 UNALIGNED *)&ftNow;

        iFileTime = (__int64)*(__int64 UNALIGNED *)&m_FileInfo.ftLastWriteTime;

        if ((iNow - iFileTime) > STRONG_ETAG_DELTA )
        {
            m_ETagIsWeak = FALSE;
        }
    }
}

#if DBG
VOID
TS_OPEN_FILE_INFO::Print( VOID) const
{
    char rgchDbg[300];

    wsprintf(rgchDbg,
             "TS_OPEN_FILE_INFO( %08x). FileHandle = %08x."
             " Opening User = %08x.\n",
             this,
             QueryFileHandle(),
             QueryOpeningUser()
             );

    OutputDebugString( rgchDbg);

    return;
} // TS_OPEN_FILE_INFO::Print()

#endif // DBG

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\cache.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        cache.cxx

   Abstract:
        This module contains the tsunami caching routines

   Author:
        Murali R. Krishnan    ( MuraliK )     16-Jan-1995

--*/

#include "TsunamiP.Hxx"
#pragma hdrstop
#include <mbstring.h>
#include <lonsi.hxx>
#include <dbgutil.h>

//
//  Items in a Bin list beyond this position will get moved to the front
//  on an object cache hit
//

#define  REORDER_LIST_THRESHOLD     5

//
//  Current count of cached file handles across a UNC connection
//

DWORD cCachedUNCHandles = 0;

//
// Enable caching of security descriptor & AccessCheck
//

BOOL g_fCacheSecDesc = TRUE;
BOOL g_fEnableCaching = TRUE;

BOOL
RemoveLruHandleCacheItem(
    VOID
    );

CACHE_TABLE CacheTable;

#if TSUNAMI_REF_DEBUG
PTRACE_LOG RefTraceLog;
#endif  // TSUNAMI_REF_DEBUG

BOOL
Cache_Initialize(
    IN DWORD MaxOpenFileInUse
    )
{
    int index;

    //
    // Initialize configuration block
    //

    ZeroMemory(&Configuration,sizeof( Configuration ));

    InitializeCriticalSection( &CacheTable.CriticalSection );
    SET_CRITICAL_SECTION_SPIN_COUNT( &CacheTable.CriticalSection,
                                          IIS_DEFAULT_CS_SPIN_COUNT);

    InitializeListHead( &CacheTable.MruList );

    CacheTable.OpenFileInUse = 0;
    CacheTable.MaxOpenFileInUse = MaxOpenFileInUse;

    for ( index=0; index<MAX_BINS; index++ ) {
        InitializeListHead( &CacheTable.Items[ index ] );
    }

    return( TRUE );
} // Cache_Initialize

BOOL
TsCacheDirectoryBlob(
    IN const TSVC_CACHE             &TSvcCache,
    IN      PCSTR                   pszDirectoryName,
    IN      ULONG                   iDemultiplexor,
    IN      PVOID                   pvBlob,
    IN      BOOLEAN                 bKeepCheckedOut,
    IN      PSECURITY_DESCRIPTOR    pSecDesc
    )
/*++

  Routine Description:

    This function associates the Blob given as input with the specified
    directory and demultiplexing number.  Services should use this
    function to add a Blob to the cache.

    Callers must not cache the same Blob twice.  Once a Blob is cached,
    its contents must not be modified, and it must not be freed or re-cached.

  Arguments

--*/
{
    CACHE_OBJECT *cache = NULL;
    PBLOB_HEADER  pbhBlob;
    BOOLEAN       bSuccess;
    ULONG         iBin;
    PLIST_ENTRY   pEntry;
    PCACHE_OBJECT pCache;
    PCHAR         pszTemp;
    HASH_TYPE     htHash;
    ULONG         cchLength;

    ASSERT( pszDirectoryName != NULL );
    ASSERT( pvBlob != NULL );

    IF_DEBUG( CACHE) {

        DBGPRINTF( (DBG_CONTEXT,
                    "TsCacheDirectoryBlob called with"
                    " Dir=%S, DeMux=%u, PvBlob=%08x, ChkedOut=%d\n",
                    pszDirectoryName,
                    iDemultiplexor,
                    pvBlob,
                    bKeepCheckedOut
                    ));
    }

    if ( g_fDisableCaching )
    {
        goto Cannot_Cache;
    }

    //
    //  The caller will have passed their pointer to the usable area of the
    //  Blob, so we have to adjust it to point to the beginning.
    //

    pbhBlob = (( PBLOB_HEADER )pvBlob ) - 1;

    ASSERT( !pbhBlob->IsCached );

    //
    //  Hash the directory name.
    //

    htHash = CalculateHashAndLengthOfPathName( pszDirectoryName,
                                                   &cchLength );


    //
    //  Allocate the cache object. We (effectively) allocate cchLength + 1
    //  bytes, to allow for the trailing NULL.
    //

    cache = (PCACHE_OBJECT)ALLOC( sizeof(CACHE_OBJECT) + cchLength);

    if ( cache == NULL ) {

        IF_DEBUG( CACHE) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "Unable to alloc Cache Object. Failure.\n"));
        }
        goto Cannot_Cache;
    }

    cache->Signature = CACHE_OBJ_SIGNATURE;

    cache->hash = htHash;
    cache->cchLength = cchLength;

    //
    //  Store the Blob in the new object.
    //

    cache->pbhBlob = pbhBlob;

    //
    //  Store the security descriptor in the new object.
    //

    cache->pSecDesc = pSecDesc;
    cache->hLastSuccessAccessToken = NULL;

    //
    //  We need to be able to find the cache entry from the Blob.
    //

    pbhBlob->pCache = cache;

    //
    //  Initialize the check-out count.
    //

    cache->references = ( bKeepCheckedOut) ? 2 : 1;
    cache->iDemux     = iDemultiplexor;
    cache->dwService  = TSvcCache.GetServiceId();
    cache->dwInstance = TSvcCache.GetInstanceId();
    cache->TTL        = 1;

    TSUNAMI_TRACE( cache->references, cache );

    IF_DEBUG(OPLOCKS) {
        DBGPRINTF( (DBG_CONTEXT,"TsCacheDirectoryBlob(%s) iDemux=%08lx, cache=%08lx, references=%d\n",
            pszDirectoryName, iDemultiplexor, cache, cache->references ));
    }

    InitializeListHead( &cache->DirChangeList );

    //
    //  Lock the cache table against changes.  We need to take the lock
    //  before we add the new object to the directory change death list,
    //  so that a directory change that kills this object will not find
    //  the cache table without the object present.
    //

    EnterCriticalSection( &CacheTable.CriticalSection );

    //
    //  Copy the directory name to the cache object.
    //

    memcpy( cache->szPath, pszDirectoryName, cache->cchLength + 1 );

    //
    //  Add the object to the directory change expiry list.
    //
    //  There's an ugly, disgusting hack here making this code aware
    //  of the structure of URI info, but it's better than going
    //  through everywhere and fixing the call to this routine to pass
    //  in the file path as well as the cache key name.
    //

    if (iDemultiplexor == RESERVED_DEMUX_URI_INFO)
    {
        PW3_URI_INFO    pURIInfo = (PW3_URI_INFO)pvBlob;

        pszTemp = pURIInfo->pszName;

    } else
    {
        pszTemp = (PCHAR)pszDirectoryName;
    }

    bSuccess = DcmAddNewItem(
                    (PIIS_SERVER_INSTANCE)TSvcCache.GetServerInstance(),
                    pszTemp,
                    cache
                    );

    if ( !bSuccess )
    {
        //
        //  For whatever reason, we cannot get notifications of changes
        //  in the directory containing the to-be-cached item.  We won't
        //  be adding this object to the cache table, so we unlock the
        //  table and jump to the failure-handling code.
        //

        LeaveCriticalSection( &CacheTable.CriticalSection );

        IF_DEBUG( CACHE) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " Unable to cache. Due to rejection by DirChngMgr\n"));
        }

        goto Cannot_Cache;
    }

    //
    //  Mark this blob as cached, since we'll either cache it or throw it
    //  away hereafter.
    //

    pbhBlob->IsCached = TRUE;

    //
    //  Add the object to the cache table, as the most-recently-used object.
    //

    iBin = HASH_TO_BIN( cache->hash );

    //
    //  Look for a previously cached object for the same directory.  If we
    //  find one, remove it.
    //

    for (   pEntry  = CacheTable.Items[ iBin ].Flink;
            pEntry != &CacheTable.Items[ iBin ];
            pEntry  = pEntry->Flink )
    {
        pCache = CONTAINING_RECORD( pEntry, CACHE_OBJECT, BinList );

        if ( pCache->cchLength == cache->cchLength &&
             pCache->hash      == cache->hash      &&
             pCache->iDemux    == cache->iDemux    &&
             pCache->dwService == cache->dwService &&
             pCache->dwInstance== cache->dwInstance &&
             !_memicmp( cache->szPath, pCache->szPath, cache->cchLength ) )
        {
            //
            //  We found a matching cache object.  We remove it, since it
            //  has been replaced by this new object.
            //

        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCacheDirectoryBlob - Decache(%s)\n", pCache->szPath ));
        }
            DeCache( pCache, FALSE );

            IF_DEBUG( CACHE) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Matching cache object found."
                            " Throwing that object ( %08x) out of cache\n",
                            pEntry));
            }

            break;
        }
    }

    //
    //  Add this object to the cache.
    //

    InsertHeadList( &CacheTable.Items[ iBin ], &cache->BinList );

    //
    //  Since this object was just added, put it at the head of the MRU list.
    //

    InsertHeadList( &CacheTable.MruList, &cache->MruList );

    //
    //  Increase the running size of cached objects by the size of the one
    //  just cached.
    //

    IF_DEBUG(OPLOCKS) {
        DBGPRINTF( (DBG_CONTEXT,"TsCacheDirectoryBlob(%s)\n",
            pszDirectoryName));
    }

    //
    // Limit number of open file entries in cache.
    // Note that in the current scenario pOpenFileInfo is set only after the URI_INFO
    // blob is inserted in cache, so TsCreateFileFromURI also has to check for
    // # of open file in cache.
    //

    if ( (iDemultiplexor == RESERVED_DEMUX_OPEN_FILE) ||
         (iDemultiplexor == RESERVED_DEMUX_URI_INFO &&
              ((W3_URI_INFO*)pvBlob)->bFileInfoValid &&
              ((W3_URI_INFO*)pvBlob)->pOpenFileInfo != NULL) )
    {
        TsIncreaseFileHandleCount( TRUE );
    }

    //
    //  Unlock the cache table.
    //

    LeaveCriticalSection( &CacheTable.CriticalSection );

    ASSERT( BLOB_IS_OR_WAS_CACHED( pvBlob ) );

    //
    //  Return success.
    //


    IF_DEBUG( CACHE) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Cached object(%08x) contains Blob (%08x)."
                    " Returning TRUE\n",
                    cache, pvBlob));
    }

    return( TRUE );

Cannot_Cache:

    //
    //  The cleanup code does not cleanup a directory change item.
    //

    if ( cache != NULL )
    {
        cache->Signature = CACHE_OBJ_SIGNATURE_X;
        FREE( cache );
        cache = NULL;
    }

    ASSERT( !BLOB_IS_OR_WAS_CACHED( pvBlob ) );

    IF_DEBUG( CACHE) {

        DBGPRINTF( (DBG_CONTEXT, " Failure to cache the object ( %08x)\n",
                    pvBlob));
    }

    return( FALSE );

} // TsCacheDirectoryBlob

BOOL
TsCheckOutCachedBlob(
    IN const TSVC_CACHE             &TSvcCache,
    IN      PCSTR                   pszDirectoryName,
    IN      ULONG                   iDemultiplexor,
    IN      PVOID *                 ppvBlob,
    IN      HANDLE                  hAccessToken,
    IN      BOOL                    fMayCacheAccessToken,
    IN      PSECURITY_DESCRIPTOR*   ppSecDesc
    )
{
    HASH_TYPE hash;
    ULONG cchLength;
    int iBin;
    BOOL Result;
    LONG refCount;
    PLIST_ENTRY pEntry;
    PCACHE_OBJECT pCache;
    DWORD         Position = 0;
    BOOL fSkipIdCheck = (iDemultiplexor != RESERVED_DEMUX_OPEN_FILE) &&
                        (iDemultiplexor != RESERVED_DEMUX_URI_INFO);

    ASSERT( pszDirectoryName != NULL );
    ASSERT( ppvBlob != NULL );

    //
    //  Prepare the return value such that we fail by default.
    //

    Result = FALSE;

    if ( ppSecDesc )
    {
        *ppSecDesc = NULL;
    }

    //
    //  Calculate the hash and length of the path name.
    //

    hash = CalculateHashAndLengthOfPathName( pszDirectoryName, &cchLength );

    //
    //  Calculate the bin of the hash table that should head the list
    //  containing the sought-after item.
    //

    iBin = HASH_TO_BIN( hash );


    EnterCriticalSection( &CacheTable.CriticalSection );

    __try
    {

        //
        //  Look for a previously cached object for the same directory.  If we
        //  find one, return it.
        //

        for (   pEntry  = CacheTable.Items[ iBin ].Flink;
                pEntry != &CacheTable.Items[ iBin ];
                pEntry  = pEntry->Flink, Position++ )
        {
            pCache = CONTAINING_RECORD( pEntry, CACHE_OBJECT, BinList );

            ASSERT( pCache->Signature == CACHE_OBJ_SIGNATURE );
            ASSERT( pCache->pbhBlob->IsCached );
            ASSERT( pCache->pbhBlob->pCache == pCache );

            if ( pCache->cchLength == cchLength &&
                 pCache->hash == hash &&
                 pCache->iDemux == iDemultiplexor &&
                 pCache->references > 0 &&
                 ( fSkipIdCheck ||
                    ( pCache->dwService == TSvcCache.GetServiceId() &&
                      pCache->dwInstance == TSvcCache.GetInstanceId() ) ) &&
                 !_memicmp( pCache->szPath, pszDirectoryName, cchLength ) )
            {
                //
                // Check access rights
                //

                if ( pCache->pSecDesc && hAccessToken &&
                     hAccessToken != pCache->hLastSuccessAccessToken )
                {
                    BOOL    fAccess;
                    DWORD   dwGrantedAccess;
                    BYTE    psFile[SIZE_PRIVILEGE_SET];
                    DWORD   dwPS = sizeof( psFile );

                    if ( !::AccessCheck(
                            pCache->pSecDesc,
                            hAccessToken,
                            FILE_GENERIC_READ,
                            &g_gmFile,
                            (PRIVILEGE_SET*)psFile,
                            &dwPS,
                            &dwGrantedAccess,
                            &fAccess ) || !fAccess )
                    {
                        DBGPRINTF( (DBG_CONTEXT, "[TsCheckOutCachedBlob] AccessCheck failed error %d\n", GetLastError() ));
                        Result = FALSE;
                        goto Exit;
                    }
                    if ( fMayCacheAccessToken )
                    {
                        pCache->hLastSuccessAccessToken = hAccessToken;
                    }
                }

                //
                //  We found a matching cache object.  We return it and increase
                //  its reference count.
                //

                *ppvBlob = pCache->pbhBlob + 1;

                ASSERT( pCache->pbhBlob->IsCached );

                //
                // Increase the reference count of the cached object, to prevent
                // it from expiration while it is checked out.
                //

                refCount = REFERENCE_CACHE_OBJ( pCache );

                if( refCount == 1 ) {
                    //
                    // The reference count was zero before we incremented
                    // it, meaning this cache entry is in the midst of
                    // getting deleted. We'll restore the reference count
                    // and ignore this entry.
                    //

                    DEREFERENCE_CACHE_OBJ( pCache );
                    continue;
                }

                TSUNAMI_TRACE( refCount, pCache );

                IF_DEBUG(OPLOCKS) {
                    DBGPRINTF( (DBG_CONTEXT,"TsCheckOutCachedBlob(%s) iDemux=%08lx, cache=%08lx, references=%d\n",
                        pszDirectoryName, pCache->iDemux, pCache, refCount ));
                }

                pCache->TTL = 1;

                Result = TRUE;

                //
                //  If the found item is far enough back in the list, move
                //  it to the front so the next hit will be quicker
                //

                if ( Position > REORDER_LIST_THRESHOLD )
                {
                    RemoveEntryList( pEntry );
                    InsertHeadList( &CacheTable.Items[ iBin ], pEntry );

                    IF_DEBUG( CACHE ) {

                        DBGPRINTF(( DBG_CONTEXT,
                                    "[TsCheckOutCachedBlobW] Reordered list for item at %d position\n",
                                    Position ));
                    }
                }

                if ( ppSecDesc && pCache->pSecDesc )
                {
                    if ( *ppSecDesc = (PSECURITY_DESCRIPTOR)LocalAlloc( LMEM_FIXED,
                            GetSecurityDescriptorLength(pCache->pSecDesc) ) )
                    {
                        memcpy( *ppSecDesc,
                                pCache->pSecDesc,
                                GetSecurityDescriptorLength(pCache->pSecDesc) );
                    }
                }

                break;
            }
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        //  As far as I can see, the only way we can end up here with
        //  Result == TRUE is an exception on LeaveCriticalSection().  If
        //  that happens, we're toast anyway, since noone will ever get to
        //  the CacheTable again.
        //

        ASSERT( !Result );

        Result = FALSE;
    }
Exit:
    LeaveCriticalSection( &CacheTable.CriticalSection );

    if ( Result) {

        INC_COUNTER( TSvcCache.GetServiceId(), CacheHits );

    } else {

        INC_COUNTER( TSvcCache.GetServiceId(), CacheMisses );
    }

    return( Result );
} // TsCheckOutCachedBlobW

VOID
InsertHeadPhysFile(
    IN PPHYS_OPEN_FILE_INFO     lpPFInfo,
    IN PVOID                    pvBlob
    )
{
    PBLOB_HEADER  pbhBlob;

    ASSERT( lpPFInfo->Signature == PHYS_OBJ_SIGNATURE );
    pbhBlob = (( PBLOB_HEADER )pvBlob ) - 1;

    EnterCriticalSection( &CacheTable.CriticalSection );
    ASSERT( IsListEmpty( &pbhBlob->PFList ) );
    InsertHeadList( &lpPFInfo->OpenReferenceList, &pbhBlob->PFList );
    LeaveCriticalSection( &CacheTable.CriticalSection );

}


BOOL
TsCheckOutCachedPhysFile(
    IN const TSVC_CACHE             &TSvcCache,
    IN      PCSTR                   pszDirectoryName,
    IN      PVOID *                 ppvBlob
    )
{
    HASH_TYPE hash;
    ULONG cchLength;
    int iBin;
    BOOL Result;
    BOOL Found;
    LONG refCount;
    PLIST_ENTRY pEntry;
    PCACHE_OBJECT pCache = NULL;
    DWORD         Position = 0;
    PBLOB_HEADER  pbhBlob;
    PPHYS_OPEN_FILE_INFO pPhysFileInfo;

    ASSERT( pszDirectoryName != NULL );
    ASSERT( ppvBlob != NULL );

    //
    //  Prepare the return value such that we fail by default.
    //

    Result = FALSE;
    Found = FALSE;
    *ppvBlob = NULL;

    //
    //  Calculate the hash and length of the path name.
    //

    hash = CalculateHashAndLengthOfPathName( pszDirectoryName, &cchLength );

    //
    //  Calculate the bin of the hash table that should head the list
    //  containing the sought-after item.
    //

    iBin = HASH_TO_BIN( hash );


    EnterCriticalSection( &CacheTable.CriticalSection );

    __try
    {

        //
        //  Look for a previously cached object for the same directory.  If we
        //  find one, return it.
        //

        for (   pEntry  = CacheTable.Items[ iBin ].Flink;
                pEntry != &CacheTable.Items[ iBin ];
                pEntry  = pEntry->Flink, Position++ )
        {
            pCache = CONTAINING_RECORD( pEntry, CACHE_OBJECT, BinList );

            ASSERT( pCache->Signature == CACHE_OBJ_SIGNATURE );
            ASSERT( pCache->pbhBlob->IsCached );
            ASSERT( pCache->pbhBlob->pCache == pCache );

            if ( pCache->cchLength == cchLength &&
                 pCache->hash == hash &&
                 pCache->iDemux == RESERVED_DEMUX_PHYSICAL_OPEN_FILE &&
                 pCache->references > 0 &&
                 !_memicmp( pCache->szPath, pszDirectoryName, cchLength ) )
            {

                //
                //  We found a matching cache object.  We return it and increase
                //  its reference count.
                //

                *ppvBlob = pCache->pbhBlob + 1;

                ASSERT( pCache->pbhBlob->IsCached );

                //
                //  Increase the reference count of the cached object, to prevent
                //  it from expiration while it is checked out.
                //

                refCount = REFERENCE_CACHE_OBJ( pCache );

                if( refCount == 1 ) {
                    //
                    // The reference count was zero before we incremented
                    // it, meaning this cache entry is in the midst of
                    // getting deleted. We'll restore the reference count
                    // and ignore this entry.
                    //

                    DEREFERENCE_CACHE_OBJ( pCache );
                    continue;
                }

                TSUNAMI_TRACE( refCount, pCache );

                IF_DEBUG(OPLOCKS) {
                    DBGPRINTF( (DBG_CONTEXT,"TsCheckOutCachedPhysFile(%s) iDemux=%08lx, cache=%08lx, references=%d\n",
                    pszDirectoryName, pCache->iDemux, pCache, refCount ));
                }

                pCache->TTL = 1;

                Result = TRUE;
                Found = TRUE;

                //
                //  If the found item is far enough back in the list, move
                //  it to the front so the next hit will be quicker
                //

                if ( Position > REORDER_LIST_THRESHOLD )
                {
                    RemoveEntryList( pEntry );
                    InsertHeadList( &CacheTable.Items[ iBin ], pEntry );

                    IF_DEBUG( OPLOCKS ) {

                        DBGPRINTF(( DBG_CONTEXT,
                                    "[TsCheckOutCachedBlobW] Reordered list for item at %d position\n",
                                    Position ));
                    }
                }

                break;
            }
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        //  As far as I can see, the only way we can end up here with
        //  Result == TRUE is an exception on LeaveCriticalSection().  If
        //  that happens, we're toast anyway, since noone will ever get to
        //  the CacheTable again.
        //

        ASSERT( !Result );

        Result = FALSE;
    }

    //
    // If we don't find a cache entry for the file, create one
    //

    pCache = NULL;

    if ( !Result ) {
        Result = TsAllocateEx(  TSvcCache,
                            sizeof( PHYS_OPEN_FILE_INFO ),
                            ppvBlob,
                            DisposePhysOpenFileInfo );

        if ( Result ) {

            pPhysFileInfo = (PPHYS_OPEN_FILE_INFO)*ppvBlob;
            TSUNAMI_TRACE( TRACE_PHYS_CREATE, pPhysFileInfo );

            pPhysFileInfo->Signature = PHYS_OBJ_SIGNATURE;
            pPhysFileInfo->hOpenFile = INVALID_HANDLE_VALUE;
            pPhysFileInfo->fInitComplete = FALSE;
            pPhysFileInfo->dwLastError = ERROR_FILE_NOT_FOUND;
            pPhysFileInfo->fSecurityDescriptor = FALSE;
            pPhysFileInfo->fDeleteOnClose = FALSE;
            pPhysFileInfo->fIsCached = FALSE;

            InitializeListHead( &pPhysFileInfo->OpenReferenceList );

            pPhysFileInfo->abSecurityDescriptor = (BYTE *)ALLOC( SECURITY_DESC_DEFAULT_SIZE );

            if ( pPhysFileInfo->abSecurityDescriptor == NULL ) {
                TsFree( TSvcCache, *ppvBlob );
                *ppvBlob = NULL;
                Result = FALSE;
                goto Exit;
            } else {
                pPhysFileInfo->cbSecDescMaxSize = SECURITY_DESC_DEFAULT_SIZE;
            }

            //
            //  *ppvBlob points to the usable area of the
            //  Blob, so we have to adjust it to point to the beginning.
            //

            pbhBlob = (( PBLOB_HEADER )*ppvBlob ) - 1;

            ASSERT( !pbhBlob->IsCached );

            if ( g_fDisableCaching )
            {
                goto Cannot_Cache;
            }

            //
            //  Allocate the cache object. We (effectively) allocate cchLength + 1
            //  bytes, to allow for the trailing NULL.
            //

            pCache = (PCACHE_OBJECT)ALLOC( sizeof(CACHE_OBJECT) + cchLength);

            if ( pCache == NULL ) {

                IF_DEBUG( OPLOCKS ) {

                    DBGPRINTF( ( DBG_CONTEXT,
                                "Unable to alloc Cache Object. Failure.\n"));
                }
                TsFree( TSvcCache, *ppvBlob );
                *ppvBlob = NULL;
                Result = FALSE;
                goto Exit;
            }

            pCache->Signature = CACHE_OBJ_SIGNATURE;

            pCache->hash = hash;
            pCache->cchLength = cchLength;

            //
            //  Store the Blob in the new object.
            //

            pCache->pbhBlob = pbhBlob;

            //
            //  Store the security descriptor in the new object.
            //

            pCache->pSecDesc = NULL;
            pCache->hLastSuccessAccessToken = NULL;

            //
            //  We need to be able to find the cache entry from the Blob.
            //

            pbhBlob->pCache = pCache;

            //
            //  Initialize the check-out count.
            //

            pCache->references = 1;
            pCache->iDemux     = RESERVED_DEMUX_PHYSICAL_OPEN_FILE;
            pCache->dwService  = TSvcCache.GetServiceId();
            pCache->dwInstance = TSvcCache.GetInstanceId();
            pCache->TTL        = 1;

            TSUNAMI_TRACE( pCache->references, pCache );

            IF_DEBUG(OPLOCKS) {
                DBGPRINTF( (DBG_CONTEXT,"TsCheckOutCachedPhysFile(%s) cache=%08lx, references=%d\n",
                    pszDirectoryName, pCache, pCache->references ));
            }

            InitializeListHead( &pCache->DirChangeList );

            //
            //  Copy the directory name to the cache object.
            //

            memcpy( pCache->szPath, pszDirectoryName, pCache->cchLength + 1 );

#if 0
            Result = DcmAddNewItem(
                            (PIIS_SERVER_INSTANCE)TSvcCache.GetServerInstance(),
                            (PCHAR)pszDirectoryName,
                            pCache
                            );

            if ( !Result )
            {
                //
                //  For whatever reason, we cannot get notifications of changes
                //  in the directory containing the to-be-cached item.  We won't
                //  be adding this object to the cache table, so we unlock the
                //  table and jump to the failure-handling code.
                //

                IF_DEBUG( OPLOCKS) {

                    DBGPRINTF( ( DBG_CONTEXT,
                                " Unable to cache. Due to rejection by DirChngMgr\n"));
                }

                goto Cannot_Cache;
            }
#endif

            //
            //  Mark this blob as cached, since we'll either cache it or throw it
            //  away hereafter.
            //

            pbhBlob->IsCached = TRUE;
            pPhysFileInfo->fIsCached = TRUE;

            //
            //  Add the object to the cache table, as the most-recently-used object.
            //

            iBin = HASH_TO_BIN( pCache->hash );

            //
            //  Add this object to the cache.
            //

            InsertHeadList( &CacheTable.Items[ iBin ], &pCache->BinList );

            //
            //  Since this object was just added, put it at the head of the MRU list.
            //

            InsertHeadList( &CacheTable.MruList, &pCache->MruList );

            //
            //  Increase the running size of cached objects by the size of the one
            //  just cached.
            //

            IF_DEBUG(OPLOCKS) {
                DBGPRINTF( (DBG_CONTEXT,"TsCheckoutCachedPhysFile(%s)\n",
                    pszDirectoryName ));
            }

            ASSERT( BLOB_IS_OR_WAS_CACHED( *ppvBlob ) );

            //
            //  Return success.
            //

            IF_DEBUG( OPLOCKS) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Cached object(%08x) contains Blob (%08x)."
                            " Returning TRUE\n",
                            pCache, *ppvBlob));
            }

            goto Exit;


        } else {
            IF_DEBUG(OPLOCKS) {
                DBGPRINTF( (DBG_CONTEXT,"TsCheckOutCachedPhysFile(%s) Alloc Failed!\n",
                    pszDirectoryName ));
            }
        }
    } else {
        goto Exit;
    }

Cannot_Cache:
    //
    //  The cleanup code does not cleanup a directory change item.
    //

    if ( pCache != NULL )
    {
        pCache->Signature = CACHE_OBJ_SIGNATURE_X;
        FREE( pCache );
        pCache = NULL;
    }

    ASSERT( !BLOB_IS_OR_WAS_CACHED( *ppvBlob ) );

    IF_DEBUG( OPLOCKS) {

        DBGPRINTF( (DBG_CONTEXT, " Failure to cache the object ( %08x)\n",
                    *ppvBlob));
    }

    Result = FALSE;

Exit:

    LeaveCriticalSection( &CacheTable.CriticalSection );

    if ( Result) {

        INC_COUNTER( TSvcCache.GetServiceId(), CacheHits );

    } else {

        INC_COUNTER( TSvcCache.GetServiceId(), CacheMisses );
    }

    return( Found );
} // TsCheckOutCachedPhysFile


BOOL
TsCheckInCachedBlob(
    IN      PVOID           pvBlob
    )
{
    PBLOB_HEADER pbhBlob;
    PCACHE_OBJECT pCache;
    BOOL bEjected;

    pbhBlob = (( PBLOB_HEADER )pvBlob ) - 1;

    ASSERT( pbhBlob->IsCached );

    pCache = pbhBlob->pCache;

    ASSERT( pCache->Signature == CACHE_OBJ_SIGNATURE );
    ASSERT( pCache->pbhBlob == pbhBlob );

    ASSERT( pCache->references > 0 );

    TsDereferenceCacheObj( pCache, TRUE );

    return( TRUE );
} // TsCheckInCachedBlob

BOOL
TsAddRefCachedBlob(
    IN      PVOID           pvBlob
    )
{
    PBLOB_HEADER pbhBlob;
    PCACHE_OBJECT pCache;
    BOOL bEjected;
    LONG refCount;

    pbhBlob = (( PBLOB_HEADER )pvBlob ) - 1;

    ASSERT( pbhBlob->IsCached );

    pCache = pbhBlob->pCache;

    ASSERT( pCache->Signature == CACHE_OBJ_SIGNATURE );
    ASSERT( pCache->pbhBlob == pbhBlob );

    ASSERT( pCache->references > 0 );

    refCount = REFERENCE_CACHE_OBJ( pCache );
    TSUNAMI_TRACE( refCount, pCache );

    return( TRUE );
} // TsCheckInCachedBlob

BOOL
TsExpireCachedBlob(
    IN const TSVC_CACHE &TSvcCache,
    IN      PVOID           pvBlob
    )
{
    PBLOB_HEADER pbhBlob;
    PCACHE_OBJECT pCache;

    pbhBlob = (( PBLOB_HEADER )pvBlob ) - 1;

    ASSERT( pbhBlob->IsCached );

    pCache = pbhBlob->pCache;

    ASSERT( pCache->Signature == CACHE_OBJ_SIGNATURE );
    ASSERT( pCache->pbhBlob == pbhBlob );
    ASSERT( pCache->references > 0 );

    return( DeCache( pCache, TRUE ) );
} // TsExpireCachedBlob

VOID
TsDereferenceCacheObj(
    IN      PCACHE_OBJECT  pCache,
    IN      BOOL           fLockCacheTable
    )
{
    LONG refCount;

    ASSERT( pCache->Signature == CACHE_OBJ_SIGNATURE );
    ASSERT( pCache->references > 0 );
    ASSERT( pCache->pbhBlob->IsCached );

    refCount = DEREFERENCE_CACHE_OBJ( pCache );
    TSUNAMI_TRACE( refCount, pCache );

    IF_DEBUG(OPLOCKS) {
        DBGPRINTF( (DBG_CONTEXT,"TsDereferenceCacheObj(%s) iDemux=%08lx, cache=%08lx, references=%d\n",
            pCache->szPath, pCache->iDemux, pCache, refCount ));
    }

    if( refCount == 0 ) {

        EnterCriticalSection( &CacheTable.CriticalSection );

        if ( pCache->references != 0 ) {
            LeaveCriticalSection( &CacheTable.CriticalSection );
            return;
        }

        if ( pCache->iDemux == RESERVED_DEMUX_PHYSICAL_OPEN_FILE ) {
            RemoveCacheObjFromLists( pCache, FALSE );
        }

        if (!DisableSPUD) {
            if (!IsListEmpty( &pCache->pbhBlob->PFList ) ) {
                RemoveEntryList( &pCache->pbhBlob->PFList );
            }
        }

        LeaveCriticalSection( &CacheTable.CriticalSection );

        //
        //  We best not be on a list if we're about to be freed here
        //

        ASSERT( IsListEmpty( &pCache->BinList ) );

        //
        //  We really want to call TsFree here, but we don't have a TsvcCache
        //

        IF_DEBUG( CACHE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "[DeCache] Free routine: 0x%lx, Blob: 0x%lx Cache obj: 0x%lx\n",
                        pCache->pbhBlob->pfnFreeRoutine,
                        pCache->pbhBlob,
                        pCache ));
        }

        if ( pCache->pbhBlob->pfnFreeRoutine )
            pCache->pbhBlob->pfnFreeRoutine( pCache->pbhBlob + 1);

        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsDereferenceCacheObj(%s)\n",
                pCache->szPath ));
        }

        DEC_COUNTER( pCache->dwService, CurrentObjects );

        if ( pCache->pSecDesc )
        {
            LocalFree( pCache->pSecDesc );
        }

        if ( pCache->iDemux == RESERVED_DEMUX_OPEN_FILE )
        {
            TsDecreaseFileHandleCount();
        }

        pCache->Signature = CACHE_OBJ_SIGNATURE_X;
        FREE( pCache->pbhBlob );
        FREE( pCache );
    }
} // TsDereferenceCacheObj

VOID
TsDecreaseFileHandleCount(
    VOID
    )
{
    ASSERT( CacheTable.OpenFileInUse != 0 );

    if ( CacheTable.OpenFileInUse )
    {
        InterlockedDecrement( (LONG*)&CacheTable.OpenFileInUse );
    }
}


VOID
TsIncreaseFileHandleCount(
    BOOL    fInCacheLock
    )
{
    if ( (UINT)(pfnInterlockedExchangeAdd( (LONG*)&CacheTable.OpenFileInUse, 1) )
            >= CacheTable.MaxOpenFileInUse )
    {
        if ( !fInCacheLock )
        {
            EnterCriticalSection( &CacheTable.CriticalSection );
        }
        RemoveLruHandleCacheItem();
        if ( !fInCacheLock )
        {
            LeaveCriticalSection( &CacheTable.CriticalSection );
        }
    }
}

BOOL
RemoveLruHandleCacheItem(
    VOID
    )
/*++

  Routine Description:

    Remove the least recently used cached item referencing a file handle


    THE CACHE TABLE LOCK MUST BE TAKEN PRIOR TO CALLING THIS FUNCTION

  Arguments:

    None

--*/
{
    PLIST_ENTRY pEntry;

    for ( pEntry = CacheTable.MruList.Blink ;
          pEntry != &CacheTable.MruList ;
          pEntry = pEntry->Blink )
    {
        //
        //  The least recently used entry is the one at the tail of the MRU
        //  list.
        //

        PCACHE_OBJECT  pCacheObject =
                         CONTAINING_RECORD( pEntry,
                                            CACHE_OBJECT,
                                            MruList );

        PW3_URI_INFO   pURI = (PW3_URI_INFO)(pCacheObject->pbhBlob+1);

        if ( (pCacheObject->iDemux == RESERVED_DEMUX_OPEN_FILE) ||
             (pCacheObject->iDemux == RESERVED_DEMUX_URI_INFO &&
                  pURI->bFileInfoValid &&
                  pURI->pOpenFileInfo != NULL) )
        {
            DeCache( pCacheObject, FALSE );

            IF_DEBUG( CACHE) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Throwing out object ( %08x) to reduce file handle ref\n",
                            pCacheObject));
            }

            return TRUE;
        }
    }

    return FALSE;
} // RemoveLruCacheItem


BOOL
TsCacheQueryStatistics(
    IN  DWORD       Level,
    IN  DWORD       dwServerMask,
    IN  INETA_CACHE_STATISTICS * pCacheCtrs
    )
/*++

  Routine Description:

    This function returns the statistics for the global cache or for the
    individual services

  Arguments:

    Level - Only valid value is 0
    dwServerMask - Server mask to retrieve statistics for or 0 for the sum
        of the services
    pCacheCtrs - Receives the statistics for cache

  Notes:
    CacheBytesTotal and CacheBytesInUse are not kept on a per-server basis
        so they are only returned when retrieving summary statistics.

  Returns:

    TRUE on success, FALSE on failure
--*/
{
    if ( Level != 0 ||
         dwServerMask > LAST_PERF_CTR_SVC ||
         !pCacheCtrs )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if ( dwServerMask )
    {
        memcpy( pCacheCtrs,
                &Configuration.Stats[ MaskIndex(dwServerMask) ],
                sizeof( Configuration.Stats[ 0 ] ) );
    }
    else
    {
        //
        //  Add up all of the statistics
        //

        memset( pCacheCtrs, 0, sizeof( *pCacheCtrs ));

        for ( int i = 0; i < MAX_PERF_CTR_SVCS; i++ )
        {
            DWORD index = MaskIndex( 1 << i );

            pCacheCtrs->CurrentOpenFileHandles+= Configuration.Stats[index].CurrentOpenFileHandles;
            pCacheCtrs->CurrentDirLists       += Configuration.Stats[index].CurrentDirLists;
            pCacheCtrs->CurrentObjects        += Configuration.Stats[index].CurrentObjects;
            pCacheCtrs->FlushesFromDirChanges += Configuration.Stats[index].FlushesFromDirChanges;
            pCacheCtrs->CacheHits             += Configuration.Stats[index].CacheHits;
            pCacheCtrs->CacheMisses           += Configuration.Stats[index].CacheMisses;
#if 0
            pCacheCtrs->TotalSuccessGetSecDesc+= Configuration.Stats[index].TotalSuccessGetSecDesc;
            pCacheCtrs->TotalFailGetSecDesc   += Configuration.Stats[index].TotalFailGetSecDesc;
            if  ( pCacheCtrs->CurrentSizeSecDesc < Configuration.Stats[index].CurrentSizeSecDesc )
            {
                pCacheCtrs->CurrentSizeSecDesc = Configuration.Stats[index].CurrentSizeSecDesc;
            }
            pCacheCtrs->TotalAccessCheck      += Configuration.Stats[index].TotalAccessCheck;
#endif
        }
    }

    return TRUE;
}

BOOL
TsCacheClearStatistics(
    IN  DWORD       dwServerMask
    )
/*++

  Routine Description:

    Clears the the specified service's statistics

--*/
{
    if ( dwServerMask > LAST_PERF_CTR_SVC )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    //  Currently this function isn't supported
    //

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
} // TsCacheClearStatistics

BOOL
TsCacheFlush(
    IN  DWORD       dwServerMask
    )
/*++

  Routine Description:

    This function flushes the cache of all items for the specified service
    or for all services if dwServerMask is zero.

--*/
{
    LIST_ENTRY * pEntry;
    LIST_ENTRY * pNext;

    if ( dwServerMask == 0 ) {
        return(TRUE);
    }

    EnterCriticalSection( &CacheTable.CriticalSection );

    for ( pEntry =  CacheTable.MruList.Flink;
          pEntry != &CacheTable.MruList;
        )
    {
        pNext = pEntry->Flink;

        PCACHE_OBJECT  pCacheObject =
                         CONTAINING_RECORD( pEntry,
                                            CACHE_OBJECT,
                                            MruList );

        if ( pCacheObject->iDemux == RESERVED_DEMUX_PHYSICAL_OPEN_FILE ) {
            pEntry = pNext;
            continue;
        }

        if ( dwServerMask == pCacheObject->dwService ) {

            DeCache( pCacheObject, FALSE );

            IF_DEBUG( CACHE) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Throwing out object ( %08x) due to manual flush\n",
                            pCacheObject));
            }
        }

        pEntry = pNext;
    }

    LeaveCriticalSection( &CacheTable.CriticalSection );

    return TRUE;
} // TsCacheFlush

BOOL
TsCacheFlushUser(
    IN  HANDLE      hUserToken,
    IN  BOOL        fDefer
    )
/*++

  Routine Description:

    This function flushes all file handles associated the passed user context

  Arguments:

    hUserToken - User token to flush from the cache
    fDefer - Build list but close handles later in worker thread (Not supported)

--*/
{
    LIST_ENTRY * pEntry;
    LIST_ENTRY * pNext;

    ASSERT( !fDefer );

    EnterCriticalSection( &CacheTable.CriticalSection );

    for ( pEntry =  CacheTable.MruList.Flink;
          pEntry != &CacheTable.MruList;
        )
    {
        pNext = pEntry->Flink;

        PCACHE_OBJECT  pCacheObject = CONTAINING_RECORD( pEntry,
                                                         CACHE_OBJECT,
                                                         MruList );

        ASSERT( pCacheObject->Signature == CACHE_OBJ_SIGNATURE );

        if ( pCacheObject->iDemux == RESERVED_DEMUX_PHYSICAL_OPEN_FILE ) {
            pEntry = pNext;
            continue;
        }

        //
        //  Find all occurrences of the matching user token in the cache and
        //  decache them
        //

        if ( pCacheObject->iDemux == RESERVED_DEMUX_OPEN_FILE &&
             ((TS_OPEN_FILE_INFO *)(pCacheObject->pbhBlob + 1))->
                 QueryOpeningUser() == hUserToken )
        {
            DeCache( pCacheObject, FALSE );

            IF_DEBUG( CACHE) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Throwing out object ( %08x) due to user token flush\n",
                            pCacheObject));
            }
        }
        else if ( pCacheObject->iDemux == RESERVED_DEMUX_DIRECTORY_LISTING &&
                    ((TS_DIRECTORY_HEADER *)(pCacheObject->pbhBlob + 1))->
                            QueryListingUser() == hUserToken )
        {
            DeCache( pCacheObject, FALSE );

            IF_DEBUG( CACHE) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Throwing out object ( %08x) due to user token flush\n",
                            pCacheObject));
            }
        }
        else if ( (pCacheObject->hLastSuccessAccessToken == hUserToken) )
        {
            //
            // If security descriptor is present, simply cancel Last successful access token
            // otherwise must decache cache object, as security check are entirely dependent
            // on last successful access token in this case
            //

            if ( pCacheObject->pSecDesc )
            {
                pCacheObject->hLastSuccessAccessToken = NULL;
            }
            else
            {
                DeCache( pCacheObject, FALSE );

                IF_DEBUG( CACHE) {

                    DBGPRINTF( ( DBG_CONTEXT,
                                " Throwing out object ( %08x) due to user token flush\n",
                                pCacheObject));
                }
            }
        }

        pEntry = pNext;
    }

    LeaveCriticalSection( &CacheTable.CriticalSection );

    return TRUE;
} // TsCacheFlushUser

BOOL
TsCacheFlushDemux(
    IN ULONG            iDemux
    )
/*++

  Routine Description:

    Flush all cache items whose demultiplexor matches that specified.

  Arguments:

    iDemux - Value of demux whose cache items are to be flushed.

--*/
{
    LIST_ENTRY * pEntry;
    LIST_ENTRY * pNext;

    EnterCriticalSection( &CacheTable.CriticalSection );

    for ( pEntry =  CacheTable.MruList.Flink;
          pEntry != &CacheTable.MruList;
        )
    {
        pNext = pEntry->Flink;

        PCACHE_OBJECT  pCacheObject = CONTAINING_RECORD( pEntry,
                                                         CACHE_OBJECT,
                                                         MruList );

        ASSERT( pCacheObject->Signature == CACHE_OBJ_SIGNATURE );

        if ( pCacheObject->iDemux == iDemux )
        {
            DeCache( pCacheObject, FALSE );

            IF_DEBUG( CACHE) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Throwing out object ( %08x) due to demux flush\n",
                            pCacheObject));
            }

            //
            //  The last Decache may have thrown out the next entry.
            //  Since this is just a shutdown path restart the scan
            //  of the list from the beginning
            //
            
            pEntry = CacheTable.MruList.Flink;
            continue;
        }

        pEntry = pNext;
    }

    LeaveCriticalSection( &CacheTable.CriticalSection );

    return TRUE;
} // TsCacheFlushDemux


VOID
TsFlushURL(
    IN const TSVC_CACHE             &TSvcCache,
    IN      PCSTR                   pszURL,
    IN      DWORD                   dwURLLength,
    IN      ULONG                   iDemultiplexor
    )
/*++

  Routine Description:

    This routine takes as input a URL and removes from the cache all cached
    objects that have the input URL as their prefix. This is mostly called
    when we get a change notify for metadata.

  Arguments

    TSvcCache               - Service cache
    pszURL                  - The URL prefix to be flushed.
    iDemultiplexor          - The demultiplexor for the caller's entries.

  Returns

    Nothing

--*/
{
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pNext;
    LIST_ENTRY              ListHead;
    PCACHE_OBJECT           pCacheObject;
    BOOL                    bIsRoot;

    // The basic algorithm is to lock the cache table, then walk the cache
    // table looking for matches and decaching those. This could get
    // expensive if the table is big and this routine is called frequently -
    // in that case we may need to schedule the decaches for later, or
    // periodically free and reaquire the critical section.


    InitializeListHead( &ListHead );

    if (!memcmp(pszURL, "/", sizeof("/")))
    {
        bIsRoot = TRUE;
    }
    else
    {
        bIsRoot = FALSE;
    }

    EnterCriticalSection( &CacheTable.CriticalSection );

    pEntry =  CacheTable.MruList.Flink;

    while (pEntry != &CacheTable.MruList)
    {
        pNext = pEntry->Flink;

        pCacheObject = CONTAINING_RECORD( pEntry, CACHE_OBJECT, MruList );
        ASSERT( pCacheObject->Signature == CACHE_OBJ_SIGNATURE );

        // Check this cache object to see if it matches.
        if ( pCacheObject->iDemux == iDemultiplexor &&
             pCacheObject->dwService == TSvcCache.GetServiceId() &&
             pCacheObject->dwInstance == TSvcCache.GetInstanceId() &&
             (bIsRoot ? TRUE : (
                !_mbsnbicmp( (PUCHAR)pCacheObject->szPath, (PUCHAR)pszURL, dwURLLength) &&
                    (pCacheObject->szPath[dwURLLength] == '/' ||
                    pCacheObject->szPath[dwURLLength] == '\0')))
            )
        {

            if ( !RemoveCacheObjFromLists( pCacheObject, FALSE ) ) {
                ASSERT( FALSE );
                continue;
            }

            InsertTailList( &ListHead, &pCacheObject->DirChangeList );

            IF_DEBUG( CACHE)
            {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Throwing cache object ( %08x) out of cache because of URL match\n",
                            pCacheObject));
            }
        }

        pEntry = pNext;
    }

    for ( pEntry  = ListHead.Flink;
          pEntry != &ListHead;
          pEntry = pNext ) {

        pNext = pEntry->Flink;
        pCacheObject = CONTAINING_RECORD( pEntry, CACHE_OBJECT, DirChangeList );

        ASSERT( pCacheObject->Signature == CACHE_OBJ_SIGNATURE );

        TsDereferenceCacheObj( pCacheObject, FALSE );
    }

    LeaveCriticalSection( &CacheTable.CriticalSection );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\creatfil.cxx ===
/*++

    creatfil.cxx

    Exports API for creating/opening a file, given the filename.
    The file handle and other information are cached for the given user handle.

    History:
        Heath Hunnicutt     ( t-heathh)     ??-??-??

        Murali R. Krishnan  ( MuraliK)      Dec 30, 1994
            Added SetLastError() to set error code as appropriate

        Murali R. Krishnan  ( MuraliK)      Jan 4, 1994
            Added ability to obtain and set the BY_HANDLE_FILE_INFORMATION
             as part of TS_OPEN_FILE_INFO
--*/

#include "TsunamiP.Hxx"
#pragma hdrstop
#include <lonsi.hxx>
#include "auxctrs.h"
#include <dbgutil.h>

#include <iistypes.hxx>
#include <iisver.h>
#include <iiscnfg.h>
#include <imd.h>
#include <mb.hxx>

LONG g_IISCacheAuxCounters[ AacIISCacheMaxCounters];

GENERIC_MAPPING g_gmFile = {
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_ALL_ACCESS
};

//
// Routines and macros for manipulating the "init complete" state of
// a PHYS_OPEN_FILE_INFO structure.
//

VOID
WaitForPhysInitComplete(
    IN PPHYS_OPEN_FILE_INFO lpPFInfo
    );

#define WAIT_FOR_PHYS_INIT_COMPLETE( lpPFInfo )                             \
    if( !lpPFInfo->fInitComplete ) {                                        \
        WaitForPhysInitComplete( lpPFInfo );                                \
    } else

#define MARK_PHYS_INIT_COMPLETE( lpPFInfo )                                 \
    if( TRUE ) {                                                            \
        ASSERT( (lpPFInfo)->Signature == PHYS_OBJ_SIGNATURE );              \
        (lpPFInfo)->fInitComplete = TRUE;                                   \
    } else

#define PHYS_INIT_SLEEP_START   100     // ms
#define PHYS_INIT_SLEEP_INCR    100     // ms
#define PHYS_INIT_SLEEP_MAX     1000    // ms

dllexp
PSECURITY_DESCRIPTOR
TsGetFileSecDesc(
    LPTS_OPEN_FILE_INFO     pFile
    )
/*++

Routine Description:

    Returns the security descriptor associated to the file
    To be freed using LocalFree()

Arguments:

    pFile - ptr to fie object

Return Value:

    ptr to security descriptor or NULL if error

--*/
{
    SECURITY_INFORMATION    si
            = OWNER_SECURITY_INFORMATION |
            GROUP_SECURITY_INFORMATION |
            DACL_SECURITY_INFORMATION;
    BYTE                    abSecDesc[ SECURITY_DESC_DEFAULT_SIZE ];
    DWORD                   dwSecDescSize;
    PSECURITY_DESCRIPTOR    pAcl;

    if ( GetKernelObjectSecurity(
            pFile->QueryFileHandle(),
            si,
            (PSECURITY_DESCRIPTOR)abSecDesc,
            SECURITY_DESC_DEFAULT_SIZE,
            &dwSecDescSize ) )
    {
        if ( dwSecDescSize > SECURITY_DESC_DEFAULT_SIZE )
        {
            if ( !(pAcl = (PSECURITY_DESCRIPTOR)LocalAlloc( LMEM_FIXED, dwSecDescSize )) )
            {
                return NULL;
            }
            if ( !GetKernelObjectSecurity(
                    pFile->QueryFileHandle(),
                    si,
                    pAcl,
                    dwSecDescSize,
                    &dwSecDescSize ) )
            {
                LocalFree( pAcl );

                return NULL;
            }
        }
        else
        {
            if ( dwSecDescSize = GetSecurityDescriptorLength(abSecDesc) )
            {
                if ( !(pAcl = (PSECURITY_DESCRIPTOR)LocalAlloc( LMEM_FIXED,
                        dwSecDescSize )) )
                {
                    return NULL;
                }
                memcpy( pAcl, abSecDesc, dwSecDescSize );
            }
            else
            {
                //
                // Security descriptor is empty : do not return ptr to security descriptor
                //

                pAcl = NULL;
            }
        }
    }
    else
    {
        pAcl = NULL;
    }

    return pAcl;
}

BOOL
TsReInitPhysFile(
    IN PPHYS_OPEN_FILE_INFO pPhysFileInfo
    )

/*+++

    TsReInitPhysFile

    Called when we get a valid, initialized phys file info structure that
    has an invalid file handle. We acquire the cache critical section and
    check to see if the file is still valid and still has an invalid handle
    value. If it does, we're the first to try to do this, so we'll mark
    the structure and initing, and let our caller try to initialize it.
    Otherwise we'll just return and let our caller try again.

    Arguments:

        pPhysFileInfo - Pointer to the phys file info structure.

    Returns:

        FALSE if we reinited, TRUE otherwise.
---*/
{
    BOOL        bRetVal;

    EnterCriticalSection( &CacheTable.CriticalSection );

    if ( pPhysFileInfo->fInitComplete &&
         pPhysFileInfo->hOpenFile == INVALID_HANDLE_VALUE
       )
    {
        pPhysFileInfo->fInitComplete = FALSE;
        bRetVal = FALSE;
    }
    else
    {
        bRetVal = TRUE;
    }

    LeaveCriticalSection( &CacheTable.CriticalSection );

    return bRetVal;
}

VOID
WaitForPhysInitComplete(
    IN PPHYS_OPEN_FILE_INFO lpPFInfo
    )
/*++

Routine Description:

    Waits for the specified physical open file info structure to become
    fully initialized.

Arguments:

    lpPFInfo - The PHYS_OPEN_FILE_INFO structure to wait for.

Return Value:

    None.

--*/
{

    DWORD sleepTime;

    //
    // Sanity check.
    //

    ASSERT( lpPFInfo != NULL );

    //
    // Perform a linear backoff delay while waiting for init complete.
    //

    sleepTime = PHYS_INIT_SLEEP_START;

    while( !lpPFInfo->fInitComplete ) {

        ASSERT( lpPFInfo->Signature == PHYS_OBJ_SIGNATURE );
        Sleep( sleepTime );

        sleepTime += PHYS_INIT_SLEEP_INCR;

        if( sleepTime > PHYS_INIT_SLEEP_MAX ) {
            sleepTime = PHYS_INIT_SLEEP_MAX;
        }

    }

}   // WaitForPhysInitComplete

VOID
OplockCreateFile(
    PVOID       Context,
    DWORD       Status
    )
{
    POPLOCK_OBJECT lpOplock = (POPLOCK_OBJECT)Context;
    PBLOB_HEADER pbhBlob;
    PCACHE_OBJECT cache;
    PCACHE_OBJECT pCacheTmp;
    PCACHE_OBJECT TmpCache;
    BOOL result = FALSE;
    LIST_ENTRY    ListHead;
    LIST_ENTRY  * pEntry;
    LIST_ENTRY  * pNextEntry;

    IF_DEBUG(OPLOCKS) {
        DBGPRINTF( (DBG_CONTEXT,"OplockCreateFile(%08lx, %08lx) - Entered\n", Context, Status ));
    }

    if (lpOplock == NULL) {
        return;
    }

    ASSERT(lpOplock->Signature == OPLOCK_OBJ_SIGNATURE);
    if ( Status != OPLOCK_BREAK_NO_OPLOCK ) {
        WaitForSingleObject( lpOplock->hOplockInitComplete, (DWORD)(-1) );
    }

    if ( Status == OPLOCK_BREAK_OPEN ) {
        if ( lpOplock->lpPFInfo != NULL ) {
            pbhBlob = (( PBLOB_HEADER )lpOplock->lpPFInfo ) - 1;
            if ( pbhBlob->IsCached ) {
                cache = pbhBlob->pCache;

                InitializeListHead( &ListHead );

                EnterCriticalSection( &CacheTable.CriticalSection );
                EnterCriticalSection( &csVirtualRoots );

                for ( pEntry  = CacheTable.MruList.Flink;
                      pEntry != &CacheTable.MruList;
                      pEntry  = pNextEntry ) {

                    pNextEntry = pEntry->Flink;

                    pCacheTmp = CONTAINING_RECORD( pEntry, CACHE_OBJECT, MruList );

                    ASSERT( pCacheTmp->Signature == CACHE_OBJ_SIGNATURE );

                    if ( pCacheTmp != cache ) {
                        continue;
                    }

                    result = TRUE;

                    while ( !IsListEmpty( &lpOplock->lpPFInfo->OpenReferenceList ) ) {
                        pEntry = RemoveHeadList( &lpOplock->lpPFInfo->OpenReferenceList );
                        pbhBlob = CONTAINING_RECORD( pEntry, BLOB_HEADER, PFList );
                        TmpCache = pbhBlob->pCache;
                        if (!RemoveCacheObjFromLists( TmpCache, FALSE ) ) {
                            IF_DEBUG(OPLOCKS) {
                                DBGPRINTF( (DBG_CONTEXT,"OplockCreateFile(%08lx, %08lx, %08lx) - Error Processing Open Reference %08lx\n", Context, Status, pEntry, TmpCache ));
                            }
                            break;
                        }
                        IF_DEBUG(OPLOCKS) {
                            DBGPRINTF( (DBG_CONTEXT,"OplockCreateFile(%08lx, %08lx, %08lx) - Processing Open Reference %08lx\n", Context, Status, pEntry, TmpCache ));
                        }
                        InsertTailList( &ListHead, pEntry );
                    }

                    break;
                }

                LeaveCriticalSection( &csVirtualRoots );
                LeaveCriticalSection( &CacheTable.CriticalSection );

                if ( result ) {
                    while ( !IsListEmpty( &ListHead ) ) {
                        pEntry = RemoveHeadList( &ListHead );
                        pbhBlob = CONTAINING_RECORD( pEntry, BLOB_HEADER, PFList );
                        TmpCache = pbhBlob->pCache;
                        IF_DEBUG(OPLOCKS) {
                            DBGPRINTF( (DBG_CONTEXT,"OplockCreateFile(%08lx, %08lx) - Processing Open Reference %08lx %08lx\n", Context, Status, pEntry, TmpCache ));
                        }
                        TsDereferenceCacheObj( TmpCache, TRUE );
                    }
                }
            }
        }
    }
    CloseHandle( lpOplock->hOplockInitComplete );
    lpOplock->Signature = 0;
    LocalFree(lpOplock);
}

VOID
TsRemovePhysFile(
    PPHYS_OPEN_FILE_INFO lpPFInfo
    )
{
    PBLOB_HEADER pbhBlob;
    PCACHE_OBJECT cache;
    PCACHE_OBJECT pCacheTmp;
    PCACHE_OBJECT TmpCache;
    BOOL result = FALSE;
    BOOL bSuccess;
    LIST_ENTRY  * pEntry;
    LIST_ENTRY  * pNextEntry;

    IF_DEBUG(OPLOCKS) {
        DBGPRINTF( (DBG_CONTEXT,"TsRemovePhysFile(%08lx) - Entered\n", lpPFInfo ));
    }

    ASSERT( lpPFInfo->Signature == PHYS_OBJ_SIGNATURE );
    TSUNAMI_TRACE( TRACE_PHYS_REMOVE, lpPFInfo );

    pbhBlob = (( PBLOB_HEADER )lpPFInfo ) - 1;
    if ( pbhBlob->IsCached ) {
        cache = pbhBlob->pCache;

        EnterCriticalSection( &CacheTable.CriticalSection );
        EnterCriticalSection( &csVirtualRoots );

        if ( cache->references > 1 ) {

            TsCheckInCachedBlob( (PVOID)lpPFInfo );

        } else {

            for ( pEntry  = CacheTable.MruList.Flink;
                  pEntry != &CacheTable.MruList;
                  pEntry  = pNextEntry ) {

                pNextEntry = pEntry->Flink;

                pCacheTmp = CONTAINING_RECORD( pEntry, CACHE_OBJECT, MruList );

                ASSERT( pCacheTmp->Signature == CACHE_OBJ_SIGNATURE );

                if ( pCacheTmp != cache ) {
                    continue;
                }

                if ( !RemoveCacheObjFromLists( cache, FALSE ) ) {
                    ASSERT( FALSE );
                    continue;
                }

                result = TRUE;

                break;
            }
        }

        LeaveCriticalSection( &csVirtualRoots );
        LeaveCriticalSection( &CacheTable.CriticalSection );

        if ( result ) {
            TsDereferenceCacheObj( cache, TRUE );
        }
    } else {
        if ( pbhBlob->pfnFreeRoutine ) {
            bSuccess = pbhBlob->pfnFreeRoutine( (PVOID)lpPFInfo );
        } else {
            bSuccess = TRUE;
        }

        if ( bSuccess ) {
            //
            //  Free the memory used by the Blob.
            //

            FREE( pbhBlob );
        }
    }

}

dllexp
BOOL
TsDeleteOnClose(PW3_URI_INFO pURIInfo,
                HANDLE OpeningUser,
                BOOL *fDeleted)
{
    PPHYS_OPEN_FILE_INFO lpPFInfo;
    LPTS_OPEN_FILE_INFO lpOpenFile;
    BYTE psFile[SIZE_PRIVILEGE_SET];
    DWORD dwPS;
    DWORD dwGrantedAccess;
    BOOL fAccess;

    if ( DisableSPUD || pURIInfo == NULL ) {
        return FALSE;
    }

#if 0
    IF_DEBUG(OPLOCKS) {
        DBGPRINTF( (DBG_CONTEXT,"TsDeleteOnClose(%08lx) - Waiting On hFileEvent!\n", pURIInfo ));
    }
    WaitForSingleObject( pURIInfo->hFileEvent, (DWORD)(-1) );
    IF_DEBUG(OPLOCKS) {
        DBGPRINTF( (DBG_CONTEXT,"TsDeleteOnClose(%08lx) - Returned from Waiting On hFileEvent!\n", pURIInfo ));
    }

    lpOpenFile = pURIInfo->pOpenFileInfo;
    if ( lpOpenFile == NULL ) {
        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsDeleteOnClose(%08lx) - lpOpenFile == NULL!\n", pURIInfo ));
        }
        return FALSE;
    }

    *fDeleted = FALSE;
    lpPFInfo = lpOpenFile->QueryPhysFileInfo();
    if ( lpPFInfo->fIsCached && lpPFInfo->fSecurityDescriptor ) {
        dwPS = sizeof(psFile);
        ((PRIVILEGE_SET*)&psFile)->PrivilegeCount = 0;
        if ( AccessCheck(
                 lpPFInfo->abSecurityDescriptor,
                 OpeningUser,
                 FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                 &g_gmFile,
                 (PRIVILEGE_SET*)psFile,
                 &dwPS,
                 &dwGrantedAccess,
                 &fAccess) ) {
            if ( fAccess ) {
                IF_DEBUG(OPLOCKS) {
                    DBGPRINTF( (DBG_CONTEXT,"TsDeleteOnClose(%08lx) - Marking file for delete!\n", lpPFInfo ));
                }
                lpPFInfo->fDeleteOnClose = TRUE;
                *fDeleted = TRUE;
            }
        }
    } else {
        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsDeleteOnClose(%08lx) - !fIsCached || !fSecurityDescriptor\n", lpPFInfo ));
        }
        return FALSE;
    }
#endif //!oplock

    return TRUE;

}


BOOL
TsAccessCheck(
    IN      PPHYS_OPEN_FILE_INFO    pFile,
    IN      HANDLE                  hUser
    )

/*+++

    TsAccessCheck

    This routine validates that the user identified by hUser has permissions
    to access the file associated with the input physical file open structure.
    We use the cached security descriptor in pFile to do so if we can;
    otherwise we'll try and read the security descriptor first.

    Arguments:

        pFile   - A pointer to the physical file open structure
                    identifying the file.

        hUser   - User access token to be checked.

    Returns:

        TRUE if the file can be accessed, FALSE otherwise.

---*/
{

    PSECURITY_DESCRIPTOR        pSecDesc;
    BOOL                        bHaveAccess;
    CHAR                        cBuffer[SIZE_PRIVILEGE_SET];
    DWORD                       dwPSSize;
    PPRIVILEGE_SET              pPS;
    DWORD                       dwGrantedAccess;


    // See if we've got a cached security descriptor; if not, read one
    // from the file.

    if ( !pFile->fSecurityDescriptor )
    {
        DWORD                       dwError;
        DWORD                       dwInputSize;
        DWORD                       dwSizeNeeded;

        // Don't have one cached, need to read one. Allocate a buffer and
        // set up the basic information we need for this call.

        dwInputSize = SECURITY_DESC_DEFAULT_SIZE;
        pSecDesc = (PSECURITY_DESCRIPTOR)ALLOC( dwInputSize );

        if ( pSecDesc == NULL )
        {
            return FALSE;
        }

        for (;;)
        {
            // Try and read the security descriptor. If we can, then we're done
            // with this loop.
            if ( GetKernelObjectSecurity(
                    pFile->hOpenFile,
                    OWNER_SECURITY_INFORMATION |
                    GROUP_SECURITY_INFORMATION |
                    DACL_SECURITY_INFORMATION,
                    pSecDesc,
                    dwInputSize,
                    &dwSizeNeeded ) )
            {
                break;
            }

            // Couldn't read it. If it happened because our buffer was too
            // small, allocate a bigger one and try again. Otherwise so other
            // error happened. In that case we can't read the descriptor, so
            // return failure.

            dwError = GetLastError();

            FREE( pSecDesc );       // Don't need this anymore, in any case.

            if ( dwError != ERROR_INSUFFICIENT_BUFFER )
            {
                // Some other error, fail.

                return FALSE;
            }

            // Now try and allocate a buffer of the size the API said we need.

            dwInputSize = dwSizeNeeded;

            pSecDesc = (PSECURITY_DESCRIPTOR)ALLOC( dwInputSize );

            if ( pSecDesc == NULL )
            {
                return FALSE;
            }
        }
    }
    else
    {
        // Have one cached, use that.
        pSecDesc = pFile->abSecurityDescriptor;
    }

    // Have a security descriptor now, so do the check.

    pPS = (PPRIVILEGE_SET)cBuffer;
    dwPSSize = SIZE_PRIVILEGE_SET;
    pPS->PrivilegeCount = 0;

    if (
        !AccessCheck(
            pSecDesc,
            hUser,
            FILE_GENERIC_READ,
            &g_gmFile,
            pPS,
            &dwPSSize,
            &dwGrantedAccess,
            &bHaveAccess )
        )
    {
        bHaveAccess = FALSE;
    }

    // Free our temporary buffer if neccessary.

    if ( !pFile->fSecurityDescriptor )
    {
        FREE( pSecDesc );
    }

    return bHaveAccess;
}

dllexp
LPTS_OPEN_FILE_INFO
TsCreateFile(
    IN const TSVC_CACHE     &TSvcCache,
    IN      LPCSTR          pszName,
    IN      HANDLE          OpeningUser,
    IN      DWORD           dwOptions
    )
{
    HANDLE hFile;
    PVOID  pvBlob;
    PPHYS_OPEN_FILE_INFO lpPFInfo;
    LPTS_OPEN_FILE_INFO lpOpenFile;
    POPLOCK_OBJECT lpOplock;
    BOOL bSuccess;
    BOOL fAtRoot;
    BOOL fImpersonated = FALSE;
    DWORD dwSecDescSize;
    DWORD dwReadN;
    SECURITY_INFORMATION si
            = OWNER_SECURITY_INFORMATION
            | GROUP_SECURITY_INFORMATION
            | DACL_SECURITY_INFORMATION;
    PSECURITY_DESCRIPTOR abSecDesc;
    BOOL fDoReadObjectSecurity;
    BOOL fObjectSecurityPresent;
    BOOL fOplockSucceeded = TRUE;
    SECURITY_ATTRIBUTES sa;
    BOOL fPhysFileCacheHit = FALSE;
    BOOL fNoCanon = (dwOptions & TS_USE_WIN32_CANON) == 0;
    BOOL fAccess;
    DWORD dwGrantedAccess;
    DWORD dwPS;
    DWORD cch;
    DWORD cbPrefix;
    LPCSTR pszPath;
    WCHAR awchPath[MAX_PATH+8+1];
    BYTE psFile[SIZE_PRIVILEGE_SET];
    BOOL fDontUseSpud = (DisableSPUD || !fNoCanon);
    DWORD err;

    //
    // Mask out options that are not applicable
    //

    dwOptions &= TsValidCreateFileOptions;
    if ( TsIsWindows95() ) {
        dwOptions |= (TS_NO_ACCESS_CHECK | TS_DONT_CACHE_ACCESS_TOKEN);
    }

    //
    //  Have we cached a handle to this file?
    //

    if ( dwOptions & TS_CACHING_DESIRED )
    {

        bSuccess = TsCheckOutCachedBlob(  TSvcCache,
                                           pszName,
                                           RESERVED_DEMUX_OPEN_FILE,
                                           &pvBlob );

        if ( bSuccess )
        {

            ASSERT( BLOB_IS_OR_WAS_CACHED( pvBlob ) );

            //
            // The following is a brutal casting of PVOID to C++ object
            //  Well. there is no way to extract the object clearly from the
            //    memory map :(
            //

            lpOpenFile = (LPTS_OPEN_FILE_INFO )pvBlob;

            //
            //  Make sure the user tokens match
            //

            if ( (OpeningUser == lpOpenFile->QueryOpeningUser()
                    && NULL != lpOpenFile->QueryOpeningUser())
                    || (dwOptions & TS_NO_ACCESS_CHECK) )
            {
                ASSERT ( lpOpenFile->IsValid());
                TSUNAMI_TRACE( TRACE_OPENFILE_REFERENCE, lpOpenFile );

                return( lpOpenFile);
            }

            //
            //  User token doesn't match
            //

            if ( !g_fCacheSecDesc )
            {
                //
                // Check in object, will have to
                // open the file with the new user access token
                //

                bSuccess = TsCheckInCachedBlob( pvBlob );

                ASSERT( bSuccess );
            }
            else
            {
                //
                // attempt to validate access using cached
                // security descriptor
                //

                if ( lpOpenFile->IsSecurityDescriptorValid() )
                {
                    dwPS = sizeof( psFile );
                    ((PRIVILEGE_SET*)&psFile)->PrivilegeCount = 0;

                    if ( !AccessCheck(
                            lpOpenFile->GetSecurityDescriptor(),
                            OpeningUser,
                            FILE_GENERIC_READ,
                            &g_gmFile,
                            (PRIVILEGE_SET*)psFile,
                            &dwPS,
                            &dwGrantedAccess,
                            &fAccess ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                                "[TsCreateFile]: AccessCheck failed, error %d\n",
                                GetLastError() ));

                        fAccess = FALSE;
                    }

                    if ( fAccess )
                    {
                        return( lpOpenFile );
                    }
                }

                //
                // not validated using cached information
                //

                bSuccess = TsCheckInCachedBlob( pvBlob );

                ASSERT( bSuccess );

                if ( lpOpenFile->IsSecurityDescriptorValid() )
                {
                    return( NULL );
                }
            }
        }
    }

    if ( TsIsWindows95() )
    {
        fNoCanon = FALSE;
    }

    fDoReadObjectSecurity = FALSE;

    sa.nLength              = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle       = FALSE;

    IF_DEBUG(OPLOCKS) {
        DBGPRINTF( (DBG_CONTEXT,"TsCreateFile(%s) - Calling TsCheckOutCachedPhysFile\n", pszName ));
    }

    fPhysFileCacheHit = TsCheckOutCachedPhysFile( TSvcCache,
                                  pszName,
                                  (VOID **)&lpPFInfo );

    while (fPhysFileCacheHit)
    {
        DWORD           dwLastError;

        ASSERT( lpPFInfo->Signature == PHYS_OBJ_SIGNATURE );
        WAIT_FOR_PHYS_INIT_COMPLETE( lpPFInfo );

        hFile = lpPFInfo->hOpenFile;

        if (hFile != INVALID_HANDLE_VALUE)
        {
            break;
        }

        dwLastError = lpPFInfo->dwLastError;

        if (dwLastError != ERROR_FILE_NOT_FOUND &&
            dwLastError != ERROR_PATH_NOT_FOUND &&
            dwLastError != ERROR_INVALID_NAME )
        {
            fPhysFileCacheHit = TsReInitPhysFile(lpPFInfo);
        }
        else
        {
            TsRemovePhysFile(lpPFInfo);
            SetLastError(dwLastError);
            return NULL;
        }
    }

    if ( fPhysFileCacheHit )
    {

        DBG_ASSERT( hFile != INVALID_HANDLE_VALUE );

        abSecDesc = lpPFInfo->abSecurityDescriptor;
        dwSecDescSize = lpPFInfo->cbSecDescMaxSize;
        fObjectSecurityPresent = lpPFInfo->fSecurityDescriptor;

        //
        // We've got a file handle from the cache. If we're doing access
        // checking make sure we can use it.
        //
        if (!(dwOptions & TS_NO_ACCESS_CHECK))
        {
            if ( !TsAccessCheck(lpPFInfo, OpeningUser) )
            {
                // Don't have permission to use this handle, so fail.
                //
                TsCheckInOrFree( (PVOID)lpPFInfo );
                SetLastError(ERROR_ACCESS_DENIED);
                return NULL;
            }
        }


    } else {

        if ( lpPFInfo == NULL ) {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }

        ASSERT( lpPFInfo->Signature == PHYS_OBJ_SIGNATURE );

        if ( (dwOptions & TS_NOT_IMPERSONATED) &&
             !(dwOptions & TS_NO_ACCESS_CHECK) )
        {
            if ( !::ImpersonateLoggedOnUser( OpeningUser ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                    "ImpersonateLoggedOnUser[%d] failed with %d\n",
                    OpeningUser, GetLastError()));

                err = lpPFInfo->dwLastError;

                MARK_PHYS_INIT_COMPLETE( lpPFInfo );
                TsRemovePhysFile(lpPFInfo);

                SetLastError( err );
                return NULL;
            }
            fImpersonated = TRUE;
        }

        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCreateFile(%s) - Not in cache, Opening!\n", pszName ));
        }

        abSecDesc = lpPFInfo->abSecurityDescriptor;
        dwSecDescSize = lpPFInfo->cbSecDescMaxSize;
        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCreateFile(%s) - abSecDesc = %08lx, size = %08lx\n", pszName, abSecDesc, SECURITY_DESC_DEFAULT_SIZE ));
        }

        if ( abSecDesc == NULL ) {
            if( fImpersonated ) {
                ::RevertToSelf();
                fImpersonated = FALSE;
            }

            ASSERT( !fImpersonated );
            MARK_PHYS_INIT_COMPLETE( lpPFInfo );
            TsRemovePhysFile(lpPFInfo);
            SetLastError( ERROR_NOT_ENOUGH_MEMORY);
            return( NULL );
        }

        if ( fNoCanon )
        {
            if ( (pszName[0] == '\\') && (pszName[1] == '\\') )
            {
                CopyMemory(
                    awchPath,
                    L"\\\\?\\UNC\\",
                    (sizeof("\\\\?\\UNC\\")-1) * sizeof(WCHAR)
                    );

                cbPrefix = sizeof("\\\\?\\UNC\\")-1;
                pszPath = pszName + sizeof( "\\\\" ) -1;
            }
            else
            {
                CopyMemory(
                    awchPath,
                    L"\\\\?\\",
                    (sizeof("\\\\?\\")-1) * sizeof(WCHAR)
                    );

                cbPrefix = sizeof("\\\\?\\")-1;
                pszPath = pszName;
            }

            cch = MultiByteToWideChar( CP_ACP,
                                       MB_PRECOMPOSED,
                                       pszPath,
                                       -1,
                                       awchPath + cbPrefix,
                                       sizeof(awchPath)/sizeof(WCHAR) - cbPrefix );
            if ( !cch )
            {
                hFile = INVALID_HANDLE_VALUE;
            }
            else
            {
                if ( (pszName[1] == ':') && (pszName[2] == '\0') )
                {
                    wcscat( awchPath, L"\\" );
                }

                sa.nLength              = sizeof(sa);
                sa.lpSecurityDescriptor = NULL;
                sa.bInheritHandle       = FALSE;

#if 1
//                if ( fDontUseSpud ) {
                    hFile = CreateFileW( awchPath,
                                         GENERIC_READ,
                                         TsCreateFileShareMode,
                                         &sa,
                                         OPEN_EXISTING,
                                         TsCreateFileFlags,
                                         NULL );
#else
                } else {
                    lpOplock = ( POPLOCK_OBJECT )LocalAlloc(LPTR, sizeof(OPLOCK_OBJECT));

                    if ( lpOplock == NULL ) {
                        DBGPRINTF((DBG_CONTEXT,"LocalAlloc lpOplock[%s] failed with %d\n",
                            pszName, GetLastError()));

                        if ( fImpersonated ) {
                            ::RevertToSelf();
                            fImpersonated = FALSE;
                        }

                        MARK_PHYS_INIT_COMPLETE( lpPFInfo );
                        TsRemovePhysFile(lpPFInfo);

                        ASSERT( !fImpersonated );
                        return( NULL );
                    }

                    lpOplock->Signature = OPLOCK_OBJ_SIGNATURE;
                    lpOplock->lpPFInfo = NULL;
                    lpOplock->hOplockInitComplete = IIS_CREATE_EVENT(
                                                        "OPLOCK_OBJECT::hOplockInitComplete",
                                                        lpOplock,
                                                        TRUE,
                                                        FALSE
                                                        );

                    hFile = AtqCreateFileW( awchPath,
                                           TsCreateFileShareMode,
                                           &sa,
                                           TsCreateFileFlags,
                                           si,
                                           (PSECURITY_DESCRIPTOR)abSecDesc,
                                           ( ( g_fCacheSecDesc
                                             && !(dwOptions & TS_NO_ACCESS_CHECK)
                                             && (dwOptions & TS_CACHING_DESIRED) ) ?
                                           SECURITY_DESC_DEFAULT_SIZE : 0 ),
                                           &dwSecDescSize,
                                           OplockCreateFile,
                                           (PVOID)lpOplock );
                }
#endif //!oplock
            }
        }
        else
        {
            hFile = CreateFile(  pszName,
                                 GENERIC_READ,
                                 TsCreateFileShareMode,
                                 &sa,
                                 OPEN_EXISTING,
                                 TsCreateFileFlags,
                                 NULL );
        }

        //
        // If we're supposed to cache the security descriptor, do so now.
        // This should only be done once, by the thread intializing the physical
        // file entry.
        //

        if (DisableSPUD && hFile != INVALID_HANDLE_VALUE)
        {
            if ( g_fCacheSecDesc )
            {
                DWORD       dwInputSize;

                dwInputSize = dwSecDescSize;

                // Loop, reading the security info each time, until we either
                // read it succesfully, are unable to allocate a big enough buffer,
                // or get some error other than buffer too smal.

                for (;;)
                {

                    if ( GetKernelObjectSecurity(
                            hFile,
                            si,
                            (PSECURITY_DESCRIPTOR)lpPFInfo->abSecurityDescriptor,
                            dwInputSize,
                            &dwSecDescSize ) )
                    {
                        lpPFInfo->fSecurityDescriptor = TRUE ;
                        fObjectSecurityPresent = TRUE;
                        abSecDesc = (PSECURITY_DESCRIPTOR)lpPFInfo->abSecurityDescriptor;
                        dwSecDescSize = dwInputSize;
                        break;
                    }

                    // Had some sort of error on the attempt to get the security
                    // descriptor.

                    if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
                    {

                        // Need a bigger buffer for the descriptor.

                        IF_DEBUG(OPLOCKS) {
                            DBGPRINTF( (DBG_CONTEXT,"TsCreateFile() - Realloc Security Desc !!!\n" ));
                        }

                        FREE( lpPFInfo->abSecurityDescriptor );
                        lpPFInfo->abSecurityDescriptor = (PSECURITY_DESCRIPTOR)ALLOC( dwSecDescSize );

                        if ( lpPFInfo->abSecurityDescriptor == NULL )
                        {
                            CloseHandle( hFile );
                            MARK_PHYS_INIT_COMPLETE( lpPFInfo );
                            TsRemovePhysFile(lpPFInfo);

                            if ( fImpersonated )
                            {
                                ::RevertToSelf();
                            }

                            SetLastError( ERROR_NOT_ENOUGH_MEMORY);
                            return NULL;
                        }

                        dwInputSize = dwSecDescSize;

                    } else
                    {
                        // This wasn't too small a buffer, so quit trying.

                        dwSecDescSize = 0;

                        break;

                    }
                }
            }
        }
    }

    IF_DEBUG(OPLOCKS) {
        DBGPRINTF( (DBG_CONTEXT,"TsCreateFile(%s) - SECURITY_DESC_DEFAULT_SIZE = %08lx, dwSecDescSize = %08lx\n",
        pszName, SECURITY_DESC_DEFAULT_SIZE, dwSecDescSize ));
    }

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        DBGPRINTF((DBG_CONTEXT,"CreateFile[%s] failed with %d\n",
            pszName, GetLastError()));


        if ( fImpersonated ) {
            ::RevertToSelf();
            fImpersonated = FALSE;
        }

        if ( !fPhysFileCacheHit ) {
            lpPFInfo->dwLastError = GetLastError();
            MARK_PHYS_INIT_COMPLETE( lpPFInfo );
        }

        ASSERT( !fImpersonated );
        err = lpPFInfo->dwLastError;
        TsRemovePhysFile(lpPFInfo);
        SetLastError( err );
        return( NULL );
    }


    if ( !fDontUseSpud ) {

        if ( GetLastError() != ERROR_SUCCESS || fPhysFileCacheHit ) {
            fOplockSucceeded = FALSE;
        }
        if ( fPhysFileCacheHit || (dwSecDescSize == SECURITY_DESC_DEFAULT_SIZE ) ) {
                fObjectSecurityPresent = TRUE;
                lpPFInfo->fSecurityDescriptor = TRUE ;
        } else {
            if ( dwSecDescSize > SECURITY_DESC_DEFAULT_SIZE ) {
                fDoReadObjectSecurity = TRUE;

                dwSecDescSize = ( (dwSecDescSize + SECURITY_DESC_GRANULARITY - 1)
                      / SECURITY_DESC_GRANULARITY )
                    * SECURITY_DESC_GRANULARITY;

            } else {
                dwSecDescSize = 0;
            }

        }

    }

    //
    //  Increment the miss count after we've confirmed it's a valid resource
    //

    bSuccess = TsAllocateEx(  TSvcCache,
                            sizeof( TS_OPEN_FILE_INFO ),
                            &pvBlob,
                            DisposeOpenFileInfo );

    if ( !bSuccess )
    {
        if ( fImpersonated ) {
            ::RevertToSelf();
            fImpersonated = FALSE;
        }

        if ( !fPhysFileCacheHit ) {
            MARK_PHYS_INIT_COMPLETE( lpPFInfo );
        }

        ASSERT( !fImpersonated );
        TsRemovePhysFile(lpPFInfo);
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return( NULL );
    }

    lpOpenFile = (LPTS_OPEN_FILE_INFO)pvBlob;

    if ( !fPhysFileCacheHit )
    {
        lpPFInfo->hOpenFile = hFile;
        if (BLOB_IS_OR_WAS_CACHED( lpPFInfo ))
        {
            INC_COUNTER( TSvcCache.GetServiceId(), CurrentOpenFileHandles );
        }
    }

#if 0
    if ( !fDontUseSpud && !fPhysFileCacheHit ) {
        if ( fOplockSucceeded ) {
            lpOplock->lpPFInfo = lpPFInfo;
            SetEvent( lpOplock->hOplockInitComplete );
        } else {
            dwOptions &= ~TS_CACHING_DESIRED;
        }
    }
#endif //!oplock

    //
    //  The file must be fully qualified so it must be at least three characters
    //  plus the terminator
    //

    fAtRoot = (pszName[1] == ':' &&
              ((pszName[2] == '\\' && pszName[3] == '\0')
               || (pszName[2] == '\0')) );

    bSuccess = lpOpenFile->SetFileInfo( lpPFInfo,
        (dwOptions & TS_DONT_CACHE_ACCESS_TOKEN) ? NULL : OpeningUser,
        fAtRoot,
        dwSecDescSize );

    if (!fDontUseSpud)
        InsertHeadPhysFile( lpPFInfo, pvBlob );

    if ( fImpersonated ) {
        ::RevertToSelf();
        fImpersonated = FALSE;
    }

    //
    // Check if security descriptor to be read.
    // Failure to read it will not make TsCreateFile to fail :
    // security descriptor size may have grown since previous call
    //

    if ( fDoReadObjectSecurity )
    {

        FREE( abSecDesc );
        abSecDesc = (PSECURITY_DESCRIPTOR)ALLOC( dwSecDescSize );
        lpPFInfo->abSecurityDescriptor = abSecDesc;
        bSuccess = lpOpenFile->SetFileInfo( lpPFInfo,
            (dwOptions & TS_DONT_CACHE_ACCESS_TOKEN) ? NULL : OpeningUser,
            fAtRoot,
            dwSecDescSize );

        if ( GetKernelObjectSecurity(
                hFile,
                si,
                lpOpenFile->GetSecurityDescriptor(),
                dwSecDescSize,
                &dwReadN ) )
        {
sec_succ:
                lpOpenFile->SetSecurityDescriptorValid( TRUE );

        }
        else
        {
            ASSERT( GetLastError() != 0 );
        }
    }
    else if ( fObjectSecurityPresent )
    {
        goto sec_succ;
    }

    if ( !bSuccess)
    {

        //
        // Error in setting up the file information.
        //

        if ( !fPhysFileCacheHit ) {
            MARK_PHYS_INIT_COMPLETE( lpPFInfo );

#if 0
            if ( !fDontUseSpud && fOplockSucceeded ) {
                SetEvent( lpOplock->hOplockInitComplete );
            }
#endif //oplock

        }

        ASSERT( !fImpersonated );
        err = lpPFInfo->dwLastError;
        TsRemovePhysFile(lpPFInfo);
        SetLastError( err );
        return ( NULL);
    }

    //
    //  If this is a UNC connection check and make sure we haven't exceeded
    //  the maximum UNC handles we will cache (SMB FID limits count to 2048)
    //

    if ( !g_fDisableCaching &&
         (dwOptions & TS_CACHING_DESIRED ) &&
         (cCachedUNCHandles < MAX_CACHED_UNC_HANDLES ||
          pszName[1] != '\\') )
    {
        bSuccess = TsCacheDirectoryBlob(  TSvcCache,
                                           pszName,
                                           RESERVED_DEMUX_OPEN_FILE,
                                           pvBlob,
                                           TRUE );

        //
        //  Only count it if we successfully added the item to the
        //  cache
        //

        if ( bSuccess )
        {
            if ( pszName[1] == '\\' )
            {
                InterlockedIncrement( (LONG *) &cCachedUNCHandles );
            }

        }

    }
    else
    {
        //
        //  Too many cached UNC handles, don't cache it.  It would be nice
        //  to do an LRU for these handles but it's probably not generally
        //  worth it
        //

        bSuccess = FALSE;
    }

#if DBG
    if ( !bSuccess )
    {
        ASSERT( !BLOB_IS_OR_WAS_CACHED( pvBlob ) );
    }
    else
    {
        ASSERT( BLOB_IS_OR_WAS_CACHED( pvBlob ) );
    }
#endif
    if ( !fPhysFileCacheHit ) {
        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCreateFile(%s) - Not in cache, Open Complete Causing Event!\n", pszName ));
        }
        MARK_PHYS_INIT_COMPLETE( lpPFInfo );

#if 0
        if ( !fDontUseSpud && fOplockSucceeded ) {
            SetEvent( lpOplock->hOplockInitComplete );
        }
#endif //!oplock

    } else {
        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCreateFile(%s) - Already in cache, Open Complete!\n", pszName ));
        }
    }

    ASSERT( !fImpersonated );
    TSUNAMI_TRACE( TRACE_OPENFILE_CREATE, lpOpenFile );
    return( lpOpenFile );

} // TsCreateFile



dllexp
LPTS_OPEN_FILE_INFO
TsCreateFileFromURI(
    IN const TSVC_CACHE     &TSvcCache,
    IN      PW3_URI_INFO    pURIInfo,
    IN      HANDLE          OpeningUser,
    IN      DWORD           dwOptions,
    IN      DWORD           *dwError
    )

/*+++

    TsCreateFileFromURI

    This routine takes a (checked out) URI block and retrieves a file
    handle from it. If the file handle in the URI info block is valid and
    we have the right security for it, we'll use that. Otherwise if it's
    invalid we'll create a valid handle and save it. If it's valid but we
    don't have security for it we'll open a new handle but not cache it.

    Not caching a new handle may become a performance problem in the future
    if authenticated file access becomes common. There are several possible
    solutions to this problem if this occurs. One would be to have a list
    of cached TS_OPEN_FILE_INFO class structures chained off the URI block,
    one for each 'distinct' security class, and then select the best one to
    return. Another would be to have a second level of cache, i.e. put the
    URI blocks in a second hash table and keep one OPEN_FILE_INFO in the
    URI block, looking up other in the other hash table if we need to. Any
    solution would have to exhibit the property of being able to handle
    mapping from a single URI to multiple file handles.

    Arguments:

        TsvcCache   -
        pURIInfo    - A pointer to the URI block from which we're to derive
                        file information.
        OpeningUser - A handle identifying the opening used.
        dwOptions   - A set of options indicating how we're to open the file.

    Returns:

        A pointer to a TS_OPEN_FILE_INFO class structure if we're succesfull,
            or NULL if we're not.
---*/

{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    LPTS_OPEN_FILE_INFO lpOpenFile;
    POPLOCK_OBJECT lpOplock;
    BOOL fAtRoot;
    BOOL bSuccess;
    PVOID pvBlob;
    PPHYS_OPEN_FILE_INFO lpPFInfo;
    BOOL fImpersonated = FALSE;
    BOOL SPUDdidCall = FALSE;
    DWORD dwSecDescSize;
    BOOL fOplockSucceeded = FALSE;
    SECURITY_INFORMATION si
            = OWNER_SECURITY_INFORMATION
            | GROUP_SECURITY_INFORMATION
            | DACL_SECURITY_INFORMATION;
    SECURITY_ATTRIBUTES sa;
    BOOL fPhysFileCacheHit = FALSE;
    BOOL fNoCanon = (dwOptions & TS_USE_WIN32_CANON) == 0;
    BOOL fAccess;
    DWORD dwGrantedAccess;
    DWORD dwPS;
    DWORD cch;
    DWORD cbPrefix;
    LPCSTR pszPath;
    PCHAR pName;
    DWORD dwInputSize;
    WCHAR awchPath[MAX_PATH+8+1];
    BYTE psFile[SIZE_PRIVILEGE_SET];

    AcIncrement( CacOpenURI);

    ASSERT(pURIInfo != NULL);

    //
    // Mask out options that are not applicable
    //

    dwOptions &= TsValidCreateFileOptions;

    if ( TsIsWindows95() ) {
        dwOptions |= (TS_NO_ACCESS_CHECK | TS_DONT_CACHE_ACCESS_TOKEN);
    }

    *dwError = pURIInfo->dwFileOpenError;

    // Check to see if the open file info is valid. If it it, try to use it.

    if ( pURIInfo->bFileInfoValid )
    {


        // Get the open file info. If it's non-NULL (the file exists)
        // see if we have permission to access it.

        lpOpenFile = pURIInfo->pOpenFileInfo;

        //
        //  Make sure the user tokens match, or that lpOpenFile is NULL.
        //  In the latter case the file doesn't exist - this is a negative
        //  hit.
        //

        if (    ( lpOpenFile == NULL ) ||
                (OpeningUser == lpOpenFile->QueryOpeningUser()
                && lpOpenFile->QueryOpeningUser() != NULL)
                || (dwOptions & TS_NO_ACCESS_CHECK) )
        {

            return( lpOpenFile);
        }

        //
        //  User token doesn't match
        //

        if ( g_fCacheSecDesc )
        {

            //
            // attempt to validate access using cached
            // security descriptor
            //

            if ( lpOpenFile->IsSecurityDescriptorValid() )
            {
                dwPS = sizeof( psFile );
                ((PRIVILEGE_SET*)&psFile)->PrivilegeCount = 0;

                if ( !AccessCheck(
                        lpOpenFile->GetSecurityDescriptor(),
                        OpeningUser,
                        FILE_GENERIC_READ,
                        &g_gmFile,
                        (PRIVILEGE_SET*)psFile,
                        &dwPS,
                        &dwGrantedAccess,
                        &fAccess ) )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                            "[TsCreateFileFromURI]: AccessCheck failed, \
                            error %d\n",
                            GetLastError() ));

                    fAccess = FALSE;
                }

                // See if we have access to the file. If we get here we know
                // we have a valid security descriptor, so if we didn't get
                // access on this check then there's no point in attemptint to
                // open the file.

                if ( fAccess )
                {
                    return( lpOpenFile );
                }
                else
                {
                    *dwError = GetLastError();

                    return NULL;
                }

            }

        }
    }


    // At this point, either the file info in the structure isn't
    // valid, or we're not allowed to cache security descriptors, or
    // the cache descriptor isn't valid. In any of these cases we need
    // to try to open the file. If this succeeds and the file info in the
    // URI block isn't valid, save the newly opened file info there.
    //
    // If we open the file but the file info isn't valid, we'll tag the
    // open file info structure as non cached so that we won't try to
    // check it in later.
    //
    // Since the file info isn't valid, the error we set in *dwError
    // is bad also. All exits from this point on need to make sure to
    // set that to the proper value. We also want to update the cached
    // error in the URI info if we're going to make the file info valid.
    //
    //
    // Now try to open the actual file.
    //

    if ( TsIsWindows95() )
    {
        fNoCanon = FALSE;
    }

    sa.nLength              = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle       = FALSE;

    IF_DEBUG(OPLOCKS) {
        DBGPRINTF( (DBG_CONTEXT,"TsCreateFileFromURI(%s) - Calling TsCheckOutCachedPhysFile\n", pURIInfo->pszName ));
    }

    fPhysFileCacheHit = TsCheckOutCachedPhysFile( TSvcCache,
                                  pURIInfo->pszName,
                                  (VOID **)&lpPFInfo );

    while (fPhysFileCacheHit)
    {
        DWORD           dwLastError;

        ASSERT( lpPFInfo->Signature == PHYS_OBJ_SIGNATURE );
        WAIT_FOR_PHYS_INIT_COMPLETE( lpPFInfo );

        hFile = lpPFInfo->hOpenFile;

        if (hFile != INVALID_HANDLE_VALUE)
        {
            break;
        }

        dwLastError = lpPFInfo->dwLastError;

        if (dwLastError != ERROR_FILE_NOT_FOUND &&
            dwLastError != ERROR_PATH_NOT_FOUND &&
            dwLastError != ERROR_INVALID_NAME )
        {
            fPhysFileCacheHit = TsReInitPhysFile(lpPFInfo);
        }
        else
        {
            TsRemovePhysFile(lpPFInfo);
            SetLastError(dwLastError);
            *dwError = dwLastError;
            return NULL;
        }
    }

    if ( fPhysFileCacheHit )
    {

        dwSecDescSize = lpPFInfo->cbSecDescMaxSize;

        DBG_ASSERT(hFile != INVALID_HANDLE_VALUE);

        //
        // We've got a file handle from the cache. If we're doing access
        // checking make sure we can use it.
        //
        if (!(dwOptions & TS_NO_ACCESS_CHECK))
        {
            if ( !TsAccessCheck(lpPFInfo, OpeningUser) )
            {
                // Don't have permission to use this handle, so fail.
                //
                TsCheckInOrFree( (PVOID)lpPFInfo );
                SetLastError(ERROR_ACCESS_DENIED);
                *dwError = ERROR_ACCESS_DENIED;
                return NULL;
            }
        }

    } else {

        if ( lpPFInfo == NULL ) {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY);
            *dwError = ERROR_NOT_ENOUGH_MEMORY;
            return NULL;
        }

        ASSERT( lpPFInfo->Signature == PHYS_OBJ_SIGNATURE );

        //
        // If we're not impersonating right now, do that before we try to
        // open the file.
        //

        if ( (dwOptions & TS_NOT_IMPERSONATED) &&
             !(dwOptions & TS_NO_ACCESS_CHECK) )
        {
            if ( !::ImpersonateLoggedOnUser( OpeningUser ) )
            {
                *dwError = GetLastError();

                DBGPRINTF(( DBG_CONTEXT,
                    "ImpersonateLoggedOnUser[%d] failed with %d\n",
                    OpeningUser, *dwError));


                MARK_PHYS_INIT_COMPLETE( lpPFInfo );
                TsRemovePhysFile(lpPFInfo);
                return NULL;
            }

            fImpersonated = TRUE;
        }

        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCreateFileFromURI(%s) - Not in Cache, Opening!\n", pURIInfo->pszName ));
        }

        dwSecDescSize = lpPFInfo->cbSecDescMaxSize;
        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCreateFileFromURI(%s) - lpPFInfo->abSecurityDescriptor = %08lx, size = %08lx\n", pURIInfo->pszName, lpPFInfo->abSecurityDescriptor, SECURITY_DESC_DEFAULT_SIZE ));
        }

        if ( lpPFInfo->abSecurityDescriptor == NULL ) {
            goto not_enough_memory;
        }


        if ( fNoCanon )
        {
            if ( (pURIInfo->pszName[0] == '\\') && (pURIInfo->pszName[1] == '\\') )
            {
                CopyMemory(
                    awchPath,
                    L"\\\\?\\UNC\\",
                    (sizeof("\\\\?\\UNC\\")-1) * sizeof(WCHAR)
                    );

                cbPrefix = sizeof("\\\\?\\UNC\\")-1;
                pszPath = pURIInfo->pszName + sizeof( "\\\\" ) -1;
            }
            else
            {
                CopyMemory(
                    awchPath,
                    L"\\\\?\\",
                    (sizeof("\\\\?\\")-1) * sizeof(WCHAR)
                    );

                cbPrefix = sizeof("\\\\?\\")-1;
                pszPath = pURIInfo->pszName;
            }

            cch = MultiByteToWideChar( CP_ACP,
                                       MB_PRECOMPOSED,
                                       pszPath,
                                       -1,
                                       awchPath + cbPrefix,
                                       sizeof(awchPath)/sizeof(WCHAR) - cbPrefix );
            if ( !cch )
            {
                hFile = INVALID_HANDLE_VALUE;
            }
            else
            {
                if ( (pURIInfo->pszName[1] == ':') && (pURIInfo->pszName[2] == '\0') )
                {
                    wcscat( awchPath, L"\\" );
                }

                sa.nLength              = sizeof(sa);
                sa.lpSecurityDescriptor = NULL;
                sa.bInheritHandle       = FALSE;

#if 1
                //if ( DisableSPUD ) {
                    hFile = CreateFileW( awchPath,
                                         GENERIC_READ,
                                         TsCreateFileShareMode,
                                         &sa,
                                         OPEN_EXISTING,
                                         TsCreateFileFlags,
                                         NULL );
#else
                } else {

                    if ( g_fCacheSecDesc &&
                         !(dwOptions & TS_NO_ACCESS_CHECK) )
                    {
                        // Assume we can get by with the default size, and just allocate
                        // that.

                        lpOpenFile = ( LPTS_OPEN_FILE_INFO )LocalAlloc(LPTR,
                                                                sizeof(TS_OPEN_FILE_INFO));

                        IF_DEBUG(OPLOCKS) {
                            DBGPRINTF( (DBG_CONTEXT,"TsCreateFileFromURI(%s) - lpOpenFile = %08lx\n", pURIInfo->pszName, lpOpenFile ));
                        }

                        if (lpOpenFile == NULL)
                        {
                            // Couldn't get the memory we needed, so fail.

                            goto not_enough_memory;
                        }

                        lpOpenFile->SetFileInfo( lpPFInfo,
                            (dwOptions & TS_DONT_CACHE_ACCESS_TOKEN) ? NULL : OpeningUser,
                            FALSE,
                            dwSecDescSize );

                    }

                    SPUDdidCall = TRUE;

                    lpOplock = ( POPLOCK_OBJECT )LocalAlloc(LPTR, sizeof(OPLOCK_OBJECT));

                    if ( lpOplock == NULL ) {
                        LocalFree( lpOpenFile );
                        goto not_enough_memory;
                    }

                    lpOplock->Signature = OPLOCK_OBJ_SIGNATURE;
                    lpOplock->lpPFInfo = NULL;
                    lpOplock->hOplockInitComplete = IIS_CREATE_EVENT(
                                                        "OPLOCK_OBJECT::hOplockInitComplete",
                                                        lpOplock,
                                                        TRUE,
                                                        FALSE
                                                        );

                    hFile = AtqCreateFileW( awchPath,
                                           TsCreateFileShareMode,
                                           &sa,
                                           TsCreateFileFlags,
                                           si,
                                           (PSECURITY_DESCRIPTOR)lpOpenFile->GetSecurityDescriptor(),
                                           ( ( g_fCacheSecDesc
                                             && !(dwOptions & TS_NO_ACCESS_CHECK)) ?
                                           SECURITY_DESC_DEFAULT_SIZE : 0 ),
                                           &dwSecDescSize,
                                           OplockCreateFile,
                                           (PVOID)lpOplock );
                }
#endif //!oplock
            }
        }
        else
        {
            hFile = CreateFile(  pURIInfo->pszName,
                                 GENERIC_READ,
                                 TsCreateFileShareMode,
                                 &sa,
                                 OPEN_EXISTING,
                                 TsCreateFileFlags,
                                 NULL );
        }

        //
        // If we're supposed to cache the security descriptor, do so now.
        // This should only be done once, by the thread intializing the physical
        // file entry.
        //

        if (DisableSPUD && hFile != INVALID_HANDLE_VALUE)
        {
            if ( g_fCacheSecDesc )
            {
                dwInputSize = dwSecDescSize;

                // Loop, reading the security info each time, until we either
                // read it succesfully, are unable to allocate a big enough buffer,
                // or get some error other than buffer too smal.

                for (;;)
                {

                    if ( GetKernelObjectSecurity(
                            hFile,
                            si,
                            (PSECURITY_DESCRIPTOR)lpPFInfo->abSecurityDescriptor,
                            dwInputSize,
                            &dwSecDescSize ) )
                    {
                        lpPFInfo->fSecurityDescriptor = TRUE ;
                        dwSecDescSize = dwInputSize;
                        break;
                    }

                    // Had some sort of error on the attempt to get the security
                    // descriptor.

                    if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
                    {

                        // Need a bigger buffer for the descriptor.

                        IF_DEBUG(OPLOCKS) {
                            DBGPRINTF( (DBG_CONTEXT,"TsCreateFileFromURI(%s) - Realloc Security Desc !!!\n", pURIInfo->pszName ));
                        }

                        FREE( lpPFInfo->abSecurityDescriptor );
                        lpPFInfo->abSecurityDescriptor = (PSECURITY_DESCRIPTOR)ALLOC( dwSecDescSize );

                        if ( lpPFInfo->abSecurityDescriptor == NULL )
                        {
                            CloseHandle( hFile );
                            goto not_enough_memory;
                        }

                        dwInputSize = dwSecDescSize;

                    } else
                    {
                        // This wasn't too small a buffer, so quit trying.

                        dwSecDescSize = 0;

                        break;

                    }
                }
            }
        }
    }

    if ( hFile != INVALID_HANDLE_VALUE )
    {
        AcIncrement( AacOpenURIFiles);

        if ( !fPhysFileCacheHit ) {
            lpPFInfo->hOpenFile = hFile;

            if (BLOB_IS_OR_WAS_CACHED( lpPFInfo ))
            {
                INC_COUNTER( TSvcCache.GetServiceId(), CurrentOpenFileHandles );
            }
        }

        //
        // If we're supposed to cache the security descriptor we'll do that
        // now. In order to do this we need to allocate the OPEN_FILE_INFO
        // structure that we'll use.
        //

#if 1 // Oplocks are always disabled
        //if ( DisableSPUD ) {

            lpOpenFile = ( LPTS_OPEN_FILE_INFO )LocalAlloc(LPTR,
                                                    sizeof(TS_OPEN_FILE_INFO));


            if (lpOpenFile == NULL)
            {
                // Couldn't get the memory we needed, so fail.

                goto not_enough_memory;
            }
#else
        } else {

            if ( !fPhysFileCacheHit ) {
                if ( GetLastError() == ERROR_SUCCESS ) {
                    fOplockSucceeded = TRUE;
                }
                if ( g_fCacheSecDesc &&
                     !(dwOptions & TS_NO_ACCESS_CHECK) )
                {
                    dwInputSize = dwSecDescSize;

                    if (dwSecDescSize > SECURITY_DESC_DEFAULT_SIZE ) {

                        PSECURITY_DESCRIPTOR TmpSd;

                        TmpSd = lpOpenFile->GetSecurityDescriptor();

                        FREE( TmpSd );
                        TmpSd = (PSECURITY_DESCRIPTOR)ALLOC( dwSecDescSize );
                        lpPFInfo->abSecurityDescriptor = TmpSd;

                        if ( TmpSd == NULL )
                        {
                            LocalFree( lpOpenFile );
                            goto not_enough_memory;
                        }

                        lpOpenFile->SetFileInfo( lpPFInfo,
                            (dwOptions & TS_DONT_CACHE_ACCESS_TOKEN) ? NULL : OpeningUser,
                            FALSE,
                            dwSecDescSize );

                        // Now loop, reading the security info each time, until we either
                        // read it succesfully, are unable to allocate a big enough buffer,
                        // or get some error other than buffer too smal.


                        if ( !GetKernelObjectSecurity(
                                hFile,
                                si,
                                (PSECURITY_DESCRIPTOR)lpOpenFile->GetSecurityDescriptor(),
                                dwInputSize,
                                &dwSecDescSize ) )
                        {

                            // Had some sort of error on the attempt to get the security
                            // descriptor.

                            // This wasn't too small a buffer, so quit trying.

                            dwSecDescSize = 0;

                        }
                        lpPFInfo->fSecurityDescriptor = TRUE ;

                    } else {
                        lpPFInfo->fSecurityDescriptor = TRUE ;
                    }

                } else {
                    lpOpenFile = ( LPTS_OPEN_FILE_INFO )LocalAlloc(LPTR,
                                                            sizeof(TS_OPEN_FILE_INFO));

                    IF_DEBUG(OPLOCKS) {
                        DBGPRINTF( (DBG_CONTEXT,"TsCreateFileFromURI(%s) - lpOpenFile = %08lx\n", pURIInfo->pszName, lpOpenFile ));
                    }

                    if (lpOpenFile == NULL)
                    {
                        // Couldn't get the memory we needed, so fail.

                        goto not_enough_memory;
                    }

                }
            } else {
                lpOpenFile = ( LPTS_OPEN_FILE_INFO )LocalAlloc(LPTR,
                                                        sizeof(TS_OPEN_FILE_INFO));

                IF_DEBUG(OPLOCKS) {
                    DBGPRINTF( (DBG_CONTEXT,"TsCreateFileFromURI(%s) - lpOpenFile = %08lx\n", pURIInfo->pszName, lpOpenFile ));
                }

                if (lpOpenFile == NULL)
                {
                    // Couldn't get the memory we needed, so fail.

                    goto not_enough_memory;
                }

            }
        }
#endif //!oplock

        *dwError = ERROR_SUCCESS;
        lpOpenFile->SetCachedFlag(TRUE);

        //
        //  The file must be fully qualified so it must be at least three
        //  characters plus the terminator
        //

        pName = pURIInfo->pszName;

        fAtRoot = (pName[1] == ':' &&
                  ((pName[2] == '\\' && pName[3] == '\0')
                   || (pName[2] == '\0')) );

        bSuccess = lpOpenFile->SetFileInfo( lpPFInfo,
            (dwOptions & TS_DONT_CACHE_ACCESS_TOKEN) ? NULL : OpeningUser,
            fAtRoot,
            dwSecDescSize );

        if ( !bSuccess )
        {
            if ( fImpersonated ) {
                ::RevertToSelf();
                fImpersonated = FALSE;
            }

            AcDecrement( AacOpenURIFiles);

            LocalFree(lpOpenFile);

            *dwError = GetLastError();

            if ( !fPhysFileCacheHit ) {
                MARK_PHYS_INIT_COMPLETE( lpPFInfo );
#if 0 //!oplock
                if ( !DisableSPUD && fOplockSucceeded ) {
                    SetEvent( lpOplock->hOplockInitComplete );
                }
#endif
            }

            ASSERT( !fImpersonated );
            TsRemovePhysFile(lpPFInfo);
            return NULL;
        }

    }
    else
    {

        if ( !fPhysFileCacheHit ) {
            lpPFInfo->dwLastError = GetLastError();
        } else {
            SetLastError(lpPFInfo->dwLastError);
        }

        IF_DEBUG(ERROR) {
            DBGPRINTF((DBG_CONTEXT,"Create file[%s] failed with %d\n",
                pURIInfo->pszName, GetLastError()));
        }

        //
        // Couldn't open the file! If the reason we failed was because
        // the file or path didn't exist, cache this information.
        //

        *dwError = GetLastError();

        //
        // if this is win95 (does not support dir opens),
        // do the right thing.
        //

        if ( TsNoDirOpenSupport ) {

            DBG_ASSERT(TsIsWindows95());
            goto no_dir_open_support;
        }

        if ( fImpersonated ) {
            ::RevertToSelf();
            fImpersonated = FALSE;
        }

        if (*dwError != ERROR_FILE_NOT_FOUND &&
            *dwError != ERROR_PATH_NOT_FOUND &&
            *dwError != ERROR_INVALID_NAME )
        {

            // Not a 'not found error'. We don't cache those.

            lpPFInfo->hOpenFile = INVALID_HANDLE_VALUE;
            if ( !fPhysFileCacheHit ) {
                MARK_PHYS_INIT_COMPLETE( lpPFInfo );
#if 0
                if ( !DisableSPUD && fOplockSucceeded ) {
                    SetEvent( lpOplock->hOplockInitComplete );
                }
#endif //!oplock
            }

            ASSERT( !fImpersonated );
            TsRemovePhysFile(lpPFInfo);
            return( NULL );
        }

        // Go ahead and set the file info structure to valid, or try to. We
        // use compare and exchange to handle the race condition where the
        // file is open by someone else, and has been deleted while the handle
        // is still open. but we couldn't use the cached values because of
        // lack of a security descriptor. In this case we could get file not
        // found when the file info in the cached URI block is valid for
        // someone else. We don't want to blindly stomp the information in
        // that case. Note that since the cached pOpenFileInfo field is
        // initialized to NULL, all we need to do is set bFileInfoValid to
        // TRUE.

        if (!pfnInterlockedCompareExchange( (PVOID *)&pURIInfo->bFileInfoValid,
                                         (PVOID)TRUE,
                                         FALSE) )
        {
            // The compare&exchange worked, so we now officially have
            // a negatively cached file. Go ahead and save the error
            // value in the URI info.

            pURIInfo->dwFileOpenError = *dwError;

        }

        if ( !fPhysFileCacheHit ) {
            MARK_PHYS_INIT_COMPLETE( lpPFInfo );
#if 0
            if ( !DisableSPUD && fOplockSucceeded ) {
                SetEvent( lpOplock->hOplockInitComplete );
            }
#endif //!oplock
        }
        TsRemovePhysFile( lpPFInfo );

        ASSERT( !fImpersonated );
        lpOpenFile = NULL;
        return lpOpenFile;

    }

    // We're all done with file operations now, so revert back to who we were.
    if ( fImpersonated ) {
        ::RevertToSelf();
        fImpersonated = FALSE;
    }

    // OK, at this point we have an LP_OPEN_FILE info, or the file doesn't
    // exist. If the file info in the URI block isn't valid, save this now.

    if ( !pURIInfo->bFileInfoValid )
    {
        PVOID           Temp;

        // Now that we've opened the file, set the information to valid.

        Temp = pfnInterlockedCompareExchange( (PVOID *)&pURIInfo->pOpenFileInfo,
                                           lpOpenFile,
                                           NULL
                                         );
        if ( Temp == NULL )
        {
            // The exchange worked. A few notes are in order: if we're
            // caching a negative hit, we wouldn't have come through
            // this path, we'd have gone through the code above where
            // we do a compate&exchange on bFileInfoValid. There is a
            // race between that code and this - if one thread opens the
            // file, the file is deleted, and another thread fails to
            // open the file we have a race. In that race this code path
            // always wins. Either we get here first and set bFileInfoValid
            // to TRUE so the negative hit cache c&e fails, or the negative
            // c&e succeeds in setting it to TRUE, and then we set the
            // file info pointer to a valid file and set bFileInfo to TRUE
            // also. In either case we end up with bFileInfo at TRUE and
            // a valid pOpenFileInfo pointer. It is possible in this case
            // that the cached file open error will be incorrect, but that's
            // OK because this is valid only when the return from this
            // function is NULL. In any case, this is a transitory state. A
            // change notify should fire shortly after this race and clean
            // all of this mess up.

            pURIInfo->bFileInfoValid = TRUE;

            pURIInfo->dwFileOpenError = ERROR_SUCCESS; // For debugging purposes.

            if ( lpOpenFile != NULL )
            {
                TsIncreaseFileHandleCount( FALSE );
            }
        }
        else
        {

            // The exchange didn't work, which means someone else snuck
            // in and set it to valid while we were doing this. In this
            // case mark our file info as not cached.

            ASSERT(pURIInfo->bFileInfoValid);

            if (lpOpenFile != NULL)
            {
                lpOpenFile->SetCachedFlag(FALSE);
                *dwError = ERROR_SUCCESS;
            }
        }
    }
    else
    {
        // The cached file info is already valid. This could be because of a
        // race and someone else got here first, or it could be because we
        // had a valid cached file before but the security tokens don't match.
        // Either way, mark the open file info as not cached so the handle gets
        // closed when we're done.


        if (lpOpenFile != NULL)
        {
            lpOpenFile->SetCachedFlag(FALSE);
            *dwError = ERROR_SUCCESS;
        }

    }

#if 0
    SetEvent( pURIInfo->hFileEvent );

    // And now we're done.
    if ( (lpOpenFile != NULL) && !DisableSPUD ) {
        InsertHeadPhysFile( lpPFInfo, (PVOID)pURIInfo );
    }

    if ( !DisableSPUD && !fPhysFileCacheHit && fOplockSucceeded ) {
        lpOplock->lpPFInfo = lpPFInfo;
        SetEvent( lpOplock->hOplockInitComplete );
    }
#endif //!oplock

    if ( !fPhysFileCacheHit ) {
        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCreateFileFromURI(%s) - Not in Cache, Open Complete Causing Event!\n", pURIInfo->pszName ));
        }
        if ( lpOpenFile != NULL ) {
            MARK_PHYS_INIT_COMPLETE( lpPFInfo );
        }
    } else {
        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCreateFileFromURI(%s) - In Cache, Open Complete!\n", pURIInfo->pszName ));
        }
    }

    ASSERT( !fImpersonated );
    return lpOpenFile;

not_enough_memory:

    if ( fImpersonated ) {
        ::RevertToSelf();
        fImpersonated = FALSE;
    }

    ASSERT( lpPFInfo != NULL );
    if ( !fPhysFileCacheHit )
    {
        MARK_PHYS_INIT_COMPLETE( lpPFInfo );
        TsRemovePhysFile(lpPFInfo);
    }
    else
    {
        TsCheckInOrFree( (PVOID)lpPFInfo );
    }

    ASSERT( !fImpersonated );
    SetLastError( ERROR_NOT_ENOUGH_MEMORY);
    *dwError = ERROR_NOT_ENOUGH_MEMORY;
    return( NULL );

no_dir_open_support:

    //
    // This is to support win95 where opening directories are not
    // allowed.
    //

    DWORD dwAttributes;
    BOOL fDirectory = FALSE;

    if ( fImpersonated ) {
        ::RevertToSelf();
        fImpersonated = FALSE;
    }

    //
    // if this is not a directory, fail it.
    //

    dwAttributes = GetFileAttributes(pURIInfo->pszName);
    if( dwAttributes != (DWORD)-1) {
        if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            fDirectory = TRUE;
        }
    }

    if (!fDirectory) {
        IF_DEBUG(ERROR) {
            DBGPRINTF((DBG_CONTEXT,"Not a directory[%x]. Fail\n",
                    dwAttributes ));
        }

        ASSERT( !fImpersonated );
        return( NULL );
    }

    lpOpenFile = (LPTS_OPEN_FILE_INFO)LocalAlloc(LPTR,
                                            sizeof(TS_OPEN_FILE_INFO));

    if (lpOpenFile == NULL) {

        //
        // Couldn't get the memory we needed, so fail.
        //

        DBGPRINTF((DBG_CONTEXT,"Cannot allocate memory for file info[%d]\n",
                   GetLastError()));
        goto not_enough_memory;
    }

    //
    // set properties
    //

    lpPFInfo->hOpenFile = BOGUS_WIN95_DIR_HANDLE;

    lpOpenFile->SetFileInfo(lpPFInfo,
                            NULL,
                            FALSE,
                            0,
                            dwAttributes
                            );

    ASSERT( !fImpersonated );
    return lpOpenFile;

} // TsCreateFileFromURI



dllexp
BOOL
TsCloseHandle(
    IN const TSVC_CACHE     &TSvcCache,
    IN LPTS_OPEN_FILE_INFO  lpOpenFile
    )
{
    PVOID pvBlob;
    BOOL bSuccess;

    ASSERT( lpOpenFile != NULL );
    TSUNAMI_TRACE( TRACE_OPENFILE_CLOSE, lpOpenFile );

    pvBlob = ( PVOID )lpOpenFile;

    bSuccess = TsCheckInOrFree( pvBlob );

    return( bSuccess );
} // TsCloseHandle

dllexp
BOOL
TsCloseURIFile(
    IN LPTS_OPEN_FILE_INFO  lpOpenFile
    )
{

    PVOID pvBlob;

    AcIncrement( CacCloseURI);
    if ( lpOpenFile != NULL ) {

        if ( !lpOpenFile->QueryCachedFlag() )
        {
            // This file isn't actually part of a URI cache block, so
            // close it.


            AcDecrement( AacOpenURIFiles);

            if ( lpOpenFile->QueryFileHandle() != BOGUS_WIN95_DIR_HANDLE ) {
                pvBlob = ( PVOID )lpOpenFile->QueryPhysFileInfo();
                TsCheckInOrFree( pvBlob );
            }

            LocalFree( lpOpenFile);
        }
    }

    return TRUE;

} // TsCloseURIFile

dllexp
BOOL TsCreateETagFromHandle(
    IN      HANDLE          hFile,
    IN      PCHAR           ETag,
    IN      BOOL            *bWeakETag
    )
/*+++

    TsCreateETagFromHandle

    This routine takes a file handle as input, and creates an ETag in
    the supplied buffer for that file handle.

    Arguments:

    hFile           - File handle for which to create an ETag.
    ETag            - Where to store the ETag. This must be long
                        enough to hold the maximum length ETag.
    bWeakETag       - Set to TRUE if the newly created ETag is weak.

    Returns:

        TRUE if we create an ETag, FALSE otherwise.
---*/
{
    BY_HANDLE_FILE_INFORMATION  FileInfo;
    BOOL                        bReturn;
    PUCHAR                      Temp;
    FILETIME                    ftNow;
    SYSTEMTIME                  stNow;
    MB                          mb( (IMDCOM*) IIS_SERVICE::QueryMDObject()  );
    DWORD                       dwChangeNumber;


    bReturn  = GetFileInformationByHandle(
                                    hFile,
                                    &FileInfo
                                    );

    if (!bReturn)
    {
        return FALSE;
    }

    dwChangeNumber = 0;
    mb.GetSystemChangeNumber(&dwChangeNumber);

    FORMAT_ETAG(ETag, FileInfo.ftLastWriteTime, dwChangeNumber );

    ::GetSystemTime(&stNow);

    if (::SystemTimeToFileTime((CONST SYSTEMTIME *)&stNow, &ftNow))
    {
        __int64 iNow, iFileTime;

        iNow = (__int64)*(__int64 UNALIGNED *)&ftNow;

        iFileTime = (__int64)*(__int64 UNALIGNED *)&FileInfo.ftLastWriteTime;

        if ((iNow - iFileTime) > STRONG_ETAG_DELTA )
        {
            *bWeakETag = FALSE;
        }
        else
        {
            *bWeakETag = TRUE;
        }

        return TRUE;
    }

    return FALSE;

}

dllexp
BOOL TsLastWriteTimeFromHandle(
    IN      HANDLE          hFile,
    IN      FILETIME        *tm
    )
/*+++

    TsLastWriteTimeFromHandle

    This routine takes a file handle as input, and returns the last write time
    for that handle.

    Arguments:

    hFile           - File handle for which to get the last write time.
    tm              - Where to return the last write time.

    Returns:

        TRUE if we succeed, FALSE otherwise.
---*/
{
    BY_HANDLE_FILE_INFORMATION  FileInfo;
    BOOL                        bReturn;

    bReturn  = GetFileInformationByHandle(
                                    hFile,
                                    &FileInfo
                                    );

    if (!bReturn)
    {
        return FALSE;
    }

    *tm = FileInfo.ftLastWriteTime;

    return TRUE;
}




const char * g_IISAuxCounterNames[] =
{
    "Aac Open URI Files",
    "Cac Calls to TsOpenURI()",
    "Cac Calls to TsCloseURI()",
    "Max Counters"
};



extern "C"
VOID
TsDumpCacheCounters( OUT CHAR * pchBuffer, IN OUT LPDWORD lpcbBuffer )
{
    DWORD  cb = 0;

    DBG_ASSERT( NULL != lpcbBuffer);

    if ( *lpcbBuffer > 30) {
        cb = wsprintf( pchBuffer, " IIS Cache Aux Counters. <p> <UL>");
    } else {
        cb = 30;
    }

    for ( DWORD i = 0; i < AacIISCacheMaxCounters; i++) {

        if ( *lpcbBuffer > cb + 30) {
            cb += wsprintf( pchBuffer + cb, " <LI> %s  = %d",
                            g_IISAuxCounterNames[i],
                            AcCounter(i));
        } else {
            cb += 30;
        }
    } // for

    if ( *lpcbBuffer > cb + 5) {
        cb += wsprintf( pchBuffer + cb, " </UL> ");
    } else {
        cb += 5;
    }

    *lpcbBuffer = cb;
    return ;
} // TsDumpCacheCounters()






=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\dirchngp.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        dirchngp.cxx

   Abstract:
        This module contains the internal directory change routines

   Author:
        Murali R. Krishnan    ( MuraliK )     16-Jan-1995

--*/

#include "TsunamiP.Hxx"
#pragma hdrstop

#include "issched.hxx"
#include "dbgutil.h"
#include <lonsi.hxx>

//
//  Manifests
//

//
//  Globals
//

HANDLE g_hChangeWaitThread = NULL;
LONG   g_nTsunamiThreads = 0;

//
//  Local prototypes
//

#if DBG
VOID
DumpCacheStructures(
    VOID
    );
#endif

VOID
Apc_ChangeHandler(
    DWORD        dwErrorCode,
    DWORD        dwBytesWritten,
    LPOVERLAPPED lpo
    )
{
    PVIRTUAL_ROOT_MAPPING   pVrm;
    PDIRECTORY_CACHING_INFO pDci;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pNextEntry;
    BOOLEAN                 bSuccess;
    PCACHE_OBJECT           pCache;
    FILE_NOTIFY_INFORMATION *pNI;
    LPBYTE                  pMax;

    //
    //  The cache lock must always be taken before the root lock
    //

    EnterCriticalSection( &CacheTable.CriticalSection );
    EnterCriticalSection( &csVirtualRoots );

    pVrm = (VIRTUAL_ROOT_MAPPING *) lpo->hEvent;
    ASSERT( pVrm->Signature == VIRT_ROOT_SIGNATURE );
    ASSERT( pVrm->cRef > 0 );

    //
    //  Is this item still active?
    //

    if ( pVrm->fDeleted )
    {
        IF_DEBUG( DIRECTORY_CHANGE ) {
            DBGPRINTF(( DBG_CONTEXT,
                        "Got APC for root that has been removed\n" ));
        }

        DereferenceRootMapping( pVrm );
        goto Exit;
    }

    pDci = ( PDIRECTORY_CACHING_INFO )( pVrm + 1 );

    //
    //  It's possible (though unlikely) we received a notification for the
    //  same item that was removed then added before we did a wait on the
    //  new item.  This is the old notify event then.
    //

    if ( !pDci->fOnSystemNotifyList )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Old APC notification for %s\n",
                    pVrm->pszDirectoryA ));

        goto Exit;
    }

    ASSERT( pVrm->fCachingAllowed );


    IF_DEBUG( DIRECTORY_CHANGE ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "Got APC thing for %s.\n",
                    pVrm->pszDirectoryA ));
    }

    //
    // Convert NotifyInfo from Unicode to Ansi
    //

    if ( dwBytesWritten )
    {
        for ( pNI = &pDci->NotifyInfo,
              pMax = (LPBYTE)pNI + sizeof(pDci->NotifyInfo) + sizeof(pDci->szPathNameBuffer) ;; )
        {
            CHAR achAnsi[MAX_PATH+1];

            pNI->FileNameLength = WideCharToMultiByte( CP_ACP,
                    WC_COMPOSITECHECK,
                    pNI->FileName,
                    pNI->FileNameLength / sizeof(WCHAR),
                    achAnsi,
                    MAX_PATH,
                    NULL,
                    NULL );
            memcpy( pNI->FileName, achAnsi, pNI->FileNameLength );

            if ( pNI->NextEntryOffset )
            {
                pNI = (FILE_NOTIFY_INFORMATION*)(((LPBYTE)pNI) + pNI->NextEntryOffset);
            }
            else
            {
                break;
            }
        }
    }

    for ( pEntry = pDci->listCacheObjects.Flink;
          pEntry != &pDci->listCacheObjects;
          pEntry = pNextEntry )
    {
        pNextEntry = pEntry->Flink;

        pCache = CONTAINING_RECORD( pEntry, CACHE_OBJECT, DirChangeList );

        if ( dwBytesWritten &&
             ( pCache->iDemux == RESERVED_DEMUX_OPEN_FILE ||
               pCache->iDemux == RESERVED_DEMUX_URI_INFO ) )
        {
            for ( pNI = &pDci->NotifyInfo ;; )
            {
                if ( pCache->iDemux == RESERVED_DEMUX_URI_INFO
                     ? ( ((PW3_URI_INFO)(pCache->pbhBlob+1))->cchName - pVrm->cchDirectoryA -1 == pNI->FileNameLength &&
                        !_memicmp( (LPSTR)pNI->FileName,
                            ((PW3_URI_INFO)(pCache->pbhBlob+1))->pszName + pVrm->cchDirectoryA + 1,
                            pNI->FileNameLength ) )
                     : ( pCache->cchLength - pVrm->cchDirectoryA -1 == pNI->FileNameLength &&
                         !_memicmp( pCache->szPath + pVrm->cchDirectoryA + 1,
                                    pNI->FileName,
                                    pNI->FileNameLength ) ) )
                {
                    IF_DEBUG( DIRECTORY_CHANGE ) {

                        DBGPRINTF(( DBG_CONTEXT,
                                    "Expired entry for: %s.\n", pCache->szPath ));
                    }

                    bSuccess = DeCache( pCache, FALSE );

                    ASSERT( bSuccess );

                    break;
                }

                if ( pNI->NextEntryOffset )
                {
                    pNI = (FILE_NOTIFY_INFORMATION*)(((LPBYTE)pNI) + pNI->NextEntryOffset);
                }
                else
                {
                    break;
                }
            }
        }
        else
            if ( pCache->iDemux != RESERVED_DEMUX_PHYSICAL_OPEN_FILE )
                {
                    IF_DEBUG( DIRECTORY_CHANGE ) {

                        DBGPRINTF(( DBG_CONTEXT,
                                    "Expired entry for: %s.\n", pCache->szPath ));
                    }

                    bSuccess = DeCache( pCache, FALSE );

                    ASSERT( bSuccess );
                }
    }

    INC_COUNTER( pVrm->dwServiceID,
                 FlushesFromDirChanges );

    if ( !pfnReadDirChangesW( pDci->hDirectoryFile,
                                 (VOID *) &pDci->NotifyInfo,
                                 sizeof( FILE_NOTIFY_INFORMATION ) +
                                    sizeof( pDci->szPathNameBuffer ),
                                 TRUE,
                                 FILE_NOTIFY_VALID_MASK &
                                    ~FILE_NOTIFY_CHANGE_LAST_ACCESS,
                                 NULL,
                                 &pDci->Overlapped,   // hEvent used as context
                                 Apc_ChangeHandler ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[ApchChangeHandler] ReadDirectoryChanges returned %d\n",
                    GetLastError() ));

        //
        //  Disable caching for this directory 'cause we aren't going to get any
        //  more change notifications
        //

        pVrm->fCachingAllowed = FALSE;

        CLOSE_DIRECTORY_HANDLE( pDci );

        //
        //  Decrement the ref-count as we'll never get an APC notification
        //

        DereferenceRootMapping( pVrm );
    }

Exit:
    LeaveCriticalSection( &csVirtualRoots );
    LeaveCriticalSection( &CacheTable.CriticalSection );

} // Apc_ChangeHandler




DWORD
WINAPI
ChangeWaitThread(
        PVOID pvParam
        )
{
    PLIST_ENTRY             pEntry;
    PVIRTUAL_ROOT_MAPPING   pVrm;
    PDIRECTORY_CACHING_INFO pDci;
    DWORD                   dwWaitResult;
    HANDLE                  ahEvents[2];

    InterlockedIncrement( &g_nTsunamiThreads );
    ahEvents[0] = g_hQuit;
    ahEvents[1] = g_hNewItem;

    do
    {
        //
        //  Loop through the list looking for any directories which haven't
        //  been added yet
        //

        EnterCriticalSection( &csVirtualRoots );

        for (  pEntry =  GlobalVRootList.Flink;
               pEntry != &GlobalVRootList;
               pEntry =  pEntry->Flink ) {

            pVrm = CONTAINING_RECORD( pEntry,
                                      VIRTUAL_ROOT_MAPPING,
                                      GlobalListEntry );

            pDci = ( PDIRECTORY_CACHING_INFO )( pVrm + 1 );

            ASSERT( pVrm->Signature == VIRT_ROOT_SIGNATURE );

            if ( !pDci->fOnSystemNotifyList ) {

                //
                // call change notify, this indicates we want change notifications
                // on this set of handles.  Note the wait is a one shot deal,
                // once a dir has been notified, it must be readded in the
                // context of this thread.
                //

                IF_DEBUG( DIRECTORY_CHANGE )
                    DBGPRINTF(( DBG_CONTEXT,
                                "Trying to wait on %S\n",
                                pVrm->pszDirectoryA ));

                //
                //  Use the hEvent field of the overlapped structure as the
                //  context to pass to the change handler.  This is allowed
                //  by the ReadDirectoryChanges API
                //

                pDci->Overlapped.hEvent = (HANDLE) pVrm;

                //
                //  If the memory cache size is zero, don't worry about
                //  change notifications
                //

                if ( !pfnReadDirChangesW( pDci->hDirectoryFile,
                                             (VOID *) &pDci->NotifyInfo,
                                             sizeof( FILE_NOTIFY_INFORMATION ) +
                                                sizeof( pDci->szPathNameBuffer ),
                                             TRUE,
                                             FILE_NOTIFY_VALID_MASK &
                                                ~FILE_NOTIFY_CHANGE_LAST_ACCESS,
                                             NULL,
                                             &pDci->Overlapped,   // Not used
                                             Apc_ChangeHandler ))
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "[ChangeWaitThread] ReadDirectoryChanges"
                               " returned %d\n",
                                GetLastError() ));

                    DBG_ASSERT( pVrm->fCachingAllowed == FALSE );

                    if ( pDci->hDirectoryFile )
                    {
                        CLOSE_DIRECTORY_HANDLE( pDci );
                        DereferenceRootMapping( pVrm );
                    }

                    //
                    //  We don't shrink the buffer because we use the
                    //  fOnSystemNotifyList flag which is in portion we
                    //  would want to shrink (and it doesn't give us a whole
                    //  lot).
                    //
                } else {
                    pVrm->fCachingAllowed = TRUE;
                }

                //
                //  Indicate we've attempted to add the entry to the system
                //  notify list.  Used for new items getting processed the 1st
                //  time
                //

                pDci->fOnSystemNotifyList = TRUE;
            }
        }

        LeaveCriticalSection( &csVirtualRoots );

Rewait:
        dwWaitResult = WaitForMultipleObjectsEx( 2,
                                                 ahEvents,
                                                 FALSE,
                                                 INFINITE,
                                                 TRUE );

        if ( dwWaitResult == WAIT_IO_COMPLETION )
        {
            //
            //  Nothing to do, the APC routine took care of everything
            //

            goto Rewait;

        }
    } while ( dwWaitResult == (WAIT_OBJECT_0 + 1) );

    ASSERT( dwWaitResult == WAIT_OBJECT_0 );

    //
    //  free the handles and all the heap.
    //

    EnterCriticalSection( &csVirtualRoots );

    for (  pEntry = GlobalVRootList.Flink;
           pEntry != &GlobalVRootList;
           pEntry = pEntry->Flink )
    {
        pVrm = CONTAINING_RECORD(
                            pEntry,
                            VIRTUAL_ROOT_MAPPING,
                            GlobalListEntry );

        if ( pVrm->fCachingAllowed ) {

            pDci = (PDIRECTORY_CACHING_INFO) (pVrm + 1);
            pVrm->fDeleted = TRUE;
            CLOSE_DIRECTORY_HANDLE( pDci );
        }

        pEntry = pEntry->Blink;
        RemoveEntryList( pEntry->Flink );
        DereferenceRootMapping( pVrm );
    }

    LeaveCriticalSection( &csVirtualRoots );

    InterlockedDecrement( &g_nTsunamiThreads );
    return( 0 );

} // ChangeWaitThread



BOOL
TsDecacheVroot(
    DIRECTORY_CACHING_INFO * pDci
    )
/*++
    Description:

        This function decouples all of the items that need to be decached
        from the associated tsunami data structures and derefences the
        cache obj.  This routine used to schedule this off to a worker thread
        but this is no longer necessary as this only is called during vroot
        destruction.

        This routine assumes the cache table lock and virtual root lock are
        taken

    Arguments:

        pDci - Directory change blob that needs to have its contents decached

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    LIST_ENTRY   * pEntry;
    CACHE_OBJECT * pCacheTmp;

    while ( !IsListEmpty( &pDci->listCacheObjects ))
    {
        pEntry = pDci->listCacheObjects.Flink;

        pCacheTmp = CONTAINING_RECORD( pEntry, CACHE_OBJECT, DirChangeList );
        ASSERT( pCacheTmp->Signature == CACHE_OBJ_SIGNATURE );

        if ( pCacheTmp->iDemux == RESERVED_DEMUX_PHYSICAL_OPEN_FILE ) {
            continue;
        }

        //
        //  Removes this cache item from all of the lists.  It had better be
        //  on the cache lists otherwise somebody is mucking with the list
        //  without taking the lock.
        //

        if ( !RemoveCacheObjFromLists( pCacheTmp, FALSE ) ) {
            ASSERT( FALSE );
            continue;
        }

        TsDereferenceCacheObj( pCacheTmp, FALSE );
    }

    return TRUE;
} // TsDecacheVroot


VOID
TsFlushTimedOutCacheObjects(
    VOID
    )
/*++
Description:

    This function walks all cache objects and decrements the TTL of the object.
    When the TTL reaches zero, the object is removed from the cache.

--*/
{
    LIST_ENTRY   * pEntry;
    LIST_ENTRY   * pNextEntry;
    CACHE_OBJECT * pCacheTmp;
    LIST_ENTRY     ListHead;

    InitializeListHead( &ListHead );

    EnterCriticalSection( &CacheTable.CriticalSection );
    EnterCriticalSection( &csVirtualRoots );

#if DBG
    IF_DEBUG( CACHE ) {
        DumpCacheStructures();
    }
#endif

    for ( pEntry  = CacheTable.MruList.Flink;
          pEntry != &CacheTable.MruList;
          pEntry  = pNextEntry ) {

        pNextEntry = pEntry->Flink;

        pCacheTmp = CONTAINING_RECORD( pEntry, CACHE_OBJECT, MruList );

        ASSERT( pCacheTmp->Signature == CACHE_OBJ_SIGNATURE );

        if ( pCacheTmp->iDemux == RESERVED_DEMUX_PHYSICAL_OPEN_FILE ) {
            continue;
        }

        //
        //  If the object hasn't been referenced since the last TTL, throw
        //  it out now
        //

        if ( pCacheTmp->TTL == 0 ) {

            //
            //  Removes this cache item from all of the lists.  It had better be
            //  on the cache lists otherwise somebody is mucking with the list
            //  without taking the lock.  We put it on a temporary list that
            //  we'll traverse after we release the locks
            //

            if ( !RemoveCacheObjFromLists( pCacheTmp, FALSE ) ) {
                ASSERT( FALSE );
                continue;
            }

            InsertTailList( &ListHead, &pCacheTmp->DirChangeList );
        } else {
            pCacheTmp->TTL--;
        }
    }

    LeaveCriticalSection( &csVirtualRoots );
    LeaveCriticalSection( &CacheTable.CriticalSection );

    //
    //  Now do the dereferences which may actually close the objects now that
    //  we don't have to hold the locks
    //

    for ( pEntry  = ListHead.Flink;
          pEntry != &ListHead;
          pEntry = pNextEntry ) {

        pNextEntry = pEntry->Flink;
        pCacheTmp = CONTAINING_RECORD( pEntry, CACHE_OBJECT, DirChangeList );

        ASSERT( pCacheTmp->Signature == CACHE_OBJ_SIGNATURE );

        TsDereferenceCacheObj( pCacheTmp, TRUE );
    }

} // TsFlushTimedOutCacheObjects


#if DBG
VOID
DumpCacheStructures(
    VOID
    )
{
    LIST_ENTRY * pEntry;
    DWORD        cItemsOnBin = 0;
    DWORD        cTotalItems = 0;
    DWORD        i, c;

    DBGPRINTF(( DBG_CONTEXT,
                "[DumpCacheStructures] CacheTable at 0x%lx, MAX_BINS = %d\n",
                &CacheTable,
                MAX_BINS ));

    for ( i = 0; i < MAX_BINS; i++ )
    {
        for ( pEntry  = CacheTable.Items[i].Flink, cItemsOnBin = 0;
              pEntry != &CacheTable.Items[i];
              pEntry  = pEntry->Flink, cItemsOnBin++, cTotalItems++ )
        {
            ;
        }

        if ( cItemsOnBin > 0) {
            DBGPRINTF(( DBG_CONTEXT,
                       "Bin[%3d] %4d\n",
                       i,
                       cItemsOnBin ));
        }
    }

    DBGPRINTF(( DBG_CONTEXT,
                "Total Objects in bins: %d\n",
                cTotalItems ));

    DBGPRINTF(( DBG_CONTEXT,
                "=====================================================\n" ));

    //
    //  Now print the contents of each bin
    //

    for ( i = 0; i < MAX_BINS; i++ )
    {
        PCACHE_OBJECT pcobj;

        if ( IsListEmpty( &CacheTable.Items[i] ))
            continue;

        DBGPRINTF(( DBG_CONTEXT,
                    "================== Bin %d ==================\n",
                    i ));

        for ( pEntry  = CacheTable.Items[i].Flink, cItemsOnBin = 0;
              pEntry != &CacheTable.Items[i];
              pEntry  = pEntry->Flink, cItemsOnBin++ )
        {
            pcobj = CONTAINING_RECORD( pEntry, CACHE_OBJECT, BinList );

            DBGPRINTF(( DBG_CONTEXT,
                        "CACHE_OBJECT[0x%lx] Service = %d, Instance = %d iDemux = 0x%lx ref = %d, TTL = %d\n"
                        "    hash = 0x%lx, cchLength = %d\n"
                        "    %s\n",
                        pcobj,
                        pcobj->dwService,
                        pcobj->dwInstance,
                        pcobj->iDemux,
                        pcobj->references,
                        pcobj->TTL,
                        pcobj->hash,
                        pcobj->cchLength,
                        pcobj->szPath ));
        }
    }
}

#endif //DBG




VOID
TsDumpCacheToHtml( OUT CHAR * pchBuffer, IN OUT LPDWORD lpcbBuffer )
{
    LIST_ENTRY * pEntry;
    DWORD        cItemsOnBin = 0;
    DWORD        cTotalItems = 0;
    DWORD        i, c, cb;

    EnterCriticalSection( &CacheTable.CriticalSection );
    EnterCriticalSection( &csVirtualRoots );

    DBG_ASSERT( lpcbBuffer != NULL && pchBuffer != NULL);
    DBG_ASSERT( *lpcbBuffer > 10240);

    cb = wsprintf( pchBuffer,
                   " CacheTable at 0x%lx, MAX_BINS=%d<br>"
                   "<TABLE BORDER> <TR> <TH> Bin Number </TH> "
                   //                   " <TH> # Items </TH> "
                   ,
                   &CacheTable, MAX_BINS);

    //
    // Generate the column headings for the bins
    //   0, 1, 2, ..... 9
    //
    for (i = 0; i < 10; i++) {
        
        if ( *lpcbBuffer >= cb + 20) {
            cb += wsprintf( pchBuffer +cb,
                            "<TH>%d</TH>",
                            i);
        }
    } // for

    for ( i = 0; i < MAX_BINS; i++ ) {

        for ( pEntry  = CacheTable.Items[i].Flink, cItemsOnBin = 0;
              pEntry != &CacheTable.Items[i];
              pEntry  = pEntry->Flink, cItemsOnBin++ )
        {
            // count the number of items in this bin
            ;
        }
        cTotalItems += cItemsOnBin;

        if ( *lpcbBuffer >= cb + 60) {
            
            if ( i % 10 == 0) {
                //
                // start a new row
                //
                cb += wsprintf( pchBuffer + cb,
                                "</TR><TR><TH>[%3d] </TH>",
                                i);
            }
            
            if ( cItemsOnBin > 0) {
                
                    cb += wsprintf( pchBuffer + cb,
                                    "<TD>%4d</TD>",
                                    cItemsOnBin);
            } else {

                //
                // Dump nothing for zero slots
                //
                cb += wsprintf( pchBuffer + cb,
                                "<TD><font color=\"0x80808080\"> </font></TD>",
                                cItemsOnBin);
            }
        }
    } // for all bins


    if ( *lpcbBuffer >=  cb + 50) {
        cb += wsprintf( pchBuffer + cb,
                        "</TR></TABLE><p>"
                        "Total Objects in bins: %d; OpenFilesInUse(%d);"
                        " Max Allowed=%d. <br> <hr>"
                        " The cached objects: "
                        ,
                        cTotalItems,
                        CacheTable.OpenFileInUse,
                        CacheTable.MaxOpenFileInUse
                        );
    }

    //
    //  Now print the contents of each bin
    //

    for ( i = 0; i < MAX_BINS; i++ ) {

        PCACHE_OBJECT pcobj;

        if ( IsListEmpty( &CacheTable.Items[i] ))
            continue;

        if ( *lpcbBuffer >=  cb + 60) {
            cb += wsprintf( pchBuffer + cb,
                        "<hr><b>============ Bin %d ==========</b><br>",
                        i );
        }

        for ( pEntry  = CacheTable.Items[i].Flink, cItemsOnBin = 0;
              pEntry != &CacheTable.Items[i];
              pEntry  = pEntry->Flink, cItemsOnBin++ )
        {
            pcobj = CONTAINING_RECORD( pEntry, CACHE_OBJECT, BinList );

            if ( *lpcbBuffer >=  cb + 300) {
                cb += wsprintf( pchBuffer + cb,
                                "[0x%lx] Svc:Inst = %d:%d; "
                                "iDemux=0x%lx; ref=%d; TTL=%d; "
                                "  hash=0x%lx; "
                                "  (%d) %s<br>",
                                pcobj,
                                pcobj->dwService,
                                pcobj->dwInstance,
                                pcobj->iDemux,
                                pcobj->references,
                                pcobj->TTL,
                                pcobj->hash,
                                pcobj->cchLength,
                                pcobj->szPath
                                );
            }
        } // for each item in bin
    } // for each bin

    LeaveCriticalSection( &csVirtualRoots );
    LeaveCriticalSection( &CacheTable.CriticalSection );

    *lpcbBuffer = cb;

    return;
}  // TsDumpCacheToHtml()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\dirchang.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        dirchang.cxx

   Abstract:

        This module contains the directory change manager routines

   Author:

        MuraliK

--*/

#include "tsunamip.Hxx"
#pragma hdrstop

#include "dbgutil.h"
#include <mbstring.h>

extern "C" {
#include <lmuse.h>
}

//
// list and cs for the virtual roots
//

LIST_ENTRY GlobalVRootList;
CRITICAL_SECTION csVirtualRoots;

VOID
DcmRemoveItem(
    PCACHE_OBJECT pCacheObject
    )
/*++

    Routine Description

        Remove the cache object from the Directory change manager list

    Arguments

        pCacheObject - Cache object to remove

    Returns

        None.

--*/
{
    ASSERT( !IsListEmpty( &pCacheObject->DirChangeList ) );

    RemoveEntryList( &pCacheObject->DirChangeList );
    return;

} // DcmRemoveItem

BOOL
DcmAddNewItem(
    IN PIIS_SERVER_INSTANCE pInstance,
    IN PCHAR                pszFileName,
    IN PCACHE_OBJECT        pCacheObject
    )
/*++

    Routine Description

        Adds a new cache object to the directory change list

    Arguments

        pCacheObject - Cache object to add

    Returns

        TRUE, if successful
        FALSE, otherwise
--*/
{
    PLIST_ENTRY pEntry;
    PVIRTUAL_ROOT_MAPPING pVrm;
    PDIRECTORY_CACHING_INFO pDci;
    BOOLEAN bResult = FALSE;
    PIIS_VROOT_TABLE pTable = pInstance->QueryVrootTable();

    ASSERT( !DisableTsunamiCaching );  // This should never get called

    //
    //  Must always take the Vroot table lock BEFORE the csVirtualRoots lock
    //  because DcmAddRoot is called with the vroot table locked then takes
    //  the csVirtualRoots lock
    //

    pTable->LockTable();
    EnterCriticalSection( &csVirtualRoots );

    __try {

        for( pEntry = pTable->m_vrootListHead.Flink;
             pEntry != &pTable->m_vrootListHead;
             pEntry = pEntry->Flink ) {

            pVrm = CONTAINING_RECORD(
                                pEntry,
                                VIRTUAL_ROOT_MAPPING,
                                TableListEntry );

            //
            //  If the directory of this virtual root doesn't match the
            //  beginning of the directory that we are being asked to cache
            //  within, skip this entry.
            //

            if ( _mbsnicmp(
                    (PUCHAR) pszFileName,
                    (PUCHAR) pVrm->pszDirectoryA,
                    _mbslen((PUCHAR)pVrm->pszDirectoryA) ) ) {
                continue;
            }

            //
            //  The virtual root contains the directory of interest.
            //

            if ( !pVrm->fCachingAllowed ) {
                break;
            }

            pDci = ( PDIRECTORY_CACHING_INFO)( pVrm+1 );

            ASSERT( IsListEmpty( &pCacheObject->DirChangeList ) );

            InsertHeadList(
                &pDci->listCacheObjects,
                &pCacheObject->DirChangeList
                );

            bResult = TRUE;
            break;
        }

    } __finally {
        LeaveCriticalSection( &csVirtualRoots );
        pTable->UnlockTable();
    }
    return( bResult );
} // DcmNewItem

BOOL
DcmInitialize(
    VOID
    )
/*++

    Routine Description

        Initialize the directory change manager.

    Arguments

        hQuitEvent - HANDLE to an event which get signalled during
                shutdown
        hNewItem - HANDLE to an event which gets signalled when a
                new item is added.

    Returns
        TRUE, if successful
        FALSE, otherwise

--*/
{
    DWORD             ThreadId;

    InitializeListHead( &GlobalVRootList );
    InitializeCriticalSection( &csVirtualRoots );
    SET_CRITICAL_SECTION_SPIN_COUNT( &csVirtualRoots,
                                     IIS_DEFAULT_CS_SPIN_COUNT);
    //
    // If tsunami caching is disabled, don't start the thread
    //

    if ( DisableTsunamiCaching ) {
        return(TRUE);
    }

    g_hChangeWaitThread = CreateThread(  ( LPSECURITY_ATTRIBUTES )NULL,
                                         0,
                                         ChangeWaitThread,
                                         0,
                                         0,
                                         &ThreadId );

    if ( g_hChangeWaitThread != NULL ) {
        return TRUE;
    }

    DeleteCriticalSection( &csVirtualRoots );
    return( FALSE );
} // DcmInitialize

BOOL
DcmAddRoot(
    PVIRTUAL_ROOT_MAPPING  pVrm
    )
/*++

    Routine Description

        Adds a virtual root to the DCM list

    Arguments

        pVrm - pointer to the VR mapping structure describing a VR

    Returns
        TRUE, if successful
        FALSE, otherwise

--*/
{
    BOOL                    bSuccess;
    PDIRECTORY_CACHING_INFO pDci;

    //
    // Check if Caching is disabled
    //

    if ( DisableTsunamiCaching ) {
        return(TRUE);
    }

    IF_DEBUG( DIRECTORY_CHANGE ) {
        DBGPRINTF(( DBG_CONTEXT,
            "Opening directory file %s\n", pVrm->pszDirectoryA ));
    }

    pDci = ( PDIRECTORY_CACHING_INFO)( pVrm+1 );

    InitializeListHead( &pDci->listCacheObjects );

    //
    //  Open the file.  If this is a UNC path name, we need to
    //  append a trailing / or the SMB server will barf
    //

    if ( pVrm->fUNC &&
        !IS_CHAR_TERM_A(pVrm->pszDirectoryA, pVrm->cchDirectoryA-1) ) {

        pVrm->pszDirectoryA[pVrm->cchDirectoryA++] = '\\';
        pVrm->pszDirectoryA[pVrm->cchDirectoryA] = '\0';

    }

    pDci->hDirectoryFile = CreateFile(
                               pVrm->pszDirectoryA,
                               FILE_LIST_DIRECTORY,
                               FILE_SHARE_READ |
                                   FILE_SHARE_WRITE |
                                   FILE_SHARE_DELETE,
                               NULL,
                               OPEN_EXISTING,
                               FILE_FLAG_BACKUP_SEMANTICS |
                                   FILE_FLAG_OVERLAPPED,
                               NULL );

    //
    // remove the trailing slash
    //

    if ( pVrm->fUNC &&
         IS_CHAR_TERM_A(pVrm->pszDirectoryA, pVrm->cchDirectoryA-1) ) {

        pVrm->pszDirectoryA[--pVrm->cchDirectoryA] = '\0';
    }

    if ( pDci->hDirectoryFile == INVALID_HANDLE_VALUE ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "Can't open directory %s, error %lx\n",
                    pVrm->pszDirectoryA,
                    GetLastError() ));

        if ( GetLastError() == ERROR_FILE_NOT_FOUND ) {
            DBGPRINTF(( DBG_CONTEXT,
                        "[AddRoot] Mapping File Not Found to Path Not Found\n" ));

            SetLastError( ERROR_PATH_NOT_FOUND );
        }
        return FALSE;
    }

    //
    // Now add this to the list
    //

    EnterCriticalSection( &csVirtualRoots );

    InsertTailList( &GlobalVRootList, &pVrm->GlobalListEntry );

    LeaveCriticalSection( &csVirtualRoots );

    //
    //  At this point, the entry in the list contains an open directory
    //  file.  This would imply that each contains a valid directory name,
    //  and is therefore a valid mapping between a "virtual root" and a
    //  directory name.
    //
    //  The next step is to wait on this directory if we can, and enable
    //  caching if we succesfully wait.
    //

    bSuccess = SetEvent( g_hNewItem );

    ASSERT( bSuccess );

    return( TRUE );
} // DcmAddRoot


VOID
DcmRemoveRoot(
    PVIRTUAL_ROOT_MAPPING  pVrm
    )
{

    //
    // Remove this from global list
    //

    EnterCriticalSection( &csVirtualRoots );
    RemoveEntryList( &pVrm->GlobalListEntry );
    LeaveCriticalSection( &csVirtualRoots );

} // DcmRemoveRoot

/*******************************************************************

    NAME:       IsCharTermA (DBCS enabled)

    SYNOPSIS:   check the character in string is terminator or not.
                terminator is '/', '\0' or '\\'

    ENTRY:      lpszString - string

                cch - offset for char to check

    RETURNS:    BOOL - TRUE if it is a terminator

    HISTORY:
        v-ChiKos    15-May-1997 Created.

********************************************************************/
BOOL
IsCharTermA(
    IN LPCSTR lpszString,
    IN INT    cch
    )
{
    CHAR achLast;

    achLast = *(lpszString + cch);

    if ( achLast == '/' || achLast == '\0' )
    {
        return TRUE;
    }

    achLast = *CharPrev(lpszString, lpszString + cch + 1);

    return (achLast == '\\');
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\globals.cxx ===
#include "TsunamiP.Hxx"
#pragma hdrstop

CONFIGURATION Configuration;
BOOL          g_fDisableCaching = FALSE;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\dirlist.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        getdir.cxx

   Abstract:
        This module implements the member functions for TS_DIRECTORY_INFO

   Author:

           Murali R. Krishnan    ( MuraliK )     16-Jan-1995

   Project:

          Tsunami Lib
          ( Common caching and directory functions for Internet Services)

   Functions Exported:

         TS_DIRECTORY_INFO::CleanupThis()

         TS_DIRECTORY_INFO::GetDirectoryListingA()
                       IN LPCSTR     pszDirectoryName,
                       IN  HANDLE    hListingUser)

         TS_DIRECTORY_INFO::SortFileInfoPointers(
                       IN PFN_CMP_WIN32_FIND_DATA pfnCompare)

         TS_DIRECTORY_INFO::FilterFiles(
                       IN PFN_IS_MATCH_WIN32_FIND_DATA  pfnMatch,
                       IN LPVOID     pContext);

   Revision History:
       MuraliK     06-Dec-1995  Used Win32 apis instead of NT apis

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "tsunamip.hxx"
# include "dbgutil.h"
# include <string.h>

/************************************************************
 *     Type Definitions
 ************************************************************/


dllexp
VOID
TS_DIRECTORY_INFO::CleanupThis( VOID)
{
    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Cleaning up TS_DIRECTORY_INFO ( %08x)\n",
                    this));
        Print();
    }

    if ( m_fValid) {

        if ( m_pTsDirectoryHeader != NULL) {

            TsFreeDirectoryListing( m_tsCache, m_pTsDirectoryHeader);
            m_pTsDirectoryHeader = NULL;
        }

        ASSERT( m_pTsDirectoryHeader == NULL);

        if ( m_prgFileInfo != NULL) {
            FREE( m_prgFileInfo);
            m_prgFileInfo = NULL;
        }
    }

    ASSERT( m_pTsDirectoryHeader == NULL);
    ASSERT( m_prgFileInfo == NULL);
    m_fValid = 0;
    m_cFilesInDirectory = 0;

} // TS_DIRECTORY_INFO::CleanupThis()




static BOOL
MakeCopyOfFileInfoPointers(
   IN OUT   PWIN32_FIND_DATA ** pppFileInfoTo,
   IN const PWIN32_FIND_DATA  * ppFileInfoFrom,
   IN int  nEntries)
/*++
  Allocates memory and makes a copy of the file info pointers in the array
   in ppFileInfoFrom.

  Returns:
    TRUE if success and FALSE if there is any failure.
--*/
{
    DWORD cbCopy;

    ASSERT( *pppFileInfoTo == NULL);

    cbCopy = nEntries * sizeof( PWIN32_FIND_DATA);

    *pppFileInfoTo = (PWIN32_FIND_DATA *) ALLOC( cbCopy);

    if ( *pppFileInfoTo != NULL) {

        memcpy((PVOID ) *pppFileInfoTo,
               (const PVOID ) ppFileInfoFrom,
               cbCopy);

    } else {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
    }

    return ( *pppFileInfoTo != NULL);
} // MakeCopyOfFileInfoPointers()




dllexp
BOOL
TS_DIRECTORY_INFO::GetDirectoryListingA(
    IN  LPCSTR          pszDirectoryName,
    IN  HANDLE          hListingUser)
{
    if ( m_pTsDirectoryHeader == NULL) {

        //
        //  Only if already a directory listing is not obtained.
        //  we obtain newly
        //

        IF_DEBUG( DIR_LIST) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "Obtaining Dir Listing for %s. UserHandle=%08x.\n",
                        pszDirectoryName, hListingUser));
        }

        m_fValid = TsGetDirectoryListing( m_tsCache,
                                           pszDirectoryName,
                                           hListingUser,
                                           &m_pTsDirectoryHeader);

        m_fValid = m_fValid &&
                   MakeCopyOfFileInfoPointers(
                       &m_prgFileInfo,
                       m_pTsDirectoryHeader->QueryArrayOfFileInfoPointers(),
                       m_pTsDirectoryHeader->QueryNumEntries());

        m_cFilesInDirectory = ( m_pTsDirectoryHeader == NULL) ? 0 :
                               m_pTsDirectoryHeader->QueryNumEntries();
    }

    return ( m_fValid);
} // TS_DIRECTORY_INFO::GetDirectoryListingA()




dllexp
BOOL
TS_DIRECTORY_INFO::SortFileInfoPointers(
    IN PFN_CMP_WIN32_FIND_DATA pfnCompare)
{
    BOOL  fReturn;

    if ( IsValid()) {

        fReturn = SortInPlaceFileInfoPointers(m_prgFileInfo,
                                              m_cFilesInDirectory,
                                              pfnCompare);
    }

    return ( fReturn);
} // TS_DIRECTORY_INFO::SortFileInfoPointers()




dllexp
BOOL
TS_DIRECTORY_INFO::FilterFiles( IN PFN_IS_MATCH_WIN32_FIND_DATA  pfnMatch,
                                IN LPVOID  pContext)
/*++
  This function filters the list of files using the pfnMatch function
        and the context information specified by pContext.
  This function eliminates all the pointers to FileInfo which do not
    match the given file specification.

  Returns:
    TRUE on success and FALSE on failure.
--*/
{
    BOOL fReturn = FALSE;

    if ( IsValid()) {

        int idxScan;      // for scanning the files
        int idxCur;       // for updating after filter

        IF_DEBUG( DIR_LIST) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "FilterFiles in DirList( %08x) for FileSpec %08x\n",
                        this, pContext));
        }

        for( idxCur = idxScan = 0;
            idxScan < m_cFilesInDirectory;
            idxScan++) {

            PWIN32_FIND_DATA   pFileInfo =
               GetFileInfoPointerFromIdx( idxScan);

            ASSERT( pFileInfo != NULL);
            ASSERT( idxCur <= idxScan);

            if ( (*pfnMatch)( pFileInfo, pContext)) {

                //
                //  this is a match. Retain this item and advance CurPtr
                //
                m_prgFileInfo[ idxCur++] = m_prgFileInfo[ idxScan];
            }
        } // for

        m_cFilesInDirectory = idxCur;
        fReturn = TRUE;
    }

    return ( fReturn);
} // TS_DIRECTORY_INFO::FilterFiles()




# if DBG

VOID
TS_DIRECTORY_INFO::Print( VOID) const
{

    DBGPRINTF( ( DBG_CONTEXT,
                " Printing TS_DIRECTORY_INFO ( %08x).\n"
                "NumEntries=%d\t Valid = %d\n"
                "Directory Header ( %08x) \t ArrayOfFileInfo = %08x\n",
                this,
                m_cFilesInDirectory, m_fValid,
                m_pTsDirectoryHeader, m_prgFileInfo));

    for( int idx  = 0; idx < m_cFilesInDirectory; idx++) {

        PWIN32_FIND_DATA pfi = m_prgFileInfo[idx];

        DBGPRINTF( ( DBG_CONTEXT,
                    "rgFileInfo[%4d] = %08x. Name=%s Attr=0x%x"
                    "Size=0x%x:%x\n",
                    idx, pfi,
                    pfi->cFileName,
                    pfi->dwFileAttributes,
                    pfi->nFileSizeHigh,
                    pfi->nFileSizeLow
                    ));
    }

    m_pTsDirectoryHeader->Print();

    return;
} // TS_DIRECTORY_INFO::Print()


# endif // DBG




BOOL __cdecl
RegExpressionMatchFileInfo( IN const WIN32_FIND_DATA  * pFileInfo,
                            IN CHAR * pszExpression)
/*++
  This function tries to find a match between the file name in
  pFileInfo and the regular expression specified in pszExpression.

  Arguments:
     pFileInfo  -- pointer to file information consisting under query.
     pszExpression - pointer to null-terminated string containing the
                      regular expression, against which file name is tobe
                      matched for.

  Returns:
    TRUE on a match and false if there is any failure.
--*/
{
    const CHAR * pszFileName;

    DBG_ASSERT( pFileInfo != NULL);
    pszFileName = pFileInfo->cFileName;

    if ( strpbrk( pszExpression, "?*<>") != NULL) {

        // No Wild cards. Do normal file comparisons
        return ( strcmp( pszFileName, pszExpression) == 0);
    } else {

        // do a case sensitive comparison
        return IsNameInRegExpressionA( pszExpression, pszFileName, FALSE);
    }

} // RegExpressionMatch()





/************************************************************
 *  Following code is based on the FileSystem Rtl routines
 *    from ntos\fsrtl\name.c
 *  But these are optimized for performance, in our case
 *    using ANSI strings!
 ************************************************************/

# define MAX_MATCHES_ARRAY_SIZE    (16)
# define IS_EMPTY_STRING(psz)      ( (psz) == NULL || *(psz) == '\0')


//
// Original code used USHORT for ULEN. However using USHORT asks
//  a 32 bit processor to add  "and <value>, 0xff for each instruction
//  that accessed the 16 bit (USHORT) value.
// Hence, I decided to use DWORD, since the space usage is not tremendous
//   during the fast path work, compared to performance benefits.
//  - MuraliK (Oct 27, 1995)
//

//  typedef  USHORT  ULEN;
typedef DWORD ULEN;


BOOL __cdecl
IsNameInRegExpressionA(
    IN LPCSTR   pszExpression,
    IN LPCSTR   pszName,
    IN BOOL     fIgnoreCase)
/*++
  This routine compares an ANSI name and an expression and decries to the
  caller if the name is in hte language defined by the expression. The input
  name cannot contain wildcards, while the expression itself may contain
  wildcards.

  Expression wild cards are evaluated as shown in the non-deterministic finite
   automatons below. Note that ~* and ~? stand for DOS_STAR and DOS_QM.


             ~* is DOS_STAR, ~? is DOS_QM, and ~. is DOS_DOT


                                       S
                                    <-----<
                                 X  |     |  e       Y
             X * Y ==       (0)----->-(1)->-----(2)-----(3)


                                      S-.
                                    <-----<
                                 X  |     |  e       Y
             X ~* Y ==      (0)----->-(1)->-----(2)-----(3)



                                X     S     S     Y
             X ?? Y ==      (0)---(1)---(2)---(3)---(4)



                                X     .        .      Y
             X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^


                                X     S-.     S-.     Y
             X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^



         where S is any single character

               S-. is any single character except .

               e is a null character transition

               EOF is the end of the name string


    The last construction, ~? (the DOS question mark), can either match any
    single character, or upon encountering a period or end of input string,
    advances the expression to the end of the set of contiguous ~?s.  This may
    seem somewhat convoluted, but is what DOS needs.

  Arguments:
    pszExpression - Supplies the input expression to check against
     ( Caller must already lowercased if passing fIgnoreCase TRUE.)

    pszName  - supplies the input name to check for.

    fIgnoreCase - if TRUE, the name should be lower-cased before comparing.
     ( that is done by this function, dynamically without destroying pszName)

    This function is costly, if the pszExpression does not contain
      any wild cards to be matched for. So Dont use it if there are
      no wild cards in the pszExpression

  Returns:
     BOOL  -- TRUE if pszName is an element in the set of strings denoted
        by the input expression.  FALSE if otherwise.
--*/
{
    ULEN    NameLen;       // length in character count
    ULEN    ExprLen;

    /*
     * Algorithm:
     *  Keep track of all possible locations in the regular expression
     *   that are matching the name. If when the name has been exhausted
     *   one of the locations in the expression is also just exhausted, the
     *  name is in the language defined by the regular expression.
     */


    DBG_ASSERT( pszName != NULL && *pszName != '\0');
    DBG_ASSERT( pszExpression != NULL && *pszName != '\0');

    //
    // if one string is empty return FALSE. If both are empty TRUE.
    //

    if ( IS_EMPTY_STRING(pszName) || IS_EMPTY_STRING(pszExpression)) {

        IF_DEBUG( DIR_LIST) {
            DBGPRINTF((DBG_CONTEXT, " IsNameInRegExpr( %s, %s, %d) ==>%d\n",
                       pszExpression, pszName, fIgnoreCase,
                       !(*pszName + *pszExpression)
                       ));
        }

        return (BOOL ) (!(*pszName + *pszExpression));
    }

    NameLen = strlen(pszName);
    ExprLen = strlen(pszExpression);

    //
    // Special case: reduce the most common wild card search of *
    //

    if ( ExprLen == 1 && pszExpression[0] == '*') {

        IF_DEBUG ( DIR_LIST) {
            DBGPRINTF((DBG_CONTEXT, " IsNameInRegExpr( %s, %s, %d) ==>%d\n",
                       pszExpression, pszName, fIgnoreCase,
                       TRUE
                       ));
        }

        // matches anything. so return TRUE
        return (TRUE);
    }

    //
    //  Walk through the name string, picking off characters.  We go one
    //  character beyond the end because some wild cards are able to match
    //  zero characters beyond the end of the string.
    //
    //  With each new name character we determine a new set of states that
    //  match the name so far.  We use two arrays that we swap back and forth
    //  for this purpose.  One array lists the possible expression states for
    //  all name characters up to but not including the current one, and other
    //  array is used to build up the list of states considering the current
    //  name character as well.  The arrays are then switched and the process
    //  repeated.
    //
    //  There is not a one-to-one correspondence between state number and
    //  offset into the pszExpression.  This is evident from the NFAs in the
    //  initial comment to this function.  State numbering is not continuous.
    //  This allows a simple conversion between state number and expression
    //  offset.  Each character in the Expression can represent one or two
    //  states.  '*' and DOS_STAR generate two states: ExprOffset*2 and
    //  ExprOffset*2 + 1.  All other expression characters can produce only
    //  a single state.  Thus ExprOffset = State/2.
    //
    //
    //  Here is a short description of the variables involved:
    //
    //  NameOffset  -The offset of the current name char being processed.
    //
    //  ExprOffset  -The offset of the current expression char being processed.
    //
    //  SrcCount    -Prior match being investigated with current name char
    //
    //  DestCount   -Next location to put a matching assuming current name char
    //
    //  NameFinished - Allows one more iteration through the Matches array
    //                 after the name is exhusted (to come *s for example)
    //
    //  PreviousDestCount - This is used to prevent entry duplication,
    //                       see comment
    //
    //  PreviousMatches   - Holds the previous set of matches (the Src array)
    //
    //  CurrentMatches    - Holds the current set of matches (the Dest array)
    //
    //  AuxBuffer, LocalBuffer - the storage for the Matches arrays
    //

    ULEN NameOffset;    // offset in terms of byte count
    ULEN ExprOffset;    // offset in terms of byte count

    ULONG SrcCount;
    ULONG DestCount;
    ULONG PreviousDestCount;
    ULONG MatchesCount;

    CHAR NameChar, ExprChar;

    // for prev and current matches
    ULEN *AuxBuffer = NULL;
    ULEN *PreviousMatches;
    ULEN *CurrentMatches;

    ULEN MaxState;
    ULEN CurrentState;

    BOOL NameFinished;

    ULEN LocalBuffer[MAX_MATCHES_ARRAY_SIZE * 2];

    // set up the intial values
    // Use the different portions of local buffer for matches.

    PreviousMatches = &LocalBuffer[0];
    CurrentMatches  = &LocalBuffer[MAX_MATCHES_ARRAY_SIZE];

    PreviousMatches[0] = 0;
    MatchesCount       = 1;

    NameOffset = 0;
    MaxState   = (ULEN ) (ExprLen * 2);

    NameFinished = FALSE;
    while (!NameFinished) {


        if ( NameOffset < NameLen) {

            NameChar = pszName[NameOffset/sizeof(CHAR)];
            NameOffset += sizeof(CHAR);
        } else {

            NameFinished = TRUE;

            // if we already exhauseted expression, stop. Else continue
            DBG_ASSERT( MatchesCount >= 1);
            if ( PreviousMatches[MatchesCount - 1] == MaxState) {

                break;
            }
        }

        //
        // Now, for each of previous stored expression matches,
        //  see what we can do with the new name character.
        //

        DestCount = 0;
        PreviousDestCount = 0;

        for( SrcCount = 0;  SrcCount < MatchesCount; ) {

            ULEN Length;

            //
            //  We have to carry on our expression analysis as far as possible
            //  for each character of name, so we loop here until the
            //  expression stops matching.  A clue here is that expression
            //  cases that can match zero or more characters end with a
            //  continue, while those that can accept only a single character
            //  end with a break.
            //

            ExprOffset = (ULEN)((PreviousMatches[SrcCount++] + 1) / 2);

            for( Length = 0; ExprOffset != ExprLen; ) {

                //
                // increment the expression offset to move to next character.
                //
                ExprOffset += Length;
                Length = sizeof(CHAR);

                CurrentState = (ULEN)(ExprOffset * 2);

                if ( ExprOffset == ExprLen * sizeof(CHAR)) {

                    CurrentMatches[DestCount++] = MaxState;
                    break;
                }

                ExprChar = pszExpression[ExprOffset/sizeof(CHAR)];

                ASSERT( !fIgnoreCase ||
                        !((ExprChar >= 'A') && (ExprChar <= 'Z')));

                //
                // Before we get started, we have to check for something really
                //  gross. We may be about to exhaust the local space for
                //  ExpressionMatch[][], so when we have to allocate some
                //   pool if this is the case. Yuk!
                //

                if ( (DestCount >= MAX_MATCHES_ARRAY_SIZE - 2) ) {

                    if (AuxBuffer == NULL) {

                        // 2 copies of array each with 2 states for each char
                        //  in the expression. Each state == ULEN.

                        IF_DEBUG( DIR_LIST) {
                            DBGPRINTF((DBG_CONTEXT, "IsNInExpr(%s,%s,%d):"
                                       "alloc %d for exprlen=%d\n",
                                       pszExpression, pszName, fIgnoreCase,
                                       (ExprLen + 1) *sizeof(ULEN)*2*2,
                                       ExprLen));
                        }

                        AuxBuffer = ((ULEN *)
                                     ALLOC((ExprLen +1) * sizeof(ULEN)* 2*2)
                                     );
                        if ( AuxBuffer == NULL) {

                            DBG_ASSERT(!"Failure in mem alloc");

                            return ( FALSE);
                        }

                        RtlCopyMemory( AuxBuffer, CurrentMatches,
                                      MAX_MATCHES_ARRAY_SIZE*sizeof(ULEN));
                        CurrentMatches = AuxBuffer;

                        RtlCopyMemory( AuxBuffer + (ExprLen + 1)*2,
                                      PreviousMatches,
                                      MAX_MATCHES_ARRAY_SIZE * sizeof(ULEN));

                        PreviousMatches = AuxBuffer + (ExprLen + 1)*2;
                    } else {

                        DBG_ASSERT(!"Double Overflow occured\n");
                    }
                }

                //
                // '*' Matches any character zero or more times
                //
                if ( ExprChar == '*') {

                    // Add all possible next states into the list
                    // use the above state diagram to identify this.
                    CurrentMatches[DestCount] = CurrentState;
                    CurrentMatches[DestCount+1] = CurrentState + 1;
                    DestCount+= 2;
                    continue;
                }

                //
                // ANSI_DOS_STAR matches any char, zero or more times,
                //  except the DOS's extension '.'
                //

                if ( ExprChar == ANSI_DOS_STAR) {

                    BOOL  ICanEatADot = FALSE;

                    //
                    // If we are at a period, determine if we are
                    //  allowed to consume it. i.e make it is not last one.
                    //
                    if ( !NameFinished && (NameChar == '.')) {

                        ULEN cchOffset;  // in character counts
                        for( cchOffset = NameOffset/sizeof(CHAR);
                            cchOffset < NameLen;
                            cchOffset ++) {

                            if ( pszName[cchOffset]  == '.') {

                                ICanEatADot = TRUE;
                                break;
                            }
                        } // for
                    }

                    if ( NameFinished || (NameChar != '.') || ICanEatADot) {

                        //
                        // Go ahead and consume this character.
                        // Gives two options to move forward.
                        //
                        CurrentMatches[DestCount] = CurrentState;
                        CurrentMatches[DestCount+1] = CurrentState+1;
                        DestCount += 2;
                    } else {

                        //
                        // We are at the period. We can only match zero
                        //  or more characters (ie. the epsilon transition)
                        //

                        CurrentMatches[DestCount++] = CurrentState+1;
                        continue;
                    }
                } // if ( ExprChar == DOS_STAR)

                //
                // The following expression characters all match by consuming
                //  a character, thus force the expression, and thus state
                //  move forward.
                //

                CurrentState += (ULEN)(sizeof(CHAR) *2);

                //
                //  DOS_QM is the most complicated.  If the name is finished,
                //  we can match zero characters.  If this name is a '.', we
                //  don't match, but look at the next expression.  Otherwise
                //  we match a single character.
                //

                if ( ExprChar == ANSI_DOS_QM ) {

                    if ( NameFinished || (NameChar == '.') ) {

                        continue;
                    }

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  DOS_DOT can match either a period, or zero characters
                //  beyond the end of the name
                //

                if ( ExprChar == ANSI_DOS_DOT) {

                    if ( NameFinished) {
                        continue;
                    }

                    if ( NameChar == '.') {

                        CurrentMatches[DestCount++] = CurrentState;
                        break;
                    }
                }

                //
                // From this point on a name character is required to
                //  even continue searching, let alone make a match.
                // So if Name is finished, stop.
                //

                if ( NameFinished) {

                    break;
                }

                //
                // If the expression was a '?' we can match it once
                //
                if ( ExprChar == '?') {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                // Finally, check if the expression char matches name char
                //

                if ( ExprChar == (CHAR ) (fIgnoreCase ?
                                          tolower(NameChar) : NameChar)
                    ){

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                // The expression did not match, go look at the next
                //  previous match
                //
                break;
            } // for matching from an old state.


            //
            //  Prevent duplication in the destination array.
            //
            //  Each of the arrays is montonically increasing and non-
            //  duplicating, thus we skip over any source element in the src
            //  array if we just added the same element to the destination
            //  array.  This guarentees non-duplication in the dest. array.
            //

            if ((SrcCount < MatchesCount) &&
                (PreviousDestCount < DestCount) ) {

                while ( SrcCount < MatchesCount &&
                       PreviousDestCount < DestCount) {
                    //
                    // logic here is: by eliminating the states with
                    //  lesser number than current matched ==> we are
                    //  skipping over the smallest states from which
                    //  no match may be found.
                    //

                    if ( PreviousMatches[SrcCount] <
                        CurrentMatches[PreviousDestCount] ) {

                        SrcCount ++;
                    }

                    PreviousDestCount += 1;
                } // while
            }
        } // for each of old matches....

        //
        //  If we found no matches in the just finished iteration, it's time
        //  to bail.
        //

        if ( DestCount == 0 ) {

            if (AuxBuffer != NULL) {
                IF_DEBUG( DIR_LIST) {

                    DBGPRINTF((DBG_CONTEXT, " Freeing %08x\n", AuxBuffer));
                }

                FREE( AuxBuffer );
            }

            return FALSE;
        }

        //
        //  Swap the meaning the two arrays
        //

        {
            ULEN *Tmp;

            Tmp = PreviousMatches;

            PreviousMatches = CurrentMatches;

            CurrentMatches = Tmp;
        }

        MatchesCount = DestCount;

    } // for each char in Name, until name is finished.

    DBG_ASSERT(MatchesCount > 0);
    CurrentState = PreviousMatches[MatchesCount-1];
    if (AuxBuffer != NULL) {
        IF_DEBUG( DIR_LIST) {
            DBGPRINTF((DBG_CONTEXT, " Freeing %08x\n", AuxBuffer));
        }

        FREE( AuxBuffer );
    }

    return (BOOL ) ( CurrentState == MaxState);

} //  IsNameInRegExpressionA()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\getdirp.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        getdirp.cxx

   Abstract:
        This module implements the functions for getting directory listings
         and transparently caching them.
        ( This uses OS specific functions to obtain the directory).

   Author:

           Murali R. Krishnan    ( MuraliK )     13-Jan-1995

   Project:

          Tsunami Lib
          ( Common caching and directory functions for Internet Services)

   Functions Exported:
   BOOL TsGetDirectoryListingA()
   BOOL TsFreeDirectoryListing()
   int __cdecl
   AlphaCompareFileBothDirInfo(
              IN const void *   pvFileInfo1,
              IN const void *   pvFileInfo2)

   TS_DIRECTORY_HEADER::ReadFromNtDirectoryFile(
                  IN LPCWSTR          pwszDirectoryName
                  )
   TS_DIRECTORY_HEADER::BuildInfoPointers(
                  IN LPCWSTR          pwszDirectoryName
                  )
   TS_DIRECTORY_HEADER::CleanupThis()

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "tsunamip.hxx"

# include <stdlib.h>
# include <string.h>
# include <dbgutil.h>

/************************************************************
 *     Type Definitions
 ************************************************************/


#define DIRECTORY_BUFFER_SIZE 8160          /* < 8192 bytes */

/************************************************************
 *    Functions
 ************************************************************/


BOOL FreeDirectoryHeaderContents( PVOID pvOldBlock );


dllexp
BOOL
TsGetDirectoryListing(
    IN const TSVC_CACHE         &tsCache,
    IN      PCSTR               pszDirectoryName,
    IN      HANDLE              ListingUser,
    OUT     PTS_DIRECTORY_HEADER * ppTsDirectoryHeader
    )
/*++
  This function obtains the directory listing for dir specified
        in pszDirectoryName.

  Arguments:
    tsCache          Cache structure which is used for lookup
    pwszDirectoryName  pointer to string containing the directory name
    ListingUser        Handle for the user opening the directory
    ppTsDirectoryHeader
                  pointer to pointer to class containing directory information.
       Filled on successful return. On failure this will be NULL

  Returns:
      TRUE on success and FALSE if  there is a failure.
--*/
{
    ASSERT( tsCache.IsValid() );
    ASSERT( pszDirectoryName   != NULL );
    ASSERT( ppTsDirectoryHeader != NULL);

    PVOID          pvBlob = NULL;
    ULONG          ulSize = 0;
    BOOL           bSuccess;

    //
    //  First, check to see if we have already cached a listing of this
    //  directory.
    //

    *ppTsDirectoryHeader = NULL;
    bSuccess = TsCheckOutCachedBlob(  tsCache,
                                      pszDirectoryName,
                                      RESERVED_DEMUX_DIRECTORY_LISTING,
                                      ( PVOID * )&pvBlob,
                                      &ulSize );

    if ( bSuccess )
    {
        ASSERT( BLOB_IS_OR_WAS_CACHED( pvBlob ) );

        *ppTsDirectoryHeader = (PTS_DIRECTORY_HEADER )pvBlob;
        ASSERT ( (*ppTsDirectoryHeader)->IsValid());

        //
        //  Make sure the user tokens match
        //

        if ( hListingUser == (*ppTsDirectoryHeader)->QueryListingUser() )
        {
            IF_DEBUG( DIR_LIST) {

                DBGPRINTF( (DBG_CONTEXT,
                            " Obtained DirectoryListing (%s) from Cache ( %08x)\n",
                            pszDirectoryName,
                            *ppTsDirectoryHeader));

                (*ppTsDirectoryHeader)->Print();
            }

            return TRUE;
        }

        //
        //  User token doesn't match, don't return it
        //

        bSuccess = TsCheckInCachedBlob( pvBlob );

        ASSERT( bSuccess );
    }

    //
    //  The block was not present in cache.
    //  Obtain a fresh copy of the directory listing and cache it.
    //

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( (DBG_CONTEXT,
                    "Missing DirListing (%s) in cache. Generating newly\n",
                    pszDirectoryName));
    }

    *ppTsDirectoryHeader = TsGetFreshDirectoryHeader(
                               tsCache,
                               pszDirectoryName,
                               hListingUser );


    bSuccess = ( *ppTsDirectoryHeader != NULL);

    return ( bSuccess);

} // TsGetDirectoryListing




dllexp
BOOL
TsFreeDirectoryListing(
    IN const TSVC_CACHE &    tsCache,
    IN PTS_DIRECTORY_HEADER  pDirectoryHeader
    )
{
    BOOL fReturn;
    BOOL fCached = BLOB_IS_OR_WAS_CACHED( (PVOID ) pDirectoryHeader);

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "TsFreeDirectoryListing( %08x) called. Cached = %d\n",
                    pDirectoryHeader,
                    fCached));

        pDirectoryHeader->Print();
    }

    if ( fCached )
    {
        fReturn = TsCheckInCachedBlob( ( PVOID )pDirectoryHeader );
    }
    else
    {
        fReturn = TsFree( tsCache, ( PVOID )pDirectoryHeader );
    }

    return( fReturn);
} // TsFreeDirectoryListing()



BOOL
FreeDirectoryHeaderContents(
    PVOID pvOldBlock
    )
{
    PTS_DIRECTORY_HEADER  pDirectoryHeader;

    pDirectoryHeader = ( PTS_DIRECTORY_HEADER )pvOldBlock;

    pDirectoryHeader->CleanupThis();

    //
    //  The item may never have been added to the cache, don't
    //  count it in this case
    //

    if ( BLOB_IS_OR_WAS_CACHED( pvOldBlock ) )
    {
        DEC_COUNTER( BLOB_GET_SVC_ID( pvOldBlock ),
                     CurrentDirLists );
    }

    return ( TRUE);
}  //  FreeDirectoryHeaderContents()




int __cdecl
AlphaCompareFileBothDirInfo(
   IN const void *   pvFileInfo1,
   IN const void *   pvFileInfo2)
{
    const FILE_BOTH_DIR_INFORMATION * pFileInfo1 =
        *((const FILE_BOTH_DIR_INFORMATION **) pvFileInfo1);
    const FILE_BOTH_DIR_INFORMATION * pFileInfo2 =
        *((const FILE_BOTH_DIR_INFORMATION **) pvFileInfo2);

    ASSERT( pFileInfo1 != NULL && pFileInfo2 != NULL);

    return ( lstrcmp( (LPCSTR )pFileInfo1->FileName,
                      (LPCSTR )pFileInfo2->FileName));

} // AlphaCompareFileBothDirInfo()



BOOL
SortInPlaceFileInfoPointers(
    IN OUT PFILE_BOTH_DIR_INFORMATION  * prgFileInfo,
    IN int   nEntries,
    IN PFN_CMP_FILE_BOTH_DIR_INFO        pfnCompare)
/*++
  This is a generic function to sort the pointers to file information
    array in place using pfnCompare to compare the records for ordering.

  Returns:
     TRUE on success and FALSE on failure.
--*/
{
    DWORD  dwTime;

#ifdef INSERTION_SORT
    int idxInner;
    int idxOuter;

    dwTime = GetTickCount();
    //
    //  A simple insertion sort is performed. May be modified in future.
    //

    for( idxOuter = 1; idxOuter < nEntries; idxOuter++) {

        for( idxInner = idxOuter; idxInner > 0; idxInner-- ) {

            int iCmp = ( *pfnCompare)( prgFileInfo[ idxInner - 1],
                                       prgFileInfo[ idxInner]);

            if ( iCmp <= 0) {
                //
                //  The entries in prgFileInfo[0 .. idxOuter] are in order.
                //  Stop bubbling the outer down.
                //
                break;
            } else {

                //
                // Swap the two entries.  idxInner, idxInner - 1
                //

                PFILE_BOTH_DIR_INFORMATION  pFInfoTmp;

                pFInfoTmp = prgFileInfo[ idxInner - 1];
                prgFileInfo[ idxInner - 1] = prgFileInfo[idxInner];
                prgFileInfo[ idxInner] = pFInfoTmp;
            }
        }  // inner for

    } // for

    dwTime = GetTickCount() -  dwTime;

# else

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Qsorting the FileInfo Array %08x ( Total = %d)\n",
                    prgFileInfo, nEntries));
    }

    dwTime = GetTickCount();
    qsort( (PVOID ) prgFileInfo, nEntries,
          sizeof( PFILE_BOTH_DIR_INFORMATION),
          pfnCompare);

    dwTime = GetTickCount() - dwTime;

# endif // INSERTION_SORT

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Time to sort %d entries = %d\n",
                    nEntries, dwTime));
    }

    return ( TRUE);
} // SortInPlaceFileInfoPointers()







/**********************************************************************
 *    TS_DIRECTORY_HEADER  related member functions
 **********************************************************************/

inline USHORT
ConvertUnicodeToAnsiInPlace(
   IN OUT  LPWSTR     pwszUnicode,
   IN      USHORT     usLen)
/*++
  Converts given Unicode strings to Ansi In place and returns the
    length of the modified string.
--*/
{
    CHAR achAnsi[MAX_PATH+1];
    DWORD cch;

    if ( usLen > sizeof(achAnsi) )
    {
        ASSERT( FALSE );
        *pwszUnicode = L'\0';
        return 0;
    }

    //
    //  usLen is a byte count and the unicode string isn't terminated
    //

    cch = WideCharToMultiByte( CP_ACP,
                               WC_COMPOSITECHECK,
                               pwszUnicode,
                               usLen / sizeof(WCHAR),
                               achAnsi,
                               sizeof( achAnsi ),
                               NULL,
                               NULL );

    if ( !cch || (cch + 1) > sizeof( achAnsi ) )
    {
        ASSERT( FALSE );
        *pwszUnicode = L'\0';
        return 0;
    }

    achAnsi[cch] = '\0';

    RtlCopyMemory( pwszUnicode, achAnsi, cch + 1 );

    return (USHORT) cch;
}  // ConvertUnicodeToAnsiInPlace()



BOOL
TS_DIRECTORY_HEADER::ReadFromNtDirectoryFile(
    IN LPCWSTR          pwszDirectoryName,
    IN OUT DWORD *      pcbMemUsed
    )
/*++
  Opens and reads the directory file for given directory to obtain
   information about files and directories in the dir.

  Returns:
     TRUE on success and   FALSE on failure.
     Use GetLastError() for further error information.

--*/
{
    BOOL                fReturn = TRUE;       // default assumed.
    UNICODE_STRING      PathName;
    RTL_RELATIVE_NAME   RelativeName;
    OBJECT_ATTRIBUTES   Obja;
    HANDLE              hFindFile = INVALID_HANDLE_VALUE;
    NTSTATUS            Status;
    IO_STATUS_BLOCK     IoStatusBlock;
    BOOL                fFirstTime;
    DWORD               cbExtraMem = 0;

    PFILE_BOTH_DIR_INFORMATION pFileDirInfo;
    PFILE_BOTH_DIR_INFORMATION pFileDirInfoPrior;

    //
    // Initialize the variables properly
    //

    memset( (PVOID ) &PathName, 0, sizeof(PathName));
    memset( (PVOID ) &RelativeName, 0, sizeof(RelativeName));

    //
    //  Convert the DOS name of directory to NT name for NT API to open it.
    //

    fReturn = RtlDosPathNameToNtPathName_U(
                             pwszDirectoryName,
                             &PathName,
                             NULL,
                             &RelativeName );

    //
    //  If translation fails or
    // If this directory name is in the form <dirname>\<filespec>,
    //        the caller has messed up.
    //

    if ( !fReturn || RelativeName.RelativeName.Length != 0)  {

        SetLastError(ERROR_PATH_NOT_FOUND);

        if ( PathName.Buffer != NULL) {     // free up the space.

            RtlFreeHeap( RtlProcessHeap(), 0, PathName.Buffer);
        }

        return( fReturn);
    }

    //
    //  Remember that we need to free the buffer containing the NT name.
    //  i.e. PathName.Buffer
    //

    ASSERT( RelativeName.ContainingDirectory == NULL );
    ASSERT( RelativeName.RelativeName.Length == 0);

    InitializeObjectAttributes(  &Obja,
                                 &PathName,
                                 OBJ_CASE_INSENSITIVE,
                                 RelativeName.ContainingDirectory,
                                 NULL );

    //
    // Open the directory for list access
    //

    Status = NtOpenFile(  &hFindFile,
                          FILE_LIST_DIRECTORY | SYNCHRONIZE,
                          &Obja,
                          &IoStatusBlock,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT |
                           FILE_OPEN_FOR_BACKUP_INTENT
                        );

    //
    //  The Buffer is not required any more. Free it before checking status.
    //

    RtlFreeHeap( RtlProcessHeap(), 0, PathName.Buffer );
    PathName.Buffer = NULL;


    if ( !NT_SUCCESS(Status) ) {

        //
        // The full path does not refer to a directory.  This could be a
        // device, but (unlike FindFirstFile()...) we don't care.  If it's
        // not a directory, we don't list it.
        //

        IF_DEBUG( DIR_LIST) {
            DBGPRINTF( ( DBG_CONTEXT, "Failed to open Dir %ws. Handle = %x\n",
                        pwszDirectoryName, hFindFile));
        }

        SetLastError( ERROR_PATH_NOT_FOUND);
        return ( FALSE);
    }

    InitializeListHead( &m_listDirectoryBuffers);

    //
    //  Loop through getting subsequent entries in the directory.
    //
    for( fFirstTime = TRUE; ; fFirstTime = FALSE)
    {
        PVOID pvBuffer;

        //
        // Get the next chunk of directory information.
        //  Obtained in a buffer  with LIST_ENTRY as the first member of buffer
        //

        #define DIR_ALLOC_SIZE  (DIRECTORY_BUFFER_SIZE + sizeof (LIST_ENTRY))

        pvBuffer = ALLOC( DIR_ALLOC_SIZE );
        cbExtraMem += DIR_ALLOC_SIZE;

        if ( pvBuffer == NULL ) {

            //
            //  Allocation failure.
            //
            SetLastError( ERROR_NOT_ENOUGH_MEMORY);
            fReturn = FALSE;
            break;                // Get out of the loop with failure.
        }

        pFileDirInfo = ( PFILE_BOTH_DIR_INFORMATION )
          ((( PCHAR ) pvBuffer) + sizeof( LIST_ENTRY ) );

        Status = NtQueryDirectoryFile(  hFindFile,         // fileHandle
                                        NULL,              // Event
                                        NULL,              // Apc Routine
                                        NULL,              // ApcContext
                                        &IoStatusBlock,    // PIoStatusBlock
                                        pFileDirInfo,      // PFileInfo
                                        DIRECTORY_BUFFER_SIZE, // Len
                                        FileBothDirectoryInformation, //Class
                                        FALSE,             // fSingleEntry ?
                                        NULL,              //FileName
                                        fFirstTime );      // RestartScan ?

        //
        //  If the NT API returns STATUS_NO_MORE_FILES, then it did not use
        //  our buffer at all.  We can just free it.
        //  Now's the time that we leave this loop, and stop reading the
        //  directory file.
        //

        if ( Status == STATUS_NO_MORE_FILES ) {

            FREE( pvBuffer );

            //
            //  Decrement the memory size so we don't get charged for it
            //

            cbExtraMem -= DIR_ALLOC_SIZE;

            fReturn = TRUE;
            break;
        }

        if ( NT_SUCCESS( Status ) || ( Status == STATUS_BUFFER_OVERFLOW ) )
        {

            ULONG Offset;

            //
            //  The buffer contains directory entries.
            //  Place it on the list of such buffers for this directory.
            //

            InsertBufferInTail( (PLIST_ENTRY ) pvBuffer);

            pFileDirInfoPrior = NULL;

            //
            // Scan thru the entries in the buffer,
            //  truncate the last entry ( if partial) and
            //  convert the Unicode strings, inplace to ansi strings.
            //

            do
            {
                pFileDirInfoPrior = pFileDirInfo;

                Offset = pFileDirInfo->NextEntryOffset;

                if ( ( Offset == 0 ) && ( Status == STATUS_BUFFER_OVERFLOW ) )
                {
                    //
                    //  If Status==STATUS_BUFFER_OVERFLOW, the last entry in
                    //  buffer may be a partial entry, broken on boundary of
                    //  buffer. The NT API will give us this entry again next
                    //  time around, so for now we patch the buffer up to
                    //  appear as if it does not contain the partial entry.
                    //

                    if ( pFileDirInfoPrior != NULL )
                    {
                        pFileDirInfoPrior->NextEntryOffset = 0;
                    }
                    else
                    {
                        //
                        // Some fatal problem. Should get out this loop.
                        //
                        BREAKPOINT();
                        fReturn = FALSE;
                        goto Failure;
                    }
                }
                else
                {
                    IncrementDirEntries();

                    if ( pFileDirInfo->FileNameLength != 0) {
                        pFileDirInfo->FileNameLength =
                             ConvertUnicodeToAnsiInPlace(
                                (LPWSTR ) pFileDirInfo->FileName,
                                (USHORT ) pFileDirInfo->FileNameLength);
                    }

                    if ( pFileDirInfo->ShortNameLength != 0) {
                        pFileDirInfo->ShortNameLength =
                           (CCHAR ) ConvertUnicodeToAnsiInPlace(
                                    (LPWSTR ) pFileDirInfo->ShortName,
                                     pFileDirInfo->ShortNameLength);
                    }


                    // Get the next entry in buffer
                    pFileDirInfo =
                      ( PFILE_BOTH_DIR_INFORMATION )
                        ((( PCHAR )pFileDirInfo ) + Offset );
                }
            }
            while ( Offset != 0);

            Status = STATUS_SUCCESS;
        }

        if ( !NT_SUCCESS(Status) )
        {
            fReturn = FALSE;
            break;
        }
    }

Failure:

    ASSERT( PathName.Buffer == NULL);
    if ( hFindFile != INVALID_HANDLE_VALUE) {
        NtClose( hFindFile );
        hFindFile = INVALID_HANDLE_VALUE;
    }

    *pcbMemUsed += cbExtraMem;

    return ( fReturn);
} // TS_DIRECTORY_HEADER::ReadFromNtDirectoryFile()




VOID
TS_DIRECTORY_HEADER::CleanupThis( VOID)
{
    PLIST_ENTRY pEntry;
    PLIST_ENTRY pNextEntry;

    for ( pEntry = QueryDirBuffersListEntry()->Flink;
         pEntry != QueryDirBuffersListEntry();
         pEntry  = pNextEntry )
    {
        pNextEntry = pEntry->Flink;

        //
        //  The buffers are allocated such that first member of buffer is
        //    LIST_ENTRY object.  Free it entirely.
        //
        FREE( pEntry );
    }

    InitializeListHead( QueryDirBuffersListEntry());

    if ( m_ppFileInfo != NULL) {

        FREE( m_ppFileInfo);
        m_ppFileInfo   = NULL;
    }

    m_hListingUser = INVALID_HANDLE_VALUE;
    m_nEntries     = 0;

    return;
} // TS_DIRECTORY_HEADER::CleanupThis()





BOOL
TS_DIRECTORY_HEADER::BuildFileInfoPointers(
    IN OUT DWORD *      pcbMemUsed
    )
/*++

  This constructs the indirection pointers from the buffers containing the
   file information.
  This array of indirection enables faster access to the file information
   structures stored.

   Should be always called after ReadFromNtDirectoryFile() to construct the
    appropriate pointers.

   Returns:
     TRUE on success and FALSE if there are any failures.
--*/
{
    BOOL fReturn = FALSE;
    DWORD cbAlloc;

    ASSERT( QueryNumEntries() != 0);  //  Any directory will atleast have "."

    //
    // Alloc space for holding the pointers for numEntries pointers.
    //

    cbAlloc = QueryNumEntries() * sizeof( PFILE_BOTH_DIR_INFORMATION );

    m_ppFileInfo = (PFILE_BOTH_DIR_INFORMATION *) ALLOC( cbAlloc );

    if ( m_ppFileInfo != NULL ) {

        int          index;
        PLIST_ENTRY  pEntry;
        ULONG        Offset;
        PFILE_BOTH_DIR_INFORMATION   pFileDirInfo;

        //
        //  Get the link to first buffer and start enumeration.
        //
        pEntry = QueryDirBuffersListEntry()->Flink;
        pFileDirInfo = (PFILE_BOTH_DIR_INFORMATION )( pEntry + 1 );

        for ( index = 0;
             index < QueryNumEntries();
             index++ ) {

            ASSERT( pEntry != QueryDirBuffersListEntry());

            m_ppFileInfo[index] = pFileDirInfo;    // store the pointer.

            Offset = pFileDirInfo->NextEntryOffset;

            if ( Offset != 0 ) {

                pFileDirInfo = (PFILE_BOTH_DIR_INFORMATION )
                                 ((( PCHAR )pFileDirInfo ) + Offset );
            } else {

                //
                // we are moving to the next buffer.
                //
                pEntry = pEntry->Flink;
                if ( pEntry == QueryDirBuffersListEntry()) {

                    ASSERT( index == QueryNumEntries() - 1);
                    break;
                }
                pFileDirInfo = ( PFILE_BOTH_DIR_INFORMATION )( pEntry + 1 );
            }


        } // for
        ASSERT( Offset == 0 );
        fReturn = SortInPlaceFileInfoPointers( m_ppFileInfo,
                                              QueryNumEntries(),
                                              AlphaCompareFileBothDirInfo);

    } // valid alloc of the pointers.

    *pcbMemUsed += cbAlloc;

    return ( fReturn);
} // TS_DIRECTORY_HEADER::BuildFileInfoPointers()




# if DBG

VOID
TS_DIRECTORY_HEADER::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                "Printing TS_DIRECTORY_HEADER ( %08x).\n", this));
    DBGPRINTF( ( DBG_CONTEXT,
                "ListingUser Handle = %08x\t Num Entries = %08x\n",
                m_hListingUser, m_nEntries));
    DBGPRINTF( ( DBG_CONTEXT,
                "Pointer to array of indirection pointers %08x\n",
                m_ppFileInfo));
    //
    //  The buffers containing the data of the file information not printed
    //

    return;
} // TS_DIRECTORY_HEADER::Print()


# endif // DBG

/************************ End of File ***********************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\getdir.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        getdir.cxx

   Abstract:
        This module implements the member functions for TS_DIRECTORY_INFO

   Author:

           Murali R. Krishnan    ( MuraliK )     16-Jan-1995

   Project:

          Tsunami Lib
          ( Common caching and directory functions for Internet Services)

   Functions Exported:

         TS_DIRECTORY_INFO::CleanupThis()

         TS_DIRECTORY_INFO::GetDirectoryListingA()
                       IN LPCSTR     pszDirectoryName,
                       IN  HANDLE    hListingUser)

         TS_DIRECTORY_INFO::SortFileInfoPointers(
                       IN PFN_CMP_FILE_BOTH_DIR_INFO pfnCompare)

         TS_DIRECTORY_INFO::FilterFiles(
                       IN PFN_IS_MATCH_FILE_BOTH_DIR_INFO  pfnMatch,
                       IN LPVOID     pContext);

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "tsunamip.hxx"
# include "dbgutil.h"
# include <string.h>

/************************************************************
 *     Type Definitions
 ************************************************************/


dllexp
VOID
TS_DIRECTORY_INFO::CleanupThis( VOID)
{
    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Cleaning up TS_DIRECTORY_INFO ( %08x)\n",
                    this));
        Print();
    }

    if ( m_fValid) {

        if ( m_pTsDirectoryHeader != NULL) {

            TsFreeDirectoryListing( m_tsCache, m_pTsDirectoryHeader);
            m_pTsDirectoryHeader = NULL;
        }

        ASSERT( m_pTsDirectoryHeader == NULL);

        if ( m_prgFileInfo != NULL) {
            FREE( m_prgFileInfo);
            m_prgFileInfo = NULL;
        }
    }

    ASSERT( m_pTsDirectoryHeader == NULL);
    ASSERT( m_prgFileInfo == NULL);
    m_fValid = 0;
    m_cFilesInDirectory = 0;

} // TS_DIRECTORY_INFO::CleanupThis()




static BOOL
MakeCopyOfFileInfoPointers(
   IN OUT  PFILE_BOTH_DIR_INFORMATION ** pppFileInfoTo,
   IN const PFILE_BOTH_DIR_INFORMATION  * ppFileInfoFrom,
   IN int  nEntries)
/*++
  Allocates memory and makes a copy of the file info pointers in the array
   in ppFileInfoFrom.

  Returns:
    TRUE if success and FALSE if there is any failure.
--*/
{
    DWORD cbCopy;

    ASSERT( *pppFileInfoTo == NULL);

    cbCopy = nEntries * sizeof( PFILE_BOTH_DIR_INFORMATION);

    *pppFileInfoTo = (PFILE_BOTH_DIR_INFORMATION *) ALLOC( cbCopy);

    if ( *pppFileInfoTo != NULL) {

        memcpy( (PVOID ) *pppFileInfoTo,
               (const PVOID ) ppFileInfoFrom,
               cbCopy);

    } else {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
    }

    return ( *pppFileInfoTo != NULL);
} // MakeCopyOfFileInfoPointers()



dllexp
BOOL
TS_DIRECTORY_INFO::GetDirectoryListingA(
    IN  LPCSTR          pszDirectoryName,
    IN  HANDLE          hListingUser)
{
    if ( m_pTsDirectoryHeader == NULL) {

        //
        //  Only if already a directory listing is not obtained.
        //  we obtain newly
        //

        IF_DEBUG( DIR_LIST) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "Obtaining Dir Listing for %s. UserHandle=%08x.\n",
                        pszDirectoryName, hListingUser));
        }

        m_fValid = TsGetDirectoryListingA( m_tsCache,
                                           pszDirectoryName,
                                           hListingUser,
                                           &m_pTsDirectoryHeader);

        m_fValid = m_fValid &&
                   MakeCopyOfFileInfoPointers(
                       &m_prgFileInfo,
                       m_pTsDirectoryHeader->QueryArrayOfFileInfoPointers(),
                       m_pTsDirectoryHeader->QueryNumEntries());

        m_cFilesInDirectory = ( m_pTsDirectoryHeader == NULL) ? 0 :
                               m_pTsDirectoryHeader->QueryNumEntries();
    }

    return ( m_fValid);
} // TS_DIRECTORY_INFO::GetDirectoryListingA()


# ifdef UNICODE

dllexp
BOOL
TS_DIRECTORY_INFO::GetDirectoryListingW(
    IN  LPCWSTR         pwszDirectoryName,
    IN  HANDLE          hListingUser)
{
    if ( m_pTsDirectoryHeader == NULL) {

        //
        //  Only if already a directory listing is not obtained.
        //  we obtain newly
        //

        m_fValid = TsGetDirectoryListingW( m_tsCache,
                                           pwszDirectoryName,
                                           hListingUser,
                                           &m_pTsDirectoryHeader);

        m_fValid = m_fValid &&
                   MakeCopyOfFileInfoPointers(
                       &m_prgFileInfo,
                       m_pTsDirectoryHeader->QueryArrayOfFileInfoPointers(),
                       m_pTsDirectoryHeader->QueryNumEntries());

        m_cFilesInDirectory = ( m_pTsDirectoryHeader == NULL) ? 0 :
                               m_pTsDirectoryHeader->QueryNumEntries();
    }

    return ( m_fValid);
} // TS_DIRECTORY_INFO::GetDirectoryListingW()

# endif // UNICODE



dllexp
BOOL
TS_DIRECTORY_INFO::SortFileInfoPointers(
    IN PFN_CMP_FILE_BOTH_DIR_INFO pfnCompare)
{
    BOOL  fReturn;

    if ( IsValid()) {

        fReturn = SortInPlaceFileInfoPointers( m_prgFileInfo,
                                              m_cFilesInDirectory,
                                              pfnCompare);
    }

    return ( fReturn);
} // TS_DIRECTORY_INFO::SortFileInfoPointers()




dllexp
BOOL
TS_DIRECTORY_INFO::FilterFiles( IN PFN_IS_MATCH_FILE_BOTH_DIR_INFO  pfnMatch,
                                IN LPVOID  pContext)
/*++
  This function filters the list of files using the pfnMatch function
        and the context information specified by pContext.
  This function eliminates all the pointers to FileInfo which do not
    match the given file specification.

  Returns:
    TRUE on success and FALSE on failure.
--*/
{
    BOOL fReturn = FALSE;

    if ( IsValid()) {

        int idxScan;      // for scanning the files
        int idxCur;       // for updating after filter

        IF_DEBUG( DIR_LIST) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "FilterFiles in DirList( %08x) for FileSpec %08x\n",
                        this, pContext));
        }

        for( idxCur = idxScan = 0;
            idxScan < m_cFilesInDirectory;
            idxScan++) {

            PFILE_BOTH_DIR_INFORMATION   pFileInfo =
               GetFileInfoPointerFromIdx( idxScan);

            ASSERT( pFileInfo != NULL);
            ASSERT( idxCur <= idxScan);

            if ( (*pfnMatch)( pFileInfo, pContext)) {

                //
                //  this is a match. Retain this item and advance CurPtr
                //
                m_prgFileInfo[ idxCur++] = m_prgFileInfo[ idxScan];
            }
        } // for

        m_cFilesInDirectory = idxCur;
        fReturn = TRUE;
    }

    return ( fReturn);
} // TS_DIRECTORY_INFO::FilterFiles()




# if DBG

VOID
TS_DIRECTORY_INFO::Print( VOID) const
{

    DBGPRINTF( ( DBG_CONTEXT,
                " Printing TS_DIRECTORY_INFO ( %08x).\n", this));
    DBGPRINTF( ( DBG_CONTEXT,
                "NumEntries=%d\t Valid = %d\n",
                m_cFilesInDirectory, m_fValid));
    DBGPRINTF( ( DBG_CONTEXT,
                "Directory Header ( %08x) \t ArrayOfFileInfo = %08x\n",
                m_pTsDirectoryHeader, m_prgFileInfo));

    for( int idx  = 0; idx < m_cFilesInDirectory; idx++) {

        PFILE_BOTH_DIR_INFORMATION pfi = m_prgFileInfo[idx];

        DBGPRINTF( ( DBG_CONTEXT,
                     "rgFileInfo[%4d] = %08x. Name=%s Attr=0x%x"
                     "Size=0x%x:%x\n",
                     idx, pfi,
                     pfi->FileName,
                     pfi->FileAttributes,
                     pfi->EndOfFile.HighPart,
                     pfi->EndOfFile.LowPart
                    ));
    }

    m_pTsDirectoryHeader->Print();

    return;
} // TS_DIRECTORY_INFO::Print()


# endif // DBG




BOOL __cdecl
RegExpressionMatchFileInfo( IN const FILE_BOTH_DIR_INFORMATION  * pFileInfo, 
                            IN CHAR * pszExpression)
/*++
  This function tries to find a match between the file name in
  pFileInfo and the regular expression specified in pszExpression.

  Arguments:
     pFileInfo  -- pointer to file information consisting under query.
     pszExpression - pointer to null-terminated string containing the 
                      regular expression, against which file name is tobe
                      matched for.

  Returns:
    TRUE on a match and false if there is any failure.
--*/
{
    const CHAR * pszFileName;

    DBG_ASSERT( pFileInfo != NULL);
    pszFileName = (const CHAR *) pFileInfo->FileName;
    
    if ( strpbrk( pszExpression, "?*<>") != NULL) {
        
        // No Wild cards. Do normal file comparisons
        return ( strcmp( pszFileName, pszExpression) == 0);
    } else {

        // do a case sensitive comparison
        return IsNameInRegExpressionA( pszExpression, pszFileName, FALSE);
    }

} // RegExpressionMatch()





/************************************************************
 *  Following code is based on the FileSystem Rtl routines
 *    from ntos\fsrtl\name.c
 *  But these are optimized for performance, in our case
 *    using ANSI strings!
 ************************************************************/

# define MAX_MATCHES_ARRAY_SIZE    (16)
# define IS_EMPTY_STRING(psz)      ( (psz) == NULL || *(psz) == '\0')


//
// Original code used USHORT for ULEN. However using USHORT asks
//  a 32 bit processor to add  "and <value>, 0xff for each instruction
//  that accessed the 16 bit (USHORT) value.
// Hence, I decided to use DWORD, since the space usage is not tremendous
//   during the fast path work, compared to performance benefits.
//  - MuraliK (Oct 27, 1995)
//

//  typedef  USHORT  ULEN; 
typedef DWORD ULEN;


BOOL __cdecl
IsNameInRegExpressionA(
    IN LPCSTR   pszExpression,
    IN LPCSTR   pszName,
    IN BOOL     fIgnoreCase)
/*++
  This routine compares an ANSI name and an expression and decries to the
  caller if the name is in hte language defined by the expression. The input
  name cannot contain wildcards, while the expression itself may contain
  wildcards.
  
  Expression wild cards are evaluated as shown in the non-deterministic finite
   automatons below. Note that ~* and ~? stand for DOS_STAR and DOS_QM.


             ~* is DOS_STAR, ~? is DOS_QM, and ~. is DOS_DOT


                                       S
                                    <-----<
                                 X  |     |  e       Y
             X * Y ==       (0)----->-(1)->-----(2)-----(3)


                                      S-.
                                    <-----<
                                 X  |     |  e       Y
             X ~* Y ==      (0)----->-(1)->-----(2)-----(3)



                                X     S     S     Y
             X ?? Y ==      (0)---(1)---(2)---(3)---(4)



                                X     .        .      Y
             X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^


                                X     S-.     S-.     Y
             X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^



         where S is any single character

               S-. is any single character except .

               e is a null character transition

               EOF is the end of the name string


    The last construction, ~? (the DOS question mark), can either match any
    single character, or upon encountering a period or end of input string,
    advances the expression to the end of the set of contiguous ~?s.  This may
    seem somewhat convoluted, but is what DOS needs.

  Arguments:
    pszExpression - Supplies the input expression to check against 
     ( Caller must already lowercased if passing fIgnoreCase TRUE.)
     
    pszName  - supplies the input name to check for.
    
    fIgnoreCase - if TRUE, the name should be lower-cased before comparing.
     ( that is done by this function, dynamically without destroying pszName)

    This function is costly, if the pszExpression does not contain 
      any wild cards to be matched for. So Dont use it if there are 
      no wild cards in the pszExpression

  Returns:
     BOOL  -- TRUE if pszName is an element in the set of strings denoted
        by the input expression.  FALSE if otherwise.
--*/
{
    ULEN    NameLen;       // length in character count
    ULEN    ExprLen;

    /*
     * Algorithm:
     *  Keep track of all possible locations in the regular expression
     *   that are matching the name. If when the name has been exhausted 
     *   one of the locations in the expression is also just exhausted, the
     *  name is in the language defined by the regular expression.
     */
         

    DBG_ASSERT( pszName != NULL && *pszName != '\0');
    DBG_ASSERT( pszExpression != NULL && *pszName != '\0');

    //
    // if one string is empty return FALSE. If both are empty TRUE.
    //

    if ( IS_EMPTY_STRING(pszName) || IS_EMPTY_STRING(pszExpression)) {

        IF_DEBUG( DIR_LIST) {
            DBGPRINTF((DBG_CONTEXT, " IsNameInRegExpr( %s, %s, %d) ==>%d\n",
                       pszExpression, pszName, fIgnoreCase,
                       !(*pszName + *pszExpression)
                       ));
        }

        return (BOOL ) (!(*pszName + *pszExpression));
    }

    NameLen = strlen(pszName);
    ExprLen = strlen(pszExpression);

    //
    // Special case: reduce the most common wild card search of *
    //

    if ( ExprLen == 1 && pszExpression[0] == '*') {
        
        IF_DEBUG ( DIR_LIST) {
            DBGPRINTF((DBG_CONTEXT, " IsNameInRegExpr( %s, %s, %d) ==>%d\n",
                       pszExpression, pszName, fIgnoreCase,
                       TRUE
                       ));
        }

        // matches anything. so return TRUE
        return (TRUE);
    }

    //
    //  Walk through the name string, picking off characters.  We go one
    //  character beyond the end because some wild cards are able to match
    //  zero characters beyond the end of the string.
    //
    //  With each new name character we determine a new set of states that
    //  match the name so far.  We use two arrays that we swap back and forth
    //  for this purpose.  One array lists the possible expression states for
    //  all name characters up to but not including the current one, and other
    //  array is used to build up the list of states considering the current
    //  name character as well.  The arrays are then switched and the process
    //  repeated.
    //
    //  There is not a one-to-one correspondence between state number and
    //  offset into the pszExpression.  This is evident from the NFAs in the
    //  initial comment to this function.  State numbering is not continuous.
    //  This allows a simple conversion between state number and expression
    //  offset.  Each character in the Expression can represent one or two
    //  states.  '*' and DOS_STAR generate two states: ExprOffset*2 and
    //  ExprOffset*2 + 1.  All other expression characters can produce only
    //  a single state.  Thus ExprOffset = State/2.
    //
    //
    //  Here is a short description of the variables involved:
    //
    //  NameOffset  -The offset of the current name char being processed.
    //
    //  ExprOffset  -The offset of the current expression char being processed.
    //
    //  SrcCount    -Prior match being investigated with current name char
    //
    //  DestCount   -Next location to put a matching assuming current name char
    //
    //  NameFinished - Allows one more iteration through the Matches array
    //                 after the name is exhusted (to come *s for example)
    //
    //  PreviousDestCount - This is used to prevent entry duplication,
    //                       see comment
    //
    //  PreviousMatches   - Holds the previous set of matches (the Src array)
    //
    //  CurrentMatches    - Holds the current set of matches (the Dest array)
    //
    //  AuxBuffer, LocalBuffer - the storage for the Matches arrays
    //

    ULEN NameOffset;    // offset in terms of byte count
    ULEN ExprOffset;    // offset in terms of byte count

    ULONG SrcCount;
    ULONG DestCount;
    ULONG PreviousDestCount;
    ULONG MatchesCount;

    CHAR NameChar, ExprChar;

    // for prev and current matches
    ULEN *AuxBuffer = NULL;
    ULEN *PreviousMatches;
    ULEN *CurrentMatches;

    ULEN MaxState;
    ULEN CurrentState;

    BOOL NameFinished;
    
    ULEN LocalBuffer[MAX_MATCHES_ARRAY_SIZE * 2]; 

    // set up the intial values
    // Use the different portions of local buffer for matches.

    PreviousMatches = &LocalBuffer[0];
    CurrentMatches  = &LocalBuffer[MAX_MATCHES_ARRAY_SIZE];
    
    PreviousMatches[0] = 0;
    MatchesCount       = 1;

    NameOffset = 0;
    MaxState   = (ULEN ) (ExprLen * 2);

    NameFinished = FALSE;
    while (!NameFinished) {


        if ( NameOffset < NameLen) {
            
            NameChar = pszName[NameOffset/sizeof(CHAR)];
            NameOffset += sizeof(CHAR);
        } else {
            
            NameFinished = TRUE;
            
            // if we already exhauseted expression, stop. Else continue
            DBG_ASSERT( MatchesCount >= 1);
            if ( PreviousMatches[MatchesCount - 1] == MaxState) {
                
                break;
            }
        }

        //
        // Now, for each of previous stored expression matches,
        //  see what we can do with the new name character.
        //
    
        DestCount = 0;
        PreviousDestCount = 0;

        for( SrcCount = 0;  SrcCount < MatchesCount; ) {

            ULEN Length;

            //
            //  We have to carry on our expression analysis as far as possible
            //  for each character of name, so we loop here until the
            //  expression stops matching.  A clue here is that expression
            //  cases that can match zero or more characters end with a
            //  continue, while those that can accept only a single character
            //  end with a break.
            //

            ExprOffset = (ULEN)((PreviousMatches[SrcCount++] + 1) / 2);

            for( Length = 0; ExprOffset != ExprLen; ) {

                //
                // increment the expression offset to move to next character.
                //
                ExprOffset += Length;
                Length = sizeof(CHAR);

                CurrentState = (ULEN)(ExprOffset * 2);
                
                if ( ExprOffset == ExprLen * sizeof(CHAR)) {

                    CurrentMatches[DestCount++] = MaxState;
                    break;
                }
                
                ExprChar = pszExpression[ExprOffset/sizeof(CHAR)];

                ASSERT( !fIgnoreCase ||
                        !((ExprChar >= 'A') && (ExprChar <= 'Z')));

                //
                // Before we get started, we have to check for something really
                //  gross. We may be about to exhaust the local space for
                //  ExpressionMatch[][], so when we have to allocate some
                //   pool if this is the case. Yuk!
                //

                if ( (DestCount >= MAX_MATCHES_ARRAY_SIZE - 2) ) {

                    if (AuxBuffer == NULL) {
                    
                        // 2 copies of array each with 2 states for each char
                        //  in the expression. Each state == ULEN.

                        IF_DEBUG( DIR_LIST) {
                            DBGPRINTF((DBG_CONTEXT, "IsNInExpr(%s,%s,%d):"
                                       "alloc %d for exprlen=%d\n",
                                       pszExpression, pszName, fIgnoreCase,
                                       (ExprLen + 1) *sizeof(ULEN)*2*2,
                                       ExprLen));
                        }
                        
                        AuxBuffer = ((ULEN *) 
                                     ALLOC((ExprLen +1) * sizeof(ULEN)* 2*2)
                                     );
                        if ( AuxBuffer == NULL) {
                        
                            DBG_ASSERT(!"Failure in mem alloc");
                            
                            return ( FALSE);
                        }
                        
                        RtlCopyMemory( AuxBuffer, CurrentMatches,
                                      MAX_MATCHES_ARRAY_SIZE*sizeof(ULEN));
                        CurrentMatches = AuxBuffer;
                        
                        RtlCopyMemory( AuxBuffer + (ExprLen + 1)*2,
                                      PreviousMatches,
                                      MAX_MATCHES_ARRAY_SIZE * sizeof(ULEN));
                        
                        PreviousMatches = AuxBuffer + (ExprLen + 1)*2;
                    } else {

                        DBG_ASSERT(!"Double Overflow occured\n");
                    }
                } 

                //
                // '*' Matches any character zero or more times
                //
                if ( ExprChar == '*') {

                    // Add all possible next states into the list 
                    // use the above state diagram to identify this.
                    CurrentMatches[DestCount] = CurrentState;
                    CurrentMatches[DestCount+1] = CurrentState + 1;
                    DestCount+= 2;
                    continue;
                }

                //
                // ANSI_DOS_STAR matches any char, zero or more times,
                //  except the DOS's extension '.'
                //

                if ( ExprChar == ANSI_DOS_STAR) {

                    BOOL  ICanEatADot = FALSE;
                    
                    //
                    // If we are at a period, determine if we are
                    //  allowed to consume it. i.e make it is not last one.
                    //
                    if ( !NameFinished && (NameChar == '.')) {

                        ULEN cchOffset;  // in character counts
                        for( cchOffset = NameOffset/sizeof(CHAR); 
                            cchOffset < NameLen; 
                            cchOffset ++) {
                            
                            if ( pszName[cchOffset]  == '.') {
                                
                                ICanEatADot = TRUE;
                                break;
                            }
                        } // for
                    }

                    if ( NameFinished || (NameChar != '.') || ICanEatADot) {

                        //
                        // Go ahead and consume this character.
                        // Gives two options to move forward.
                        //
                        CurrentMatches[DestCount] = CurrentState;
                        CurrentMatches[DestCount+1] = CurrentState+1;
                        DestCount += 2;
                    } else {
                        
                        //
                        // We are at the period. We can only match zero
                        //  or more characters (ie. the epsilon transition)
                        //
                        
                        CurrentMatches[DestCount++] = CurrentState+1;
                        continue;
                    }
                } // if ( ExprChar == DOS_STAR)
                        
                //
                // The following expression characters all match by consuming
                //  a character, thus force the expression, and thus state
                //  move forward.
                //

                CurrentState += (ULEN)(sizeof(CHAR) *2);

                //
                //  DOS_QM is the most complicated.  If the name is finished,
                //  we can match zero characters.  If this name is a '.', we
                //  don't match, but look at the next expression.  Otherwise
                //  we match a single character.
                //

                if ( ExprChar == ANSI_DOS_QM ) {

                    if ( NameFinished || (NameChar == '.') ) {

                        continue;
                    }

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  DOS_DOT can match either a period, or zero characters
                //  beyond the end of the name
                //

                if ( ExprChar == ANSI_DOS_DOT) {

                    if ( NameFinished) {
                        continue;
                    }
                    
                    if ( NameChar == '.') {
                        
                        CurrentMatches[DestCount++] = CurrentState;
                        break;
                    }
                }
                
                //
                // From this point on a name character is required to
                //  even continue searching, let alone make a match.
                // So if Name is finished, stop.
                //
                    
                if ( NameFinished) {

                    break;
                }

                //
                // If the expression was a '?' we can match it once
                //
                if ( ExprChar == '?') {
                    
                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                // 
                // Finally, check if the expression char matches name char
                //

                if ( ExprChar == (CHAR ) (fIgnoreCase ? 
                                          tolower(NameChar) : NameChar)
                    ){
                    
                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                // The expression did not match, go look at the next 
                //  previous match
                //
                break;
            } // for matching from an old state.


            //
            //  Prevent duplication in the destination array.
            //
            //  Each of the arrays is montonically increasing and non-
            //  duplicating, thus we skip over any source element in the src
            //  array if we just added the same element to the destination
            //  array.  This guarentees non-duplication in the dest. array.
            //
            
            if ((SrcCount < MatchesCount) &&
                (PreviousDestCount < DestCount) ) {

                while ( SrcCount < MatchesCount && 
                       PreviousDestCount < DestCount) {
                    //
                    // logic here is: by eliminating the states with
                    //  lesser number than current matched ==> we are 
                    //  skipping over the smallest states from which 
                    //  no match may be found.
                    //
                    
                    if ( PreviousMatches[SrcCount] <
                        CurrentMatches[PreviousDestCount] ) {
                        
                        SrcCount ++;
                    }

                    PreviousDestCount += 1;
                } // while
            }
        } // for each of old matches....
    
        //
        //  If we found no matches in the just finished iteration, it's time
        //  to bail.
        //
        
        if ( DestCount == 0 ) {
            
            if (AuxBuffer != NULL) { 
                IF_DEBUG( DIR_LIST) {
                    
                    DBGPRINTF((DBG_CONTEXT, " Freeing %08x\n", AuxBuffer));
                }
                
                FREE( AuxBuffer ); 
            }
            
            return FALSE;
        }
        
        //
        //  Swap the meaning the two arrays
        //

        {
            ULEN *Tmp;

            Tmp = PreviousMatches;

            PreviousMatches = CurrentMatches;

            CurrentMatches = Tmp;
        }

        MatchesCount = DestCount;

    } // for each char in Name, until name is finished.

    DBG_ASSERT(MatchesCount > 0);
    CurrentState = PreviousMatches[MatchesCount-1];
    if (AuxBuffer != NULL) { 
        IF_DEBUG( DIR_LIST) {
            DBGPRINTF((DBG_CONTEXT, " Freeing %08x\n", AuxBuffer));
        }

        FREE( AuxBuffer ); 
    }
    
    return (BOOL ) ( CurrentState == MaxState);

} //  IsNameInRegExpressionA()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\dirlistp.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        getdirp.cxx

   Abstract:
        This module implements the functions for getting directory listings
         and transparently caching them.
        ( This uses OS specific functions to obtain the directory).

   Author:

           Murali R. Krishnan    ( MuraliK )     13-Jan-1995

   Project:

          Tsunami Lib
          ( Common caching and directory functions for Internet Services)

   Functions Exported:
   BOOL TsGetDirectoryListing()
   BOOL TsFreeDirectoryListing()
   int __cdecl
   AlphaCompareFileBothDirInfo(
              IN const void *   pvFileInfo1,
              IN const void *   pvFileInfo2)

   TS_DIRECTORY_HEADER::ReadWin32DirListing( IN LPCSTR pszDirectoryName)

   TS_DIRECTORY_HEADER::ReadFromNtDirectoryFile(
                  IN LPCWSTR          pwszDirectoryName
                  )
   TS_DIRECTORY_HEADER::BuildFileInfoPointers(
                  IN LPCWSTR          pwszDirectoryName
                  )
   TS_DIRECTORY_HEADER::CleanupThis()

   Revision History:
       MuraliK     06-Dec-1995  Used Win32 apis instead of NT apis

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "tsunamip.hxx"

# include <stdlib.h>
# include <string.h>
# include <dbgutil.h>

/************************************************************
 *     Type Definitions
 ************************************************************/

# define DBGCODE(s)      DBG_CODE(s)

#define DIRECTORY_BUFFER_SIZE 8160          /* < 8192 bytes */

/************************************************************
 *    Functions
 ************************************************************/


BOOL FreeDirectoryHeaderContents( PVOID pvOldBlock );

PTS_DIRECTORY_HEADER
TsGetFreshDirectoryHeader(
     IN const TSVC_CACHE  &  tsCache,
     IN LPCSTR               pszDirectoryName,
     IN HANDLE               hLisingUser);



dllexp
BOOL
TsGetDirectoryListing(
    IN const TSVC_CACHE         &tsCache,
    IN      PCSTR               pszDirectoryName,
    IN      HANDLE              hListingUser,
    OUT     PTS_DIRECTORY_HEADER * ppTsDirectoryHeader
    )
/*++
  This function obtains the directory listing for dir specified
        in pszDirectoryName.

  Arguments:
    tsCache          Cache structure which is used for lookup
    pszDirectoryName  pointer to string containing the directory name
    ListingUser        Handle for the user opening the directory
    ppTsDirectoryHeader
       pointer to pointer to class containing directory information.
       Filled on successful return. On failure this will be NULL

  Returns:
      TRUE on success and FALSE if  there is a failure.
--*/
{
    PVOID          pvBlob = NULL;
    ULONG          ulSize = 0;
    BOOL           bSuccess;

    ASSERT( pszDirectoryName   != NULL );
    ASSERT( ppTsDirectoryHeader != NULL);


    //
    //  First, check to see if we have already cached a listing of this
    //  directory.
    //

    *ppTsDirectoryHeader = NULL;
    bSuccess = TsCheckOutCachedBlob(  tsCache,
                                       pszDirectoryName,
                                       RESERVED_DEMUX_DIRECTORY_LISTING,
                                       ( PVOID * )&pvBlob,
                                       &ulSize );

    if ( bSuccess )
    {
        ASSERT( BLOB_IS_OR_WAS_CACHED( pvBlob ) );

        *ppTsDirectoryHeader = (PTS_DIRECTORY_HEADER )pvBlob;
        ASSERT ( (*ppTsDirectoryHeader)->IsValid());

        //
        //  Make sure the user tokens match
        //

        if ( hListingUser == (*ppTsDirectoryHeader)->QueryListingUser() ) {

            IF_DEBUG( DIR_LIST) {

                DBGPRINTF( (DBG_CONTEXT,
                            "Obtained DirListing (%s) from Cache (%08x)\n",
                            pszDirectoryName,
                            *ppTsDirectoryHeader));

                (*ppTsDirectoryHeader)->Print();
            }

            return TRUE;
        }

        //
        //  User token doesn't match, don't return it
        //

        bSuccess = TsCheckInCachedBlob( pvBlob );

        ASSERT( bSuccess );
    }

    //
    //  The block was not present in cache.
    //  Obtain a fresh copy of the directory listing and cache it.
    //

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( (DBG_CONTEXT,
                    "Missing DirListing (%s) in cache. Generating newly\n",
                    pszDirectoryName));
    }

    *ppTsDirectoryHeader = TsGetFreshDirectoryHeader(
                                                      tsCache,
                                                      pszDirectoryName,
                                                      hListingUser );


    bSuccess = ( *ppTsDirectoryHeader != NULL);

    IF_DEBUG( DIR_LIST) {

        DBGCODE(
            CHAR pchBuff[600];
            wsprintfA( pchBuff,
                      "Obtained DirListing (%s). NEntries = %d\n",
                      pszDirectoryName,
                      (*ppTsDirectoryHeader)->QueryNumEntries());
            OutputDebugString( pchBuff);
        );
    }

    return ( bSuccess);

} // TsGetDirectoryListing()




dllexp
BOOL
TsFreeDirectoryListing
(
    IN const TSVC_CACHE &    tsCache,
    IN PTS_DIRECTORY_HEADER  pDirectoryHeader
)
{
    BOOL fReturn;
    BOOL fCached = BLOB_IS_OR_WAS_CACHED( (PVOID ) pDirectoryHeader);

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "TsFreeDirectoryListing( %08x) called. Cached = %d\n",
                    pDirectoryHeader,
                    fCached));

        pDirectoryHeader->Print();
    }

    if ( fCached )
    {
        fReturn = TsCheckInCachedBlob( ( PVOID )pDirectoryHeader );
    }
    else
    {
        fReturn = TsFree( tsCache, ( PVOID )pDirectoryHeader );
    }

    return( fReturn);
} // TsFreeDirectoryListing()







PTS_DIRECTORY_HEADER
TsGetFreshDirectoryHeader(
     IN const TSVC_CACHE  &  tsCache,
     IN LPCSTR               pszDirectoryName,
     IN HANDLE               hListingUser)
/*++

  This function obtains a fresh copy of the directory listing for the
    directory specified and caches it if possible, before returning pointer
    to the directory information.

  Returns:
     On success it returns the pointer to newly constructed directory listing.
     On failure this returns a NULL

--*/
{
    PTS_DIRECTORY_HEADER pDirectoryHeader;
    PVOID               pvGuardBlob;
    BOOL                bSuccess;
    BOOL                bCachedGuardianBlob;

    //
    //  If we are going to cache this directory, we would like to increase the
    //  likelihood that it is an "atomic" snapshot.  This is done as follows:
    //
    //  We cache and hold checked-out a small blob while create the directory
    //  listing.  If that Blob (1) could not be cached, or (2) was ejected
    //  from the cache while we were generating a listing, then we do not
    //  attempt to cache the directory.
    //
    //  Reasoning:
    //
    //  1) If the Blob couldn't be cached then the directory info won't be any
    //     different.
    //
    //  2) If the Blob was ejected, the directory must have changed while we
    //     were reading it.  If this happens, we don't want to cache possibly
    //     inconsistent data.
    //
    //  If the directory changed and the Blob has not yet been ejected, the
    //  directory will soon be ejected anyway.  Notice that the Blob is not
    //  DeCache()'d until after the directory has been cached.
    //

    if ( !TsAllocate( tsCache, sizeof( TS_DIRECTORY_HEADER),
                     (PVOID *) &pvGuardBlob)) {

        //
        //  Failure to allocate and secure a guardian blob.
        //

        IF_DEBUG( DIR_LIST) {

            DBGPRINTF( (DBG_CONTEXT,
                        "Allocation of Guardianblob for %s failed. Error=%d\n",
                        pszDirectoryName, GetLastError()));
        }

        return ( NULL);
    }

    //
    //  A successful guardian block allocated. Try and cache it.
    //

    bCachedGuardianBlob = TsCacheDirectoryBlob(
                              tsCache,
                              pszDirectoryName,
                              RESERVED_DEMUX_ATOMIC_DIRECTORY_GUARD,
                              pvGuardBlob,
                              TRUE );

    if ( !bCachedGuardianBlob ) {

        BOOL  fFreed;

        //
        //  Already there is one such cached blob. ignore this blob.
        //  So free up the space used.
        //

        fFreed = TsFree( tsCache, pvGuardBlob );
        ASSERT( fFreed);
        pvGuardBlob = NULL;
    }


    //
    // Allocate space for Directory listing
    //

    bSuccess = TsAllocateEx( tsCache,
                            sizeof( TS_DIRECTORY_HEADER ),
                            ( PVOID * )&pDirectoryHeader,
                            FreeDirectoryHeaderContents );

    if ( bSuccess) {

        BOOL fReadSuccess;
        DWORD cbBlob = 0;

        ASSERT( pDirectoryHeader != NULL);

        pDirectoryHeader->ReInitialize();  // called since we raw alloced space
        pDirectoryHeader->SetListingUser( hListingUser);

        fReadSuccess = (pDirectoryHeader->ReadWin32DirListing(pszDirectoryName,
                                                               &cbBlob ) &&
                        pDirectoryHeader->BuildFileInfoPointers( &cbBlob )
                        );

        if ( fReadSuccess) {

            //
            //  Attempt and cache the blob if the blob size is cacheable
            //

            if ( bCachedGuardianBlob &&
                 !BLOB_IS_EJECTATE( pvGuardBlob )  ) {


                ASSERT( BLOB_IS_OR_WAS_CACHED( pvGuardBlob ) );

                bSuccess =
                  TsCacheDirectoryBlob(tsCache,
                                        pszDirectoryName,
                                        RESERVED_DEMUX_DIRECTORY_LISTING,
                                        pDirectoryHeader,
                                        TRUE );

                if ( bSuccess ) {

                    INC_COUNTER( tsCache.GetServiceId(), CurrentDirLists );
                }

                //
                // Even if caching of the blob failed, that is okay!
                //

                if ( bSuccess && BLOB_IS_EJECTATE( pvGuardBlob ) ) {

                    TsExpireCachedBlob( tsCache, pDirectoryHeader );
                }

            }

        } else {

            //
            // Reading directory failed.
            //  cleanup directory related data and get out.
            //

            BOOL fFreed = TsFree( tsCache, pDirectoryHeader);
            ASSERT( fFreed);
            pDirectoryHeader = NULL;
            bSuccess = FALSE;
        }

    } else {

        //
        // Allocation of Directory Header failed.
        //
        ASSERT( pDirectoryHeader == NULL);
    }

    // Free up the guardian block and exit.

    if ( bCachedGuardianBlob) {

        bSuccess = TsExpireCachedBlob( tsCache, pvGuardBlob );

        ASSERT( bSuccess );

        bSuccess = TsCheckInCachedBlob(  pvGuardBlob );
        ASSERT( bSuccess );

        pvGuardBlob = NULL;
    }

    ASSERT( pvGuardBlob  == NULL);
    return ( pDirectoryHeader);
} // TsGetFreshDirectoryHeader




BOOL
FreeDirectoryHeaderContents( PVOID pvOldBlock )
{
    PTS_DIRECTORY_HEADER  pDirectoryHeader;

    pDirectoryHeader = ( PTS_DIRECTORY_HEADER )pvOldBlock;

    pDirectoryHeader->CleanupThis();

    //
    //  The item may never have been added to the cache, don't
    //  count it in this case
    //

    if ( BLOB_IS_OR_WAS_CACHED( pvOldBlock ) ) {

        DEC_COUNTER( BLOB_GET_SVC_ID( pvOldBlock ), CurrentDirLists );
    }

    return ( TRUE);
}  //  FreeDirectoryHeaderContents()




int __cdecl
AlphaCompareFileBothDirInfo(
   IN const void *   pvFileInfo1,
   IN const void *   pvFileInfo2)
{
    const WIN32_FIND_DATA * pFileInfo1 =
        *((const WIN32_FIND_DATA **) pvFileInfo1);
    const WIN32_FIND_DATA * pFileInfo2 =
        *((const WIN32_FIND_DATA **) pvFileInfo2);

    ASSERT( pFileInfo1 != NULL && pFileInfo2 != NULL);

    return ( lstrcmp( (LPCSTR )pFileInfo1->cFileName,
                      (LPCSTR )pFileInfo2->cFileName));

} // AlphaCompareFileBothDirInfo()



BOOL
SortInPlaceFileInfoPointers(
    IN OUT PWIN32_FIND_DATA  *   prgFileInfo,
    IN int   nEntries,
    IN PFN_CMP_WIN32_FIND_DATA   pfnCompare)
/*++
  This is a generic function to sort the pointers to file information
    array in place using pfnCompare to compare the records for ordering.

  Returns:
     TRUE on success and FALSE on failure.
--*/
{
    DWORD  dwTime;

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Qsorting the FileInfo Array %08x ( Total = %d)\n",
                    prgFileInfo, nEntries));
        dwTime = GetTickCount();
    }


    qsort( (PVOID ) prgFileInfo, nEntries,
          sizeof( PWIN32_FIND_DATA),
          pfnCompare);


    IF_DEBUG( DIR_LIST) {

        dwTime = GetTickCount() - dwTime;
        DBGPRINTF( ( DBG_CONTEXT,
                    " Time to sort %d entries = %d\n",
                    nEntries, dwTime));
    }

    return ( TRUE);
} // SortInPlaceFileInfoPointers()




/**********************************************************************
 *    TS_DIRECTORY_HEADER  related member functions
 **********************************************************************/



const char PSZ_DIR_STAR_STAR[] = "*.*";
# define LEN_PSZ_DIR_STAR_STAR  ( sizeof(PSZ_DIR_STAR_STAR)/sizeof(CHAR))

BOOL
TS_DIRECTORY_HEADER::ReadWin32DirListing(
    IN LPCSTR           pszDirectoryName,
    IN OUT DWORD *      pcbMemUsed
    )
/*++
  Opens and reads the directory file for given directory to obtain
   information about files and directories in the dir.

  Arguments:
    pszDirectoryName  - pointer to string containing directory name
                         with a terminating "\".
    pcbMemUsed        - pointer to DWORD which on successful return
                         will contain the memory used.

  Returns:
     TRUE on success and   FALSE on failure.
     Use GetLastError() for further error information.

--*/
{
    BOOL                fReturn = TRUE;       // default assumed.
    CHAR                pchFullPath[MAX_PATH*2];
    HANDLE              hFindFile = INVALID_HANDLE_VALUE;
    BOOL                fFirstTime;
    DWORD               cbExtraMem = 0;
    DWORD               dwError = NO_ERROR;
    PWIN32_FIND_DATA    pFileInfo = NULL;
    PTS_DIR_BUFFERS     pTsDirBuffers = NULL;
    DWORD startCount;

    DBGCODE( CHAR pchBuff[300];
            );


    DBG_ASSERT( pszDirectoryName != NULL);

    if ( strlen(pszDirectoryName) > MAX_PATH*2 - LEN_PSZ_DIR_STAR_STAR) {

        return ( ERROR_PATH_NOT_FOUND);
    }

    wsprintfA( pchFullPath, "%s%s", pszDirectoryName, PSZ_DIR_STAR_STAR);

    InitializeListHead( &m_listDirectoryBuffers);

    //
    // Get the next chunk of directory information.
    //

    pTsDirBuffers = (PTS_DIR_BUFFERS ) ALLOC( sizeof(TS_DIR_BUFFERS));

    if ( pTsDirBuffers == NULL ) {

        //
        //  Allocation failure.
        //
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        fReturn = FALSE;
        goto Failure;
    }

    cbExtraMem += sizeof(TS_DIR_BUFFERS);

    // insert the buffer into the list so that it may be freed later.
    InsertBufferInTail( &pTsDirBuffers->listEntry);
    pTsDirBuffers->nEntries = 0;

    pFileInfo = (PWIN32_FIND_DATA ) pTsDirBuffers->rgFindData;

    hFindFile = FindFirstFile( pchFullPath, pFileInfo);
    if ( hFindFile == INVALID_HANDLE_VALUE) {

        dwError = GetLastError();

        IF_DEBUG( DIR_LIST) {
            DBGPRINTF(( DBG_CONTEXT,
                       "FindFirstFile(%s, %08x) failed. Error = %d\n",
                       pchFullPath, pFileInfo, dwError));
        }
        fReturn = FALSE;
        goto Failure;
    }
    IF_DEBUG( DIR_LIST) {

        DBGCODE(
                wsprintf( pchBuff, "-%d-[%d](%08x) %s(%s)\t%08x\n",
                         MAX_DIR_ENTRIES_PER_BLOCK,
                         0,
                         pFileInfo,
                         pFileInfo->cFileName, pFileInfo->cAlternateFileName,
                         pFileInfo->dwFileAttributes);
                OutputDebugString( pchBuff);
                );
    }

    pFileInfo++;
    IncrementDirEntries();
    pTsDirBuffers->nEntries++;
    startCount = 1;

    // atleast 10 to justify overhead
    DBG_ASSERT( MAX_DIR_ENTRIES_PER_BLOCK > 10);

    //
    //  Loop through getting subsequent entries in the directory.
    //

    for( dwError = NO_ERROR; dwError == NO_ERROR; ) {

        // loop thru and get a block of items

        for( int i = startCount; i < MAX_DIR_ENTRIES_PER_BLOCK; i++ ) {

            if ( !FindNextFile( hFindFile, pFileInfo)) {

                dwError = GetLastError();

                if ( dwError != ERROR_NO_MORE_FILES) {
                    DBGPRINTF(( DBG_CONTEXT,
                               "FindNextFile(%s(%08x), %08x) failed."
                               " Error = %d\n",
                               pchFullPath, hFindFile, pFileInfo,
                               dwError));
                    fReturn = FALSE;
                    goto Failure;
                } else {

                    break;
                }
            }

            IF_DEBUG( DIR_LIST) {

                DBGCODE(
                        wsprintf( pchBuff, "[%d](%08x) %s(%s)\t%08x\n",
                                 i, pFileInfo,
                                 pFileInfo->cFileName,
                                 pFileInfo->cAlternateFileName,
                                 pFileInfo->dwFileAttributes);
                        OutputDebugString( pchBuff);
                        );
            }

            IncrementDirEntries();
            pFileInfo++;

        } // for all elements that fit in this block

        pTsDirBuffers->nEntries = i;

        if ( dwError == ERROR_NO_MORE_FILES) {

            //
            // info on all entries in a directory obtained. Return back.
            //

            dwError = NO_ERROR;
            break;
        } else {

            //
            //  The buffer contains directory entries and is full now.
            //  Update the count of entries in this buffer and
            //  Allocate a new buffer and set the start counts properly.
            //

            IF_DEBUG( DIR_LIST) {
                DBGCODE( OutputDebugString( " Allocating Next Chunck\n"););
            }

            pTsDirBuffers = (PTS_DIR_BUFFERS ) ALLOC(sizeof(TS_DIR_BUFFERS));

            if ( pTsDirBuffers == NULL ) {

                //
                //  Allocation failure.
                //
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                fReturn = FALSE;
                break;                // Get out of the loop with failure.
            }

            cbExtraMem += sizeof(TS_DIR_BUFFERS);

            // insert the buffer into the list so that it may be freed later.
            InsertBufferInTail( &pTsDirBuffers->listEntry);
            pTsDirBuffers->nEntries = 0;

            pFileInfo = ( PWIN32_FIND_DATA ) pTsDirBuffers->rgFindData;

            startCount = 0;  // start count from zero items on this buffer page
        }

    } // for all directory entries

Failure:

    if ( hFindFile != INVALID_HANDLE_VALUE) {
        DBG_REQUIRE( FindClose( hFindFile ));
        hFindFile = INVALID_HANDLE_VALUE;
    }

    *pcbMemUsed += cbExtraMem;

    return ( fReturn);
} // TS_DIRECTORY_HEADER::ReadWin32DirListing()


VOID
TS_DIRECTORY_HEADER::CleanupThis( VOID)
{
    PLIST_ENTRY pEntry;
    PLIST_ENTRY pNextEntry;

    for ( pEntry = QueryDirBuffersListEntry()->Flink;
         pEntry != QueryDirBuffersListEntry();
         pEntry  = pNextEntry )
    {
        PTS_DIR_BUFFERS  pTsDirBuffer =
          CONTAINING_RECORD( pEntry, TS_DIR_BUFFERS, listEntry);

        // cache the next block pointer.
        pNextEntry = pEntry->Flink;

        // remove the current block from list.
        RemoveEntryList( pEntry);

        // delete the current block.
        FREE( pTsDirBuffer );
    }

    InitializeListHead( QueryDirBuffersListEntry());

    if ( m_ppFileInfo != NULL) {

        FREE( m_ppFileInfo);
        m_ppFileInfo   = NULL;
    }

    m_hListingUser = INVALID_HANDLE_VALUE;
    m_nEntries     = 0;

    return;
} // TS_DIRECTORY_HEADER::CleanupThis()





BOOL
TS_DIRECTORY_HEADER::BuildFileInfoPointers(
    IN OUT DWORD *      pcbMemUsed
    )
/*++

  This constructs the indirection pointers from the buffers containing the
   file information.
  This array of indirection enables faster access to the file information
   structures stored.

   Should be always called after ReadFromNtDirectoryFile() to construct the
    appropriate pointers.

   Returns:
     TRUE on success and FALSE if there are any failures.
--*/
{
    BOOL  fReturn = FALSE;
    DWORD cbAlloc;
    int   maxIndex;

    maxIndex = QueryNumEntries();

    ASSERT( maxIndex != 0);  //  Any directory will atleast have "."

    //
    // Alloc space for holding the pointers for numEntries pointers.
    //

    cbAlloc = maxIndex * sizeof( PWIN32_FIND_DATA );

    m_ppFileInfo = (PWIN32_FIND_DATA *) ALLOC( cbAlloc );

    if ( m_ppFileInfo != NULL ) {

        int          index;
        PLIST_ENTRY  pEntry;
        PTS_DIR_BUFFERS    pTsDirBuffers;
        PWIN32_FIND_DATA   pFileInfo;

        //
        //  Get the link to first buffer and start enumeration.
        //

        for( pEntry = QueryDirBuffersListEntry()->Flink, index = 0;
             pEntry != QueryDirBuffersListEntry();
            pEntry = pEntry->Flink
            ) {

            pTsDirBuffers = CONTAINING_RECORD( pEntry, TS_DIR_BUFFERS,
                                               listEntry);

            pFileInfo = pTsDirBuffers->rgFindData;

            for (int  i = 0;
                 i < pTsDirBuffers->nEntries;
                 i++ ) {

                m_ppFileInfo[index++] = pFileInfo;    // store the pointer.

                IF_DEBUG( DIR_LIST) {
                    DBGCODE(
                            CHAR pchBuff[300];
                            wsprintf( pchBuff, "[%d](%08x) %s(%s)\t%08x\n",
                                     index, pFileInfo,
                                     pFileInfo->cFileName,
                                     pFileInfo->cAlternateFileName,
                                     pFileInfo->dwFileAttributes);
                            OutputDebugString( pchBuff);
                            );
                }

                pFileInfo++;

            } // for all elements in a buffer

        } // for ( all buffers in the list)


        ASSERT( index == maxIndex);

        fReturn = SortInPlaceFileInfoPointers( m_ppFileInfo,
                                              maxIndex,
                                              AlphaCompareFileBothDirInfo);

    } // valid alloc of the pointers.

    *pcbMemUsed += cbAlloc;

    return ( fReturn);
} // TS_DIRECTORY_HEADER::BuildFileInfoPointers()



# if DBG

VOID
TS_DIRECTORY_HEADER::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                "Printing TS_DIRECTORY_HEADER ( %08x).\n"
                "ListingUser Handle = %08x\t Num Entries = %08x\n"
                "Pointer to array of indirection pointers %08x\n",
                this,
                m_hListingUser, m_nEntries,
                m_ppFileInfo));

    //
    //  The buffers containing the data of the file information not printed
    //

    return;
} // TS_DIRECTORY_HEADER::Print()


# endif // DBG

/************************ End of File ***********************/


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\metacach.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        metacach.cxx

   Abstract:
        This module contains the tsunami caching routines for metadata.

   Author:
        Henry Sanders    ( henrysa )     15-Oct-1996

--*/

#include "TsunamiP.Hxx"
#pragma hdrstop
#include <dbgutil.h>
#include <issched.hxx>
#include <metacach.hxx>

extern TCHAR * FlipSlashes( TCHAR * pszPath );

//
// The number of buckets in our hash table.
//

#define METACACHE_TABLE_SIZE    32
#define METACACHE_ENTRY_SIGN    ((DWORD)'ECEM')
#define METACACHE_ENTRY_FREE    ((DWORD)'ECEf')

//
// Structure of a metacache table entry.
//

typedef struct _METACACHE_ENTRY {

    DWORD                   Signature;
    struct _METACACHE_ENTRY *pNext;
    DWORD                   dwDataSetNumber;
    DWORD                   dwServiceID;
    PVOID                   pMetaData;
    DWORD                   dwRefCount;
    PMDFREERTN              pFreeRoutine;
    BOOL                    bValid;

} METACACHE_ENTRY, *PMETACACHE_ENTRY;

//
// Structure of a hash table bucket.
//

typedef struct _METACACHE_BUCKET {

    PMETACACHE_ENTRY        pEntry;
    CRITICAL_SECTION        csCritSec;

} METACACHE_BUCKET;

METACACHE_BUCKET    MetaCacheTable[METACACHE_TABLE_SIZE];

DWORD   MetaCacheTimerCookie = 0;


/************************************************************
 *    Functions
 ************************************************************/
dllexp
PVOID
TsFindMetaData(

    IN      DWORD           dwDataSetNumber,
    IN      DWORD           dwServiceID

    )
/*++

  Routine Description:

    This function takes a data set number and service ID, and tries to find
    a formatted chunk of metadata in the cache. If it does so, it returns a
    pointer to it, otherwise it returns NULL.

  Arguments

    dwDataSetNumber         - The data set number to be found.
    dwServiceID             - ID of calling service.
--*/
{
    DWORD               dwIndex;
    PMETACACHE_ENTRY    pCurrentEntry;

    dwIndex = dwDataSetNumber % METACACHE_TABLE_SIZE;

    //
    // This needes to be protected, we use a critical section per bucket.
    //
    EnterCriticalSection(&MetaCacheTable[dwIndex].csCritSec);

    pCurrentEntry = MetaCacheTable[dwIndex].pEntry;

    // Walk the chain on the bucket. If we find a match, return it.
    //
    while (pCurrentEntry != NULL )
    {
        PCOMMON_METADATA        pCMD;

        pCMD = (PCOMMON_METADATA)pCurrentEntry->pMetaData;

        pCMD->CheckSignature();
        ASSERT(pCMD->QueryCacheInfo() == pCurrentEntry);


        if (pCurrentEntry->dwDataSetNumber == dwDataSetNumber &&
            pCurrentEntry->dwServiceID == dwServiceID &&
            pCurrentEntry->bValid)
        {

            ASSERT( pCurrentEntry->Signature == METACACHE_ENTRY_SIGN );

            // Found a match. Increment the refcount and return a pointer
            // to the metadata.
            InterlockedIncrement((LONG *)&pCurrentEntry->dwRefCount);
            LeaveCriticalSection(&MetaCacheTable[dwIndex].csCritSec);

            return pCurrentEntry->pMetaData;
        }

        // Otherwise try the next one.
        pCurrentEntry = pCurrentEntry->pNext;
    }


    // Didn't find a match, so we'll return NULL.

    LeaveCriticalSection(&MetaCacheTable[dwIndex].csCritSec);

    return NULL;
}

dllexp
PVOID
TsAddMetaData(

    IN      PCOMMON_METADATA pMetaData,
    IN      PMDFREERTN      pFreeRoutine,
    IN      DWORD           dwDataSetNumber,
    IN      DWORD           dwServiceID
    )
/*++

  Routine Description:

    Add a chunk of formatted metadata to our cache.

  Arguments

    pMetaData               - MetaData to be added.
    dwDataSetNumber         - The data set number to be found.
    dwServiceID             - ID of calling service.

  Returns
    Pointer to metacache 'handle' to be used when freeing information.

--*/
{
    PMETACACHE_ENTRY        pNewEntry;
    DWORD                   dwIndex;

    pMetaData->CheckSignature();

    dwIndex = dwDataSetNumber % METACACHE_TABLE_SIZE;


    pNewEntry = (PMETACACHE_ENTRY)ALLOC(sizeof(METACACHE_ENTRY));

    if (pNewEntry == NULL)
    {
        // Couldn't add the entry. No big deal, just return.
        return NULL;
    }

    pNewEntry->Signature = METACACHE_ENTRY_SIGN;
    pNewEntry->dwDataSetNumber = dwDataSetNumber;
    pNewEntry->dwServiceID = dwServiceID;
    pNewEntry->pMetaData = pMetaData;
    pNewEntry->pFreeRoutine = pFreeRoutine;
    pNewEntry->dwRefCount = 1;
    pNewEntry->bValid = TRUE;

    pMetaData->SetCacheInfo(pNewEntry);

    EnterCriticalSection(&MetaCacheTable[dwIndex].csCritSec);

    pNewEntry->pNext = MetaCacheTable[dwIndex].pEntry;

    MetaCacheTable[dwIndex].pEntry = pNewEntry;

    LeaveCriticalSection(&MetaCacheTable[dwIndex].csCritSec);

    return pNewEntry;

}

dllexp
VOID
TsFreeMetaData(

    IN      PVOID           pCacheEntry

    )
/*++

  Routine Description:

    Free a chunk of formatted metadata to the cache. What we really do here
    is decrement the ref count. If it goes to 0 and the cache element is
    marked deleted, we'll free it here.

  Arguments

    pMetaData               - MetaData to be freed.
--*/
{
    PMETACACHE_ENTRY        pEntry = (PMETACACHE_ENTRY)pCacheEntry;
    PCOMMON_METADATA        pCMD;


    ASSERT( pEntry->Signature == METACACHE_ENTRY_SIGN );

    pCMD = (PCOMMON_METADATA)pEntry->pMetaData;

    pCMD->CheckSignature();

    ASSERT(pCMD->QueryCacheInfo() == pEntry);

    InterlockedDecrement((LONG *)&pEntry->dwRefCount);

}

dllexp
VOID
TsAddRefMetaData(

    IN      PVOID           pCacheEntry

    )
/*++

  Routine Description:

    Increment reference count to chunk of formatted metadata

  Arguments

    pMetaData               - MetaData to be AddRef'ed
--*/
{
    PMETACACHE_ENTRY        pEntry = (PMETACACHE_ENTRY)pCacheEntry;

    ASSERT( pEntry->Signature == METACACHE_ENTRY_SIGN );

    InterlockedIncrement((LONG *)&pEntry->dwRefCount);
}

dllexp
VOID
TsFlushMetaCache(
    DWORD       dwService,
    BOOL        bTerminating
    )
/*++

  Routine Description:

    Called when we need to flush all of our cached metainformation. We walk
    the table, and for each entry we check to see if it's in use. If it's not
    we'll free it, otherwise we'll mark it as deleted.

    If the passed in dwService ID is non-zero, then we'll only
    flush those entries that match the service. Also, if we're terminating,
    we'll do some additional checking, and also cancle any callbacks if we need
    to.

  Arguments

        dwService       - Service ID of entries to be flushed, 0 for all
                            services.
        bTerminating    - TRUE if the caller is terminating.


--*/
{
    UINT                i;
    PMETACACHE_ENTRY    pEntry;
    PMETACACHE_ENTRY    pTrailer;
    PCOMMON_METADATA        pCMD;

    for (i = 0; i < METACACHE_TABLE_SIZE; i++)
    {
        EnterCriticalSection(&MetaCacheTable[i].csCritSec);

        pTrailer = CONTAINING_RECORD(&MetaCacheTable[i].pEntry,
                                        METACACHE_ENTRY, pNext);

        // Walk the chain on the bucket. For every entry, if it's not in
        // use, free it.
        //
        while (pTrailer->pNext != NULL )
        {
            pEntry = pTrailer->pNext;

            ASSERT( pEntry->Signature == METACACHE_ENTRY_SIGN );

            pCMD = (PCOMMON_METADATA)pEntry->pMetaData;

            pCMD->CheckSignature();
            ASSERT(pCMD->QueryCacheInfo() == pEntry);

            if (dwService == 0 || dwService == pEntry->dwServiceID)
            {
                if (pEntry->dwRefCount == 0)
                {
                    // This entry is not in use.

                    // If whoever added it gave us a free routine, call it now.
                    if (pEntry->pFreeRoutine != NULL)
                    {
                        (*(pEntry->pFreeRoutine))(pEntry->pMetaData);
                    }

                    // Look at the next one.
                    pTrailer->pNext = pEntry->pNext;

                    pEntry->Signature = METACACHE_ENTRY_FREE;
                    FREE(pEntry);
                }
                else
                {
                    // In a debug build we'll assert here if we're terminating,
                    // since that shouldn't happen. In a free build we won't
                    // assert for that but we will NULL out the free routine to
                    // keep it from getting called, since presumably the owner is
                    // going away.

                    if (bTerminating)
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                            "\n=========================================\n"
                            "Leftover item in metacache - %8x, bValid = %s\n"
                            "\t dwServiceID    = %8d  pMetaData    = %8x\n"
                            "\t dwRefCount     = %8d  pFreeRoutine = %8x\n"
                            ,
                            pEntry,
                            (pEntry->bValid ? "TRUE" : "FALSE"),
                            pEntry->dwServiceID,
                            pEntry->pMetaData,
                            pEntry->dwRefCount,
                            pEntry->pFreeRoutine ));

                        pEntry->pFreeRoutine = NULL;
                    }


                    pEntry->bValid = FALSE;
                    pTrailer = pEntry;
                }
            }
            else
            {
                pTrailer = pEntry;
            }
        }


        LeaveCriticalSection(&MetaCacheTable[i].csCritSec);
    }
}

dllexp
VOID
TsReferenceMetaData(
    IN      PVOID           pEntry
    )
/*++

  Routine Description:

    Called when we need to reference a metadata cache entry. The caller
    must have already referenced it once.

  Arguments

    pEntry          - Entry to be referenced.


--*/
{
    PMETACACHE_ENTRY        pCacheEntry = (PMETACACHE_ENTRY)pEntry;
    PCOMMON_METADATA        pCMD;


    ASSERT( pCacheEntry->Signature == METACACHE_ENTRY_SIGN );

    pCMD = (PCOMMON_METADATA)pCacheEntry->pMetaData;

    pCMD->CheckSignature();

    ASSERT(pCMD->QueryCacheInfo() == pCacheEntry);

    InterlockedIncrement((LONG *)&pCacheEntry->dwRefCount);

}

VOID
MetaCacheScavenger(
    PVOID       pContext
    )
/*++

  Routine Description:

    Called periodically to time out metacache information. We scan the table;
    if we find an object that's not in use we free it.

  Arguments

    None.


--*/
{
    UINT                i;
    PMETACACHE_ENTRY    pEntry;
    PMETACACHE_ENTRY    pTrailer;
    PCOMMON_METADATA        pCMD;

    for (i = 0; i < METACACHE_TABLE_SIZE; i++)
    {
        if (MetaCacheTable[i].pEntry == NULL)
        {
            continue;
        }

        EnterCriticalSection(&MetaCacheTable[i].csCritSec);

        pTrailer = CONTAINING_RECORD(&MetaCacheTable[i].pEntry,
                                        METACACHE_ENTRY, pNext);


        // Walk the chain on the bucket. For every entry, if it's not in
        // use, free it.
        //
        while (pTrailer->pNext != NULL )
        {
            pEntry = pTrailer->pNext;

            ASSERT( pEntry->Signature == METACACHE_ENTRY_SIGN );
            pCMD = (PCOMMON_METADATA)pEntry->pMetaData;

            pCMD->CheckSignature();
            ASSERT(pCMD->QueryCacheInfo() == pEntry);


            if (pEntry->dwRefCount == 0)
            {

                // This entry is not in use.

                // If whoever added it gave us a free routine, call it now.
                if (pEntry->pFreeRoutine != NULL)
                {
                    (*(pEntry->pFreeRoutine))(pEntry->pMetaData);
                }

                // Free the entry and look at the next one.
                pTrailer->pNext = pEntry->pNext;

                pEntry->Signature = METACACHE_ENTRY_FREE;

                FREE(pEntry);
            }
            else
            {
                pTrailer = pEntry;
            }
        }

        LeaveCriticalSection(&MetaCacheTable[i].csCritSec);
    }
}


dllexp
VOID
_TsValidateMetaCache(
    VOID
    )
/*++


--*/
{
    UINT                i;
    PMETACACHE_ENTRY    pEntry;
    PCOMMON_METADATA        pCMD;

    for (i = 0; i < METACACHE_TABLE_SIZE; i++)
    {
        if (MetaCacheTable[i].pEntry == NULL)
        {
            continue;
        }

        EnterCriticalSection(&MetaCacheTable[i].csCritSec);

        pEntry = MetaCacheTable[i].pEntry;

        while (pEntry != NULL )
        {

            ASSERT( pEntry->Signature == METACACHE_ENTRY_SIGN );
            pCMD = (PCOMMON_METADATA)pEntry->pMetaData;

            pCMD->CheckSignature();
            ASSERT(pCMD->QueryCacheInfo() == pEntry);

            pEntry = pEntry->pNext;
        }

        LeaveCriticalSection(&MetaCacheTable[i].csCritSec);
    }
}


BOOL
MetaCache_Initialize(
    VOID
    )
/*++

  Routine Description:

    Initialize our metacache code.

  Arguments

    Nothing.

--*/
{
    UINT        i;

    for (i = 0; i < METACACHE_TABLE_SIZE; i++)
    {
        InitializeCriticalSection(&MetaCacheTable[i].csCritSec);
        MetaCacheTable[i].pEntry = NULL;

        SET_CRITICAL_SECTION_SPIN_COUNT( &MetaCacheTable[i].csCritSec,
                                         IIS_DEFAULT_CS_SPIN_COUNT);
    }

    MetaCacheTimerCookie = ScheduleWorkItem(
                                       (PFN_SCHED_CALLBACK) MetaCacheScavenger,
                                       NULL,
                                       60000,      // BUGBUG
                                       TRUE );     // Periodic

    if (!MetaCacheTimerCookie)
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
MetaCache_Terminate(
    VOID
    )
/*++

  Routine Description:

    Terminate our metacache code.

  Arguments

    Nothing.

--*/
{
    if (MetaCacheTimerCookie != 0)
    {
        RemoveWorkItem(MetaCacheTimerCookie);
        MetaCacheTimerCookie = 0;
    }

    TsFlushMetaCache(0, TRUE);

    return TRUE;
}




COMMON_METADATA::COMMON_METADATA(VOID)
: m_IpDnsAccessCheckSize( 0 ),
  m_IpDnsAccessCheckPtr ( NULL ),
  m_IpDnsAccessCheckTag ( 0 ),
  m_fDontLog            ( FALSE ),
  m_dwAccessPerm        ( MD_ACCESS_READ ),
  m_dwSslAccessPerm     ( 0 ),
  m_pAcl                ( NULL ),
  m_dwAclTag            ( 0 ),
  m_dwVrLevel           ( 0 ),
  m_dwVrLen             ( 0 ),
  m_hVrToken            ( NULL ),
  m_fVrPassThrough      ( FALSE ),
  m_dwVrError           ( 0 ),
  m_Signature           ( CMD_SIG )
{
    //
    //  Hmmm, since most of these values aren't getting initialized, if
    //  somebody went and deleted all the metadata items from the tree, then
    //  bad things could happen.  We should initialize with defaults things
    //  that might mess us
    //

} // COMMON_METADATA::COMMON_METADATA()


COMMON_METADATA::~COMMON_METADATA(VOID)
{
    CheckSignature();

    if ( m_IpDnsAccessCheckTag )
        {
            FreeMdTag( m_IpDnsAccessCheckTag );
            m_IpDnsAccessCheckTag = 0;
        }
    if ( m_dwAclTag )
        {
            FreeMdTag( m_dwAclTag );
            m_dwAclTag = 0;
        }

    if ( m_hVrToken )
        {
            TsDeleteUserToken( m_hVrToken );
            m_hVrToken = NULL;
        }

} // COMMON_METADATA::~COMMON_METADATA()


VOID
COMMON_METADATA::FreeMdTag(
    DWORD dwTag
    )
/*++

Routine Description:

    Free a metadata object accessed by reference

Arguments:

    dwTag - tag of metadata object reference

Returns:

    Nothing

--*/
{
    MB  mb( (IMDCOM*) m_pInstance->m_Service->QueryMDObject() );

    CheckSignature();
    mb.ReleaseReferenceData( dwTag );
}


//
//  Private constants.
//

#define DEFAULT_MD_RECORDS          40
#define DEFAULT_RECORD_SIZE         50

# define DEF_MD_REC_SIZE   ((1 + DEFAULT_MD_RECORDS) * \
                            (sizeof(METADATA_RECORD) + DEFAULT_RECORD_SIZE))

#define RMD_ASSERT(x) if (!(x)) {DBG_ASSERT(FALSE); return FALSE; }


BOOL
COMMON_METADATA::ReadMetaData(
    PIIS_SERVER_INSTANCE    pInstance,
    MB *                    pmb,
    LPSTR                   pszURL,
    PMETADATA_ERROR_INFO    pMDError
    )
{
    PMETADATA_RECORD    pMDRecord;
    DWORD               dwNumMDRecords;
    BYTE                tmpBuffer[ DEF_MD_REC_SIZE];
    BUFFER              TempBuff( tmpBuffer, DEF_MD_REC_SIZE);
    DWORD               i;
    DWORD               dwDataSetNumber;
    INT                 ch;
    LPSTR               pszInVr;
    LPSTR               pszMinInVr;
    DWORD               dwNeed;
    DWORD               dwL;
    DWORD               dwVRLen;
    LPSTR               pszVrUserName;
    LPSTR               pszVrPassword;
    BYTE                tmpPrivateBuffer[ 20 ];
    BUFFER              PrivateBuffer( tmpPrivateBuffer, 20 );
    DWORD               dwPrivateBufferUsed;


    CheckSignature();
    TsValidateMetaCache();

    m_pInstance = pInstance;

    DBG_ASSERT( TempBuff.QuerySize() >=
                (DEFAULT_MD_RECORDS *
                 (sizeof(METADATA_RECORD) + DEFAULT_RECORD_SIZE))
                );

    if ( !pmb->Open( pInstance->QueryMDVRPath() ))
    {
        return FALSE;
    }

    if ( !pmb->GetAll( pszURL,
                     METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_REFERENCE,
                     IIS_MD_UT_FILE,
                     &TempBuff,
                     &dwNumMDRecords,
                     &dwDataSetNumber ))
    {
        return FALSE;
    }

    pMDRecord = (PMETADATA_RECORD)TempBuff.QueryPtr();
    i = 0;

    //
    // Check from where we got VR_PATH
    //

    pszMinInVr = pszURL ;
    if ( *pszURL )
    {
        for ( pszInVr = pszMinInVr + strlen(pszMinInVr) ;; )
        {
            ch = *pszInVr;
            *pszInVr = '\0';
            dwNeed = 0;
            if ( !pmb->GetString( pszURL, MD_VR_PATH, IIS_MD_UT_FILE, NULL, &dwNeed, 0 ) &&
                 GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                *pszInVr = ch;
                // VR_PATH was defined at this level !

                break;
            }
            *pszInVr = ch;

            if ( ch )
            {
                if ( pszInVr > pszMinInVr )
                {
                    pszInVr = CharPrev( pszMinInVr, pszInVr );
                }
                else
                {
                    //
                    // VR_PATH was defined above Instance vroot
                    // or not at all. If defined above, then the reference
                    // path is empty, so we can claim we found it.
                    // if not defined, then this will be catch later.
                    //

                    break;
                }
            }

            // scan for previous delimiter

            while ( *pszInVr != '/' && *pszInVr != '\\' )
            {
                if ( pszInVr > pszMinInVr )
                {
                    pszInVr = CharPrev( pszMinInVr, pszInVr );
                }
                else
                {
                    //
                    // VR_PATH was defined above Instance vroot
                    // or not at all. If defined above, then the reference
                    // path is empty, so we can claim we found it.
                    // if not defined, then this will be catch later.
                    //

                    break;
                }
            }
        }

        dwVRLen = pszInVr - pszMinInVr;
    }
    else
    {
        dwVRLen = 0;
        pszInVr = pszMinInVr;
    }

    // Close this now to minimize lock contention.
    DBG_REQUIRE(pmb->Close());

    for ( dwL = 0 ; pszMinInVr < pszInVr - 1 ; pszMinInVr = CharNext(pszMinInVr) )
    {
        if ( *pszMinInVr == '/' || *pszMinInVr == '\\' )
        {
            ++dwL;
        }
    }

    // Now walk through the array of returned metadata objects and format
    // each one into our predigested form.

    SetVrLevelAndLen( dwL, dwVRLen );
    pszVrPassword = NULL;
    pszVrUserName = NULL;
    dwPrivateBufferUsed = 0;
    pMDError->IsValid = FALSE;

    for ( ; i < dwNumMDRecords; i++, pMDRecord++ ) {

        PVOID       pDataPointer;
        CHAR        *pszMimePtr;
        CHAR        *pszTemp;
        DWORD       dwTemp;


        pDataPointer = (PVOID) ((PCHAR)TempBuff.QueryPtr() +
                                    (UINT)pMDRecord->pbMDData);

        switch ( pMDRecord->dwMDIdentifier ) {

        case MD_IP_SEC:
            DBG_ASSERT( pMDRecord->dwMDDataTag );
            RMD_ASSERT( pMDRecord->dwMDDataType == BINARY_METADATA &&
                         pMDRecord->dwMDAttributes & METADATA_REFERENCE );
            if ( pMDRecord->dwMDDataTag )
            {
                if ( !SetIpDnsAccessCheck( pMDRecord->pbMDData,
                                           pMDRecord->dwMDDataLen,
                                           pMDRecord->dwMDDataTag ) )
                {
                    goto FreeRefs;
                }
            }
            break;

        case MD_ACCESS_PERM:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            SetAccessPerms( *((DWORD *) pDataPointer) );
            break;

        case MD_SSL_ACCESS_PERM:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            SetSslAccessPerms( *((DWORD *) pDataPointer) );
            break;

        case MD_DONT_LOG:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            DBG_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            SetDontLogFlag( *((DWORD *) pDataPointer ));
            break;

        case MD_VR_PATH:
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );
            if (!QueryVrPath()->Copy((const CHAR *)pDataPointer))
            {
                goto FreeRefs;
            }
            break;

                case MD_APP_ROOT:
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );
            if (!QueryAppPath()->Copy((const CHAR *)pDataPointer))
            {
                goto FreeRefs;
            }
            break;

        case MD_VR_USERNAME:
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );
            pszVrUserName = (LPSTR)pDataPointer;
            break;

        case MD_VR_PASSWORD:
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );
            pszVrPassword = (LPSTR)pDataPointer;
            break;

        case MD_VR_PASSTHROUGH:
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            SetVrPassThrough( !!*((DWORD *) pDataPointer) );
            break;

        case MD_VR_ACL:
            DBG_ASSERT( pMDRecord->dwMDDataTag );
            RMD_ASSERT( pMDRecord->dwMDDataType == BINARY_METADATA );
            if ( pMDRecord->dwMDDataTag )
            {
                SetAcl( pMDRecord->pbMDData,
                        pMDRecord->dwMDDataLen,
                        pMDRecord->dwMDDataTag );
            }
            break;

        default:
            if ( !HandlePrivateProperty( pszURL, pInstance, pMDRecord, pDataPointer, &PrivateBuffer, &dwPrivateBufferUsed, pMDError ) )
            {
                goto FreeRefs;
            }
            CheckSignature();
            break;
        }
    }

    if (!FinishPrivateProperties(&PrivateBuffer, dwPrivateBufferUsed, TRUE))
    {
        goto FreeRefs;
    }

    if ( QueryVrPath()->IsEmpty() )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[ReadMetaData] Virtual Dir Path mapping not found\n" ));
        SetLastError( ERROR_FILE_NOT_FOUND );
        return FALSE;
    }

    //
    // If this is an UNC share, logon using associated credentials
    // keep a reference to this access token in the cache
    //

    if ( QueryVrPath()->QueryStr()[0] == '\\' &&
         QueryVrPath()->QueryStr()[1] == '\\' )
    {
        if ( pszVrUserName != NULL && pszVrPassword != NULL &&
             pszVrUserName[0] )
        {

            if ( !SetVrUserNameAndPassword( pInstance, pszVrUserName, pszVrPassword ) )
            {
                return FALSE;
            }
        }
    }

    CheckSignature();
    TsValidateMetaCache();
    return TRUE;

FreeRefs:

    FinishPrivateProperties(&PrivateBuffer, dwPrivateBufferUsed, FALSE);
    CheckSignature();
    TsValidateMetaCache();

    for ( ; i < dwNumMDRecords; i++, pMDRecord++ )
    {
        if ( pMDRecord->dwMDDataTag )
        {
            pmb->ReleaseReferenceData( pMDRecord->dwMDDataTag );
        }
    }

    return FALSE;
}


BOOL
COMMON_METADATA::SetVrUserNameAndPassword(
    PIIS_SERVER_INSTANCE    pInstance,
    LPSTR                   pszUserName,
    LPSTR                   pszPassword
    )
/*++
    Description:

        Set the account used to access the virtual root
        associated with this metadata

    Arguments:
        pInstance - current instance
        pszUserName - User name
        pszPassword - password

    Returns:
        TRUE if success, otherwise FALSE

--*/
{
    LARGE_INTEGER       liPwdExpiry;
    BOOL                fHaveExp;
    BOOL                fAsGuest;
    BOOL                fAsAnonymous;
    TCP_AUTHENT_INFO    TAI;

    CheckSignature();
    TAI.fDontUseAnonSubAuth = TRUE;

    m_hVrToken = TsLogonUser( pszUserName,
                              pszPassword,
                              &fAsGuest,
                              &fAsAnonymous,
                              pInstance,
                              &TAI,
                              NULL,
                              &liPwdExpiry,
                              &fHaveExp );

    //
    // If fail to logo, we remember the error and return SUCCESS
    // Caller will have to check metadata after creating it to check
    // the error code. Necessary because metadata needs to be set in HTTP_REQUEST
    // to send back proper auth status even if virtual root init failed.
    //

    if ( !m_hVrToken )
    {
        m_dwVrError = GetLastError();
    }

    return TRUE;
}


BOOL
COMMON_METADATA::BuildApplPhysicalPath(
  STR *           pstrApplPhysicalPath
  ) const
/*++
  Description:
    This function builds the physical path for the ApplPath of the current
    METADATA object. The ApplPath is a metbase path of the form
     /LM/W3Svc/<instance>/app-root-path
    This function uses the VR_PATH & portion of the APPL_PATH to
      construct the appropriate physical path.

  Arguments:
    pstrApplPhysicalPath - pointer to STR object that will contain
                           the physical path on return.

  Returns:
    TRUE on success and FALSE if there are errors.
    Use GetLastError() to get the appropriate error code.
--*/
{

    LPCSTR       pszInVr;
    DWORD        dwL;
    INT          ch;

    CheckSignature();
    DBG_ASSERT( pstrApplPhysicalPath);


    //
    // At the minimum copy the current Virtual path
    //  (1A) NYI: What happens with the default instance for which
    //  the metabase path is: /LM/W3Svc   ??
    //

    if ( !pstrApplPhysicalPath->Copy( m_strVrPath ) )
    {
        return FALSE;
    }


    //
    // Scan for the portion of the URL that is part of the VROOT path.
    //  Do this by scanning forward for all the appropriate # of slashes.
    // This works only if the AppRoot is contained within the Vroot
    //
    // AppPath is of the form:  /LM/W3Svc/<instance>/ROOT/app-path
    // the VRLevel counts slashes after the <instance> id
    // So we scan for the appropriate # of VrLevel "/" + 4
    //
    // Since the App Path is internal Metabase Path, it should only have
    //  the '/'  and not the weird '\\' :-(
    //

    pszInVr = m_strAppPath.QueryStr();
    DBG_ASSERT( *pszInVr == '/');
    dwL = QueryVrLevel() + 4;
    while ( dwL-- )
    {
        if ( *pszInVr )
        {
            DBG_ASSERT( *pszInVr == '/' );
            DBG_ASSERT( *pszInVr != '\\' );

            LPCSTR pszNext = strchr( pszInVr + 1, '/');
            if ( pszNext == NULL) {
                //
                // Invalid Metabase Path :(  Ignore the error!
                //  See (1A) above
                // SetLastError( ERROR_PATH_NOT_FOUND);
                pszInVr = NULL;
                dwL = (DWORD ) -1;
                break;
            }

            // set the scanning pointer to next slash.
            pszInVr = pszNext;
        }
    }

    DBG_ASSERT( dwL == (DWORD)-1 );


    //
    // Add a path delimiter char between virtual root mount point
    //  & significant part of URI
    //
    DWORD cchAppPath = pstrApplPhysicalPath->QueryCCH();
    if ( cchAppPath > 0 )
    {
        ch = *CharPrev(pstrApplPhysicalPath->QueryStr(), pstrApplPhysicalPath->QueryStr() + cchAppPath);
        if ( ch == '/' || ch == '\\')
        {
            if ( ( pszInVr != NULL ) && *pszInVr )
            {
                DBG_ASSERT( *pszInVr == '/');
                ++pszInVr;
            }
        } else {
            if ( pszInVr == NULL)
            {
                // happens for the special case (1A)
                // Append a "\\" now.
                if ( !pstrApplPhysicalPath->Append( "\\")) {
                    return (FALSE);
                }
            }
        }
    }

    if ( (pszInVr != NULL) &&  !pstrApplPhysicalPath->Append( pszInVr ) )
    {
        return FALSE;
    }

    //
    // insure physical path last char uses standard directory delimiter
    //

    FlipSlashes( pstrApplPhysicalPath->QueryStr() );

    return TRUE;

} // COMMON_METADATA::BuildApplPhysicalPath()






BOOL
COMMON_METADATA::BuildPhysicalPath(
    LPSTR           pszURL,
    STR *           pstrPhysicalPath
    )
{
    LPSTR               pszInVr;
    DWORD               dwL;
    INT                 ch;


    CheckSignature();
    TsValidateMetaCache();

    //
    // Build physical path from VR_PATH & portion of URI not used to define VR_PATH
    //


    //
    // skip the URI components used to locate the virtual root
    //

    pszInVr = pszURL ;
    dwL = QueryVrLevel();
    while ( dwL-- )
    {
        if ( *pszInVr )
        {
            DBG_ASSERT( *pszInVr == '/' || *pszInVr == '\\' );

            ++pszInVr;

            while ( (ch = *pszInVr) && ch != '/' && ch !='\\' )
            {
                pszInVr = CharNext( pszInVr );
            }
        }
    }

    DBG_ASSERT( dwL == (DWORD)-1 );

    if ( !pstrPhysicalPath->Copy( m_strVrPath ) )
    {
        return FALSE;
    }

    //
    // Add a path delimiter char between virtual root mount point & significant part of URI
    //

    if ( pstrPhysicalPath->QueryCCH() )
    {
        ch = *CharPrev(pstrPhysicalPath->QueryStr(), pstrPhysicalPath->QueryStr() +
                                                     pstrPhysicalPath->QueryCCH());
        if ( (ch == '/' || ch == '\\') && *pszInVr )
        {
            ++pszInVr;
        }
    }

    if ( !pstrPhysicalPath->Append( pszInVr ) )
    {
        return FALSE;
    }

    //
    // insure physical path last char uses standard directory delimiter
    //

    FlipSlashes( pstrPhysicalPath->QueryStr() );

    CheckSignature();
    TsValidateMetaCache();
    return TRUE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\tsinit.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        tsinit.cxx

   Abstract:
        This module contains the tsunami initialization code.

   Author:
        Murali R. Krishnan    ( MuraliK )     16-Jan-1995

--*/

#include "TsunamiP.Hxx"

#include <dbgutil.h>
#include <inetsvcs.h>
#pragma hdrstop

#include <iistypes.hxx>
#include <iisver.h>
#include <iiscnfg.h>
#include <imd.h>
#include <mb.hxx>

HANDLE g_hQuit = NULL;
HANDLE g_hNewItem   = NULL;
BOOL g_fW3OnlyNoAuth = FALSE;

extern LONG   g_nTsunamiThreads;

//
// Disables Tsunami Caching
//

BOOL DisableTsunamiCaching = FALSE;

//
// DisableSPUD
//

BOOL DisableSPUD = FALSE;

//
// Allows us to mask the invalid flags
//

DWORD TsValidCreateFileOptions = TS_IIS_VALID_FLAGS;

//
// flags to set on CreateFile
//

DWORD TsCreateFileShareMode = (FILE_SHARE_READ   |
                                FILE_SHARE_WRITE |
                                FILE_SHARE_DELETE);

BOOL  TsNoDirOpenSupport = FALSE;
DWORD TsCreateFileFlags = (FILE_FLAG_SEQUENTIAL_SCAN  |
                           FILE_FLAG_OVERLAPPED       |
                           FILE_FLAG_BACKUP_SEMANTICS );


BOOL
Tsunami_Initialize(
            VOID
            )
/*++

    Description:

        Initializes the tsunami package

    Note: This routine assumes the caller is handling multiple initializers
    and will only call this routine once in a thread safe manner

--*/
{

    HKEY hKey;
    DWORD dwType;
    DWORD nBytes;
    DWORD dwValue;
    DWORD dwMaxFile;
    DWORD err;

#if TSUNAMI_REF_DEBUG
    RefTraceLog = CreateRefTraceLog(
                      256,              // LogSize
                      0                 // ExtraBytesInHeader
                      );
#endif  // TSUNAMI_REF_DEBUG

    //
    // Initialize global events
    //

    g_hQuit = IIS_CREATE_EVENT(
                  "g_hQuit",
                  &g_hQuit,
                  TRUE,
                  FALSE
                  );

    g_hNewItem = IIS_CREATE_EVENT(
                     "g_hNewItem",
                     &g_hNewItem,
                     FALSE,
                     FALSE
                     );

    if ( (g_hQuit == NULL) || (g_hNewItem == NULL) ) {
        goto Failure;
    }

    //
    // Set defaults
    //

    MEMORYSTATUS ms;
    ms.dwLength = sizeof(MEMORYSTATUS);
    GlobalMemoryStatus( &ms );

    //
    // default is 1K files per 32MB of physical memory after the 1st 8MB,
    // minimum INETA_MIN_DEF_FILE_HANDLE
    //

    if ( ms.dwTotalPhys > 8 * 1024 * 1024 )
    {
        dwMaxFile = (ms.dwTotalPhys - 8 * 1024 * 1024) / ( 32 * 1024 );
        if ( dwMaxFile < INETA_MIN_DEF_FILE_HANDLE )
        {
            dwMaxFile = INETA_MIN_DEF_FILE_HANDLE;
        }
    }
    else
    {
        dwMaxFile = INETA_MIN_DEF_FILE_HANDLE;
    }

    //
    // If this is not a NTS, disable tsunami caching by default
    //

    DisableSPUD = !AtqSpudInitialized();


    if ( !TsIsNtServer() ) {
        DisableTsunamiCaching = TRUE;
        DisableSPUD = TRUE;
    }

    DisableSPUD = TRUE;

    if ( DisableSPUD ) {
        DbgPrint("DisableCacheOplocks set to TRUE by default.\n");
    } else {
        DbgPrint("DisableCacheOplocks set to FALSE by default.\n");
    }
    //
    // no overlapped i/o in win95.
    //

    if ( TsIsWindows95() ) {
        TsCreateFileFlags = FILE_FLAG_SEQUENTIAL_SCAN;
        TsCreateFileShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
        TsNoDirOpenSupport = TRUE;
        // |FILE_FLAG_BACKUP_SEMANTICS;
    }

    //
    // Read the registry key to see whether tsunami caching is enabled
    //

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                INETA_PARAMETERS_KEY,
                0,
                KEY_READ,
                &hKey
                );

    if ( err == ERROR_SUCCESS ) {

        //
        // This cannot be overridded in win95
        //

        if ( !TsIsWindows95() ) {
            nBytes = sizeof(dwValue);
            err = RegQueryValueEx(
                        hKey,
                        INETA_DISABLE_TSUNAMI_CACHING,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwValue,
                        &nBytes
                        );

            if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
                DisableTsunamiCaching = (BOOL)dwValue;
            }

            nBytes = sizeof(dwValue);
            err = RegQueryValueEx(
                        hKey,
                        INETA_DISABLE_TSUNAMI_SPUD,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwValue,
                        &nBytes
                        );

            if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
                DisableSPUD = (BOOL)dwValue;
                if ( DisableSPUD ) {
                    DbgPrint("DisableCacheOplocks set to TRUE in Registry.\n");
                } else {
                    DbgPrint("DisableCacheOplocks set to FALSE in Registry.\n");
                }
                DbgPrint("The Registry Setting will override the default.\n");
            }
        }

        if ( g_fW3OnlyNoAuth )
        {
            //
            // TODO: investigate is security descriptor caching
            // can be used in the non-SYSTEM account case.
            //

            g_fCacheSecDesc = FALSE;
        }
        else
        {
            //
            // read the enable cache sec desc flag
            //

            nBytes = sizeof(dwValue);
            err = RegQueryValueEx(
                            hKey,
                            INETA_CACHE_USE_ACCESS_CHECK,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &nBytes
                            );

            if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
                g_fCacheSecDesc = !!dwValue;
            }
            else {
                 g_fCacheSecDesc = INETA_DEF_CACHE_USE_ACCESS_CHECK;
            }
        }

        //
        // Read the maximum # of files in cache
        //

        nBytes = sizeof(dwValue);
        if ( RegQueryValueEx(
                            hKey,
                            INETA_MAX_OPEN_FILE,
                            NULL,
                            &dwType,
                            (LPBYTE) &dwValue,
                            &nBytes
                            ) == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            dwMaxFile = dwValue;
        }

        RegCloseKey( hKey );

    }

    //
    // if tsunami caching is disabled, set the flags accordingly
    //

    if ( DisableTsunamiCaching ) {
        g_fDisableCaching = TRUE;
        TsValidCreateFileOptions = TS_PWS_VALID_FLAGS;
        g_fCacheSecDesc = FALSE;
    }

    //
    // Initialize the directory change manager
    //

    if ( !DcmInitialize( ) ) {
        goto Failure;
    }

    //
    // Initialize the tsunami cache manager
    //

    if ( !Cache_Initialize( dwMaxFile )) {
        goto Failure;
    }

    if ( !MetaCache_Initialize() ) {
        goto Failure;
    }
    return( TRUE );

Failure:

    IIS_PRINTF( ( buff, "Tsunami_Initialize() Failed. Error = %d\n",
                GetLastError()));

    if ( g_hQuit )
    {
        CloseHandle( g_hQuit );
        g_hQuit = NULL;
    }

    if ( g_hNewItem )
    {
        CloseHandle( g_hNewItem );
        g_hNewItem = NULL;
    }

    return FALSE;
} // Tsunami_Initialize

VOID
Tsunami_Terminate(
    VOID
    )
/*++
    Description:

        Cleans up the Tsunami package

--*/
{
    DWORD dwResult;

    if ( !SetEvent( g_hQuit ) ) {
        IIS_PRINTF((buff,
                "No Quit event posted for Tsunami. No Cleanup\n"));
        return;
    }

    //
    //  Flush all items from the cache
    //

    TsCacheFlush( 0 );

    //
    //  Synchronize with our thread so we don't leave here before the
    //  thread has finished cleaning up
    //

    if ( g_hChangeWaitThread != NULL ) {
        DBG_REQUIRE( WaitForSingleObject( g_hChangeWaitThread, 20000 ) == WAIT_OBJECT_0 );
        CloseHandle( g_hChangeWaitThread);
    }

    CloseHandle( g_hQuit );
    CloseHandle( g_hNewItem );

    DeleteCriticalSection( &csVirtualRoots );

    MetaCache_Terminate();

#if TSUNAMI_REF_DEBUG
    if( RefTraceLog != NULL ) {
        DestroyRefTraceLog( RefTraceLog );
        RefTraceLog = NULL;
    }
#endif  // TSUNAMI_REF_DEBUG

} // Tsunami_Terminate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\tsmemp.cxx ===
#include "TsunamiP.Hxx"
#pragma hdrstop

#if DBG

PVOID DbgAllocateHeap
(
    IN PCHAR File,
    IN int   Line,
    IN ULONG Flags,
    IN ULONG Size
)
{
    PVOID pv;

    ASSERT( Flags == 0 );

    pv= LocalAlloc( LPTR, Size + sizeof( PCHAR ) + sizeof( int ));

    if ( pv )
    {
        *((PCHAR *)pv)=File;
        pv= (( PCHAR *)pv)+1;

        *((int *)pv)=Line;
        pv= (( int *)pv)+1;
    }

    return( pv );
}

PVOID DbgReAllocateHeap
(
    IN PCHAR File,
    IN int   Line,
    IN ULONG Flags,
    IN PVOID pvOld,
    IN ULONG Size
)
{
    PVOID pv;

    ASSERT( Flags == 0 );

    pvOld = (PVOID)( ((PCHAR)pvOld) - (sizeof( PCHAR ) + sizeof( int )) );

    pv=LocalReAlloc( pvOld, Size + sizeof( PCHAR ) + sizeof( int ), 0 );

    if ( pv )
    {
        pv = (PVOID)( ((PCHAR)pv) + sizeof( PCHAR ) + sizeof( int ) );
    }

    return( pv );
}

BOOL DbgFreeHeap
(
    IN PCHAR File,
    IN int   Line,
    IN ULONG Flags,
    IN PVOID pvOld
)
{
    ASSERT( Flags == 0 );

    pvOld = (PVOID)( ((PCHAR)pvOld) - (sizeof( PCHAR ) + sizeof( int )) );

    return LocalFree( pvOld ) == NULL;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\oplock\cache.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        cache.cxx

   Abstract:
        This module contains the tsunami caching routines

   Author:
        Murali R. Krishnan    ( MuraliK )     16-Jan-1995

--*/

#include "TsunamiP.Hxx"
#pragma hdrstop
#include <lonsi.hxx>
#include <dbgutil.h>

//
//  Items in a Bin list beyond this position will get moved to the front
//  on an object cache hit
//

#define  REORDER_LIST_THRESHOLD     5

//
//  Current count of cached file handles across a UNC connection
//

DWORD cCachedUNCHandles = 0;

//
// Enable caching of security descriptor & AccessCheck
//

BOOL g_fCacheSecDesc = TRUE;
BOOL g_fEnableCaching = TRUE;

BOOL
RemoveLruHandleCacheItem(
    VOID
    );

CACHE_TABLE CacheTable;

#if TSUNAMI_REF_DEBUG
PTRACE_LOG RefTraceLog;
#endif  // TSUNAMI_REF_DEBUG

BOOL
Cache_Initialize(
    IN DWORD MaxOpenFileInUse
    )
{
    int index;

    //
    // Initialize configuration block
    //

    ZeroMemory(&Configuration,sizeof( Configuration ));

    InitializeCriticalSection( &CacheTable.CriticalSection );
    SET_CRITICAL_SECTION_SPIN_COUNT( &CacheTable.CriticalSection,
                                          IIS_DEFAULT_CS_SPIN_COUNT);

    InitializeListHead( &CacheTable.MruList );

    CacheTable.OpenFileInUse = 0;
    CacheTable.MaxOpenFileInUse = MaxOpenFileInUse;

    for ( index=0; index<MAX_BINS; index++ ) {
        InitializeListHead( &CacheTable.Items[ index ] );
    }

    return( TRUE );
} // Cache_Initialize

BOOL
TsCacheDirectoryBlob(
    IN const TSVC_CACHE             &TSvcCache,
    IN      PCSTR                   pszDirectoryName,
    IN      ULONG                   iDemultiplexor,
    IN      PVOID                   pvBlob,
    IN      BOOLEAN                 bKeepCheckedOut,
    IN      PSECURITY_DESCRIPTOR    pSecDesc
    )
/*++

  Routine Description:

    This function associates the Blob given as input with the specified
    directory and demultiplexing number.  Services should use this
    function to add a Blob to the cache.

    Callers must not cache the same Blob twice.  Once a Blob is cached,
    its contents must not be modified, and it must not be freed or re-cached.

  Arguments

--*/
{
    CACHE_OBJECT *cache = NULL;
    PBLOB_HEADER  pbhBlob;
    BOOLEAN       bSuccess;
    ULONG         iBin;
    PLIST_ENTRY   pEntry;
    PCACHE_OBJECT pCache;
    PCHAR         pszTemp;
    HASH_TYPE     htHash;
    ULONG         cchLength;

    ASSERT( pszDirectoryName != NULL );
    ASSERT( pvBlob != NULL );

    IF_DEBUG( CACHE) {

        DBGPRINTF( (DBG_CONTEXT,
                    "TsCacheDirectoryBlob called with"
                    " Dir=%S, DeMux=%u, PvBlob=%08x, ChkedOut=%d\n",
                    pszDirectoryName,
                    iDemultiplexor,
                    pvBlob,
                    bKeepCheckedOut
                    ));
    }

    if ( g_fDisableCaching )
    {
        goto Cannot_Cache;
    }

    //
    //  The caller will have passed their pointer to the usable area of the
    //  Blob, so we have to adjust it to point to the beginning.
    //

    pbhBlob = (( PBLOB_HEADER )pvBlob ) - 1;

    ASSERT( !pbhBlob->IsCached );

    //
    //  Hash the directory name.
    //

    htHash = CalculateHashAndLengthOfPathName( pszDirectoryName,
                                                   &cchLength );


    //
    //  Allocate the cache object. We (effectively) allocate cchLength + 1
    //  bytes, to allow for the trailing NULL.
    //

    cache = (PCACHE_OBJECT)ALLOC( sizeof(CACHE_OBJECT) + cchLength);

    if ( cache == NULL ) {

        IF_DEBUG( CACHE) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "Unable to alloc Cache Object. Failure.\n"));
        }
        goto Cannot_Cache;
    }

    cache->Signature = CACHE_OBJ_SIGNATURE;

    cache->hash = htHash;
    cache->cchLength = cchLength;

    //
    //  Store the Blob in the new object.
    //

    cache->pbhBlob = pbhBlob;

    //
    //  Store the security descriptor in the new object.
    //

    cache->pSecDesc = pSecDesc;
    cache->hLastSuccessAccessToken = NULL;
    cache->fZombie = FALSE;

    //
    //  We need to be able to find the cache entry from the Blob.
    //

    pbhBlob->pCache = cache;

    //
    //  Initialize the check-out count.
    //

    cache->references = ( bKeepCheckedOut) ? 2 : 1;
    cache->iDemux     = iDemultiplexor;
    cache->dwService  = TSvcCache.GetServiceId();
    cache->dwInstance = TSvcCache.GetInstanceId();
    cache->TTL        = 1;

    TSUNAMI_TRACE( cache->references, cache );

    IF_DEBUG(OPLOCKS) {
        DBGPRINTF( (DBG_CONTEXT,"TsCacheDirectoryBlob(%s) iDemux=%08lx, cache=%08lx, references=%d\n",
            pszDirectoryName, iDemultiplexor, cache, cache->references ));
    }

    InitializeListHead( &cache->DirChangeList );

    //
    //  Lock the cache table against changes.  We need to take the lock
    //  before we add the new object to the directory change death list,
    //  so that a directory change that kills this object will not find
    //  the cache table without the object present.
    //

    EnterCriticalSection( &CacheTable.CriticalSection );

    //
    //  Copy the directory name to the cache object.
    //

    memcpy( cache->szPath, pszDirectoryName, cache->cchLength + 1 );

    //
    //  Add the object to the directory change expiry list.
    //
    //  There's an ugly, disgusting hack here making this code aware
    //  of the structure of URI info, but it's better than going
    //  through everywhere and fixing the call to this routine to pass
    //  in the file path as well as the cache key name.
    //

    if (iDemultiplexor == RESERVED_DEMUX_URI_INFO)
    {
        PW3_URI_INFO    pURIInfo = (PW3_URI_INFO)pvBlob;

        pszTemp = pURIInfo->pszName;

    } else
    {
        pszTemp = (PCHAR)pszDirectoryName;
    }

    bSuccess = DcmAddNewItem(
                    (PIIS_SERVER_INSTANCE)TSvcCache.GetServerInstance(),
                    pszTemp,
                    cache
                    );

    if ( !bSuccess )
    {
        //
        //  For whatever reason, we cannot get notifications of changes
        //  in the directory containing the to-be-cached item.  We won't
        //  be adding this object to the cache table, so we unlock the
        //  table and jump to the failure-handling code.
        //

        LeaveCriticalSection( &CacheTable.CriticalSection );

        IF_DEBUG( CACHE) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " Unable to cache. Due to rejection by DirChngMgr\n"));
        }

        goto Cannot_Cache;
    }

    //
    //  Mark this blob as cached, since we'll either cache it or throw it
    //  away hereafter.
    //

    pbhBlob->IsCached = TRUE;

    //
    //  Add the object to the cache table, as the most-recently-used object.
    //

    iBin = HASH_TO_BIN( cache->hash );

    //
    //  Look for a previously cached object for the same directory.  If we
    //  find one, remove it.
    //

    for (   pEntry  = CacheTable.Items[ iBin ].Flink;
            pEntry != &CacheTable.Items[ iBin ];
            pEntry  = pEntry->Flink )
    {
        pCache = CONTAINING_RECORD( pEntry, CACHE_OBJECT, BinList );

        if ( pCache->cchLength == cache->cchLength &&
             pCache->hash      == cache->hash      &&
             pCache->iDemux    == cache->iDemux    &&
             pCache->dwService == cache->dwService &&
             pCache->dwInstance== cache->dwInstance &&
             !_memicmp( cache->szPath, pCache->szPath, cache->cchLength ) )
        {
            //
            //  We found a matching cache object.  We remove it, since it
            //  has been replaced by this new object.
            //

        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCacheDirectoryBlob - Decache(%s)\n", pCache->szPath ));
        }
            DeCache( pCache, FALSE );

            IF_DEBUG( CACHE) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Matching cache object found."
                            " Throwing that object ( %08x) out of cache\n",
                            pEntry));
            }

            break;
        }
    }

    //
    //  Add this object to the cache.
    //

    InsertHeadList( &CacheTable.Items[ iBin ], &cache->BinList );

    //
    //  Since this object was just added, put it at the head of the MRU list.
    //

    InsertHeadList( &CacheTable.MruList, &cache->MruList );

    //
    //  Increase the running size of cached objects by the size of the one
    //  just cached.
    //

    IF_DEBUG(OPLOCKS) {
        DBGPRINTF( (DBG_CONTEXT,"TsCacheDirectoryBlob(%s)\n",
            pszDirectoryName));
    }

    //
    // Limit number of open file entries in cache.
    // Note that in the current scenario pOpenFileInfo is set only after the URI_INFO
    // blob is inserted in cache, so TsCreateFileFromURI also has to check for
    // # of open file in cache.
    //

    if ( (iDemultiplexor == RESERVED_DEMUX_OPEN_FILE) ||
         (iDemultiplexor == RESERVED_DEMUX_URI_INFO &&
              ((W3_URI_INFO*)pvBlob)->bFileInfoValid &&
              ((W3_URI_INFO*)pvBlob)->pOpenFileInfo != NULL) )
    {
        TsIncreaseFileHandleCount( TRUE );
    }

    //
    //  Unlock the cache table.
    //

    LeaveCriticalSection( &CacheTable.CriticalSection );

    ASSERT( BLOB_IS_OR_WAS_CACHED( pvBlob ) );

    //
    //  Return success.
    //


    IF_DEBUG( CACHE) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Cached object(%08x) contains Blob (%08x)."
                    " Returning TRUE\n",
                    cache, pvBlob));
    }

    return( TRUE );

Cannot_Cache:

    //
    //  The cleanup code does not cleanup a directory change item.
    //

    if ( cache != NULL )
    {
        cache->Signature = 0;
        FREE( cache );
        cache = NULL;
    }

    ASSERT( !BLOB_IS_OR_WAS_CACHED( pvBlob ) );

    IF_DEBUG( CACHE) {

        DBGPRINTF( (DBG_CONTEXT, " Failure to cache the object ( %08x)\n",
                    pvBlob));
    }

    return( FALSE );

} // TsCacheDirectoryBlob

BOOL
TsCheckOutCachedBlob(
    IN const TSVC_CACHE             &TSvcCache,
    IN      PCSTR                   pszDirectoryName,
    IN      ULONG                   iDemultiplexor,
    IN      PVOID *                 ppvBlob,
    IN      HANDLE                  hAccessToken,
    IN      BOOL                    fMayCacheAccessToken,
    IN      PSECURITY_DESCRIPTOR*   ppSecDesc
    )
{
    HASH_TYPE hash;
    ULONG cchLength;
    int iBin;
    BOOL Result;
    LONG refCount;
    PLIST_ENTRY pEntry;
    PCACHE_OBJECT pCache;
    DWORD         Position = 0;
    BOOL fSkipIdCheck = (iDemultiplexor != RESERVED_DEMUX_OPEN_FILE) &&
                        (iDemultiplexor != RESERVED_DEMUX_URI_INFO);

    ASSERT( pszDirectoryName != NULL );
    ASSERT( ppvBlob != NULL );

    //
    //  Prepare the return value such that we fail by default.
    //

    Result = FALSE;

    if ( ppSecDesc )
    {
        *ppSecDesc = NULL;
    }

    //
    //  Calculate the hash and length of the path name.
    //

    hash = CalculateHashAndLengthOfPathName( pszDirectoryName, &cchLength );

    //
    //  Calculate the bin of the hash table that should head the list
    //  containing the sought-after item.
    //

    iBin = HASH_TO_BIN( hash );


    EnterCriticalSection( &CacheTable.CriticalSection );

    __try
    {

        //
        //  Look for a previously cached object for the same directory.  If we
        //  find one, return it.
        //

        for (   pEntry  = CacheTable.Items[ iBin ].Flink;
                pEntry != &CacheTable.Items[ iBin ];
                pEntry  = pEntry->Flink, Position++ )
        {
            pCache = CONTAINING_RECORD( pEntry, CACHE_OBJECT, BinList );

            ASSERT( pCache->Signature == CACHE_OBJ_SIGNATURE );
            ASSERT( pCache->pbhBlob->IsCached );
            ASSERT( pCache->pbhBlob->pCache == pCache );

            if ( pCache->cchLength == cchLength &&
                 pCache->hash == hash &&
                 pCache->iDemux == iDemultiplexor &&
                 ( fSkipIdCheck ||
                    ( pCache->dwService == TSvcCache.GetServiceId() &&
                      pCache->dwInstance == TSvcCache.GetInstanceId() ) ) &&
                 !_memicmp( pCache->szPath, pszDirectoryName, cchLength ) )
            {
                //
                // Check access rights
                //

                if ( pCache->pSecDesc && hAccessToken &&
                     hAccessToken != pCache->hLastSuccessAccessToken )
                {
                    BOOL    fAccess;
                    DWORD   dwGrantedAccess;
                    BYTE    psFile[SIZE_PRIVILEGE_SET];
                    DWORD   dwPS = sizeof( psFile );

                    if ( !::AccessCheck(
                            pCache->pSecDesc,
                            hAccessToken,
                            FILE_GENERIC_READ,
                            &g_gmFile,
                            (PRIVILEGE_SET*)psFile,
                            &dwPS,
                            &dwGrantedAccess,
                            &fAccess ) || !fAccess )
                    {
                        DBGPRINTF( (DBG_CONTEXT, "[TsCheckOutCachedBlob] AccessCheck failed error %d\n", GetLastError() ));
                        Result = FALSE;
                        goto Exit;
                    }
                    if ( fMayCacheAccessToken )
                    {
                        pCache->hLastSuccessAccessToken = hAccessToken;
                    }
                }

                //
                //  We found a matching cache object.  We return it and increase
                //  its reference count.
                //

                *ppvBlob = pCache->pbhBlob + 1;

                ASSERT( pCache->pbhBlob->IsCached );

                //
                //  Increase the reference count of the cached object, to prevent
                //  it from expiration while it is checked out.
                //

                refCount = InterlockedIncrement( ( LONG * )( &(pCache->references ) ) );

                TSUNAMI_TRACE( refCount, pCache );

                IF_DEBUG(OPLOCKS) {

                    DBGPRINTF( (DBG_CONTEXT,"TsCheckOutCachedBlob(%s) iDemux=%08lx, cache=%08lx, references=%d\n",
                        pszDirectoryName, pCache->iDemux, pCache, pCache->references ));
                }

                pCache->TTL = 1;

                Result = TRUE;

                //
                //  If the found item is far enough back in the list, move
                //  it to the front so the next hit will be quicker
                //

                if ( Position > REORDER_LIST_THRESHOLD )
                {
                    RemoveEntryList( pEntry );
                    InsertHeadList( &CacheTable.Items[ iBin ], pEntry );

                    IF_DEBUG( CACHE ) {

                        DBGPRINTF(( DBG_CONTEXT,
                                    "[TsCheckOutCachedBlobW] Reordered list for item at %d position\n",
                                    Position ));
                    }
                }

                if ( ppSecDesc && pCache->pSecDesc )
                {
                    if ( *ppSecDesc = (PSECURITY_DESCRIPTOR)LocalAlloc( LMEM_FIXED,
                            GetSecurityDescriptorLength(pCache->pSecDesc) ) )
                    {
                        memcpy( *ppSecDesc,
                                pCache->pSecDesc,
                                GetSecurityDescriptorLength(pCache->pSecDesc) );
                    }
                }

                break;
            }
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        //  As far as I can see, the only way we can end up here with
        //  Result == TRUE is an exception on LeaveCriticalSection().  If
        //  that happens, we're toast anyway, since noone will ever get to
        //  the CacheTable again.
        //

        ASSERT( !Result );

        Result = FALSE;
    }
Exit:
    LeaveCriticalSection( &CacheTable.CriticalSection );

    if ( Result) {

        INC_COUNTER( TSvcCache.GetServiceId(), CacheHits );

    } else {

        INC_COUNTER( TSvcCache.GetServiceId(), CacheMisses );
    }

    return( Result );
} // TsCheckOutCachedBlobW


VOID
CheckForZombieCacheObjs(
    IN PPHYS_OPEN_FILE_INFO pPhysFileInfo,
    IN PVOID pOtherCachedBlob,
    IN BOOL fAddBlobToPhysFileList
    )
{

    PBLOB_HEADER pbhPhysBlob;
    PBLOB_HEADER pbhOtherBlob;
    PCACHE_OBJECT physCache;
    PCACHE_OBJECT otherCache;

    EnterCriticalSection( &CacheTable.CriticalSection );

    //
    // Validate the incoming PHYS_OPEN_FILE_INFO pointer, then map
    // it and the other cached object to their containing BLOBs.
    //

    ASSERT( pPhysFileInfo->Signature == PHYS_OBJ_SIGNATURE );
    pbhPhysBlob = ((PBLOB_HEADER)pPhysFileInfo) - 1;
    ASSERT( pbhPhysBlob->IsCached );

    pbhOtherBlob = ((PBLOB_HEADER)pOtherCachedBlob) - 1;

    //
    // If so requested, add the cached object to the open reference list.
    //

    if( fAddBlobToPhysFileList ) {
        ASSERT( IsListEmpty( &pbhPhysBlob->PFList ) );
        InsertHeadList( &pPhysFileInfo->OpenReferenceList, &pbhOtherBlob->PFList );
    }

    //
    // Get the containing CACHE_OBJECTs.
    //

    physCache = pbhPhysBlob->pCache;
    ASSERT( physCache != NULL );
    ASSERT( physCache->Signature == CACHE_OBJ_SIGNATURE );
    ASSERT( physCache->pbhBlob == pbhPhysBlob );
    TSUNAMI_TRACE( TRACE_CACHE_ZOMBIE_CHECK, physCache );

    otherCache = pbhOtherBlob->pCache;
    TSUNAMI_TRACE( TRACE_CACHE_ZOMBIE_CHECK, otherCache );

    if( otherCache != NULL ) {
        ASSERT( otherCache->Signature == CACHE_OBJ_SIGNATURE );
        ASSERT( otherCache->pbhBlob == pbhOtherBlob );

        //
        // If either the physical entry or the other entry are marked as
        // zombies, then remove the other entry from the cache.
        //

        if( physCache->fZombie || otherCache->fZombie ) {
            if( RemoveCacheObjFromLists( otherCache, FALSE ) ) {
                TsDereferenceCacheObj( otherCache, FALSE );
            }

            //
            // Ensure the physical entry is marked as a zombie.
            //

            physCache->fZombie = TRUE;
            TSUNAMI_TRACE( TRACE_CACHE_ZOMBIE, physCache );
        }
    }

    LeaveCriticalSection( &CacheTable.CriticalSection );

}   // CheckForZombieCacheObjs


BOOL
TsCheckOutCachedPhysFile(
    IN const TSVC_CACHE             &TSvcCache,
    IN      PCSTR                   pszDirectoryName,
    IN      PVOID *                 ppvBlob
    )
{
    HASH_TYPE hash;
    ULONG cchLength;
    int iBin;
    BOOL Result;
    BOOL Found;
    LONG refCount;
    PLIST_ENTRY pEntry;
    PCACHE_OBJECT pCache = NULL;
    DWORD         Position = 0;
    PBLOB_HEADER  pbhBlob;
    PPHYS_OPEN_FILE_INFO pPhysFileInfo;
    LPSTR eventName;

    ASSERT( pszDirectoryName != NULL );
    ASSERT( ppvBlob != NULL );

    //
    //  Prepare the return value such that we fail by default.
    //

    Result = FALSE;
    Found = FALSE;
    *ppvBlob = NULL;

    //
    //  Calculate the hash and length of the path name.
    //

    hash = CalculateHashAndLengthOfPathName( pszDirectoryName, &cchLength );

    //
    //  Calculate the bin of the hash table that should head the list
    //  containing the sought-after item.
    //

    iBin = HASH_TO_BIN( hash );


    EnterCriticalSection( &CacheTable.CriticalSection );

    __try
    {

        //
        //  Look for a previously cached object for the same directory.  If we
        //  find one, return it.
        //

        for (   pEntry  = CacheTable.Items[ iBin ].Flink;
                pEntry != &CacheTable.Items[ iBin ];
                pEntry  = pEntry->Flink, Position++ )
        {
            pCache = CONTAINING_RECORD( pEntry, CACHE_OBJECT, BinList );

            ASSERT( pCache->Signature == CACHE_OBJ_SIGNATURE );
            ASSERT( pCache->pbhBlob->IsCached );
            ASSERT( pCache->pbhBlob->pCache == pCache );

            if ( pCache->cchLength == cchLength &&
                 pCache->hash == hash &&
                 pCache->iDemux == RESERVED_DEMUX_PHYSICAL_OPEN_FILE &&
                 !pCache->fZombie &&
                 !_memicmp( pCache->szPath, pszDirectoryName, cchLength ) )
            {

                //
                //  We found a matching cache object. Increment its
                //  reference count and return the object.
                //

                *ppvBlob = pCache->pbhBlob + 1;

                ASSERT( pCache->pbhBlob->IsCached );

                //
                //  Increase the reference count of the cached object, to prevent
                //  it from expiration while it is checked out.
                //

                refCount = InterlockedIncrement( ( LONG * )( &(pCache->references ) ) );

                TSUNAMI_TRACE( refCount, pCache );

                IF_DEBUG(OPLOCKS) {
                    DBGPRINTF( (DBG_CONTEXT,"TsCheckOutCachedPhysFile(%s) iDemux=%08lx, cache=%08lx, references=%d\n",
                    pszDirectoryName, pCache->iDemux, pCache, pCache->references ));
                }

                pCache->TTL = 1;

                Result = TRUE;
                Found = TRUE;

                //
                //  If the found item is far enough back in the list, move
                //  it to the front so the next hit will be quicker
                //

                if ( Position > REORDER_LIST_THRESHOLD )
                {
                    RemoveEntryList( pEntry );
                    InsertHeadList( &CacheTable.Items[ iBin ], pEntry );

                    IF_DEBUG( OPLOCKS ) {

                        DBGPRINTF(( DBG_CONTEXT,
                                    "[TsCheckOutCachedBlobW] Reordered list for item at %d position\n",
                                    Position ));
                    }
                }

                break;
            }
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        //  As far as I can see, the only way we can end up here with
        //  Result == TRUE is an exception on LeaveCriticalSection().  If
        //  that happens, we're toast anyway, since noone will ever get to
        //  the CacheTable again.
        //

        ASSERT( !Result );

        Result = FALSE;
    }

    //
    // If we don't find a cache entry for the file, create one
    //

    pCache = NULL;

    if ( !Result ) {
        Result = TsAllocateEx(  TSvcCache,
                            sizeof( PHYS_OPEN_FILE_INFO ),
                            ppvBlob,
                            DisposePhysOpenFileInfo );

        if ( Result ) {

            pPhysFileInfo = (PPHYS_OPEN_FILE_INFO)*ppvBlob;

            pPhysFileInfo->Signature = PHYS_OBJ_SIGNATURE;
            pPhysFileInfo->hOpenFile = INVALID_HANDLE_VALUE;
            pPhysFileInfo->dwLastError = ERROR_FILE_NOT_FOUND;
            pPhysFileInfo->fSecurityDescriptor = FALSE;
            pPhysFileInfo->fIsCached = FALSE;
            pPhysFileInfo->pOplock = NULL;

#if DBG
            CHAR dbgEventName[sizeof("PhysFileInfo @ 12345789 PID 1234567890")];

            wsprintf(
                dbgEventName,
                "PhysFileInfo @ %08lx PID %lu",
                pPhysFileInfo,
                GetCurrentProcessId()
                );

            eventName = dbgEventName;
#else
            eventName = NULL;
#endif

            pPhysFileInfo->hOpenEvent = CreateEvent(
                                            NULL,
                                            TRUE,
                                            FALSE,
                                            eventName
                                            );

            if ( pPhysFileInfo->hOpenEvent == NULL ) {
                TsFree( TSvcCache, *ppvBlob );
                *ppvBlob = NULL;
                Result = FALSE;
                goto Exit;
            }

            InitializeListHead( &pPhysFileInfo->OpenReferenceList );

            pPhysFileInfo->abSecurityDescriptor = (BYTE *)ALLOC( SECURITY_DESC_DEFAULT_SIZE );

            if ( pPhysFileInfo->abSecurityDescriptor == NULL ) {
                TsFree( TSvcCache, *ppvBlob );
                *ppvBlob = NULL;
                Result = FALSE;
                goto Exit;
            } else {
                pPhysFileInfo->cbSecDescMaxSize = SECURITY_DESC_DEFAULT_SIZE;
            }

            //
            //  *ppvBlob points to the usable area of the
            //  Blob, so we have to adjust it to point to the beginning.
            //

            pbhBlob = (( PBLOB_HEADER )*ppvBlob ) - 1;

            ASSERT( !pbhBlob->IsCached );

            if ( g_fDisableCaching )
            {
                goto Cannot_Cache;
            }

            //
            //  Allocate the cache object. We (effectively) allocate cchLength + 1
            //  bytes, to allow for the trailing NULL.
            //

            pCache = (PCACHE_OBJECT)ALLOC( sizeof(CACHE_OBJECT) + cchLength);

            if ( pCache == NULL ) {

                IF_DEBUG( OPLOCKS ) {

                    DBGPRINTF( ( DBG_CONTEXT,
                                "Unable to alloc Cache Object. Failure.\n"));
                }
                TsFree( TSvcCache, *ppvBlob );
                *ppvBlob = NULL;
                Result = FALSE;
                goto Exit;
            }

            pCache->Signature = CACHE_OBJ_SIGNATURE;

            pCache->hash = hash;
            pCache->cchLength = cchLength;

            //
            //  Store the Blob in the new object.
            //

            pCache->pbhBlob = pbhBlob;

            //
            //  Store the security descriptor in the new object.
            //

            pCache->pSecDesc = NULL;
            pCache->hLastSuccessAccessToken = NULL;
            pCache->fZombie = FALSE;

            //
            //  We need to be able to find the cache entry from the Blob.
            //

            pbhBlob->pCache = pCache;

            //
            //  Initialize the check-out count.
            //

            pCache->references = 1;
            pCache->iDemux     = RESERVED_DEMUX_PHYSICAL_OPEN_FILE;
            pCache->dwService  = TSvcCache.GetServiceId();
            pCache->dwInstance = TSvcCache.GetInstanceId();
            pCache->TTL        = 1;

            TSUNAMI_TRACE( pCache->references, pCache );

            IF_DEBUG(OPLOCKS) {
                DBGPRINTF( (DBG_CONTEXT,"TsCheckOutCachedPhysFile(%s) cache=%08lx, references=%d\n",
                    pszDirectoryName, pCache, pCache->references ));
            }

            InitializeListHead( &pCache->DirChangeList );

            //
            //  Copy the directory name to the cache object.
            //

            memcpy( pCache->szPath, pszDirectoryName, pCache->cchLength + 1 );

#if 0
            Result = DcmAddNewItem(
                            (PIIS_SERVER_INSTANCE)TSvcCache.GetServerInstance(),
                            (PCHAR)pszDirectoryName,
                            pCache
                            );

            if ( !Result )
            {
                //
                //  For whatever reason, we cannot get notifications of changes
                //  in the directory containing the to-be-cached item.  We won't
                //  be adding this object to the cache table, so we unlock the
                //  table and jump to the failure-handling code.
                //

                IF_DEBUG( OPLOCKS) {

                    DBGPRINTF( ( DBG_CONTEXT,
                                " Unable to cache. Due to rejection by DirChngMgr\n"));
                }

                goto Cannot_Cache;
            }
#endif

            //
            //  Mark this blob as cached, since we'll either cache it or throw it
            //  away hereafter.
            //

            pbhBlob->IsCached = TRUE;
            pPhysFileInfo->fIsCached = TRUE;

            //
            //  Add the object to the cache table, as the most-recently-used object.
            //

            iBin = HASH_TO_BIN( pCache->hash );

            //
            //  Add this object to the cache.
            //

            InsertHeadList( &CacheTable.Items[ iBin ], &pCache->BinList );

            //
            //  Since this object was just added, put it at the head of the MRU list.
            //

            InsertHeadList( &CacheTable.MruList, &pCache->MruList );

            //
            //  Increase the running size of cached objects by the size of the one
            //  just cached.
            //

            IF_DEBUG(OPLOCKS) {
                DBGPRINTF( (DBG_CONTEXT,"TsCheckoutCachedPhysFile(%s)\n",
                    pszDirectoryName ));
            }

            ASSERT( BLOB_IS_OR_WAS_CACHED( *ppvBlob ) );

            //
            //  Return success.
            //

            IF_DEBUG( OPLOCKS) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Cached object(%08x) contains Blob (%08x)."
                            " Returning TRUE\n",
                            pCache, *ppvBlob));
            }

            goto Exit;


        } else {
            IF_DEBUG(OPLOCKS) {
                DBGPRINTF( (DBG_CONTEXT,"TsCheckOutCachedPhysFile(%s) Alloc Failed!\n",
                    pszDirectoryName ));
            }
        }
    } else {
        goto Exit;
    }

Cannot_Cache:
    //
    //  The cleanup code does not cleanup a directory change item.
    //

    if ( pCache != NULL )
    {
        pCache->Signature = 0;
        FREE( pCache );
        pCache = NULL;
    }

    ASSERT( !BLOB_IS_OR_WAS_CACHED( *ppvBlob ) );

    IF_DEBUG( OPLOCKS) {

        DBGPRINTF( (DBG_CONTEXT, " Failure to cache the object ( %08x)\n",
                    *ppvBlob));
    }

    Result = FALSE;

Exit:

    LeaveCriticalSection( &CacheTable.CriticalSection );

    if ( Result) {

        INC_COUNTER( TSvcCache.GetServiceId(), CacheHits );

    } else {

        INC_COUNTER( TSvcCache.GetServiceId(), CacheMisses );
    }

    return( Found );
} // TsCheckOutCachedPhysFile


BOOL
TsCheckInCachedBlob(
    IN      PVOID           pvBlob
    )
{
    PBLOB_HEADER pbhBlob;
    PCACHE_OBJECT pCache;
    BOOL bEjected;

    pbhBlob = (( PBLOB_HEADER )pvBlob ) - 1;

    ASSERT( pbhBlob->IsCached );

    pCache = pbhBlob->pCache;

    ASSERT( pCache->Signature == CACHE_OBJ_SIGNATURE );
    ASSERT( pCache->pbhBlob == pbhBlob );

    ASSERT( pCache->references > 0 );

    TsDereferenceCacheObj( pCache, TRUE );

    return( TRUE );
} // TsCheckInCachedBlob

BOOL
TsAddRefCachedBlob(
    IN      PVOID           pvBlob
    )
{
    PBLOB_HEADER pbhBlob;
    PCACHE_OBJECT pCache;
    BOOL bEjected;
    LONG refCount;

    pbhBlob = (( PBLOB_HEADER )pvBlob ) - 1;

    ASSERT( pbhBlob->IsCached );

    pCache = pbhBlob->pCache;

    ASSERT( pCache->Signature == CACHE_OBJ_SIGNATURE );
    ASSERT( pCache->pbhBlob == pbhBlob );

    ASSERT( pCache->references > 0 );

    refCount = InterlockedIncrement( (LONG *) &pCache->references );

    TSUNAMI_TRACE( refCount, pCache );

    return( TRUE );
} // TsCheckInCachedBlob

BOOL
TsExpireCachedBlob(
    IN const TSVC_CACHE &TSvcCache,
    IN      PVOID           pvBlob
    )
{
    PBLOB_HEADER pbhBlob;
    PCACHE_OBJECT pCache;

    pbhBlob = (( PBLOB_HEADER )pvBlob ) - 1;

    ASSERT( pbhBlob->IsCached );

    pCache = pbhBlob->pCache;

    ASSERT( pCache->Signature == CACHE_OBJ_SIGNATURE );
    ASSERT( pCache->pbhBlob == pbhBlob );
    ASSERT( pCache->references > 0 );

    return( DeCache( pCache, TRUE ) );
} // TsExpireCachedBlob

VOID
TsDereferenceCacheObj(
    IN      PCACHE_OBJECT  pCache,
    IN      BOOL           fLockCacheTable
    )
{

    LONG refCount;

    ASSERT( pCache->Signature == CACHE_OBJ_SIGNATURE );
    ASSERT( pCache->references > 0 );
    ASSERT( pCache->pbhBlob->IsCached );

    IF_DEBUG(OPLOCKS) {
        DBGPRINTF( (DBG_CONTEXT,"TsDereferenceCacheObj(%s) iDemux=%08lx, cache=%08lx, references=%d\n",
            pCache->szPath, pCache->iDemux, pCache, (pCache->references - 1) ));
    }

    refCount = InterlockedDecrement( (LONG *)&pCache->references );

    TSUNAMI_TRACE( refCount, pCache );

    if( refCount == 0 ) {

        EnterCriticalSection( &CacheTable.CriticalSection );

        if ( pCache->references != 0 ) {
            LeaveCriticalSection( &CacheTable.CriticalSection );
            return;
        }

        RemoveCacheObjFromLists( pCache, FALSE );

        if (!DisableSPUD) {
            if (!IsListEmpty( &pCache->pbhBlob->PFList ) ) {
                RemoveEntryList( &pCache->pbhBlob->PFList );
                InitializeListHead( &pCache->pbhBlob->PFList );
            }
        }

        //
        //  We best not be on a list if we're about to be freed here
        //

        ASSERT( IsListEmpty( &pCache->BinList ) );

        //
        //  We really want to call TsFree here, but we don't have a TsvcCache
        //

        IF_DEBUG( CACHE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "[DeCache] Free routine: 0x%lx, Blob: 0x%lx Cache obj: 0x%lx\n",
                        pCache->pbhBlob->pfnFreeRoutine,
                        pCache->pbhBlob,
                        pCache ));
        }

        if ( pCache->pbhBlob->pfnFreeRoutine )
            pCache->pbhBlob->pfnFreeRoutine( pCache->pbhBlob + 1);

        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsDereferenceCacheObj(%s)\n",
                pCache->szPath ));
        }

        DEC_COUNTER( pCache->dwService, CurrentObjects );

        if ( pCache->pSecDesc )
        {
            LocalFree( pCache->pSecDesc );
        }

        if ( pCache->iDemux == RESERVED_DEMUX_OPEN_FILE )
        {
            TsDecreaseFileHandleCount();
        }

        pCache->Signature = CACHE_OBJ_SIGNATURE_X;
        FREE( pCache->pbhBlob );
        FREE( pCache );

        LeaveCriticalSection( &CacheTable.CriticalSection );

    }

} // TsDereferenceCacheObj

VOID
TsDecreaseFileHandleCount(
    VOID
    )
{
    ASSERT( CacheTable.OpenFileInUse != 0 );

    if ( CacheTable.OpenFileInUse )
    {
        InterlockedDecrement( (LONG*)&CacheTable.OpenFileInUse );
    }
}


VOID
TsIncreaseFileHandleCount(
    BOOL    fInCacheLock
    )
{
    if ( (UINT)(pfnInterlockedExchangeAdd( (LONG*)&CacheTable.OpenFileInUse, 1) )
            >= CacheTable.MaxOpenFileInUse )
    {
        if ( !fInCacheLock )
        {
            EnterCriticalSection( &CacheTable.CriticalSection );
        }
        RemoveLruHandleCacheItem();
        if ( !fInCacheLock )
        {
            LeaveCriticalSection( &CacheTable.CriticalSection );
        }
    }
}

BOOL
RemoveLruHandleCacheItem(
    VOID
    )
/*++

  Routine Description:

    Remove the least recently used cached item referencing a file handle


    THE CACHE TABLE LOCK MUST BE TAKEN PRIOR TO CALLING THIS FUNCTION

  Arguments:

    None

--*/
{
    PLIST_ENTRY pEntry;

    for ( pEntry = CacheTable.MruList.Blink ;
          pEntry != &CacheTable.MruList ;
          pEntry = pEntry->Blink )
    {
        //
        //  The least recently used entry is the one at the tail of the MRU
        //  list.
        //

        PCACHE_OBJECT  pCacheObject =
                         CONTAINING_RECORD( pEntry,
                                            CACHE_OBJECT,
                                            MruList );

        PW3_URI_INFO   pURI = (PW3_URI_INFO)(pCacheObject->pbhBlob+1);

        if ( (pCacheObject->iDemux == RESERVED_DEMUX_OPEN_FILE) ||
             (pCacheObject->iDemux == RESERVED_DEMUX_URI_INFO &&
                  pURI->bFileInfoValid &&
                  pURI->pOpenFileInfo != NULL) )
        {
            DeCache( pCacheObject, FALSE );

            IF_DEBUG( CACHE) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Throwing out object ( %08x) to reduce file handle ref\n",
                            pCacheObject));
            }

            return TRUE;
        }
    }

    return FALSE;
} // RemoveLruCacheItem


BOOL
TsCacheQueryStatistics(
    IN  DWORD       Level,
    IN  DWORD       dwServerMask,
    IN  INETA_CACHE_STATISTICS * pCacheCtrs
    )
/*++

  Routine Description:

    This function returns the statistics for the global cache or for the
    individual services

  Arguments:

    Level - Only valid value is 0
    dwServerMask - Server mask to retrieve statistics for or 0 for the sum
        of the services
    pCacheCtrs - Receives the statistics for cache

  Notes:
    CacheBytesTotal and CacheBytesInUse are not kept on a per-server basis
        so they are only returned when retrieving summary statistics.

  Returns:

    TRUE on success, FALSE on failure
--*/
{
    if ( Level != 0 ||
         dwServerMask > LAST_PERF_CTR_SVC ||
         !pCacheCtrs )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if ( dwServerMask )
    {
        memcpy( pCacheCtrs,
                &Configuration.Stats[ MaskIndex(dwServerMask) ],
                sizeof( Configuration.Stats[ 0 ] ) );
    }
    else
    {
        //
        //  Add up all of the statistics
        //

        memset( pCacheCtrs, 0, sizeof( *pCacheCtrs ));

        for ( int i = 0; i < MAX_PERF_CTR_SVCS; i++ )
        {
            DWORD index = MaskIndex( 1 << i );

            pCacheCtrs->CurrentOpenFileHandles+= Configuration.Stats[index].CurrentOpenFileHandles;
            pCacheCtrs->CurrentDirLists       += Configuration.Stats[index].CurrentDirLists;
            pCacheCtrs->CurrentObjects        += Configuration.Stats[index].CurrentObjects;
            pCacheCtrs->FlushesFromDirChanges += Configuration.Stats[index].FlushesFromDirChanges;
            pCacheCtrs->CacheHits             += Configuration.Stats[index].CacheHits;
            pCacheCtrs->CacheMisses           += Configuration.Stats[index].CacheMisses;
#if 0
            pCacheCtrs->TotalSuccessGetSecDesc+= Configuration.Stats[index].TotalSuccessGetSecDesc;
            pCacheCtrs->TotalFailGetSecDesc   += Configuration.Stats[index].TotalFailGetSecDesc;
            if  ( pCacheCtrs->CurrentSizeSecDesc < Configuration.Stats[index].CurrentSizeSecDesc )
            {
                pCacheCtrs->CurrentSizeSecDesc = Configuration.Stats[index].CurrentSizeSecDesc;
            }
            pCacheCtrs->TotalAccessCheck      += Configuration.Stats[index].TotalAccessCheck;
#endif
        }
    }

    return TRUE;
}

BOOL
TsCacheClearStatistics(
    IN  DWORD       dwServerMask
    )
/*++

  Routine Description:

    Clears the the specified service's statistics

--*/
{
    if ( dwServerMask > LAST_PERF_CTR_SVC )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    //  Currently this function isn't supported
    //

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
} // TsCacheClearStatistics

BOOL
TsCacheFlush(
    IN  DWORD       dwServerMask
    )
/*++

  Routine Description:

    This function flushes the cache of all items for the specified service
    or for all services if dwServerMask is zero.

--*/
{
    LIST_ENTRY * pEntry;
    LIST_ENTRY * pNext;

    if ( dwServerMask == 0 ) {
        return(TRUE);
    }

    EnterCriticalSection( &CacheTable.CriticalSection );

    for ( pEntry =  CacheTable.MruList.Flink;
          pEntry != &CacheTable.MruList;
        )
    {
        pNext = pEntry->Flink;

        PCACHE_OBJECT  pCacheObject =
                         CONTAINING_RECORD( pEntry,
                                            CACHE_OBJECT,
                                            MruList );

        if ( pCacheObject->iDemux == RESERVED_DEMUX_PHYSICAL_OPEN_FILE ) {
            pEntry = pNext;
            continue;
        }

        if ( dwServerMask == pCacheObject->dwService ) {

            DeCache( pCacheObject, FALSE );

            IF_DEBUG( CACHE) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Throwing out object ( %08x) due to manual flush\n",
                            pCacheObject));
            }
        }

        pEntry = pNext;
    }

    LeaveCriticalSection( &CacheTable.CriticalSection );

    return TRUE;
} // TsCacheFlush

BOOL
TsCacheFlushUser(
    IN  HANDLE      hUserToken,
    IN  BOOL        fDefer
    )
/*++

  Routine Description:

    This function flushes all file handles associated the passed user context

  Arguments:

    hUserToken - User token to flush from the cache
    fDefer - Build list but close handles later in worker thread (Not supported)

--*/
{
    LIST_ENTRY * pEntry;
    LIST_ENTRY * pNext;

    ASSERT( !fDefer );

    EnterCriticalSection( &CacheTable.CriticalSection );

    for ( pEntry =  CacheTable.MruList.Flink;
          pEntry != &CacheTable.MruList;
        )
    {
        pNext = pEntry->Flink;

        PCACHE_OBJECT  pCacheObject = CONTAINING_RECORD( pEntry,
                                                         CACHE_OBJECT,
                                                         MruList );

        ASSERT( pCacheObject->Signature == CACHE_OBJ_SIGNATURE );

        if ( pCacheObject->iDemux == RESERVED_DEMUX_PHYSICAL_OPEN_FILE ) {
            pEntry = pNext;
            continue;
        }

        //
        //  Find all occurrences of the matching user token in the cache and
        //  decache them
        //

        if ( pCacheObject->iDemux == RESERVED_DEMUX_OPEN_FILE &&
             ((TS_OPEN_FILE_INFO *)(pCacheObject->pbhBlob + 1))->
                 QueryOpeningUser() == hUserToken )
        {
            DeCache( pCacheObject, FALSE );

            IF_DEBUG( CACHE) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Throwing out object ( %08x) due to user token flush\n",
                            pCacheObject));
            }
        }
        else if ( pCacheObject->iDemux == RESERVED_DEMUX_DIRECTORY_LISTING &&
                    ((TS_DIRECTORY_HEADER *)(pCacheObject->pbhBlob + 1))->
                            QueryListingUser() == hUserToken )
        {
            DeCache( pCacheObject, FALSE );

            IF_DEBUG( CACHE) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Throwing out object ( %08x) due to user token flush\n",
                            pCacheObject));
            }
        }
        else if ( (pCacheObject->hLastSuccessAccessToken == hUserToken) )
        {
            //
            // If security descriptor is present, simply cancel Last successful access token
            // otherwise must decache cache object, as security check are entirely dependent
            // on last successful access token in this case
            //

            if ( pCacheObject->pSecDesc )
            {
                pCacheObject->hLastSuccessAccessToken = NULL;
            }
            else
            {
                DeCache( pCacheObject, FALSE );

                IF_DEBUG( CACHE) {

                    DBGPRINTF( ( DBG_CONTEXT,
                                " Throwing out object ( %08x) due to user token flush\n",
                                pCacheObject));
                }
            }
        }

        pEntry = pNext;
    }

    LeaveCriticalSection( &CacheTable.CriticalSection );

    return TRUE;
} // TsCacheFlushUser

BOOL
TsCacheFlushDemux(
    IN ULONG            iDemux
    )
/*++

  Routine Description:

    Flush all cache items whose demultiplexor matches that specified.

  Arguments:

    iDemux - Value of demux whose cache items are to be flushed.

--*/
{
    LIST_ENTRY * pEntry;
    LIST_ENTRY * pNext;

    EnterCriticalSection( &CacheTable.CriticalSection );

    for ( pEntry =  CacheTable.MruList.Flink;
          pEntry != &CacheTable.MruList;
        )
    {
        pNext = pEntry->Flink;

        PCACHE_OBJECT  pCacheObject = CONTAINING_RECORD( pEntry,
                                                         CACHE_OBJECT,
                                                         MruList );

        ASSERT( pCacheObject->Signature == CACHE_OBJ_SIGNATURE );

        if ( pCacheObject->iDemux == iDemux )
        {
            DeCache( pCacheObject, FALSE );

            IF_DEBUG( CACHE) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Throwing out object ( %08x) due to demux flush\n",
                            pCacheObject));
            }
        }

        pEntry = pNext;
    }

    LeaveCriticalSection( &CacheTable.CriticalSection );

    return TRUE;
} // TsCacheFlushDemux


VOID
TsFlushURL(
    IN const TSVC_CACHE             &TSvcCache,
    IN      PCSTR                   pszURL,
    IN      DWORD                   dwURLLength,
    IN      ULONG                   iDemultiplexor
    )
/*++

  Routine Description:

    This routine takes as input a URL and removes from the cache all cached
    objects that have the input URL as their prefix. This is mostly called
    when we get a change notify for metadata.

  Arguments

    TSvcCache               - Service cache
    pszURL                  - The URL prefix to be flushed.
    iDemultiplexor          - The demultiplexor for the caller's entries.

  Returns

    Nothing

--*/
{
    PLIST_ENTRY             pEntry;
    LIST_ENTRY              ListHead;
    PCACHE_OBJECT           pCacheObject;
    BOOL                    bIsRoot;

    // The basic algorithm is to lock the cache table, then walk the cache
    // table looking for matches and decaching those. This could get
    // expensive if the table is big and this routine is called frequently -
    // in that case we may need to schedule the decaches for later, or
    // periodically free and reaquire the critical section.


    InitializeListHead( &ListHead );

    if (!memcmp(pszURL, "/", sizeof("/")))
    {
        bIsRoot = TRUE;
    }
    else
    {
        bIsRoot = FALSE;
    }

    EnterCriticalSection( &CacheTable.CriticalSection );

    pEntry =  CacheTable.MruList.Flink;

    while (pEntry != &CacheTable.MruList)
    {
        pCacheObject = CONTAINING_RECORD( pEntry, CACHE_OBJECT, MruList );
        ASSERT( pCacheObject->Signature == CACHE_OBJ_SIGNATURE );
        pEntry = pEntry->Flink;

        // Check this cache object to see if it matches.
        if ( pCacheObject->iDemux == iDemultiplexor &&
             ( iDemultiplexor == RESERVED_DEMUX_PHYSICAL_OPEN_FILE ||
               ( pCacheObject->dwService == TSvcCache.GetServiceId() &&
                 pCacheObject->dwInstance == TSvcCache.GetInstanceId() ) ) &&
             (bIsRoot ? TRUE : (
                !_strnicmp( pCacheObject->szPath, pszURL, dwURLLength) &&
                    (pCacheObject->szPath[dwURLLength] == '/' ||
                    pCacheObject->szPath[dwURLLength] == '\0')))
            )
        {

            DeCacheHelper(
                pCacheObject,
                &ListHead,
                &pCacheObject->DirChangeList
                );

            IF_DEBUG( CACHE) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Throwing cache object ( %08x) out of cache because of URL match\n",
                            pCacheObject));
            }
        }

    }

    while( !IsListEmpty( &ListHead ) ) {
        pEntry = RemoveHeadList( &ListHead );
        InitializeListHead( pEntry );
        pCacheObject = CONTAINING_RECORD( pEntry, CACHE_OBJECT, DirChangeList );
        ASSERT( pCacheObject->Signature == CACHE_OBJ_SIGNATURE );
        TsDereferenceCacheObj( pCacheObject, FALSE );
    }

    LeaveCriticalSection( &CacheTable.CriticalSection );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\oplock\cachep.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        cachep.cxx

   Abstract:
        This module contains the internal tsunami caching routines

   Author:
        Murali R. Krishnan    ( MuraliK )     16-Jan-1995

--*/

#include "TsunamiP.Hxx"
#pragma hdrstop

HASH_TYPE
CalculateHashAndLengthOfPathName(
    LPCSTR pszPathName,
    PULONG pcbLength
    )
{
    HASH_TYPE hash = 0;
    CHAR      ch;

    DWORD     start;
    DWORD     index;

    ASSERT( pszPathName != NULL );
    ASSERT( pcbLength != NULL );

    *pcbLength = strlen(pszPathName);

    //
    // hash the last 8 characters
    //

    if ( *pcbLength < 8 ) {
        start = 0;
    } else {
        start = *pcbLength - 8;
    }

    for ( index = start; pszPathName[index] != '\0'; index++ ) {

        //
        // This is an extremely slimey way of getting upper case.
        // Kids, don't try this at home
        // -johnson
        //

        ch = pszPathName[index] & (CHAR)~0x20;

        hash <<= 1;
        hash ^= ch;
        hash <<= 1;
        hash += ch;
    }

    //
    // Multiply by length.  Murali said so.
    //

    return( hash * *pcbLength);

} // CalculateHashAndLengthOfPathName


BOOL
DeCacheHelper(
    PCACHE_OBJECT pCacheObject,
    PLIST_ENTRY   DeferredDerefListHead OPTIONAL,
    PLIST_ENTRY   DeferredDerefListEntry OPTIONAL
    )
{

    LPTS_OPEN_FILE_INFO openFileInfo = NULL;
    PPHYS_OPEN_FILE_INFO physFileInfo;
    PCACHE_OBJECT physCacheObject;
    PBLOB_HEADER blob;

    ASSERT( pCacheObject->Signature == CACHE_OBJ_SIGNATURE );
    TSUNAMI_TRACE( TRACE_CACHE_DECACHE, pCacheObject );

    //
    //  Already decached if not on any cache lists
    //

    if( RemoveCacheObjFromLists( pCacheObject, FALSE ) ) {

        //
        // If this is a URI_INFO or OPEN_FILE object, then mark the
        // corresponding PHYSICAL_OPEN_FILE object as a Zombie.
        //

        blob = pCacheObject->pbhBlob;

        if( blob != NULL ) {
            ASSERT( blob->IsCached );
            ASSERT( blob->pCache == pCacheObject );

            if( pCacheObject->iDemux == RESERVED_DEMUX_URI_INFO ) {

                //
                // Map the blob pointer to a W3_URI_INFO pointer, then
                // extract the TS_OPEN_FILE_INFO pointer.
                //

                openFileInfo = ((PW3_URI_INFO)( blob + 1 ))->pOpenFileInfo;

            } else if( pCacheObject->iDemux == RESERVED_DEMUX_OPEN_FILE ) {

                //
                // Simply map the blob pointer to a TS_OPEN_FILE_INFO
                // pointer.
                //

                openFileInfo = (LPTS_OPEN_FILE_INFO)( blob + 1 );

            }

            if( openFileInfo != NULL ) {

                //
                // OK, we have a TS_OPEN_FILE_INFO pointer. Extract the
                // PHYS_OPEN_FILE_INFO pointer, and mark the containing
                // CACHE_OBJECT as a zombie.
                //

                physFileInfo = openFileInfo->QueryPhysFileInfo();

                if( physFileInfo != NULL ) {
                    ASSERT( physFileInfo->Signature == PHYS_OBJ_SIGNATURE );
                    blob = ((PBLOB_HEADER)physFileInfo) - 1;

                    if( blob->pCache != NULL ) {
                        ASSERT( blob->pCache->Signature == CACHE_OBJ_SIGNATURE );
                        TSUNAMI_TRACE( TRACE_CACHE_ZOMBIE, blob->pCache );

                        IF_DEBUG(OPLOCKS) {
                            DBGPRINTF((
                                DBG_CONTEXT,
                                "Marking cache @ %08lx as zombie\n",
                                blob->pCache
                                ));
                        }

                        blob->pCache->fZombie = TRUE;
                    }
                }

            }

        }

        //
        // This undoes the initial reference.  The last person to check in
        // this cache object will cause it to be deleted after this point.
        //

        if( DeferredDerefListHead == NULL ) {
            ASSERT( DeferredDerefListEntry == NULL );
            TsDereferenceCacheObj( pCacheObject, FALSE );
        } else {
            ASSERT( DeferredDerefListEntry != NULL );
            ASSERT( (ULONG)DeferredDerefListEntry >= (ULONG)pCacheObject );
            ASSERT( (ULONG)DeferredDerefListEntry <=
                ( (ULONG)pCacheObject + sizeof(*pCacheObject) - sizeof(LIST_ENTRY) ) );
            InsertTailList( DeferredDerefListHead, DeferredDerefListEntry );
        }

    }

    return TRUE;

}   // DeCacheHelper


BOOL
DeCache(
    PCACHE_OBJECT pCacheObject,
    BOOL          fLockCacheTable
    )
/*++
    Description:

        This function removes this cache object from any list it may be on.

        The cache table lock must be taken if fLockCacheTable is FALSE.

    Arguments:

        pCacheObject - Object to decache
        fLockCacheTable - FALSE if the cache table lock has already been taken

--*/
{
    LPTS_OPEN_FILE_INFO openFileInfo = NULL;
    PPHYS_OPEN_FILE_INFO physFileInfo;
    PCACHE_OBJECT physCacheObject;
    PBLOB_HEADER blob;

    ASSERT( pCacheObject->Signature == CACHE_OBJ_SIGNATURE );

    if( fLockCacheTable ) {
        EnterCriticalSection( &CacheTable.CriticalSection );
    }

    //
    // Let the helper do the dirty work.
    //

    DeCacheHelper( pCacheObject, NULL, NULL );

    if( fLockCacheTable ) {
        LeaveCriticalSection( &CacheTable.CriticalSection );
    }

    return( TRUE );
}

BOOL
TsDeCacheCachedBlob(
    PVOID   pBlobPayload
    )
/*++
    Description:

        This function removes a blob payload object from the cache

    Arguments:

        pCacheObject - Object to decache

--*/
{
    return DeCache( (((PBLOB_HEADER)pBlobPayload)-1)->pCache, TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\oplock\creatflp.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        creatflp.cxx

   Abstract:
        This module contains internal create file caching routines.

   Author:
        ????

--*/

#include "TsunamiP.Hxx"
#pragma hdrstop

#include <ctype.h>

#include <iistypes.hxx>
#include <iisver.h>
#include <iiscnfg.h>
#include <imd.h>
#include <mb.hxx>

BOOL
DisposeOpenFileInfo(
    IN  PVOID   pvOldBlock
    )
/*++

    Routine Description

        Close open file handles

    Arguments

        pvOldBlock - pointer to the file information block.

    Returns

        TRUE if operation successful.

--*/
{
    LPTS_OPEN_FILE_INFO lpFileInfo;
    PVOID pvBlob;

    IF_DEBUG(OPLOCKS) {
        PBLOB_HEADER pbhBlob;
        PCACHE_OBJECT pCache;

        if (BLOB_IS_OR_WAS_CACHED( pvOldBlock ) ) {
            pbhBlob = (( PBLOB_HEADER )pvOldBlock ) - 1;
            pCache = pbhBlob->pCache;

            DBGPRINTF( (DBG_CONTEXT,"DisposeOpenFileInfo(%s) iDemux=%08lx, cache=%08lx, references=%d\n",
                pCache->szPath, pCache->iDemux, pCache, pCache->references ));
        }
    }

    lpFileInfo = (LPTS_OPEN_FILE_INFO ) pvOldBlock;
    pvBlob = ( PVOID )lpFileInfo->QueryPhysFileInfo();

#ifdef CHICAGO
    if (!(lpFileInfo->m_FileInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        TsCheckInOrFree( pvBlob );
    }
#else

    TsCheckInOrFree( pvBlob );

#endif

    //
    //  The item may never have been added to the cache, don't
    //  count it in this case
    //

    if ( BLOB_IS_OR_WAS_CACHED( pvOldBlock ) ) {

        DEC_COUNTER( BLOB_GET_SVC_ID( pvOldBlock ),
                     CurrentOpenFileHandles );

        if ( BLOB_IS_UNC( pvOldBlock )) {
            InterlockedDecrement( (LONG *) &cCachedUNCHandles );
        }
    }

    return( TRUE );
} // DisposeOpenFileInfo


BOOL
DisposePhysOpenFileInfo(
    IN  PVOID   pvOldBlock
    )
/*++

    Routine Description

        Close open file handles

    Arguments

        pvOldBlock - pointer to the file information block.

    Returns

        TRUE if operation successful.

--*/
{
    PPHYS_OPEN_FILE_INFO lpPhysFileInfo;
    BOOL bSuccess;
    LIST_ENTRY * pEntry;
    PBLOB_HEADER pbhBlob = NULL;
    PCACHE_OBJECT pCache = NULL;

    if (BLOB_IS_OR_WAS_CACHED( pvOldBlock ) ) {
        pbhBlob = (( PBLOB_HEADER )pvOldBlock ) - 1;
        pCache = pbhBlob->pCache;

    }

    IF_DEBUG(OPLOCKS) {
        DBGPRINTF( (DBG_CONTEXT,"DisposePhysOpenFileInfo(%08lx)\n", pvOldBlock ));
        DBGPRINTF( (DBG_CONTEXT,"DisposePhysOpenFileInfo(%s) iDemux=%08lx, cache=%08lx, references=%d\n",
            pCache->szPath, pCache->iDemux, pCache, pCache->references ));
    }

    lpPhysFileInfo = (PPHYS_OPEN_FILE_INFO ) pvOldBlock;
    ASSERT( lpPhysFileInfo->Signature == PHYS_OBJ_SIGNATURE );

    if ( lpPhysFileInfo->abSecurityDescriptor != NULL ) {
        FREE( lpPhysFileInfo->abSecurityDescriptor );
    }

    if ( lpPhysFileInfo->hOpenFile != INVALID_HANDLE_VALUE ) {
        bSuccess = CloseHandle( lpPhysFileInfo->hOpenFile );
        ASSERT( bSuccess );
        lpPhysFileInfo->hOpenFile = INVALID_HANDLE_VALUE;
    }

    if ( lpPhysFileInfo->hOpenEvent != NULL ) {
        bSuccess = CloseHandle( lpPhysFileInfo->hOpenEvent );
        ASSERT( bSuccess );
        lpPhysFileInfo->hOpenEvent = NULL;
    }

    if (!DisableSPUD) {
        EnterCriticalSection( &CacheTable.CriticalSection );
        while ( !IsListEmpty( &lpPhysFileInfo->OpenReferenceList ) ) {
            pEntry = RemoveHeadList( &lpPhysFileInfo->OpenReferenceList );
            InitializeListHead( pEntry );
        }
        if( lpPhysFileInfo->pOplock != NULL ) {
            ASSERT( lpPhysFileInfo->pOplock->Signature == OPLOCK_OBJ_SIGNATURE );
            ASSERT( lpPhysFileInfo->pOplock->lpPFInfo == lpPhysFileInfo );
            lpPhysFileInfo->pOplock->lpPFInfo = NULL;
        }
        LeaveCriticalSection( &CacheTable.CriticalSection );
    }

    IF_DEBUG(OPLOCKS) {
        DBGPRINTF( (DBG_CONTEXT,"DisposePhysOpenFileInfo(%s)\n",
            pCache->szPath ));
    }

    lpPhysFileInfo->Signature = PHYS_OBJ_SIGNATURE_X;

    return( TRUE );

} // DisposePhysOpenFileInfo



BOOL
TS_OPEN_FILE_INFO::SetHttpInfo(
    IN PSTR pszInfo,
    IN INT  InfoLength
    )
/*++

    Routine Description

        Set the "Last-Modified:" header field in the file structure.

    Arguments

        pszDate - pointer to the header value to save
        InfoLength - length of the header value to save

    Returns

        TRUE if information was cached,
        FALSE if not cached

--*/
{
    if ( !m_ETagIsWeak && InfoLength < sizeof(m_achHttpInfo)-1 ) {

        CopyMemory( m_achHttpInfo, pszInfo, InfoLength+1 );

        //
        // this MUST be set after updating the array,
        // as this is checked to know if the array content is valid.
        //

        m_cchHttpInfo = InfoLength;
        return TRUE;
    }

    return FALSE;
} // TS_OPEN_FILE_INFO::SetHttpInfo



BOOL
TS_OPEN_FILE_INFO::SetFileInfo(
    IN PPHYS_OPEN_FILE_INFO lpPhysFileInfo,
    IN HANDLE   hOpeningUser,
    IN BOOL     fAtRoot,
    IN DWORD    cbSecDescMaxCacheSize,
    IN DWORD    dwAttributes
    )
/*++

    Routine Description

        Gets the file information for a handle.

    Arguments

        hFile - Handle of the file to get information on.
        hOpeningUser - HANDLE of user opening the file
        fAtRoot - TRUE if this is the root directory
        cbSecDescMaxCacheSize - size of the memory allocated to
          cache the security descriptor for this file object
        dwAttributes - attributes of the file

    Returns

        TRUE if information was stored.
        FALSE otherwise.

--*/
{
    BOOL fReturn;
    FILETIME    ftNow;
    SYSTEMTIME  stNow;

    if ( lpPhysFileInfo == NULL) {

        SetLastError( ERROR_INVALID_PARAMETER);
        fReturn = FALSE;

    } else if ( lpPhysFileInfo->hOpenFile == BOGUS_WIN95_DIR_HANDLE) {

        ASSERT( lpPhysFileInfo->Signature == PHYS_OBJ_SIGNATURE );
        m_PhysFileInfo = lpPhysFileInfo;
        m_hOpeningUser = NULL;
        m_ETagIsWeak = TRUE;
        m_FileInfo.dwFileAttributes = dwAttributes;
        m_cchETag = 0;
        fReturn = TRUE;

    } else {

        MB      mb( (IMDCOM*) IIS_SERVICE::QueryMDObject()  );
        DWORD   dwChangeNumber;


        ASSERT(dwAttributes == 0);
        ASSERT( lpPhysFileInfo->Signature == PHYS_OBJ_SIGNATURE );

        m_PhysFileInfo = lpPhysFileInfo;
        m_hOpeningUser = hOpeningUser;
        m_ETagIsWeak = TRUE;


        fReturn  = GetFileInformationByHandle(
                                            m_PhysFileInfo->hOpenFile,
                                            &m_FileInfo
                                            );

        dwChangeNumber = 0;

        mb.GetSystemChangeNumber(&dwChangeNumber);

        m_cchETag = FORMAT_ETAG(m_achETag, m_FileInfo.ftLastWriteTime,
                                    dwChangeNumber);

        ::GetSystemTime(&stNow);

        if (::SystemTimeToFileTime((CONST SYSTEMTIME *)&stNow, &ftNow))
        {
            __int64 iNow, iFileTime;

            iNow = (__int64)*(__int64 UNALIGNED *)&ftNow;

            iFileTime =
                (__int64)*(__int64 UNALIGNED *)&m_FileInfo.ftLastWriteTime;

            if ((iNow - iFileTime) > STRONG_ETAG_DELTA )
            {
                m_ETagIsWeak = FALSE;
            }
        }

        *((__int64 UNALIGNED*)&m_CastratedLastWriteTime)
            = (*((__int64 UNALIGNED*)&m_FileInfo.ftLastWriteTime) / 10000000)
              * 10000000;

        //
        //  Turn off the hidden attribute if this is a root directory listing
        //  (root some times has the bit set for no apparent reason)
        //

        if ( fReturn && fAtRoot ) {
            m_FileInfo.dwFileAttributes &= ~FILE_ATTRIBUTE_HIDDEN;
        }
        m_PhysFileInfo->cbSecDescMaxSize = cbSecDescMaxCacheSize;

    }

    return ( fReturn);
} // TS_OPEN_FILE_INFO::SetFileInfo()


VOID
TS_OPEN_FILE_INFO::MakeStrongETag(
    VOID
    )
/*++

    Routine Description

        Try and make an ETag 'strong'. To do this we see if the difference
        between now and the last modified date is greater than our strong ETag
        delta - if so, we mark the ETag strong.

    Arguments

        None.

    Returns

        Nothing.

--*/
{
    FILETIME                    ftNow;
    SYSTEMTIME                  stNow;
    __int64                     iNow, iFileTime;

    if ( m_PhysFileInfo == NULL || m_PhysFileInfo->hOpenFile == INVALID_HANDLE_VALUE)
    {
        return;
    }

    ::GetSystemTime(&stNow);

    if (::SystemTimeToFileTime((CONST SYSTEMTIME *)&stNow, &ftNow))
    {

        iNow = (__int64)*(__int64 UNALIGNED *)&ftNow;

        iFileTime = (__int64)*(__int64 UNALIGNED *)&m_FileInfo.ftLastWriteTime;

        if ((iNow - iFileTime) > STRONG_ETAG_DELTA )
        {
            m_ETagIsWeak = FALSE;
        }
    }
}

#if DBG
VOID
TS_OPEN_FILE_INFO::Print( VOID) const
{
    char rgchDbg[300];

    wsprintf(rgchDbg,
             "TS_OPEN_FILE_INFO( %08x). FileHandle = %08x."
             " Opening User = %08x.\n",
             this,
             QueryFileHandle(),
             QueryOpeningUser()
             );

    OutputDebugString( rgchDbg);

    return;
} // TS_OPEN_FILE_INFO::Print()

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\virtroot.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

       virtroot.cxx

   Abstract:

       This module defines functions for managing virtual roots.

   Author:

      ???                  ( ???)      ??-??-1994/5

   Environment:

      User Mode -- Win32
   Project:

       TSunami DLL for Internet Services

   Functions Exported:



   Revision History:

       MuraliK         Added File System type to information stored about
                          each virtual root.
       MuraliK         Modified TsLookupVirtualRoot() to support variable
                          length buffer and hence check for invalid writes

       MuraliK    22-Jan-1996  Cache & return UNC virtual root impersonation
                                   token.
--*/



/************************************************************
 *     Include Headers
 ************************************************************/

#include "TsunamiP.Hxx"
#pragma hdrstop

#include <mbstring.h>
#include <rpc.h>
#include <rpcndr.h>
#include "dbgutil.h"
#include <string.h>
#include <refb.hxx>
#include <imd.h>
#include <mb.hxx>
#include <iiscnfg.h>


IIS_VROOT_TABLE::IIS_VROOT_TABLE(
                            VOID
                            )
:
    m_nVroots           (0 )
{
    InitializeCriticalSection( &m_csLock );
    InitializeListHead( &m_vrootListHead );

} // IIS_VROOT_TABLE::IIS_VROOT_TABLE



IIS_VROOT_TABLE::~IIS_VROOT_TABLE(
                            VOID
                            )
{
    RemoveVirtualRoots( );
    DeleteCriticalSection( &m_csLock );

    DBG_ASSERT( m_nVroots == 0 );
    DBG_ASSERT( IsListEmpty( &m_vrootListHead ) );

} // IIS_VROOT_TABLE::~IIS_VROOT_TABLE




BOOL
IIS_VROOT_TABLE::AddVirtualRoot(
    PCHAR                  pszRoot,
    PCHAR                  pszDirectory,
    DWORD                  dwAccessMask,
    PCHAR                  pszAccountName,
    HANDLE                 hImpersonationToken,
    DWORD                  dwFileSystem
    )
/*++
    Description:

        This function adds a symbolic link root and directory mapping
        part to the virtual root list

        We always strip trailing slashes from the root and directory name.

        If the root is "\" or "/", then the effective root will be zero
        length and will always be placed last in the list.  Thus if a lookup
        can't find a match, it will always match the last entry.

    Arguments:
        pszRoot - Virtual symbolic link root
        pszDirectory - Physical directory
        dwAccessMask - Type of access allowed on this virtual root
        pszAccountName - User name to impersonate if UNC (only gets stored
            for RPC apis)
        hImpersonationToken - Impersonation token to use for UNC
                                directory paths
        dwFileSystem - DWORD containing the file system type
                      ( symbolic constant)

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    PVIRTUAL_ROOT_MAPPING   pVrm, pVrmOld;
    PDIRECTORY_CACHING_INFO pDci;
    PLIST_ENTRY             pEntry;
    BOOL                    fRet = FALSE;
    BOOL                    fUNC;
    DWORD                   cchRoot;

    if ( !pszRoot || !*pszRoot || !pszDirectory || !*pszDirectory )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    //  Disallow allow UNC roots if we don't have an impersonation token and
    //  this isn't a placeholder
    //

    fUNC = (BOOL)((pszDirectory[0] == '\\') && (pszDirectory[1] == '\\'));

    //
    //  Strip the trailing '/' from the virtual root
    //

    cchRoot = strlen( pszRoot );

    if ( IS_CHAR_TERM_A( pszRoot, cchRoot - 1))
    {
        pszRoot[--cchRoot] = '\0';
    }

    //
    //  Look in the current list and see if the root is already there.
    //  If the directory is the same, we just return success.  If the
    //  directory is different, we remove the old item and add the new one.
    //

    LockTable();

    for ( pEntry =  m_vrootListHead.Flink;
          pEntry != &m_vrootListHead;
          pEntry =  pEntry->Flink )
    {
        pVrm = CONTAINING_RECORD( pEntry, VIRTUAL_ROOT_MAPPING, TableListEntry );

        //
        //  If we have a match up to the length of the previously added root
        //  and the new item is a true match (as opposed to a matching prefix)
        //  and the matching item isn't the default root (which matches against
        //  everything cause it's zero length)
        //

        if ( (cchRoot == pVrm->cchRootA)                          &&
            !_mbsnicmp( (PUCHAR)pszRoot, (PUCHAR)pVrm->pszRootA, _mbslen((PUCHAR)pVrm->pszRootA) ) &&
             IS_CHAR_TERM_A( pszRoot, pVrm->cchRootA )            &&
             ((pVrm->cchRootA != 0) || (cchRoot == 0)) )
        {
            if ( !lstrcmpi( pszDirectory, pVrm->pszDirectoryA ) &&
                 IS_CHAR_TERM_A( pszDirectory, pVrm->cchDirectoryA ))
            {
                //
                //  This root is already in the list
                //

                UnlockTable();
                return TRUE;

            } else{

                //
                //  A root is having its directory entry changed
                //

                //
                //  If last item on this dir, need to remove from list(s?),
                //  free dir handle, free memory
                //

                UnlockTable();
                SetLastError( ERROR_NOT_SUPPORTED );
                return FALSE;
            }
        }
    }

    UnlockTable();

    pVrm = ( PVIRTUAL_ROOT_MAPPING )ALLOC( sizeof( VIRTUAL_ROOT_MAPPING ) +
                                           sizeof( DIRECTORY_CACHING_INFO ));
    pDci = ( PDIRECTORY_CACHING_INFO)( pVrm+1 );

    if ( pVrm == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    //
    //  Initialize the new root item
    //

    pVrm->Signature     = VIRT_ROOT_SIGNATURE;
    pVrm->cchRootA      = strlen( pszRoot );
    pVrm->cchDirectoryA = strlen( pszDirectory );
    pVrm->dwFileSystem  = dwFileSystem;
    pVrm->dwAccessMask  = dwAccessMask;

    InitializeListHead(&pVrm->GlobalListEntry);

    pDci->hDirectoryFile      = NULL;
    pDci->fOnSystemNotifyList = FALSE;
    pVrm->fCachingAllowed     = FALSE;
    pVrm->fUNC                = fUNC;
    pVrm->fDeleted            = FALSE;
    pVrm->hImpersonationToken = hImpersonationToken;

    //
    //  Set the initial reference count to 2.  Once when TsRemoveVirtualRoots
    //  is called and once when the Apc completes
    //

    pVrm->cRef                = 2;

    strcpy( pVrm->pszRootA, pszRoot );
    strcpy( pVrm->pszDirectoryA, pszDirectory );
    strcpy( pVrm->pszAccountName, pszAccountName ? pszAccountName : "" );

    //
    //  Strip trailing slashes from the root and directory
    //

    if ( (pVrm->cchRootA != 0) &&
         IS_CHAR_TERM_A( pVrm->pszRootA, pVrm->cchRootA - 1 ))
    {
        pVrm->pszRootA[--pVrm->cchRootA] = '\0';
    }

    if ( IS_CHAR_TERM_A( pVrm->pszDirectoryA, pVrm->cchDirectoryA - 1))
    {
        //
        //  Note we assume virtual directories always begin with a '/...' to
        //  provide the necessary path separator between the root directory
        //  path and the remaining virtual directory
        //

        pVrm->pszDirectoryA[--pVrm->cchDirectoryA] = '\0';
    }

    //
    //  Add the item to the list
    //

    LockTable();

    //
    //  If the root is zero length, then it will match all occurrences so put
    //  it last.  Note this is useful for default root entries (such as "/").
    //

    if ( pVrm->cchRootA == 0  ) {

        //
        //  Roots that specify an address go in front of roots that do not
        //  thus giving precedence to matching roots w/ addresses
        //

        InsertTailList( &m_vrootListHead, &pVrm->TableListEntry );

    } else {

        //
        //  Insert the virtual root in descending length of their
        //  virtual root name, i.e.,
        //
        //    /abc/123, /abc/12, /abc, /a
        //
        //  This ensures matches occur on the longest possible virtual root
        //

        for ( pEntry =  m_vrootListHead.Flink;
              pEntry != &m_vrootListHead;
              pEntry =  pEntry->Flink )
        {
            pVrmOld = CONTAINING_RECORD( pEntry,
                                         VIRTUAL_ROOT_MAPPING,
                                         TableListEntry );

            if ( pVrmOld->cchRootA < pVrm->cchRootA )
            {
                pVrm->TableListEntry.Flink = pEntry;
                pVrm->TableListEntry.Blink = pEntry->Blink;

                pEntry->Blink->Flink = &pVrm->TableListEntry;
                pEntry->Blink        = &pVrm->TableListEntry;

                goto Added;
            }
        }

        //
        //  There aren't any named roots so put this root
        //  at the beginning
        //

        InsertHeadList( &m_vrootListHead, &pVrm->TableListEntry );
    }

Added:

    if ( !(fRet = DcmAddRoot( pVrm ))) {

        RemoveEntryList( &pVrm->TableListEntry );

        UnlockTable();
        goto Failure;
    }

    m_nVroots++;

    UnlockTable();

    IF_DEBUG( VIRTUAL_ROOTS )
        DBGPRINTF(( DBG_CONTEXT,
                    " - %s => %s\n",
                    pVrm->pszRootA,
                    pVrm->pszDirectoryA ));

    return TRUE;

Failure:

    DBGPRINTF(( DBG_CONTEXT,
                " Error %d adding - %s => %s\n",
                GetLastError(),
                pVrm->pszRootA,
                pVrm->pszDirectoryA ));

    FREE( pVrm );

    return fRet;
} // IIS_VROOT_TABLE::AddVirtualRoot



BOOL
IIS_VROOT_TABLE::LookupVirtualRoot(
    IN     const CHAR *       pszVirtPath,
    OUT    CHAR *             pszDirectory,
    IN OUT LPDWORD            lpcbSize,
    OUT    LPDWORD            lpdwAccessMask,        // Optional
    OUT    LPDWORD            pcchDirRoot,           // Optional
    OUT    LPDWORD            pcchVRoot,             // Optional
    OUT    HANDLE   *         phImpersonationToken,  // Optional
    OUT    LPDWORD            lpdwFileSystem         // Optional
    )
/*++
    Description:

        This function looks in the map list for the specified root
        and returns the corresponding directory

    Arguments:
        pszVirtPath - Virtual symbolic link path
        pszDirectory - receives Physical directory.
                    This is of the size specified by lpcbSize
        lpcbSize - pointer to DWORD containing the size of buffer pszDirectory
                     On retur contains the number of bytes written
        lpdwAccessMask - The access mask for this root
        pcchDirRoot - Number of characters of the directory this virtual
            root maps to (i.e., /foo/ ==> c:\root, lookup "/foo/bar/abc.htm"
            this value returns the length of "c:\root")
        pcchVRoot - Number of characters that made up the found virtual root
            (i.e., returns the lenght of "/foo/")
        phImpersonationToken - pointer to handle object that will contain
           the handle to be used for impersonation for UNC/secure virtual roots
        lpdwFileSystem - on successful return will contain the file system
                        type for the directory matched with root specified.

    Returns:
        TRUE on success and FALSE if any failure.

    History:
        MuraliK     28-Apr-1995   Improved robustness
        MuraliK     18-Jan-1996   Support imperonstaion token

    Note:
       This function is growing in the number of parameters returned.
       Maybe we should expose the VIRTUAL_ROOT_MAPPING structure
         and return a pointer to this object and allow the callers to
         extract all required pieces of data.

--*/
{
    DWORD dwError = NO_ERROR;
    PVIRTUAL_ROOT_MAPPING   pVrm;
    PLIST_ENTRY             pEntry;

    DBG_ASSERT( pszDirectory != NULL);
    DBG_ASSERT( lpcbSize != NULL);

    LockTable();

    for ( pEntry =  m_vrootListHead.Flink;
          pEntry != &m_vrootListHead;
          pEntry =  pEntry->Flink )
    {
        pVrm = CONTAINING_RECORD( pEntry, VIRTUAL_ROOT_MAPPING, TableListEntry );

        ASSERT( pVrm->Signature == VIRT_ROOT_SIGNATURE );

        //
        //  If the virtual paths match and (the addresses match
        //  or this is a global address for this service)
        //

        if ( !_mbsnicmp( (PUCHAR)pszVirtPath,
                         (PUCHAR)pVrm->pszRootA,
                         _mbslen( (PUCHAR)pVrm->pszRootA ) ) &&
            IS_CHAR_TERM_A( pszVirtPath, pVrm->cchRootA ) )
        {
            //
            //  we found a match. return all requested parameters.
            //

            DWORD cbReqd = ( pVrm->cchDirectoryA +
                            strlen(pszVirtPath + pVrm->cchRootA));

            if ( cbReqd <= *lpcbSize) {

                PCHAR pathStart = pszDirectory + pVrm->cchDirectoryA;

                //
                //  Copy the physical directory base then append the rest of
                //  the non-matching virtual path
                //

                CopyMemory(
                    pszDirectory,
                    pVrm->pszDirectoryA,
                    pVrm->cchDirectoryA
                    );

                strcpy( pathStart,
                        pszVirtPath + pVrm->cchRootA );

                if ( lpdwFileSystem != NULL) {
                    *lpdwFileSystem = pVrm->dwFileSystem;
                }

                if ( pcchDirRoot ) {
                    *pcchDirRoot = pVrm->cchDirectoryA;
                }

                if ( pcchVRoot ) {
                    *pcchVRoot = pVrm->cchRootA;
                }

                if ( lpdwAccessMask != NULL) {
                    *lpdwAccessMask = pVrm->dwAccessMask;
                }

                if ( phImpersonationToken != NULL) {

                    // Should we increment refcount of the impersonation token?
                    *phImpersonationToken = pVrm->hImpersonationToken;
                }

                UnlockTable();
                FlipSlashes( pathStart );
                *lpcbSize = cbReqd;
                return(TRUE);

            } else {

                dwError = ERROR_INSUFFICIENT_BUFFER;
            }

            *lpcbSize = cbReqd;
            break;
        }
    } // for

    UnlockTable();

    if ( lpdwAccessMask ) {
        *lpdwAccessMask = 0;
    }

    if ( lpdwFileSystem != NULL) {
        *lpdwFileSystem  = FS_ERROR;
    }

    if ( phImpersonationToken != NULL) {
        *phImpersonationToken = NULL;
    }

    if ( dwError == NO_ERROR) {
        dwError = ERROR_PATH_NOT_FOUND;
    }
    SetLastError( dwError );

    return FALSE;
} // IIS_VROOT_TABLE::LookupVirtualRoot



BOOL
IIS_VROOT_TABLE::RemoveVirtualRoots(
    VOID
    )
/*++
    Description:

        Removes all of the virtual roots for the instance

    Arguments:
        None.

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{

    PVIRTUAL_ROOT_MAPPING   pVrm;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pEntryFile;
    PLIST_ENTRY             pNextEntry;
    PCACHE_OBJECT           pCache;
    PDIRECTORY_CACHING_INFO pDci;
    BOOL                    bSuccess;

    //
    //  If both locks are going to be taken, taken the cache table lock first
    //  to avoid deadlock with the change notification thread.
    //
    //  Note the table lock (m_csLock) needs to be taken before the
    //  csVirtualRoots lock.  We must take csVirtualRoots lock to synchronize
    //  with the ChangeWaitThread().
    //

    EnterCriticalSection( &CacheTable.CriticalSection );
    LockTable();
    EnterCriticalSection( &csVirtualRoots );

    for ( pEntry =  m_vrootListHead.Flink;
          pEntry != &m_vrootListHead;
          pEntry =  pEntry->Flink )
    {
        pVrm = CONTAINING_RECORD( pEntry, VIRTUAL_ROOT_MAPPING, TableListEntry );

        ASSERT( pVrm->Signature == VIRT_ROOT_SIGNATURE );

        pDci = (PDIRECTORY_CACHING_INFO) (pVrm + 1);

        if ( pVrm->fCachingAllowed )
        {
            //
            //  Indicate this root is deleted before we close the dir
            //  handle.  When the APC notification of the aborted IO
            //  completes, it will dereference all deleted items
            //

            pVrm->fDeleted = TRUE;

            CLOSE_DIRECTORY_HANDLE( pDci );

            //
            //  Close any open files on this virtual root
            //

            if ( !TsDecacheVroot( pDci ) ) {
                DBGPRINTF(( DBG_CONTEXT,
                            "Warning - TsDecacheVroot failed!\n" ));
            }
        }
        else
        {
            CLOSE_DIRECTORY_HANDLE( pDci );
        }

        pEntry = pEntry->Blink;

        RemoveEntryList( pEntry->Flink );
        m_nVroots--;

        IF_DEBUG( DIRECTORY_CHANGE )
            DBGPRINTF(( DBG_CONTEXT,
                        "Removing root %s\n",
                        pVrm->pszDirectoryA ));

        //
        // Remove from global list too
        //

        DcmRemoveRoot( pVrm );
        DereferenceRootMapping( pVrm );
    }

    LeaveCriticalSection( &csVirtualRoots );
    UnlockTable();
    LeaveCriticalSection( &CacheTable.CriticalSection );

    return TRUE;
} // TsRemoveVirtualRoots


VOID
DereferenceRootMapping(
        IN OUT PVIRTUAL_ROOT_MAPPING pVrm
        )
{
    if ( !InterlockedDecrement( &pVrm->cRef )) {

        // DBGPRINTF((DBG_CONTEXT,"*** Deleting VRM memory ***\n"));

        //
        // We need to close the impersonation token, if one exists.
        //

        if ( pVrm->hImpersonationToken != NULL) {

            DBG_REQUIRE( CloseHandle( pVrm->hImpersonationToken ));
            pVrm->hImpersonationToken = NULL;
        }

        pVrm->Signature = 0;
        FREE( pVrm );
    }

    return;

} // DereferenceRootMapping



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\oplock\alloc.cxx ===
#include "TsunamiP.Hxx"
#pragma hdrstop


BOOL
TsAllocate(
    IN const TSVC_CACHE &TSvcCache,
    IN      ULONG           cbSize,
    IN OUT  PVOID *         ppvNewBlock
    )
{
    return( TsAllocateEx(  TSvcCache,
                           cbSize,
                           ppvNewBlock,
                           NULL ) );
} // TsAllocate

BOOL
TsAllocateEx(
    IN const TSVC_CACHE &TSvcCache,
    IN      ULONG           cbSize,
    IN OUT  PVOID *         ppvNewBlock,
    OPTIONAL PUSER_FREE_ROUTINE pfnFreeRoutine
    )
/*++

  Routine Description:

      This function allocates a memory block for the calling server.

      The returned block is suitable for use as a parameter to
      TsCacheDirectoryBlob().  Blocks allocated by this function
      must either be cached or freed with TsFree().  Freeing of
      cached blocks will be handled by the cache manager.

  Arguments:

      pServiceInfo - An initialized SERVICE_INFO structure.

      cbSize       - Number of bytes to allocate.  (Must be strictly
                     greater than zero.)

      ppvNewBlock  - Address of a pointer to store the new block's
                     address in.

  Return Value:

      TRUE  - The allocation succeeded, and *ppvNewBlock points to
              at least cbSize accessable bytes.

      FALSE - The allocation failed.

--*/
{
    PBLOB_HEADER pbhNewBlock;

    ASSERT( cbSize > 0 );
    ASSERT( ppvNewBlock != NULL );

    //
    //  Set pbhNewBlock to NULL so that the exception-cleanup code
    //  can test against it to see if an allocation occurred before
    //  the exception.
    //

    pbhNewBlock = NULL;

    __try
    {
        //
        //  If asked to allocate zero bytes, we return FALSE and NULL,
        //  as if allocation failure had occurred.
        //

        if ( cbSize != 0 )
        {
            pbhNewBlock = ( PBLOB_HEADER )
                      ALLOC( cbSize + sizeof( BLOB_HEADER ) );

        }

        if ( pbhNewBlock != NULL )
        {
            //
            //  If the allocation succeeded, we return a pointer to the
            //  memory just following the BLOB_HEADER.
            //

            *ppvNewBlock = ( PVOID )( pbhNewBlock + 1 );

            //
            //  Set up the BLOB_HEADER: Normal flags and stored allocation
            //  size.
            //

            pbhNewBlock->IsCached        = FALSE;
            pbhNewBlock->pfnFreeRoutine  = pfnFreeRoutine;
            InitializeListHead( &pbhNewBlock->PFList );
        }
        else
        {
            //
            //  The allocation failed, and we need to return NULL
            //

            *ppvNewBlock = NULL;
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        //  An exception transpired.  The most likely causes are bogus input
        //  pointers for pServiceInfo and pbhNewBlock.  Whatever the case, we
        //  free up any memory that may have been allocated and return failure.
        //

        if ( pbhNewBlock != NULL )
        {

            FREE( pbhNewBlock );

            pbhNewBlock = NULL;
        }
    }

    //
    //  Return TRUE or FALSE, according to the result of the allocation.
    //

    if ( pbhNewBlock == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return( FALSE );
    }

    INC_COUNTER( TSvcCache.GetServiceId(),
                 CurrentObjects );

    return( TRUE );
} // TsAllocate

BOOL
TsReallocate(
    IN const TSVC_CACHE &TSvcCache,
    IN      ULONG           cbSize,
    IN      PVOID           pvOldBlock,
    IN OUT  PVOID *         ppvNewBlock
    )
/*++

  Routine Description:

    This function will resize a previously allocated memory Blob
    for the calling server, possibly moving it in the process.

  Arguments:

      pServiceInfo - An initialized SERVICE_INFO structure.

      cbSize       - Number of bytes to resize the block to.
                     (Must be strictly greater than zero.)

      pvOldBlock   - Address of a pointer to a previously-allocated
                     block.

      ppvNewBlock  - Address of a pointer to store the new block's
                     address in.  If the allocation fails, NULL is
                     stored here.  Note that in many cases,
                     pvOldBlock will be stored here.

  Return Value:

      TRUE  - The reallocation succeeded, and *ppvNewBlock points to
              at least cbSize accessable bytes.  pvOldBlock is no
              longer a valid pointer, if *ppvNewBlock!=pvOldBlock.

      FALSE - The allocation failed.  *ppvNewBlock = NULL.
              pvOldBlock is still a valid pointer to the block that
              we wished to resize.

--*/
{
    PBLOB_HEADER pbhNewBlock;
    PBLOB_HEADER pbhOldBlock;

    ASSERT( pvOldBlock != NULL );

    //
    //  Set pbhNewBlock to NULL so that the exception-cleanup code
    //  can test against it to see if an allocation occurred before
    //  the exception.
    //

    pbhNewBlock = NULL;

    __try
    {
        //
        //  Adjust the input pointer to refer to the BLOB_HEADER.
        //

        pbhOldBlock = (( PBLOB_HEADER )pvOldBlock ) - 1;

        //
        //  If the Blob is currently cached, we can't move it
        //  or change its size.  Check for this in the Blob's
        //  flags, and fail if it occurs.
        //

        if ( pbhOldBlock->IsCached )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "A service (%d) has attempted to TsRealloc a BLOB that is cached.",
                        TSvcCache.GetServiceId() ));
            BREAKPOINT();
            SetLastError( ERROR_INVALID_PARAMETER );
        }
        else
        {
            //
            //  The following assignment probes ppvNewBlock for writeability.
            //  Hopefully, this ensures that we get an AV from writing to it
            //  before we call REALLOC and potentially free the old block.
            //

            *ppvNewBlock = NULL;

            pbhNewBlock = ( PBLOB_HEADER )REALLOC( pbhOldBlock, cbSize );

            if ( pbhNewBlock != NULL )
            {
                //
                //  Store a pointer to the caller-usable part of the new Blob in
                //  the output parameter.
                //

                *ppvNewBlock = ( PVOID )( pbhNewBlock + 1 );
            }
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        //  An exception occured.  If this was caught after a block was
        //  allocated, we must free the new block.  Unfortunately, this
        //  means that we may end up returning FALSE in a case where
        //  pbhOldBlock is no longer valid.
        //
        //  if ( pbhOldBlock == pbhNewBlock ), which implies the old
        //  pointer is still valid, we do not free the new block, but
        //  hope that the caller will.  In any other case, we must
        //  free the new block to avoid a memory leak, and assume that
        //  TCPSVCs are going down soon...
        //
        //  ISSUE: It might be best to reflect the exception up to the
        //  caller, so they can handle it and bail out of the current
        //  operation.
        //

        if ( pbhNewBlock != NULL && pbhOldBlock != pbhNewBlock )
        {
            FREE( pbhNewBlock );

            pbhNewBlock = NULL;

            SetLastError( ERROR_INVALID_PARAMETER );
        }
    }

    //
    //  Return TRUE or FALSE, according to the result of the allocation.
    //

    if ( pbhNewBlock == NULL )
    {
        return( FALSE );
    }

    return( TRUE );
} // TsReallocate

BOOL
TsFree(
    IN const TSVC_CACHE &TSvcCache,
    IN      PVOID           pvOldBlock
    )
/*++

  Routine Description:

    This function frees a memory block allocated with TsAllocate().

    Blocks that are currently cached cannot be freed with this
    function.

  Arguments:

    pServiceInfo - An initialized SERVICE_INFO structure.

    pvOldBlock   - The address of the block to free.  (Must be
                   non-NULL.)

  Return Value:

    TRUE  - The block was freed.  The pointer pvOldBlock is no longer
            valid.

    FALSE - The block was not freed.  Possible reasons include:

             -  pvOldBlock does not point to a block allocated with
                TsAllocate().

             -  pvOldBlock points to a block that has been cached
                with CacheDirectoryBlob().

             -  pServiceInfo does not point to a valid SERVICE_INFO
                structure.

--*/
{
    BOOLEAN bSuccess;
    PBLOB_HEADER pbhOldBlock;

    ASSERT( pvOldBlock != NULL );

    __try
    {
        //
        //  Adjust the input pointer to refer to the BLOB_HEADER.
        //

        pbhOldBlock = (( PBLOB_HEADER )pvOldBlock ) - 1;

        if (!DisableSPUD) {
            EnterCriticalSection( &CacheTable.CriticalSection );
            if ( !IsListEmpty( &pbhOldBlock->PFList ) ) {
                RemoveEntryList( &pbhOldBlock->PFList );
            }
            LeaveCriticalSection( &CacheTable.CriticalSection );
        }

        //
        //  If the Blob is currently in the cache, we can't free it.
        //  Check for this in the Blob's flags, and fail if it
        //  occurs.
        //

        if ( pbhOldBlock->IsCached )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "A service (%d) has attempted to TsFree a BLOB that it put in the cache.",
                        TSvcCache.GetServiceId() ));
            BREAKPOINT();

            bSuccess = FALSE;
        }
        else
        {
            if ( pbhOldBlock->pfnFreeRoutine )
            {
                bSuccess = pbhOldBlock->pfnFreeRoutine( pvOldBlock );
            }
            else
            {
                bSuccess = TRUE;
            }

            if ( bSuccess )
            {
                //
                //  Free the memory used by the Blob.
                //

                bSuccess = FREE( pbhOldBlock );

                DEC_COUNTER( TSvcCache.GetServiceId(),
                             CurrentObjects );
            }

        }

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        //  Handle exception.  Obviously, it's time to return failure.
        //  It's hardly possible to get here after succefully freeing
        //  the block, so it's likely that an app will either:
        //     - not check the return value and leak some memory.
        //     - check the return value and try again, probably
        //       only to fail forever.
        //
        //  So, it is not advisable for callers to keep trying this
        //  call until it succeeds.
        //

        bSuccess = FALSE;
    }

    return( bSuccess );
} // TsFree


BOOL
TsCheckInOrFree(
    IN      PVOID           pvOldBlock
    )
/*++

  Routine Description:

    This function checks in a cached memory block or
    frees a non-cached memory block allocated with TsAllocate().

  Arguments:

    pServiceInfo - An initialized SERVICE_INFO structure.

    pvOldBlock   - The address of the block to free.  (Must be
                   non-NULL.)

  Return Value:

    TRUE  - The block was freed.  The pointer pvOldBlock is no longer
            valid.

    FALSE - The block was not freed.  Possible reasons include:

             -  pvOldBlock does not point to a block allocated with
                TsAllocate().

--*/
{
    BOOLEAN bSuccess;
    PBLOB_HEADER pbhOldBlock;

    ASSERT( pvOldBlock != NULL );

    __try
    {
        //
        //  Adjust the input pointer to refer to the BLOB_HEADER.
        //

        pbhOldBlock = (( PBLOB_HEADER )pvOldBlock ) - 1;

        if (BLOB_IS_OR_WAS_CACHED(pvOldBlock)) {
            bSuccess = TsCheckInCachedBlob( pvOldBlock );
        } else {
            if (!DisableSPUD) {
                EnterCriticalSection( &CacheTable.CriticalSection );
                if (!IsListEmpty( &pbhOldBlock->PFList ) ) {
                    RemoveEntryList( &pbhOldBlock->PFList );
                }
                LeaveCriticalSection( &CacheTable.CriticalSection );
            }

            if ( pbhOldBlock->pfnFreeRoutine )
            {
                bSuccess = pbhOldBlock->pfnFreeRoutine( pvOldBlock );
            }
            else
            {
                bSuccess = TRUE;
            }

            if ( bSuccess )
            {
                //
                //  Free the memory used by the Blob.
                //

                bSuccess = FREE( pbhOldBlock );
            }
        }

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        //  Handle exception.  Obviously, it's time to return failure.
        //  It's hardly possible to get here after succefully freeing
        //  the block, so it's likely that an app will either:
        //     - not check the return value and leak some memory.
        //     - check the return value and try again, probably
        //       only to fail forever.
        //
        //  So, it is not advisable for callers to keep trying this
        //  call until it succeeds.
        //

        ASSERT(FALSE);
        bSuccess = FALSE;
    }

    return( bSuccess );
} // TsCheckInOrFree
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\oplock\creatfil.cxx ===
/*++

    creatfil.cxx

    Exports API for creating/opening a file, given the filename.
    The file handle and other information are cached for the given user handle.

    History:
        Heath Hunnicutt     ( t-heathh)     ??-??-??

        Murali R. Krishnan  ( MuraliK)      Dec 30, 1994
            Added SetLastError() to set error code as appropriate

        Murali R. Krishnan  ( MuraliK)      Jan 4, 1994
            Added ability to obtain and set the BY_HANDLE_FILE_INFORMATION
             as part of TS_OPEN_FILE_INFO
--*/

#include "TsunamiP.Hxx"
#pragma hdrstop
#include <lonsi.hxx>
#include "auxctrs.h"
#include <dbgutil.h>

#include <iistypes.hxx>
#include <iisver.h>
#include <iiscnfg.h>
#include <imd.h>
#include <mb.hxx>

LONG g_IISCacheAuxCounters[ AacIISCacheMaxCounters];

GENERIC_MAPPING g_gmFile = {
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_ALL_ACCESS
};

dllexp
PSECURITY_DESCRIPTOR
TsGetFileSecDesc(
    LPTS_OPEN_FILE_INFO     pFile
    )
/*++

Routine Description:

    Returns the security descriptor associated to the file
    To be freed using LocalFree()

Arguments:

    pFile - ptr to fie object

Return Value:

    ptr to security descriptor or NULL if error

--*/
{
    SECURITY_INFORMATION    si
            = OWNER_SECURITY_INFORMATION |
            GROUP_SECURITY_INFORMATION |
            DACL_SECURITY_INFORMATION;
    BYTE                    abSecDesc[ SECURITY_DESC_DEFAULT_SIZE ];
    DWORD                   dwSecDescSize;
    PSECURITY_DESCRIPTOR    pAcl;

    if ( GetKernelObjectSecurity(
            pFile->QueryFileHandle(),
            si,
            (PSECURITY_DESCRIPTOR)abSecDesc,
            SECURITY_DESC_DEFAULT_SIZE,
            &dwSecDescSize ) )
    {
        if ( dwSecDescSize > SECURITY_DESC_DEFAULT_SIZE )
        {
            if ( !(pAcl = (PSECURITY_DESCRIPTOR)LocalAlloc( LMEM_FIXED, dwSecDescSize )) )
            {
                return NULL;
            }
            if ( !GetKernelObjectSecurity(
                    pFile->QueryFileHandle(),
                    si,
                    pAcl,
                    dwSecDescSize,
                    &dwSecDescSize ) )
            {
                LocalFree( pAcl );

                return NULL;
            }
        }
        else
        {
            if ( dwSecDescSize = GetSecurityDescriptorLength(abSecDesc) )
            {
                if ( !(pAcl = (PSECURITY_DESCRIPTOR)LocalAlloc( LMEM_FIXED,
                        dwSecDescSize )) )
                {
                    return NULL;
                }
                memcpy( pAcl, abSecDesc, dwSecDescSize );
            }
            else
            {
                //
                // Security descriptor is empty : do not return ptr to security descriptor
                //

                pAcl = NULL;
            }
        }
    }
    else
    {
        pAcl = NULL;
    }

    return pAcl;
}

VOID
TsRemovePhysFile(
    PPHYS_OPEN_FILE_INFO lpPFInfo
    )
{
    PBLOB_HEADER pbhBlob;
    PCACHE_OBJECT cache;
    PCACHE_OBJECT pCacheTmp;
    PCACHE_OBJECT TmpCache;
    BOOL result = FALSE;
    BOOL bSuccess;
    LIST_ENTRY  * pEntry;
    LIST_ENTRY  * pNextEntry;

    IF_DEBUG(OPLOCKS) {
        DBGPRINTF( (DBG_CONTEXT,"TsRemovePhysFile(%08lx) - Entered\n", lpPFInfo ));
    }

    ASSERT( lpPFInfo->Signature == PHYS_OBJ_SIGNATURE );

    pbhBlob = (( PBLOB_HEADER )lpPFInfo ) - 1;
    if ( pbhBlob->IsCached ) {
        cache = pbhBlob->pCache;

        EnterCriticalSection( &CacheTable.CriticalSection );
        EnterCriticalSection( &csVirtualRoots );

        if ( cache->references > 1 ) {

            TsCheckInCachedBlob( (PVOID)lpPFInfo );

        } else {

            for ( pEntry  = CacheTable.MruList.Flink;
                  pEntry != &CacheTable.MruList;
                  pEntry  = pNextEntry ) {

                pNextEntry = pEntry->Flink;

                pCacheTmp = CONTAINING_RECORD( pEntry, CACHE_OBJECT, MruList );

                ASSERT( pCacheTmp->Signature == CACHE_OBJ_SIGNATURE );

                if ( pCacheTmp != cache ) {
                    continue;
                }

                if ( !RemoveCacheObjFromLists( cache, FALSE ) ) {
                    ASSERT( FALSE );
                    continue;
                }

                result = TRUE;

                break;
            }
        }

        LeaveCriticalSection( &csVirtualRoots );
        LeaveCriticalSection( &CacheTable.CriticalSection );

        if ( result ) {
            TsDereferenceCacheObj( cache, TRUE );
        }
    } else {
        if ( pbhBlob->pfnFreeRoutine ) {
            bSuccess = pbhBlob->pfnFreeRoutine( (PVOID)lpPFInfo );
        } else {
            bSuccess = TRUE;
        }

        if ( bSuccess ) {
            //
            //  Free the memory used by the Blob.
            //

            FREE( pbhBlob );
        }
    }

}

dllexp
LPTS_OPEN_FILE_INFO
TsCreateFile(
    IN const TSVC_CACHE     &TSvcCache,
    IN      LPCSTR          pszName,
    IN      HANDLE          OpeningUser,
    IN      DWORD           dwOptions
    )
{
    HANDLE hFile;
    PVOID  pvBlob;
    PPHYS_OPEN_FILE_INFO lpPFInfo;
    LPTS_OPEN_FILE_INFO lpOpenFile;
    POPLOCK_OBJECT lpOplock = NULL;
    BOOL bSuccess;
    BOOL fAtRoot;
    BOOL fImpersonated = FALSE;
    DWORD dwSecDescSize;
    DWORD dwReadN;
    SECURITY_INFORMATION si
            = OWNER_SECURITY_INFORMATION
            | GROUP_SECURITY_INFORMATION
            | DACL_SECURITY_INFORMATION;
    PSECURITY_DESCRIPTOR abSecDesc;
    BOOL fDoReadObjectSecurity;
    BOOL fObjectSecurityPresent;
    BOOL fOplockSucceeded = TRUE;
    SECURITY_ATTRIBUTES sa;
    BOOL fPhysFileCacheHit = FALSE;
    BOOL fNoCanon = (dwOptions & TS_USE_WIN32_CANON) == 0;
    BOOL fAccess;
    DWORD dwGrantedAccess;
    DWORD dwPS;
    DWORD cch;
    DWORD cbPrefix;
    LPCSTR pszPath;
    WCHAR awchPath[MAX_PATH+8+1];
    BYTE psFile[SIZE_PRIVILEGE_SET];
    BOOL fDontUseSpud = (DisableSPUD || !fNoCanon);

    //
    // Mask out options that are not applicable
    //

    dwOptions &= TsValidCreateFileOptions;
    if ( TsIsWindows95() ) {
        dwOptions |= (TS_NO_ACCESS_CHECK | TS_DONT_CACHE_ACCESS_TOKEN);
    }

    //
    //  Have we cached a handle to this file?
    //

    if ( dwOptions & TS_CACHING_DESIRED )
    {

        bSuccess = TsCheckOutCachedBlob(  TSvcCache,
                                           pszName,
                                           RESERVED_DEMUX_OPEN_FILE,
                                           &pvBlob );

        if ( bSuccess )
        {

            ASSERT( BLOB_IS_OR_WAS_CACHED( pvBlob ) );

            //
            // The following is a brutal casting of PVOID to C++ object
            //  Well. there is no way to extract the object clearly from the
            //    memory map :(
            //

            lpOpenFile = (LPTS_OPEN_FILE_INFO )pvBlob;

            //
            //  Make sure the user tokens match
            //

            if ( (OpeningUser == lpOpenFile->QueryOpeningUser()
                    && NULL != lpOpenFile->QueryOpeningUser())
                    || (dwOptions & TS_NO_ACCESS_CHECK) )
            {
                ASSERT ( lpOpenFile->IsValid());

                return( lpOpenFile);
            }

            //
            //  User token doesn't match
            //

            if ( !g_fCacheSecDesc )
            {
                //
                // Check in object, will have to
                // open the file with the new user access token
                //

                bSuccess = TsCheckInCachedBlob( pvBlob );

                ASSERT( bSuccess );
            }
            else
            {
                //
                // attempt to validate access using cached
                // security descriptor
                //

                if ( lpOpenFile->IsSecurityDescriptorValid() )
                {
                    dwPS = sizeof( psFile );
                    ((PRIVILEGE_SET*)&psFile)->PrivilegeCount = 0;

                    if ( !AccessCheck(
                            lpOpenFile->GetSecurityDescriptor(),
                            OpeningUser,
                            FILE_GENERIC_READ,
                            &g_gmFile,
                            (PRIVILEGE_SET*)psFile,
                            &dwPS,
                            &dwGrantedAccess,
                            &fAccess ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                                "[TsCreateFile]: AccessCheck failed, error %d\n",
                                GetLastError() ));

                        fAccess = FALSE;
                    }

                    if ( fAccess )
                    {
                        return( lpOpenFile );
                    }
                }

                //
                // not validated using cached information
                //

                bSuccess = TsCheckInCachedBlob( pvBlob );

                ASSERT( bSuccess );

                if ( lpOpenFile->IsSecurityDescriptorValid() )
                {
                    return( NULL );
                }
            }
        }
    }

    if ( TsIsWindows95() )
    {
        fNoCanon = FALSE;
    }

    sa.nLength              = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle       = FALSE;

    IF_DEBUG(OPLOCKS) {
        DBGPRINTF( (DBG_CONTEXT,"TsCreateFile(%s) - Calling TsCheckOutCachedPhysFile\n", pszName ));
    }

    if (TsCheckOutCachedPhysFile( TSvcCache,
                                  pszName,
                                  (VOID **)&lpPFInfo ) ) {

        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCreateFile(%s) - Already in cache, Waiting!\n", pszName ));
        }

        ASSERT( lpPFInfo->Signature == PHYS_OBJ_SIGNATURE );
        WaitForSingleObject( lpPFInfo->hOpenEvent, (DWORD)(-1) );

        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCreateFile(%s) - Already in cache, Return from Waiting!\n", pszName ));
        }
        fPhysFileCacheHit = TRUE;
        hFile = lpPFInfo->hOpenFile;
        abSecDesc = lpPFInfo->abSecurityDescriptor;
        dwSecDescSize = lpPFInfo->cbSecDescMaxSize;
        fObjectSecurityPresent = TRUE;
        fDoReadObjectSecurity = FALSE;
//        if ( g_fCacheSecDesc ) {
        if ( FALSE ) {

            // attempt to validate access using cached
            // security descriptor
            //

            if ( lpPFInfo->fSecurityDescriptor ) {
                dwPS = sizeof( psFile );
                ((PRIVILEGE_SET*)&psFile)->PrivilegeCount = 0;

                if ( !AccessCheck(
                        abSecDesc,
                        OpeningUser,
                        FILE_GENERIC_READ,
                        &g_gmFile,
                        (PRIVILEGE_SET*)psFile,
                        &dwPS,
                        &dwGrantedAccess,
                        &fAccess ) )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                            "[TsCreateFile]: AccessCheck failed, error %d\n",
                            GetLastError() ));

                    fAccess = FALSE;
                }

                if ( !fAccess )
                {
                    TsCheckInOrFree( (PVOID)lpPFInfo );
                    SetLastError(ERROR_ACCESS_DENIED);
                    return NULL;

                }
            }
        }

    } else {

        if ( lpPFInfo == NULL ) {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }

        ASSERT( lpPFInfo->Signature == PHYS_OBJ_SIGNATURE );

        if ( (dwOptions & TS_NOT_IMPERSONATED) &&
             !(dwOptions & TS_NO_ACCESS_CHECK) )
        {
            if ( !::ImpersonateLoggedOnUser( OpeningUser ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                    "ImpersonateLoggedOnUser[%d] failed with %d\n",
                    OpeningUser, GetLastError()));

                TsRemovePhysFile(lpPFInfo);
                SetLastError(lpPFInfo->dwLastError);
                return NULL;
            }
            fImpersonated = TRUE;
        }

        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCreateFile(%s) - Not in cache, Opening!\n", pszName ));
        }
        fPhysFileCacheHit = FALSE;

        abSecDesc = lpPFInfo->abSecurityDescriptor;
        dwSecDescSize = lpPFInfo->cbSecDescMaxSize;
        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCreateFile(%s) - abSecDesc = %08lx, size = %08lx\n", pszName, abSecDesc, SECURITY_DESC_DEFAULT_SIZE ));
        }

        if ( abSecDesc == NULL ) {
            TsRemovePhysFile(lpPFInfo);
            SetLastError( ERROR_NOT_ENOUGH_MEMORY);
            return( NULL );
        }

        if ( fNoCanon )
        {
            if ( (pszName[0] == '\\') && (pszName[1] == '\\') )
            {
                CopyMemory(
                    awchPath,
                    L"\\\\?\\UNC\\",
                    (sizeof("\\\\?\\UNC\\")-1) * sizeof(WCHAR)
                    );

                cbPrefix = sizeof("\\\\?\\UNC\\")-1;
                pszPath = pszName + sizeof( "\\\\" ) -1;
            }
            else
            {
                CopyMemory(
                    awchPath,
                    L"\\\\?\\",
                    (sizeof("\\\\?\\")-1) * sizeof(WCHAR)
                    );

                cbPrefix = sizeof("\\\\?\\")-1;
                pszPath = pszName;
            }

            cch = MultiByteToWideChar( CP_ACP,
                                       MB_PRECOMPOSED,
                                       pszPath,
                                       -1,
                                       awchPath + cbPrefix,
                                       sizeof(awchPath)/sizeof(WCHAR) - cbPrefix );
            if ( !cch )
            {
                hFile = INVALID_HANDLE_VALUE;
            }
            else
            {
                if ( (pszName[1] == ':') && (pszName[2] == '\0') )
                {
                    wcscat( awchPath, L"\\" );
                }

                sa.nLength              = sizeof(sa);
                sa.lpSecurityDescriptor = NULL;
                sa.bInheritHandle       = FALSE;

                if ( fDontUseSpud ) {
                    hFile = CreateFileW( awchPath,
                                         GENERIC_READ,
                                         TsCreateFileShareMode,
                                         &sa,
                                         OPEN_EXISTING,
                                         TsCreateFileFlags,
                                         NULL );
                } else {

                    lpOplock = CreateOplockObject();

                    if ( lpOplock == NULL ) {
                        DBGPRINTF((DBG_CONTEXT,"LocalAlloc lpOplock[%s] failed with %d\n",
                            pszName, GetLastError()));

                        if ( fImpersonated )
                        {
                            ::RevertToSelf();
                        }

                        return( NULL );
                    }

                    hFile = AtqCreateFileW( awchPath,
                                           TsCreateFileShareMode,
                                           &sa,
                                           TsCreateFileFlags,
                                           si,
                                           (PSECURITY_DESCRIPTOR)abSecDesc,
                                           ( ( g_fCacheSecDesc
                                             && !(dwOptions & TS_NO_ACCESS_CHECK)
                                             && (dwOptions & TS_CACHING_DESIRED) ) ?
                                           SECURITY_DESC_DEFAULT_SIZE : 0 ),
                                           &dwSecDescSize,
                                           OplockCreateFile,
                                           (PVOID)lpOplock );
                }
            }
        }
        else
        {
            hFile = CreateFile(  pszName,
                                 GENERIC_READ,
                                 TsCreateFileShareMode,
                                 &sa,
                                 OPEN_EXISTING,
                                 TsCreateFileFlags,
                                 NULL );
        }
    }

    IF_DEBUG(OPLOCKS) {
        DBGPRINTF( (DBG_CONTEXT,"TsCreateFile(%s) - SECURITY_DESC_DEFAULT_SIZE = %08lx, dwSecDescSize = %08lx\n",
        pszName, SECURITY_DESC_DEFAULT_SIZE, dwSecDescSize ));
    }

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        TSUNAMI_TRACE( TRACE_FILE_OPEN_FAILURE, lpOplock );

        DBGPRINTF((DBG_CONTEXT,"CreateFile[%s] failed with %d\n",
            pszName, GetLastError()));


        if ( fImpersonated )
        {
            ::RevertToSelf();
        }

        if ( !fPhysFileCacheHit ) {
            lpPFInfo->dwLastError = GetLastError();
            SetEvent( lpPFInfo->hOpenEvent );
        }

        //
        // Destroy the oplock object if we managed to create one.
        //

        if( lpOplock != NULL ) {
            DestroyOplockObject( lpOplock );
        }

        SetLastError(lpPFInfo->dwLastError);
        TsRemovePhysFile(lpPFInfo);
        return( NULL );
    }

    TSUNAMI_TRACE( TRACE_FILE_OPEN_SUCCESS, lpOplock );

    //
    // determine length of buffer necessary to read
    // security descriptor. If default size sufficient
    // the descriptor will be store in a temporary array,
    // to be copied to the tsunami cache after allocation
    //

    if (!fPhysFileCacheHit) {
        fDoReadObjectSecurity = FALSE;
        fObjectSecurityPresent = FALSE;
    }

    if ( fDontUseSpud ) {

            if ( g_fCacheSecDesc
                    && !(dwOptions & TS_NO_ACCESS_CHECK)
                    && (dwOptions & TS_CACHING_DESIRED) )
            {
                if ( GetKernelObjectSecurity(
                        hFile,
                        si,
                        (PSECURITY_DESCRIPTOR)abSecDesc,
                        SECURITY_DESC_DEFAULT_SIZE,
                        &dwSecDescSize ) )
                {
                    fObjectSecurityPresent = TRUE;
                    lpPFInfo->fSecurityDescriptor = TRUE ;

                    dwSecDescSize = SECURITY_DESC_DEFAULT_SIZE;
                }
                else
                {
                    if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
                         dwSecDescSize > SECURITY_DESC_DEFAULT_SIZE )
                    {
                        // buffer length was too small, compute new length

                        fDoReadObjectSecurity = TRUE;

                        dwSecDescSize = ( (dwSecDescSize + SECURITY_DESC_GRANULARITY - 1)
                              / SECURITY_DESC_GRANULARITY )
                            * SECURITY_DESC_GRANULARITY;
                    }
                    else
                    {
                        dwSecDescSize = 0;
                    }
                }
            }
            else
            {
                dwSecDescSize = 0;
            }
    } else {

        if ( GetLastError() != ERROR_SUCCESS || fPhysFileCacheHit ) {
            fOplockSucceeded = FALSE;
        }
        if ( fPhysFileCacheHit || (dwSecDescSize == SECURITY_DESC_DEFAULT_SIZE ) ) {
                fObjectSecurityPresent = TRUE;
                lpPFInfo->fSecurityDescriptor = TRUE ;
        } else {
            if ( dwSecDescSize > SECURITY_DESC_DEFAULT_SIZE ) {
                fDoReadObjectSecurity = TRUE;

                dwSecDescSize = ( (dwSecDescSize + SECURITY_DESC_GRANULARITY - 1)
                      / SECURITY_DESC_GRANULARITY )
                    * SECURITY_DESC_GRANULARITY;

            } else {
                dwSecDescSize = 0;
            }

        }

    }

    //
    //  Increment the miss count after we've confirmed it's a valid resource
    //

    bSuccess = TsAllocateEx(  TSvcCache,
                            sizeof( TS_OPEN_FILE_INFO ),
                            &pvBlob,
                            DisposeOpenFileInfo );

    if ( !bSuccess )
    {
        if ( fImpersonated )
        {
            ::RevertToSelf();
        }

        lpPFInfo->hOpenFile = INVALID_HANDLE_VALUE;
        if ( !fPhysFileCacheHit ) {
            SetEvent( lpPFInfo->hOpenEvent );
        }

        if( hFile != INVALID_HANDLE_VALUE ) {
            CloseHandle( hFile );
        }

        TsRemovePhysFile(lpPFInfo);
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return( NULL );
    }

    lpOpenFile = (LPTS_OPEN_FILE_INFO)pvBlob;

    if ( !fPhysFileCacheHit ) {
        lpPFInfo->hOpenFile = hFile;
        lpPFInfo->abSecurityDescriptor = abSecDesc;
    }

    if ( !fDontUseSpud && !fPhysFileCacheHit ) {
        if ( fOplockSucceeded ) {
            ASSERT( lpPFInfo->pOplock == NULL );
            lpPFInfo->pOplock = lpOplock;
            ASSERT( lpOplock->lpPFInfo == NULL );
            lpOplock->lpPFInfo = lpPFInfo;
            SetEvent( lpOplock->hOplockInitComplete );
        } else {
            dwOptions &= ~TS_CACHING_DESIRED;
        }
    }

    //
    //  The file must be fully qualified so it must be at least three characters
    //  plus the terminator
    //

    fAtRoot = (pszName[1] == ':' &&
              ((pszName[2] == '\\' && pszName[3] == '\0')
               || (pszName[2] == '\0')) );

    bSuccess = lpOpenFile->SetFileInfo( lpPFInfo,
        (dwOptions & TS_DONT_CACHE_ACCESS_TOKEN) ? NULL : OpeningUser,
        fAtRoot,
        dwSecDescSize );

    if( lpOpenFile != NULL && !DisableSPUD ) {
        CheckForZombieCacheObjs(
            lpPFInfo,               // pPhysFileInfoBlob
            lpOpenFile,             // pOtherCachedBlob
            !fDontUseSpud           // fAddBlobToPhysFileList
            );
    }

    if ( fImpersonated )
    {
        ::RevertToSelf();
        fImpersonated = FALSE;
    }

    //
    // Check if security descriptor to be read.
    // Failure to read it will not make TsCreateFile to fail :
    // security descriptor size may have grown since previous call
    //

    if ( fDoReadObjectSecurity )
    {

        FREE( abSecDesc );
        abSecDesc = (PSECURITY_DESCRIPTOR)ALLOC( dwSecDescSize );
        lpPFInfo->abSecurityDescriptor = abSecDesc;
        bSuccess = lpOpenFile->SetFileInfo( lpPFInfo,
            (dwOptions & TS_DONT_CACHE_ACCESS_TOKEN) ? NULL : OpeningUser,
            fAtRoot,
            dwSecDescSize );

        if ( GetKernelObjectSecurity(
                hFile,
                si,
                lpOpenFile->GetSecurityDescriptor(),
                dwSecDescSize,
                &dwReadN ) )
        {
sec_succ:
                lpOpenFile->SetSecurityDescriptorValid( TRUE );

        }
        else
        {
            ASSERT( GetLastError() != 0 );
        }
    }
    else if ( fObjectSecurityPresent )
    {
        goto sec_succ;
    }

    if ( !bSuccess)
    {

        //
        // Error in setting up the file information.
        //

        if ( hFile != INVALID_HANDLE_VALUE ) {
            bSuccess = CloseHandle( hFile);

            lpPFInfo->hOpenFile = INVALID_HANDLE_VALUE;

            ASSERT(bSuccess);
        }

        if ( !fPhysFileCacheHit ) {
            SetEvent( lpPFInfo->hOpenEvent );
            if ( !fDontUseSpud && fOplockSucceeded ) {
                ASSERT( lpPFInfo->pOplock == NULL );
                lpPFInfo->pOplock = lpOplock;
                ASSERT( lpOplock->lpPFInfo == NULL );
                lpOplock->lpPFInfo = lpPFInfo;
                SetEvent( lpOplock->hOplockInitComplete );
            }
        }

        TsRemovePhysFile(lpPFInfo);
        SetLastError(lpPFInfo->dwLastError);
        return ( NULL);
    }

    //
    //  If this is a UNC connection check and make sure we haven't exceeded
    //  the maximum UNC handles we will cache (SMB FID limits count to 2048)
    //

    if ( !g_fDisableCaching &&
         (dwOptions & TS_CACHING_DESIRED ) &&
         (cCachedUNCHandles < MAX_CACHED_UNC_HANDLES ||
          pszName[1] != '\\') )
    {
        bSuccess = TsCacheDirectoryBlob(  TSvcCache,
                                           pszName,
                                           RESERVED_DEMUX_OPEN_FILE,
                                           pvBlob,
                                           TRUE );

        //
        //  Only count it if we successfully added the item to the
        //  cache
        //

        if ( bSuccess )
        {
            if ( pszName[1] == '\\' )
            {
                InterlockedIncrement( (LONG *) &cCachedUNCHandles );
            }

            INC_COUNTER( TSvcCache.GetServiceId(),
                         CurrentOpenFileHandles );
        }

    }
    else
    {
        //
        //  Too many cached UNC handles, don't cache it.  It would be nice
        //  to do an LRU for these handles but it's probably not generally
        //  worth it
        //

        bSuccess = FALSE;
    }

#if DBG
    if ( !bSuccess )
    {
        ASSERT( !BLOB_IS_OR_WAS_CACHED( pvBlob ) );
    }
    else
    {
        ASSERT( BLOB_IS_OR_WAS_CACHED( pvBlob ) );
    }
#endif
    if ( !fPhysFileCacheHit ) {
        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCreateFile(%s) - Not in cache, Open Complete Causing Event!\n", pszName ));
        }
        SetEvent( lpPFInfo->hOpenEvent );
        if ( !fDontUseSpud && fOplockSucceeded ) {
            ASSERT( lpPFInfo->pOplock == NULL );
            lpPFInfo->pOplock = lpOplock;
            ASSERT( lpOplock->lpPFInfo == NULL );
            lpOplock->lpPFInfo = lpPFInfo;
            SetEvent( lpOplock->hOplockInitComplete );
        }
    } else {
        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCreateFile(%s) - Already in cache, Open Complete!\n", pszName ));
        }
    }
    return( lpOpenFile );

} // TsCreateFile



dllexp
LPTS_OPEN_FILE_INFO
TsCreateFileFromURI(
    IN const TSVC_CACHE     &TSvcCache,
    IN      PW3_URI_INFO    pURIInfo,
    IN      HANDLE          OpeningUser,
    IN      DWORD           dwOptions,
    IN      DWORD           *dwError
    )

/*+++

    TsCreateFileFromURI

    This routine takes a (checked out) URI block and retrieves a file
    handle from it. If the file handle in the URI info block is valid and
    we have the right security for it, we'll use that. Otherwise if it's
    invalid we'll create a valid handle and save it. If it's valid but we
    don't have security for it we'll open a new handle but not cache it.

    Not caching a new handle may become a performance problem in the future
    if authenticated file access becomes common. There are several possible
    solutions to this problem if this occurs. One would be to have a list
    of cached TS_OPEN_FILE_INFO class structures chained off the URI block,
    one for each 'distinct' security class, and then select the best one to
    return. Another would be to have a second level of cache, i.e. put the
    URI blocks in a second hash table and keep one OPEN_FILE_INFO in the
    URI block, looking up other in the other hash table if we need to. Any
    solution would have to exhibit the property of being able to handle
    mapping from a single URI to multiple file handles.

    Arguments:

        TsvcCache   -
        pURIInfo    - A pointer to the URI block from which we're to derive
                        file information.
        OpeningUser - A handle identifying the opening used.
        dwOptions   - A set of options indicating how we're to open the file.

    Returns:

        A pointer to a TS_OPEN_FILE_INFO class structure if we're succesfull,
            or NULL if we're not.
---*/

{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    LPTS_OPEN_FILE_INFO lpOpenFile;
    POPLOCK_OBJECT lpOplock = NULL;
    BOOL fAtRoot;
    BOOL bSuccess;
    PVOID pvBlob;
    PPHYS_OPEN_FILE_INFO lpPFInfo;
    BOOL fImpersonated = FALSE;
    BOOL SPUDdidCall = FALSE;
    DWORD dwSecDescSize;
    BOOL fOplockSucceeded = FALSE;
    SECURITY_INFORMATION si
            = OWNER_SECURITY_INFORMATION
            | GROUP_SECURITY_INFORMATION
            | DACL_SECURITY_INFORMATION;
    SECURITY_ATTRIBUTES sa;
    BOOL fPhysFileCacheHit = FALSE;
    BOOL fNoCanon = (dwOptions & TS_USE_WIN32_CANON) == 0;
    BOOL fAccess;
    DWORD dwGrantedAccess;
    DWORD dwPS;
    DWORD cch;
    DWORD cbPrefix;
    LPCSTR pszPath;
    PCHAR pName;
    DWORD dwInputSize;
    WCHAR awchPath[MAX_PATH+8+1];
    BYTE psFile[SIZE_PRIVILEGE_SET];

    AcIncrement( CacOpenURI);

    ASSERT(pURIInfo != NULL);

    //
    // Mask out options that are not applicable
    //

    dwOptions &= TsValidCreateFileOptions;

    if ( TsIsWindows95() ) {
        dwOptions |= (TS_NO_ACCESS_CHECK | TS_DONT_CACHE_ACCESS_TOKEN);
    }

    *dwError = pURIInfo->dwFileOpenError;

    // Check to see if the open file info is valid. If it is, try to use it.

    if ( pURIInfo->bFileInfoValid )
    {


        // Get the open file info. If it's non-NULL (the file exists)
        // see if we have permission to access it.

        lpOpenFile = pURIInfo->pOpenFileInfo;

        //
        //  Make sure the user tokens match, or that lpOpenFile is NULL.
        //  In the latter case the file doesn't exist - this is a negative
        //  hit.
        //

        if (    ( lpOpenFile == NULL ) ||
                (OpeningUser == lpOpenFile->QueryOpeningUser()
                && lpOpenFile->QueryOpeningUser() != NULL)
                || (dwOptions & TS_NO_ACCESS_CHECK) )
        {

            return( lpOpenFile);
        }

        //
        //  User token doesn't match
        //

        if ( g_fCacheSecDesc )
        {

            //
            // attempt to validate access using cached
            // security descriptor
            //

            if ( lpOpenFile->IsSecurityDescriptorValid() )
            {
                dwPS = sizeof( psFile );
                ((PRIVILEGE_SET*)&psFile)->PrivilegeCount = 0;

                if ( !AccessCheck(
                        lpOpenFile->GetSecurityDescriptor(),
                        OpeningUser,
                        FILE_GENERIC_READ,
                        &g_gmFile,
                        (PRIVILEGE_SET*)psFile,
                        &dwPS,
                        &dwGrantedAccess,
                        &fAccess ) )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                            "[TsCreateFileFromURI]: AccessCheck failed, \
                            error %d\n",
                            GetLastError() ));

                    fAccess = FALSE;
                }

                // See if we have access to the file. If we get here we know
                // we have a valid security descriptor, so if we didn't get
                // access on this check then there's no point in attemptint to
                // open the file.

                if ( fAccess )
                {
                    return( lpOpenFile );
                }
                else
                {
                    *dwError = GetLastError();

                    return NULL;
                }

            }

        }
    }


    // At this point, either the file info in the structure isn't
    // valid, or we're not allowed to cache security descriptors, or
    // the cache descriptor isn't valid. In any of these cases we need
    // to try to open the file. If this succeeds and the file info in the
    // URI block isn't valid, save the newly opened file info there.
    //
    // If we open the file but the file info isn't valid, we'll tag the
    // open file info structure as non cached so that we won't try to
    // check it in later.
    //
    // Since the file info isn't valid, the error we set in *dwError
    // is bad also. All exits from this point on need to make sure to
    // set that to the proper value. We also want to update the cached
    // error in the URI info if we're going to make the file info valid.
    //
    //
    // Now try to open the actual file.
    //

    if ( TsIsWindows95() )
    {
        fNoCanon = FALSE;
    }

    sa.nLength              = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle       = FALSE;

    IF_DEBUG(OPLOCKS) {
        DBGPRINTF( (DBG_CONTEXT,"TsCreateFileFromURI(%s) - Calling TsCheckOutCachedPhysFile\n", pURIInfo->pszName ));
    }

    if (TsCheckOutCachedPhysFile( TSvcCache,
                                  pURIInfo->pszName,
                                  (VOID **)&lpPFInfo ) ) {

        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCreateFileFromURI(%s) - Already in Cache, Waiting!\n", pURIInfo->pszName ));
        }

        ASSERT( lpPFInfo->Signature == PHYS_OBJ_SIGNATURE );
        WaitForSingleObject( lpPFInfo->hOpenEvent, (DWORD)(-1) );

        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCreateFileFromURI(%s) - Already in Cache, Return from Waiting!\n", pURIInfo->pszName ));
        }
        fPhysFileCacheHit = TRUE;
        hFile = lpPFInfo->hOpenFile;
        dwSecDescSize = lpPFInfo->cbSecDescMaxSize;
//        if ( g_fCacheSecDesc )
        if ( FALSE )
        {

            //
            // attempt to validate access using cached
            // security descriptor
            //

            if ( lpPFInfo->fSecurityDescriptor )
            {
                dwPS = sizeof( psFile );
                ((PRIVILEGE_SET*)&psFile)->PrivilegeCount = 0;

                if ( !AccessCheck(
                        lpPFInfo->abSecurityDescriptor,
                        OpeningUser,
                        FILE_GENERIC_READ,
                        &g_gmFile,
                        (PRIVILEGE_SET*)psFile,
                        &dwPS,
                        &dwGrantedAccess,
                        &fAccess ) )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                            "[TsCreateFileFromURI]: AccessCheck failed, \
                            error %d\n",
                            GetLastError() ));

                    fAccess = FALSE;
                }

                // See if we have access to the file. If we get here we know
                // we have a valid security descriptor, so if we didn't get
                // access on this check then there's no point in attemptint to
                // open the file.

                if ( !fAccess )
                {
                    SetLastError(ERROR_ACCESS_DENIED);
                    TsCheckInOrFree( (PVOID)lpPFInfo );
                    return NULL;
                }

            }

        }

    } else {

        if ( lpPFInfo == NULL ) {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }

        ASSERT( lpPFInfo->Signature == PHYS_OBJ_SIGNATURE );

        //
        // If we're not impersonating right now, do that before we try to
        // open the file.
        //

        if ( (dwOptions & TS_NOT_IMPERSONATED) &&
             !(dwOptions & TS_NO_ACCESS_CHECK) )
        {
            if ( !::ImpersonateLoggedOnUser( OpeningUser ) )
            {
                *dwError = GetLastError();

                DBGPRINTF(( DBG_CONTEXT,
                    "ImpersonateLoggedOnUser[%d] failed with %d\n",
                    OpeningUser, *dwError));


                SetEvent( lpPFInfo->hOpenEvent );
                TsRemovePhysFile(lpPFInfo);
                return NULL;
            }

            fImpersonated = TRUE;
        }

        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCreateFileFromURI(%s) - Not in Cache, Opening!\n", pURIInfo->pszName ));
        }
        fPhysFileCacheHit = FALSE;

        dwSecDescSize = lpPFInfo->cbSecDescMaxSize;
        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCreateFileFromURI(%s) - lpPFInfo->abSecurityDescriptor = %08lx, size = %08lx\n", pURIInfo->pszName, lpPFInfo->abSecurityDescriptor, SECURITY_DESC_DEFAULT_SIZE ));
        }

        if ( lpPFInfo->abSecurityDescriptor == NULL ) {
            goto not_enough_memory;
        }


        if ( fNoCanon )
        {
            if ( (pURIInfo->pszName[0] == '\\') && (pURIInfo->pszName[1] == '\\') )
            {
                CopyMemory(
                    awchPath,
                    L"\\\\?\\UNC\\",
                    (sizeof("\\\\?\\UNC\\")-1) * sizeof(WCHAR)
                    );

                cbPrefix = sizeof("\\\\?\\UNC\\")-1;
                pszPath = pURIInfo->pszName + sizeof( "\\\\" ) -1;
            }
            else
            {
                CopyMemory(
                    awchPath,
                    L"\\\\?\\",
                    (sizeof("\\\\?\\")-1) * sizeof(WCHAR)
                    );

                cbPrefix = sizeof("\\\\?\\")-1;
                pszPath = pURIInfo->pszName;
            }

            cch = MultiByteToWideChar( CP_ACP,
                                       MB_PRECOMPOSED,
                                       pszPath,
                                       -1,
                                       awchPath + cbPrefix,
                                       sizeof(awchPath)/sizeof(WCHAR) - cbPrefix );
            if ( !cch )
            {
                hFile = INVALID_HANDLE_VALUE;
            }
            else
            {
                if ( (pURIInfo->pszName[1] == ':') && (pURIInfo->pszName[2] == '\0') )
                {
                    wcscat( awchPath, L"\\" );
                }

                sa.nLength              = sizeof(sa);
                sa.lpSecurityDescriptor = NULL;
                sa.bInheritHandle       = FALSE;

                if ( DisableSPUD ) {
                    hFile = CreateFileW( awchPath,
                                         GENERIC_READ,
                                         TsCreateFileShareMode,
                                         &sa,
                                         OPEN_EXISTING,
                                         TsCreateFileFlags,
                                         NULL );
                } else {

                    if ( g_fCacheSecDesc &&
                         !(dwOptions & TS_NO_ACCESS_CHECK) )
                    {
                        // Assume we can get by with the default size, and just allocate
                        // that.

                        lpOpenFile = ( LPTS_OPEN_FILE_INFO )LocalAlloc(LPTR,
                                                                sizeof(TS_OPEN_FILE_INFO));

                        IF_DEBUG(OPLOCKS) {
                            DBGPRINTF( (DBG_CONTEXT,"TsCreateFileFromURI(%s) - lpOpenFile = %08lx\n", pURIInfo->pszName, lpOpenFile ));
                        }

                        if (lpOpenFile == NULL)
                        {
                            // Couldn't get the memory we needed, so fail.

                            goto not_enough_memory;
                        }

                        lpOpenFile->SetFileInfo( lpPFInfo,
                            (dwOptions & TS_DONT_CACHE_ACCESS_TOKEN) ? NULL : OpeningUser,
                            FALSE,
                            dwSecDescSize );

                    }

                    SPUDdidCall = TRUE;

                    lpOplock = CreateOplockObject();

                    if ( lpOplock == NULL ) {
                        goto not_enough_memory;
                    }

                    hFile = AtqCreateFileW( awchPath,
                                           TsCreateFileShareMode,
                                           &sa,
                                           TsCreateFileFlags,
                                           si,
                                           (PSECURITY_DESCRIPTOR)lpOpenFile->GetSecurityDescriptor(),
                                           ( ( g_fCacheSecDesc
                                             && !(dwOptions & TS_NO_ACCESS_CHECK)) ?
                                           SECURITY_DESC_DEFAULT_SIZE : 0 ),
                                           &dwSecDescSize,
                                           OplockCreateFile,
                                           (PVOID)lpOplock );
                }
            }
        }
        else
        {
            hFile = CreateFile(  pURIInfo->pszName,
                                 GENERIC_READ,
                                 TsCreateFileShareMode,
                                 &sa,
                                 OPEN_EXISTING,
                                 TsCreateFileFlags,
                                 NULL );
        }
    }

    if ( hFile != INVALID_HANDLE_VALUE )
    {
        TSUNAMI_TRACE( TRACE_FILE_OPEN_SUCCESS, lpOplock );

        AcIncrement( AacOpenURIFiles);

        if ( !fPhysFileCacheHit ) {
            lpPFInfo->hOpenFile = hFile;
        }

        //
        // If we're supposed to cache the security descriptor we'll do that
        // now. In order to do this we need to allocate the OPEN_FILE_INFO
        // structure that we'll use.
        //

        if ( DisableSPUD ) {

            if ( g_fCacheSecDesc &&
                 !(dwOptions & TS_NO_ACCESS_CHECK) )
            {
                dwInputSize = SECURITY_DESC_DEFAULT_SIZE;

                // Assume we can get by with the default size, and just allocate
                // that.

                lpOpenFile = ( LPTS_OPEN_FILE_INFO )LocalAlloc(LPTR,
                                                        sizeof(TS_OPEN_FILE_INFO));


                if (lpOpenFile == NULL)
                {
                    // Couldn't get the memory we needed, so fail.

                    goto not_enough_memory;
                }

                lpOpenFile->SetFileInfo( lpPFInfo,
                    (dwOptions & TS_DONT_CACHE_ACCESS_TOKEN) ? NULL : OpeningUser,
                    FALSE,
                    dwSecDescSize );

                // Now loop, reading the security info each time, until we either
                // read it succesfully, are unable to allocate a big enough buffer,
                // or get some error other than buffer too smal.

                for (;;)
                {

                    if ( GetKernelObjectSecurity(
                            hFile,
                            si,
                            (PSECURITY_DESCRIPTOR)lpOpenFile->GetSecurityDescriptor(),
                            dwInputSize,
                            &dwSecDescSize ) )
                    {
                        lpPFInfo->fSecurityDescriptor = TRUE ;
                        break;
                    }

                    // Had some sort of error on the attempt to get the security
                    // descriptor.

                    if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
                    {
                        PSECURITY_DESCRIPTOR TmpSd;

                        // Need a bigger buffer for the descriptor.

                        IF_DEBUG(OPLOCKS) {
                            DBGPRINTF( (DBG_CONTEXT,"TsCreateFileFromURI(%s) - Realloc Security Desc !!!\n", pURIInfo->pszName ));
                        }

                        TmpSd = lpOpenFile->GetSecurityDescriptor();

                        FREE( TmpSd );
                        TmpSd = (PSECURITY_DESCRIPTOR)ALLOC( dwSecDescSize );
                        lpPFInfo->abSecurityDescriptor = TmpSd;

                        if ( TmpSd == NULL )
                        {
                            goto not_enough_memory;
                        }

                        lpOpenFile->SetFileInfo( lpPFInfo,
                            (dwOptions & TS_DONT_CACHE_ACCESS_TOKEN) ? NULL : OpeningUser,
                            FALSE,
                            dwSecDescSize );

                        dwInputSize = dwSecDescSize;

                    } else
                    {
                        // This wasn't too small a buffer, so quit trying.

                        dwSecDescSize = 0;

                        break;

                    }
                }

            } else {

                lpOpenFile = ( LPTS_OPEN_FILE_INFO )LocalAlloc(LPTR,
                                                        sizeof(TS_OPEN_FILE_INFO));


                if (lpOpenFile == NULL)
                {
                    // Couldn't get the memory we needed, so fail.

                    goto not_enough_memory;
                }
                dwSecDescSize = 0;
            }

        } else {

            if ( !fPhysFileCacheHit ) {
                if ( GetLastError() == ERROR_SUCCESS ) {
                    fOplockSucceeded = TRUE;
                }
                if ( g_fCacheSecDesc &&
                     !(dwOptions & TS_NO_ACCESS_CHECK) )
                {
                    dwInputSize = dwSecDescSize;

                    if (dwSecDescSize > SECURITY_DESC_DEFAULT_SIZE ) {

                        PSECURITY_DESCRIPTOR TmpSd;

                        TmpSd = lpOpenFile->GetSecurityDescriptor();

                        FREE( TmpSd );
                        TmpSd = (PSECURITY_DESCRIPTOR)ALLOC( dwSecDescSize );
                        lpPFInfo->abSecurityDescriptor = TmpSd;

                        if ( TmpSd == NULL )
                        {
                            goto not_enough_memory;
                        }

                        lpOpenFile->SetFileInfo( lpPFInfo,
                            (dwOptions & TS_DONT_CACHE_ACCESS_TOKEN) ? NULL : OpeningUser,
                            FALSE,
                            dwSecDescSize );

                        // Now loop, reading the security info each time, until we either
                        // read it succesfully, are unable to allocate a big enough buffer,
                        // or get some error other than buffer too smal.


                        if ( !GetKernelObjectSecurity(
                                hFile,
                                si,
                                (PSECURITY_DESCRIPTOR)lpOpenFile->GetSecurityDescriptor(),
                                dwInputSize,
                                &dwSecDescSize ) )
                        {

                            // Had some sort of error on the attempt to get the security
                            // descriptor.

                            // This wasn't too small a buffer, so quit trying.

                            dwSecDescSize = 0;

                        }
                        lpPFInfo->fSecurityDescriptor = TRUE ;

                    } else {
                        lpPFInfo->fSecurityDescriptor = TRUE ;
                    }

                } else {
                    lpOpenFile = ( LPTS_OPEN_FILE_INFO )LocalAlloc(LPTR,
                                                            sizeof(TS_OPEN_FILE_INFO));

                    IF_DEBUG(OPLOCKS) {
                        DBGPRINTF( (DBG_CONTEXT,"TsCreateFileFromURI(%s) - lpOpenFile = %08lx\n", pURIInfo->pszName, lpOpenFile ));
                    }

                    if (lpOpenFile == NULL)
                    {
                        // Couldn't get the memory we needed, so fail.

                        goto not_enough_memory;
                    }

                }
            } else {
                lpOpenFile = ( LPTS_OPEN_FILE_INFO )LocalAlloc(LPTR,
                                                        sizeof(TS_OPEN_FILE_INFO));

                IF_DEBUG(OPLOCKS) {
                    DBGPRINTF( (DBG_CONTEXT,"TsCreateFileFromURI(%s) - lpOpenFile = %08lx\n", pURIInfo->pszName, lpOpenFile ));
                }

                if (lpOpenFile == NULL)
                {
                    // Couldn't get the memory we needed, so fail.

                    goto not_enough_memory;
                }

            }
        }

        *dwError = ERROR_SUCCESS;
        lpOpenFile->SetCachedFlag(TRUE);

        //
        //  The file must be fully qualified so it must be at least three
        //  characters plus the terminator
        //

        pName = pURIInfo->pszName;

        fAtRoot = (pName[1] == ':' &&
                  ((pName[2] == '\\' && pName[3] == '\0')
                   || (pName[2] == '\0')) );

        bSuccess = lpOpenFile->SetFileInfo( lpPFInfo,
            (dwOptions & TS_DONT_CACHE_ACCESS_TOKEN) ? NULL : OpeningUser,
            fAtRoot,
            dwSecDescSize );

        if ( !bSuccess )
        {
            if ( fImpersonated )
            {
                ::RevertToSelf();
            }
            CloseHandle( hFile );
            AcDecrement( AacOpenURIFiles);

            LocalFree(lpOpenFile);

            *dwError = GetLastError();

            lpPFInfo->hOpenFile = INVALID_HANDLE_VALUE;
            if ( !fPhysFileCacheHit ) {
                SetEvent( lpPFInfo->hOpenEvent );
                if ( !DisableSPUD && fOplockSucceeded ) {
                    ASSERT( lpPFInfo->pOplock == NULL );
                    lpPFInfo->pOplock = lpOplock;
                    ASSERT( lpOplock->lpPFInfo == NULL );
                    lpOplock->lpPFInfo = lpPFInfo;
                    SetEvent( lpOplock->hOplockInitComplete );
                }
            }
            TsRemovePhysFile(lpPFInfo);
            return NULL;
        }

    }
    else
    {

        TSUNAMI_TRACE( TRACE_FILE_OPEN_FAILURE, lpOplock );

        if ( !fPhysFileCacheHit ) {
            lpPFInfo->dwLastError = GetLastError();
        } else {
            SetLastError(lpPFInfo->dwLastError);
        }

        IF_DEBUG(ERROR) {
            DBGPRINTF((DBG_CONTEXT,"Create file[%s] failed with %d\n",
                pURIInfo->pszName, GetLastError()));
        }

        //
        // Couldn't open the file! If the reason we failed was because
        // the file or path didn't exist, cache this information.
        //

        *dwError = GetLastError();

        //
        // Destroy the oplock object if we managed to create one.
        //

        if( lpOplock != NULL ) {
            DestroyOplockObject( lpOplock );
        }

        //
        // if this is win95 (does not support dir opens),
        // do the right thing.
        //

        if ( TsNoDirOpenSupport ) {

            DBG_ASSERT(TsIsWindows95());
            goto no_dir_open_support;
        }

        if (*dwError != ERROR_FILE_NOT_FOUND &&
            *dwError != ERROR_PATH_NOT_FOUND &&
            *dwError != ERROR_INVALID_NAME )
        {

            // Not a 'not found error'. We don't cache those.
            if ( fImpersonated )
            {
                ::RevertToSelf();
            }

            lpPFInfo->hOpenFile = INVALID_HANDLE_VALUE;
            if ( !fPhysFileCacheHit ) {
                SetEvent( lpPFInfo->hOpenEvent );
                if ( !DisableSPUD && fOplockSucceeded ) {
                    ASSERT( lpPFInfo->pOplock == NULL );
                    lpPFInfo->pOplock = lpOplock;
                    ASSERT( lpOplock->lpPFInfo == NULL );
                    lpOplock->lpPFInfo = lpPFInfo;
                    SetEvent( lpOplock->hOplockInitComplete );
                }
            }
            TsRemovePhysFile(lpPFInfo);
            return( NULL );
        }

        // Go ahead and set the file info structure to valid, or try to. We
        // use compare and exchange to handle the race condition where the
        // file is open by someone else, and has been deleted while the handle
        // is still open. but we couldn't use the cached values because of
        // lack of a security descriptor. In this case we could get file not
        // found when the file info in the cached URI block is valid for
        // someone else. We don't want to blindly stomp the information in
        // that case. Note that since the cached pOpenFileInfo field is
        // initialized to NULL, all we need to do is set bFileInfoValid to
        // TRUE.

        if (!pfnInterlockedCompareExchange( (PVOID *)&pURIInfo->bFileInfoValid,
                                         (PVOID)TRUE,
                                         FALSE) )
        {
            // The compare&exchange worked, so we now officially have
            // a negatively cached file. Go ahead and save the error
            // value in the URI info.

            pURIInfo->dwFileOpenError = *dwError;

        }

        if ( !fPhysFileCacheHit ) {
            SetEvent( lpPFInfo->hOpenEvent );
            if ( !DisableSPUD && fOplockSucceeded ) {
                ASSERT( lpPFInfo->pOplock == NULL );
                lpPFInfo->pOplock = lpOplock;
                ASSERT( lpOplock->lpPFInfo == NULL );
                lpOplock->lpPFInfo = lpPFInfo;
                SetEvent( lpOplock->hOplockInitComplete );
            }
        }
        TsRemovePhysFile( lpPFInfo );

        lpOpenFile = NULL;
        return lpOpenFile;

    }

    // We're all done with file operations now, so revert back to who we were.
    if ( fImpersonated )
    {
        ::RevertToSelf();
        fImpersonated = FALSE;
    }

    // OK, at this point we have an LP_OPEN_FILE info, or the file doesn't
    // exist. If the file info in the URI block isn't valid, save this now.

    if ( !pURIInfo->bFileInfoValid )
    {
        PVOID           Temp;

        // Now that we've opened the file, set the information to valid.

        Temp = pfnInterlockedCompareExchange( (PVOID *)&pURIInfo->pOpenFileInfo,
                                           lpOpenFile,
                                           NULL
                                         );
        if ( Temp == NULL )
        {
            // The exchange worked. A few notes are in order: if we're
            // caching a negative hit, we wouldn't have come through
            // this path, we'd have gone through the code above where
            // we do a compate&exchange on bFileInfoValid. There is a
            // race between that code and this - if one thread opens the
            // file, the file is deleted, and another thread fails to
            // open the file we have a race. In that race this code path
            // always wins. Either we get here first and set bFileInfoValid
            // to TRUE so the negative hit cache c&e fails, or the negative
            // c&e succeeds in setting it to TRUE, and then we set the
            // file info pointer to a valid file and set bFileInfo to TRUE
            // also. In either case we end up with bFileInfo at TRUE and
            // a valid pOpenFileInfo pointer. It is possible in this case
            // that the cached file open error will be incorrect, but that's
            // OK because this is valid only when the return from this
            // function is NULL. In any case, this is a transitory state. A
            // change notify should fire shortly after this race and clean
            // all of this mess up.

            pURIInfo->bFileInfoValid = TRUE;

            pURIInfo->dwFileOpenError = ERROR_SUCCESS; // For debugging purposes.

            if ( lpOpenFile != NULL )
            {
                TsIncreaseFileHandleCount( FALSE );
            }
        }
        else
        {

            // The exchange didn't work, which means someone else snuck
            // in and set it to valid while we were doing this. In this
            // case mark our file info as not cached.

            ASSERT(pURIInfo->bFileInfoValid);

            if (lpOpenFile != NULL)
            {
                lpOpenFile->SetCachedFlag(FALSE);
                *dwError = ERROR_SUCCESS;
            }
        }
    }
    else
    {
        // The cached file info is already valid. This could be because of a
        // race and someone else got here first, or it could be because we
        // had a valid cached file before but the security tokens don't match.
        // Either way, mark the open file info as not cached so the handle gets
        // closed when we're done.


        if (lpOpenFile != NULL)
        {
            lpOpenFile->SetCachedFlag(FALSE);
            *dwError = ERROR_SUCCESS;
        }

    }
    SetEvent( pURIInfo->hFileEvent );

    // And now we're done.

    if( lpOpenFile != NULL && !DisableSPUD ) {
        CheckForZombieCacheObjs(
            lpPFInfo,               // pPhysFileInfoBlob
            pURIInfo,               // pOtherCachedBlob
            !fPhysFileCacheHit      // fAddBlobToPhysFileList
            );
    }

    if ( !DisableSPUD && !fPhysFileCacheHit && fOplockSucceeded ) {
        ASSERT( lpPFInfo->pOplock == NULL );
        lpPFInfo->pOplock = lpOplock;
        ASSERT( lpOplock->lpPFInfo == NULL );
        lpOplock->lpPFInfo = lpPFInfo;
        SetEvent( lpOplock->hOplockInitComplete );
    }

    if ( !fPhysFileCacheHit ) {
        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCreateFileFromURI(%s) - Not in Cache, Open Complete Causing Event!\n", pURIInfo->pszName ));
        }
        if ( lpOpenFile != NULL ) {
            SetEvent( lpPFInfo->hOpenEvent );
        }
    } else {
        IF_DEBUG(OPLOCKS) {
            DBGPRINTF( (DBG_CONTEXT,"TsCreateFileFromURI(%s) - In Cache, Open Complete!\n", pURIInfo->pszName ));
        }
    }

    return lpOpenFile;

not_enough_memory:

    if ( fImpersonated )
    {
        ::RevertToSelf();
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle( hFile );
        AcDecrement( AacOpenURIFiles);
    }

    lpPFInfo->hOpenFile = INVALID_HANDLE_VALUE;

    SetLastError( ERROR_NOT_ENOUGH_MEMORY);
    *dwError = ERROR_NOT_ENOUGH_MEMORY;
    return( NULL );

no_dir_open_support:

    //
    // This is to support win95 where opening directories are not
    // allowed.
    //

    DWORD dwAttributes;
    BOOL fDirectory = FALSE;

    if ( fImpersonated ) {
        ::RevertToSelf();
        fImpersonated = FALSE;
    }

    //
    // if this is not a directory, fail it.
    //

    dwAttributes = GetFileAttributes(pURIInfo->pszName);
    if( dwAttributes != (DWORD)-1) {
        if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            fDirectory = TRUE;
        }
    }

    if (!fDirectory) {
        IF_DEBUG(ERROR) {
            DBGPRINTF((DBG_CONTEXT,"Not a directory[%x]. Fail\n",
                    dwAttributes ));
        }
        return( NULL );
    }

    lpOpenFile = (LPTS_OPEN_FILE_INFO)LocalAlloc(LPTR,
                                            sizeof(TS_OPEN_FILE_INFO));

    if (lpOpenFile == NULL) {

        //
        // Couldn't get the memory we needed, so fail.
        //

        DBGPRINTF((DBG_CONTEXT,"Cannot allocate memory for file info[%d]\n",
                   GetLastError()));
        goto not_enough_memory;
    }

    //
    // set properties
    //

    lpPFInfo->hOpenFile = BOGUS_WIN95_DIR_HANDLE;

    lpOpenFile->SetFileInfo(lpPFInfo,
                            NULL,
                            FALSE,
                            0,
                            dwAttributes
                            );

    return lpOpenFile;

} // TsCreateFileFromURI



dllexp
BOOL
TsCloseHandle(
    IN const TSVC_CACHE     &TSvcCache,
    IN LPTS_OPEN_FILE_INFO  lpOpenFile
    )
{
    PVOID pvBlob;
    BOOL bSuccess;

    ASSERT( lpOpenFile != NULL );

    pvBlob = ( PVOID )lpOpenFile;

    bSuccess = TsCheckInOrFree( pvBlob );

    return( bSuccess );
} // TsCloseHandle

dllexp
BOOL
TsCloseURIFile(
    IN LPTS_OPEN_FILE_INFO  lpOpenFile
    )
{

    PVOID pvBlob;

    AcIncrement( CacCloseURI);
    if ( lpOpenFile != NULL ) {

        if ( !lpOpenFile->QueryCachedFlag() )
        {
            // This file isn't actually part of a URI cache block, so
            // close it.


            AcDecrement( AacOpenURIFiles);

            if ( lpOpenFile->QueryFileHandle() != BOGUS_WIN95_DIR_HANDLE ) {
                pvBlob = ( PVOID )lpOpenFile->QueryPhysFileInfo();
                TsCheckInOrFree( pvBlob );
            }

            LocalFree( lpOpenFile);
        }
    }

    return TRUE;

} // TsCloseURIFile

dllexp
BOOL TsCreateETagFromHandle(
    IN      HANDLE          hFile,
    IN      PCHAR           ETag,
    IN      BOOL            *bWeakETag
    )
/*+++

    TsCreateETagFromHandle

    This routine takes a file handle as input, and creates an ETag in
    the supplied buffer for that file handle.

    Arguments:

    hFile           - File handle for which to create an ETag.
    ETag            - Where to store the ETag. This must be long
                        enough to hold the maximum length ETag.
    bWeakETag       - Set to TRUE if the newly created ETag is weak.

    Returns:

        TRUE if we create an ETag, FALSE otherwise.
---*/
{
    BY_HANDLE_FILE_INFORMATION  FileInfo;
    BOOL                        bReturn;
    PUCHAR                      Temp;
    FILETIME                    ftNow;
    SYSTEMTIME                  stNow;
    MB                          mb( (IMDCOM*) IIS_SERVICE::QueryMDObject()  );
    DWORD                       dwChangeNumber;


    bReturn  = GetFileInformationByHandle(
                                    hFile,
                                    &FileInfo
                                    );

    if (!bReturn)
    {
        return FALSE;
    }

    dwChangeNumber = 0;
    mb.GetSystemChangeNumber(&dwChangeNumber);

    FORMAT_ETAG(ETag, FileInfo.ftLastWriteTime, dwChangeNumber );

    ::GetSystemTime(&stNow);

    if (::SystemTimeToFileTime((CONST SYSTEMTIME *)&stNow, &ftNow))
    {
        __int64 iNow, iFileTime;

        iNow = (__int64)*(__int64 UNALIGNED *)&ftNow;

        iFileTime = (__int64)*(__int64 UNALIGNED *)&FileInfo.ftLastWriteTime;

        if ((iNow - iFileTime) > STRONG_ETAG_DELTA )
        {
            *bWeakETag = FALSE;
        }
        else
        {
            *bWeakETag = TRUE;
        }

        return TRUE;
    }

    return FALSE;

}

dllexp
BOOL TsLastWriteTimeFromHandle(
    IN      HANDLE          hFile,
    IN      FILETIME        *tm
    )
/*+++

    TsLastWriteTimeFromHandle

    This routine takes a file handle as input, and returns the last write time
    for that handle.

    Arguments:

    hFile           - File handle for which to get the last write time.
    tm              - Where to return the last write time.

    Returns:

        TRUE if we succeed, FALSE otherwise.
---*/
{
    BY_HANDLE_FILE_INFORMATION  FileInfo;
    BOOL                        bReturn;

    bReturn  = GetFileInformationByHandle(
                                    hFile,
                                    &FileInfo
                                    );

    if (!bReturn)
    {
        return FALSE;
    }

    *tm = FileInfo.ftLastWriteTime;

    return TRUE;
}




const char * g_IISAuxCounterNames[] =
{
    "Aac Open URI Files",
    "Cac Calls to TsOpenURI()",
    "Cac Calls to TsCloseURI()",
    "Max Counters"
};



extern "C"
VOID
TsDumpCacheCounters( OUT CHAR * pchBuffer, IN OUT LPDWORD lpcbBuffer )
{
    DWORD  cb = 0;

    DBG_ASSERT( NULL != lpcbBuffer);

    if ( *lpcbBuffer > 30) {
        cb = wsprintf( pchBuffer, " IIS Cache Aux Counters. <p> <UL>");
    } else {
        cb = 30;
    }

    for ( DWORD i = 0; i < AacIISCacheMaxCounters; i++) {

        if ( *lpcbBuffer > cb + 30) {
            cb += wsprintf( pchBuffer + cb, " <LI> %s  = %d",
                            g_IISAuxCounterNames[i],
                            AcCounter(i));
        } else {
            cb += 30;
        }
    } // for

    if ( *lpcbBuffer > cb + 5) {
        cb += wsprintf( pchBuffer + cb, " </UL> ");
    } else {
        cb += 5;
    }

    *lpcbBuffer = cb;
    return ;
} // TsDumpCacheCounters()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\oplock\tsinit.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        tsinit.cxx

   Abstract:
        This module contains the tsunami initialization code.

   Author:
        Murali R. Krishnan    ( MuraliK )     16-Jan-1995

--*/

#include "TsunamiP.Hxx"

#include <dbgutil.h>
#include <inetsvcs.h>
#pragma hdrstop

#include <iistypes.hxx>
#include <iisver.h>
#include <iiscnfg.h>
#include <imd.h>
#include <mb.hxx>

HANDLE g_hQuit = NULL;
HANDLE g_hNewItem   = NULL;
BOOL g_fW3OnlyNoAuth = FALSE;

extern LONG   g_nTsunamiThreads;

//
// Disables Tsunami Caching
//

BOOL DisableTsunamiCaching = FALSE;

//
// DisableSPUD
//

BOOL DisableSPUD = FALSE;

//
// Allows us to mask the invalid flags
//

DWORD TsValidCreateFileOptions = TS_IIS_VALID_FLAGS;

//
// flags to set on CreateFile
//

DWORD TsCreateFileShareMode = (FILE_SHARE_READ   |
                                FILE_SHARE_WRITE |
                                FILE_SHARE_DELETE);

BOOL  TsNoDirOpenSupport = FALSE;
DWORD TsCreateFileFlags = (FILE_FLAG_SEQUENTIAL_SCAN  |
                           FILE_FLAG_OVERLAPPED       |
                           FILE_FLAG_BACKUP_SEMANTICS );


BOOL
Tsunami_Initialize(
            VOID
            )
/*++

    Description:

        Initializes the tsunami package

    Note: This routine assumes the caller is handling multiple initializers
    and will only call this routine once in a thread safe manner

--*/
{

    HKEY hKey;
    DWORD dwType;
    DWORD nBytes;
    DWORD dwValue;
    DWORD dwMaxFile;
    DWORD err;

#if TSUNAMI_REF_DEBUG
    RefTraceLog = CreateRefTraceLog(
                      1024,             // LogSize
                      0                 // ExtraBytesInHeader
                      );
#endif  // TSUNAMI_REF_DEBUG

    //
    // Initialize global events
    //

    g_hQuit = CreateEvent( NULL, TRUE, FALSE, NULL );
    g_hNewItem   = CreateEvent( NULL, FALSE, FALSE, NULL );

    if ( (g_hQuit == NULL) || (g_hNewItem == NULL) ) {
        goto Failure;
    }

    //
    // Set defaults
    //

    MEMORYSTATUS ms;
    ms.dwLength = sizeof(MEMORYSTATUS);
    GlobalMemoryStatus( &ms );

    //
    // default is 1K files per 32MB of physical memory after the 1st 8MB,
    // minimum INETA_MIN_DEF_FILE_HANDLE
    //

    if ( ms.dwTotalPhys > 8 * 1024 * 1024 )
    {
        dwMaxFile = (ms.dwTotalPhys - 8 * 1024 * 1024) / ( 32 * 1024 );
        if ( dwMaxFile < INETA_MIN_DEF_FILE_HANDLE )
        {
            dwMaxFile = INETA_MIN_DEF_FILE_HANDLE;
        }
    }
    else
    {
        dwMaxFile = INETA_MIN_DEF_FILE_HANDLE;
    }

    //
    // If this is not a NTS, disable tsunami caching by default
    //

    DisableSPUD = !AtqSpudInitialized();


    if ( !TsIsNtServer() ) {
        DisableTsunamiCaching = TRUE;
        DisableSPUD = TRUE;
    }

    //
    // Uncomment the following line to forcibly disable SPUD on all
    // platforms.
    //
    // DisableSPUD = TRUE;
    //

    if ( DisableSPUD ) {
        DbgPrint("DisableCacheOplocks set to TRUE by default.\n");
    } else {
        DbgPrint("DisableCacheOplocks set to FALSE by default.\n");
    }
    //
    // no overlapped i/o in win95.
    //

    if ( TsIsWindows95() ) {
        TsCreateFileFlags = FILE_FLAG_SEQUENTIAL_SCAN;
        TsCreateFileShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
        TsNoDirOpenSupport = TRUE;
        // |FILE_FLAG_BACKUP_SEMANTICS;
    }

    //
    // Read the registry key to see whether tsunami caching is enabled
    //

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                INETA_PARAMETERS_KEY,
                0,
                KEY_READ,
                &hKey
                );

    if ( err == ERROR_SUCCESS ) {

        //
        // This cannot be overridded in win95
        //

        if ( !TsIsWindows95() ) {
            nBytes = sizeof(dwValue);
            err = RegQueryValueEx(
                        hKey,
                        INETA_DISABLE_TSUNAMI_CACHING,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwValue,
                        &nBytes
                        );

            if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
                DisableTsunamiCaching = (BOOL)dwValue;
            }

            nBytes = sizeof(dwValue);
            err = RegQueryValueEx(
                        hKey,
                        INETA_DISABLE_TSUNAMI_SPUD,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwValue,
                        &nBytes
                        );

            if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
                DisableSPUD = (BOOL)dwValue;
                if ( DisableSPUD ) {
                    DbgPrint("DisableCacheOplocks set to TRUE in Registry.\n");
                } else {
                    DbgPrint("DisableCacheOplocks set to FALSE in Registry.\n");
                }
                DbgPrint("The Registry Setting will override the default.\n");
            }
        }

        if ( g_fW3OnlyNoAuth )
        {
            //
            // TODO: investigate is security descriptor caching
            // can be used in the non-SYSTEM account case.
            //

            g_fCacheSecDesc = FALSE;
        }
        else
        {
            //
            // read the enable cache sec desc flag
            //

            nBytes = sizeof(dwValue);
            err = RegQueryValueEx(
                            hKey,
                            INETA_CACHE_USE_ACCESS_CHECK,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &nBytes
                            );

            if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
                g_fCacheSecDesc = !!dwValue;
            }
            else {
                 g_fCacheSecDesc = INETA_DEF_CACHE_USE_ACCESS_CHECK;
            }
        }

        //
        // Read the maximum # of files in cache
        //

        nBytes = sizeof(dwValue);
        if ( RegQueryValueEx(
                            hKey,
                            INETA_MAX_OPEN_FILE,
                            NULL,
                            &dwType,
                            (LPBYTE) &dwValue,
                            &nBytes
                            ) == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            dwMaxFile = dwValue;
        }

        RegCloseKey( hKey );

    }

    //
    // if tsunami caching is disabled, set the flags accordingly
    //

    if ( DisableTsunamiCaching ) {
        g_fDisableCaching = TRUE;
        TsValidCreateFileOptions = TS_PWS_VALID_FLAGS;
        g_fCacheSecDesc = FALSE;
    }

    //
    // Initialize the directory change manager
    //

    if ( !DcmInitialize( ) ) {
        goto Failure;
    }

    //
    // Initialize the tsunami cache manager
    //

    if ( !Cache_Initialize( dwMaxFile )) {
        goto Failure;
    }

    if ( !MetaCache_Initialize() ) {
        goto Failure;
    }
    return( TRUE );

Failure:

    IIS_PRINTF( ( buff, "Tsunami_Initialize() Failed. Error = %d\n",
                GetLastError()));

    if ( g_hQuit )
    {
        CloseHandle( g_hQuit );
        g_hQuit = NULL;
    }

    if ( g_hNewItem )
    {
        CloseHandle( g_hNewItem );
        g_hNewItem = NULL;
    }

    return FALSE;
} // Tsunami_Initialize

VOID
Tsunami_Terminate(
    VOID
    )
/*++
    Description:

        Cleans up the Tsunami package

--*/
{
    DWORD dwResult;

    if ( !SetEvent( g_hQuit ) ) {
        IIS_PRINTF((buff,
                "No Quit event posted for Tsunami. No Cleanup\n"));
        return;
    }

    //
    //  Flush all items from the cache
    //

    TsCacheFlush( 0 );

    //
    //  Synchronize with our thread so we don't leave here before the
    //  thread has finished cleaning up
    //

    if ( g_hChangeWaitThread != NULL ) {
        DBG_REQUIRE( WaitForSingleObject( g_hChangeWaitThread, 20000 ) == WAIT_OBJECT_0 );
        CloseHandle( g_hChangeWaitThread);
    }

    CloseHandle( g_hQuit );
    CloseHandle( g_hNewItem );

    DeleteCriticalSection( &csVirtualRoots );

    MetaCache_Terminate();

#if TSUNAMI_REF_DEBUG
    if( RefTraceLog != NULL ) {
        DestroyRefTraceLog( RefTraceLog );
        RefTraceLog = NULL;
    }
#endif  // TSUNAMI_REF_DEBUG

} // Tsunami_Terminate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\spechash\spechash.cxx ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
      spechash.cxx

   Abstract:
      This module calculates the hash value for SpecWeb96 style file-names
        
   Author:

       Murali R. Krishnan    ( MuraliK )     06-Nov-1997 

   Environment:
       Win32 - User Mode
       
   Project:

       Internet Server Test DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
# include <windows.h>
# include <stdio.h>
# include <stdlib.h>
# include <math.h>

/************************************************************
 *    Functions 
 ************************************************************/



// specifies how many characters we will use for hashing string names
DWORD  g_dwFastHashLength = (16);


//
// Following is the original hash-calculator used by Tsunami cache in
//  IIS 4.0
//
DWORD
CalculateHashAndLengthOfPathName(
    LPCSTR pszPathName,
    PULONG pcbLength
    )
{
    DWORD hash = 0;
    CHAR      ch;

    DWORD     start;
    DWORD     index;

    *pcbLength = strlen(pszPathName);

    //
    // hash the last g_dwFastHashLength characters
    //

    if ( *pcbLength < g_dwFastHashLength ) {
        start = 0;
    } else {
        start = *pcbLength - g_dwFastHashLength;
    }

    for ( index = start; pszPathName[index] != '\0'; index++ ) {

        //
        // This is an extremely slimey way of getting upper case.
        // Kids, don't try this at home
        // -johnson
        //

        ch = pszPathName[index] & (CHAR)~0x20;

        hash <<= 1;
        hash ^= ch;
        hash <<= 1;
        hash += ch;
    }

    //
    // Multiply by length to give additional randomness
    //

    return( hash * *pcbLength);

} // CalculateHashAndLengthOfPathName()




//
// Following is the version of Perfect hash function used inside
//  NTFS for hashing file names - used in NT5
//
DWORD
NTPerfCalcHashAndLengthOfPathName(
    LPCSTR pszPathName,
    PULONG pcbLength
    )
{

    /* default value for "scrambling constant" */
#define FILENAME_STRING_CONVERT_CONSTANT   314159269 
    /* prime number, also used for scrambling  */
#define FILENAME_STRING_PRIME     1000000007   

//
// Compute a hash value for the string which is invairant to case.  The 
// distribution of hash strings should be nearly perfect using the following
// function.  Unless file names become extremely long, say average over 512
// characters, processing all characters is the best way to get perfect
// distribution.
//
// For really long file names a better algorithm could include taking the
// first n plus the last n plus psuedo-random number of characters in the
// middle using the last n has the psuedo-random seed.  Just the cost of 
// calculating a new end point (say last 10 characters) will decrease the
// speed of this function enough to cancel the savings of not using the first
// n-1 characters, so any changes here should be tested for performance.
//
// Leave out the upcase code for now (see sample here).
// todo: Leave in _ch until case issue solved
//_ch = RtlUpcaseUnicodeChar( *_p++ );    and put slash here                

    DWORD hash = 0;
    CHAR      ch;

    LPCSTR    pszScan;
    LPCSTR    pszEnd;

    *pcbLength = strlen(pszPathName);

    pszScan  = pszPathName;
    pszEnd   = pszPathName + *pcbLength;
    
    while ( pszScan < pszEnd) {
        hash = 37 * hash + (unsigned int)((*pszScan++) &  (CHAR)~0x20);
    } // while

    return ( abs(FILENAME_STRING_CONVERT_CONSTANT * hash) % 
             FILENAME_STRING_PRIME);
}  // NTPerfCalcHashAndLengthOfPathName()




DWORD
CalculateVariance( IN LPDWORD prgBinDistribs, IN DWORD nBins, 
                   IN DWORD dwAverage)
{
    //
    // Variance  = Sigma( (X-Avg)^2)/n
    //
    
    DWORD dwVariance = 0;
    LONG  delta;
    DWORD binIndex;

    for ( binIndex = 0; binIndex < nBins; binIndex++) {
        
        delta = (prgBinDistribs[binIndex] - dwAverage);
        dwVariance += (delta * delta);
    } // for binIndex

    return ( dwVariance/nBins);
} // CalculateVariance()



void
PrintBinDistributions( IN LPDWORD prgBinDistribs, IN DWORD nBins)
{
    
    printf( "\n-------------------------------------------------------\n"
            "\n     Hash Value Distributions Calculated  Bins = %d    \n"
            "[Index]  "
            ,
            nBins
            );

    DWORD binIndex;
    DWORD dwAverage = 0;

    // print the header
    for (binIndex = 0; binIndex < 10; binIndex++) {
        printf( "%4d,", binIndex);
    }
        
    for ( binIndex = 0; binIndex < nBins; binIndex++) {

        if ( binIndex %10 == 0) {
            printf( "\n[%5d]  ", binIndex);
        }

        dwAverage += prgBinDistribs[binIndex];
        printf( "%4d,", prgBinDistribs[binIndex]);
    } // for binIndex

    dwAverage /= nBins;

    DWORD dwVariance = CalculateVariance( prgBinDistribs, nBins, dwAverage);

    printf( "\n--------------------------------------------------------\n"
            "\n  Average = %d; Variance = %d; Standard Deviation +/- %8.3g\n"
            "\n--------------------------------------------------------\n"
            ,
            dwAverage,
            dwVariance,
            sqrt( (double ) dwVariance)
            );
    return;
} // PrintBinDistributions()


/* ------------------------------------------------------------
 *  SpecWeb96 file names have following syntax
 *  /spec/dirX/classY_Z
 * where,
 *    X = 0 ... 200
 *    Y = 0, 1, 2, 3
 *    Z = 0 ... 8
 * ------------------------------------------------------------
 */

# define MAX_DIR_INDEX (200)
# define MAX_Y_INDEX   (3)
# define MAX_Z_INDEX   (8)


DWORD g_rgBinDistrib113[114];
DWORD g_rgBinDistrib223[224];


int __cdecl
main(int argc, char * argv[])
{
    DWORD dirIndex;
    DWORD YIndex;
    DWORD ZIndex;
    DWORD index = 0;


    if ( argc > 1 ) {
        g_dwFastHashLength = atoi( argv[1]);
        printf( "Using fast hash-lenght with match for %d suffix chars\n",
                g_dwFastHashLength);
    }

    ZeroMemory( g_rgBinDistrib113, sizeof(g_rgBinDistrib113));
    ZeroMemory( g_rgBinDistrib223, sizeof(g_rgBinDistrib223));


    printf( "\n------------------------------------------------------------\n"
           "\n         Hash Values Calculated                             \n"
           "%6s, %30s, %6s, %8s, %6s, %6s\n",
           "Index",
           "File Name",
           "Len",
           "Hash",
           "Bin113",
           "Bin223"
           );
    for ( dirIndex = 0; dirIndex <= MAX_DIR_INDEX; dirIndex++) {
        
        CHAR  rgchFileName[MAX_PATH];
        DWORD cchDirName;
        
        cchDirName = wsprintf( rgchFileName, "/spec/dir%d/class", dirIndex);

        for ( YIndex = 0; YIndex <= MAX_Y_INDEX; YIndex++) {
            
            for (ZIndex = 0; ZIndex <= MAX_Z_INDEX; ZIndex++) {

                DWORD cchFileName;
                DWORD hashValue;
                DWORD cchPathLen = 0;

                cchFileName = (cchDirName + 
                               wsprintf( rgchFileName + cchDirName,
                                         "%d_%d",
                                         YIndex, ZIndex)
                               );

# ifdef IIS_K2_HASH
                hashValue = CalculateHashAndLengthOfPathName( rgchFileName,
                                                              &cchPathLen
                                                              );
# else 
                hashValue = NTPerfCalcHashAndLengthOfPathName( rgchFileName,
                                                               &cchPathLen);
# endif // IIS_K2_HA

                printf( "[%6d], %30s, %6d, 0x%8X, %6d, %6d\n",
                        index++,
                        rgchFileName,
                        cchPathLen,
                        hashValue,
                        hashValue % 113,  // bin for 113 bins
                        hashValue % 223   // bin for 223 bins
                        );

                g_rgBinDistrib113[hashValue%113] += 1;
                g_rgBinDistrib223[hashValue%223] += 1;
                
            } // for ZIndex

        } // for YIndex

    } // for dirIndex()


    PrintBinDistributions( g_rgBinDistrib113, 113);
    PrintBinDistributions( g_rgBinDistrib223, 223);


    return (0);
} // main()



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\oplock\oplock.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    oplock.cxx

Abstract:

    This module implements the oplock object.

Author:

    Keith Moore (keithmo)       29-Aug-1997
        Split off from the overly huge creatfil.cxx.

Revision History:

--*/


#include "TsunamiP.Hxx"
#pragma hdrstop



POPLOCK_OBJECT
CreateOplockObject(
    VOID
    )

/*++

Routine Description:

    Creates a new oplock object.

Arguments:

    None.

Return Value:

    POPLOCK_OBJECT - Pointer to the newly created object if successful,
        NULL otherwise.

--*/

{

    POPLOCK_OBJECT oplock;
    LPSTR eventName;

    oplock = (POPLOCK_OBJECT)ALLOC( sizeof(*oplock) );

    if( oplock != NULL ) {

        oplock->Signature = OPLOCK_OBJ_SIGNATURE;
        oplock->lpPFInfo = NULL;

        //
        // On checked builds, we'll create a name for our event. The
        // name contains the address of the containing oplock structure
        // and the process ID. This ensures the name should be unique
        // across all processes. (Using a named event makes it easy
        // to search for orphaned oplocks using the handles.exe utility.)
        //
        // On free builds, we'll create an unnamed event.
        //

#if DBG
        CHAR dbgEventName[sizeof("Oplock @ 12345678 PID 1234567890")];

        wsprintf(
            dbgEventName,
            "Oplock @ %08lx PID %lu",
            oplock,
            GetCurrentProcessId()
            );

        eventName = dbgEventName;
#else
        eventName = NULL;
#endif

        oplock->hOplockInitComplete = CreateEvent(
                                          NULL,
                                          TRUE,
                                          FALSE,
                                          eventName
                                          );

        if( oplock->hOplockInitComplete == NULL ) {
            FREE( oplock );
            oplock = NULL;
        } else {
            TSUNAMI_TRACE( TRACE_OPLOCK_CREATE, oplock );
        }

    }

    return oplock;

}   // CreateOplockObject


VOID
DestroyOplockObject(
    IN POPLOCK_OBJECT Oplock
    )

/*++

Routine Description:

    Destroys an oplock object.

Arguments:

    Oplock - The oplock object to destroy.

Return Value:

    None.

--*/

{

    BOOL bSuccess;

    ASSERT( Oplock != NULL );
    ASSERT( Oplock->Signature == OPLOCK_OBJ_SIGNATURE );
    TSUNAMI_TRACE( TRACE_OPLOCK_DESTROY, Oplock );

    bSuccess = CloseHandle( Oplock->hOplockInitComplete );
    ASSERT( bSuccess );

    Oplock->Signature = OPLOCK_OBJ_SIGNATURE_X;
    FREE( Oplock );

}   // DestroyOplockObject


VOID
OplockCreateFile(
    PVOID Context,
    DWORD Status
    )

/*++

Routine Description:

    This routine is called by ATQ after an oplock break notification
    is received. This routine is responsible for flushing the item
    from the open file cache to ensure the file will be closed in
    a timely manner.

Arguments:

    Context - An uninterpreted context value. In reality, this is
        a pointer to an OPLOCK_OBJECT.

    Status - The oplock break status. This will be one of the following
        values:

            OPLOCK_BREAK_NO_OPLOCK - This notification is sent
                immediately if the oplock could not be acquired.
                This typically occurs if the target file is already
                open.

            OPLOCK_BREAK_OPEN -

            OPLOCK_BREAK_CLOSE -

Return Value:

    None.

--*/

{

    POPLOCK_OBJECT lpOplock = (POPLOCK_OBJECT)Context;
    PBLOB_HEADER pbhBlob;
    PCACHE_OBJECT cache;
    PCACHE_OBJECT pCacheTmp;
    PCACHE_OBJECT TmpCache;
    BOOL result = FALSE;
    LIST_ENTRY    ListHead;
    PLIST_ENTRY   pEntry;

    IF_DEBUG(OPLOCKS) {
        DBGPRINTF((
            DBG_CONTEXT,
            "OplockCreateFile(%08lx, %08lx) - Entered\n",
            Context,
            Status
            ));
    }

    ASSERT( lpOplock != NULL );
    ASSERT( lpOplock->Signature == OPLOCK_OBJ_SIGNATURE );

    if( Status != OPLOCK_BREAK_NO_OPLOCK ) {
        DWORD waitResult;

        while( TRUE ) {
            waitResult = WaitForSingleObject(
                             lpOplock->hOplockInitComplete,
                             1000
                             );

            if( waitResult == WAIT_OBJECT_0 ) {
                break;
            }

            ASSERT( waitResult == WAIT_TIMEOUT );

            DBGPRINTF((
                DBG_CONTEXT,
                "Rewaiting on oplock @ %08lx\n",
                lpOplock
                ));
        }
    }

    EnterCriticalSection( &CacheTable.CriticalSection );
    EnterCriticalSection( &csVirtualRoots );

    if( lpOplock->lpPFInfo == NULL ) {
        TSUNAMI_TRACE( TRACE_OPLOCK_FAILURE, lpOplock );
    } else {
        ASSERT( lpOplock->lpPFInfo->Signature == PHYS_OBJ_SIGNATURE );
        ASSERT( lpOplock->lpPFInfo->pOplock == lpOplock );
        lpOplock->lpPFInfo->pOplock = NULL;

        TSUNAMI_TRACE( TRACE_OPLOCK_BREAK, lpOplock );
        pbhBlob = (( PBLOB_HEADER )lpOplock->lpPFInfo ) - 1;
        if( pbhBlob->IsCached ) {
            cache = pbhBlob->pCache;
            TSUNAMI_TRACE( TRACE_CACHE_BREAK, cache );

            InitializeListHead( &ListHead );

            for( pEntry  = CacheTable.MruList.Flink;
                 pEntry != &CacheTable.MruList;
                 pEntry  = pEntry->Flink ) {

                pCacheTmp = CONTAINING_RECORD( pEntry, CACHE_OBJECT, MruList );

                ASSERT( pCacheTmp->Signature == CACHE_OBJ_SIGNATURE );

                if( pCacheTmp != cache ) {
                    continue;
                }

                result = TRUE;

                while( !IsListEmpty( &lpOplock->lpPFInfo->OpenReferenceList ) ) {
                    pEntry = RemoveHeadList( &lpOplock->lpPFInfo->OpenReferenceList );
                    InitializeListHead( pEntry );

                    pbhBlob = CONTAINING_RECORD( pEntry, BLOB_HEADER, PFList );
                    TmpCache = pbhBlob->pCache;

                    if( !RemoveCacheObjFromLists( TmpCache, FALSE ) ) {
                        IF_DEBUG(OPLOCKS) {
                            DBGPRINTF((
                                DBG_CONTEXT,
                                "OplockCreateFile(%08lx, %08lx, %08lx) - Error Processing Open Reference %08lx\n",
                                Context,
                                Status,
                                pEntry,
                                TmpCache
                                ));
                        }

                        continue;
                    }

                    IF_DEBUG(OPLOCKS) {
                        DBGPRINTF((
                            DBG_CONTEXT,
                            "OplockCreateFile(%08lx, %08lx, %08lx) - Processing Open Reference %08lx\n",
                            Context,
                            Status,
                            pEntry,
                            TmpCache
                            ));
                    }

                    InsertTailList( &ListHead, pEntry );
                }

                break;
            }

            if( result ) {
                while( !IsListEmpty( &ListHead ) ) {
                    pEntry = RemoveHeadList( &ListHead );
                    InitializeListHead( pEntry );

                    pbhBlob = CONTAINING_RECORD( pEntry, BLOB_HEADER, PFList );
                    TmpCache = pbhBlob->pCache;

                    IF_DEBUG(OPLOCKS) {
                        DBGPRINTF((
                            DBG_CONTEXT,
                            "OplockCreateFile(%08lx, %08lx) - Processing Open Reference %08lx %08lx\n",
                            Context,
                            Status,
                            pEntry,
                            TmpCache
                            ));
                    }

                    TsDereferenceCacheObj( TmpCache, FALSE );
                }

                if( RemoveCacheObjFromLists( cache, FALSE ) ) {
                    if( cache->fZombie ) {
//DON'T DO IT!                        TsDereferenceCacheObj( cache, FALSE );
                    }
                } else {
                    IF_DEBUG(OPLOCKS) {
                        DBGPRINTF((
                            DBG_CONTEXT,
                            "OplockCreateFile(%08lx, %08lx) - Error Processing Open Reference %08lx\n",
                            Context,
                            Status,
                            cache
                            ));
                    }
                }

            } else {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "Unknown oplock %08lx, cache == %08lx\n",
                    lpOplock,
                    cache
                    ));
            }

        }

    }

    LeaveCriticalSection( &csVirtualRoots );
    LeaveCriticalSection( &CacheTable.CriticalSection );

    DestroyOplockObject( lpOplock );

}   // OplockCreateFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\spechash\dbgutil.h ===
/*++

   Copyright    (c)    1994-1997    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to 
      modify for each application the accompanying pgmutils.dll is used.
     
   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE 

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

    
// end_user_modifiable
// begin_user_unmodifiable



/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants 
// 

// Use the default constants from pudebug.h

# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\win95\cachew95.cxx ===
#include "TsunamiP.Hxx"
#pragma hdrstop


#include <dbgutil.h>

/*++


--*/

//
//  Items in a Bin list beyond this position will get moved to the front
//  on an object cache hit
//

#define  REORDER_LIST_THRESHOLD     5

//
//  Current count of cached file handles across a UNC connection
//

DWORD cCachedUNCHandles;

VOID
CheckCacheSize(
    DWORD  cbNewBlobSize
    );

CACHE_TABLE CacheTable;

BOOL Cache_Initialize( VOID )
{
    int index;
    DWORD err;
    DWORD dwDummy;
    HKEY  hkey;
    DWORD cbSize = sizeof( Configuration.Cache.cbMaximumSize );

    memset( &Configuration, 0, sizeof( Configuration ));

    cCachedUNCHandles = 0;

    //
    //  Read the initial cache size from the registry
    //

    err = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                          INETA_PARAMETERS_KEY,
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hkey,
                          &dwDummy );

    if ( err )
    {
        SetLastError( err );
        return FALSE;
    }

    err = RegQueryValueEx( hkey,
                           INETA_MEMORY_CACHE_SIZE,
                           NULL,
                           &dwDummy,
                           (LPBYTE) &Configuration.Cache.cbMaximumSize,
                           &cbSize );

    //
    //  Default the cache size if we failed to query the value
    //

    if ( err )
        Configuration.Cache.cbMaximumSize = INETA_DEF_MEMORY_CACHE_SIZE;

    RegCloseKey( hkey );

    //
    //  Limit the cache size to 2 gigs so integer comparisons will work
    //

    if ( Configuration.Cache.cbMaximumSize > 0x7fffffff )
    {
        Configuration.Cache.cbMaximumSize = 0x7fffffff;
    }

    InitializeCriticalSection( &CacheTable.CriticalSection );

    InitializeListHead( &CacheTable.MruList );

    for ( index=0; index<MAX_BINS; index++ )
    {
        InitializeListHead( &CacheTable.Items[ index ] );
    }

    return( TRUE );
}

BOOL TsCacheDirectoryBlobW
(
    IN const TSVC_CACHE     &TSvcCache,
    IN      PCWSTR          pwszDirectoryName,
    IN      ULONG           iDemultiplexor,
    IN      PVOID           pvBlob,
    IN      ULONG           cbBlobSize,
    IN      BOOLEAN         bKeepCheckedOut
)
{
#ifdef DBG
	DebugBreak();
#endif
	return ERROR_NOT_SUPPORTED;
}

BOOL TsCacheDirectoryBlobA
(
    IN const TSVC_CACHE     &TSvcCache,
    IN      PCSTR           pszDirectoryName,
    IN      ULONG           iDemultiplexor,
    IN      PVOID           pvBlob,
    IN      ULONG           cbBlobSize,
    IN      BOOLEAN         bKeepCheckedOut
)
/*++

  Routine Description:

    This function associates the Blob given as input with the specified
    directory and demultiplexing number.  Services should use this
    function to add a Blob to the cache.

    Callers must not cache the same Blob twice.  Once a Blob is cached,
    its contents must not be modified, and it must not be freed or re-cached.

  Arguments

    cbBlobSize is the externally allocated size of the logical object being
        cached (i.e., the memory to store a directory listing for example).
        This will be charged against the cache quota.

--*/
{
	// Do not cache for now
    return( FALSE );
}

BOOL TsCheckOutCachedBlobA
(
    IN const TSVC_CACHE     &TSvcCache,
    IN      PCSTR           pszDirectoryName,
    IN      ULONG           iDemultiplexor,
    IN      PVOID *         ppvBlob,
    IN OPTIONAL PULONG      pcbBlobSize
)
{
    DWORD cch;
    WCHAR awchPath[ MAX_PATH + 1 ];
    BOOL  bSuccess;

    //
    //  Convert directory name to UNICODE.
    //

    cch = MultiByteToWideChar( CP_ACP,
                               MB_PRECOMPOSED,
                               pszDirectoryName,
                               -1,
                               awchPath,
                               sizeof( awchPath ) / sizeof(WCHAR) );

    if ( !cch )
        return FALSE;

    bSuccess = TsCheckOutCachedBlobW(  TSvcCache,
                                       awchPath,
                                       iDemultiplexor,
                                       ppvBlob,
                                       pcbBlobSize );

    return( bSuccess );
}


BOOL TsCheckOutCachedBlobW
(
    IN const TSVC_CACHE     &TSvcCache,
    IN      PCWSTR          pwszDirectoryName,
    IN      ULONG           iDemultiplexor,
    IN      PVOID *         ppvBlob,
    IN OPTIONAL PULONG      pcbBlobSize
    )
{
    return( FALSE );
} // TsCheckOutCachedBlobW()



BOOL TsCheckInCachedBlob
(
    IN const TSVC_CACHE     &TSvcCache,
    IN      PVOID           pvBlob
    )
{
	return FALSE;
}


BOOL TsExpireCachedBlob
(
    IN const TSVC_CACHE &TSvcCache,
    IN      PVOID           pvBlob
    )
{
    PBLOB_HEADER pbhBlob;
    PCACHE_OBJECT pCache;

    pbhBlob = (( PBLOB_HEADER )pvBlob ) - 1;

    ASSERT( pbhBlob->IsCached );

    pCache = pbhBlob->pCache;

    ASSERT( pCache->Signature == CACHE_OBJ_SIGNATURE );
    ASSERT( pCache->pbhBlob == pbhBlob );
    ASSERT( pCache->references > 0 );

    return( DeCache( pCache, TRUE ) );
}

VOID
TsDereferenceCacheObj(
    IN      PCACHE_OBJECT  pCache
    )
{
    ASSERT( pCache->Signature == CACHE_OBJ_SIGNATURE );
    ASSERT( pCache->references > 0 );
    ASSERT( pCache->pbhBlob->IsCached );

    if ( !InterlockedDecrement( (LONG *) &pCache->references ))
    {
        //
        //  We best not be on a list if we're about to be freed here
        //

        ASSERT( IsListEmpty( &pCache->BinList ) );

        //
        //  We really want to call TsFree here, but we don't have a TsvcCache
        //

        IF_DEBUG( CACHE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "[DeCache] Free routine: 0x%lx, Blob: 0x%lx Cache obj: 0x%lx\n",
                        pCache->pbhBlob->pfnFreeRoutine,
                        pCache->pbhBlob,
                        pCache ));
        }

        if ( pCache->pbhBlob->pfnFreeRoutine )
            pCache->pbhBlob->pfnFreeRoutine( pCache->pbhBlob + 1);

        CacheTable.MemoryInUse -= pCache->pbhBlob->cbSize +
                                  pCache->UserValue;

        ASSERT( !(CacheTable.MemoryInUse & 0x80000000 ));

        DEC_COUNTER( pCache->dwService,
                     CurrentObjects );

        FREE( pCache->pbhBlob );
        FREE( pCache );
    }
}


VOID
CheckCacheSize(
    DWORD cbNewBlobSize
    )
/*++

  Routine Description:

    Checks to see if the cache size limit has been exceeded and throws out
    objects until it is below the limit.


    THE CACHE TABLE LOCK MUST BE TAKEN PRIOR TO CALLING THIS FUNCTION

  Arguments:

    cbNewBlobSize - Optional blob that is about to be added to the cache

--*/
{
    while ( (CacheTable.MemoryInUse + cbNewBlobSize) > Configuration.Cache.cbMaximumSize &&
            !IsListEmpty( &CacheTable.MruList ) )
    {
        //
        //  The least recently used entry is the one at the tail of the MRU
        //  list.
        //

        PCACHE_OBJECT  pCacheObject =
                         CONTAINING_RECORD( CacheTable.MruList.Blink,
                                            CACHE_OBJECT,
                                            MruList );
        DeCache( pCacheObject, FALSE );

        IF_DEBUG( CACHE) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " Throwing out object ( %08x) to reduce cache size\n",
                        pCacheObject));
        }

    }
}

BOOL
TsAdjustCachedBlobSize(
    IN PVOID              pvBlob,
    IN INT                cbSize
    )
/*++

  Routine Description:

    Adjusts the user supplied cache size for this specified cache blob

  Arguments:

    pvBlob - Blob to adjust
    cbSize - positive or negative size to adjust by

  Returns:

    TRUE if the size was adjust successfully, FALSE if the blob should not
    be added to the cache because it own't fit

--*/
{
    PBLOB_HEADER    pbhBlob;
    PCACHE_OBJECT   pCache;

    pbhBlob = (( PBLOB_HEADER )pvBlob ) - 1;

    ASSERT( pbhBlob->IsCached );

    pCache = pbhBlob->pCache;

    ASSERT( pCache->Signature == CACHE_OBJ_SIGNATURE );
    ASSERT( pCache->pbhBlob == pbhBlob );

    ASSERT( pCache->references > 0 );

    //
    //  If the size of this blob would never fit, indicate to the client
    //  they shouldn't do what they are about to do
    //

    if ( cbSize > (INT) Configuration.Cache.cbMaximumSize )
    {
        return FALSE;
    }

    //
    //  Take the table lock to decache items from the MRU and to adjust the
    //  MemoryInuse field of the CacheTable
    //

    EnterCriticalSection( &CacheTable.CriticalSection );

    if ( (DWORD)((INT) CacheTable.MemoryInUse + cbSize) >
         Configuration.Cache.cbMaximumSize &&
         cbSize > 0 )
    {
        CheckCacheSize( (DWORD) cbSize );
    }

    CacheTable.MemoryInUse += cbSize;
    pbhBlob->cbSize += cbSize;

    LeaveCriticalSection( &CacheTable.CriticalSection );

    return TRUE;
}

VOID
TsCacheSetSize(
    DWORD cbMemoryCacheSize
    )
/*++

  Routine Description:

    Sets the new maximum size of the memory cache and flushes items till we
    meet the new size requirements.


  Arguments:

    cbMemoryCacheSize - New memory cache size to set

--*/
{
    EnterCriticalSection( &CacheTable.CriticalSection );

    Configuration.Cache.cbMaximumSize = cbMemoryCacheSize;

    //
    //  Throw out any thing that won't fit under out new size
    //

    CheckCacheSize( 0 );

    LeaveCriticalSection( &CacheTable.CriticalSection );
}

extern
DWORD
TsCacheQuerySize(
    VOID
    )
/*++

  Routine Description:

    Returns the current maximum size of the memory cache

--*/
{
    return Configuration.Cache.cbMaximumSize;
}

BOOL
TsCacheQueryStatistics(
    IN  DWORD       Level,
    IN  DWORD       dwServerMask,
    IN  INETA_CACHE_STATISTICS * pCacheCtrs
    )
/*++

  Routine Description:

    This function returns the statistics for the global cache or for the
    individual services

  Arguments:

    Level - Only valid value is 0
    dwServerMask - Server mask to retrieve statistics for or 0 for the sum
        of the services
    pCacheCtrs - Receives the statistics for cache

  Notes:
    CacheBytesTotal and CacheBytesInUse are not kept on a per-server basis
        so they are only returned when retrieving summary statistics.

  Returns:

    TRUE on success, FALSE on failure
--*/
{
    if ( Level != 0 ||
         dwServerMask > LAST_PERF_CTR_SVC ||
         !pCacheCtrs )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if ( dwServerMask )
    {
        memcpy( pCacheCtrs,
                &Configuration.Stats[ MaskIndex(dwServerMask) ],
                sizeof( Configuration.Stats[ 0 ] ) );
    }
    else
    {
        //
        //  Add up all of the statistics
        //

        memset( pCacheCtrs, 0, sizeof( *pCacheCtrs ));

        pCacheCtrs->CacheBytesTotal = Configuration.Cache.cbMaximumSize;
        pCacheCtrs->CacheBytesInUse = CacheTable.MemoryInUse;

        for ( int i = 0; i < MAX_PERF_CTR_SVCS; i++ )
        {
            DWORD index = MaskIndex( 1 << i );

            pCacheCtrs->CurrentOpenFileHandles+= Configuration.Stats[index].CurrentOpenFileHandles;
            pCacheCtrs->CurrentDirLists       += Configuration.Stats[index].CurrentDirLists;
            pCacheCtrs->CurrentObjects        += Configuration.Stats[index].CurrentObjects;
            pCacheCtrs->FlushesFromDirChanges += Configuration.Stats[index].FlushesFromDirChanges;
            pCacheCtrs->CacheHits             += Configuration.Stats[index].CacheHits;
            pCacheCtrs->CacheMisses           += Configuration.Stats[index].CacheMisses;
        }
    }

    return TRUE;
}

BOOL
TsCacheClearStatistics(
    IN  DWORD       dwServerMask
    )
/*++

  Routine Description:

    Clears the the specified service's statistics

--*/
{
    if ( dwServerMask > LAST_PERF_CTR_SVC )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    //  Currently this function isn't supported
    //

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
TsCacheFlush(
    IN  DWORD       dwServerMask
    )
/*++

  Routine Description:

    This function flushes the cache of all items for the specified service
    or for all services if dwServerMask is zero.

--*/
{
    LIST_ENTRY * pEntry;
    LIST_ENTRY * pNext;

    EnterCriticalSection( &CacheTable.CriticalSection );

    for ( pEntry =  CacheTable.MruList.Flink;
          pEntry != &CacheTable.MruList;
        )
    {
        pNext = pEntry->Flink;

        PCACHE_OBJECT  pCacheObject =
                         CONTAINING_RECORD( pEntry,
                                            CACHE_OBJECT,
                                            MruList );

        if ( !dwServerMask ||
             (dwServerMask & pCacheObject->dwService))
        {
            DeCache( pCacheObject, FALSE );

            IF_DEBUG( CACHE) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Throwing out object ( %08x) due to manual flush\n",
                            pCacheObject));
            }
        }

        pEntry = pNext;
    }

    LeaveCriticalSection( &CacheTable.CriticalSection );

    return TRUE;
}

BOOL
TsCacheFlushUser(
    IN  HANDLE      hUserToken,
    IN  BOOL        fDefer
    )
/*++

  Routine Description:

    This function flushes all file handles associated the passed user context

  Arguments:

    hUserToken - User token to flush from the cache
    fDefer - Build list but close handles later in worker thread (Not supported)

--*/
{
    LIST_ENTRY * pEntry;
    LIST_ENTRY * pNext;

    ASSERT( !fDefer );

    EnterCriticalSection( &CacheTable.CriticalSection );

    for ( pEntry =  CacheTable.MruList.Flink;
          pEntry != &CacheTable.MruList;
        )
    {
        pNext = pEntry->Flink;

        PCACHE_OBJECT  pCacheObject = CONTAINING_RECORD( pEntry,
                                                         CACHE_OBJECT,
                                                         MruList );

        ASSERT( pCacheObject->Signature == CACHE_OBJ_SIGNATURE );

        //
        //  Find all occurrences of the matching user token in the cache and
        //  decache them
        //

        if ( pCacheObject->iDemux == RESERVED_DEMUX_OPEN_FILE &&
             ((TS_OPEN_FILE_INFO *)(pCacheObject->pbhBlob + 1))->
                 QueryOpeningUser() == hUserToken )
        {
            ASSERT( pCacheObject->pbhBlob->cbSize == sizeof(TS_OPEN_FILE_INFO));

            DeCache( pCacheObject, FALSE );

            IF_DEBUG( CACHE) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Throwing out object ( %08x) due to user token flush\n",
                            pCacheObject));
            }
        }
        else if ( pCacheObject->iDemux == RESERVED_DEMUX_DIRECTORY_LISTING &&
                    ((TS_DIRECTORY_HEADER *)(pCacheObject->pbhBlob + 1))->
                            QueryListingUser() == hUserToken )
        {
            ASSERT( pCacheObject->pbhBlob->cbSize == sizeof(TS_DIRECTORY_HEADER));

            DeCache( pCacheObject, FALSE );

            IF_DEBUG( CACHE) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Throwing out object ( %08x) due to user token flush\n",
                            pCacheObject));
            }
        }

        pEntry = pNext;
    }

    LeaveCriticalSection( &CacheTable.CriticalSection );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache\win95\getdirpw.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        getdirp.cxx

   Abstract:
        This module implements the functions for getting directory listings
         and transparently caching them.
        ( This uses OS specific functions to obtain the directory).

		Rewritten for Windows95

   Author:

		VladS	11-20-95	WIndows95 version

   Project:

          Tsunami Lib
          ( Common caching and directory functions for Internet Services)

   Functions Exported:
   BOOL TsGetDirectoryListingA()
   BOOL TsGetDirectoryListingW()
   BOOL TsFreeDirectoryListing()
   int __cdecl
   AlphaCompareFileBothDirInfo(
              IN const void *   pvFileInfo1,
              IN const void *   pvFileInfo2)

   TS_DIRECTORY_HEADER::ReadFromNtDirectoryFile(
                  IN LPCWSTR          pwszDirectoryName
                  )
   TS_DIRECTORY_HEADER::BuildInfoPointers(
                  IN LPCWSTR          pwszDirectoryName
                  )
   TS_DIRECTORY_HEADER::CleanupThis()

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "tsunamip.hxx"

# include <stdlib.h>
# include <string.h>
# include <dbgutil.h>

/************************************************************
 *     Type Definitions
 ************************************************************/


#define DIRECTORY_BUFFER_SIZE 8160          /* < 8192 bytes */

/************************************************************
 *    Functions
 ************************************************************/


BOOL FreeDirectoryHeaderContents( PVOID pvOldBlock );

PTS_DIRECTORY_HEADER
TsGetFreshDirectoryHeaderW(
     IN const TSVC_CACHE  &  tsCache,
     IN LPCWSTR              pwszDirectoryName,
     IN HANDLE               hLisingUser);



dllexp
BOOL
TsGetDirectoryListingA
(
    IN const TSVC_CACHE         &tsCache,
    IN      PCSTR               pszDirectoryName,
    IN      HANDLE              hListingUser,
    OUT     PTS_DIRECTORY_HEADER * ppTsDirectoryHeader
)
/*++
  This function obtains the directory listing for dir specified
        in pwszDirectoryName.

  Arguments:
    tsCache          Cache structure which is used for lookup
    pwszDirectoryName  pointer to string containing the directory name
    ListingUser        Handle for the user opening the directory
    ppTsDirectoryHeader
                  pointer to pointer to class containing directory information.
       Filled on successful return. On failure this will be NULL

  Returns:
      TRUE on success and FALSE if  there is a failure.
--*/
{
	BOOL					bSuccess;
    BOOL					fReadSuccess;
    DWORD					cbBlob = 0;
	PTS_DIRECTORY_HEADER	pDirectoryHeader=NULL;

    //
    // Allocate space for Directory listing
    //

    bSuccess = TsAllocateEx( tsCache,
                            sizeof( TS_DIRECTORY_HEADER ),
                            ( PVOID * )&pDirectoryHeader,
                            FreeDirectoryHeaderContents );

    if ( !bSuccess) {
        //
        // Allocation of Directory Header failed.
        //
		return FALSE;
	}

    ASSERT( pDirectoryHeader != NULL);

    pDirectoryHeader->ReInitialize();  // called since we raw alloced space
    pDirectoryHeader->SetListingUser( hListingUser);

	//
	// Read fresh directory listing. We don not cache ( now)
	// when running on Windows95, but may in future
	// We are reusing the same method to obtaining directory information
	// as defined in NT class definition, although in reality this is
	// platform specific method
	//
    fReadSuccess = pDirectoryHeader->ReadFromNtDirectoryFile(
                                              (LPCWSTR)pszDirectoryName,
                                              &cbBlob ) &&
                   pDirectoryHeader->BuildFileInfoPointers( &cbBlob );

	if (! fReadSuccess) {
        //
        // Reading directory failed.
        //  cleanup directory related data and get out.
        //
        BOOL fFreed = TsFree( tsCache, pDirectoryHeader);
        ASSERT( fFreed);
        pDirectoryHeader = NULL;
    }

    *ppTsDirectoryHeader = pDirectoryHeader;
    bSuccess = ( *ppTsDirectoryHeader != NULL);

	return bSuccess;

} // TsGetDirectoryListingA()






dllexp
BOOL
TsFreeDirectoryListing
(
    IN const TSVC_CACHE &    tsCache,
    IN PTS_DIRECTORY_HEADER  pDirectoryHeader
)
{
    BOOL fReturn;

    fReturn = TsFree( tsCache, ( PVOID )pDirectoryHeader );

    return( fReturn);
} // TsFreeDirectoryListing()



BOOL
FreeDirectoryHeaderContents( PVOID pvOldBlock )
{
    PTS_DIRECTORY_HEADER  pDirectoryHeader;

    pDirectoryHeader = ( PTS_DIRECTORY_HEADER )pvOldBlock;

    pDirectoryHeader->CleanupThis();

    //
    //  The item may never have been added to the cache, don't
    //  count it in this case
    //

    if ( BLOB_IS_OR_WAS_CACHED( pvOldBlock ) )
    {
        DEC_COUNTER( BLOB_GET_SVC_ID( pvOldBlock ),
                     CurrentDirLists );
    }

    return ( TRUE);
}  //  FreeDirectoryHeaderContents()




int __cdecl
AlphaCompareFileBothDirInfo(
   IN const void *   pvFileInfo1,
   IN const void *   pvFileInfo2)
{
    const FILE_BOTH_DIR_INFORMATION * pFileInfo1 =
        *((const FILE_BOTH_DIR_INFORMATION **) pvFileInfo1);
    const FILE_BOTH_DIR_INFORMATION * pFileInfo2 =
        *((const FILE_BOTH_DIR_INFORMATION **) pvFileInfo2);

    ASSERT( pFileInfo1 != NULL && pFileInfo2 != NULL);

    return ( lstrcmp( (LPCSTR )pFileInfo1->FileName,
                      (LPCSTR )pFileInfo2->FileName));

} // AlphaCompareFileBothDirInfo()



BOOL
SortInPlaceFileInfoPointers(
    IN OUT PFILE_BOTH_DIR_INFORMATION  * prgFileInfo,
    IN int   nEntries,
    IN PFN_CMP_FILE_BOTH_DIR_INFO        pfnCompare)
/*++
  This is a generic function to sort the pointers to file information
    array in place using pfnCompare to compare the records for ordering.

  Returns:
     TRUE on success and FALSE on failure.
--*/
{
    DWORD  dwTime;

#ifdef INSERTION_SORT
    int idxInner;
    int idxOuter;

    dwTime = GetTickCount();
    //
    //  A simple insertion sort is performed. May be modified in future.
    //

    for( idxOuter = 1; idxOuter < nEntries; idxOuter++) {

        for( idxInner = idxOuter; idxInner > 0; idxInner-- ) {

            int iCmp = ( *pfnCompare)( prgFileInfo[ idxInner - 1],
                                       prgFileInfo[ idxInner]);

            if ( iCmp <= 0) {
                //
                //  The entries in prgFileInfo[0 .. idxOuter] are in order.
                //  Stop bubbling the outer down.
                //
                break;
            } else {

                //
                // Swap the two entries.  idxInner, idxInner - 1
                //

                PFILE_BOTH_DIR_INFORMATION  pFInfoTmp;

                pFInfoTmp = prgFileInfo[ idxInner - 1];
                prgFileInfo[ idxInner - 1] = prgFileInfo[idxInner];
                prgFileInfo[ idxInner] = pFInfoTmp;
            }
        }  // inner for

    } // for

    dwTime = GetTickCount() -  dwTime;

# else

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Qsorting the FileInfo Array %08x ( Total = %d)\n",
                    prgFileInfo, nEntries));
    }

    dwTime = GetTickCount();
    qsort( (PVOID ) prgFileInfo, nEntries,
          sizeof( PFILE_BOTH_DIR_INFORMATION),
          pfnCompare);

    dwTime = GetTickCount() - dwTime;

# endif // INSERTION_SORT

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Time to sort %d entries = %d\n",
                    nEntries, dwTime));
    }

    return ( TRUE);
} // SortInPlaceFileInfoPointers()







/**********************************************************************
 *    TS_DIRECTORY_HEADER  related member functions
 **********************************************************************/

inline USHORT
ConvertUnicodeToAnsiInPlace(
   IN OUT  LPWSTR     pwszUnicode,
   IN      USHORT     usLen)
/*++
  Converts given Unicode strings to Ansi In place and returns the
    length of the modified string.
--*/
{
    CHAR achAnsi[MAX_PATH+1];
    DWORD cch;

    if ( usLen > sizeof(achAnsi) )
    {
        ASSERT( FALSE );
        *pwszUnicode = L'\0';
        return 0;
    }

    //
    //  usLen is a byte count and the unicode string isn't terminated
    //

    cch = WideCharToMultiByte( CP_ACP,
                               WC_COMPOSITECHECK,
                               pwszUnicode,
                               usLen / sizeof(WCHAR),
                               achAnsi,
                               sizeof( achAnsi ),
                               NULL,
                               NULL );

    if ( !cch || (cch + 1) > sizeof( achAnsi ) )
    {
        ASSERT( FALSE );
        *pwszUnicode = L'\0';
        return 0;
    }

    achAnsi[cch] = '\0';

    RtlCopyMemory( pwszUnicode, achAnsi, cch + 1 );

    return (USHORT) cch;
}  // ConvertUnicodeToAnsiInPlace()



BOOL
TS_DIRECTORY_HEADER::ReadFromNtDirectoryFile(
    IN LPCWSTR          pwszDirectoryName,
    IN OUT DWORD *      pcbMemUsed
    )
/*++
  Opens and reads the directory file for given directory to obtain
   information about files and directories in the dir.

  Returns:
     TRUE on success and   FALSE on failure.
     Use GetLastError() for further error information.

--*/
{
    BOOL                fReturn = TRUE;       // default assumed.


	CHAR				szDirectoryName[MAX_PATH+5];
	WIN32_FIND_DATA		fd;
    HANDLE              hFindFile = INVALID_HANDLE_VALUE;
    BOOL                fFirstTime,fOverflow=FALSE;
    DWORD               cbExtraMem = 0, cch;

    PFILE_BOTH_DIR_INFORMATION pFileDirInfo = NULL;
    PFILE_BOTH_DIR_INFORMATION pFileDirInfoPrior = NULL;

    ULONG Offset;

	lstrcpy(szDirectoryName,(LPCSTR)pwszDirectoryName);
	lstrcat(szDirectoryName,TEXT("\\*.*"));
    //
    // Open the directory for list access
    //

	hFindFile = FindFirstFile(szDirectoryName,&fd);
	if (hFindFile == INVALID_HANDLE_VALUE) {
        IF_DEBUG( DIR_LIST) {
            DBGPRINTF( ( DBG_CONTEXT, "Failed to open Dir %ws. Handle = %x\n",
                        pwszDirectoryName, hFindFile));
        }

        SetLastError( ERROR_PATH_NOT_FOUND);
        return ( FALSE);
	}

    InitializeListHead( &m_listDirectoryBuffers);

    //
    //  Loop through getting subsequent entries in the directory.
    //
    for( fFirstTime = TRUE; ; fFirstTime = FALSE)
    {
        PVOID pvBuffer;

        //
        // Get the next chunk of directory information.
        //  Obtained in a buffer  with LIST_ENTRY as the first member of buffer
        //

        #define DIR_ALLOC_SIZE  (DIRECTORY_BUFFER_SIZE + sizeof (LIST_ENTRY))

        pvBuffer = ALLOC( DIR_ALLOC_SIZE );
        cbExtraMem += DIR_ALLOC_SIZE;

        if ( pvBuffer == NULL ) {

            //
            //  Allocation failure.
            //
            SetLastError( ERROR_NOT_ENOUGH_MEMORY);
            fReturn = FALSE;
            break;                // Get out of the loop with failure.
        }

        pFileDirInfo = ( PFILE_BOTH_DIR_INFORMATION )
          ((PLIST_ENTRY)pvBuffer + 1 );

        //
        //  The buffer contains directory entries.
        //  Place it on the list of such buffers for this directory.
        //

        InsertBufferInTail( (PLIST_ENTRY ) pvBuffer);

        pFileDirInfoPrior = NULL;
		fOverflow=FALSE;
		Offset = 0;

		do {

			Offset = sizeof(FILE_BOTH_DIR_INFORMATION)+
					  lstrlen(fd.cFileName)+sizeof(CHAR);

			if (((PCHAR)pFileDirInfo+Offset-(PCHAR)pvBuffer) >= DIR_ALLOC_SIZE) {
				fOverflow  = TRUE;
				break;
			}

            IncrementDirEntries();

			//
			// Move Win32 structure into FILE_BOTH
			//
			if (pFileDirInfoPrior){
				pFileDirInfoPrior->NextEntryOffset =
					sizeof(FILE_BOTH_DIR_INFORMATION)+
					 pFileDirInfoPrior->FileNameLength+sizeof(CHAR);
					;
			}

			// BUGBUG THis is not quite correct
			pFileDirInfo->NextEntryOffset = 0;

			pFileDirInfo->FileIndex = 0;
			pFileDirInfo->CreationTime.QuadPart = 0;//(LARGE_INTEGER)fd.ftCreationTime;
			pFileDirInfo->LastAccessTime.QuadPart = 0;//fd.ftLastAccessTime;
			pFileDirInfo->LastWriteTime.QuadPart = 0;//fd.ftLastWriteTime;
			pFileDirInfo->ChangeTime.QuadPart = 0;
			pFileDirInfo->EndOfFile.QuadPart = 0;
			pFileDirInfo->AllocationSize.QuadPart= fd.nFileSizeLow;
			pFileDirInfo->FileAttributes = fd.dwFileAttributes;
			pFileDirInfo->FileNameLength = lstrlen(fd.cFileName);
			pFileDirInfo->EaSize = 0;
			pFileDirInfo->ShortNameLength = min(lstrlen(fd.cAlternateFileName),12);
			strncpy((LPSTR)pFileDirInfo->ShortName,fd.cAlternateFileName,pFileDirInfo->ShortNameLength);
			strcpy((LPSTR)pFileDirInfo->FileName,fd.cFileName);

			pFileDirInfoPrior = pFileDirInfo;

			// Get the next entry in buffer
            pFileDirInfo =
                  ( PFILE_BOTH_DIR_INFORMATION )
                  ((( PCHAR )pFileDirInfo ) + Offset);

		}
		while(!fOverflow && FindNextFile(hFindFile,&fd));

		if (!fOverflow)
			break;
	}


    if ( hFindFile != INVALID_HANDLE_VALUE) {
		FindClose(hFindFile);
        hFindFile = INVALID_HANDLE_VALUE;
    }

    *pcbMemUsed += cbExtraMem;

    return ( fReturn);

} // TS_DIRECTORY_HEADER::ReadFromNtDirectoryFile()




VOID
TS_DIRECTORY_HEADER::CleanupThis( VOID)
{
    PLIST_ENTRY pEntry;
    PLIST_ENTRY pNextEntry;

    for ( pEntry = QueryDirBuffersListEntry()->Flink;
         pEntry != QueryDirBuffersListEntry();
         pEntry  = pNextEntry )
    {
        pNextEntry = pEntry->Flink;

        //
        //  The buffers are allocated such that first member of buffer is
        //    LIST_ENTRY object.  Free it entirely.
        //
        FREE( pEntry );
    }

    InitializeListHead( QueryDirBuffersListEntry());

    if ( m_ppFileInfo != NULL) {

        FREE( m_ppFileInfo);
        m_ppFileInfo   = NULL;
    }

    m_hListingUser = INVALID_HANDLE_VALUE;
    m_nEntries     = 0;

    return;
} // TS_DIRECTORY_HEADER::CleanupThis()





BOOL
TS_DIRECTORY_HEADER::BuildFileInfoPointers(
    IN OUT DWORD *      pcbMemUsed
    )
/*++

  This constructs the indirection pointers from the buffers containing the
   file information.
  This array of indirection enables faster access to the file information
   structures stored.

   Should be always called after ReadFromNtDirectoryFile() to construct the
    appropriate pointers.

   Returns:
     TRUE on success and FALSE if there are any failures.
--*/
{
    BOOL fReturn = FALSE;
    DWORD cbAlloc;

    ASSERT( QueryNumEntries() != 0);  //  Any directory will atleast have "."

    //
    // Alloc space for holding the pointers for numEntries pointers.
    //

    cbAlloc = QueryNumEntries() * sizeof( PFILE_BOTH_DIR_INFORMATION );

    m_ppFileInfo = (PFILE_BOTH_DIR_INFORMATION *) ALLOC( cbAlloc );

    if ( m_ppFileInfo != NULL ) {

        int          index;
        PLIST_ENTRY  pEntry;
        ULONG        Offset;
        PFILE_BOTH_DIR_INFORMATION   pFileDirInfo;

        //
        //  Get the link to first buffer and start enumeration.
        //
        pEntry = QueryDirBuffersListEntry()->Flink;
        pFileDirInfo = (PFILE_BOTH_DIR_INFORMATION )( pEntry + 1 );

        for ( index = 0;
             index < QueryNumEntries();
             index++ ) {

            ASSERT( pEntry != QueryDirBuffersListEntry());

            m_ppFileInfo[index] = pFileDirInfo;    // store the pointer.

            Offset = pFileDirInfo->NextEntryOffset;

            if ( Offset != 0 ) {

                pFileDirInfo = (PFILE_BOTH_DIR_INFORMATION )
                                 ((( PCHAR )pFileDirInfo ) + Offset );
            } else {

                //
                // we are moving to the next buffer.
                //
                pEntry = pEntry->Flink;
                if ( pEntry == QueryDirBuffersListEntry()) {

                    ASSERT( index == QueryNumEntries() - 1);
                    break;
                }
                pFileDirInfo = ( PFILE_BOTH_DIR_INFORMATION )( pEntry + 1 );
            }


        } // for
        ASSERT( Offset == 0 );
        fReturn = SortInPlaceFileInfoPointers( m_ppFileInfo,
                                              QueryNumEntries(),
                                              AlphaCompareFileBothDirInfo);

    } // valid alloc of the pointers.

    *pcbMemUsed += cbAlloc;

    return ( fReturn);
} // TS_DIRECTORY_HEADER::BuildFileInfoPointers()


dllexp
BOOL
TsGetDirectoryListingW
(
    IN const TSVC_CACHE         &tsCache,
    IN      PCWSTR              pwszDirectoryName,
    IN      HANDLE              hListingUser,
    OUT     PTS_DIRECTORY_HEADER * ppTsDirectoryHeader
)
/*++
  This function obtains the directory listing for dir specified
        in pwszDirectoryName.

  Arguments:
    tsCache          Cache structure which is used for lookup
    pwszDirectoryName  pointer to string containing the directory name
    ListingUser        Handle for the user opening the directory
    ppTsDirectoryHeader
                  pointer to pointer to class containing directory information.
       Filled on successful return. On failure this will be NULL

  Returns:
      TRUE on success and FALSE if  there is a failure.
--*/
{
    return ( FALSE);

} // TsGetDirectoryListingW()




# if DBG

VOID
TS_DIRECTORY_HEADER::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                "Printing TS_DIRECTORY_HEADER ( %08x).\n", this));
    DBGPRINTF( ( DBG_CONTEXT,
                "ListingUser Handle = %08x\t Num Entries = %08x\n",
                m_hListingUser, m_nEntries));
    DBGPRINTF( ( DBG_CONTEXT,
                "Pointer to array of indirection pointers %08x\n",
                m_ppFileInfo));
    //
    //  The buffers containing the data of the file information not printed
    //

    return;
} // TS_DIRECTORY_HEADER::Print()


# endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache2\blobcach.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    blobcach.cxx

    This module implements the private interface to the blob cache.

    FILE HISTORY:
        MCourage    09-Dec-1997     Created
*/

#include <tsunami.hxx>
#include <tscache.hxx>
#include <pudebug.h>
#include "tsmemp.hxx"
#include "blobcach.hxx"
#include "blobhash.hxx"

/*
 * Globals
 */
CBlobHashTable * g_pURITable;
CBlobHashTable * g_pBlobTable;
CBlobCacheStats * g_pURICacheStats;
CBlobCacheStats * g_pBlobCacheStats;

#if TSUNAMI_REF_DEBUG
PTRACE_LOG g_pBlobRefTraceLog;
#endif

/*
 * Private helper function declarations
 */
inline VOID DerefBlob(PBLOB_HEADER pBlob);
BOOL BlobFlushFilterAll(PBLOB_HEADER pBlob, PVOID pv);


#define CHECK_BLOB_TYPE(dmx)   DBG_ASSERT(                \
        RESERVED_DEMUX_DIRECTORY_LISTING         == (dmx) \
        || RESERVED_DEMUX_ATOMIC_DIRECTORY_GUARD == (dmx) \
        || RESERVED_DEMUX_URI_INFO               == (dmx) \
        || RESERVED_DEMUX_FILE_DATA              == (dmx) \
        || RESERVED_DEMUX_SSI                    == (dmx) \
        || RESERVED_DEMUX_QUERY_CACHE            == (dmx) \
        )



/*
 * function definitions
 */
BOOL
BlobCache_Initialize(
    VOID
    )
{
#if TSUNAMI_REF_DEBUG
    g_pBlobRefTraceLog = CreateRefTraceLog(
                            256,              // LogSize
                            0                 // ExtraBytesInHeader
                            );
#endif  // TSUNAMI_REF_DEBUG

    g_pURITable = new CBlobHashTable("uri");
    if (!g_pURITable) {
        goto error;
    }
    
    g_pBlobTable = new CBlobHashTable("blob");
    if (!g_pBlobTable) {
        goto error;
    }

    g_pURICacheStats = new CBlobCacheStats;
    if (!g_pURICacheStats) {
        goto error;
    }

    g_pBlobCacheStats = new CBlobCacheStats;
    if (!g_pBlobCacheStats) {
        goto error;
    }
    return TRUE;

error:
    if (g_pURICacheStats) {
        delete g_pURICacheStats;
    }

    if (g_pBlobCacheStats) {
        delete g_pBlobCacheStats;
    }

    if (g_pBlobTable) {
        delete g_pBlobTable;
    }

    if (g_pURITable) {
        delete g_pURITable;
    }

    return FALSE;
}



VOID
BlobCache_Terminate(
    VOID
    )
{
    FlushBlobCache();
    
    delete g_pBlobTable;
    DBGPRINTF(( DBG_CONTEXT,
                 "BlobCache_Terminate: deleted g_pBlobTable.\n" ));
    delete g_pURITable;
    DBGPRINTF(( DBG_CONTEXT,
                 "FileCache_Terminate: deleted g_pURITable.\n" ));

    delete g_pURICacheStats;
    delete g_pBlobCacheStats;

#if TSUNAMI_REF_DEBUG
    if( g_pBlobRefTraceLog != NULL ) {
        DestroyRefTraceLog( g_pBlobRefTraceLog );
        g_pBlobRefTraceLog = NULL;
    }
#endif  // TSUNAMI_REF_DEBUG
}

BOOL
CacheBlob(
    IN  PBLOB_HEADER pBlob
    )
/*++
Routine Description:

    Add a Blob info structure to the cache.

Arguments:

    pBlob    - The structure to be cached. 

Return Values:

    TRUE on success.
    FALSE on failure (the item was not cached)
--*/
{
    CBlobHashTable * pHT;
    CBlobCacheStats * pCS;
    enum LK_RETCODE  lkrc;
    BOOL             bRetval;

    DBG_ASSERT( NULL != pBlob );
    DBG_ASSERT( NULL != pBlob->pBlobKey );
    DBG_ASSERT( TS_BLOB_SIGNATURE == pBlob->Signature );
    DBG_ASSERT( !pBlob->IsCached );
    DBG_ASSERT( pBlob->pBlobKey != NULL );
    CHECK_BLOB_TYPE(pBlob->pBlobKey->m_dwDemux);

    //
    // URI's in the URI table, and directories in the dir table
    //

    if (RESERVED_DEMUX_URI_INFO == pBlob->pBlobKey->m_dwDemux) {
        pHT = g_pURITable;
        pCS = g_pURICacheStats;
    } else {
        pHT = g_pBlobTable;
        pCS = g_pBlobCacheStats;
    }

    //
    // Add a reference for the caller
    //
    pBlob->AddRef();

    pBlob->IsCached = TRUE;

    //
    // put it in the hash table
    //
    lkrc = pHT->InsertRecord(pBlob, false);

    if (LK_SUCCESS == lkrc) {
        bRetval = TRUE;

        DBG_ASSERT( pCS );
        pCS->IncBlobsCached();
    } else {
        bRetval = FALSE;
        pBlob->IsCached = FALSE;
    }

    return (pBlob->IsCached);
}

VOID
DecacheBlob(
    IN  PBLOB_HEADER pBlob
    )
/*++
Routine Description:

    Remove a Blob info entry from the cache. After a call to DecacheBlob
    the entry will not be returned by CheckoutBlob. The entry itself is
    cleaned up when the last CheckinBlob occurs. Calling DecacheBlob
    checks the entry in.

Arguments:

    pBlob - The Blob info structure to be decached 

Return Values:

    None.
--*/
{
    CBlobHashTable * pHT;
    CBlobCacheStats * pCS;

    DBG_ASSERT( NULL != pBlob );
    DBG_ASSERT( TS_BLOB_SIGNATURE == pBlob->Signature );
    DBG_ASSERT( pBlob->IsCached );
    DBG_ASSERT( pBlob->pBlobKey != NULL );
    CHECK_BLOB_TYPE(pBlob->pBlobKey->m_dwDemux);

    if (RESERVED_DEMUX_URI_INFO == pBlob->pBlobKey->m_dwDemux) {
        pHT = g_pURITable;
        pCS = g_pURICacheStats;
    } else {
        pHT = g_pBlobTable;
        pCS = g_pBlobCacheStats;
    }

    DBG_REQUIRE( LK_SUCCESS == pHT->DeleteKey(pBlob->pBlobKey) );
    
    DBG_ASSERT( pCS );
    pCS->DecBlobsCached();

    pBlob->IsFlushed = TRUE;
    DerefBlob(pBlob);
}

VOID
FlushBlobCache(
    VOID
    )
/*++
Routine Description:

    Removes all entries from the cache. Unlike DecacheBlob, this
    function does not check any entries in.

Arguments:

    None

Return Value:

    None
--*/
{
    DBG_ASSERT( g_pBlobCacheStats );
    g_pBlobCacheStats->IncFlushes();
    
    FilteredFlushBlobCache(BlobFlushFilterAll, NULL);
}


LK_PREDICATE
BlobFlushCachePredicate(
    PBLOB_HEADER pBlob,
    void* pvState
    )
{
    TS_BLOB_FLUSH_STATE * pFlushState = static_cast<TS_BLOB_FLUSH_STATE*>(pvState);
    LK_PREDICATE          lkpAction;

    if (pFlushState->pfnFilter(pBlob, pFlushState->pvParm)) {
        //
        // put it on the list
        //
        pBlob->AddRef(); // for the list
        
        InsertHeadList(&pFlushState->ListHead, &pBlob->FlushList);
        lkpAction = LKP_PERFORM;
    } else {
        lkpAction = LKP_NO_ACTION;
    }

    return lkpAction;
}


VOID
FilteredFlushBlobCacheHelper (
    IN CBlobHashTable * pHT,
    IN PBLOBFILTERRTN   pFilterRoutine,
    IN PVOID            pv
    )
/*++
Routine Description:

    Removes entries based on a caller specified filter. The caller
    provides a boolean function which takes a cache entry as a 
    parameter. The function will be called with each item in the cache.
    If the function returns TRUE, the item will be decached (but not
    checked in). Otherwise the item will remain in the cache.

Arguments:

    pFilterRoutine - A pointer to the filter function 
    
Return Value:

    None
--*/
{
    TS_BLOB_FLUSH_STATE FlushState;
    
    //
    // Initialize the flush state
    //
    FlushState.pfnFilter = pFilterRoutine;
    InitializeListHead(&FlushState.ListHead);
    FlushState.pvParm = pv;

    //
    // Delete elements from table and construct list
    //
    pHT->DeleteIf(BlobFlushCachePredicate, &FlushState);

    //
    // Update element state and delete blobs as necessary
    //
    PLIST_ENTRY pEntry;
    PLIST_ENTRY pNext;
    PBLOB_HEADER pBlob;

    for (pEntry = FlushState.ListHead.Flink;
         pEntry != &FlushState.ListHead;
         pEntry = pNext ) {

        pNext = pEntry->Flink;
        pBlob = CONTAINING_RECORD( pEntry, BLOB_HEADER, FlushList );
        DBG_ASSERT( TS_BLOB_SIGNATURE == pBlob->Signature );

        pBlob->IsFlushed = TRUE;

        DerefBlob(pBlob);  // remove list's reference

    }
}


VOID
FilteredFlushBlobCache (
    IN PBLOBFILTERRTN   pFilterRoutine,
    IN PVOID            pv
    )
/*++
Routine Description:

    Removes entries based on a caller specified filter. The caller
    provides a boolean function which takes a cache entry as a 
    parameter. The function will be called with each item in the cache.
    If the function returns TRUE, the item will be decached (but not
    checked in). Otherwise the item will remain in the cache.

Arguments:

    pFilterRoutine - A pointer to the filter function 
    
Return Value:

    None
--*/
{
    DBG_ASSERT( g_pURICacheStats );
    DBG_ASSERT( g_pBlobCacheStats );

    g_pURICacheStats->IncFlushes();
    g_pBlobCacheStats->IncFlushes();

    FilteredFlushBlobCacheHelper(g_pURITable, pFilterRoutine, pv);
    FilteredFlushBlobCacheHelper(g_pBlobTable, pFilterRoutine, pv);
}

VOID
FilteredFlushURIBlobCache (
    IN PBLOBFILTERRTN   pFilterRoutine,
    IN PVOID            pv
    )
/*++
Routine Description:

    Removes entries based on a caller specified filter. The caller
    provides a boolean function which takes a cache entry as a 
    parameter. The function will be called with each item in the cache.
    If the function returns TRUE, the item will be decached (but not
    checked in). Otherwise the item will remain in the cache.

    This routine only flushes the URI cache.

Arguments:

    pFilterRoutine - A pointer to the filter function 
    
Return Value:

    None
--*/
{
    DBG_ASSERT( g_pURICacheStats );

    g_pURICacheStats->IncFlushes();

    FilteredFlushBlobCacheHelper(g_pURITable, pFilterRoutine, pv);
}


BOOL
CheckoutBlob(
    IN  LPCSTR         pstrPath,
    IN ULONG           cchPath,
    IN DWORD           dwService,
    IN DWORD           dwInstance,
    IN ULONG           iDemux,
    OUT PBLOB_HEADER * ppBlob
    )
/*++
Routine Description:

    Look up an entry in the cache and return it. 

Arguments:

    pstrPath  - The pathname of the desired Blob info in UPPERCASE!!
    TSvcCache - This structure identifies the calling server instance,
                which is also used to identify the cache entry. 
    ppBlob    - On success this output points to the cached entry.
                Otherwise it is set to NULL. 

Return Value:

    TRUE if the item was found, FALSE otherwise.
--*/
{
    CBlobHashTable * pHT;
    CBlobCacheStats * pCS;
    CBlobKey blobKey;
    PBLOB_HEADER pBlob;
    BOOL bRetVal;
    BOOL bFlushed;

    DBG_ASSERT( pstrPath != NULL );
    CHECK_BLOB_TYPE(iDemux);

    //
    // Look in the hash table
    //
    blobKey.m_pszPathName = const_cast<char *>(pstrPath);
    blobKey.m_cbPathName = cchPath;
    blobKey.m_dwService = dwService;
    blobKey.m_dwInstance = dwInstance;
    blobKey.m_dwDemux = iDemux;

    //
    // URI's in the URI table, and everything else in the blob table
    //

    if (RESERVED_DEMUX_URI_INFO == blobKey.m_dwDemux) {
        pHT = g_pURITable;
        pCS = g_pURICacheStats;
    } else {
        pHT = g_pBlobTable;
        pCS = g_pBlobCacheStats;
    }
    
    pHT->FindKey(&blobKey, &pBlob);

    if (NULL == pBlob) {
        bRetVal = FALSE;
        goto exit;
    }

    //
    // Make sure it's valid and update state
    //

    DBG_ASSERT( pBlob->IsCached );
    DBG_ASSERT( !pBlob->IsFlushed );

    //
    // success
    //
    bRetVal = TRUE;
    *ppBlob = pBlob;
    
exit:    

    DBG_ASSERT( pCS );
    if (bRetVal) {
        pCS->IncHits();
    } else {
        pCS->IncMisses();
    }

    return bRetVal;
}

BOOL
CheckoutBlobEntry(
    IN  PBLOB_HEADER pBlob
    )
/*++
Routine Description:

    This function checks out an entry to which the caller already has
    a reference.

Arguments:

    pBlob - The blob structure to be checked out. 

Return Value:

    TRUE  - Blob was successfully checked out
    FALSE - Blob was checked out, but should not be used by the
            caller. (it's been flushed)
--*/
{
    BOOL bSuccess;
    CBlobCacheStats * pCS;

    DBG_ASSERT( pBlob != NULL );
    DBG_ASSERT( pBlob->IsCached );
    DBG_ASSERT( pBlob->pBlobKey != NULL );
    CHECK_BLOB_TYPE(pBlob->pBlobKey->m_dwDemux);

    pBlob->AddRef();

    if (RESERVED_DEMUX_URI_INFO == pBlob->pBlobKey->m_dwDemux) {
        pCS = g_pURICacheStats;
    } else {
        pCS = g_pBlobCacheStats;
    }
    DBG_ASSERT( pCS );

    if (pBlob->IsFlushed == FALSE) {
        pCS->IncHits();
        bSuccess = TRUE;
    } else {
        pCS->IncMisses();
        bSuccess = FALSE;
    }

    return bSuccess;
}


VOID
CheckinBlob(
    IN  PBLOB_HEADER pBlob
    )
/*++
Routine Description:

    Indicate that a previously checked out Blob info is no longer in use.

Arguments:

    pvBlob - The Blob info structure to be checked in. 

Return Value:

    None.
--*/
{
    DBG_ASSERT( pBlob != NULL );
    DBG_ASSERT( pBlob->IsCached );
    DBG_ASSERT( pBlob->pBlobKey != NULL );
    CHECK_BLOB_TYPE(pBlob->pBlobKey->m_dwDemux);

    DerefBlob(pBlob);
}



inline VOID
DerefBlob(
    PBLOB_HEADER pBlob
    )
/*++

--*/
{
    DBG_ASSERT( pBlob != NULL );
    DBG_ASSERT( pBlob->IsCached );
    DBG_ASSERT( pBlob->pBlobKey != NULL );
    DBG_ASSERT( pBlob->Signature == TS_BLOB_SIGNATURE );
    CHECK_BLOB_TYPE(pBlob->pBlobKey->m_dwDemux);

    LONG lRefCount;

    //
    // Track memory corruption in free builds.
    //
    if ( TS_BLOB_SIGNATURE != pBlob->Signature )
    {
        DBG_ASSERT(!"The blob is corrupted");
        // This was hit once on winweb during NT5 deployment. Unfortunately
        // it was too close to escrow for a complete investigation.
        return;
    }


    lRefCount = pBlob->Deref();
    
    DBG_ASSERT( lRefCount >= 0 );
    
    if (lRefCount == 0) {
        DBG_ASSERT(pBlob->IsFlushed);

        pBlob->Signature = TS_FREE_BLOB_SIGNATURE;

        //
        // No one is using this one. Destroy!
        // First let the user specified cleanup run
        //
        if (pBlob->pfnFreeRoutine) {
            DBG_REQUIRE( pBlob->pfnFreeRoutine(pBlob) );
        }

        //
        // Delete the key stuff.
        // This should probably be in some other place
        // since we didn't allocate this string.
        // The FREE should go in some counterpart to
        // TsCacheDirectoryBlob.
        //
        CBlobKey * pblock = pBlob->pBlobKey;
        FREE(pblock->m_pszPathName);
        
        //
        // Delete the blob
        // Since TsAllocateEx does this funky trick to
        // allocate the key and the blob at once, we
        // only have to free the key.
        //
        FREE(pblock);
    }
}

BOOL
BlobFlushFilterAll(
    PBLOB_HEADER pBlob,
    PVOID pv
    )
{
    return TRUE;
}

//
// blobcach.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache2\dirchngp.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        dirchngp.cxx

   Abstract:
        This module contains the internal directory change routines

   Author:
        Murali R. Krishnan    ( MuraliK )     16-Jan-1995

--*/

#include "TsunamiP.Hxx"
#pragma hdrstop

#include "issched.hxx"
#include "dbgutil.h"
#include <lonsi.hxx>

//
//  Manifests
//

//
//  Globals
//

HANDLE g_hChangeWaitThread = NULL;
LONG   g_nTsunamiThreads = 0;

//
//  Local prototypes
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache2\etagmb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1999                **/
/**********************************************************************/

/*
    etagmb.cxx

    This module contains the methods for ETagMetabaseSink and
    ETagChangeNumber, which watch the metabase for change
    notifications relating to ETags

    FILE HISTORY:
        GeorgeRe    02-Aug-1999     Created
*/

#define INITGUID 
#include <tsunami.hxx>
#include "tsunamip.hxx"
#include "etagmb.h"

ETagChangeNumber* ETagChangeNumber::sm_pSingleton = NULL;

HRESULT
ETagMetabaseSink::SinkNotify(
    /* [in] */          DWORD              dwMDNumElements,
    /* [size_is][in] */ MD_CHANGE_OBJECT_W pcoChangeList[])

/*++

Routine Description:

    This is the change notification routine.  It is called by
    the metabase whenever there is a change in the metabase.

    This routine walks the list of changed metabase values to determine
    whether any etag-related properties have been modified.

Arguments:

    dwMDNumElements - The number of MD_CHANGE_OBJECT structures passed
        to this routine.

    pcoChangeList - An array of all the metabase values that have changed.

Return Value:

    Not used.

--*/

{
    int cUpdates = 0;

    for (DWORD i = 0;  i < dwMDNumElements;  ++i)
    {
        for (DWORD j = 0;  j < pcoChangeList[i].dwMDNumDataIDs;  ++j)
        {
            switch (pcoChangeList[i].pdwMDDataIDs[j])
            {
            case MD_HTTP_PICS:                      // HttpPics
            case MD_DEFAULT_LOAD_FILE:              // DefaultDoc
            case MD_FOOTER_DOCUMENT:                // DefaultDocFooter
            case MD_FOOTER_ENABLED:                 // EnableDocFooter
            case MD_SCRIPT_MAPS:                    // ScriptMaps
            case MD_MIME_MAP:                       // MimeMap
            case MD_VPROP_DIRBROW_LOADDEFAULT:      // EnableDefaultDoc
            case MD_ASP_CODEPAGE:                   // AspCodepage
            case MD_ASP_ENABLEAPPLICATIONRESTART:   // AspEnableApplicationRestart
                ++cUpdates;
                IF_DEBUG( CACHE) {
                    DBGPRINTF(( DBG_CONTEXT,
                                "Updating ETag Change Number for notification %d\n",
                                pcoChangeList[i].pdwMDDataIDs[j]
                                ));
                }
                goto endloop;

            default:
                break;
            }
        }
    }

  endloop:
    if (cUpdates > 0)
    {
        m_pParent->UpdateChangeNumber();
    }
    else
    {
        IF_DEBUG( CACHE) {
            DBGPRINTF(( DBG_CONTEXT,
                        "SinkNotify: not interested in %d changes\n", 
                        dwMDNumElements
                        ));
        }
    }

    return S_OK;
}


ETagChangeNumber::ETagChangeNumber()
    : m_pSink(NULL),
      m_pcAdmCom(NULL),
      m_pConnPoint(NULL),
      m_pConnPointContainer(NULL),
      m_dwSinkNotifyCookie(0),
      m_fChanged(FALSE)
{
    m_dwETagMetabaseChangeNumber = GetETagChangeNumberFromMetabase();
    m_pSink = new ETagMetabaseSink(this);

    HRESULT hr = (m_pSink != NULL) ? S_OK : E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_MSAdminBase_W, NULL, CLSCTX_ALL, 
                              IID_IMSAdminBase, (void**) &m_pcAdmCom);
        if (FAILED(hr))
        {
            DBGERROR(( DBG_CONTEXT,
                       "CCI(CLSID_MSAdminBase_W) failed: err %x\n", 
                       hr
                       ));
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pcAdmCom->QueryInterface(IID_IConnectionPointContainer,
                                        (void**) &m_pConnPointContainer);
        if (FAILED(hr))
        {
            DBGERROR(( DBG_CONTEXT,
                       "QI(IConnectionPointContainer failed): %x\n", 
                       hr
                       ));
        }
    }
    
    if (SUCCEEDED(hr))
    {
        hr = m_pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink_W,
                                                        &m_pConnPoint);
        if (FAILED(hr))
        {
            DBGERROR(( DBG_CONTEXT,
                       "FindConnectionPoint failed: err %x\n", 
                       hr
                       ));
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pConnPoint->Advise(m_pSink, &m_dwSinkNotifyCookie);
        if (FAILED(hr))
        {
            DBGERROR(( DBG_CONTEXT,
                       "Advise failed: err %x\n", 
                       hr 
                       ));
        }
    }

    if (FAILED(hr))
    {
        Cleanup();
    }
    else
    {
        DBGERROR(( DBG_CONTEXT,
                   "Created ETagChangeNumber successfully, %d\n",
                   m_dwETagMetabaseChangeNumber
                   ));
    }
}


ETagChangeNumber::~ETagChangeNumber()
{
    if (m_fChanged)
        SetETagChangeNumberInMetabase(m_dwETagMetabaseChangeNumber);
    Cleanup();
}


void
ETagChangeNumber::Cleanup()
{
    if (m_pConnPoint != NULL)
    {
        if (m_dwSinkNotifyCookie != 0)
            m_pConnPoint->Unadvise(m_dwSinkNotifyCookie);
        
        m_pConnPoint->Release();
    }
    m_dwSinkNotifyCookie = 0;
    m_pConnPoint = NULL;

    if (m_pConnPointContainer != NULL)
        m_pConnPointContainer->Release();
    m_pConnPointContainer = NULL;

    if (m_pcAdmCom != NULL)
        m_pcAdmCom->Release();
    m_pcAdmCom = NULL;

    if (m_pSink != NULL)
        m_pSink->Release();
    m_pSink = NULL;

    m_fChanged = FALSE;
}


//
// Read the ETag Metabase Change Number from the metabase
//
DWORD
ETagChangeNumber::GetETagChangeNumberFromMetabase()
{
    MB    mb((IMDCOM*) IIS_SERVICE::QueryMDObject());
    DWORD dwETagMetabaseChangeNumber;

    mb.GetSystemChangeNumber(&dwETagMetabaseChangeNumber);

    if (mb.Open(IIS_MD_LOCAL_MACHINE_PATH "/w3svc", METADATA_PERMISSION_READ))
    {
         if (mb.GetDword("", MD_ETAG_CHANGE_NUMBER, IIS_MD_UT_SERVER,
                         &dwETagMetabaseChangeNumber))
         {
            IF_DEBUG( CACHE) {
                DBGPRINTF(( DBG_CONTEXT,
                            "ETag Change Number = %x.\n",
                            dwETagMetabaseChangeNumber
                            ));
            }
         }
         else
         {
            IF_DEBUG( CACHE) {
                DBGPRINTF(( DBG_CONTEXT,
                            "No ETag Change Number. Using %d. Error = %lu\n",
                            dwETagMetabaseChangeNumber, 
                            GetLastError()
                            ));
            }
         }
         mb.Close();
    }
    else
    {
        DBGERROR(( DBG_CONTEXT,
                   "Couldn't open metabase. Using %x instead. Error = %lu.\n",
                   dwETagMetabaseChangeNumber, 
                   GetLastError()
                   ));
    }

    return dwETagMetabaseChangeNumber;
}


//
// Persist the ETag Metabase Change Number to the metabase
//
BOOL
ETagChangeNumber::SetETagChangeNumberInMetabase(
    DWORD dwETagMetabaseChangeNumber)
{
    MB   mb((IMDCOM*) IIS_SERVICE::QueryMDObject());
    BOOL fSuccess = FALSE;
    
    if (mb.Open(IIS_MD_LOCAL_MACHINE_PATH "/w3svc", METADATA_PERMISSION_WRITE))
    {
        if (mb.SetDword("", MD_ETAG_CHANGE_NUMBER, IIS_MD_UT_SERVER,
                        dwETagMetabaseChangeNumber))
        {
            fSuccess = TRUE;
            IF_DEBUG( CACHE) {
                DBGPRINTF(( DBG_CONTEXT,
                            "Updated ETag Metabase Change Number to %x.\n",
                            dwETagMetabaseChangeNumber
                            ));
            }
        }
        else
        {
            IF_DEBUG( CACHE) {
                DBGPRINTF(( DBG_CONTEXT,
                            "Unable to update ETag Metabase Change Number to %x.\n",
                            dwETagMetabaseChangeNumber
                            ));
            }
        }
        mb.Close();
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache2\dirlist.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        dirlist.cxx

   Abstract:
        This module implements the member functions for TS_DIRECTORY_INFO

   Author:

           Murali R. Krishnan    ( MuraliK )     16-Jan-1995

   Project:

          Tsunami Lib
          ( Common caching and directory functions for Internet Services)

   Functions Exported:

         TS_DIRECTORY_INFO::CleanupThis()

         TS_DIRECTORY_INFO::GetDirectoryListingA()
                       IN LPCSTR     pszDirectoryName,
                       IN  HANDLE    hListingUser)

         TS_DIRECTORY_INFO::SortFileInfoPointers(
                       IN PFN_CMP_WIN32_FIND_DATA pfnCompare)

         TS_DIRECTORY_INFO::FilterFiles(
                       IN PFN_IS_MATCH_WIN32_FIND_DATA  pfnMatch,
                       IN LPVOID     pContext);

   Revision History:
       MuraliK     06-Dec-1995  Used Win32 apis instead of NT apis
       MCourage    05-Jan-1997  Moved to cache2 directory

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <tsunami.hxx>
# include "tsunamip.hxx"
# include "dbgutil.h"
# include <string.h>

/************************************************************
 *     Type Definitions
 ************************************************************/


dllexp
VOID
TS_DIRECTORY_INFO::CleanupThis( VOID)
{
    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Cleaning up TS_DIRECTORY_INFO ( %08p)\n",
                    this));
        Print();
    }

    if ( m_fValid) {

        if ( m_pTsDirectoryHeader != NULL) {

            TsFreeDirectoryListing( m_tsCache, m_pTsDirectoryHeader);
            m_pTsDirectoryHeader = NULL;
        }

        ASSERT( m_pTsDirectoryHeader == NULL);

        if ( m_prgFileInfo != NULL) {
            FREE( m_prgFileInfo);
            m_prgFileInfo = NULL;
        }
    }

    ASSERT( m_pTsDirectoryHeader == NULL);
    ASSERT( m_prgFileInfo == NULL);
    m_fValid = 0;
    m_cFilesInDirectory = 0;

} // TS_DIRECTORY_INFO::CleanupThis()




static BOOL
MakeCopyOfFileInfoPointers(
   IN OUT   PWIN32_FIND_DATA ** pppFileInfoTo,
   IN const PWIN32_FIND_DATA  * ppFileInfoFrom,
   IN int  nEntries)
/*++
  Allocates memory and makes a copy of the file info pointers in the array
   in ppFileInfoFrom.

  Returns:
    TRUE if success and FALSE if there is any failure.
--*/
{
    DWORD cbCopy;

    ASSERT( *pppFileInfoTo == NULL);

    cbCopy = nEntries * sizeof( PWIN32_FIND_DATA);

    *pppFileInfoTo = (PWIN32_FIND_DATA *) ALLOC( cbCopy);

    if ( *pppFileInfoTo != NULL) {

        memcpy((PVOID ) *pppFileInfoTo,
               (const PVOID ) ppFileInfoFrom,
               cbCopy);

    } else {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
    }

    return ( *pppFileInfoTo != NULL);
} // MakeCopyOfFileInfoPointers()




dllexp
BOOL
TS_DIRECTORY_INFO::GetDirectoryListingA(
    IN  LPCSTR          pszDirectoryName,
    IN  HANDLE          hListingUser)
{
    if ( m_pTsDirectoryHeader == NULL) {

        //
        //  Only if already a directory listing is not obtained.
        //  we obtain newly
        //

        IF_DEBUG( DIR_LIST) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "Obtaining Dir Listing for %s. UserHandle=%08p.\n",
                        pszDirectoryName, hListingUser));
        }

        m_fValid = TsGetDirectoryListing( m_tsCache,
                                           pszDirectoryName,
                                           hListingUser,
                                           &m_pTsDirectoryHeader);

        m_fValid = m_fValid &&
                   MakeCopyOfFileInfoPointers(
                       &m_prgFileInfo,
                       m_pTsDirectoryHeader->QueryArrayOfFileInfoPointers(),
                       m_pTsDirectoryHeader->QueryNumEntries());

        m_cFilesInDirectory = ( m_pTsDirectoryHeader == NULL) ? 0 :
                               m_pTsDirectoryHeader->QueryNumEntries();
    }

    return ( m_fValid);
} // TS_DIRECTORY_INFO::GetDirectoryListingA()




dllexp
BOOL
TS_DIRECTORY_INFO::SortFileInfoPointers(
    IN PFN_CMP_WIN32_FIND_DATA pfnCompare)
{
    BOOL  fReturn = FALSE;

    if ( IsValid()) {

        fReturn = SortInPlaceFileInfoPointers(m_prgFileInfo,
                                              m_cFilesInDirectory,
                                              pfnCompare);
    }

    return ( fReturn);
} // TS_DIRECTORY_INFO::SortFileInfoPointers()




dllexp
BOOL
TS_DIRECTORY_INFO::FilterFiles( IN PFN_IS_MATCH_WIN32_FIND_DATA  pfnMatch,
                                IN LPVOID  pContext)
/*++
  This function filters the list of files using the pfnMatch function
        and the context information specified by pContext.
  This function eliminates all the pointers to FileInfo which do not
    match the given file specification.

  Returns:
    TRUE on success and FALSE on failure.
--*/
{
    BOOL fReturn = FALSE;

    if ( IsValid()) {

        int idxScan;      // for scanning the files
        int idxCur;       // for updating after filter

        IF_DEBUG( DIR_LIST) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "FilterFiles in DirList( %08p) for FileSpec %08p\n",
                        this, pContext));
        }

        for( idxCur = idxScan = 0;
            idxScan < m_cFilesInDirectory;
            idxScan++) {

            PWIN32_FIND_DATA   pFileInfo =
               GetFileInfoPointerFromIdx( idxScan);

            ASSERT( pFileInfo != NULL);
            ASSERT( idxCur <= idxScan);

            if ( (*pfnMatch)( pFileInfo, pContext)) {

                //
                //  this is a match. Retain this item and advance CurPtr
                //
                m_prgFileInfo[ idxCur++] = m_prgFileInfo[ idxScan];
            }
        } // for

        m_cFilesInDirectory = idxCur;
        fReturn = TRUE;
    }

    return ( fReturn);
} // TS_DIRECTORY_INFO::FilterFiles()




# if DBG

VOID
TS_DIRECTORY_INFO::Print( VOID) const
{

    DBGPRINTF( ( DBG_CONTEXT,
                " Printing TS_DIRECTORY_INFO ( %08p).\n"
                "NumEntries=%d\t Valid = %d\n"
                "Directory Header ( %08p) \t ArrayOfFileInfo = %08p\n",
                this,
                m_cFilesInDirectory, m_fValid,
                m_pTsDirectoryHeader, m_prgFileInfo));

    for( int idx  = 0; idx < m_cFilesInDirectory; idx++) {

        PWIN32_FIND_DATA pfi = m_prgFileInfo[idx];

        DBGPRINTF( ( DBG_CONTEXT,
                    "rgFileInfo[%4d] = %08p. Name=%s Attr=0x%x"
                    "Size=0x%x:%x\n",
                    idx, pfi,
                    pfi->cFileName,
                    pfi->dwFileAttributes,
                    pfi->nFileSizeHigh,
                    pfi->nFileSizeLow
                    ));
    }

    m_pTsDirectoryHeader->Print();

    return;
} // TS_DIRECTORY_INFO::Print()


# endif // DBG




BOOL __cdecl
RegExpressionMatchFileInfo( IN const WIN32_FIND_DATA  * pFileInfo,
                            IN CHAR * pszExpression)
/*++
  This function tries to find a match between the file name in
  pFileInfo and the regular expression specified in pszExpression.

  Arguments:
     pFileInfo  -- pointer to file information consisting under query.
     pszExpression - pointer to null-terminated string containing the
                      regular expression, against which file name is tobe
                      matched for.

  Returns:
    TRUE on a match and false if there is any failure.
--*/
{
    const CHAR * pszFileName;

    DBG_ASSERT( pFileInfo != NULL);
    pszFileName = pFileInfo->cFileName;

    if ( strpbrk( pszExpression, "?*<>") != NULL) {

        // No Wild cards. Do normal file comparisons
        return ( strcmp( pszFileName, pszExpression) == 0);
    } else {

        // do a case sensitive comparison
        return IsNameInRegExpressionA( pszExpression, pszFileName, FALSE);
    }

} // RegExpressionMatch()





/************************************************************
 *  Following code is based on the FileSystem Rtl routines
 *    from ntos\fsrtl\name.c
 *  But these are optimized for performance, in our case
 *    using ANSI strings!
 ************************************************************/

# define MAX_MATCHES_ARRAY_SIZE    (16)
# define IS_EMPTY_STRING(psz)      ( (psz) == NULL || *(psz) == '\0')


//
// Original code used USHORT for ULEN. However using USHORT asks
//  a 32 bit processor to add  "and <value>, 0xff for each instruction
//  that accessed the 16 bit (USHORT) value.
// Hence, I decided to use DWORD, since the space usage is not tremendous
//   during the fast path work, compared to performance benefits.
//  - MuraliK (Oct 27, 1995)
//

//  typedef  USHORT  ULEN;
typedef DWORD ULEN;


BOOL __cdecl
IsNameInRegExpressionA(
    IN LPCSTR   pszExpression,
    IN LPCSTR   pszName,
    IN BOOL     fIgnoreCase)
/*++
  This routine compares an ANSI name and an expression and decries to the
  caller if the name is in hte language defined by the expression. The input
  name cannot contain wildcards, while the expression itself may contain
  wildcards.

  Expression wild cards are evaluated as shown in the non-deterministic finite
   automatons below. Note that ~* and ~? stand for DOS_STAR and DOS_QM.


             ~* is DOS_STAR, ~? is DOS_QM, and ~. is DOS_DOT


                                       S
                                    <-----<
                                 X  |     |  e       Y
             X * Y ==       (0)----->-(1)->-----(2)-----(3)


                                      S-.
                                    <-----<
                                 X  |     |  e       Y
             X ~* Y ==      (0)----->-(1)->-----(2)-----(3)



                                X     S     S     Y
             X ?? Y ==      (0)---(1)---(2)---(3)---(4)



                                X     .        .      Y
             X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^


                                X     S-.     S-.     Y
             X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^



         where S is any single character

               S-. is any single character except .

               e is a null character transition

               EOF is the end of the name string


    The last construction, ~? (the DOS question mark), can either match any
    single character, or upon encountering a period or end of input string,
    advances the expression to the end of the set of contiguous ~?s.  This may
    seem somewhat convoluted, but is what DOS needs.

  Arguments:
    pszExpression - Supplies the input expression to check against
     ( Caller must already lowercased if passing fIgnoreCase TRUE.)

    pszName  - supplies the input name to check for.

    fIgnoreCase - if TRUE, the name should be lower-cased before comparing.
     ( that is done by this function, dynamically without destroying pszName)

    This function is costly, if the pszExpression does not contain
      any wild cards to be matched for. So Dont use it if there are
      no wild cards in the pszExpression

  Returns:
     BOOL  -- TRUE if pszName is an element in the set of strings denoted
        by the input expression.  FALSE if otherwise.
--*/
{
    ULEN    NameLen;       // length in character count
    ULEN    ExprLen;

    /*
     * Algorithm:
     *  Keep track of all possible locations in the regular expression
     *   that are matching the name. If when the name has been exhausted
     *   one of the locations in the expression is also just exhausted, the
     *  name is in the language defined by the regular expression.
     */


    DBG_ASSERT( pszName != NULL && *pszName != '\0');
    DBG_ASSERT( pszExpression != NULL && *pszExpression != '\0');

    //
    // if one string is empty return FALSE. If both are empty TRUE.
    //

    if ( IS_EMPTY_STRING(pszName) || IS_EMPTY_STRING(pszExpression)) {

        IF_DEBUG( DIR_LIST) {
            DBGPRINTF((DBG_CONTEXT, " IsNameInRegExpr( %s, %s, %d) ==>%d\n",
                       pszExpression, pszName, fIgnoreCase,
                       !(*pszName + *pszExpression)
                       ));
        }

        return (BOOL ) (IS_EMPTY_STRING(pszName) && IS_EMPTY_STRING(pszExpression));
    }

    NameLen = strlen(pszName);
    ExprLen = strlen(pszExpression);

    //
    // Special case: reduce the most common wild card search of *
    //

    if ( ExprLen == 1 && pszExpression[0] == '*') {

        IF_DEBUG ( DIR_LIST) {
            DBGPRINTF((DBG_CONTEXT, " IsNameInRegExpr( %s, %s, %d) ==>%d\n",
                       pszExpression, pszName, fIgnoreCase,
                       TRUE
                       ));
        }

        // matches anything. so return TRUE
        return (TRUE);
    }

    //
    //  Walk through the name string, picking off characters.  We go one
    //  character beyond the end because some wild cards are able to match
    //  zero characters beyond the end of the string.
    //
    //  With each new name character we determine a new set of states that
    //  match the name so far.  We use two arrays that we swap back and forth
    //  for this purpose.  One array lists the possible expression states for
    //  all name characters up to but not including the current one, and other
    //  array is used to build up the list of states considering the current
    //  name character as well.  The arrays are then switched and the process
    //  repeated.
    //
    //  There is not a one-to-one correspondence between state number and
    //  offset into the pszExpression.  This is evident from the NFAs in the
    //  initial comment to this function.  State numbering is not continuous.
    //  This allows a simple conversion between state number and expression
    //  offset.  Each character in the Expression can represent one or two
    //  states.  '*' and DOS_STAR generate two states: ExprOffset*2 and
    //  ExprOffset*2 + 1.  All other expression characters can produce only
    //  a single state.  Thus ExprOffset = State/2.
    //
    //
    //  Here is a short description of the variables involved:
    //
    //  NameOffset  -The offset of the current name char being processed.
    //
    //  ExprOffset  -The offset of the current expression char being processed.
    //
    //  SrcCount    -Prior match being investigated with current name char
    //
    //  DestCount   -Next location to put a matching assuming current name char
    //
    //  NameFinished - Allows one more iteration through the Matches array
    //                 after the name is exhusted (to come *s for example)
    //
    //  PreviousDestCount - This is used to prevent entry duplication,
    //                       see comment
    //
    //  PreviousMatches   - Holds the previous set of matches (the Src array)
    //
    //  CurrentMatches    - Holds the current set of matches (the Dest array)
    //
    //  AuxBuffer, LocalBuffer - the storage for the Matches arrays
    //

    ULEN NameOffset;    // offset in terms of byte count
    ULEN ExprOffset;    // offset in terms of byte count

    ULONG SrcCount;
    ULONG DestCount;
    ULONG PreviousDestCount;
    ULONG MatchesCount;
    ULONG BufSize = MAX_MATCHES_ARRAY_SIZE;

    CHAR NameChar, ExprChar;

    // for prev and current matches
    ULEN *AuxBuffer = NULL;
    ULEN *PreviousMatches;
    ULEN *CurrentMatches;

    ULEN MaxState;
    ULEN CurrentState;

    BOOL NameFinished;

    ULEN LocalBuffer[MAX_MATCHES_ARRAY_SIZE * 2];

    // set up the intial values
    // Use the different portions of local buffer for matches.

    PreviousMatches = &LocalBuffer[0];
    CurrentMatches  = &LocalBuffer[MAX_MATCHES_ARRAY_SIZE];

    PreviousMatches[0] = 0;
    MatchesCount       = 1;

    NameOffset = 0;
    MaxState   = (ULEN ) (ExprLen * 2);

    NameFinished = FALSE;
    while (!NameFinished) {


        if ( NameOffset < NameLen) {

            NameChar = pszName[NameOffset/sizeof(CHAR)];
            NameOffset += sizeof(CHAR);
        } else {

            NameFinished = TRUE;

            // if we already exhauseted expression, stop. Else continue
            DBG_ASSERT( MatchesCount >= 1);
            if ( PreviousMatches[MatchesCount - 1] == MaxState) {

                break;
            }
        }

        //
        // Now, for each of previous stored expression matches,
        //  see what we can do with the new name character.
        //

        DestCount = 0;
        PreviousDestCount = 0;

        for( SrcCount = 0;  SrcCount < MatchesCount; ) {

            ULEN Length;

            //
            //  We have to carry on our expression analysis as far as possible
            //  for each character of name, so we loop here until the
            //  expression stops matching.  A clue here is that expression
            //  cases that can match zero or more characters end with a
            //  continue, while those that can accept only a single character
            //  end with a break.
            //

            ExprOffset = (ULEN)((PreviousMatches[SrcCount++] + 1) / 2);

            for( Length = 0; ExprOffset != ExprLen; ) {

                //
                // increment the expression offset to move to next character.
                //
                ExprOffset += Length;
                Length = sizeof(CHAR);

                CurrentState = (ULEN)(ExprOffset * 2);

                if ( ExprOffset == ExprLen * sizeof(CHAR)) {

                    CurrentMatches[DestCount++] = MaxState;
                    break;
                }

                ExprChar = pszExpression[ ExprOffset/sizeof(CHAR) ];

                ASSERT( !fIgnoreCase ||
                        !((ExprChar >= 'A') && (ExprChar <= 'Z')));

                //
                // Before we get started, we have to check for something really
                //  gross. We may be about to exhaust the local space for
                //  ExpressionMatch[][], so when we have to allocate some
                //   pool if this is the case. Yuk!
                //

                if ( DestCount >= BufSize - 2 ) {

                    if (AuxBuffer == NULL) {

                        // 2 copies of array each with 2 states for each char
                        //  in the expression. Each state == ULEN.

                        IF_DEBUG( DIR_LIST) {
                            DBGPRINTF((DBG_CONTEXT, "IsNInExpr(%s,%s,%d):"
                                       "alloc %d for exprlen=%d\n",
                                       pszExpression, pszName, fIgnoreCase,
                                       (ExprLen + 1) *sizeof(ULEN)*2*2,
                                       ExprLen));
                        }

                        BufSize = (ExprLen+1)*2;

                        AuxBuffer = ((ULEN *)
                                     ALLOC(BufSize * sizeof(ULEN) * 2)
                                     );
                        if ( AuxBuffer == NULL) {

                            DBG_ASSERT(!"Failure in mem alloc");

                            return ( FALSE);
                        }

                        RtlCopyMemory( AuxBuffer, CurrentMatches,
                                      MAX_MATCHES_ARRAY_SIZE*sizeof(ULEN));
                        CurrentMatches = AuxBuffer;

                        RtlCopyMemory( AuxBuffer + BufSize,
                                      PreviousMatches,
                                      MAX_MATCHES_ARRAY_SIZE * sizeof(ULEN));

                        PreviousMatches = AuxBuffer + BufSize;
                    } else {

                        DBG_ASSERT(!"Double Overflow occured\n");

                        FREE( AuxBuffer );

                        return FALSE;
                    }
                }

                //
                // '*' Matches any character zero or more times
                //
                if ( ExprChar == '*') {

                    // Add all possible next states into the list
                    // use the above state diagram to identify this.
                    CurrentMatches[DestCount] = CurrentState;
                    CurrentMatches[DestCount+1] = CurrentState + 1;
                    DestCount+= 2;
                    continue;
                }

                //
                // ANSI_DOS_STAR matches any char, zero or more times,
                //  except the DOS's extension '.'
                //

                if ( ExprChar == ANSI_DOS_STAR) {

                    BOOL  ICanEatADot = FALSE;

                    //
                    // If we are at a period, determine if we are
                    //  allowed to consume it. i.e make it is not last one.
                    //
                    if ( !NameFinished && (NameChar == '.')) {

                        ULEN cchOffset;  // in character counts
                        for( cchOffset = NameOffset/sizeof(CHAR);
                            cchOffset < NameLen;
                            cchOffset ++) {

                            if ( pszName[cchOffset]  == '.') {

                                ICanEatADot = TRUE;
                                break;
                            }
                        } // for
                    }

                    if ( NameFinished || (NameChar != '.') || ICanEatADot) {

                        //
                        // Go ahead and consume this character.
                        // Gives two options to move forward.
                        //
                        CurrentMatches[DestCount] = CurrentState;
                        CurrentMatches[DestCount+1] = CurrentState+1;
                        DestCount += 2;
                        continue;
                    } else {

                        //
                        // We are at the period. We can only match zero
                        //  or more characters (ie. the epsilon transition)
                        //

                        CurrentMatches[DestCount++] = CurrentState+1;
                        continue;
                    }
                } // if ( ExprChar == DOS_STAR)

                //
                // The following expression characters all match by consuming
                //  a character, thus force the expression, and thus state
                //  move forward.
                //

                CurrentState += (ULEN)(sizeof(CHAR) *2);

                //
                //  DOS_QM is the most complicated.  If the name is finished,
                //  we can match zero characters.  If this name is a '.', we
                //  don't match, but look at the next expression.  Otherwise
                //  we match a single character.
                //

                if ( ExprChar == ANSI_DOS_QM ) {

                    if ( NameFinished || (NameChar == '.') ) {

                        continue;
                    }

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  DOS_DOT can match either a period, or zero characters
                //  beyond the end of the name
                //

                if ( ExprChar == ANSI_DOS_DOT) {

                    if ( NameFinished) {
                        continue;
                    }

                    if ( NameChar == '.') {

                        CurrentMatches[DestCount++] = CurrentState;
                        break;
                    }
                }

                //
                // From this point on a name character is required to
                //  even continue searching, let alone make a match.
                // So if Name is finished, stop.
                //

                if ( NameFinished) {

                    break;
                }

                //
                // If the expression was a '?' we can match it once
                //
                if ( ExprChar == '?') {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                // Finally, check if the expression char matches name char
                //

                if ( ExprChar == (CHAR ) (fIgnoreCase ?
                                          tolower(NameChar) : NameChar)
                    ){

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                // The expression did not match, go look at the next
                //  previous match
                //
                break;
            } // for matching from an old state.


            //
            //  Prevent duplication in the destination array.
            //
            //  Each of the arrays is montonically increasing and non-
            //  duplicating, thus we skip over any source element in the src
            //  array if we just added the same element to the destination
            //  array.  This guarentees non-duplication in the dest. array.
            //

            while ( SrcCount < MatchesCount &&
                   PreviousDestCount < DestCount) {
                //
                // logic here is: by eliminating the states with
                //  lesser number than current matched ==> we are
                //  skipping over the smallest states from which
                //  no match may be found.
                //

                if ( PreviousMatches[SrcCount] <
                    CurrentMatches[PreviousDestCount] ) {

                    SrcCount ++;
                }

                PreviousDestCount += 1;
            } // while
        } // for each of old matches....

        //
        //  If we found no matches in the just finished iteration, it's time
        //  to bail.
        //

        if ( DestCount == 0 ) {

            if (AuxBuffer != NULL) {
                IF_DEBUG( DIR_LIST) {

                    DBGPRINTF((DBG_CONTEXT, " Freeing %08p\n", AuxBuffer));
                }

                FREE( AuxBuffer );
            }

            return FALSE;
        }

        //
        //  Swap the meaning the two arrays
        //

        {
            ULEN *Tmp;

            Tmp = PreviousMatches;

            PreviousMatches = CurrentMatches;

            CurrentMatches = Tmp;
        }

        MatchesCount = DestCount;

    } // for each char in Name, until name is finished.

    DBG_ASSERT(MatchesCount > 0);
    CurrentState = PreviousMatches[MatchesCount-1];
    if (AuxBuffer != NULL) {
        IF_DEBUG( DIR_LIST) {
            DBGPRINTF((DBG_CONTEXT, " Freeing %08p\n", AuxBuffer));
        }

        FREE( AuxBuffer );
    }

    return (BOOL ) ( CurrentState == MaxState);

} //  IsNameInRegExpressionA()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache2\dirlistp.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        getdirp.cxx

   Abstract:
        This module implements the functions for getting directory listings
         and transparently caching them.
        ( This uses OS specific functions to obtain the directory).

   Author:

           Murali R. Krishnan    ( MuraliK )     13-Jan-1995

   Project:

          Tsunami Lib
          ( Common caching and directory functions for Internet Services)

   Functions Exported:
   BOOL TsGetDirectoryListing()
   BOOL TsFreeDirectoryListing()
   int __cdecl
   AlphaCompareFileBothDirInfo(
              IN const void *   pvFileInfo1,
              IN const void *   pvFileInfo2)

   TS_DIRECTORY_HEADER::ReadWin32DirListing( IN LPCSTR pszDirectoryName)

   TS_DIRECTORY_HEADER::ReadFromNtDirectoryFile(
                  IN LPCWSTR          pwszDirectoryName
                  )
   TS_DIRECTORY_HEADER::BuildFileInfoPointers(
                  IN LPCWSTR          pwszDirectoryName
                  )
   TS_DIRECTORY_HEADER::CleanupThis()

   Revision History:
       MuraliK     06-Dec-1995  Used Win32 apis instead of NT apis
       MCourage    09-Jan-1998  Stopped caching directory information
                                Removed "guardian blobs"

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "tsunamip.hxx"

# include <stdlib.h>
# include <string.h>
# include <dbgutil.h>

/************************************************************
 *     Type Definitions
 ************************************************************/

# define DBGCODE(s)      DBG_CODE(s)

#define DIRECTORY_BUFFER_SIZE 8160          /* < 8192 bytes */

/************************************************************
 *    Functions
 ************************************************************/


BOOL FreeDirectoryHeaderContents( PVOID pvOldBlock );

PTS_DIRECTORY_HEADER
TsGetFreshDirectoryHeader(
     IN const TSVC_CACHE  &  tsCache,
     IN LPCSTR               pszDirectoryName,
     IN HANDLE               hLisingUser);



dllexp
BOOL
TsGetDirectoryListing(
    IN const TSVC_CACHE         &tsCache,
    IN      PCSTR               pszDirectoryName,
    IN      HANDLE              hListingUser,
    OUT     PTS_DIRECTORY_HEADER * ppTsDirectoryHeader
    )
/*++
  This function obtains the directory listing for dir specified
        in pszDirectoryName.

  Arguments:
    tsCache          Cache structure which is used for lookup
    pszDirectoryName  pointer to string containing the directory name
    ListingUser        Handle for the user opening the directory
    ppTsDirectoryHeader
       pointer to pointer to class containing directory information.
       Filled on successful return. On failure this will be NULL

  Returns:
      TRUE on success and FALSE if  there is a failure.
--*/
{
    PVOID          pvBlob = NULL;
    ULONG          ulSize = 0;
    BOOL           bSuccess;

    ASSERT( pszDirectoryName   != NULL );
    ASSERT( ppTsDirectoryHeader != NULL);


    //
    //  First, check to see if we have already cached a listing of this
    //  directory.
    //

    *ppTsDirectoryHeader = NULL;

//
// Dont try to cache directory listings
//
//    bSuccess = TsCheckOutCachedBlob(  tsCache,
//                                       pszDirectoryName,
//                                       RESERVED_DEMUX_DIRECTORY_LISTING,
//                                       ( PVOID * )&pvBlob,
//                                       &ulSize );
    bSuccess = FALSE;


    //
    //  The block was not present in cache.
    //  Obtain a fresh copy of the directory listing and cache it.
    //

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( (DBG_CONTEXT,
                    "Missing DirListing (%s) in cache. Generating newly\n",
                    pszDirectoryName));
    }

    *ppTsDirectoryHeader = TsGetFreshDirectoryHeader(
                                                      tsCache,
                                                      pszDirectoryName,
                                                      hListingUser );


    bSuccess = ( *ppTsDirectoryHeader != NULL);

    IF_DEBUG( DIR_LIST) {

        DBGCODE(
            CHAR pchBuff[600];
            wsprintfA( pchBuff,
                      "Obtained DirListing (%s). NEntries = %d\n",
                      pszDirectoryName,
                      (*ppTsDirectoryHeader)->QueryNumEntries());
            OutputDebugString( pchBuff);
        );
    }

    return ( bSuccess);

} // TsGetDirectoryListing()




dllexp
BOOL
TsFreeDirectoryListing
(
    IN const TSVC_CACHE &    tsCache,
    IN PTS_DIRECTORY_HEADER  pDirectoryHeader
)
{
    BOOL fReturn;
    BOOL fCached = pDirectoryHeader->IsCached;

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "TsFreeDirectoryListing( %08p) called. Cached = %d\n",
                    pDirectoryHeader,
                    fCached));

        pDirectoryHeader->Print();
    }

    if ( fCached )
    {
        fReturn = TsCheckInCachedBlob( ( PVOID )pDirectoryHeader );
    }
    else
    {
        fReturn = TsFree( tsCache, ( PVOID )pDirectoryHeader );
    }

    return( fReturn);
} // TsFreeDirectoryListing()







PTS_DIRECTORY_HEADER
TsGetFreshDirectoryHeader(
     IN const TSVC_CACHE  &  tsCache,
     IN LPCSTR               pszDirectoryName,
     IN HANDLE               hListingUser)
/*++

  This function obtains a fresh copy of the directory listing for the
    directory specified and caches it if possible, before returning pointer
    to the directory information.

  Returns:
     On success it returns the pointer to newly constructed directory listing.
     On failure this returns a NULL

--*/
{
    PTS_DIRECTORY_HEADER pDirectoryHeader;
    PVOID               pvGuardBlob;
    BOOL                bSuccess;
    BOOL                bCachedGuardianBlob;

#ifdef TS_USE_DIRECTORY_GUARD
    //
    //  If we are going to cache this directory, we would like to increase the
    //  likelihood that it is an "atomic" snapshot.  This is done as follows:
    //
    //  We cache and hold checked-out a small blob while create the directory
    //  listing.  If that Blob (1) could not be cached, or (2) was ejected
    //  from the cache while we were generating a listing, then we do not
    //  attempt to cache the directory.
    //
    //  Reasoning:
    //
    //  1) If the Blob couldn't be cached then the directory info won't be any
    //     different.
    //
    //  2) If the Blob was ejected, the directory must have changed while we
    //     were reading it.  If this happens, we don't want to cache possibly
    //     inconsistent data.
    //
    //  If the directory changed and the Blob has not yet been ejected, the
    //  directory will soon be ejected anyway.  Notice that the Blob is not
    //  DeCache()'d until after the directory has been cached.
    //

    if ( !TsAllocate( tsCache, sizeof( TS_DIRECTORY_HEADER),
                     (PVOID *) &pvGuardBlob)) {

        //
        //  Failure to allocate and secure a guardian blob.
        //

        IF_DEBUG( DIR_LIST) {

            DBGPRINTF( (DBG_CONTEXT,
                        "Allocation of Guardianblob for %s failed. Error=%d\n",
                        pszDirectoryName, GetLastError()));
        }

        return ( NULL);
    }

    //
    //  A successful guardian block allocated. Try and cache it.
    //

    ULONG cchDirectoryName = strlen(pszDirectoryName);

    bCachedGuardianBlob = TsCacheDirectoryBlob(
                              tsCache,
                              pszDirectoryName,
                              cchDirectoryName,
                              RESERVED_DEMUX_ATOMIC_DIRECTORY_GUARD,
                              pvGuardBlob,
                              TRUE );

    if ( !bCachedGuardianBlob ) {

        BOOL  fFreed;

        //
        //  Already there is one such cached blob. ignore this blob.
        //  So free up the space used.
        //

        fFreed = TsFree( tsCache, pvGuardBlob );
        ASSERT( fFreed);
        pvGuardBlob = NULL;
    }
#endif // TS_USE_DIRECTORY_GUARD

    //
    // Allocate space for Directory listing
    //

    bSuccess = TsAllocateEx( tsCache,
                            sizeof( TS_DIRECTORY_HEADER ),
                            ( PVOID * )&pDirectoryHeader,
                            FreeDirectoryHeaderContents );

    if ( bSuccess) {

        BOOL fReadSuccess;
        DWORD cbBlob = 0;

        ASSERT( pDirectoryHeader != NULL);

        pDirectoryHeader->ReInitialize();  // called since we raw alloced space
        pDirectoryHeader->SetListingUser( hListingUser);

        fReadSuccess = (pDirectoryHeader->ReadWin32DirListing(pszDirectoryName,
                                                               &cbBlob ) &&
                        pDirectoryHeader->BuildFileInfoPointers( &cbBlob )
                        );

        if ( fReadSuccess) {
#if TS_USE_DIRECTORY_GUARD
            //
            //  Attempt and cache the blob if the blob size is cacheable
            //

            if ( bCachedGuardianBlob &&
                 !BLOB_IS_EJECTATE( pvGuardBlob )  ) {


                ASSERT( BLOB_IS_OR_WAS_CACHED( pvGuardBlob ) );

                bSuccess =
                  TsCacheDirectoryBlob(tsCache,
                                        pszDirectoryName,
                                        cchDirectoryName,
                                        RESERVED_DEMUX_DIRECTORY_LISTING,
                                        pDirectoryHeader,
                                        TRUE );

                if ( bSuccess ) {

                    INC_COUNTER( tsCache.GetServiceId(), CurrentDirLists );
                }

                //
                // Even if caching of the blob failed, that is okay!
                //

                if ( bSuccess && BLOB_IS_EJECTATE( pvGuardBlob ) ) {

                    TsExpireCachedBlob( tsCache, pDirectoryHeader );
                }

            }

#endif // TS_USE_DIRECTORY_GUARD

        } else {

            //
            // Reading directory failed.
            //  cleanup directory related data and get out.
            //

            BOOL fFreed = TsFree( tsCache, pDirectoryHeader);
            ASSERT( fFreed);
            pDirectoryHeader = NULL;
            bSuccess = FALSE;
        }

    } else {

        //
        // Allocation of Directory Header failed.
        //
        ASSERT( pDirectoryHeader == NULL);
    }

#if TS_USE_DIRECTORY_GUARD
    // Free up the guardian block and exit.

    if ( bCachedGuardianBlob) {

        bSuccess = TsExpireCachedBlob( tsCache, pvGuardBlob );

        ASSERT( bSuccess );

        bSuccess = TsCheckInCachedBlob(  pvGuardBlob );
        ASSERT( bSuccess );

        pvGuardBlob = NULL;
    }

    ASSERT( pvGuardBlob  == NULL);
#endif // TS_USE_DIRECTORY_GUARD
    
    return ( pDirectoryHeader);
} // TsGetFreshDirectoryHeader




BOOL
FreeDirectoryHeaderContents( PVOID pvOldBlock )
{
    PTS_DIRECTORY_HEADER  pDirectoryHeader;

    pDirectoryHeader = ( PTS_DIRECTORY_HEADER )pvOldBlock;

    pDirectoryHeader->CleanupThis();

    //
    //  The item may never have been added to the cache, don't
    //  count it in this case
    //
//
// We're never caching dir blobs now
//
//    if ( BLOB_IS_OR_WAS_CACHED( pvOldBlock ) ) {
//
//        DEC_COUNTER( BLOB_GET_SVC_ID( pvOldBlock ), CurrentDirLists );
//    }

    return ( TRUE);
}  //  FreeDirectoryHeaderContents()




int __cdecl
AlphaCompareFileBothDirInfo(
   IN const void *   pvFileInfo1,
   IN const void *   pvFileInfo2)
{
    const WIN32_FIND_DATA * pFileInfo1 =
        *((const WIN32_FIND_DATA **) pvFileInfo1);
    const WIN32_FIND_DATA * pFileInfo2 =
        *((const WIN32_FIND_DATA **) pvFileInfo2);

    ASSERT( pFileInfo1 != NULL && pFileInfo2 != NULL);

    return ( lstrcmp( (LPCSTR )pFileInfo1->cFileName,
                      (LPCSTR )pFileInfo2->cFileName));

} // AlphaCompareFileBothDirInfo()



BOOL
SortInPlaceFileInfoPointers(
    IN OUT PWIN32_FIND_DATA  *   prgFileInfo,
    IN int   nEntries,
    IN PFN_CMP_WIN32_FIND_DATA   pfnCompare)
/*++
  This is a generic function to sort the pointers to file information
    array in place using pfnCompare to compare the records for ordering.

  Returns:
     TRUE on success and FALSE on failure.
--*/
{
    DWORD  dwTime;

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Qsorting the FileInfo Array %08p ( Total = %d)\n",
                    prgFileInfo, nEntries));
        dwTime = GetTickCount();
    }


    qsort( (PVOID ) prgFileInfo, nEntries,
          sizeof( PWIN32_FIND_DATA),
          pfnCompare);


    IF_DEBUG( DIR_LIST) {

        dwTime = GetTickCount() - dwTime;
        DBGPRINTF( ( DBG_CONTEXT,
                    " Time to sort %d entries = %d\n",
                    nEntries, dwTime));
    }

    return ( TRUE);
} // SortInPlaceFileInfoPointers()




/**********************************************************************
 *    TS_DIRECTORY_HEADER  related member functions
 **********************************************************************/



const char PSZ_DIR_STAR_STAR[] = "*.*";
# define LEN_PSZ_DIR_STAR_STAR  ( sizeof(PSZ_DIR_STAR_STAR)/sizeof(CHAR))

BOOL
TS_DIRECTORY_HEADER::ReadWin32DirListing(
    IN LPCSTR           pszDirectoryName,
    IN OUT DWORD *      pcbMemUsed
    )
/*++
  Opens and reads the directory file for given directory to obtain
   information about files and directories in the dir.

  Arguments:
    pszDirectoryName  - pointer to string containing directory name
                         with a terminating "\".
    pcbMemUsed        - pointer to DWORD which on successful return
                         will contain the memory used.

  Returns:
     TRUE on success and   FALSE on failure.
     Use GetLastError() for further error information.

--*/
{
    BOOL                fReturn = TRUE;       // default assumed.
    CHAR                pchFullPath[MAX_PATH*2];
    HANDLE              hFindFile = INVALID_HANDLE_VALUE;
    BOOL                fFirstTime;
    DWORD               cbExtraMem = 0;
    DWORD               dwError = NO_ERROR;
    PWIN32_FIND_DATA    pFileInfo = NULL;
    PTS_DIR_BUFFERS     pTsDirBuffers = NULL;
    DWORD startCount;

    DBGCODE( CHAR pchBuff[300];
            );


    DBG_ASSERT( pszDirectoryName != NULL);

    if ( strlen(pszDirectoryName) > MAX_PATH*2 - LEN_PSZ_DIR_STAR_STAR) {

        return ( ERROR_PATH_NOT_FOUND);
    }

    wsprintfA( pchFullPath, "%s%s", pszDirectoryName, PSZ_DIR_STAR_STAR);

    InitializeListHead( &m_listDirectoryBuffers);

    //
    // Get the next chunk of directory information.
    //

    pTsDirBuffers = (PTS_DIR_BUFFERS ) ALLOC( sizeof(TS_DIR_BUFFERS));

    if ( pTsDirBuffers == NULL ) {

        //
        //  Allocation failure.
        //
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        fReturn = FALSE;
        goto Failure;
    }

    cbExtraMem += sizeof(TS_DIR_BUFFERS);

    // insert the buffer into the list so that it may be freed later.
    InsertBufferInTail( &pTsDirBuffers->listEntry);
    pTsDirBuffers->nEntries = 0;

    pFileInfo = (PWIN32_FIND_DATA ) pTsDirBuffers->rgFindData;

    hFindFile = FindFirstFile( pchFullPath, pFileInfo);
    if ( hFindFile == INVALID_HANDLE_VALUE) {

        dwError = GetLastError();

        IF_DEBUG( DIR_LIST) {
            DBGPRINTF(( DBG_CONTEXT,
                       "FindFirstFile(%s, %08p) failed. Error = %d\n",
                       pchFullPath, pFileInfo, dwError));
        }
        fReturn = FALSE;
        goto Failure;
    }
    IF_DEBUG( DIR_LIST) {

        DBGCODE(
                wsprintf( pchBuff, "-%d-[%d](%08p) %s(%s)\t%08x\n",
                         MAX_DIR_ENTRIES_PER_BLOCK,
                         0,
                         pFileInfo,
                         pFileInfo->cFileName, pFileInfo->cAlternateFileName,
                         pFileInfo->dwFileAttributes);
                OutputDebugString( pchBuff);
                );
    }

    pFileInfo++;
    IncrementDirEntries();
    pTsDirBuffers->nEntries++;
    startCount = 1;

    // atleast 10 to justify overhead
    DBG_ASSERT( MAX_DIR_ENTRIES_PER_BLOCK > 10);

    //
    //  Loop through getting subsequent entries in the directory.
    //

    for( dwError = NO_ERROR; dwError == NO_ERROR; ) {

        // loop thru and get a block of items

        for( int i = startCount; i < MAX_DIR_ENTRIES_PER_BLOCK; i++ ) {

            if ( !FindNextFile( hFindFile, pFileInfo)) {

                dwError = GetLastError();

                if ( dwError != ERROR_NO_MORE_FILES) {
                    DBGPRINTF(( DBG_CONTEXT,
                               "FindNextFile(%s(%08p), %08p) failed."
                               " Error = %d\n",
                               pchFullPath, hFindFile, pFileInfo,
                               dwError));
                    fReturn = FALSE;
                    goto Failure;
                } else {

                    break;
                }
            }

            IF_DEBUG( DIR_LIST) {

                DBGCODE(
                        wsprintf( pchBuff, "[%d](%08p) %s(%s)\t%08x\n",
                                 i, pFileInfo,
                                 pFileInfo->cFileName,
                                 pFileInfo->cAlternateFileName,
                                 pFileInfo->dwFileAttributes);
                        OutputDebugString( pchBuff);
                        );
            }

            IncrementDirEntries();
            pFileInfo++;

        } // for all elements that fit in this block

        pTsDirBuffers->nEntries = i;

        if ( dwError == ERROR_NO_MORE_FILES) {

            //
            // info on all entries in a directory obtained. Return back.
            //

            dwError = NO_ERROR;
            break;
        } else {

            //
            //  The buffer contains directory entries and is full now.
            //  Update the count of entries in this buffer and
            //  Allocate a new buffer and set the start counts properly.
            //

            IF_DEBUG( DIR_LIST) {
                DBGCODE( OutputDebugString( " Allocating Next Chunck\n"););
            }

            pTsDirBuffers = (PTS_DIR_BUFFERS ) ALLOC(sizeof(TS_DIR_BUFFERS));

            if ( pTsDirBuffers == NULL ) {

                //
                //  Allocation failure.
                //
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                fReturn = FALSE;
                break;                // Get out of the loop with failure.
            }

            cbExtraMem += sizeof(TS_DIR_BUFFERS);

            // insert the buffer into the list so that it may be freed later.
            InsertBufferInTail( &pTsDirBuffers->listEntry);
            pTsDirBuffers->nEntries = 0;

            pFileInfo = ( PWIN32_FIND_DATA ) pTsDirBuffers->rgFindData;

            startCount = 0;  // start count from zero items on this buffer page
        }

    } // for all directory entries

Failure:

    if ( hFindFile != INVALID_HANDLE_VALUE) {
        DBG_REQUIRE( FindClose( hFindFile ));
        hFindFile = INVALID_HANDLE_VALUE;
    }

    *pcbMemUsed += cbExtraMem;

    return ( fReturn);
} // TS_DIRECTORY_HEADER::ReadWin32DirListing()


VOID
TS_DIRECTORY_HEADER::CleanupThis( VOID)
{
    PLIST_ENTRY pEntry;
    PLIST_ENTRY pNextEntry;

    for ( pEntry = QueryDirBuffersListEntry()->Flink;
         pEntry != QueryDirBuffersListEntry();
         pEntry  = pNextEntry )
    {
        PTS_DIR_BUFFERS  pTsDirBuffer =
          CONTAINING_RECORD( pEntry, TS_DIR_BUFFERS, listEntry);

        // cache the next block pointer.
        pNextEntry = pEntry->Flink;

        // remove the current block from list.
        RemoveEntryList( pEntry);

        // delete the current block.
        FREE( pTsDirBuffer );
    }

    InitializeListHead( QueryDirBuffersListEntry());

    if ( m_ppFileInfo != NULL) {

        FREE( m_ppFileInfo);
        m_ppFileInfo   = NULL;
    }

    m_hListingUser = INVALID_HANDLE_VALUE;
    m_nEntries     = 0;

    return;
} // TS_DIRECTORY_HEADER::CleanupThis()





BOOL
TS_DIRECTORY_HEADER::BuildFileInfoPointers(
    IN OUT DWORD *      pcbMemUsed
    )
/*++

  This constructs the indirection pointers from the buffers containing the
   file information.
  This array of indirection enables faster access to the file information
   structures stored.

   Should be always called after ReadFromNtDirectoryFile() to construct the
    appropriate pointers.

   Returns:
     TRUE on success and FALSE if there are any failures.
--*/
{
    BOOL  fReturn = FALSE;
    DWORD cbAlloc;
    int   maxIndex;

    maxIndex = QueryNumEntries();

    ASSERT( maxIndex != 0);  //  Any directory will atleast have "."

    //
    // Alloc space for holding the pointers for numEntries pointers.
    //

    cbAlloc = maxIndex * sizeof( PWIN32_FIND_DATA );

    m_ppFileInfo = (PWIN32_FIND_DATA *) ALLOC( cbAlloc );

    if ( m_ppFileInfo != NULL ) {

        int          index;
        PLIST_ENTRY  pEntry;
        PTS_DIR_BUFFERS    pTsDirBuffers;
        PWIN32_FIND_DATA   pFileInfo;

        //
        //  Get the link to first buffer and start enumeration.
        //

        for( pEntry = QueryDirBuffersListEntry()->Flink, index = 0;
             pEntry != QueryDirBuffersListEntry();
            pEntry = pEntry->Flink
            ) {

            pTsDirBuffers = CONTAINING_RECORD( pEntry, TS_DIR_BUFFERS,
                                               listEntry);

            pFileInfo = pTsDirBuffers->rgFindData;

            for (int  i = 0;
                 i < pTsDirBuffers->nEntries;
                 i++ ) {

                m_ppFileInfo[index++] = pFileInfo;    // store the pointer.

                IF_DEBUG( DIR_LIST) {
                    DBGCODE(
                            CHAR pchBuff[300];
                            wsprintf( pchBuff, "[%d](%08p) %s(%s)\t%08x\n",
                                     index, pFileInfo,
                                     pFileInfo->cFileName,
                                     pFileInfo->cAlternateFileName,
                                     pFileInfo->dwFileAttributes);
                            OutputDebugString( pchBuff);
                            );
                }

                pFileInfo++;

            } // for all elements in a buffer

        } // for ( all buffers in the list)


        ASSERT( index == maxIndex);

        fReturn = SortInPlaceFileInfoPointers( m_ppFileInfo,
                                              maxIndex,
                                              AlphaCompareFileBothDirInfo);

    } // valid alloc of the pointers.

    *pcbMemUsed += cbAlloc;

    return ( fReturn);
} // TS_DIRECTORY_HEADER::BuildFileInfoPointers()



# if DBG

VOID
TS_DIRECTORY_HEADER::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                "Printing TS_DIRECTORY_HEADER ( %08p).\n"
                "ListingUser Handle = %08p\t Num Entries = %08x\n"
                "Pointer to array of indirection pointers %08p\n",
                this,
                m_hListingUser, m_nEntries,
                m_ppFileInfo));

    //
    //  The buffers containing the data of the file information not printed
    //

    return;
} // TS_DIRECTORY_HEADER::Print()


# endif // DBG

/************************ End of File ***********************/


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache2\dirchang.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :

        dirchang.cxx

   Abstract:

        This module contains the directory change manager routines

   Author:

        MuraliK

   Revision History:

        MCourage    24-Mar-1998  Rewrote to use CDirMonitor

--*/

#include "tsunamip.Hxx"
#pragma hdrstop

#include "dbgutil.h"
#include <mbstring.h>

extern "C" {
#include <lmuse.h>
}

#if ENABLE_DIR_MONITOR

#include <malloc.h>
#include "filecach.hxx"
#include "filehash.hxx"

//#define DIR_CHANGE_FILTER   (FILE_NOTIFY_CHANGE_DIR_NAME | FILE_NOTIFY_CHANGE_ATTRIBUTES)

#define DIR_CHANGE_FILTER (FILE_NOTIFY_VALID_MASK & ~FILE_NOTIFY_CHANGE_LAST_ACCESS)
#define DIRMON_BUFFER_SIZE  4096

BOOL ConvertToLongFileName(
                const char *pszPath,
                const char *pszName,
                WIN32_FIND_DATA *pwfd);


CDirMonitor * g_pVRootDirMonitor;
#endif // ENABLE_DIR_MONITOR

BOOL
DcmInitialize(
    VOID
    )
{
#if ENABLE_DIR_MONITOR
    g_pVRootDirMonitor = new CDirMonitor;

    return (g_pVRootDirMonitor != NULL);
#else
    return TRUE;
#endif // ENABLE_DIR_MONITOR
}


VOID
DcmTerminate(
    VOID
    )
{
#if ENABLE_DIR_MONITOR
    if (g_pVRootDirMonitor) {
        g_pVRootDirMonitor->Cleanup();
        delete g_pVRootDirMonitor;
        g_pVRootDirMonitor = NULL;
    }
#endif // ENABLE_DIR_MONITOR
}


BOOL
DcmAddRoot(
    PVIRTUAL_ROOT_MAPPING  pVrm
    )
{
#if ENABLE_DIR_MONITOR
    IF_DEBUG( DIRECTORY_CHANGE ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "DCM: Adding root \"%s\" to \"%s\"\n",
                    pVrm->pszRootA, pVrm->pszDirectoryA ));
    }

    ASSERT(NULL != g_pVRootDirMonitor);

    CVRootDirMonitorEntry * pDME;

    //
    // See if we're already watching this directory
    //

    pDME = (CVRootDirMonitorEntry *) g_pVRootDirMonitor->FindEntry(pVrm->pszDirectoryA);

    if ( pDME == NULL )
    {
        // Not found - create new entry

        pDME = new CVRootDirMonitorEntry;

        if ( pDME )
        {
            pDME->AddRef();

            // Start monitoring
            if ( !g_pVRootDirMonitor->Monitor(pDME, pVrm->pszDirectoryA, TRUE, DIR_CHANGE_FILTER) )
            {
                // Cleanup if failed
                pDME->Release();
                pDME = NULL;
            }
        }
    }

    // Return entry if found
    if ( pDME != NULL )
    {
        pVrm->pDME = static_cast<CVRootDirMonitorEntry *>(pDME);
        return TRUE;
    }
    else
    {
        pVrm->pDME = NULL;
        return FALSE;
    }

#else // !ENABLE_DIR_MONITOR
    //
    // Doesn't do anything.  Ha!
    //
    return TRUE;
#endif // ENABLE_DIR_MONITOR
}


VOID
DcmRemoveRoot(
    PVIRTUAL_ROOT_MAPPING  pVrm
    )
{
#if ENABLE_DIR_MONITOR
    IF_DEBUG( DIRECTORY_CHANGE ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "DCM: Removing root \"%s\" to \"%s\"\n",
                    pVrm->pszRootA, pVrm->pszDirectoryA ));
    }

    CVRootDirMonitorEntry * pDME = pVrm->pDME;

    pVrm->pDME = NULL;

    if (pDME) {
        pDME->Release();
    }
#else // !ENABLE_DIR_MONITOR
    //
    // Doesn't do anything.  Ha!
    //
#endif // ENABLE_DIR_MONITOR
}



#if ENABLE_DIR_MONITOR

typedef struct _FLUSH_PREFIX_PARAM {
    PCSTR pszPrefix;
    DWORD cbPrefix;
} FLUSH_PREFIX_PARAM;


BOOL
FlushFilterPrefix(
    TS_OPEN_FILE_INFO * pOpenFile,
    PVOID               pv
    )
{
    DBG_ASSERT( pOpenFile );
    DBG_ASSERT( pOpenFile->GetKey() );

    FLUSH_PREFIX_PARAM * fpp = (FLUSH_PREFIX_PARAM *)pv;
    const CFileKey * pfk = pOpenFile->GetKey();

    //
    // If the prefix matches then we flush.
    //

    //
    // The key stored in TS_OPEN_FILE_INFO is uppercased, so we will do a
    // case insensitive memcmp here. 
    // The alternative is to create a temporary and uppercase all instances 
    // when the directory is dumped or to have CDirMonitorEntry store its 
    // name uppercased.
    //

    return ((pfk->m_cbFileName >= fpp->cbPrefix)
            && (_memicmp(pfk->m_pszFileName, fpp->pszPrefix, fpp->cbPrefix) == 0));
}


/*===================================================================
strcpyEx

Copy one string to another, returning a pointer to the NUL character
in the destination

Parameters:
    szDest - pointer to the destination string
    szSrc - pointer to the source string

Returns:
    A pointer to the NUL terminator is returned.
===================================================================*/

char *strcpyEx(char *szDest, const char *szSrc)
    {
    while (*szDest++ = *szSrc++)
        ;

    return szDest - 1;
    }


CVRootDirMonitorEntry::CVRootDirMonitorEntry() : m_cNotificationFailures(0)
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    None
--*/
{
}

CVRootDirMonitorEntry::~CVRootDirMonitorEntry()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    None
--*/
{
}

BOOL
CVRootDirMonitorEntry::Init(
    VOID
    )
/*++

Routine Description:

    Initialize monitor entry

Arguments:

    pvData    - passed to base Init member

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    return CDirMonitorEntry::Init(DIRMON_BUFFER_SIZE);
}

#if 0
BOOL CVRootDirMonitorEntry::Release(VOID)
/*++

Routine Description:

    Decrement refcount to an entry, we override the base class because
    otherwise Denali's memory manager can't track when we free the object
    and reports  it as a memory leak

Arguments:

    None

Return Value:

    TRUE if object still alive, FALSE if was last release and object
    destroyed

--*/
{
    IF_DEBUG( DIRECTORY_CHANGE ) {
        DBGPRINTF((DBG_CONTEXT, "[CVRootDirMonitorEntry] Before Release Ref count %d on directory %s\n", m_cDirRefCount, m_pszPath));
    }

    if ( !InterlockedDecrement( &m_cDirRefCount ) )
    {
        BOOL fDeleteNeeded = Cleanup();
        if (fDeleteNeeded)
        {
            delete this;
        }
        return FALSE;
    }

    return TRUE;
}
#endif

BOOL
CVRootDirMonitorEntry::ActOnNotification(
                        DWORD dwStatus,
                        DWORD dwBytesWritten)
/*++

Routine Description:

    Do any work associated with a change notification, i.e.

Arguments:

    None

Return Value:

    TRUE if directory should continue to be monitored, otherwise FALSE

--*/
{
    FILE_NOTIFY_INFORMATION *pNotify = NULL;
    FILE_NOTIFY_INFORMATION *pNextNotify = NULL;
    LPSTR    pszScriptName = NULL; // Name of script
    WCHAR   *pwstrFileName = NULL; // Wide file name
    DWORD   cch = 0;

    pNextNotify = (FILE_NOTIFY_INFORMATION *) m_pbBuffer;

    // If the status word is not NOERROR, then the ReadDirectoryChangesW failed
    if (dwStatus)
    {
        // If the status is ERROR_ACCESS_DENIED the directory may be deleted
        // or secured so we want to stop watching it for changes.
        // we should flush the dir and everything in it.

        if (dwStatus == ERROR_ACCESS_DENIED)
        {
            //
            // Flush the dir here
            //
            IF_DEBUG( DIRECTORY_CHANGE ) {
                DBGPRINTF(( DBG_CONTEXT,
                            "DCM: Flushing directory \"%s\" because we got ACCESS_DENIED\n",
                            m_pszPath ));
            }

            FLUSH_PREFIX_PARAM param;
            param.pszPrefix = m_pszPath;
            param.cbPrefix = strlen(m_pszPath);
            FilteredFlushFileCache(FlushFilterPrefix, &param);

            //
            // no point in having the handle open anymore
            //
            m_hDir = INVALID_HANDLE_VALUE;
            AtqCloseFileHandle( m_pAtqCtxt );

            // No further notifications desired
            // so return false

            return FALSE;
        }

        // If we return TRUE, we'll try change notification again
        // If we return FALSE, we give up on any further change notifcation
        // We'll try a MAX_NOTIFICATION_FAILURES times and give up.

        if (m_cNotificationFailures < MAX_NOTIFICATION_FAILURES)
        {
            IF_DEBUG ( DIRECTORY_CHANGE ) {
                DBGPRINTF((DBG_CONTEXT, "[CVRootDirMonitorEntry] ReadDirectoryChange failed. Status = %d\n", dwStatus));
            }

            m_cNotificationFailures++;
            return TRUE;    // Try to get change notification again
        }
        else
        {
            // CONSIDER: Should we log this?
            DBGPRINTF((DBG_CONTEXT, "[CVRootDirMonitorEntry] ReadDirectoryChange failed too many times. Giving up.\n"));
            return FALSE;   // Give up trying to get change notification
        }
    }
    else
    {
        // Reset the number of notification failure

        m_cNotificationFailures = 0;
    }

    // If dwBytesWritten is 0, then there were more changes then could be
    // recorded in the buffer we provided. Expire the application just in case
    // CONSIDER: is this the best course of action, or should iterate through the
    // cache and test which files are expired

    if (dwBytesWritten == 0)
    {
        IF_DEBUG( DIRECTORY_CHANGE ) {
            DBGPRINTF((DBG_CONTEXT, "[CVRootDirMonitorEntry] ReadDirectoryChange failed, too many changes for buffer\n"));
        }

        // Flush everything in the dir as a precaution
        FLUSH_PREFIX_PARAM param;
        param.pszPrefix = m_pszPath;
        param.cbPrefix = strlen(m_pszPath);
        FilteredFlushFileCache(FlushFilterPrefix, &param);

        return TRUE;
    }

    while ( pNextNotify != NULL )
    {
        BOOL    bDoFlush = TRUE;

        pNotify        = pNextNotify;
        pNextNotify = (FILE_NOTIFY_INFORMATION    *) ((PCHAR) pNotify + pNotify->NextEntryOffset);

        // Get the unicode file name from the notification struct
        // pNotify->FileNameLength returns the wstr's length in **bytes** not wchars

        cch = pNotify->FileNameLength / 2;

        // Convert to ANSI with uniform case and directory delimiters

        pszScriptName = (LPSTR) _alloca(pNotify->FileNameLength + 1);
        DBG_ASSERT(pszScriptName != NULL);
        pszScriptName[ 0 ] = '\0';
        
        cch = WideCharToMultiByte(CP_ACP, 0, pNotify->FileName, cch, pszScriptName, pNotify->FileNameLength + 1, NULL, NULL);
        pszScriptName[cch] = '\0';

        // Take the appropriate action for the directory change
        switch (pNotify->Action)
        {
            case FILE_ACTION_MODIFIED:
                //
                // Since this change won't change the pathname of
                // any files, we don't have to do a flush.
                //
                bDoFlush = FALSE;
            case FILE_ACTION_REMOVED:
            case FILE_ACTION_RENAMED_OLD_NAME:
                FileChanged(pszScriptName, bDoFlush);
                break;
            case FILE_ACTION_ADDED:
            case FILE_ACTION_RENAMED_NEW_NAME:
            default:
                break;
        }

        if(pNotify == pNextNotify)
        {
            break;
        }
    }

    // We should sign up for further change notification

    return TRUE;
}

void
CVRootDirMonitorEntry::FileChanged(const char *pszScriptName, BOOL bDoFlush)
/*++

Routine Description:

    An existing file has been modified or deleted
    Flush scripts from cache or mark application as expired

Arguments:

    pszScriptName   Name of file that changed

Return Value:

    None    Fail silently

--*/
{

    // The file name is set by the application that
    // modified the file, so old applications like EDIT
    // may hand us a munged 8.3 file name which we should
    // convert to a long name. All munged 8.3 file names contain '~'
    // We assume the path does not contain any munged names.
    WIN32_FIND_DATA wfd;
    CHAR            achFullScriptName[ MAX_PATH + 1 ];

    IF_DEBUG( DIRECTORY_CHANGE ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "DCM: Notification on \"%s\\%s\"\n",
                    m_pszPath, pszScriptName ));
    }

    if (strchr(pszScriptName, '~'))
    {

        if (ConvertToLongFileName(m_pszPath, pszScriptName, &wfd))
        {
            CHAR *              pszEnd;
            
            //
            // The filename in wfd.cFileName is the path-less.  We need to 
            // append it to another other sub dirs in pszScriptName (if any)
            //
            
            pszEnd = strrchr( pszScriptName, '\\' );
            if ( pszEnd )
            {
                memcpy( achFullScriptName,
                        pszScriptName,
                        DIFF( pszEnd - pszScriptName ) + 1 );

                memcpy( achFullScriptName + ( pszEnd - pszScriptName ) + 1,
                        wfd.cFileName,
                        strlen( wfd.cFileName ) + 1 );

                pszScriptName = achFullScriptName;
            }
            else
            {
                pszScriptName = wfd.cFileName;
            }
                          
            IF_DEBUG( DIRECTORY_CHANGE ) {
                DBGPRINTF(( DBG_CONTEXT,
                            "DCM: Converted name to \"%s\"\n",
                            pszScriptName ));
            }

        }
        else
        {
            // Fail silently
            return;
        }
    }

    // Allocate enough memory to concatentate the
    // application path and script name

    DWORD cch = m_cPathLength + strlen(pszScriptName) + 1;
    LPSTR pszScriptPath = (LPSTR) _alloca(cch + 1); // CONSIDER using malloc
    DBG_ASSERT(pszScriptPath != NULL);

    // Copy the application path into the script path
    // pT will point to the terminator of the application path

    char* pT = strcpyEx(pszScriptPath, m_pszPath);

    // append a backslash
    *pT++ = '\\';

    // Now append the script name. Note that the script name is
    // relative to the directory that we received the notification for

    lstrcpy(pT, pszScriptName);
    _mbsupr((PUCHAR)pszScriptPath);

    // Get rid of this file, or dir tree
    TS_OPEN_FILE_INFO * pOpenFile;

    if (bDoFlush) {
        //
        // This path is a directory that got removed or renamed
        // so we have to flush everything below it.
        //
        IF_DEBUG( DIRECTORY_CHANGE ) {
            DBGPRINTF(( DBG_CONTEXT,
                        "DCM: Flushing directory \"%s\"\n",
                        pszScriptPath ));
        }

        FLUSH_PREFIX_PARAM param;
        param.pszPrefix = pszScriptPath;
        param.cbPrefix = strlen(pszScriptPath);

        FilteredFlushFileCache(FlushFilterPrefix, &param);
    } else if (CheckoutFile(pszScriptPath, 0, &pOpenFile)) {
        //
        // this is just one file, or a directory whose
        // name didn't change. We only have to decache it.
        //
        IF_DEBUG( DIRECTORY_CHANGE ) {
            DBGPRINTF(( DBG_CONTEXT,
                        "DCM: decaching file \"%s\"\n",
                        pszScriptPath ));
        }

        DecacheFile(pOpenFile, 0);
    }
}

BOOL
ConvertToLongFileName(
                const char *pszPath,
                const char *pszName,
                WIN32_FIND_DATA *pwfd)
/*++

Routine Description:

    Finds the long filename corresponding to a munged 8.3 filename.

Arguments:

    pszPath     The path to the file
    pszName     The 8.3 munged version of the file name
    pwfd        Find data structure used to contain the long
                version of the file name.

Return Value:

    TRUE        if the file is found,
    FALSE       otherwise
--*/
{
    // Allocate enough memory to concatentate the file path and name

    DWORD cch = strlen(pszPath) + strlen(pszName) + 1;
    char *pszFullName = (char *) _alloca(cch + 1);
    DBG_ASSERT(pszFullName != NULL);

    // Copy the path into the working string
    // pT will point to the terminator of the application path

    char* pT = strcpyEx(pszFullName,
                        pszPath);

    // append a backslash
    *pT++ = '\\';

    // Now append the file name. Note that the script name is
    // relative to the directory that we received the notification for

    lstrcpy(pT, pszName);


    // FindFirstFile will find using the short name
    // We can then find the long name from the WIN32_FIND_DATA

    HANDLE hFindFile = FindFirstFile(pszFullName, pwfd);
    if (hFindFile == INVALID_HANDLE_VALUE)
    {
           return FALSE;
    }

    // Now that we have the find data we don't need the handle
    FindClose(hFindFile);
    return TRUE;
}



#endif // ENABLE_DIR_MONITOR




/*******************************************************************

    NAME:       IsCharTermA (DBCS enabled)

    SYNOPSIS:   check the character in string is terminator or not.
                terminator is '/', '\0' or '\\'

    ENTRY:      lpszString - string

                cch - offset for char to check

    RETURNS:    BOOL - TRUE if it is a terminator

    HISTORY:
        v-ChiKos    15-May-1997 Created.

********************************************************************/
BOOL
IsCharTermA(
    IN LPCSTR lpszString,
    IN INT    cch
    )
{
    CHAR achLast;

    achLast = *(lpszString + cch);

    if ( achLast == '/' || achLast == '\0' )
    {
        return TRUE;
    }

    achLast = *CharPrev(lpszString, lpszString + cch + 1);

    return (achLast == '\\');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache2\fileinfo.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1998                **/
/**********************************************************************/

/*
    fileinfo.cxx

    This module contains the methods for TS_OPEN_FILE_INFO


    FILE HISTORY:
        MCourage    09-Dec-1997     Created
*/

#include <tsunami.hxx>
#include "tsunamip.hxx"
#include <iistypes.hxx>
#include <acache.hxx>
#include <imd.h>
#include <mb.hxx>
#include "string.h"
#include <uspud.h>

#include "filecach.hxx"
#include "filehash.hxx"
#include "tlcach.h"
#include "etagmb.h"


GENERIC_MAPPING g_gmFile = {
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_ALL_ACCESS
};



ALLOC_CACHE_HANDLER * TS_OPEN_FILE_INFO::sm_pachFileInfos;
CRITICAL_SECTION      TS_OPEN_FILE_INFO::sm_cs;


TS_OPEN_FILE_INFO::TS_OPEN_FILE_INFO()
  : m_Signature(TS_FILE_INFO_SIGNATURE),
    m_hFile(INVALID_HANDLE_VALUE),
    m_hCopyFile(INVALID_HANDLE_VALUE),
    m_pFileBuffer(0),
    m_hUser(INVALID_HANDLE_VALUE),
    m_cbSecDescMaxSize(0),
    m_pSecurityDescriptor(m_abSecDesc),
    m_fSecurityDescriptor(FALSE),
    m_cchHttpInfo(0),
    m_cchETag(0),
    m_ETagIsWeak(TRUE),
    m_bIsCached(FALSE),
    m_state(FI_UNINITIALIZED),
    m_lRefCount(0),
    m_dwIORefCount(0),
    m_TTL(1),
    m_FileAttributes(0xFFFFFFFF),
    m_pvContext( NULL ),
    m_pfnFreeRoutine( NULL )
{
    m_FileKey.m_cbFileName = 0;
    m_FileKey.m_pszFileName = NULL;
}

BOOL
TS_OPEN_FILE_INFO::SetContext( 
    PVOID                   pvContext,
    PCONTEXT_FREE_ROUTINE   pfnFreeRoutine
)
/*++

Routine Description
    
    Used by external components (SSI) to set an opaque context and a
    free routine to be called when freeing the context.  This allows SSI
    to associate the SSI parsed template with actual TS_OPEN_FILE_INFO

Arguments

    None.

Return

    TRUE if the context was set.  FALSE if there was already a context.

--*/
{
    BOOL                    fRet;
    
    Lock();
    
    if ( m_pvContext != NULL )
    {
        fRet = FALSE;
    }
    else
    {
        m_pvContext = pvContext;
        m_pfnFreeRoutine = pfnFreeRoutine;
        fRet = TRUE;
    }
    
    Unlock();
    
    return fRet;
}

PVOID
TS_OPEN_FILE_INFO::QueryContext(
    VOID 
) const
/*++

Routine Description
    
    Returns the context associated with the TS_OPEN_FILE_INFO

Arguments

    None.

Return

    Pointer to context

--*/
{
    PVOID               pvContext;
    
    Lock();
    pvContext = m_pvContext;
    Unlock();
    
    return pvContext;
}

VOID
TS_OPEN_FILE_INFO::FreeContext(
    VOID
)
/*++

Routine Description
    
    Frees the opaque context by calling the free routine

Arguments

    None.

Return

    None

--*/
{
    Lock();
    if ( m_pvContext )
    {
        if ( m_pfnFreeRoutine )
        {
            __try 
            {
                m_pfnFreeRoutine( m_pvContext );
            }
            __finally
            {
                m_pvContext = NULL;
            }
        }
        else
        {
            DBG_ASSERT( FALSE );
        }
    }
    Unlock();
}

BOOL
FileFlushFilterContext(
    TS_OPEN_FILE_INFO *pOpenFile,
    PVOID              pv
)
/*++

Routine Description
    
    Filter used by FilteredFlushFileCache to select those TS_OPEN_FILE_INFO
    objects which have a context.  This routine will actually do the freeing
    and will return FALSE.  This is done to prevent premature flushing of
    the cache when SSI shuts down.

Arguments

    pOpenFile - TS_OPEN_FILE_INFO object
    pv - Unused context

Return

    Always returns FALSE    

--*/
{
    DBG_ASSERT( pOpenFile );
    
    pOpenFile->FreeContext();
    
    DBG_ASSERT( !pOpenFile->QueryContext() );

    return FALSE;
}

VOID
TsFlushFilesWithContext(
    VOID
)
/*++

Routine Description

    Exported routine used by SSI to free all opaque contexts.  This is called
    before SSINC.DLL is unloaded to prevent AVs in context free    

Arguments
    
    None

Return

    None

--*/
{
    FilteredFlushFileCache( FileFlushFilterContext, NULL );
}

BOOL
TS_OPEN_FILE_INFO::SetFileName(const CHAR * pszFileName)
{
    DBG_ASSERT( pszFileName );
    DBG_ASSERT( pszFileName[0] );

    m_FileKey.m_cbFileName = strlen(pszFileName);

    if (m_FileKey.m_cbFileName < TS_DEFAULT_PATH_SIZE) {
        //
        // It fits in our fixed size buffer
        //
        m_FileKey.m_pszFileName = m_FileKey.m_achFileNameBuf;
    } else {
        //
        // we need a bigger buffer
        //
        m_FileKey.m_pszFileName = new CHAR[m_FileKey.m_cbFileName + 1];
    }

    if (NULL != m_FileKey.m_pszFileName) {
        memcpy(m_FileKey.m_pszFileName, pszFileName, m_FileKey.m_cbFileName + 1);
    } else {
        m_FileKey.m_cbFileName = 0;
    }

    return (0 != m_FileKey.m_cbFileName);
}


TS_OPEN_FILE_INFO::~TS_OPEN_FILE_INFO( VOID)
{
    DBG_ASSERT( 0 == m_lRefCount );
    DBG_ASSERT( 0 == m_dwIORefCount );
    DBG_ASSERT( CheckSignature() );

    m_Signature = TS_FREE_FILE_INFO_SIGNATURE;

    if (m_FileKey.m_pszFileName
        && (m_FileKey.m_achFileNameBuf != m_FileKey.m_pszFileName)) {

        delete [] m_FileKey.m_pszFileName;
    }

    if (m_pFileBuffer) {
        DWORD dwError;
        
        dwError = ReleaseFromMemoryCache(
                      m_pFileBuffer,
                      m_nFileSizeLow
                      );

        DBG_ASSERT(dwError == ERROR_SUCCESS);
    }
            

    if (m_pSecurityDescriptor
        && (m_pSecurityDescriptor != m_abSecDesc)) {
        FREE(m_pSecurityDescriptor);
    }
    
    if (m_pvContext)
    {
        FreeContext();
    }
}

BOOL
TS_OPEN_FILE_INFO::AccessCheck(
    IN  HANDLE hUser,
    IN  BOOL   bCache
    )
{
    DBG_ASSERT(hUser != INVALID_HANDLE_VALUE);

    //
    // If it's the same user that last opened the file
    // then we know we have access.
    //
    if (hUser == m_hUser) {
        TraceCheckpointEx(TS_MAGIC_ACCESS_CHECK, (PVOID)hUser, (PVOID)(LONG_PTR)0xffffffff);
        return TRUE;
    }

    //
    // If we've got a security descriptor we can check
    // against that, otherwise fail the check.
    //
    BYTE  psFile[SIZE_PRIVILEGE_SET];
    DWORD dwPS;
    DWORD dwGrantedAccess;
    BOOL  fAccess;

    dwPS = sizeof(psFile);
    ((PRIVILEGE_SET*)&psFile)->PrivilegeCount = 0;

    if (m_fSecurityDescriptor
        && ::AccessCheck(m_pSecurityDescriptor,
                         hUser,
                         FILE_GENERIC_READ,
                         &g_gmFile,
                         (PRIVILEGE_SET*)psFile,
                         &dwPS,
                         &dwGrantedAccess,
                         &fAccess) ) {

        if (fAccess && bCache) {
            m_hUser = hUser;
        }

        TraceCheckpointEx(TS_MAGIC_ACCESS_CHECK, (PVOID)hUser, (PVOID) (ULONG_PTR) fAccess);
        return fAccess;
    } else {
        return FALSE;
    }
}

VOID
TS_OPEN_FILE_INFO::SetFileInfo(
    HANDLE               hFile,
    HANDLE               hUser,
    PSECURITY_DESCRIPTOR pSecDesc,
    DWORD                dwSecDescSize
    )
{
    BY_HANDLE_FILE_INFORMATION FileInfo;

    //
    // Fetch file information
    //
    BOOL fReturn;

    fReturn = GetFileInformationByHandle(
                                        hFile,
                                        &FileInfo
                                        );

    m_FileAttributes = FileInfo.dwFileAttributes;
    m_nFileSizeLow   = FileInfo.nFileSizeLow;
    m_nFileSizeHigh  = FileInfo.nFileSizeHigh;

    m_ftLastWriteTime = (__int64)*(__int64 *) &FileInfo.ftLastWriteTime;

    //
    // Handle common info
    //
    SetFileInfoHelper(hFile, hUser, pSecDesc, dwSecDescSize);
}

VOID
TS_OPEN_FILE_INFO::SetFileInfo(
    PBYTE                  pFileBuff,
    HANDLE                 hCopyFile,
    HANDLE                 hFile,
    HANDLE                 hUser,
    PSECURITY_DESCRIPTOR   pSecDesc,
    DWORD                  dwSecDescSize,
    PSPUD_FILE_INFORMATION pFileInfo
    )
{
    //
    // Save SPUD specific parameters
    //

    m_FileAttributes = pFileInfo->BasicInformation.FileAttributes;
    m_nFileSizeLow   = pFileInfo->StandardInformation.EndOfFile.LowPart;
    m_nFileSizeHigh  = pFileInfo->StandardInformation.EndOfFile.HighPart;

    m_ftLastWriteTime = (__int64)*(__int64 *) &pFileInfo->BasicInformation.LastWriteTime;

    //
    // Save file buffer
    //

    m_pFileBuffer = pFileBuff;
    m_hCopyFile = hCopyFile;

    //
    // Handle common info
    //
    SetFileInfoHelper(hFile, hUser, pSecDesc, dwSecDescSize);
}


VOID
TS_OPEN_FILE_INFO::SetFileInfoHelper(
    HANDLE               hFile,
    HANDLE               hUser,
    PSECURITY_DESCRIPTOR pSecDesc,
    DWORD                dwSecDescSize
    )
{
    //
    // Save away the given parameters
    //
    m_hFile = hFile;
    m_hUser = hUser;

    m_pSecurityDescriptor = pSecDesc;
    m_cbSecDescMaxSize = dwSecDescSize;
    if (dwSecDescSize)
        m_fSecurityDescriptor = TRUE;

    //
    // Generate some other file attributes
    //
    DWORD dwChangeNumber = ETagChangeNumber::GetChangeNumber();
    BOOL  fReturn = TRUE;

    *((__int64 *)&m_CastratedLastWriteTime)
        = (*((__int64 *)&m_ftLastWriteTime) / 10000000)
          * 10000000;
    //
    // Make the ETag
    //
    m_ETagIsWeak = TRUE;

    m_cchETag = FORMAT_ETAG(m_achETag, *(FILETIME*) &m_ftLastWriteTime,
                                dwChangeNumber);

    //
    // Make the ETag strong if possible
    //
    MakeStrongETag();

    //
    //  Turn off the hidden attribute if this is a root directory listing
    //  (root some times has the bit set for no apparent reason)
    //
    
    if ( m_FileAttributes & FILE_ATTRIBUTE_HIDDEN )
    {
        CHAR * pszFileName = m_FileKey.m_pszFileName;
         
        if ( m_FileKey.m_cbFileName >= 2 )
        {
            if ( pszFileName[ 1 ] == ':' )
            {
                if ( ( pszFileName[ 2 ] == '\0' ) ||
                     ( pszFileName[ 2 ] == '\\' && pszFileName[ 3 ] == '\0' ) )
                {
                    //
                    // This looks like a local root.  Mask out the bit
                    //
            
                    m_FileAttributes &= ~FILE_ATTRIBUTE_HIDDEN;
                }
            }
        }
    }
}


VOID
TS_OPEN_FILE_INFO::CloseHandle(
    void
    )
{
    HANDLE hFile;
    PBYTE  pFileBuffer;
    BOOL   bClose = FALSE;
    BOOL   bRelease = FALSE;
    DWORD  dwError;
    
    Lock();
    ASSERT( DisableTsunamiCaching 
            || (m_state == FI_FLUSHED)
            || (m_bIsCached == FALSE) );
    ASSERT( m_dwIORefCount == 0 );

    m_state = FI_CLOSED;

    if (m_pFileBuffer) {
        pFileBuffer = m_pFileBuffer;
        m_pFileBuffer = NULL;

        bRelease = TRUE;
    }
    

    if (m_hFile != INVALID_HANDLE_VALUE) {
        hFile = m_hFile;
        m_hFile = INVALID_HANDLE_VALUE;

        bClose = TRUE;
    }

    DBG_ASSERT(m_hCopyFile == INVALID_HANDLE_VALUE);
    
    Unlock();

    if (bRelease) {
        TraceCheckpointEx(TS_MAGIC_CLOSE, pFileBuffer, (PVOID) 1);
    
        dwError = ReleaseFromMemoryCache(
                      pFileBuffer,
                      m_nFileSizeLow
                      );

        DBG_ASSERT(dwError == ERROR_SUCCESS);
    }

    if (bClose) {
        TraceCheckpointEx(TS_MAGIC_CLOSE, hFile, 0);
        ::CloseHandle(hFile);
    }
}



INT
FormatETag(
    PCHAR pszBuffer,
    const FILETIME& rft,
    DWORD mdchange)
{
    PCHAR psz = pszBuffer;
    PBYTE pbTime = (PBYTE) &rft;
    const char szHex[] = "0123456789abcdef";

    *psz++ = '\"';
    for (int i = 0; i < 8; i++)
    {
        BYTE b = *pbTime++;
        BYTE bH = b >> 4;
        if (bH != 0)
            *psz++ = szHex[bH];
        *psz++ = szHex[b & 0xF];
    }
    *psz++ = ':';
    psz += strlen(_itoa((DWORD) mdchange, psz, 16));
    *psz++ = '\"';
    *psz = '\0';

    return (INT)(psz - pszBuffer);
}



VOID
TS_OPEN_FILE_INFO::MakeStrongETag(
    VOID
    )
/*++

    Routine Description

        Try and make an ETag 'strong'. To do this we see if the difference
        between now and the last modified date is greater than our strong ETag
        delta - if so, we mark the ETag strong.

    Arguments

        None.

    Returns

        Nothing.

--*/
{
    FILETIME                    ftNow;
    SYSTEMTIME                  stNow;
    __int64                     iNow, iFileTime;

    if ( m_pFileBuffer ||
         m_hFile != INVALID_HANDLE_VALUE ) {
        ::GetSystemTimeAsFileTime(&ftNow);

        iNow = (__int64)*(__int64 *)&ftNow;

        iFileTime = (__int64)*(__int64 *)&m_ftLastWriteTime;

        if ((iNow - iFileTime) > STRONG_ETAG_DELTA )
        {
            m_ETagIsWeak = FALSE;
        }
    }
}




BOOL
TS_OPEN_FILE_INFO::SetHttpInfo(
    IN PSTR pszInfo,
    IN INT  InfoLength
    )
/*++

    Routine Description

        Set the "Last-Modified:" header field in the file structure.

    Arguments

        pszDate - pointer to the header value to save
        InfoLength - length of the header value to save

    Returns

        TRUE if information was cached,
        FALSE if not cached

--*/
{
    if ( !m_ETagIsWeak && InfoLength < sizeof(m_achHttpInfo)-1 ) {

        CopyMemory( m_achHttpInfo, pszInfo, InfoLength+1 );

        //
        // this MUST be set after updating the array,
        // as this is checked to know if the array content is valid.
        //

        m_cchHttpInfo = InfoLength;
        return TRUE;
    }
    return FALSE;
} // TS_OPEN_FILE_INFO::SetHttpInfo

/*
 * Static members
 */

BOOL
TS_OPEN_FILE_INFO::Initialize(
    DWORD dwMaxFiles
    )
{
    ALLOC_CACHE_CONFIGURATION  acConfig = { 1, dwMaxFiles, sizeof(TS_OPEN_FILE_INFO)};

    if ( NULL != sm_pachFileInfos) {

        // already initialized
        return ( TRUE);
    }

    sm_pachFileInfos = new ALLOC_CACHE_HANDLER( "FileInfos",
                                                 &acConfig);

    if ( sm_pachFileInfos ) {
        INITIALIZE_CRITICAL_SECTION(&sm_cs);
    }

    return ( NULL != sm_pachFileInfos);
}

VOID
TS_OPEN_FILE_INFO::Cleanup(
    VOID
    )
{
    if ( NULL != sm_pachFileInfos) {

        delete sm_pachFileInfos;
        sm_pachFileInfos = NULL;

        DeleteCriticalSection(&sm_cs);
    }
}



VOID
TS_OPEN_FILE_INFO::Lock(
    VOID
    )
{
    EnterCriticalSection(&sm_cs);
}


VOID
TS_OPEN_FILE_INFO::Unlock(
    VOID
    )
{
    LeaveCriticalSection(&sm_cs);
}

VOID *
TS_OPEN_FILE_INFO::operator new( size_t s)
{
    DBG_ASSERT( s == sizeof( TS_OPEN_FILE_INFO));

    // allocate from allocation cache.
    DBG_ASSERT( NULL != sm_pachFileInfos);
    return (sm_pachFileInfos->Alloc());
}

VOID
TS_OPEN_FILE_INFO::operator delete( void * pOpenFile)
{
    DBG_ASSERT( NULL != pOpenFile);

    // free to the allocation pool
    DBG_ASSERT( NULL != sm_pachFileInfos);
    DBG_REQUIRE( sm_pachFileInfos->Free(pOpenFile));

    return;
}

//
// fileopen.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\cache2\filemisc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    filemisc.cxx

    This module contains some random functions for manipulating
    TS_OPEN_FILE_INFO objects


    FILE HISTORY:
        MCourage    09-Dec-1997     Created
*/

#include <tsunami.hxx>

#include <imd.h>
#include <mb.hxx>
#include <mbstring.h>

#include "tsunamip.hxx"
#include "etagmb.h"

BOOL
TsDeleteOnClose(PW3_URI_INFO pURIInfo,
                HANDLE OpeningUser,
                BOOL *fDeleted)
/*++
Routine Description:

    Marks the file associated with the passed URIInfo for deletion. When everyone 
    is done using that file, it will be deleted

Arguments:

    pURIInfo    - The W3_URI_INFO whose file will be marked for deletion 
    OpeningUser - HANDLE for the user attempting the delete operation 
    fDeleted    - Will be set if TsDeleteOnClose returns TRUE. If the user has access 
                  and the file was marked deleted fDeleted will be TRUE. Otherwise it will be 
                  FALSE. 

Return Values:

TRUE  - The user had access and the file was marked, or the user was denied access. 
FALSE - An error other than Access Denied occured. 

--*/
{
    //
    // Doesn't do anything.  Ha ha!
    //
    *fDeleted = FALSE;
    return FALSE;

}



PSECURITY_DESCRIPTOR
TsGetFileSecDesc(
    LPTS_OPEN_FILE_INFO     pFile
    )
/*++

Routine Description:

    Returns the security descriptor associated to the file
    To be freed using LocalFree()

Arguments:

    pFile - ptr to fie object

Return Value:

    ptr to security descriptor or NULL if error

--*/
{
    SECURITY_INFORMATION    si
            = OWNER_SECURITY_INFORMATION |
            GROUP_SECURITY_INFORMATION |
            DACL_SECURITY_INFORMATION;
    BYTE                    abSecDesc[ SECURITY_DESC_DEFAULT_SIZE ];
    DWORD                   dwSecDescSize;
    PSECURITY_DESCRIPTOR    pAcl;

    if ( GetKernelObjectSecurity(
            pFile->QueryFileHandle(),
            si,
            (PSECURITY_DESCRIPTOR)abSecDesc,
            SECURITY_DESC_DEFAULT_SIZE,
            &dwSecDescSize ) )
    {
        if ( dwSecDescSize > SECURITY_DESC_DEFAULT_SIZE )
        {
            if ( !(pAcl = (PSECURITY_DESCRIPTOR)LocalAlloc( LMEM_FIXED, dwSecDescSize )) )
            {
                return NULL;
            }
            if ( !GetKernelObjectSecurity(
                    pFile->QueryFileHandle(),
                    si,
                    pAcl,
                    dwSecDescSize,
                    &dwSecDescSize ) )
            {
                LocalFree( pAcl );

                return NULL;
            }
        }
        else
        {
            if ( dwSecDescSize = GetSecurityDescriptorLength(abSecDesc) )
            {
                if ( !(pAcl = (PSECURITY_DESCRIPTOR)LocalAlloc( LMEM_FIXED,
                        dwSecDescSize )) )
                {
                    return NULL;
                }
                memcpy( pAcl, abSecDesc, dwSecDescSize );
            }
            else
            {
                //
                // Security descriptor is empty : do not return ptr to security descriptor
                //

                pAcl = NULL;
            }
        }
    }
    else
    {
        pAcl = NULL;
    }

    return pAcl;
}



BOOL TsCreateETagFromHandle(
    IN      HANDLE          hFile,
    IN      PCHAR           ETag,
    IN      BOOL            *bWeakETag
    )
/*+++

    TsCreateETagFromHandle

    This routine takes a file handle as input, and creates an ETag in
    the supplied buffer for that file handle.

    Arguments:

    hFile           - File handle for which to create an ETag.
    ETag            - Where to store the ETag. This must be long
                        enough to hold the maximum length ETag.
    bWeakETag       - Set to TRUE if the newly created ETag is weak.

    Returns:

        TRUE if we create an ETag, FALSE otherwise.
---*/
{
    BY_HANDLE_FILE_INFORMATION  FileInfo;
    BOOL                        bReturn;
    PUCHAR                      Temp;
    FILETIME                    ftNow;
    DWORD                 dwChangeNumber = ETagChangeNumber::GetChangeNumber();


    bReturn  = GetFileInformationByHandle(
                                    hFile,
                                    &FileInfo
                                    );

    if (!bReturn)
    {
        return FALSE;
    }

    FORMAT_ETAG(ETag, FileInfo.ftLastWriteTime, dwChangeNumber );

    ::GetSystemTimeAsFileTime(&ftNow);

    __int64 iNow, iFileTime;

    iNow = (__int64)*(__int64 *)&ftNow;
    
    iFileTime = (__int64)*(__int64 *)&FileInfo.ftLastWriteTime;
    
    if ((iNow - iFileTime) > STRONG_ETAG_DELTA )
    {
        *bWeakETag = FALSE;
    }
    else
    {
        *bWeakETag = TRUE;
    }

    return TRUE;
}



BOOL TsLastWriteTimeFromHandle(
    IN      HANDLE          hFile,
    IN      FILETIME        *tm
    )
/*+++

    TsLastWriteTimeFromHandle

    This routine takes a file handle as input, and returns the last write time
    for that handle.

    Arguments:

    hFile           - File handle for which 