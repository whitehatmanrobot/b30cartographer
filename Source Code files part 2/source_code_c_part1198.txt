cheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            &srb,
                                            dataBuffer,
                                            sizeof(INQUIRYDATA),
                                            FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    //
    // Determine drive type.
    //

    if (RtlCompareMemory(dataBuffer->VendorId,"PLASMON ", 8) == 8) {
        if (RtlCompareMemory(dataBuffer->ProductId,"D-SERIES",8) == 8) {
            changerData->DriveType = PLSMN_CD;
            changerData->DriveID = PLASMON_DSERIES;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"FTA",3) == 3) {
            changerData->DriveType = PLSMN_TAPE;
            changerData->DriveID = PLASMON_FTA;
        }
    }

    changerData->BuildMagazineMapInProgress = FALSE;


    DebugPrint((1,
               "ChangerInitialize: DriveType %x, DriveID %x\n",
               changerData->DriveType,
               changerData->DriveID));

    ChangerClassFreePool(dataBuffer);

    if ((changerData->DriveID) == PLASMON_DSERIES) {

        sizeNeeded = sizeof(PLASMON_DSERIES_UNIT_INFO_PAGE);
    } else if ((changerData->DriveID) == PLASMON_FTA) {

        sizeNeeded = sizeof(PLASMON_FTA_UNIT_INFO_PAGE);
    } else {

        return STATUS_NOT_IMPLEMENTED;
    }

    unitInfo = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                                        sizeNeeded);
    if (unitInfo) {

        RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

        //
        // Set timeout value.
        //

        srb.TimeOutValue = 10;
        srb.CdbLength = 6;

        cdb = (PCDB)srb.Cdb;

        //
        // Set CDB operation code.
        //

        cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

        cdb->CDB6INQUIRY.PageCode = 0xC0;

        //
        // Set EVPD
        //

        cdb->CDB6INQUIRY.Reserved1 = 1;

        //
        // Set allocation length to inquiry data buffer size.
        //

        cdb->CDB6INQUIRY.AllocationLength = sizeNeeded;

        changerData->BarCodeReaderInstalled = FALSE;

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                                &srb,
                                                unitInfo,
                                                sizeNeeded,
                                                FALSE);

        if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
            SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

            if ((changerData->DriveID) == PLASMON_DSERIES) {
                dseriesUnitInfo = (PPLASMON_DSERIES_UNIT_INFO_PAGE) unitInfo;
                changerData->MagazineSlots = dseriesUnitInfo->MaximumMagazines;
                changerData->SlotsPerMag = 10;
            } else if ((changerData->DriveID) == PLASMON_FTA) {
                ftaUnitInfo = (PPLASMON_FTA_UNIT_INFO_PAGE) unitInfo;
                changerData->MagazineSlots = ftaUnitInfo->MaximumMagazines;
                changerData->SlotsPerMag = 5;

                if (ftaUnitInfo->BarCodes) {
                    changerData->BarCodeReaderInstalled = TRUE;
                }
            }

        } else {
            if ((changerData->DriveID) == PLASMON_FTA) {
                changerData->MagazineSlots = 1;
            } else {
                changerData->MagazineSlots = 12;
            }
        }

        //
        // Determine the current magazine state of the device.
        //

        status = BuildMagazineMap(DeviceObject);


        ChangerClassFreePool(unitInfo);
    }

    //
    // Build address mapping.
    //

    status = PlasmonBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Send a mode sense for the Library Mode parameters page 2.
    //

    //
    // ISSUE : nramas 12/15/2000
    //         LIBRARY_MODE_PARAMS_PAGE2 is slightly different, but
    //         LvClosed bit matches both D-SERIES and FTA. But, this
    //         should be fixed.
    //
    length = sizeof(MODE_PARAMETER_HEADER) + sizeof(LIBRARY_MODE_PARAMS_PAGE2);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (modeBuffer) {

        RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);
        RtlZeroMemory(modeBuffer, length);
        srb.CdbLength = CDB6GENERIC_LENGTH;
        srb.TimeOutValue = 20;
        srb.DataTransferLength = length;
        srb.DataBuffer = modeBuffer;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = MODE_PARAMS_PAGE2;
        cdb->MODE_SENSE.AllocationLength = (UCHAR)srb.DataTransferLength;

        //
        // Send the request.
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                                &srb,
                                                modeBuffer,
                                                length,
                                                FALSE);

        if (NT_SUCCESS(status)) {

            PMODE_PARAMETER_HEADER header;

            RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);
            modePage2 = (PLIBRARY_MODE_PARAMS_PAGE2)modeBuffer;
            header = (PMODE_PARAMETER_HEADER)modeBuffer;

            //
            // Zero out this field.
            //

            header->ModeDataLength = 0;

            //
            // Bypass the header.
            //

            (ULONG_PTR)modePage2 += sizeof(MODE_PARAMETER_HEADER);

            //
            // Setup the unit to NOT open the ieport port on moves to it.
            //

            modePage2->PageCode &= ~0x80;
            modePage2->LvClosed = 1;

            srb.CdbLength = CDB6GENERIC_LENGTH;
            srb.TimeOutValue = 20;
            srb.DataTransferLength = length;
            srb.DataBuffer = modeBuffer;

            cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
            cdb->MODE_SELECT.ParameterListLength = (UCHAR)srb.DataTransferLength;

            //
            // Send the request.
            //

            status = ChangerClassSendSrbSynchronous(DeviceObject,
                                                    &srb,
                                                    modeBuffer,
                                                    length,
                                                    TRUE);

            DebugPrint((1,
                       "Plasmc: Mode select of page2 - %x\n",
                       status));

        }

        ChangerClassFreePool(modeBuffer);
    }

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    ULONG   deviceStatus;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        DebugPrint((1,
                   "Plasmc: senseCode %x\n",
                   senseBuffer->SenseKey & 0xf));
        DebugPrint((1,
                   "Plasmc: additionalSenseCode %x\n",
                   senseBuffer->AdditionalSenseCode));
        DebugPrint((1,
                   "Plasmc: additionalSenseCodeQualifier %x\n",
                   senseBuffer->AdditionalSenseCodeQualifier));

        switch (senseBuffer->SenseKey & 0xf) {

            case SCSI_SENSE_ILLEGAL_REQUEST:

                if (senseBuffer->AdditionalSenseCode == 0x3B) {
                    if (senseBuffer->AdditionalSenseCodeQualifier == 0x81) {
                        BuildMagazineMap(DeviceObject);
                    }
                }
                break;

            case SCSI_SENSE_UNIT_ATTENTION:

                //
                // Update the map, as the door might have been opened, etc.
                //

                BuildMagazineMap(DeviceObject);
                break;

            case SCSI_SENSE_HARDWARE_ERROR: {
               deviceStatus = PLASMC_HW_ERROR;
               switch (senseBuffer->AdditionalSenseCode) {
                  case PLASMC_ASC_DIAGNOSTIC_FAILURE: {
                     deviceStatus = PLASMC_HW_ERROR;
                     break;
                  }

                  case PLASMC_ASC_INTERNAL_TARGET_FAILURE: {
                     deviceStatus = PLASMC_TARGET_FAILURE;
                     break;
                  }
                  
                  case PLASMC_ASC_VENDOR_UNIQUE: {
                     UCHAR plasmcASCQ = senseBuffer->AdditionalSenseCodeQualifier;

                     if ((plasmcASCQ >= PLASMC_ASCQ_PICKER_HOME_FAILURE) &&
                         (plasmcASCQ <= PLASMC_ASCQ_LIFT_BLOCKED_BY_TRAY)) {
                        deviceStatus = PLASMC_CHM_MOVE_ERROR;
                     } else {
                        deviceStatus = PLASMC_HW_ERROR;
                     }
                     break;
                  }
               }

               changerData->DeviceStatus = deviceStatus;
               break;
            }

            default:
               break;
        }
    }

    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    plasmon changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    bufferLength;
    PVOID    modeBuffer;
    PCDB     cdb;
    ULONG    i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    cdb->MODE_SENSE.Dbd = 1;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = PLAS_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;


    changerParameters->MagazineSize = (USHORT)changerData->SlotsPerMag;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;


    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_PAGE_TRANSPORT_GEOMETRY);
    cdb->MODE_SENSE.Dbd = 1;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (ULONG_PTR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Determine if mc has 2-sided media.
    //

    changerParameters->Features0 = transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;

    //
    // Features based on manual, nothing programatic.
    //

    if ((changerData->DriveType) == PLSMN_TAPE) {
        changerParameters->DriveCleanTimeout = 300;
    } else {
        changerParameters->DriveCleanTimeout = 0;
    }
    
    changerParameters->Features0 |= CHANGER_EXCHANGE_MEDIA                |
                                    CHANGER_LOCK_UNLOCK                   |
                                    CHANGER_POSITION_TO_ELEMENT           |
                                    CHANGER_DEVICE_REINITIALIZE_CAPABLE   |
                                    CHANGER_CLOSE_IEPORT                  |
                                    CHANGER_OPEN_IEPORT                   |
                                    CHANGER_CARTRIDGE_MAGAZINE            |
                                    CHANGER_REPORT_IEPORT_STATE;

    if (changerData->DriveID == PLASMON_DSERIES) {
        changerParameters->Features1 = (CHANGER_SLOTS_USE_TRAYS | 
                                        CHANGER_TRUE_EXCHANGE_CAPABLE);
    }

    if (changerData->DriveID == PLASMON_FTA) {
        changerParameters->Features0 |= (CHANGER_PREDISMOUNT_EJECT_REQUIRED |
                                         CHANGER_DRIVE_CLEANING_REQUIRED    |
                                         CHANGER_CLEANER_ACCESS_NOT_VALID);

        changerParameters->Features0 &= ~(CHANGER_CLOSE_IEPORT      |
                                          CHANGER_OPEN_IEPORT       |
                                          CHANGER_CARTRIDGE_MAGAZINE);
    }

    if (changerData->BarCodeReaderInstalled) {
        changerParameters->Features0 |= CHANGER_BAR_CODE_SCANNER_INSTALLED;
    }

    changerParameters->PositionCapabilities = (CHANGER_TO_SLOT | CHANGER_TO_IEPORT | CHANGER_TO_DRIVE);
    changerParameters->LockUnlockCapabilities = (LOCK_UNLOCK_IEPORT | LOCK_UNLOCK_DOOR);

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    cdb->MODE_SENSE.Dbd = 1;
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            NULL,
                                            0,
                                            FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);
    RtlMoveMemory(productData->SerialNumber, changerData->InquiryData.VendorSpecific, SERIAL_NUMBER_LENGTH);

    //
    // Indicate drive type and whether media is two-sided.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the IEPort.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    UCHAR IePortCode = 0;
    UCHAR ControlCode = 0;


    if (ElementOutOfRange(addressMapping, (USHORT)setAccess->Element.ElementAddress, setAccess->Element.ElementType)) {
        DebugPrint((1,
                   "ChangerSetAccess: Element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;

    if (setAccess->Element.ElementType == ChangerDoor) {

        if (controlOperation == LOCK_ELEMENT) {

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // Issue prevent media removal command to lock the door.
            //

            cdb->MEDIA_REMOVAL.Prevent = 1;

        } else if (controlOperation == UNLOCK_ELEMENT) {

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // Issue allow media removal.
            //

            cdb->MEDIA_REMOVAL.Prevent = 0;
        } else {

            status = STATUS_INVALID_PARAMETER;
        }

    } else if (setAccess->Element.ElementType == ChangerIEPort) {

        if (changerData->DriveID == PLASMON_DSERIES) {
            IePortCode = SCSIOP_OPEN_IEPORT_DSERIES;
            ControlCode = PLASMON_DSERIES_IEPORT_LOCK;
        } else {
            IePortCode = SCSIOP_OPEN_IEPORT_FTA;
            ControlCode = PLASMON_FTA_IEPORT_LOCK;
        }

        if (addressMapping->NumberOfElements[ChangerIEPort] == 0) {
            status = STATUS_INVALID_PARAMETER;
        } else {

            if (controlOperation == LOCK_ELEMENT) {

                cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

                //
                // Issue prevent media removal command to lock the ie port.
                //

                cdb->MEDIA_REMOVAL.Prevent = 1;
                cdb->MEDIA_REMOVAL.Control = ControlCode;

            } else if (controlOperation == UNLOCK_ELEMENT) {

                cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

                //
                // Issue allow media removal.
                //

                cdb->MEDIA_REMOVAL.Prevent = 0;
                cdb->MEDIA_REMOVAL.Control = ControlCode;

            } else if (controlOperation == EXTEND_IEPORT) {

                //
                // The Plasmon CAN extend and retract the ieport,
                // but the plastic trays for the disc need to come from
                // a slot. So disallow direct access to this feature.
                //

                srb->TimeOutValue = fdoExtension->TimeOutValue;
                cdb->CDB6GENERIC.OperationCode = IePortCode; //SCSIOP_OPEN_IEPORT;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = PLASMON_MAILSLOT_OPEN;

                //status = STATUS_INVALID_PARAMETER;

            } else if (controlOperation == RETRACT_IEPORT) {

                srb->TimeOutValue = fdoExtension->TimeOutValue;
                cdb->CDB6GENERIC.OperationCode = IePortCode; //SCSIOP_OPEN_IEPORT;
                cdb->CDB6GENERIC.CommandUniqueBytes[2] = PLASMON_MAILSLOT_CLOSE;

                //status = STATUS_INVALID_PARAMETER;

            } else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
    } else {

        //
        // No keypad selectivity programatically.
        //

        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // Issue the srb.
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                                srb,
                                                NULL,
                                                0,
                                                FALSE);

    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    ULONG    totalElements = 0;
    NTSTATUS status;
    PVOID    statusBuffer;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;


    if (((changerData->DriveID) == PLASMON_DSERIES) &&
         (readElementStatus->VolumeTagInfo)) {

        //
        // These units have no Volume tag capability.
        //

        return STATUS_INVALID_PARAMETER;
    }

    if (elementType == AllElements ||
        elementType == ChangerSlot) {

        //
        // Build bitmap of available slot locations.
        //

        status = BuildMagazineMap(DeviceObject);

    }

    if (elementType == AllElements) {

        ULONG i;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;
            totalElements += addressMapping->NumberOfElements[i];
        }

        if (totalElements != readElementStatus->ElementList.NumberOfElements) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) AllElements\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements));

            return STATUS_INVALID_PARAMETER;
        }

        //
        // Account for length of the descriptors expected for the drives.
        //


        length = sizeof(PLASMON_ELEMENT_DESCRIPTOR) * totalElements;

        //
        // Add in header and status pages.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);


    } else {

        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType)) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        totalElements = readElementStatus->ElementList.NumberOfElements;
        if (totalElements > addressMapping->NumberOfElements[elementType]) {

            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) for type (%x)\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements,
                       elementType));

            return STATUS_INVALID_PARAMETER;
        }

        length = (sizeof(PLASMON_ELEMENT_DESCRIPTOR) * totalElements);

        //
        // Add in length of header and status page.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);
    }

    DebugPrint((2,
               "ChangerGetElementStatus: Allocation Length %x, for %x elements of type %x\n",
               length,
               totalElements,
               elementType));

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // may not have the low address as 0.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(totalElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(totalElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);

    if (NT_SUCCESS(status) ||
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        if (remainingElements < 0 ) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Returned elements less than zero - %x\n",
                       remainingElements));

            ChangerClassFreePool(srb);
            ChangerClassFreePool(statusBuffer);

            return STATUS_IO_DEVICE_ERROR;
        }

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        if (typeCount < 0) {
            DebugPrint((1,
                       "ChangerGetElementStatus (1): Count of type %x less than zero - %x\n",
                       elementType,
                       typeCount));

            ChangerClassFreePool(srb);
            ChangerClassFreePool(statusBuffer);

            return STATUS_IO_DEVICE_ERROR;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;


                if (elementType == ChangerDrive) {

                    if (elementDescriptor->IdValid) {
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }
                    if (elementDescriptor->LunValid) {
                        elementStatus->Lun = elementDescriptor->Lun;
                    }
                }

                if (elementDescriptor->SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];
                    elementStatus->Flags |= ELEMENT_STATUS_SVALID;
                }

                //
                // Build Flags field.
                //

                elementStatus->Flags |= elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);

                //
                // Map any exceptions reported directly.
                // If there is volume info returned ensure that it's not all spaces
                // as this indicates that the label is missing or unreadable.
                //

                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {

                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                }

                if ((changerData->DriveID == PLASMON_DSERIES) &&
                    (elementType == ChangerSlot) &&
                    ((changerData->SlotsPerMag) != 0)) {

                    ULONG magNumber;

                    //
                    // Make sure that the magazine for this slot is really there.
                    //

                    magNumber = elementStatus->Element.ElementAddress / changerData->SlotsPerMag;
                    if (!(changerData->MagazinePresent & (1 << magNumber))) {

                        elementStatus->Flags |= ELEMENT_STATUS_EXCEPT;
                        elementStatus->ExceptionCode = ERROR_SLOT_NOT_PRESENT;
                        DebugPrint((1,
                                    "Plasmc: Slot %x in non-existant magazine (%x)\n",
                                    elementStatus->Element.ElementAddress,
                                    magNumber));

                    }
                }

                if ((readElementStatus->VolumeTagInfo) &&
                    ((changerData->DriveID) == PLASMON_FTA)) {
                    PLASMON_ELEMENT_DESCRIPTOR *plasmonDescriptor =
                        (PLASMON_ELEMENT_DESCRIPTOR *) elementDescriptor;

                    RtlFillMemory(elementStatus->PrimaryVolumeID,
                                  MAX_VOLUME_ID_SIZE,
                                  ' ');

                    RtlFillMemory(elementStatus->AlternateVolumeID,
                                  MAX_VOLUME_ID_SIZE,
                                  ' ');

                    RtlCopyMemory(elementStatus->PrimaryVolumeID,
                                  plasmonDescriptor->PLASMON_FTA_DESCRIPTOR.BarCode,
                                  32);
                    elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                }

                //
                // Get next descriptor.
                //

                (ULONG_PTR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                elementStatus += 1;

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * totalElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            NULL,
                                            0,
                                            FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += addressMapping->FirstElement[setPosition->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    //
    // Doesn't support two-sided media, but as a ref. source base, it should be noted.
    //

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;


    srb->DataTransferLength = 0;
    srb->TimeOutValue = 200;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            NULL,
                                            0,
                                            TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{


    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_EXCHANGE_MEDIUM exchangeMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination1, destination2;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(exchangeMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(exchangeMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, exchangeMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination1 = (USHORT)(exchangeMedium->Destination1.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination1, exchangeMedium->Destination1.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination2 = (USHORT)(exchangeMedium->Destination2.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination2, exchangeMedium->Destination2.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[exchangeMedium->Source.ElementType];
    destination1 += addressMapping->FirstElement[exchangeMedium->Destination1.ElementType];
    destination2 += addressMapping->FirstElement[exchangeMedium->Destination2.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->EXCHANGE_MEDIUM.OperationCode = SCSIOP_EXCHANGE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->EXCHANGE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->EXCHANGE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->EXCHANGE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->EXCHANGE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[0] = (UCHAR)(destination1 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[1] = (UCHAR)(destination1 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[0] = (UCHAR)(destination2 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[1] = (UCHAR)(destination2 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Flip1 = exchangeMedium->Flip1;
    cdb->EXCHANGE_MEDIUM.Flip2 = exchangeMedium->Flip2;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            NULL,
                                            0,
                                            FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_EXCHANGE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport;
    USHORT source;
    USHORT destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status = STATUS_SUCCESS;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            NULL,
                                            0,
                                            FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    } else {
        DebugPrint((1,
                   "MoveMedium: Status of Move %x\n",
                   status));
    }

    ChangerClassFreePool(srb);

    DebugPrint((1,
               "MoveMedium: Returning %x\n",
               status));
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;



    //
    // Issue a rezero unit to the device.
    //

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_REZERO_UNIT;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;


    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            NULL,
                                            0,
                                            FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT);
    }

    //
    // Clear locks.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
    cdb->MEDIA_REMOVAL.Prevent = 0;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            NULL,
                                            0,
                                            FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
PlasmonBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    ULONG                  bufferLength;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);


    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = PLAS_NO_ELEMENT;
    }

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    cdb->MODE_SENSE.Dbd = 1;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];
        addressMapping->FirstElement[ChangerDoor] = 0;

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = PLAS_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}



NTSTATUS
BuildMagazineMap(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate commands and builds a bitmap indicating
    available magazines.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA            changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSCSI_REQUEST_BLOCK    srb;
    PREAD_MAGAZINE_STATUS  cdb;
    NTSTATUS               status;
    ULONG                  length;
    PVOID                  statusBuffer;
    ULONG i;

    //
    // If we are already building magazin map, do nothing.
    // This will avoid recursion when ChangerError calls
    // BuildMagazineMap
    //
    if ((changerData->BuildMagazineMapInProgress)) {
        changerData->BuildMagazineMapInProgress = FALSE;
        return STATUS_SUCCESS;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PREAD_MAGAZINE_STATUS)srb->Cdb;

    length = sizeof(MAGAZINE_STATUS_HEADER) + (sizeof(MAGAZINE_DESCRIPTOR) * changerData->MagazineSlots);

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build the request.
    //

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    if ((changerData->DriveID) == PLASMON_DSERIES) {
        cdb->OperationCode = SCSIOP_READ_MAG_STATUS_DSERIES;
    } else if ((changerData->DriveID) == PLASMON_FTA) {
        cdb->OperationCode = SCSIOP_READ_MAG_STATUS_FTA;
    } else {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(statusBuffer);

        return STATUS_INVALID_DEVICE_REQUEST;
    }
    
    cdb->FirstMagazineNumber[0] = 0x00;
    cdb->FirstMagazineNumber[1] = 0x01;

    cdb->NumberOfMagazines[0] = (UCHAR)(changerData->MagazineSlots >> 8);
    cdb->NumberOfMagazines[1] = (UCHAR)(changerData->MagazineSlots & 0xFF);

    cdb->AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->AllocationLength[2] = (UCHAR)(length & 0xFF);

    changerData->BuildMagazineMapInProgress = TRUE;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);

    if (NT_SUCCESS(status)) {

        PMAGAZINE_STATUS_HEADER statusHeader;
        PMAGAZINE_DESCRIPTOR magDescriptor;
        ULONG numberMags;
        USHORT firstElement;

        statusHeader = (PMAGAZINE_STATUS_HEADER)statusBuffer;
        magDescriptor = (PMAGAZINE_DESCRIPTOR)statusHeader;
        (ULONG_PTR)magDescriptor += sizeof(MAGAZINE_STATUS_HEADER);

        //
        // Verify some information in the header.
        //

        numberMags = statusHeader->NumberOfMagazines[1];
        numberMags += (statusHeader->NumberOfMagazines[0] << 8);

        if (numberMags != changerData->MagazineSlots) {
            DebugPrint((1,
                       "Plasmc: Mismatch of magazine information. Expected %x, got %x\n",
                       changerData->MagazineSlots,
                       numberMags));

        }

        changerData->MagazinePresent = 0;
        changerData->SlotsPerMag = 0;

        //
        // Keep track of the first element of the first magazine.
        // Use this later to determine how many slots are in each
        // magazine.
        //

        firstElement = magDescriptor->FirstElementAddress[1];
        firstElement += magDescriptor->FirstElementAddress[0] << 8;

        //
        // Loop through descriptors and set appropriate bits.
        //

        for (i = 0; i < numberMags; i++) {
            if ((magDescriptor->Description) & MAGAZINE_FULL) {
                changerData->MagazinePresent |= 1 << i;
                DebugPrint((2,
                           "Plasmc: Magazine %x present\n",
                           magDescriptor->MagazineNumber));
            }

            if (!changerData->SlotsPerMag) {
                changerData->SlotsPerMag = magDescriptor->FirstElementAddress[1];
                changerData->SlotsPerMag += magDescriptor->FirstElementAddress[0] << 8;

                changerData->SlotsPerMag -= firstElement;
                DebugPrint((1,
                           "Plasmc: Slots per magazine - %x\n",
                           changerData->SlotsPerMag));

            }


            //
            // Advance to next descriptor.
            //

            magDescriptor++;
        }
    }

    changerData->BuildMagazineMapInProgress = FALSE;

    ChangerClassFreePool(statusBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{

    ULONG exceptionCode = 0;
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;


    switch (asc) {
        case 0x0:
            break;

        case 0x83: {
            if (ascq == 0x09) {
                exceptionCode = ERROR_LABEL_UNREADABLE;
            }

            break;
        }

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    DebugPrint((1,
               "plasmc.MapExceptionCode: ASC %x, ASCQ %x, exceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;

}


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == PLAS_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}

                                                                                                                                                             

NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize the devicestatus in the device extension to 
   // PLASMC_DEVICE_PROBLEM_NONE. If the changer returns sense code
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set an appropriate 
   // devicestatus.
   //
   changerData->DeviceStatus = PLASMC_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "PLASMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set SelfTest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) != PLASMC_DEVICE_PROBLEM_NONE) {
      switch (changerData->DeviceStatus) {
         case PLASMC_HW_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }

         case PLASMC_CHM_MOVE_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemCHMMoveError;
            break;
         }

         case PLASMC_TARGET_FAILURE: {
            changerDeviceError->ChangerProblemType = DeviceProblemCalibrationError;
            break;
         }

         default: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }
      } // switch (changerData->DeviceStatus)
   }

   ChangerClassFreePool(srb);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\powerfil\powerfil.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    powerfil.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _POWERFIL_H
#define _POWERFIL_H

//
// Drive type
//
#define POWERFILE_DVD    1

#define STARMATX_NO_ELEMENT          0xFFFF

#define SCSI_VOLUME_ID_LENGTH    32
typedef struct _SCSI_VOLUME_TAG {
   UCHAR VolumeIdentificationField[SCSI_VOLUME_ID_LENGTH];
   UCHAR Reserved1[2];
   ULONG VolumeSequenceNumber;
} SCSI_VOLUME_TAG, *PSCSI_VOLUME_TAG;


typedef struct _STARMATX_ELEMENT_DESCRIPTOR {
 UCHAR ElementAddress[2];
 UCHAR Full : 1;
 UCHAR ImpExp : 1;
 UCHAR Except : 1;
 UCHAR Access : 1;
 UCHAR ExEnab : 1;
 UCHAR InEnab : 1;
 UCHAR Reserved1 : 2;
 UCHAR Reserved2;
 UCHAR AdditionalSenseCode;
 UCHAR AddSenseCodeQualifier;
 UCHAR Lun : 3;
 UCHAR Reserved3 : 1;
 UCHAR LUValid :1;
 UCHAR IDValid :1;
 UCHAR Reserved4 : 1;
 UCHAR NotBus : 1;
 UCHAR SCSIBusAddress;
 UCHAR Reserved5 ;
 UCHAR Reserved6 :6;
 UCHAR Invert : 1;
 UCHAR SValid : 1;
 UCHAR SourceStorageElementAddress[2];
 UCHAR Reserved7 [4];
} STARMATX_ELEMENT_DESCRIPTOR, *PSTARMATX_ELEMENT_DESCRIPTOR;
 
typedef struct _STARMATX_ELEMENT_DESCRIPTOR_PLUS {
   UCHAR ElementAddress[2];
   UCHAR Full : 1;
   UCHAR ImpExp : 1;
   UCHAR Except : 1;
   UCHAR Access : 1;
   UCHAR ExEnab : 1;
   UCHAR InEnab : 1;
   UCHAR Reserved1 : 2;
   UCHAR Reserved2;
   UCHAR AdditionalSenseCode;
   UCHAR AddSenseCodeQualifier;
   UCHAR Lun : 3;
   UCHAR Reserved3 : 1;
   UCHAR LUValid :1;
   UCHAR IDValid :1;
   UCHAR Reserved4 : 1;
   UCHAR NotBus : 1;
   UCHAR SCSIBusAddress;
   UCHAR Reserved5 ;
   UCHAR Reserved6 :6;
   UCHAR Invert : 1;
   UCHAR SValid : 1;
   UCHAR SourceStorageElementAddress[2];
   SCSI_VOLUME_TAG PrimaryVolumeTag;
   SCSI_VOLUME_TAG AlternateVolumeTag;
   UCHAR Reserved7 [4];
} STARMATX_ELEMENT_DESCRIPTOR_PLUS, *PSTARMATX_ELEMENT_DESCRIPTOR_PLUS;


typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Drive type
    //

    ULONG DriveType;

    //
    // Drive Id. Based on inquiry.
    //

    ULONG DriveID;

    //
    // Lock count
    //
    ULONG LockCount;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

} CHANGER_DATA, *PCHANGER_DATA;



NTSTATUS
StarMatxBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif // _POWERFIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\pnrmc\pnrmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    pnrmc.c

Abstract:

    This module contains device-specific routines for Pioneer DRM-1004 CD Library changers.

Author:

    chuckp (Chuck Park)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "pnrmc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, PNRBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the Pioneer changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //

    status = PNRBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    //
    // Determine drive type.
    //

    if (RtlCompareMemory(dataBuffer->ProductId,"CHANGR DRM-1004X",16) == 16) {
        changerData->DeviceID = DRM_1004;
    }

    ChangerClassFreePool(dataBuffer);

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA                changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
       switch (senseBuffer->SenseKey) {
           case SCSI_SENSE_NOT_READY:
   
               if ((senseBuffer->AdditionalSenseCode == 0x53) &&
                   (senseBuffer->AdditionalSenseCodeQualifier == 0x82)) {
   
                   //
                   // Indicate that the door is open.
                   //
   
                   *Status = STATUS_DEVICE_DOOR_OPEN;
                   *Retry = FALSE;
               } else if ((senseBuffer->AdditionalSenseCode == 0x53) &&
                       (senseBuffer->AdditionalSenseCodeQualifier == 0x88)) {
   
                   //
                   // IEPORT is extended.
                   //
   
                   *Status = STATUS_DEVICE_NOT_READY;
                   *Retry = TRUE;
               }
   
               break;
   
           case SCSI_SENSE_UNIT_ATTENTION:
               if ((senseBuffer->AdditionalSenseCode == 0x28) &&
                   (senseBuffer->AdditionalSenseCodeQualifier == 0x01)) {
   
                   //
                   // Indicate that the door was opened and reclosed.
                   //
   
                   *Status = STATUS_MEDIA_CHANGED;
                   *Retry = FALSE;
               }
   
               break;
   
           case SCSI_SENSE_HARDWARE_ERROR:    {
               changerData->HardwareError = TRUE;
               break;
           }
       }
    }
    
    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    DVL changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA                changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK          srb;
    PGET_CHANGER_PARAMETERS      changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE   elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE  transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    PVOID    modeBuffer;
    PCDB     cdb;
    ULONG    i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];

        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];

        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = PNR_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    DebugPrint((1,"GetParams: First addresses\n"));
    DebugPrint((1,"Transport: %x\n",
                elementAddressPage->MediumTransportElementAddress[1]));
    DebugPrint((1,"Slot: %x\n",
                elementAddressPage->FirstStorageElementAddress[1]));
    DebugPrint((1,"Ieport: %x\n",
                elementAddressPage->FirstIEPortElementAddress[1]));
    DebugPrint((1,"Drive: %x\n",
                elementAddressPage->FirstDataXFerElementAddress[1]));
    DebugPrint((1,"LowAddress: %x\n",
                addressMapping->LowAddress));

    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;

    changerParameters->MagazineSize = 50;
    changerParameters->DriveCleanTimeout = 0;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 = CHANGER_OPEN_IEPORT         |
                                   CHANGER_REPORT_IEPORT_STATE |
                                   CHANGER_CARTRIDGE_MAGAZINE  |
                                   CHANGER_DEVICE_REINITIALIZE_CAPABLE;

    changerParameters->Features1 = CHANGER_IEPORT_USER_CONTROL_CLOSE; 

    //
    // build device caps mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_DEVICE_CAPABILITIES_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;



    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);

    //
    // Indicate drive type.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the IEPort/ Front panel.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    BOOLEAN             writeToDevice = FALSE;


    if (ElementOutOfRange(addressMapping, (USHORT)setAccess->Element.ElementAddress, setAccess->Element.ElementType)) {
        DebugPrint((1,
                   "ChangerSetAccess: Element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Nothing can be locked and the ieport can only be extended.
    //

    if (controlOperation == EXTEND_IEPORT) {
        if (setAccess->Element.ElementType == ChangerIEPort) {

            USHORT              transport;
            USHORT              destination;

            //
            // The pioneer units use Position to Element as the method of opening the IEPort.
            //

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;

            srb->CdbLength = CDB10GENERIC_LENGTH;
            cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

            transport = addressMapping->FirstElement[ChangerTransport];
            destination = addressMapping->FirstElement[ChangerIEPort];

            DebugPrint((1,
                       "SetAccess: Transport %x, Destination %x\n",
                       transport,
                       destination));

            //
            // Build device-specific addressing.
            //

            cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
            cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

            cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
            cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

            srb->DataTransferLength = 0;
            srb->TimeOutValue = 200;

        } else {
            status = STATUS_INVALID_PARAMETER;
        }
    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // Issue the srb.
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             srb->DataBuffer,
                                             srb->DataTransferLength,
                                             writeToDevice);
    }

    ChangerClassFreePool(srb);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    NTSTATUS status;
    PVOID    statusBuffer;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;


    if (readElementStatus->VolumeTagInfo) {

        return STATUS_INVALID_PARAMETER;
    }

    if (elementType == AllElements) {

        ULONG i;
        ULONG totalElements = 0;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;

            //
            // Add these up instead of using the number passed in the user's buffer, as the driver
            // fakes that there are no IEPorts.
            //

            totalElements += addressMapping->NumberOfElements[i];
        }

        //
        // Determine length of the descriptors expected for the elements.
        //

        length = (sizeof(PNR_ELEMENT_DESCRIPTOR) * totalElements);

        //
        // Add in header and status pages.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);


    } else {


        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType)) {
            DebugPrint((1,
                        "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        length = (sizeof(PNR_ELEMENT_DESCRIPTOR) * readElementStatus->ElementList.NumberOfElements);

        //
        // Add in length of header and status page.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);

    }

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // Ensure that starting address is valid.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (NT_SUCCESS(status) ||
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (PCHAR)statusPage = (PCHAR)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;

                //
                // Source address
                //

                if (elementDescriptor->SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                    elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                }

                if (elementDescriptor->IdValid) {
                    elementStatus->TargetId = elementDescriptor->BusAddress;
                }
                if (elementDescriptor->LunValid) {
                    elementStatus->Lun = elementDescriptor->Lun;
                }

                //
                // Build Flags field.
                //

                elementStatus->Flags |= elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);


                //
                // Map the exceptions.
                //

                if (elementDescriptor->Exception) {
                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);

                    if (elementStatus->ExceptionCode == 0) {

                        //
                        // The Pioneer marks an exception on No media and IEPort extended.
                        // Turn it off.
                        //

                        elementStatus->Flags &=~ELEMENT_STATUS_EXCEPT;
                    }
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                elementStatus += 1;
            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:


--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_EXCHANGE_MEDIUM exchangeMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination1, destination2;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(exchangeMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(exchangeMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, exchangeMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination1 = (USHORT)(exchangeMedium->Destination1.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination1, exchangeMedium->Destination1.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination2 = (USHORT)(exchangeMedium->Destination2.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination2, exchangeMedium->Destination2.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[exchangeMedium->Source.ElementType];
    destination1 += addressMapping->FirstElement[exchangeMedium->Destination1.ElementType];
    destination2 += addressMapping->FirstElement[exchangeMedium->Destination2.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->EXCHANGE_MEDIUM.OperationCode = SCSIOP_EXCHANGE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->EXCHANGE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->EXCHANGE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->EXCHANGE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->EXCHANGE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[0] = (UCHAR)(destination1 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[1] = (UCHAR)(destination1 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[0] = (UCHAR)(destination2 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[1] = (UCHAR)(destination2 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Flip1 = exchangeMedium->Flip1;
    cdb->EXCHANGE_MEDIUM.Flip2 = exchangeMedium->Flip2;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_EXCHANGE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;


    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;



    //
    // Issue a rezero unit to the device.
    //

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_REZERO_UNIT;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;


    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
PNRBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = PNR_NO_ELEMENT;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = PNR_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }

        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }


    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;
    ULONG exceptionCode = 0;

    switch (asc) {
        case 0x00:

            //
            // No error.
            //

            exceptionCode = 0;
            break;

        case 0x04:
            if (ascq == 0x02) {
                exceptionCode = ERROR_INIT_STATUS_NEEDED;
            } else if (ascq == 0x03) {
                exceptionCode = ERROR_SLOT_NOT_PRESENT;
            }
        case 0x3A:
            if (ascq == 0x0) {

                DebugPrint((2,
                           "PNRMC: FW reports no media as exception\n"));
                exceptionCode = 0;

            }
        case 0x53:
            if (ascq == 0x88) {

                //
                // IEPort extended.
                //

                exceptionCode = 0;
            }
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
            break;
    }

    DebugPrint((2,
               "PNRMC: MapExceptionCode - ASC %x, ASCQ %x ExceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;

}



BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == PNR_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++ 

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{

   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize the flag in the device extension to FALSE.
   // If the changer returns sense code SCSI_SENSE_HARDWARE_ERROR
   // on SelfTest, we'll set this flag to TRUE in ChangerError routine.
   //
   changerData->HardwareError = FALSE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "PNRMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set SelfTest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->HardwareError) == TRUE) {
      changerDeviceError->ChangerProblemType = DeviceProblemHardware;
   }

   ChangerClassFreePool(srb);

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\qualstar\qlstrmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    qlstrmc.c

Abstract:

    This module contains device-specific routines for Qualstar's 
        medium changers:
            TLS-4xxx (w/Exabyte 8mm Drives, Sony SDX300 8mm Drives)
            TLS-2xxx (w/HP, Conner/Seagate, Sony 4mm Drives)

Author:

    davet (Dave Therrien)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "qlstrmc.h"


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, ExaBuildAddressMapping)
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the qualstar changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}




NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;
    PCONFIG_MODE_PAGE    modeBuffer;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //

    status = ExaBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((1,
                    "BuildAddressMapping failed. %x\n", status));
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        DebugPrint((1,
                    "BuildAddressMapping failed. %x\n", status));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         dataBuffer,
                                         sizeof(INQUIRYDATA),
                                         FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

        //
        // Determine drive id.
        //

        if (RtlCompareMemory(dataBuffer->ProductId,"TLS-4210",8) == 8) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-4210A",9) == 9) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-4220",8) == 8) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-4420",8) == 8) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-4440",8) == 8) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-4480",8) == 8) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-4660",8) == 8) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-46120",9) == 9) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-2218",8) == 8) {
            changerData->DriveID = TLS_2xxx;
            changerData->DriveType = D_4MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-2218A",9) == 9) {
            changerData->DriveID = TLS_2xxx;
            changerData->DriveType = D_4MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-2236",8) == 8) {
            changerData->DriveID = TLS_2xxx;
            changerData->DriveType = D_4MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-2436",8) == 8) {
            changerData->DriveID = TLS_2xxx;
            changerData->DriveType = D_4MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-2472",8) == 8) {
            changerData->DriveID = TLS_2xxx;
            changerData->DriveType = D_4MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-24144",9) == 9) {
            changerData->DriveID = TLS_2xxx;
            changerData->DriveType = D_4MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"QLS SDX 220",11) == 11) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"QLS SDX 420",11) == 11) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"QLS SDX 440",11) == 11) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"QLS SDX 480",11) == 11) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"QLS SDX 660",11) == 11) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"QLS SDX 6120",12) == 12) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"QLS 4G 236",10) == 10) {
            changerData->DriveID = TLS_2xxx;
            changerData->DriveType = D_4MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"QLS 4G 436",10) == 10) {
            changerData->DriveID = TLS_2xxx;
            changerData->DriveType = D_4MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"QLS 4G 472",10) == 10) {
            changerData->DriveID = TLS_2xxx;
            changerData->DriveType = D_4MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"QLS 4G 4144",11) == 11) {
            changerData->DriveID = TLS_2xxx;
            changerData->DriveType = D_4MM;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"TLS-412360", 10) == 10) {
            changerData->DriveID = TLS_4xxx;
            changerData->DriveType = D_8MM;
        }
    }

    ChangerClassFreePool(dataBuffer);

    // 
    // -------------------------------------------------------------------------
    // 
    // THREE Library Config parameters will be set by this driver
    // 
    // 1) Config/Hndlr/DoorOpen/Hold
    //      ( to deal with someone opening the front door randomly

    
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                                   sizeof(CONFIG_MODE_PAGE));
    if (!modeBuffer) {
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(CONFIG_MODE_PAGE));
    modeBuffer->PageCode = 0x3D;
    modeBuffer->PageLength = 0x28;
    modeBuffer->Length = 0;
    modeBuffer->Type = 0;
    modeBuffer->Write = 1;
    RtlMoveMemory(modeBuffer->VariableName,"HNDLR_DOOR_OPEN", 15);
    RtlMoveMemory(modeBuffer->VariableValue,"HOLD", 4);

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);
    srb.CdbLength = CDB6GENERIC_LENGTH;
    srb.TimeOutValue = 20;
    srb.DataTransferLength = sizeof(CONFIG_MODE_PAGE);
    srb.DataBuffer = modeBuffer;

    cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
    cdb->MODE_SELECT.PFBit = 1;
    cdb->MODE_SELECT.ParameterListLength = (UCHAR)srb.DataTransferLength;
   
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             &srb,
                                             modeBuffer,
                                             sizeof(CONFIG_MODE_PAGE),
                                             TRUE);
    ChangerClassFreePool(modeBuffer);

    // -----------------------------------------------------------
    // 2) Config/Hndlr/Io Call Key / Disabled
    //      ( to allow NTMS to timeout )
   
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                                   sizeof(CONFIG_MODE_PAGE));
    if (!modeBuffer) {
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(CONFIG_MODE_PAGE));
    modeBuffer->PageCode = 0x3D;
    modeBuffer->PageLength = 0x28;
    modeBuffer->Length = 0;
    modeBuffer->Type = 0;
    modeBuffer->Write = 1;
    RtlMoveMemory(modeBuffer->VariableName,"HNDLR_IO_CALL_KEY", 17);
    RtlMoveMemory(modeBuffer->VariableValue,"DISABLE", 7);

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);
    srb.CdbLength = CDB6GENERIC_LENGTH;
    srb.TimeOutValue = 20;
    srb.DataTransferLength = sizeof(CONFIG_MODE_PAGE);
    srb.DataBuffer = modeBuffer;

    cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
    cdb->MODE_SELECT.PFBit = 1;
    cdb->MODE_SELECT.ParameterListLength = (UCHAR)srb.DataTransferLength;
   
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             &srb,
                                             modeBuffer,
                                             sizeof(CONFIG_MODE_PAGE),
                                             TRUE);
    ChangerClassFreePool(modeBuffer);

    // -----------------------------------------------------------
    // 3) Disable CALL key, only allow host control

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                                   sizeof(CONFIG_MODE_PAGE));
    if (!modeBuffer) {
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(CONFIG_MODE_PAGE));
    modeBuffer->PageCode = 0x3D;
    modeBuffer->PageLength = 0x28;
    modeBuffer->Length = 0;
    modeBuffer->Type = 0;
    modeBuffer->Write = 1;
    RtlMoveMemory(modeBuffer->VariableName,"HNDLR_IO_SLOT_ACCESS", 20);
    RtlMoveMemory(modeBuffer->VariableValue,"HOST", 4);

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);
    srb.CdbLength = CDB6GENERIC_LENGTH;
    srb.TimeOutValue = 20;
    srb.DataTransferLength = sizeof(CONFIG_MODE_PAGE);
    srb.DataBuffer = modeBuffer;

    cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
    cdb->MODE_SELECT.PFBit = 1;
    cdb->MODE_SELECT.ParameterListLength = (UCHAR)srb.DataTransferLength;
   
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             &srb,
                                             modeBuffer,
                                             sizeof(CONFIG_MODE_PAGE),
                                             TRUE);
    ChangerClassFreePool(modeBuffer);

    // -----------------------------------------------------------

    return STATUS_SUCCESS;
}

VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_NOT_READY:

            if (senseBuffer->AdditionalSenseCode == 0x04) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x83:

                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_DOOR_OPEN;
                        break;
                }
            }

            break;

        case SCSI_SENSE_ILLEGAL_REQUEST:
            if (senseBuffer->AdditionalSenseCode == 0x80) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x03:
                    case 0x04:

                        *Retry = FALSE;
                        *Status = STATUS_MAGAZINE_NOT_PRESENT;
                         break;
                    case 0x05:
                    case 0x06:
                        *Retry = TRUE;
                        *Status = STATUS_DEVICE_NOT_CONNECTED;
                        break;
                default:
                    break;
                }
            }
            break;

        case SCSI_SENSE_HARDWARE_ERROR: {
           DebugPrint((1, "Hardware Error - SenseCode %x, ASC %x, ASCQ %x\n",
                       senseBuffer->SenseKey,
                       senseBuffer->AdditionalSenseCode,
                       senseBuffer->AdditionalSenseCodeQualifier));
           changerData->HardwareError = TRUE;
           break;
        }

        default:
            break;
        }
    }


    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    qualstar changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    length;
    PVOID    modeBuffer;
    PCDB     cdb;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);
    changerParameters->NumberOfDoors = 1;

    // There can be many FIXED slots in the various models of these
    // libraries and none are identified as a cleaner. 
    // This unit also numbers its slots based on the
    // front panel setting. We will suggest setting 
    // the Configure\SCSI\StorageOrder to MAG making
    // slot 1..N order be A01, A02... B01, ... F1, F2... 
    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;
    changerParameters->FirstCleanerSlotAddress = 0;

    if (changerData->DriveID == TLS_2xxx) {
        changerParameters->MagazineSize = 18;
    } else {
        changerParameters->MagazineSize = 10;
    }

    changerParameters->DriveCleanTimeout = 600;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_PAGE_TRANSPORT_GEOMETRY));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_TRANSPORT_GEOMETRY_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_TRANSPORT_GEOMETRY_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (ULONG_PTR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);

        
    // initialize Features1  
    changerParameters->Features1 = 0;
        // Took away Exchange capability. The device supports the command
        // but a customer may load a medium into the exchange slot and 
        // cause an exchange to fail. Since the picker does not support 
        // holding two media, this device does not really support it. 
        // CHANGER_TRUE_EXCHANGE_CAPABLE;

    //
    // Determine if mc has 2-sided media.
    //

    changerParameters->Features0 = transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;



    //
    // Qualstar indicates whether a bar-code scanner is
    // attached by setting bit-0 in this byte.
    //

    changerParameters->Features0 |= ((changerData->InquiryData.VendorSpecific[19] & 0x1)) ?
                                         CHANGER_BAR_CODE_SCANNER_INSTALLED : 0;
    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 |= CHANGER_INIT_ELEM_STAT_WITH_RANGE     |
                                    CHANGER_CARTRIDGE_MAGAZINE            |
                                    CHANGER_PREDISMOUNT_EJECT_REQUIRED    |
                                    CHANGER_DRIVE_CLEANING_REQUIRED;
 
    if (changerParameters->NumberIEElements != 0) {
        changerParameters->Features0 |= CHANGER_CLOSE_IEPORT                  |
                                        CHANGER_OPEN_IEPORT                   |
                                        CHANGER_LOCK_UNLOCK                   |
                                        CHANGER_REPORT_IEPORT_STATE; 

        changerParameters->LockUnlockCapabilities = LOCK_UNLOCK_IEPORT;
    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Qualstar uses an addition 4 bytes...
    //

    length =  sizeof(MODE_PARAMETER_HEADER) +                            
              sizeof(MODE_DEVICE_CAPABILITIES_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, length);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = length;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = 0;
    changerParameters->ExchangeFromSlot = 0;
    changerParameters->ExchangeFromIePort = 0;
    changerParameters->ExchangeFromDrive = 0;


        // legal Position capabilities... 
        changerParameters->PositionCapabilities = 0;
        
                
    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}



NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    //
    // Copy cached inquiry data fields into the system buffer.
    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA)); 
    RtlMoveMemory(productData->VendorId, 
         changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, 
         changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, 
         changerData->InquiryData.ProductRevisionLevel, 4);
    RtlMoveMemory(productData->SerialNumber, "", 1);    

    //
    // Indicate that this is a tape changer and that media isn't two-sided.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}




NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the door or IEPort. Value can be one of the
    following:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;

    // should not be called by an app, but if it is, just return OK
    if ((setAccess->Element.ElementType == ChangerKeypad) || 
        (setAccess->Element.ElementType == ChangerDoor)) { 
                return STATUS_INVALID_DEVICE_REQUEST;
    }

    // if the unit has no IEPORT, fail the request
    if ((setAccess->Element.ElementType == ChangerIEPort) && 
        (changerData->AddressMapping.NumberOfElements[ChangerIEPort] == 0)) {
            return STATUS_INVALID_DEVICE_REQUEST;
    } 

    // Solenoid door locking is an option with this library
    // but do a prevent/allow in case it's present. 

    if (setAccess->Element.ElementType == ChangerIEPort)  {

        srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
        if (!srb) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;

        if (controlOperation == LOCK_ELEMENT) {

            srb->CdbLength = CDB6GENERIC_LENGTH;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            srb->DataTransferLength = 0;
            srb->TimeOutValue = fdoExtension->TimeOutValue;

            cdb->MEDIA_REMOVAL.Prevent = 1;
            cdb->MEDIA_REMOVAL.Control = 0;

        } else if (controlOperation == UNLOCK_ELEMENT) {

            srb->CdbLength = CDB6GENERIC_LENGTH;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            srb->DataTransferLength = 0;
            srb->TimeOutValue = fdoExtension->TimeOutValue;

            cdb->MEDIA_REMOVAL.Prevent = 0;
            cdb->MEDIA_REMOVAL.Control = 0;

        } else if (controlOperation == EXTEND_IEPORT) {

            srb->CdbLength = CDB12GENERIC_LENGTH;
            srb->TimeOutValue = fdoExtension->TimeOutValue;

            cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

            cdb->MOVE_MEDIUM.TransportElementAddress[0] = 0;
            cdb->MOVE_MEDIUM.TransportElementAddress[1] = 0;

            cdb->MOVE_MEDIUM.SourceElementAddress[0] = 0;
            cdb->MOVE_MEDIUM.SourceElementAddress[1] = 0;

            cdb->MOVE_MEDIUM.DestinationElementAddress[0] = 0;
            cdb->MOVE_MEDIUM.DestinationElementAddress[1] = 0;

            cdb->MOVE_MEDIUM.Flip = 0;

            // Indicate that the IEPORT should be extended.
            cdb->MOVE_MEDIUM.Control = 0x40;

            srb->DataTransferLength = 0;

        } else if (controlOperation == RETRACT_IEPORT) {
            srb->CdbLength = CDB12GENERIC_LENGTH;
            srb->TimeOutValue = fdoExtension->TimeOutValue;

            cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

            cdb->MOVE_MEDIUM.TransportElementAddress[0] = 0;
            cdb->MOVE_MEDIUM.TransportElementAddress[1] = 0;

            cdb->MOVE_MEDIUM.SourceElementAddress[0] = 0;
            cdb->MOVE_MEDIUM.SourceElementAddress[1] = 0;

            cdb->MOVE_MEDIUM.DestinationElementAddress[0] = 0;
            cdb->MOVE_MEDIUM.DestinationElementAddress[1] = 0;

            cdb->MOVE_MEDIUM.Flip = 0;

            // indicate that the IEPORT must be retracted
            cdb->MOVE_MEDIUM.Control = 0x80;

            srb->DataTransferLength = 0;

         } else {
             status = STATUS_INVALID_PARAMETER;
         }
    } else { // Illegal Element Type
        return STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}




NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    NTSTATUS status;
    PVOID    statusBuffer;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    //
    // length will be based on whether vol. tags are returned and element type(s).
    //

    if (elementType == AllElements) {

        //
        // There should be 4 status pages in the returned buffer.
        //
        statusPages = 4;
    } else {
        statusPages = 1;
    }

    if (readElementStatus->VolumeTagInfo) {

        //
        // Each descriptor will have an embedded volume tag buffer.
        //

        length = sizeof(ELEMENT_STATUS_HEADER) + 
                         (statusPages * sizeof(ELEMENT_STATUS_PAGE)) +
                 (QUAL_FULL_SIZE * readElementStatus->ElementList.NumberOfElements);
    } else {

        length = sizeof(ELEMENT_STATUS_HEADER) + 
                       (statusPages * sizeof(ELEMENT_STATUS_PAGE)) +
               (QUAL_PARTIAL_SIZE * readElementStatus->ElementList.NumberOfElements);

    }

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
       ChangerClassFreePool(statusBuffer);
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {
       cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] = 0;
       cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] = 0;
    } else {
       cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
           (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
   
       cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
           (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }


    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if ((NT_SUCCESS(status)) || 
          (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PQUAL_ELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        //
        // If the status was STATUS_DATA_OVERRUN, check
        // if it was really DATA_OVERRUN or was it just
        // DATA_UNDERRUN
        //
        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress =
                    elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.ElementAddress[1];
                elementStatus->Element.ElementAddress |=
                    (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;


                if (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                }

                //
                // Build Flags field.
                //

                elementStatus->Flags = elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.Full;
                elementStatus->Flags |= (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.Exception << 2);
                elementStatus->Flags |= (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.Invert << 22);
                elementStatus->Flags |= (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.SValid << 23);


                elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);

                if (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.IdValid) {
                    elementStatus->TargetId = elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.BusAddress;
                }
                if (elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.LunValid) {
                    elementStatus->Lun = elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.Lun;
                }

                if (tagInfo) {
                    RtlMoveMemory(elementStatus->PrimaryVolumeID, elementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.PrimaryVolumeTag, MAX_VOLUME_ID_SIZE);
                    elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                }

                //
                // Get next descriptor.
                //

                (ULONG_PTR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer and element descriptor array.
                //

                elementStatus += 1;

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}



NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;
        cdb->INIT_ELEMENT_STATUS.NoBarCode = initElementStatus->BarCodeScan ? 0 : 1;


        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {

        PCHANGER_ELEMENT_LIST elementList = &initElementStatus->ElementList;
        PCHANGER_ELEMENT element = &elementList->Element;

        //
        // Use the vendor-unique initialize with range command
        //

        srb->CdbLength = CDB10GENERIC_LENGTH;
        cdb->INITIALIZE_ELEMENT_RANGE.OperationCode = SCSIOP_INIT_ELEMENT_RANGE;
        cdb->INITIALIZE_ELEMENT_RANGE.Range = 1;

        //
        // Addresses of elements need to be mapped from 0-based to device-specific.
        //

        cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
        cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

        cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[0] = (UCHAR)(elementList->NumberOfElements >> 8);
        cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[1] = (UCHAR)(elementList->NumberOfElements & 0xFF);

        //
        // Indicate whether to use bar code scanning.
        //

        cdb->INITIALIZE_ELEMENT_RANGE.NoBarCode = initElementStatus->BarCodeScan ? 0 : 1;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport, maxTransport;
    USHORT destination, maxDest;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    return STATUS_INVALID_DEVICE_REQUEST;
/*

    if ((setPosition->Destination.ElementType == ChangerDoor) || 
        (setPosition->Destination.ElementType == ChangerKeypad) ||
        (setPosition->Destination.ElementType == ChangerTransport)) { 
        return STATUS_ILLEGAL_ELEMENT_ADDRESS;       
    } 

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }


    //
    // This library doesn't support 2-sided media.
    //

    if (setPosition->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    //
    // Doesn't support two-sided media, but as a ref. source base, it should be noted.
    //

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;


    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
*/
}



NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    These library units support the exchange medium command but it has
    limitations since it is not a dual picker mechanism. Therefore, 
    this device will return STATUS_INVALID_DEVICE_REQUEST. 

Arguments:

    DeviceObject
    Irp

Return Value:

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport, maxTransport;
    USHORT source, maxSource;
    USHORT destination, maxDest;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];


    //
    // This library doesn't support 2-sided media.
    //

    if (moveMedium->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    // this device does not support a Rezero Unit Command
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ExaBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = QLS_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);


    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];
        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;
    }


    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}



ULONG
MapExceptionCodes(
    IN PQUAL_ELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asq = ElementDescriptor->QUAL_FULL_ELEMENT_DESCRIPTOR.AddSenseCodeQualifier;
    ULONG exceptionCode;

    //
    // On this library, the additional sense code is always 0x83.
    //

    switch (asq) {
        case 0x0:
            exceptionCode = ERROR_LABEL_QUESTIONABLE;
            break;

        case 0x1:
            exceptionCode = ERROR_LABEL_UNREADABLE;
            break;

        case 0x2:
            exceptionCode = ERROR_SLOT_NOT_PRESENT;
            break;

        case 0x3:
            exceptionCode = ERROR_LABEL_QUESTIONABLE;
            break;


        case 0x4:
            exceptionCode = ERROR_DRIVE_NOT_INSTALLED;
            break;

        case 0x8:
        case 0x9:
        case 0xA:
            exceptionCode = ERROR_LABEL_UNREADABLE;
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    return exceptionCode;

}




BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == QLS_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{

   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
   
   //
   // Initialize the flag in the device extension to FALSE.
   // If the changer returns sense code SCSI_SENSE_HARDWARE_ERROR
   // on SelfTest, we'll set this flag to TRUE in ChangerError routine.
   //
   changerData->HardwareError = FALSE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "Qlstrmc\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set SelfTest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->HardwareError) == TRUE) {
      changerDeviceError->ChangerProblemType = DeviceProblemHardware;
   }

   ChangerClassFreePool(srb);

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\qualstar\qlstrmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    qlstrmc.h

Abstract:

Authors:

Revision History:

--*/
#ifndef _QLSTR_MC_
#define _QLSTR_MC_

//
// Exabyte uses an addition 4 bytes on their device capabilities page...
//

typedef union _QUAL_ELEMENT_DESCRIPTOR {

    struct _QUAL_FULL_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR PrimaryVolumeTag[36];
        UCHAR Reserved8[4];
    } QUAL_FULL_ELEMENT_DESCRIPTOR, *PQUAL_FULL_ELEMENT_DESCRIPTOR;

    struct _QUAL_PARTIAL_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR Reserved8[4];
    } QUAL_PARTIAL_ELEMENT_DESCRIPTOR, *PQUAL_PARTIAL_ELEMENT_DESCRIPTOR;

} QUAL_ELEMENT_DESCRIPTOR, *PQUAL_ELEMENT_DESCRIPTOR;

#define QUAL_PARTIAL_SIZE sizeof(struct _QUAL_PARTIAL_ELEMENT_DESCRIPTOR)
#define QUAL_FULL_SIZE sizeof(struct _QUAL_FULL_ELEMENT_DESCRIPTOR)


typedef struct _CONFIG_MODE_PAGE {
    UCHAR MdSelHeader[4];
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR Length : 5;
    UCHAR Type : 2;
    UCHAR Write : 1;
    UCHAR Reserved2;
    UCHAR VariableName[20];
    UCHAR Reserved3;
    UCHAR VariableValue[16];
    UCHAR Reserved4;
} CONFIG_MODE_PAGE, *PCONFIG_MODE_PAGE;

#define QLS_NO_ELEMENT 0xFFFF


// DriveID
#define TLS_2xxx      1
#define TLS_4xxx      2

// DriveType
#define D_4MM           1
#define D_8MM           2


typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Unique identifier for the supported models. See above.
    //

    ULONG DriveID;

    //
    // Unique identifier for the supported models. See above.
    //

    ULONG DriveType;

    //
    // Flag to indicate if Diagnostic command failed or not
    //
    BOOLEAN HardwareError;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif

} CHANGER_DATA, *PCHANGER_DATA;



NTSTATUS
ExaBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PQUAL_ELEMENT_DESCRIPTOR ElementDescriptor
    );


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\seagate\wmi.c ===
/*++ 

Copyright (c) 1999 Microsoft

Module Name:

    wmi.c

Abstract:

    This module contains WMI routines for DDS changers.

Environment:

    kernel mode only

Revision History:

--*/ 
#include "ntddk.h"
#include "mcd.h"
#include "seaddsmc.h"

NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++ 

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.


Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   PUCHAR  resultBuffer;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   changerData->HardwareError = FALSE;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "SEADDSMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set SelfTest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                            srb,
                                            srb->DataBuffer,
                                            srb->DataTransferLength,
                                            FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->HardwareError) == TRUE) {
        //
        // Diagnostic test failed. Do ReceiveDiagnostic to receive
        // the results of the diagnostic test
        //  
        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

        cdb = (PCDB)srb->Cdb;
        cdb->CDB6GENERIC.OperationCode = SCSIOP_RECEIVE_DIAGNOSTIC;
        cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(SEADDSMC_RECV_DIAG);

        resultBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                                                sizeof(SEADDSMC_RECV_DIAG));
        if (resultBuffer == NULL) {
            //
            // No memory. Set the generic error code (DeviceProblemHardware)
            // and return STATUS_SUCCESS
            //
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            DebugPrint((1, "SEADDSMC:PerformDiagnostics - Not enough memory to ",
                        "receive diagnostic results\n"));

            ChangerClassFreePool(srb);
            return STATUS_SUCCESS;
        }

        srb->DataTransferLength = sizeof(SEADDSMC_RECV_DIAG);
        srb->DataBuffer = resultBuffer;
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->TimeOutValue = 120;
        
        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                                srb,
                                                srb->DataBuffer,
                                                srb->DataTransferLength,
                                                FALSE);
        if (NT_SUCCESS(status)) {
              ProcessDiagnosticResult(changerDeviceError,
                                      resultBuffer);
        }
                               
        ChangerClassFreePool(resultBuffer);
        status = STATUS_SUCCESS;
   } 

   ChangerClassFreePool(srb);
   return status;
}


VOID
ProcessDiagnosticResult(
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError,
    IN PUCHAR resultBuffer
    )
/*+++

Routine Description :

   This routine parses the data returned by the device on
   Receive Diagnostic command, and returns appropriate
   value for the problem type.
   
Arguements :

   changerDeviceError - Output buffer with diagnostic info
   
   resultBuffer - Buffer in which the data returned by the device
                  Receive Diagnostic command is stored.
   
Return Value :

   DeviceProblemNone - If there is no problem with the device
   Appropriate status code indicating the changer problem type.   
--*/
{
   UCHAR fraCode;
   CHANGER_DEVICE_PROBLEM_TYPE changerErrorType;
   PSEADDSMC_RECV_DIAG diagBuffer;

   changerErrorType = DeviceProblemNone;

   diagBuffer = (PSEADDSMC_RECV_DIAG)resultBuffer;
   fraCode = diagBuffer->FRA;

   DebugPrint((1, "seaddsmc\\FRACode : %x\n", fraCode));
   switch (fraCode) {
      case SEADDSMC_NO_ERROR: {
          changerErrorType = DeviceProblemNone;
          break;
      }

      case SEADDSMC_DRIVE_ERROR: {
          changerErrorType = DeviceProblemDriveError;
          break;
      }

      default: {
          changerErrorType = DeviceProblemHardware;
          break;
      }
   } // switch (fraCode) 

   changerDeviceError->ChangerProblemType = changerErrorType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\quantum\qntmmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    qntmmc.c

Abstract:

    This module contains device-specific routines for Quantum's DLT
        Changers: 
                DLT2500, DLT4500, DLT7500
                DLT2700, DLT4700, DLT7700

Author:

    chuckp (Chuck Park)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "qntmmc.h"


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, QntmBuildAddressMapping)
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the exabyte changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}





NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);


    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         dataBuffer,
                                         sizeof(INQUIRYDATA),
                                         FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    //
    // Determine drive type.
    //

    changerData->DriveType = QNTM_DLT;

    ChangerClassFreePool(dataBuffer);

    //
    // Build address mapping.
    //

    status = QntmBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
   PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
   PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
   ULONG deviceStatus;

   if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
    switch (senseBuffer->SenseKey) {
      case SCSI_SENSE_HARDWARE_ERROR: {
         UCHAR qntmmcASC;
         UCHAR qntmmcASCQ;

         qntmmcASC = senseBuffer->AdditionalSenseCode;
         qntmmcASCQ = senseBuffer->AdditionalSenseCodeQualifier;
         deviceStatus = QNTMMC_HW_ERROR;

         switch (qntmmcASC) {
            case QNTMMC_ASC_POSITION_ERROR: {
               deviceStatus = QNTMMC_CHM_ERROR;
               break;
            }

            default: {
               deviceStatus = QNTMMC_HW_ERROR;
               break;
            }
         } // switch (qntmmcASC) 

         changerData->DeviceStatus = deviceStatus;
         break;
      }
    } // switch (senseBuffer->SenseKey)
   }

   return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    exabyte changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    bufferLength;
    PVOID    modeBuffer;
    PCDB     cdb;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + 
                   sizeof(MODE_ELEMENT_ADDRESS_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;
    cdb->MODE_SENSE.Dbd = 1;
    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += (sizeof(MODE_PARAMETER_HEADER));

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[AllElements] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = elementAddressPage->MediumTransportElementAddress[1];
        if (elementAddressPage->FirstDataXFerElementAddress[1] < addressMapping->LowAddress) {
            addressMapping->LowAddress = elementAddressPage->FirstDataXFerElementAddress[1];
        }
    }
    DebugPrint((1,"GetParams: First addresses\n"));
    DebugPrint((1,"Transport: %x\n",
                elementAddressPage->MediumTransportElementAddress[1]));
    DebugPrint((1,"Slot: %x\n",
                elementAddressPage->FirstStorageElementAddress[1]));
    DebugPrint((1,"Ieport: %x\n",
                elementAddressPage->FirstIEPortElementAddress[1]));
    DebugPrint((1,"Drive: %x\n",
                elementAddressPage->FirstDataXFerElementAddress[1]));
    DebugPrint((1,"LowAddress: %x\n",
                addressMapping->LowAddress));

    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 0;

    changerParameters->DriveCleanTimeout = 300;

    changerParameters->FirstSlotNumber = 0;             
    changerParameters->FirstDriveNumber =  0;           
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;           

    changerParameters->MagazineSize = addressMapping->NumberOfElements[ChangerSlot];

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

   
    //
    // Features based on manual, nothing programatic.
    //

    // initialize Features1  
        changerParameters->Features1 = 0;


    changerParameters->Features0 = 
         CHANGER_CARTRIDGE_MAGAZINE              |
         CHANGER_DRIVE_CLEANING_REQUIRED         |
         // TODO - change to CHANGER_CLEANER_ACCESS_NOT_VALID 
         CHANGER_CLEANER_ACCESS_NOT_VALID          |
         CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS;

        // door cannot be programmatically locked on this device

    //
    // build device capabilities mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + 
                   sizeof(MODE_DEVICE_CAPABILITIES_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;
    cdb->MODE_SENSE.Dbd = 1;
    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += (sizeof(MODE_PARAMETER_HEADER));
    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

        changerParameters->PositionCapabilities = 0;


    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}



NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA)); 
    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, 4);

    //
    // Indicate drive type .
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}




NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the Door, Keypad and IEPort.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    // this device does not support changer locking of any kind
    return STATUS_INVALID_DEVICE_REQUEST;

}




NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages, realElements;
    NTSTATUS status;
    PVOID    statusBuffer;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    if (elementType == AllElements) {
        statusPages = 3;                // only transport, slot and drive
    } else {
        statusPages = 1;
    }

    length = sizeof(ELEMENT_STATUS_HEADER) + 
                    (sizeof(ELEMENT_STATUS_PAGE) * statusPages);

    if (readElementStatus->VolumeTagInfo) {
         return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (elementType == AllElements) {
        length +=  ( sizeof(QNTM_TRANSPORT_ELEMENT_DESCRIPTOR) +
                     ( sizeof(QNTM_ELEMENT_DESCRIPTOR) * 
                       ((readElementStatus->ElementList.NumberOfElements)-1))); 
    } else if (elementType == ChangerTransport) {
           length += (sizeof(QNTM_TRANSPORT_ELEMENT_DESCRIPTOR) * 
                              readElementStatus->ElementList.NumberOfElements); 
    } else {
        length += (sizeof(QNTM_ELEMENT_DESCRIPTOR) * 
                           readElementStatus->ElementList.NumberOfElements);
    }


    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = 0;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {
        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] = 0;
        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] = 0;
    } else { 
        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
             (UCHAR)((element->ElementAddress + 
              addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
             (UCHAR)((element->ElementAddress + 
             addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = 
           (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = 
           (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = 
           (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if ((NT_SUCCESS(status)) || (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements =
               readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        //
        // Check if the error was STATUS_DATA_OVERRUN
        //
        if (status == STATUS_DATA_OVERRUN) {
           //
           // Check if there was a DATA_OVERRUN, or was it just 
           // DATA_UNDERRUN reported as DATA_OVERRRUN.
           //
           if (srb->DataTransferLength < length) {
              DebugPrint((1, 
                          "DATA_UNDERRUN status reported as DATA_OVERRUN.\n"));
              status = STATUS_SUCCESS;
           } else {
              //
              // It was really DATA_OVERRUN error. Report accordingly.
              //
              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);
          
              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, a status page, 
          // and one or more element descriptors.
        // Point each element to its respective place in the buffer.
        //

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        do {
            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress =
                                 elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= 
                                (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= 
                                addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;

                // if the element type is a drive, get SCSI Address 
                // and LUN information, also check SValid
                
                if (elementType == ChangerDrive) {
                    if (elementDescriptor->IdValid) {
                        elementStatus->Flags |= 
                                           ELEMENT_STATUS_ID_VALID;
                        elementStatus->TargetId = 
                                     elementDescriptor->BusAddress;
                    }

                    if (elementDescriptor->LunValid) {
                        elementStatus->Flags |= 
                                          ELEMENT_STATUS_LUN_VALID;
                        elementStatus->Lun = 
                                            elementDescriptor->Lun;
                    }
                    
                    if (elementDescriptor->SValid) {
                        ULONG  j;
                        USHORT tmpAddress;

                        tmpAddress = 
                 elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= 
                 (elementDescriptor->SourceStorageElementAddress[0] << 8);
                        for (j = 1; j <= ChangerDrive; j++) {
                          if (addressMapping->FirstElement[j] <= 
                                                       tmpAddress) {
                             if (tmpAddress < 
                                                (addressMapping->NumberOfElements[j] 
                                                + addressMapping->FirstElement[j])){
                        elementStatus->SrcElementAddress.ElementType = j;
                                        break;
                             }
                          }
                        }
                        elementStatus->SrcElementAddress.ElementAddress=
                                 tmpAddress - addressMapping->FirstElement[j];
                        elementStatus->Flags |= ELEMENT_STATUS_SVALID;
                    }
                }

                //
                // Build Flags field.
                //
                elementStatus->Flags |= 
                               elementDescriptor->Full;
                elementStatus->Flags |= 
                              (elementDescriptor->Exception << 2);
                elementStatus->Flags |= 
                              (elementDescriptor->Accessible << 3);
                elementStatus->Flags |= 
                              (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= 
                              (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= 
                              (elementDescriptor->NotThisBus << 15);
                elementStatus->Flags |= 
                              (elementDescriptor->Invert << 22);
                elementStatus->Flags |= 
                              (elementDescriptor->SValid << 23);

                //
                // Map any exceptions reported directly.
                //

                // for this device, access is not reported properly, so set it
                if (elementType == ChangerTransport) {
                       elementStatus->Flags |= 1 << 3;
                }
 
                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {

                    //
                    // The QNTM units don't have the 
                    // capability of reporting exceptions
                    // in this manner 
                    //
                    elementStatus->ExceptionCode =
                                MapExceptionCodes(elementDescriptor);
                }

                //
                // Get next descriptor.
                //
                (ULONG_PTR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //
                elementStatus += 1;
            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //
                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //
                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = 
                                statusPage->ElementDescriptorLength[1];
                descriptorLength |= 
                                (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |= (statusPage->DescriptorByteCount[1] << 8);
                typeCount |= (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = 
                        sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}




NTSTATUS
ChangerGetDisplay(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerSetDisplay(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to initialize all elements

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    if (initElementStatus->ElementList.Element.ElementType 
        != AllElements) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

    srb->TimeOutValue = fdoExtension->TimeOutValue;
    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport, maxTransport;
    USHORT destination, maxDest;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport, maxTransport;
    USHORT source, maxSource;
    USHORT destination, maxDest;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

   // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];


    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = 0;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
QntmBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    ULONG                  bufferLength;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = QNT_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + 
                   sizeof(MODE_ELEMENT_ADDRESS_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;
    cdb->MODE_SENSE.Dbd = 1;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += (sizeof(MODE_PARAMETER_HEADER));

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = elementAddressPage->MediumTransportElementAddress[1];
        if (elementAddressPage->FirstDataXFerElementAddress[1] < addressMapping->LowAddress) {
            addressMapping->LowAddress = elementAddressPage->FirstDataXFerElementAddress[1];
        }

        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->FirstElement[AllElements] = 0;


        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }


    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}



ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{

    ULONG exceptionCode = 0;
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;

    switch (asc) {
        case 0x00:

            //
            // No error.
            //

            exceptionCode = 0;
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
            break;
    }

    DebugPrint((1,
               "qntmmc: MapExceptionCode - ASC %x, ASCQ %x ExceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;




}



BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == QNT_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{

   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize DeviceStatusin the device extension to 
   // QNTMMC_DEVICE_PROBLEM_NONE. If the changer returns sense code 
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set appropriate 
   // DeviceStatus in ChangerError routine.
   //
   changerData->DeviceStatus = QNTMMC_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "QNTMMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set SelfTest bit
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) == QNTMMC_DEVICE_PROBLEM_NONE) {
      switch (changerData->DeviceStatus) {
         case QNTMMC_CHM_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemCHMError;
            break;
         }

         case QNTMMC_HW_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }

         default: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }
      } // switch(changerData->DeviceStatus)
   }

   ChangerClassFreePool(srb);

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\quantum\qntmmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    qntmmc.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _QNTM_MC_
#define _QNTM_MC_

typedef struct _QNTM_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;                      // true for drives only
    UCHAR Reserved6 : 1;                // true for drives only
    UCHAR LunValid : 1;                 // true for drives only
    UCHAR IdValid : 1;                  // true for drives only
    UCHAR Reserved7 : 1;                // true for drives only
    UCHAR NotThisBus : 1;               // true for drives only
    UCHAR BusAddress;                   // true for drives only
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR Reserved10[4];
    UCHAR DensityCode;
    UCHAR Unused;
} QNTM_ELEMENT_DESCRIPTOR, *PQNTM_ELEMENT_DESCRIPTOR;

typedef struct _QNTM_TRANSPORT_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;                      // true for drives only
    UCHAR Reserved6 : 1;                // true for drives only
    UCHAR LunValid : 1;                 // true for drives only
    UCHAR IdValid : 1;                  // true for drives only
    UCHAR Reserved7 : 1;                // true for drives only
    UCHAR NotThisBus : 1;               // true for drives only
    UCHAR BusAddress;                   // true for drives only
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR Reserved10[4];
} QNTM_TRANSPORT_ELEMENT_DESCRIPTOR, *PQNTM_TRANSPORT_ELEMENT_DESCRIPTOR;
#define QNT_NO_ELEMENT 0xFFFF

//
// Diagnostic related defines
//
// ASC
//
#define QNTMMC_ASC_POSITION_ERROR       0x15

//
// DeviceStatus defines
//
#define QNTMMC_DEVICE_PROBLEM_NONE      0x00
#define QNTMMC_HW_ERROR                 0x01
#define QNTMMC_CHM_ERROR                0x02


// DriveType
#define QNTM_DLT  1


typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;



typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Drive type, either optical or dlt.
    //

    ULONG DriveType;

    //
    // Drive Id. Based on inquiry.
    //

    ULONG DriveID;

    //
    // DeviceStatus after diagnostic test has been completed
    //
    ULONG DeviceStatus;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;



NTSTATUS
QntmBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif // _QNTM_MC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\snyaitmc\snyaitmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    hpmc.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _SNYAIT_MC_
#define _SNYAIT_MC_

typedef struct _SONY_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
} SONY_ELEMENT_DESCRIPTOR, *PSONY_ELEMENT_DESCRIPTOR;

typedef struct _SONY_ELEMENT_DESCRIPTOR_PLUS {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR PVolTagInformation[36];
    UCHAR AVolTagInformation[36];
} SONY_ELEMENT_DESCRIPTOR_PLUS, *PSONY_ELEMENT_DESCRIPTOR_PLUS;

#define SONY_NO_ELEMENT          0xFFFF

#define SONY_SERIAL_NUMBER_LENGTH 16

typedef struct _SERIAL_NUMBER {
    UCHAR DeviceType;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR ControllerSerialNumber[SONY_SERIAL_NUMBER_LENGTH];
    UCHAR MechanicalSerialNumber[SONY_SERIAL_NUMBER_LENGTH];
} SERIAL_NUMBER, *PSERIAL_NUMBER;


//
// Diagnostic related defines
//
typedef struct _SNYAITMC_RECV_DIAG {
    UCHAR ErrorSet : 4;
    UCHAR Reserved1 : 2;
    UCHAR TimeReSync : 1;
    UCHAR ResetError : 1;
    UCHAR ErrorCode;
    UCHAR ResultA;
    UCHAR ResultB;
    UCHAR TestNumber;
} SNYAITMC_RECV_DIAG, *PSNYAITMC_RECV_DIAG;

#define SNYAITMC_DEVICE_PROBLEM_NONE    0x00
#define SNYAITMC_HW_ERROR               0x01


typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Drive type, either optical or dlt.
    //

    ULONG DriveType;

    //
    // Drive Id. Based on inquiry.
    //

    ULONG DriveID;

    //
    // INTERLOCKED counter of the number of prevent/allows.
    // As these units lock the IEPort on these operations
    // Move/ExchangeMedium might need to clear a prevent
    // to do the operation.
    //

    LONG LockCount;

    //
    // Device Status after diagnostic command
    //
    ULONG DeviceStatus;

    //
    // Cached unique serial number.
    //

    UCHAR SerialNumber[SONY_SERIAL_NUMBER_LENGTH];

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif    

} CHANGER_DATA, *PCHANGER_DATA;



NTSTATUS
SonyBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

VOID
ProcessDiagnosticResult(   
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError,
    IN PUCHAR resultBuffer
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\seagate\seaddsmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    seaddsmc.c

Abstract:

    This module contains device-specific routines for many DDS-2 & DDS-3 medium changers:
    - Seagate / Archive 4586

Author:

    davet (Dave Therrien - HighGround Systems)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "seaddsmc.h"


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, DdsBuildAddressMapping)
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}

typedef struct _SERIALNUMBER {
    UCHAR DeviceType;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR SerialNumber[SEAGATE_SERIAL_NUMBER_LENGTH];
} SERIALNUMBER, *PSERIALNUMBER;




NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PSERIALNUMBER  serialBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //


    status = DdsBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         dataBuffer,
                                         sizeof(INQUIRYDATA),
                                         FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

        //
        // Determine drive id.
        //


        if (RtlCompareMemory(changerData->InquiryData.VendorId,"ARCHIVE",7) == 7) {
            if (RtlCompareMemory(changerData->InquiryData.ProductId,"Python",6)== 6) {
                changerData->DriveID = SEAGATE;
            }
            if (RtlCompareMemory(changerData->InquiryData.ProductId,"IBM4586",7)== 7) {
                changerData->DriveID = SEAGATE;
            }
            if (RtlCompareMemory(changerData->InquiryData.ProductId,"4586XX",6)== 6) {
                changerData->DriveID = SEAGATE;
            }
            if (RtlCompareMemory(changerData->InquiryData.ProductId,"IBM-STL496",10)== 10) {
                changerData->DriveID = SEAGATE;
            }

        } 
   
        if (RtlCompareMemory(changerData->InquiryData.VendorId,"SEAGATE",7) == 7) {
            if (RtlCompareMemory(changerData->InquiryData.ProductId,"DAT",3)== 3) {
                changerData->DriveID = SEAGATE;
            }
        }
    }

    //
    // Get serial number page for Seagate/Archive
    //
    //


    if (changerData->DriveID == SEAGATE) {
        serialBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                   SEAGATE_SERIAL_NUMBER_LENGTH+4);
        if (!serialBuffer) {
            DebugPrint((1, "BuildAddressMapping failed. %x\n", status));
            ChangerClassFreePool(dataBuffer);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(serialBuffer, SEAGATE_SERIAL_NUMBER_LENGTH+4);

        RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

        srb.TimeOutValue = 10;
        srb.CdbLength = 6;
        cdb = (PCDB)srb.Cdb;
        cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

        //
        // Set EVPD and Unit Serial number page
        //
        cdb->CDB6INQUIRY.Reserved1 = 1;
        cdb->CDB6INQUIRY.PageCode = 0x80;

        //
        // Set allocation length to inquiry data buffer size.
        //

        cdb->CDB6INQUIRY.AllocationLength = 
                                 SEAGATE_SERIAL_NUMBER_LENGTH+4;

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     serialBuffer,
                                     SEAGATE_SERIAL_NUMBER_LENGTH+4,
                                     FALSE);

        if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
            SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

            ULONG i;

            RtlMoveMemory(changerData->SerialNumber, 
                                 serialBuffer->SerialNumber, 
                                 SEAGATE_SERIAL_NUMBER_LENGTH);

            DebugPrint((1,"DeviceType - %x\n", serialBuffer->DeviceType));
            DebugPrint((1,"PageCode - %x\n", serialBuffer->PageCode));
            DebugPrint((1,"Length - %x\n", serialBuffer->PageLength));

            DebugPrint((1,"Serial number "));

            for (i = 0; i < SEAGATE_SERIAL_NUMBER_LENGTH; i++) {
                DebugPrint((1,"%x", serialBuffer->SerialNumber[i]));
            }

            DebugPrint((1,"\n"));
        }

        ChangerClassFreePool(serialBuffer);
    }
    ChangerClassFreePool(dataBuffer);

    return STATUS_SUCCESS;
}

VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:


--*/
{

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_NOT_READY: {
            if (senseBuffer->AdditionalSenseCode == 0x04) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x3:

                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_DOOR_OPEN;
                        break;
                }
            }

            break;
        }


        case SCSI_SENSE_HARDWARE_ERROR: {
            changerData->HardwareError = TRUE;
            break;
        }

        default:
            break;
        }
    }

    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    PVOID    modeBuffer;
    PCDB     cdb;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //
 
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                                  sizeof(MODE_PARAMETER_HEADER) + 
                                  sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
       ChangerClassFreePool(srb);
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + 
                                  sizeof(MODE_ELEMENT_ADDRESS_PAGE));

    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + 
                                  sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    cdb->MODE_SENSE.Dbd = 1;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    // TODO - how to handle operators changing magazines from 4 slot to 12 slot 
    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);
    changerParameters->NumberOfDoors = 1;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  0;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;


    changerParameters->NumberCleanerSlots = 0;
    changerParameters->FirstCleanerSlotAddress = 0;
    changerParameters->MagazineSize = changerParameters->NumberStorageElements;

    if (!addressMapping->Initialized) {

        ULONG i;

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];

        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = DDS_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    addressMapping->NumberOfElements[ChangerTransport] = changerParameters->NumberTransportElements;
    addressMapping->NumberOfElements[ChangerDrive] = changerParameters->NumberDataTransferElements;
    addressMapping->NumberOfElements[ChangerIEPort] = changerParameters->NumberIEElements;
    addressMapping->NumberOfElements[ChangerSlot] = changerParameters->NumberStorageElements;
    addressMapping->NumberOfElements[ChangerDoor] = changerParameters->NumberOfDoors;
    addressMapping->NumberOfElements[ChangerKeypad] = 0;


    DebugPrint((1,"GetParams: First addresses\n"));
    DebugPrint((1,"Transport: %x\n",
                elementAddressPage->MediumTransportElementAddress[1]));
    DebugPrint((1,"Slot: %x\n",
                elementAddressPage->FirstStorageElementAddress[1]));
    DebugPrint((1,"Ieport: %x\n",
                elementAddressPage->FirstIEPortElementAddress[1]));
    DebugPrint((1,"Drive: %x\n",
                elementAddressPage->FirstDataXFerElementAddress[1]));
    DebugPrint((1,"LowAddress: %x\n",
                addressMapping->LowAddress));

    changerParameters->DriveCleanTimeout = 600;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);


        
    // initialize Features1  
        changerParameters->Features1 = CHANGER_CLEANER_AUTODISMOUNT;

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 = CHANGER_LOCK_UNLOCK                   |
                                   CHANGER_CARTRIDGE_MAGAZINE            |
                                   CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS    |                                  
                                   CHANGER_DRIVE_CLEANING_REQUIRED;

        // Only the DOOR can be locked and unlocked
    changerParameters->LockUnlockCapabilities = LOCK_UNLOCK_DOOR;


    // EXCHANGE MEDIUM IS SUPPORTED IN THIS DEVICE, BUT ONLY CONDITIONALLY. 
    // CAN ONLY DO AN EXCHANGE BETWEEN 2 SLOTS AND THE DRIVE. 
    //
    // build transport geometry mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                        sizeof(MODE_PARAMETER_HEADER) + 
                        sizeof(MODE_DEVICE_CAPABILITIES_PAGE));

    if (!modeBuffer) {
       ChangerClassFreePool(srb);
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + 
                                  sizeof(MODE_DEVICE_CAPABILITIES_PAGE));

    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + 
                                  sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    cdb->MODE_SENSE.Dbd = 1;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);


    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->PositionCapabilities = 0;

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}



NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA)); 
    RtlMoveMemory(productData->VendorId, 
         changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, 
         changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, 
         changerData->InquiryData.ProductRevisionLevel, 4);
    RtlMoveMemory(productData->SerialNumber, 
         changerData->InquiryData.VendorSpecific, SEAGATE_SERIAL_NUMBER_LENGTH);

    //
    // Indicate that this is a tape changer and that media isn't two-sided.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}




NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the loader mechanism.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;


    if (setAccess->Element.ElementType != ChangerDoor) {
                return STATUS_INVALID_DEVICE_REQUEST;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // DOOR is the only element that can really be locked
    // and unlocked, but since there is only one locking 
    // SCSI command for this device, funnel all requests to lock
    // any element into this Prevent/Allow. 

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

    if (controlOperation == LOCK_ELEMENT) {
        cdb->MEDIA_REMOVAL.Prevent = 1;
    } else if (controlOperation == UNLOCK_ELEMENT) {
        cdb->MEDIA_REMOVAL.Prevent = 0;
    } else {
        ChangerClassFreePool(srb);
        return STATUS_SUCCESS;
    }
 
    if (NT_SUCCESS(status)) {
        //
        // Issue the srb.
        //
        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PIO_STACK_LOCATION           irpStack = IoGetCurrentIrpStackLocation(Irp);
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    ELEMENT_TYPE        originalElementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    UCHAR    bitmask, bit;
    ULONG    length;
    ULONG    statusPages;
    ULONG    realElements;
    NTSTATUS status;
    PVOID    statusBuffer;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    originalElementType = elementType;

    DebugPrint((2,
               "GetElementStatus: ElementType: %x\n",
                elementType));

    if (elementType == AllElements) {

        ULONG i;

        statusPages = 0;
        realElements = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;
            realElements += addressMapping->NumberOfElements[i];
        }
    } else {

        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType)) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        statusPages = 1;
        realElements = readElementStatus->ElementList.NumberOfElements;
    }

    DebugPrint((2,
               "StatusPages %x, readElements %x\n",
               statusPages,
               realElements));

    if (readElementStatus->VolumeTagInfo) {

        //
        // These units have no Volume tag capability.
        //

        return STATUS_INVALID_PARAMETER;
    } else {

        //
        // length will be based on number of element type(s).
        //

        length = sizeof(ELEMENT_STATUS_HEADER) + 
                 (sizeof(ELEMENT_STATUS_PAGE) * statusPages) +
                 (sizeof(SEAGATE_ELEMENT_DESCRIPTOR) *
                    readElementStatus->ElementList.NumberOfElements);
    }

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // The changers may not have the low address as 0.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(realElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(realElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (NT_SUCCESS(status) ||
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        RtlZeroMemory(elementStatus, irpStack->Parameters.DeviceIoControl.OutputBufferLength);

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;

                //
                // Source address
                //

                if (elementDescriptor->SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                    elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                }

                //
                // Build Flags field.
                //

                elementStatus->Flags = elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);

                //
                // These units don't have the capability of reporting exceptions
                // in this manner.
                //

                elementStatus->ExceptionCode = 0;

                if (elementType == ChangerDrive) {

                    if (elementDescriptor->IdValid) {
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }

                    if (elementDescriptor->LunValid) {
                        elementStatus->Lun = elementDescriptor->Lun;
                    }
                }
       


                //
                // Get next descriptor.
                //

                (ULONG_PTR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                elementStatus += 1;

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }                
            }

        } while (remainingElements);


        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}




NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    // Seagate/Archive will eject the medium in the drive if this command
    // is issued. The unit performs inventory on its own if the mag is
    // removed and returned to the changer. 

    return STATUS_SUCCESS;

}



NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. None of the support devices currently have this functionality.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;

}



NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

 
Arguments:

    DeviceObject
    Irp

Return Value:



--*/
{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport, maxTransport;
    USHORT source, maxSource;
    USHORT destination, maxDest;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);


    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

       DebugPrint((1, "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }


    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];


    //
    // DDS changers don't support 2-sided media.
    //

    if (moveMedium->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }



    // Seagate unlocks the changer when a drive driver unlocks the drive. 
    // close the exposure to unauthorized access to this changer by 
    // relocking the changer on a drive unload. 

    if ((changerData->DriveID == SEAGATE) && 
        (moveMedium->Destination.ElementType == ChangerSlot) && 
        (moveMedium->Source.ElementType == ChangerDrive))  {

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = fdoExtension->TimeOutValue;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        cdb->MEDIA_REMOVAL.Prevent = 1;
        ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
        // return status from Move Medium, ignore this lock operation  status
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
DdsBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID                  modeBuffer;
    ULONG                  i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = DDS_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                                + sizeof(MODE_PARAMETER_HEADER)
                                + sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
       ChangerClassFreePool(srb);
       return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + 
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE));

    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + 
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    cdb->MODE_SENSE.Dbd = 1;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];
        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->LowAddress = DDS_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }


    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}



BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == DDS_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\seagate\seaddsmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    sddsmc.h

Abstract:

Authors:

Revision History:

--*/
#ifndef _SDDS_MC_
#define _SDDS_MC_


typedef struct _SEAGATE_ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
} SEAGATE_ELEMENT_DESCRIPTOR, *PSEAGATE_ELEMENT_DESCRIPTOR;

#define DDS_NO_ELEMENT 0xFFFF


//
// Drive ID's
//

#define SEAGATE   0x00000001

#define SEAGATE_SERIAL_NUMBER_LENGTH 7

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the Lowest element address of the unit.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

    UCHAR Reserved[3];

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Indicates which device is currently supported.
    // See above.
    //

    ULONG DriveID;

    //
    // Flag to indicate if the diagnostic test failed or not.
    //
    BOOLEAN HardwareError;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached unique serial number.
    //

    UCHAR SerialNumber[SEAGATE_SERIAL_NUMBER_LENGTH];

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif

} CHANGER_DATA, *PCHANGER_DATA;

typedef struct _SEADDSMC_RECV_DIAG {
    UCHAR PageCode;
    UCHAR Reserved1;
    UCHAR Reserved2;
    UCHAR AdditionalLength;
    UCHAR LastSuccessfulTest;
    UCHAR ErrorCode;
    UCHAR FRA;
    UCHAR TapeLoadCount;
} SEADDSMC_RECV_DIAG, *PSEADDSMC_RECV_DIAG;

//
// defines for Diagnostics
//
#define SEADDSMC_NO_ERROR       0x00
#define SEADDSMC_DRIVE_ERROR    0x01

NTSTATUS
DdsBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

//
// Internal functions for wmi
//
VOID
ProcessDiagnosticResult(
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError,
    IN PUCHAR resultBuffer
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\snyaitmc\snyaitmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    snyaitmc.c

Abstract:

    This module contains device-specific routines for Sony AIT medium changers:
    SEAGATE AIT-LDR -- Seagate Sidewinder 200 AIT Loader (manufactured by Sony)
        STA4200000W  (Internal full height 5 1/4")
        STA6200000W  (External)

Author:

    Based on sonymc.c by chuckp (Chuck Park)
    Adapted for SEAGATE AIT-LDR by Bruce Janiszewski

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "snyaitmc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, SonyBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the Sony changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PSERIAL_NUMBER  serialBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);


    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    ExFreePool(dataBuffer);

    //
    // Build address mapping.
    //

    status = SonyBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    serialBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(SERIAL_NUMBER));
    if (!serialBuffer) {

        ExFreePool(dataBuffer);

        DebugPrint((1,
                    "Sonyaitmc.ChangerInitialize: Error allocating serial number buffer. %x\n",
                    status));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Get serial number.
    //

    RtlZeroMemory(serialBuffer, sizeof(SERIAL_NUMBER));

    //
    // Get serial number page.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set EVPD
    //

    cdb->CDB6INQUIRY.Reserved1 = 1;

    //
    // Unit serial number page.
    //

    cdb->CDB6INQUIRY.PageCode = 0x80;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(SERIAL_NUMBER);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         serialBuffer,
                                         sizeof(SERIAL_NUMBER),
                                         FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        RtlMoveMemory(changerData->SerialNumber, serialBuffer->ControllerSerialNumber, SONY_SERIAL_NUMBER_LENGTH);

    }

    ExFreePool(serialBuffer);

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_UNIT_ATTENTION:

            //
            // Zero the lock count, as any prevents are now gone.
            //

            InterlockedExchange(&changerData->LockCount, 0);
            break;

        case SCSI_SENSE_HARDWARE_ERROR: {
            if ((senseBuffer->AdditionalSenseCode == 0x44) &&
                (senseBuffer->AdditionalSenseCodeQualifier == 0)) {
                changerData->DeviceStatus = SNYAITMC_HW_ERROR;
            }
           break;
        }

        case SCSI_SENSE_NOT_READY: {
            if ((senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_NO_MEDIA_IN_DEVICE) &&
                (senseBuffer->AdditionalSenseCodeQualifier == 0x00)) {

                //
                // Indicates there's no magazine in the changer
                //
                *Status = STATUS_MAGAZINE_NOT_PRESENT;
            }

            break;
        }

        default:
            break;
        }

        DebugPrint((1,
                   "ChangerError: Sense Key - %x\n",
                   senseBuffer->SenseKey & 0x0f));
        DebugPrint((1,
                   "              AdditionalSenseCode - %x\n",
                   senseBuffer->AdditionalSenseCode));
        DebugPrint((1,
                   "              AdditionalSenseCodeQualifier - %x\n",
                   senseBuffer->AdditionalSenseCodeQualifier));
    }

    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    Sony changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    bufferLength;
    PVOID    modeBuffer;
    PCDB     cdb;
    ULONG    i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ExFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ExFreePool(srb);
        ExFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = SONY_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;


    changerParameters->MagazineSize = 4;

    //
    // Free buffer.
    //

    ExFreePool(modeBuffer);

    changerParameters->Features0 = 0;

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->DriveCleanTimeout = 0;

    changerParameters->Features0 |= CHANGER_LOCK_UNLOCK                     |
                                    CHANGER_CARTRIDGE_MAGAZINE              |
                                    CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS;

    changerParameters->LockUnlockCapabilities = (LOCK_UNLOCK_DOOR);

    //
    // build device capability mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ExFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ExFreePool(srb);
        ExFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

    ExFreePool(srb);
    ExFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ExFreePool(srb);
    // Return success if magazine not present.
    if (status == STATUS_NO_MEDIA_IN_DEVICE)
        return STATUS_SUCCESS;
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);
    RtlMoveMemory(productData->SerialNumber, changerData->SerialNumber, SONY_SERIAL_NUMBER_LENGTH);

    //
    // Indicate drive type and whether media is two-sided.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the IEPort.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    LONG                lockValue = 0;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;


    if (ElementOutOfRange(addressMapping, (USHORT)setAccess->Element.ElementAddress, setAccess->Element.ElementType)) {
        DebugPrint((1,
                   "ChangerSetAccess: Element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;

    if (controlOperation == LOCK_ELEMENT) {

        //
        // Set the state to locked.
        //

        InterlockedIncrement(&changerData->LockCount);

    } else if (controlOperation == UNLOCK_ELEMENT) {

        //
        // Clear the state.
        //

        InterlockedExchange(&changerData->LockCount, 0);

    } else {

        //
        // Get the current state.
        //

        lockValue = (LONG)InterlockedCompareExchange((PVOID)&changerData->LockCount,
                                                     0,
                                                     0);

        DebugPrint((1,
                   "SetAccess: Current lock count - %x\n",
                   lockValue));
    }

    if (setAccess->Element.ElementType == ChangerDoor) {

        if (controlOperation == LOCK_ELEMENT) {

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // Issue prevent media removal command to lock the door.
            //

            cdb->MEDIA_REMOVAL.Prevent = 1;

        } else if (controlOperation == UNLOCK_ELEMENT) {

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // Issue allow media removal.
            //

            cdb->MEDIA_REMOVAL.Prevent = 0;
        } else {
            status = STATUS_INVALID_PARAMETER;
        }

    } else if (setAccess->Element.ElementType == ChangerIEPort) {

        if (controlOperation == LOCK_ELEMENT) {

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // Issue prevent media removal command to lock the ie port.
            //

            cdb->MEDIA_REMOVAL.Prevent = 1;

        } else if (controlOperation == UNLOCK_ELEMENT) {

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // Issue allow media removal.
            //

            cdb->MEDIA_REMOVAL.Prevent = 0;

        } else {
            status = STATUS_INVALID_PARAMETER;
        }
    } else {

        //
        // No keypad selectivity programatically.
        //

        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // Issue the srb.
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    }

    ExFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    ULONG    totalElements = 0;
    NTSTATUS status;
    PVOID    statusBuffer;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    if (elementType == AllElements) {

        ULONG i;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;
            totalElements += addressMapping->NumberOfElements[i];
        }

        if (totalElements != readElementStatus->ElementList.NumberOfElements) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) AllElements\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements));

            return STATUS_INVALID_PARAMETER;
        }

        //
        // Account for length of the descriptors expected for the drives.
        //


        if (readElementStatus->VolumeTagInfo) {

            return STATUS_INVALID_PARAMETER;

        } else {

            length = sizeof(SONY_ELEMENT_DESCRIPTOR) * totalElements;

            //
            // Add in header and status pages.
            //

            length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);

        }

    } else {

        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType)) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        totalElements = readElementStatus->ElementList.NumberOfElements;
        if (totalElements > addressMapping->NumberOfElements[elementType]) {

            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) for type (%x)\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements,
                       elementType));

            return STATUS_INVALID_PARAMETER;
        }

        length = (sizeof(SONY_ELEMENT_DESCRIPTOR) * totalElements);

        //
        // Add in length of header and status page.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);

    }

    DebugPrint((3,
               "ChangerGetElementStatus: Allocation Length %x, for %x elements of type %x\n",
               length,
               totalElements,
               elementType));

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ExFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // These devices may not have the low address as 0.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(totalElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(totalElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (NT_SUCCESS(status)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        LONG remainingElements;
        LONG typeCount;
        LONG i;
        ULONG descriptorLength;

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        if (remainingElements < 0 ) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Returned elements less than zero - %x\n",
                       remainingElements));

            ExFreePool(srb);
            ExFreePool(statusBuffer);

            return STATUS_IO_DEVICE_ERROR;
        }

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        if (typeCount < 0) {
            DebugPrint((1,
                       "ChangerGetElementStatus (1): Count of type %x less than zero - %x\n",
                       elementType,
                       typeCount));

            ExFreePool(srb);
            ExFreePool(statusBuffer);

            return STATUS_IO_DEVICE_ERROR;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;

                //
                // Source address
                //

                if (elementDescriptor->SValid) {
                    ULONG  j;
                    USHORT tmpAddress;


                    //
                    // Source address is valid. Determine the device specific address.
                    //

                    tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                    //
                    // Now convert to 0-based values.
                    //

                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];
                    elementStatus->Flags |= ELEMENT_STATUS_SVALID;
                }

#if NO_FIX_BUSADDRESS
                if (elementDescriptor->IdValid) {
                    elementStatus->Flags |= ELEMENT_STATUS_ID_VALID;
                    elementStatus->TargetId = elementDescriptor->BusAddress;
                }
#else
                if (statusPage->ElementType == ChangerDrive) {
                    // Seagate U1j6 firmware returns
                    //   IdValid=1 and BussAddress=0
                    elementStatus->Flags |= ELEMENT_STATUS_ID_VALID;
                    elementStatus->TargetId = srb->TargetId;
                }
#endif

                if (elementDescriptor->LunValid) {
                    elementStatus->Flags |= ELEMENT_STATUS_LUN_VALID;
                    elementStatus->Lun = elementDescriptor->Lun;
                }

                //
                // Build Flags field.
                //

                elementStatus->Flags |= elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);

                //
                // Map any exceptions reported directly.
                //

                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {

                    //
                    // Map the exception.
                    //

                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                }

                //
                // Get next descriptor.
                //

                (ULONG_PTR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                elementStatus += 1;

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }

                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }

                DebugPrint((1,
                           "ChangerGetElementStatus(2): Count of type %x less than zero - %x\n",
                           elementType,
                           typeCount));
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * totalElements;

    }

    ExFreePool(srb);
    ExFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ExFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.
    SCSIOP_POSITION_TO_ELEMENT is not supported by:
       SEAGATE Sidewinder 200 AIT Loader.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.
    SCSIOP_EXCHANGE_MEDIUM is not supported by:
       SEAGATE Sidewinder 200 AIT Loader.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport;
    USHORT source;
    USHORT destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    LONG                lockValue = 0;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    if ((moveMedium->Destination.ElementType == ChangerIEPort) ||
        (moveMedium->Source.ElementType == ChangerIEPort)) {

        //
        // Determine value of LockCount.
        //

        lockValue = (LONG)InterlockedCompareExchange((PVOID)&changerData->LockCount,
                                                     0,
                                                     0);

        DebugPrint((1,
                   "MoveMedium: LockCount is %x\n",
                   lockValue));

        if (lockValue) {

            //
            // Send an allow to clear the prevent for IEPORT extend/retract.
            //

            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 0;

            //
            // Ignore errors at this point. If this fails and the move doesn't happen, the LM will
            // clean things up.
            //

            status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
            DebugPrint((1,
                       "MoveMedium: Allow sent. Status %x\n",
                       status));

            status = STATUS_SUCCESS;
        }
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
#if FIX_CDB12
    srb->CdbLength = CDB10GENERIC_LENGTH;
#endif
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    } else {
        DebugPrint((1,
                   "MoveMedium: Status of Move %x\n",
                   status));
    }


    if ((moveMedium->Destination.ElementType == ChangerIEPort) ||
        (moveMedium->Source.ElementType == ChangerIEPort)) {

        if (lockValue) {

            NTSTATUS preventStatus;

            //
            // Send the prevent to re-lock down the unit.
            //

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 1;

            //
            // Ignore any errors at this point. The LM will fixup any problems with
            // prevent/allow
            //

            preventStatus = ChangerClassSendSrbSynchronous(DeviceObject,
                                    srb,
                                    NULL,
                                    0,
                                    FALSE);
            DebugPrint((1,
                       "MoveMedium: Prevent sent. Status %x\n",
                       preventStatus));
        }
    }

    ExFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    SCSIOP_REZERO_UNIT is not supported by:
       SEAGATE Sidewinder 200 AIT Loader.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Volume Tags are not supported by:
       SEAGATE Sidewinder 200 AIT Loader.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
SonyBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    ULONG                  bufferLength;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);


    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = SONY_NO_ELEMENT;
    }

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];

        //
        // Determine lowest address of all elements.
        //


        addressMapping->LowAddress = SONY_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }

    //
    // Free buffer.
    //

    ExFreePool(modeBuffer);
    ExFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{

    ULONG exceptionCode = 0;
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;


    switch (asc) {
        case 0x0:
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    DebugPrint((1,
               "Sonyaitmc.MapExceptionCode: ASC %x, ASCQ %x, exceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;

}


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == SONY_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{

   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize DeviceStatusin the device extension to 
   // SNYAITMC_DEVICE_PROBLEM_NONE. If the changer returns sense code 
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set appropriate 
   // DeviceStatus in ChangerError routine.
   //
   changerData->DeviceStatus = SNYAITMC_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "SNYAITMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set SelfTest bit
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) == SNYAITMC_HW_ERROR) {
       //
       // Diagnostic test failed. Do ReceiveDiagnostic to receive
       // the results of the diagnostic test
       //  
       RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

       cdb = (PCDB)srb->Cdb;
       cdb->CDB6GENERIC.OperationCode = SCSIOP_RECEIVE_DIAGNOSTIC;       
       cdb->CDB6GENERIC.CommandUniqueBytes[2] = sizeof(SNYAITMC_RECV_DIAG);

       resultBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                                               sizeof(SNYAITMC_RECV_DIAG));
       if (resultBuffer == NULL) {
           //
           // No memory. Just set the generic error code (DeviceProblemHardware)
           // and return STATUS_SUCCESS.
           //
           changerDeviceError->ChangerProblemType = DeviceProblemHardware;
           DebugPrint((1, "SEADDSMC:PerformDiagnostics - Not enough memory to ",
                       "receive diagnostic results\n"));

           ChangerClassFreePool(srb);
           return STATUS_SUCCESS;
       }

       srb->DataTransferLength = sizeof(SNYAITMC_RECV_DIAG);;
       srb->DataBuffer = resultBuffer;
       srb->CdbLength = CDB6GENERIC_LENGTH;
       srb->TimeOutValue = 120;

       status = ChangerClassSendSrbSynchronous(DeviceObject,
                                    srb,
                                    srb->DataBuffer,
                                    srb->DataTransferLength,
                                    FALSE);
       if (NT_SUCCESS(status)) {
           ProcessDiagnosticResult(changerDeviceError,
                                   resultBuffer);
       }

       ChangerClassFreePool(resultBuffer);
       status = STATUS_SUCCESS;
   }

   ChangerClassFreePool(srb);

   return status;
}


VOID
ProcessDiagnosticResult(
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError,
    IN PUCHAR resultBuffer
    )
/*+++

Routine Description :

   This routine parses the data returned by the device on
   Receive Diagnostic command, and returns appropriate
   value for the problem type.
   
Arguements :

   changerDeviceError - Output buffer with diagnostic info
   
   resultBuffer - Buffer in which the data returned by the device
                  Receive Diagnostic command is stored.
   
Return Value :

   DeviceProblemNone - If there is no problem with the device
   Appropriate status code indicating the changer problem type.   
--*/
{
   PSNYAITMC_RECV_DIAG diagBuffer;
   UCHAR errorSet;
   UCHAR errorCode;

   diagBuffer = (PSNYAITMC_RECV_DIAG)resultBuffer;
   errorSet = diagBuffer->ErrorSet;
   errorCode = diagBuffer->ErrorCode;
   DebugPrint((1, "snyaitmc\\ProcessDiagResult : ErrorSet %x, ErrorCode %x\n",
               errorSet, errorCode));

   //
   // ISSUE: 02/24/2000 - nramas
   // All errorCodes given in the manual indicate somekind of
   // hardware failure. For now, just return  DeviceProblemHardware.
   //
   changerDeviceError->ChangerProblemType = DeviceProblemHardware;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\spectra\spctramc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    spctra.h

Abstract:

Authors:

    davet (Dave Therrien)

Revision History:

--*/
#ifndef _SPCTRA_MC_
#define _SPCTRA_MC_


typedef union _SPC_ED {

    struct _SPC_FED {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR PrimaryVolumeTag[36];
        UCHAR Reserved8[4];
    } SPC_FED, *PSPC_FED;

    struct _SPC_PED {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
        UCHAR Reserved8[4];
    } SPC_PED, *PSPC_PED;

} SPC_ED, *PSPC_ED;

#define SPC_PARTIAL_SIZE sizeof(struct _SPC_PED)
#define SPC_FULL_SIZE sizeof(struct _SPC_FED)

#define SPC_DISPLAY_LINES        4
#define SPC_DISPLAY_LINE_LENGTH  20

// LCD Mode Page - Page 0x22

typedef struct _LCD_MODE_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR WriteLine : 4;
    UCHAR Reserved2 : 2;
    UCHAR FrontPanelLock : 1;
    UCHAR DoorUnlock : 1;
    UCHAR Reserved4;
    UCHAR DisplayLine[SPC_DISPLAY_LINES][SPC_DISPLAY_LINE_LENGTH];
} LCD_MODE_PAGE, *PLCD_MODE_PAGE;


// Vendor Unique Parameter List Mode Page - 00 

typedef struct _VUPL_MODE_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR EBarCo : 1;
    UCHAR ChkSum : 1;
    UCHAR Auto : 1;
    UCHAR QueuedUnload;
    UCHAR LockTouchScreen;
    UCHAR Reserved[5];
} VUPL_MODE_PAGE, *PVUPL_MODE_PAGE;


#define SPC_NO_ELEMENT 0xFFFF


#define S_4mm_4000    1
#define S_8mm_EXB     2
#define S_8mm_SONY    3
#define S_4mm_5000    4
#define S_8mm_AIT     5

#define VPD_SERIAL_NUMBER_LENGTH 10

//
// DeviceStatus codes for diagnostic tests
//
#define SPECTRA_DEVICE_PROBLEM_NONE     0x00
#define SPECTRA_HW_ERROR                0x01

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Unique identifier for the supported models. See above.
    //

    ULONG DriveID;

    //
    // Device Status after diagnostic test is completed
    //
    ULONG DeviceStatus;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached unique serial number.
    //

    UCHAR SerialNumber[VPD_SERIAL_NUMBER_LENGTH];

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;



NTSTATUS
ExaBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PSPC_ED ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\sonymc\sonymc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    sonymc.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _SONYMC_H_
#define _SONYMC_H_

typedef struct _SONY_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
} SONY_ELEMENT_DESCRIPTOR, *PSONY_ELEMENT_DESCRIPTOR;

typedef struct _SONY_ELEMENT_DESCRIPTOR_PLUS {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR PVolTagInformation[36];
    UCHAR AVolTagInformation[36];
} SONY_ELEMENT_DESCRIPTOR_PLUS, *PSONY_ELEMENT_DESCRIPTOR_PLUS;

#define SONY_NO_ELEMENT          0xFFFF

#define SONY_SERIAL_NUMBER_LENGTH 16

typedef struct _SERIAL_NUMBER {
    UCHAR DeviceType;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR ControllerSerialNumber[SONY_SERIAL_NUMBER_LENGTH];
    UCHAR MechanicalSerialNumber[SONY_SERIAL_NUMBER_LENGTH];
} SERIAL_NUMBER, *PSERIAL_NUMBER;

#define SCSIOP_ROTATE_MAILSLOT 0xC0
#define SONY_MAILSLOT_CLOSE 0x00
#define SONY_MAILSLOT_OPEN 0x01

#define SONY_MO 0x01
#define SONY_CD 0x02

#define CDL1100 0x01
#define CDL5000 0x02

//
// Diagnostic related defines
//
#define SONYMC_DEVICE_PROBLEM_NONE      0x00
#define SONYMC_HW_ERROR                 0x01

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Drive type, either optical or dlt.
    //

    ULONG DriveType;

    //
    // Drive Id. Based on inquiry.
    //

    ULONG DriveID;

    //
    // INTERLOCKED counter of the number of prevent/allows.
    // As the Sony units lock the IEPort on these operations
    // MoveMedium/SetAccess might need to clear a prevent
    // to do the operation.
    //

    LONG LockCount;

    //
    // Device Status after diagnostic test is completed.
    //
    ULONG DeviceStatus;

    //
    // Cached unique serial number.
    //

    UCHAR SerialNumber[SONY_SERIAL_NUMBER_LENGTH];

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;


//
// Internal routines
//
NTSTATUS
SonyBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );


#endif // _SONYMC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\sonymc\sonymc.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sonymc.c

Abstract:

    This module contains device-specific routines for Sony CD changers

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "sonymc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, SonyBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the Sony changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PSERIAL_NUMBER  serialBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);


    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    //
    // Determine drive type.
    //

    if (RtlCompareMemory(dataBuffer->ProductId,"CDL1100",7) == 7) {
        changerData->DriveType = SONY_CD;
        changerData->DriveID = CDL1100;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"CDL5000",7) == 7) {
        changerData->DriveID = CDL5000;
        changerData->DriveType = SONY_CD;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"CDL2200",7) == 7) {
        changerData->DriveID = CDL5000;
        changerData->DriveType = SONY_CD;

    } else if (RtlCompareMemory(dataBuffer->ProductId,"CDL2100",7) == 7) {
        changerData->DriveID = CDL5000;
        changerData->DriveType = SONY_CD;

    }

    ChangerClassFreePool(dataBuffer);

    //
    // Build address mapping.
    //

    status = SonyBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // SONY_MO changers (OSL-6000, OSL-2500) are no more supported, but
    // we'll keep SONY_MO specific code anyways
    //
    if (changerData->DriveType == SONY_MO) {
        serialBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(SERIAL_NUMBER));
        if (!serialBuffer) {

            DebugPrint((1,
                        "Sonymc.ChangerInitialize: Error allocating serial number buffer. %x\n",
                        status));

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Get serial number.
        //

        RtlZeroMemory(serialBuffer, sizeof(SERIAL_NUMBER));

        //
        // Get serial number page.
        //

        RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

        //
        // Set timeout value.
        //

        srb.TimeOutValue = 10;

        srb.CdbLength = 6;

        cdb = (PCDB)srb.Cdb;

        //
        // Set CDB operation code.
        //

        cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

        //
        // Set EVPD
        //

        cdb->CDB6INQUIRY.Reserved1 = 1;

        //
        // Unit serial number page.
        //

        cdb->CDB6INQUIRY.PageCode = 0x80;

        //
        // Set allocation length to inquiry data buffer size.
        //

        cdb->CDB6INQUIRY.AllocationLength = sizeof(SERIAL_NUMBER);

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             &srb,
                                             serialBuffer,
                                             sizeof(SERIAL_NUMBER),
                                             FALSE);

        if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
            SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

            RtlMoveMemory(changerData->SerialNumber, serialBuffer->ControllerSerialNumber, SONY_SERIAL_NUMBER_LENGTH);

        }

        ChangerClassFreePool(serialBuffer);

    }

    //
    // Send an allow to the unit to ensure that the LockCount and state of the unit
    // are in sync.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb.Cdb;
    srb.CdbLength = CDB6GENERIC_LENGTH;
    srb.DataTransferLength = 0;
    srb.TimeOutValue = 10;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
    cdb->MEDIA_REMOVAL.Prevent = 0;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     NULL,
                                     0,
                                     FALSE);

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    
    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_UNIT_ATTENTION:

            if (senseBuffer->AdditionalSenseCode != SCSI_ADSENSE_MEDIUM_CHANGED) {

                //
                // Reset/power-on clears any prevents.
                //

                InterlockedExchange(&changerData->LockCount, 0);
            }
            break;

        case SCSI_SENSE_HARDWARE_ERROR: {
           changerData->DeviceStatus = SONYMC_HW_ERROR;
           break;
        }

        default:
            break;
        }
        DebugPrint((1,
                   "ChangerError: Sense Key - %x\n",
                   senseBuffer->SenseKey & 0x0f));
        DebugPrint((1,
                   "              AdditionalSenseCode - %x\n",
                   senseBuffer->AdditionalSenseCode));
        DebugPrint((1,
                   "              AdditionalSenseCodeQualifier - %x\n",
                   senseBuffer->AdditionalSenseCodeQualifier));
    } else {
        DebugPrint((1,
                   "ChangerError: Autosense not valid. SrbStatus %x\n",
                   Srb->SrbStatus));
    }


    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    Sony changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    bufferLength;
    PVOID    modeBuffer;
    PCDB     cdb;
    ULONG    i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = SONY_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    if (changerData->DriveType == SONY_MO) {
        changerParameters->NumberOfDoors = 1;
        changerParameters->MagazineSize = 10;
    }

    changerParameters->NumberCleanerSlots = 0;
    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_TRANSPORT_GEOMETRY_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (PCHAR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Determine if mc has 2-sided media.
    //

    changerParameters->Features0 = transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->DriveCleanTimeout = 0;

    changerParameters->Features0 |= CHANGER_LOCK_UNLOCK                     |
                                    CHANGER_STATUS_NON_VOLATILE             |
                                    CHANGER_EXCHANGE_MEDIA                  |
                                    CHANGER_POSITION_TO_ELEMENT             |
                                    CHANGER_CARTRIDGE_MAGAZINE              |
                                    CHANGER_REPORT_IEPORT_STATE             |
                                    CHANGER_DEVICE_REINITIALIZE_CAPABLE     |
                                    CHANGER_SERIAL_NUMBER_VALID             |
                                    CHANGER_VOLUME_IDENTIFICATION           |
                                    CHANGER_VOLUME_REPLACE                  |
                                    CHANGER_VOLUME_SEARCH;

    changerParameters->PositionCapabilities = (CHANGER_TO_DRIVE | CHANGER_TO_SLOT | CHANGER_TO_IEPORT);
    changerParameters->LockUnlockCapabilities = (LOCK_UNLOCK_IEPORT);

    if (changerData->DriveType == SONY_CD) {
        changerParameters->Features0 &= ~(CHANGER_CARTRIDGE_MAGAZINE    |
                                          CHANGER_VOLUME_IDENTIFICATION |
                                          CHANGER_VOLUME_REPLACE        |
                                          CHANGER_VOLUME_SEARCH         |
                                          CHANGER_SERIAL_NUMBER_VALID   |
                                          CHANGER_BAR_CODE_SCANNER_INSTALLED);
        if (changerData->DriveID == CDL1100) {
            changerParameters->Features0 |= CHANGER_CLOSE_IEPORT | CHANGER_OPEN_IEPORT;
        } else {
            changerParameters->Features1 |= CHANGER_SLOTS_USE_TRAYS |
                                            CHANGER_MOVE_EXTENDS_IEPORT |
                                            CHANGER_MOVE_RETRACTS_IEPORT;
            changerParameters->Features0 &= ~CHANGER_REPORT_IEPORT_STATE;
        }
    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);

    if (changerData->DriveType == SONY_MO) {
        RtlMoveMemory(productData->SerialNumber, changerData->SerialNumber, SONY_SERIAL_NUMBER_LENGTH);
    }

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the IEPort.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;


    if (ElementOutOfRange(addressMapping, (USHORT)setAccess->Element.ElementAddress, setAccess->Element.ElementType)) {
        DebugPrint((1,
                   "ChangerSetAccess: Element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;

    if (setAccess->Element.ElementType == ChangerIEPort) {

        if (controlOperation == LOCK_ELEMENT) {


            //
            // Inc the lock count to indicate that a prevent is on the device.
            //

            InterlockedIncrement(&changerData->LockCount);

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // Issue prevent media removal command to lock the ie port.
            //

            cdb->MEDIA_REMOVAL.Prevent = 1;

        } else if (controlOperation == UNLOCK_ELEMENT) {

            InterlockedExchange(&changerData->LockCount, 0);

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // Issue allow media removal.
            //

            cdb->MEDIA_REMOVAL.Prevent = 0;

        } else {
            if (changerData->DriveType == SONY_MO) {
                status = STATUS_INVALID_PARAMETER;
            } else {

                if (controlOperation == EXTEND_IEPORT) {

                    srb->TimeOutValue = fdoExtension->TimeOutValue;

                    //
                    // Sony uses a vendor unique mailslot command.
                    // bytes 0/1 need to be the address of the mailslot (0x000A)
                    //

                    cdb->CDB6GENERIC.OperationCode = SCSIOP_ROTATE_MAILSLOT;

                    cdb->CDB6GENERIC.CommandUniqueBytes[0] = 0x00;
                    cdb->CDB6GENERIC.CommandUniqueBytes[1] = 0x0A;
                    cdb->CDB6GENERIC.CommandUniqueBytes[2] = SONY_MAILSLOT_OPEN;

                } else if (controlOperation == RETRACT_IEPORT) {

                    srb->TimeOutValue = fdoExtension->TimeOutValue;

                    //
                    // Sony uses a vendor unique mailslot command.
                    // bytes 0/1 need to be the address of the mailslot (0x000A)
                    //

                    cdb->CDB6GENERIC.OperationCode = SCSIOP_ROTATE_MAILSLOT;


                    cdb->CDB6GENERIC.CommandUniqueBytes[0] = 0x00;
                    cdb->CDB6GENERIC.CommandUniqueBytes[1] = 0x0A;
                    cdb->CDB6GENERIC.CommandUniqueBytes[2] = SONY_MAILSLOT_CLOSE;

                } else {
                    status = STATUS_INVALID_PARAMETER;
                }
            }
        }
    } else {

        //
        // No door/keypad selectivity programatically.
        //

        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // Issue the srb.
        //

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    ULONG    totalElements = 0;
    NTSTATUS status;
    PVOID    statusBuffer;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    if (elementType == AllElements) {

        ULONG i;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;
            totalElements += addressMapping->NumberOfElements[i];
        }

        if (totalElements != readElementStatus->ElementList.NumberOfElements) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) AllElements\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements));

            return STATUS_INVALID_PARAMETER;
        }

        //
        // Account for length of the descriptors expected for the drives.
        //


        if (readElementStatus->VolumeTagInfo) {

            length = sizeof(SONY_ELEMENT_DESCRIPTOR_PLUS) * totalElements;

            //
            // Add in header and status pages.
            //

            length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);

        } else {

            length = sizeof(SONY_ELEMENT_DESCRIPTOR) * totalElements;

            //
            // Add in header and status pages.
            //

            length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);

        }

    } else {

        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType)) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        totalElements = readElementStatus->ElementList.NumberOfElements;
        if (totalElements > addressMapping->NumberOfElements[elementType]) {

            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) for type (%x)\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements,
                       elementType));

            return STATUS_INVALID_PARAMETER;
        }

        if (readElementStatus->VolumeTagInfo) {

            length = (sizeof(SONY_ELEMENT_DESCRIPTOR_PLUS) * totalElements);

        } else {

            length = (sizeof(SONY_ELEMENT_DESCRIPTOR) * totalElements);
        }

        //
        // Add in length of header and status page.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);

    }

    DebugPrint((3,
               "ChangerGetElementStatus: Allocation Length %x, for %x elements of type %x\n",
               length,
               totalElements,
               elementType));

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // These devices may not have the low address as 0.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(totalElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(totalElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (NT_SUCCESS(status) ||
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG remainingElements;
        ULONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        ULONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        if (remainingElements > totalElements ) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Returned elements incorrect - %x\n",
                       remainingElements));

            ChangerClassFreePool(srb);
            ChangerClassFreePool(statusBuffer);

            return STATUS_IO_DEVICE_ERROR;
        }

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (PCHAR)statusPage = (PCHAR)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;

                if (tagInfo) {

                    PSONY_ELEMENT_DESCRIPTOR_PLUS tmpDescriptor =
                                                            (PSONY_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor;

                    if (statusPage->PVolTag) {

                        RtlZeroMemory(elementStatus->PrimaryVolumeID, MAX_VOLUME_ID_SIZE);
                        RtlMoveMemory(elementStatus->PrimaryVolumeID, tmpDescriptor->PVolTagInformation, MAX_VOLUME_ID_SIZE);

                        elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                    }
                    if (statusPage->AVolTag) {

                        RtlZeroMemory(elementStatus->AlternateVolumeID, MAX_VOLUME_ID_SIZE);
                        //RtlMoveMemory(elementStatus->AlternateVolumeID, tmpDescriptor->AVolTagInformation, MAX_VOLUME_ID_SIZE);

                        elementStatus->Flags |= ELEMENT_STATUS_AVOLTAG;
                    }


                    if (elementDescriptor->IdValid) {
                        elementStatus->Flags |= ELEMENT_STATUS_ID_VALID;
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }

                    if (elementDescriptor->LunValid) {
                        elementStatus->Flags |= ELEMENT_STATUS_LUN_VALID;
                        elementStatus->Lun = elementDescriptor->Lun;
                    }

                    //
                    // Source address
                    //

                    if (elementDescriptor->SValid) {

                        ULONG  j;
                        USHORT tmpAddress;


                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                        elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                    }

                } else {

                    //
                    // Source address
                    //

                    if (elementDescriptor->SValid) {
                        ULONG  j;
                        USHORT tmpAddress;


                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];
                        elementStatus->Flags |= ELEMENT_STATUS_SVALID;
                    }

                    if (elementDescriptor->IdValid) {
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }
                    if (elementDescriptor->LunValid) {
                        elementStatus->Lun = elementDescriptor->Lun;
                    }
                }

                //
                // Build Flags field.
                //

                elementStatus->Flags |= elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);

                //
                // Map any exceptions reported directly.
                // If there is volume info returned ensure that it's not all spaces
                // as this indicates that the label is missing or unreadable.
                //

                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {

                    //
                    // Map the exception.
                    //

                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                } else if (elementStatus->Flags & ELEMENT_STATUS_PVOLTAG) {

                    ULONG index;

                    //
                    // Ensure that the tag info isn't all spaces. This indicates an error.
                    //

                    for (index = 0; index < MAX_VOLUME_ID_SIZE; index++) {
                        if (elementStatus->PrimaryVolumeID[index] != ' ') {
                            break;
                        }
                    }

                    //
                    // Determine if the volume id was all spaces. Do an extra check to see if media is
                    // actually present, for the unit will set the PVOLTAG flag whether media is present or not.
                    //

                    if ((index == MAX_VOLUME_ID_SIZE) && (elementStatus->Flags & ELEMENT_STATUS_FULL)) {

                        DebugPrint((1,
                                   "Sonymc.GetElementStatus: Setting exception to LABEL_UNREADABLE\n"));

                        elementStatus->Flags &= ~ELEMENT_STATUS_PVOLTAG;
                        elementStatus->Flags |= ELEMENT_STATUS_EXCEPT;
                        elementStatus->ExceptionCode = ERROR_LABEL_UNREADABLE;
                    }
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                elementStatus += 1;

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * totalElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue * 10;
        srb->DataTransferLength = 0;

    } else {

        ChangerClassFreePool(srb);
        return STATUS_INVALID_PARAMETER;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += addressMapping->FirstElement[setPosition->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;


    srb->DataTransferLength = 0;
    srb->TimeOutValue = 200;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{


    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_EXCHANGE_MEDIUM exchangeMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination1, destination2;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    LONG                lockValue = 0;
    NTSTATUS            status;


    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(exchangeMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(exchangeMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, exchangeMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerExchangeMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination1 = (USHORT)(exchangeMedium->Destination1.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination1, exchangeMedium->Destination1.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination2 = (USHORT)(exchangeMedium->Destination2.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination2, exchangeMedium->Destination2.ElementType)) {
        DebugPrint((1,
                   "ChangerExchangeMedium: Destination1 element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[exchangeMedium->Source.ElementType];
    destination1 += addressMapping->FirstElement[exchangeMedium->Destination1.ElementType];
    destination2 += addressMapping->FirstElement[exchangeMedium->Destination2.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    if ((exchangeMedium->Destination1.ElementType == ChangerIEPort) ||
        (exchangeMedium->Destination2.ElementType == ChangerIEPort) ||
        (exchangeMedium->Source.ElementType == ChangerIEPort)) {

        //
        // Determine value of LockCount.
        // Note that if other functionality is added to this routine, EXTEND/RETRACT
        // will have to be split out from this else.
        //

        lockValue = changerData->LockCount;
        DebugPrint((1,
                   "ExchangeMedium: LockCount is %x\n",
                   lockValue));

        if (lockValue) {

            //
            // Send an allow to clear the prevent for IEPORT extend/retract.
            //

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 0;

            //
            // Ignore errors at this point. If this fails and the move doesn't happen, the LM will
            // clean things up.
            //

            status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
            DebugPrint((1,
                       "ExchangeMedium: Allow sent. Status %x\n",
                       status));

            status = STATUS_SUCCESS;
        }
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->EXCHANGE_MEDIUM.OperationCode = SCSIOP_EXCHANGE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->EXCHANGE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->EXCHANGE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->EXCHANGE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->EXCHANGE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[0] = (UCHAR)(destination1 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination1ElementAddress[1] = (UCHAR)(destination1 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[0] = (UCHAR)(destination2 >> 8);
    cdb->EXCHANGE_MEDIUM.Destination2ElementAddress[1] = (UCHAR)(destination2 & 0xFF);

    cdb->EXCHANGE_MEDIUM.Flip1 = exchangeMedium->Flip1;
    cdb->EXCHANGE_MEDIUM.Flip2 = exchangeMedium->Flip2;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_EXCHANGE_MEDIUM);
    }


    if ((exchangeMedium->Destination1.ElementType == ChangerIEPort) ||
        (exchangeMedium->Destination2.ElementType == ChangerIEPort) ||
        (exchangeMedium->Source.ElementType == ChangerIEPort)) {

        if (lockValue) {

            NTSTATUS preventStatus;

            //
            // Send the prevent to re-lock down the unit.
            //

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 1;

            //
            // Ignore any errors at this point. The calling layer will need to fixup any problems with
            // prevent/allow.
            //

            preventStatus = ChangerClassSendSrbSynchronous(DeviceObject,
                                                    srb,
                                                    NULL,
                                                    0,
                                                    FALSE);

            DebugPrint((1,
                       "ExchangeMedium: Prevent sent. Status %x\n",
                       preventStatus));
        }
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport;
    USHORT source;
    USHORT destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    LONG                lockValue = 0;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // Check if an attempt is being made to move the medium from an element to
    // itself (drive1 to drive1, slot1 to slot1, etc). If so, just return
    // SUCCESS. Do nothing else unless Flip is set to TRUE. Flip is true
    // when the user just wants to flip the media, and not move per se.
    //
    if ((moveMedium->Flip == FALSE) &&
        (moveMedium->Source.ElementType == moveMedium->Destination.ElementType)) {
       if (source == destination) {
          DebugPrint((1, 
                      "Attempt to move from an element to itself. \n"));
          DebugPrint((1, 
                      "Element Type : %d, Source : %d, Destination %d. \n",
                      moveMedium->Source.ElementType, source, destination));
          return STATUS_SUCCESS;
       }
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    if ((moveMedium->Destination.ElementType == ChangerIEPort) ||
        (moveMedium->Source.ElementType == ChangerIEPort)) {

        //
        // Determine value of LockCount.
        // Note that if other functionality is added to this routine, EXTEND/RETRACT
        // will have to be split out from this else.
        //

        lockValue = changerData->LockCount;
        DebugPrint((1,
                   "MoveMedium: LockCount is %x\n",
                   lockValue));

        if (lockValue) {

            //
            // Send an allow to clear the prevent for IEPORT extend/retract.
            //

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 0;

            //
            // Ignore errors at this point. If this fails and the move doesn't happen, the LM will
            // clean things up.
            //

            status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
            DebugPrint((1,
                       "MoveMedium: Allow sent. Status %x\n",
                       status));

            status = STATUS_SUCCESS;
        }
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    } else {
        DebugPrint((1,
                   "MoveMedium: Status of Move %x\n",
                   status));
    }

    if ((moveMedium->Destination.ElementType == ChangerIEPort) ||
        (moveMedium->Source.ElementType == ChangerIEPort)) {

        if (lockValue) {

            NTSTATUS preventStatus;

            //
            // Send the prevent to re-lock down the unit.
            //

            RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
            cdb = (PCDB)srb->Cdb;
            srb->CdbLength = CDB6GENERIC_LENGTH;
            srb->DataTransferLength = 0;
            srb->TimeOutValue = 10;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            cdb->MEDIA_REMOVAL.Prevent = 1;

            //
            // Ignore any errors at this point. The LM will fixup any problems with
            // prevent/allow
            //

            preventStatus = ChangerClassSendSrbSynchronous(DeviceObject,
                                    srb,
                                    NULL,
                                    0,
                                    FALSE);
            DebugPrint((1,
                       "MoveMedium: Prevent sent. Status %x\n",
                       preventStatus));
        }
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Issue a rezero unit to the device.
    //

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_REZERO_UNIT;
    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;


    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{


    PCHANGER_SEND_VOLUME_TAG_INFORMATION volTagInfo = Irp->AssociatedIrp.SystemBuffer;
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_ELEMENT    element = &volTagInfo->StartingElement;
    PSCSI_REQUEST_BLOCK srb;
    PVOID    tagBuffer;
    PVOID    statusBuffer;
    PCDB     cdb;
    NTSTATUS status;

    //
    // Do some validation.
    //

    if (changerData->DriveType == SONY_CD) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    switch (volTagInfo->ActionCode) {
        case SEARCH_ALL      :
        case SEARCH_PRIMARY  :
        case SEARCH_ALTERNATE:
        case SEARCH_ALL_NO_SEQ:
        case SEARCH_PRI_NO_SEQ:
        case SEARCH_ALT_NO_SEQ:
        case UNDEFINE_PRIMARY:
        case UNDEFINE_ALTERNATE:
        case ASSERT_PRIMARY:
        case ASSERT_ALTERNATE:
             break;

        case REPLACE_PRIMARY:
        case REPLACE_ALTERNATE:

            //
            // Ensure that only one element is being specified.
            //

            if (element->ElementType == AllElements) {

                DebugPrint((1,
                           "QueryVolumeTags: Attempting REPLACE on AllElements\n"));

                return STATUS_INVALID_DEVICE_REQUEST;
            }
            break;
        default:

            DebugPrint((1,
                       "QueryVolumeTags: Unsupported operation. ActionCode %x\n",
                       volTagInfo->ActionCode));

            return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    tagBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, MAX_VOLUME_TEMPLATE_SIZE);

    if (!srb || !tagBuffer) {

        if (srb) {
            ChangerClassFreePool(srb);
        }
        if (tagBuffer) {
            ChangerClassFreePool(tagBuffer);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    RtlZeroMemory(tagBuffer, MAX_VOLUME_TEMPLATE_SIZE);

    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataTransferLength = MAX_VOLUME_TEMPLATE_SIZE;

    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->SEND_VOLUME_TAG.OperationCode = SCSIOP_SEND_VOLUME_TAG;


    if ((volTagInfo->ActionCode == SEARCH_ALL)        ||
        (volTagInfo->ActionCode == SEARCH_PRIMARY)    ||
        (volTagInfo->ActionCode == SEARCH_ALTERNATE)  ||
        (volTagInfo->ActionCode == SEARCH_ALL_NO_SEQ) ||
        (volTagInfo->ActionCode == SEARCH_PRI_NO_SEQ) ||
        (volTagInfo->ActionCode == SEARCH_ALT_NO_SEQ)) {

        //
        // This is reserved for all other action codes.
        //

        cdb->SEND_VOLUME_TAG.ElementType = (UCHAR)element->ElementType;

        cdb->SEND_VOLUME_TAG.ParameterListLength[0] = 0;
        cdb->SEND_VOLUME_TAG.ParameterListLength[1] = MAX_VOLUME_TEMPLATE_SIZE;

        //
        // Load buffer with template.
        //

        RtlMoveMemory(tagBuffer, volTagInfo->VolumeIDTemplate, MAX_VOLUME_TEMPLATE_SIZE);


    } else if ((volTagInfo->ActionCode == UNDEFINE_PRIMARY)   ||
               (volTagInfo->ActionCode == UNDEFINE_ALTERNATE)) {

        cdb->SEND_VOLUME_TAG.ParameterListLength[0] = 0;
        cdb->SEND_VOLUME_TAG.ParameterListLength[1] = 0;

    } else if ((volTagInfo->ActionCode == REPLACE_PRIMARY)   ||
               (volTagInfo->ActionCode == REPLACE_ALTERNATE) ||
               (volTagInfo->ActionCode == ASSERT_PRIMARY)    ||
               (volTagInfo->ActionCode == ASSERT_ALTERNATE)) {


        cdb->SEND_VOLUME_TAG.ParameterListLength[0] = 0;
        cdb->SEND_VOLUME_TAG.ParameterListLength[1] = MAX_VOLUME_TEMPLATE_SIZE;

        //
        // Load buffer with template.
        //

        RtlMoveMemory(tagBuffer, volTagInfo->VolumeIDTemplate, MAX_VOLUME_TEMPLATE_SIZE);
    }


    if (element->ElementType == AllElements) {
        cdb->SEND_VOLUME_TAG.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->SEND_VOLUME_TAG.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {
        cdb->SEND_VOLUME_TAG.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
        cdb->SEND_VOLUME_TAG.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

    }

    cdb->SEND_VOLUME_TAG.ActionCode = (UCHAR)volTagInfo->ActionCode;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         tagBuffer,
                                         MAX_VOLUME_TEMPLATE_SIZE,
                                         TRUE);

    ChangerClassFreePool(tagBuffer);

    if (NT_SUCCESS(status)) {

        PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
        PREAD_ELEMENT_ADDRESS_INFO readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;
        ULONG returnElements = irpStack->Parameters.DeviceIoControl.OutputBufferLength / sizeof(READ_ELEMENT_ADDRESS_INFO);
        ULONG requestLength;
        PVOID statusBuffer;

        //
        // Size of buffer returned is based on the size of the user buffer. If it's incorrectly
        // sized, the IoStatus.Information will be updated to indicate how large it should really be.
        //

        requestLength = sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE) +
                              (sizeof(SONY_ELEMENT_DESCRIPTOR_PLUS) * returnElements);

        statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, requestLength);
        if (!statusBuffer) {
            ChangerClassFreePool(srb);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(statusBuffer, requestLength);

        //
        // Build read volume element command.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB12GENERIC_LENGTH;
        srb->DataTransferLength = requestLength;

        srb->TimeOutValue = fdoExtension->TimeOutValue;

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.OperationCode = SCSIOP_REQUEST_VOL_ELEMENT;
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.ElementType = (UCHAR)element->ElementType;

        if (element->ElementType == AllElements) {
            cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[0] =
                (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);
            cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[1] =
                (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

        } else {
            cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[0] =
                (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
            cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[1] =
                (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
        }

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.NumberElements[0] = (UCHAR)(returnElements >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.NumberElements[1] = (UCHAR)(returnElements & 0xFF);

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.VolTag = 1;

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.AllocationLength[0] = (UCHAR)(requestLength >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.AllocationLength[1] = (UCHAR)(requestLength & 0xFF);


        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             statusBuffer,
                                             requestLength,
                                             TRUE);


        if ((status == STATUS_SUCCESS) || (status == STATUS_DATA_OVERRUN)) {

            PREAD_ELEMENT_ADDRESS_INFO readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;
            PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
            PELEMENT_STATUS_PAGE   statusPage;
            PCHANGER_ELEMENT_STATUS elementStatus;
            PELEMENT_DESCRIPTOR elementDescriptor;
            ULONG i;
            ULONG descriptorLength;
            ULONG numberElements;
            ULONG dataTransferLength = srb->DataTransferLength;

            //
            // Make it success.
            //

            status = STATUS_SUCCESS;

            //
            // Determine if ANY matches were found.
            //

            if (dataTransferLength <= sizeof(ELEMENT_STATUS_HEADER)) {
                numberElements = 0;
            } else {

                //
                // Subtract out header and page info.
                //

                dataTransferLength -= sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);
                numberElements = dataTransferLength / sizeof(SONY_ELEMENT_DESCRIPTOR_PLUS);

            }

            DebugPrint((1,
                       "QueryVolumeTags: Matches found - %x\n",
                       numberElements));

            //
            // Update IoStatus.Information to indicate the correct buffer size.
            // Account for the fact that READ_ELEMENT_ADDRESS_INFO is declared
            // with a one-element array of CHANGER_ELEMENT_STATUS.
            //

            Irp->IoStatus.Information = sizeof(READ_ELEMENT_ADDRESS_INFO) +
                                        ((numberElements - 1) *
                                         sizeof(CHANGER_ELEMENT_STATUS));

            //
            // Fill in user buffer.
            //

            readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;

            readElementAddressInfo->NumberOfElements = numberElements;

            if (numberElements) {

                ELEMENT_TYPE        elementType;

                //
                // The buffer is composed of a header, status page, and element descriptors.
                // Point each element to it's respective place in the buffer.
                //


                (PCHAR)statusPage = (PCHAR)statusHeader;
                (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

                elementType = statusPage->ElementType;

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                elementStatus = &readElementAddressInfo->ElementStatus[0];

                //
                // Set values for each element descriptor.
                //

                for (i = 0; i < numberElements; i++ ) {

                    PSONY_ELEMENT_DESCRIPTOR_PLUS tmpDescriptor =
                                                            (PSONY_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor;

                    //
                    // Get the address for this element.
                    //

                    elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                    elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                    //
                    // Account for address mapping.
                    //

                    elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                    //
                    // Set the element type.
                    //

                    elementStatus->Element.ElementType = elementType;
                    elementStatus->Flags = 0;

                    //
                    // Source address
                    //

                    if (elementDescriptor->SValid) {

                        ULONG  j;
                        USHORT tmpAddress;


                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                        elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                    }


                    //
                    // Build Flags field.
                    //

                    elementStatus->Flags |= elementDescriptor->Full;
                    elementStatus->Flags |= (elementDescriptor->Exception << 2);
                    elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                    elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                    elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                    elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                    elementStatus->Flags |= (elementDescriptor->Invert << 22);
                    elementStatus->Flags |= (elementDescriptor->SValid << 23);

                    //
                    // Map any exceptions reported directly.
                    // If there is volume info returned ensure that it's not all spaces
                    // as this indicates that the label is missing or unreadable.
                    //

                    if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {

                        //
                        // Map the exception.
                        //

                        elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                    }

                    if (elementDescriptor->IdValid) {
                        elementStatus->Flags |= ELEMENT_STATUS_ID_VALID;
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }

                    if (elementDescriptor->LunValid) {
                        elementStatus->Flags |= ELEMENT_STATUS_LUN_VALID;
                        elementStatus->Lun = elementDescriptor->Lun;
                    }

                    if (statusPage->PVolTag) {

                        RtlZeroMemory(elementStatus->PrimaryVolumeID, MAX_VOLUME_ID_SIZE);
                        RtlMoveMemory(elementStatus->PrimaryVolumeID, tmpDescriptor->PVolTagInformation, MAX_VOLUME_ID_SIZE);

                        elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                    }
                    if (statusPage->AVolTag) {
                        RtlZeroMemory(elementStatus->AlternateVolumeID, MAX_VOLUME_ID_SIZE);
                        //RtlMoveMemory(elementStatus->AlternateVolumeID, tmpDescriptor->AVolTagInformation, MAX_VOLUME_ID_SIZE);

                        elementStatus->Flags |= ELEMENT_STATUS_AVOLTAG;
                    }

                    //
                    // Advance to the next entry in the user buffer and element descriptor array.
                    //

                    elementStatus += 1;
                    (PCHAR)elementDescriptor += descriptorLength;
                }
            }
        } else {
            DebugPrint((1,
                       "QueryVolumeTags: RequestElementAddress failed. %x\n",
                       status));
        }

        ChangerClassFreePool(statusBuffer);

    } else {
        DebugPrint((1,
                   "QueryVolumeTags: Send Volume Tag failed. %x\n",
                   status));
    }
    if (srb) {
        ChangerClassFreePool(srb);
    }
    return status;
}


NTSTATUS
SonyBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    ULONG                  bufferLength;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);


    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = SONY_NO_ELEMENT;
    }

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];

        //
        // Determine lowest address of all elements.
        //


        addressMapping->LowAddress = SONY_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{

    ULONG exceptionCode = 0;
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;


    switch (asc) {
        case 0x0:
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    DebugPrint((1,
               "Sonymc.MapExceptionCode: ASC %x, ASCQ %x, exceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;

}


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == SONY_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{

   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize DeviceStatusin the device extension to 
   // SONYMC_DEVICE_PROBLEM_NONE. If the changer returns sense code 
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set appropriate 
   // DeviceStatus in ChangerError routine.
   //
   changerData->DeviceStatus = SONYMC_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "SONYMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set SelfTest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) == SONYMC_DEVICE_PROBLEM_NONE) {
      switch (changerData->DeviceStatus) {
         case SONYMC_HW_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }

         default: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }
      } // switch(changerData->DeviceStatus)
   }

   ChangerClassFreePool(srb);

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\spectra\spctramc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    spctramc.c

Abstract:

    This module contains device-specific routines for the following
    Spectralogic medium changers: 
            - Spectra 4000, 5000, 9000, 10000

Author:

    davet (Dave Therrien - HighGround Systems)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "spctramc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, ExaBuildAddressMapping)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}


typedef struct _SERIALNUMBER {
    UCHAR DeviceType;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR SerialNumber[VPD_SERIAL_NUMBER_LENGTH];
} SERIALNUMBER, *PSERIALNUMBER;



NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PSERIALNUMBER  serialBuffer;
    PVUPL_MODE_PAGE modeBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);

    //
    // Build address mapping.
    //

    status = ExaBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        DebugPrint((1,
                    "BuildAddressMapping failed. %x\n", status));
        // Don't fail this here , this unit has a problem with 
        // being not ready for a long time 

        // return status;
    }

    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                                sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Now get the full inquiry information for the device.

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);
    srb.TimeOutValue = 10;
    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;
    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;
    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         dataBuffer,
                                         sizeof(INQUIRYDATA),
                                         FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength +
                             FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }

        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

        if (RtlCompareMemory(dataBuffer->ProductId,"4000",4) == 4) {
            changerData->DriveID = S_4mm_4000;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"5000",4) == 4) {
            changerData->DriveID = S_4mm_5000;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"9000",4) == 4) {
            changerData->DriveID = S_8mm_EXB;
        } else if (RtlCompareMemory(dataBuffer->ProductId,"10000",5) == 5) {
            changerData->DriveID = S_8mm_SONY;
        } else if (RtlCompareMemory(dataBuffer->ProductId, "215", 3)) {
            changerData->DriveID = S_8mm_AIT;
        }
    }

    // -------------------------------------------------------------------
    // 
    // Get serial number page for the 10000 and Treefrog units only
    // not supported on 4000, 5000 and 9000 units !

    if (changerData->DriveID == S_8mm_SONY) {

        serialBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 14);
        if (!serialBuffer) {
            ChangerClassFreePool(dataBuffer);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(serialBuffer, sizeof(SERIALNUMBER));

        RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);
        srb.TimeOutValue = 10;
        srb.CdbLength = 6;

        cdb = (PCDB)srb.Cdb;
        cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

        // Set EVPD
        cdb->CDB6INQUIRY.Reserved1 = 1;

        // Unit serial number page.
        cdb->CDB6INQUIRY.PageCode = 0x80;

        // Set allocation length to inquiry data buffer size.
        cdb->CDB6INQUIRY.AllocationLength = sizeof(SERIALNUMBER);

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         serialBuffer,
                                         sizeof(SERIALNUMBER),
                                         FALSE);

        if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
            SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

            RtlMoveMemory(changerData->SerialNumber, 
                      serialBuffer->SerialNumber, VPD_SERIAL_NUMBER_LENGTH);
            ChangerClassFreePool(serialBuffer);
        }
    }

    ChangerClassFreePool(dataBuffer);

    return STATUS_SUCCESS;
}


VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PIRP irp = Srb->OriginalRequest;


    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_NOT_READY:
           if (senseBuffer->AdditionalSenseCode == 0x04) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x84:
                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_DOOR_OPEN;
                        break;
                    default:
                        break;
                }
            }
            break;

        case SCSI_SENSE_HARDWARE_ERROR:
           changerData->DeviceStatus = SPECTRA_HW_ERROR;
           if (senseBuffer->AdditionalSenseCode == 0x85) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x23:
                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_NOT_CONNECTED;
                        break;
                    default:
                        break;
                }
            }
            break;

        default:
            break;
        }
    }

    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    PVUPL_MODE_PAGE vuplModePage;
    NTSTATUS status;
    ULONG    length;
    PVOID    modeBuffer;
    PCDB     cdb;

    if (addressMapping->Initialized != TRUE) {
        status = ExaBuildAddressMapping(DeviceObject);
        if (status != STATUS_SUCCESS) {
            DebugPrint((1,
                       "Spctrmc: InitElementStatus: Build address map failed %x\n",
                       status));
            return status;
        }
    }

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (srb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    // ----------------------------------------------------------
    // 
    // Get Mode Sense Page 1D - Element address assignment page.

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                sizeof(MODE_PARAMETER_HEADER) +
                                sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    // Send the request.
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    // Fill in values.

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = 
                 elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= 
                 (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = 
                 elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= 
                 (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = 
                 elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= 
                 (elementAddressPage->NumberIEPortElements[0] << 8);
    
    changerParameters->NumberDataTransferElements = 
                 elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= 
                 (elementAddressPage->NumberDataXFerElements[0] << 8);

    changerParameters->NumberOfDoors = 0;
    if (changerData->DriveID == S_8mm_AIT) {
        changerParameters->NumberOfDoors = 1;
    }

    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;
    changerParameters->FirstCleanerSlotAddress = 0;

    changerParameters->MagazineSize = 
                     changerParameters->NumberStorageElements;

    changerParameters->DriveCleanTimeout = 600;

    ChangerClassFreePool(modeBuffer);

    // ----------------------------------------------------------
    // 
    // Get Mode Sense Page 1E - transport geometry mode sense.

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, 
                             sizeof(MODE_PARAMETER_HEADER) +
                             sizeof(MODE_PAGE_TRANSPORT_GEOMETRY));
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) +
                              sizeof(MODE_TRANSPORT_GEOMETRY_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + 
                              sizeof(MODE_TRANSPORT_GEOMETRY_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    // Send the request.
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (ULONG_PTR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);

    // initialize Features1  
        changerParameters->Features1 = CHANGER_IEPORT_USER_CONTROL_OPEN |
                                                                   CHANGER_IEPORT_USER_CONTROL_CLOSE ;

    // initialize Features 0 and then set flip bit... 
    changerParameters->Features0 = 
             transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;

    // Features based on manual, nothing programatic.
    changerParameters->Features0 |= 
               CHANGER_STATUS_NON_VOLATILE           | 
               CHANGER_LOCK_UNLOCK                   |                                   
               CHANGER_POSITION_TO_ELEMENT           |
               CHANGER_REPORT_IEPORT_STATE           |
               CHANGER_DRIVE_CLEANING_REQUIRED       |
               CHANGER_PREDISMOUNT_EJECT_REQUIRED;

        // Only the IEPORT can be locked and unlocked
    changerParameters->LockUnlockCapabilities = LOCK_UNLOCK_IEPORT;

    // Serial number not supported on 4000 and 9000 libraries
    // Serial number is supported on 5000, 10000 and Treefrog units
    if (changerData->DriveID == S_8mm_SONY) {
        changerParameters->Features0 |= 
               CHANGER_SERIAL_NUMBER_VALID;
    } 
   
    ChangerClassFreePool(modeBuffer);

    // ----------------------------------------------------------
    // 
    // Get Mode Sense Page 00 - Vendor Unique Parameter List Page
    //                          Is Barcode reader installed ? 

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    length =  sizeof(MODE_PARAMETER_HEADER) + 
              sizeof(VUPL_MODE_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, length);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = length;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = 0;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    vuplModePage = modeBuffer;
    (ULONG_PTR)vuplModePage += sizeof(MODE_PARAMETER_HEADER);

    // EBarCo is set if there is a barcode reader installed
    if (vuplModePage->EBarCo == 1) { 
         changerParameters->Features0 |=
                             CHANGER_BAR_CODE_SCANNER_INSTALLED; 
    }

    // ----------------------------------------------------------
    // 
    // Get Mode Sense Page 1F - Device Capabilities Page

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    length =  sizeof(MODE_PARAMETER_HEADER) + 
              sizeof(MODE_DEVICE_CAPABILITIES_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, length);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = length;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    // Fill in values in Features that are contained in this page.

    changerParameters->Features0 |= 
     capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= 
     capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= 
     capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= 
     capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    // Determine all the move from and exchange from 
    // capabilities of this device.

    changerParameters->MoveFromTransport = 
     capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= 
     capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= 
     capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= 
     capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = 
     capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= 
     capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= 
     capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= 
     capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = 
     capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= 
     capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= 
     capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= 
     capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = 
     capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= 
     capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= 
     capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= 
     capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = 
     capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= 
     capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= 
     capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= 
     capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = 
     capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= 
     capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= 
     capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= 
     capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = 
     capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= 
     capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= 
     capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= 
     capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = 
     capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= 
     capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= 
     capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= 
     capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

        
        // legal Position capabilities... 
        changerParameters->PositionCapabilities = 
                        CHANGER_TO_SLOT | 
                        CHANGER_TO_IEPORT | 
                        CHANGER_TO_DRIVE;
                

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}



NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);
    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    // Copy cached inquiry data fields into the system buffer.
    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA)); 
    RtlMoveMemory(productData->VendorId, 
        changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, 
        changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, 
        changerData->InquiryData.ProductRevisionLevel, 4);
    RtlMoveMemory(productData->SerialNumber, 
        changerData->SerialNumber, VPD_SERIAL_NUMBER_LENGTH);

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the Door or IEPort. 

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    BOOLEAN             writeToDevice = FALSE;

    // could lock the front panel, but it may be needed for other 
    // operator tasks. 
    if ((setAccess->Element.ElementType == ChangerKeypad) ||
        (setAccess->Element.ElementType == ChangerDoor)) {
              return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (setAccess->Element.ElementType == ChangerIEPort) {

        // Do Prevent/Allow Medium  Removal... 
        srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
        if (!srb) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

        srb->DataBuffer = NULL;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = 10;

        if (controlOperation == LOCK_ELEMENT) {
            cdb->MEDIA_REMOVAL.Prevent = 1;
        } else if (controlOperation == UNLOCK_ELEMENT) {
            cdb->MEDIA_REMOVAL.Prevent = 0;
        } else {
            status = STATUS_INVALID_PARAMETER;
        }
    } else {
       return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (NT_SUCCESS(status)) {
        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             srb->DataBuffer,
                                             srb->DataTransferLength,
                                             FALSE);
    }

    if (srb->DataBuffer) {
        ChangerClassFreePool(srb->DataBuffer);
    }

    ChangerClassFreePool(srb);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command 
    for either all elements or the
    specified element type. The buffer returned is used to build 
    the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    NTSTATUS status;
    PVOID    statusBuffer;

    // Get the element type.
    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    // Q215 does not report IEPORT status

    if (elementType == AllElements) {
        statusPages = 4;
    } else {
        statusPages = 1;
    } 

    if (readElementStatus->VolumeTagInfo) {
        length = sizeof(ELEMENT_STATUS_HEADER) + 
            (statusPages * sizeof(ELEMENT_STATUS_PAGE)) +
            (SPC_FULL_SIZE * 
                readElementStatus->ElementList.NumberOfElements);
    } else {
        length = sizeof(ELEMENT_STATUS_HEADER) + 
            (statusPages * sizeof(ELEMENT_STATUS_PAGE)) +
            (SPC_PARTIAL_SIZE * 
                readElementStatus->ElementList.NumberOfElements);
    }

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);
    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
        (UCHAR)((element->ElementAddress + 
        addressMapping->FirstElement[element->ElementType]) >> 8);
    cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
        (UCHAR)((element->ElementAddress + 
        addressMapping->FirstElement[element->ElementType]) & 0xFF);

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] =         
        (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] =         (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] =
                                      (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] =
                                      (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] =
                                      (UCHAR)(length & 0xFF);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);
    if (NT_SUCCESS(status) ||
        (status == STATUS_DATA_OVERRUN)) {
        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PSPC_ED elementDescriptor;
        ULONG numberElements = 
             readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        // Determine total number elements returned.
        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        // The buffer is composed of a header, status page, 
        // and element descriptors.
        // Point each element to it's respective place in the buffer.

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = 
           statusPage->ElementDescriptorLength[1];
        descriptorLength |= 
           (statusPage->ElementDescriptorLength[0] << 8);

        // Determine the number of elements of this type reported.
        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        // Fill in user buffer.
        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        do {
            for (i = 0; i < typeCount; i++, remainingElements--) {

                // Get the address for this element.

                elementStatus->Element.ElementAddress =
                 elementDescriptor->SPC_FED.ElementAddress[1];

                elementStatus->Element.ElementAddress |=
                  (elementDescriptor->SPC_FED.ElementAddress[0] << 8);

                // Account for address mapping.
                elementStatus->Element.ElementAddress -= 
                   addressMapping->FirstElement[elementType];

                // Set the element type.
                elementStatus->Element.ElementType = elementType;

                if (elementDescriptor->SPC_FED.SValid) {

                    ULONG  j;
                    USHORT tmpAddress;


                    // Source address is valid. 
                    // Determine the device specific address.
                    tmpAddress = elementDescriptor->SPC_FED.SourceStorageElementAddress[1];
                    tmpAddress |= (elementDescriptor->SPC_FED.SourceStorageElementAddress[0] << 8);

                    // Now convert to 0-based values.
                    for (j = 1; j <= ChangerDrive; j++) {
                        if (addressMapping->FirstElement[j] <= tmpAddress) {
                            if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                elementStatus->SrcElementAddress.ElementType = j;
                                break;
                            }
                        }
                    }

                    elementStatus->SrcElementAddress.ElementAddress =
                         tmpAddress - addressMapping->FirstElement[j];

                }

                // Build Flags field.

                elementStatus->Flags = 
                 elementDescriptor->SPC_FED.Full;
                elementStatus->Flags |= 
                 (elementDescriptor->SPC_FED.Exception << 2);
                elementStatus->Flags |= 
                 (elementDescriptor->SPC_FED.Accessible << 3);

                elementStatus->Flags |= 
                 (elementDescriptor->SPC_FED.LunValid << 12);
                elementStatus->Flags |= 
                 (elementDescriptor->SPC_FED.IdValid << 13);
                elementStatus->Flags |= 
                 (elementDescriptor->SPC_FED.NotThisBus << 15);

                elementStatus->Flags |= 
                 (elementDescriptor->SPC_FED.Invert << 22);
                elementStatus->Flags |= 
                 (elementDescriptor->SPC_FED.SValid << 23);


                if (tagInfo) {
                    RtlMoveMemory(elementStatus->PrimaryVolumeID, 
                        elementDescriptor->SPC_FED.PrimaryVolumeTag, 
                        MAX_VOLUME_ID_SIZE);
                    elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                }

                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {
                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                }

                // if the Pvoltag field is all nulls, this indicates a missing 
                // barcode label as well. 

                if (elementStatus->Flags & ELEMENT_STATUS_PVOLTAG) {

                    ULONG index;
                    for (index = 0; index < MAX_VOLUME_ID_SIZE; index++) {
                        if (elementStatus->PrimaryVolumeID[index] != '\0') {
                            break;
                        }
                    }

                    //
                    // Determine if the volume id was all spaces. Do an extra check to see if media is
                    // actually present, for the unit will set the PVOLTAG flag whether media is present or not.
                    //

                    if ((index == MAX_VOLUME_ID_SIZE) && 
                        (elementStatus->Flags & ELEMENT_STATUS_FULL)) {

                        elementStatus->Flags &= ~ELEMENT_STATUS_PVOLTAG;
                        elementStatus->Flags |= ELEMENT_STATUS_EXCEPT;
                        elementStatus->ExceptionCode = ERROR_LABEL_UNREADABLE;
                    }
                }


                if (elementDescriptor->SPC_FED.IdValid) {
                    elementStatus->TargetId = 
                     elementDescriptor->SPC_FED.BusAddress;
                }
                if (elementDescriptor->SPC_FED.LunValid) {
                    elementStatus->Lun = elementDescriptor->SPC_FED.Lun;
                }



                // Get next descriptor.
                (ULONG_PTR)elementDescriptor += descriptorLength;

                // Advance to the next entry in the user 
                // buffer and element descriptor array.
                elementStatus += 1;
            }

            if (remainingElements > 0) {
                // Get next status page.
                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;
                elementType = statusPage->ElementType;

                // Point to decriptors.
                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = 
                   statusPage->ElementDescriptorLength[1];
                descriptorLength |= 
                   (statusPage->ElementDescriptorLength[0] << 8);

                // Determine the number of this element type reported.
                typeCount = statusPage->DescriptorByteCount[2];
                typeCount |= (statusPage->DescriptorByteCount[1] << 8);
                typeCount |= (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = 
                sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}



NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either 
    initialize all elements or the specified range of elements 
    using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    if (addressMapping->Initialized != TRUE) {
        status = ExaBuildAddressMapping(DeviceObject);
        if (status != STATUS_SUCCESS) {
            DebugPrint((1,
                       "Spctrmc: InitElementStatus: Build address map failed %x\n",
                       status));
            return status;
        }
    }

    // IES w/Range is only supported on Q215
    // 
    if (initElementStatus->ElementList.Element.ElementType != 
                                                 AllElements) {
        return STATUS_INVALID_DEVICE_REQUEST;
    } 

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    // All elements requested...
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;
    srb->DataTransferLength = 0;

    cdb->INIT_ELEMENT_STATUS.OperationCode = 
                                  SCSIOP_INIT_ELEMENT_STATUS;
    cdb->INIT_ELEMENT_STATUS.NoBarCode = 
        initElementStatus->BarCodeScan ? 0 : 1;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = 
                     sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the 
    robotic mechanism to the specified
    element address. Normally used to optimize moves or 
    exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    if ((setPosition->Destination.ElementType == ChangerKeypad) ||
        (setPosition->Destination.ElementType == ChangerDoor)   ||
        (setPosition->Destination.ElementType == ChangerMaxElement)) {
        return STATUS_INVALID_PARAMETER;
    }

    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.

    transport = (USHORT)(setPosition->Transport.ElementAddress);
    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);
    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    // Convert to device addresses.

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += 
     addressMapping->FirstElement[setPosition->Destination.ElementType];

    if (setPosition->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    // Build srb and cdb.

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    // Build device-specific addressing.

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] =
                    (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = 
                    (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = 
                    (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = 
                    (UCHAR)(destination & 0xFF);

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    None of the units support exchange medium.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }


    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // If the source or destination is an IEPORT,
    // do an allow before the move and a prevent after the move.
    // This works around the behaviour of the device whereby a PreventMediumRemoval
    // inhibits a MoveMedium to/from the IEPORT.
    //

    if ((moveMedium->Destination.ElementType == ChangerIEPort) ||
        (moveMedium->Source.ElementType == ChangerIEPort)) {

        //
        // Send an allow to clear the prevent for IEPORT extend/retract.
        //

        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = fdoExtension->TimeOutValue;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        cdb->MEDIA_REMOVAL.Prevent = 0;

        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
        status = STATUS_SUCCESS;
    }

    // Convert to device addresses.
    //
    transport += 
      addressMapping->FirstElement[ChangerTransport];
    source += 
      addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += 
      addressMapping->FirstElement[moveMedium->Destination.ElementType];

    if (moveMedium->Flip) {
        return STATUS_INVALID_PARAMETER;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;
    srb->DataTransferLength = 0;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = 
      (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = 
      (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = 
      (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = 
      (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = 
      (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = 
      (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }


    if ((moveMedium->Destination.ElementType == ChangerIEPort) ||
        (moveMedium->Source.ElementType == ChangerIEPort)) {

        //
        // Send a prevent to prevent further IEPORT extend/retract.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = fdoExtension->TimeOutValue;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        cdb->MEDIA_REMOVAL.Prevent = 1;

        ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
    }


    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    // there is no command on these libraries to home or reinit the 
    // changer mechanism

    return STATUS_INVALID_DEVICE_REQUEST;
}




NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ExaBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = SPC_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned,
                                sizeof(MODE_PARAMETER_HEADER) +
                                sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    if (!modeBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, sizeof(MODE_PARAMETER_HEADER) + 
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE));
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER) + 
                              sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.Dbd = 1;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = 
         (elementAddressPage->MediumTransportElementAddress[0] << 8) |
         elementAddressPage->MediumTransportElementAddress[1];

        addressMapping->FirstElement[ChangerDrive] = 
         (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
         elementAddressPage->FirstDataXFerElementAddress[1];

        addressMapping->FirstElement[ChangerIEPort] = 
         (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
         elementAddressPage->FirstIEPortElementAddress[1];

        addressMapping->FirstElement[ChangerSlot] = 
         (elementAddressPage->FirstStorageElementAddress[0] << 8) |
         elementAddressPage->FirstStorageElementAddress[1];

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = 
         elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= 
         (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = 
         elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= 
         (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = 
         elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= 
         (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = 
         elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= 
         (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 1;

        addressMapping->Initialized = TRUE;
    }


    // Determine the lowest element address for use with AllElements.
    //
    for (i = 0; i < ChangerDrive; i++) {
        if (addressMapping->FirstElement[i] < 
                         addressMapping->FirstElement[AllElements]) {
            addressMapping->FirstElement[AllElements] = 
                                     addressMapping->FirstElement[i];
        }
    }

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}



ULONG
MapExceptionCodes(
    IN PSPC_ED ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor 
    and creates the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
    UCHAR asc = ElementDescriptor->SPC_FED.AdditionalSenseCode;
    UCHAR asq = ElementDescriptor->SPC_FED.AddSenseCodeQualifier;
    ULONG exceptionCode = 0;

    if (asc == 0x85) {
        switch (asq) {
                case 0x33:
                    exceptionCode = ERROR_LABEL_UNREADABLE;
                    break;

                case 0x23:
                    exceptionCode = ERROR_DRIVE_NOT_INSTALLED;
                    break;

                default:
                    exceptionCode = ERROR_UNHANDLED_ERROR;

        }
    }

    if (asc == 0x83) {    
        switch (asq) {
                case 0x00:
                case 0x01:
                    exceptionCode = ERROR_LABEL_UNREADABLE;
                    break;

                default:
                    exceptionCode = ERROR_UNHANDLED_ERROR;
        }
    }

    return exceptionCode;
}



BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == SPC_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize the devicestatus in the device extension to
   // SPECTRA_DEVICE_PROBLEM_NONE. If the changer returns sense code
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set an appropriate
   // devicestatus.
   //
   changerData->DeviceStatus = SPECTRA_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "SPCTRAMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set selftest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) != SPECTRA_DEVICE_PROBLEM_NONE) {
         changerDeviceError->ChangerProblemType = DeviceProblemHardware;
   }
   
   ChangerClassFreePool(srb);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\starmatx\starmatx.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    starmatx.c

Abstract:

    This module contains device-specific routines for StarMatix Powerfile
    changer device.
 
Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "starmatx.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, ChangerExchangeMedium)
#pragma alloc_text(PAGE, ChangerGetElementStatus)
#pragma alloc_text(PAGE, ChangerGetParameters)
#pragma alloc_text(PAGE, ChangerGetProductData)
#pragma alloc_text(PAGE, ChangerGetStatus)
#pragma alloc_text(PAGE, ChangerInitialize)
#pragma alloc_text(PAGE, ChangerInitializeElementStatus)
#pragma alloc_text(PAGE, ChangerMoveMedium)
#pragma alloc_text(PAGE, ChangerPerformDiagnostics)
#pragma alloc_text(PAGE, ChangerQueryVolumeTags)
#pragma alloc_text(PAGE, ChangerReinitializeUnit)
#pragma alloc_text(PAGE, ChangerSetAccess)
#pragma alloc_text(PAGE, ChangerSetPosition)
#pragma alloc_text(PAGE, ElementOutOfRange)
#pragma alloc_text(PAGE, MapExceptionCodes)
#pragma alloc_text(PAGE, StarMatxBuildAddressMapping)
#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    MCD_INIT_DATA mcdInitData;

    RtlZeroMemory(&mcdInitData, sizeof(MCD_INIT_DATA));

    mcdInitData.InitDataSize = sizeof(MCD_INIT_DATA);

    mcdInitData.ChangerAdditionalExtensionSize = ChangerAdditionalExtensionSize;

    mcdInitData.ChangerError = ChangerError;

    mcdInitData.ChangerInitialize = ChangerInitialize;

    mcdInitData.ChangerPerformDiagnostics = ChangerPerformDiagnostics;

    mcdInitData.ChangerGetParameters = ChangerGetParameters;
    mcdInitData.ChangerGetStatus = ChangerGetStatus;
    mcdInitData.ChangerGetProductData = ChangerGetProductData;
    mcdInitData.ChangerSetAccess = ChangerSetAccess;
    mcdInitData.ChangerGetElementStatus = ChangerGetElementStatus;
    mcdInitData.ChangerInitializeElementStatus = ChangerInitializeElementStatus;
    mcdInitData.ChangerSetPosition = ChangerSetPosition;
    mcdInitData.ChangerExchangeMedium = ChangerExchangeMedium;
    mcdInitData.ChangerMoveMedium = ChangerMoveMedium;
    mcdInitData.ChangerReinitializeUnit = ChangerReinitializeUnit;
    mcdInitData.ChangerQueryVolumeTags = ChangerQueryVolumeTags;

    return ChangerClassInitialize(DriverObject, RegistryPath, 
                                  &mcdInitData);
}


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the StarMatix changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{
    return sizeof(CHANGER_DATA);
}


NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);


    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     &srb,
                                     dataBuffer,
                                     sizeof(INQUIRYDATA),
                                     FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    changerData->DriveID = 0;
    changerData->DriveType = POWERFILE_DVD;

    ChangerClassFreePool(dataBuffer);

    //
    // Build address mapping.
    //

    status = StarMatxBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    return STATUS_SUCCESS;
}



VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        DebugPrint((1,
                   "ChangerError: Sense Key - %x\n",
                   senseBuffer->SenseKey & 0x0f));
        DebugPrint((1,
                   "              AdditionalSenseCode - %x\n",
                   senseBuffer->AdditionalSenseCode));
        DebugPrint((1,
                   "              AdditionalSenseCodeQualifier - %x\n",
                   senseBuffer->AdditionalSenseCodeQualifier));
    } else {
        DebugPrint((1,
                   "ChangerError: Autosense not valid. SrbStatus %x\n",
                   Srb->SrbStatus));
    }

    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    StarMatix changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA              changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    bufferLength;
    PVOID    modeBuffer;
    PCDB     cdb;
    ULONG    i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    
    //
    // ISSUE : nramas 02/19/2001
    //         StarMatix firmware reports that there is one transport, but
    //         the device has none.
    //
    changerParameters->NumberTransportElements = 0;

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = 0;

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = STARMATX_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }
    }

    //
    // PowerFile C200 does not have a door
    //
    changerParameters->NumberOfDoors = 0;

    changerParameters->MagazineSize = 200;

    changerParameters->NumberCleanerSlots = 0;
    
    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  1;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_TRANSPORT_GEOMETRY_PAGE);

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //
    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (PCHAR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Determine if mc has 2-sided media.
    //
    changerParameters->Features0 = transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;

    //
    // Features based on manual, nothing programatic.
    //
    changerParameters->DriveCleanTimeout = 0;

    changerParameters->Features0 |= CHANGER_STATUS_NON_VOLATILE             |
                                    CHANGER_POSITION_TO_ELEMENT             |
                                    CHANGER_VOLUME_IDENTIFICATION           |
                                    CHANGER_VOLUME_REPLACE                  |
                                    CHANGER_VOLUME_ASSERT                   |
                                    CHANGER_VOLUME_SEARCH;

    changerParameters->PositionCapabilities = (CHANGER_TO_DRIVE | 
                                               CHANGER_TO_SLOT  | 
                                               CHANGER_TO_IEPORT);

    //
    // Free buffer.
    //
    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (PCHAR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    //
    // Determine all the move from and exchange from capabilities of this device.
    //

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? CHANGER_TO_DRIVE : 0;

    //
    // ISSUE: 03/03/2000 - nramas
    // Powerfile C200 is reporting that it can move media from IEPort to Drive & IEPort.
    // It also says it cannot move from slot to IEPort or Drive. This is reveresed. Till
    // we get a firmware fix for this, let's hard code that :
    //  Capable of moving media from Slot to IEPort & Drive
    //  Capable of moving media from IEPort to Slot
    //
    changerParameters->MoveFromSlot = (CHANGER_TO_DRIVE |
                                       CHANGER_TO_IEPORT);
    changerParameters->MoveFromIePort = CHANGER_TO_SLOT;

    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}


NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, changerData->InquiryData.ProductRevisionLevel, REVISION_LENGTH);

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}



NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the IEPort.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;

    //
    // SetAccess not supported by this changer
    //
    Irp->IoStatus.Information = 0;
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    ULONG    totalElements = 0;
    NTSTATUS status;
    PVOID    statusBuffer;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    if (elementType == AllElements) {

        ULONG i;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;
            totalElements += addressMapping->NumberOfElements[i];
        }

        if (totalElements != readElementStatus->ElementList.NumberOfElements) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) AllElements\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements));

            return STATUS_INVALID_PARAMETER;
        }

        //
        // Account for length of the descriptors expected for the drives.
        //


        if (readElementStatus->VolumeTagInfo) {

            length = sizeof(STARMATX_ELEMENT_DESCRIPTOR_PLUS) * totalElements;

            //
            // Add in header and status pages.
            //

            length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);

        } else {

            length = sizeof(STARMATX_ELEMENT_DESCRIPTOR) * totalElements;

            //
            // Add in header and status pages.
            //

            length += sizeof(ELEMENT_STATUS_HEADER) + (sizeof(ELEMENT_STATUS_PAGE) * statusPages);

        }

    } else {

        if (ElementOutOfRange(addressMapping, (USHORT)element->ElementAddress, elementType)) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Element out of range.\n"));

            return STATUS_ILLEGAL_ELEMENT_ADDRESS;
        }

        totalElements = readElementStatus->ElementList.NumberOfElements;
        if (totalElements > addressMapping->NumberOfElements[elementType]) {

            DebugPrint((1,
                       "ChangerGetElementStatus: Bogus number of elements in list (%x) actual (%x) for type (%x)\n",
                       totalElements,
                       readElementStatus->ElementList.NumberOfElements,
                       elementType));

            return STATUS_INVALID_PARAMETER;
        }

        if (readElementStatus->VolumeTagInfo) {

            length = (sizeof(STARMATX_ELEMENT_DESCRIPTOR_PLUS) * totalElements);

        } else {

            length = (sizeof(STARMATX_ELEMENT_DESCRIPTOR) * totalElements);
        }

        //
        // Add in length of header and status page.
        //

        length += sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);

    }

    DebugPrint((3,
               "ChangerGetElementStatus: Allocation Length %x, for %x elements of type %x\n",
               length,
               totalElements,
               elementType));

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        ChangerClassFreePool(statusBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = 200;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        //
        // These devices may not have the low address as 0.
        //

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(totalElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(totalElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    if (NT_SUCCESS(status)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG remainingElements;
        ULONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        ULONG i;
        ULONG descriptorLength;

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        if (remainingElements > totalElements ) {
            DebugPrint((1,
                       "ChangerGetElementStatus: Returned elements incorrect - %x\n",
                       remainingElements));

            ChangerClassFreePool(srb);
            ChangerClassFreePool(statusBuffer);

            return STATUS_IO_DEVICE_ERROR;
        }

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (PCHAR)statusPage = (PCHAR)statusHeader;
        (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (PCHAR)elementDescriptor = (PCHAR)statusPage;
        (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        typeCount /= descriptorLength;

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;

                if (tagInfo) {

                    PSTARMATX_ELEMENT_DESCRIPTOR_PLUS tmpDescriptor =
                                                            (PSTARMATX_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor;

                    if (statusPage->PVolTag) {

                        RtlZeroMemory(elementStatus->PrimaryVolumeID, MAX_VOLUME_ID_SIZE);
                        RtlMoveMemory(elementStatus->PrimaryVolumeID, 
                                      (PUCHAR)&(tmpDescriptor->PrimaryVolumeTag), 
                                      sizeof(SCSI_VOLUME_TAG));

                        elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                    }
                    if (statusPage->AVolTag) {

                        RtlZeroMemory(elementStatus->AlternateVolumeID, MAX_VOLUME_ID_SIZE);
                        RtlMoveMemory(elementStatus->AlternateVolumeID, 
                                      (PUCHAR)&(tmpDescriptor->AlternateVolumeTag), 
                                      sizeof(SCSI_VOLUME_TAG));

                        elementStatus->Flags |= ELEMENT_STATUS_AVOLTAG;
                    }


                    if (elementDescriptor->IdValid) {
                        elementStatus->Flags |= ELEMENT_STATUS_ID_VALID;
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }

                    if (elementDescriptor->LunValid) {
                        elementStatus->Flags |= ELEMENT_STATUS_LUN_VALID;
                        elementStatus->Lun = elementDescriptor->Lun;
                    }

                    //
                    // Source address
                    //

                    if (elementDescriptor->SValid) {

                        ULONG  j;
                        USHORT tmpAddress;


                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                        elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                    }

                } else {

                    //
                    // Source address
                    //

                    if (elementDescriptor->SValid) {
                        ULONG  j;
                        USHORT tmpAddress;


                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];
                        elementStatus->Flags |= ELEMENT_STATUS_SVALID;
                    }

                    if (elementDescriptor->IdValid) {
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }
                    if (elementDescriptor->LunValid) {
                        elementStatus->Lun = elementDescriptor->Lun;
                    }
                }

                //
                // Build Flags field.
                //

                elementStatus->Flags |= elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Exception << 2);
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);

                //
                // Map any exceptions reported directly.
                // If there is volume info returned ensure that it's not all spaces
                // as this indicates that the label is missing or unreadable.
                //

                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {

                    //
                    // Map the exception.
                    //

                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                } else if (elementStatus->Flags & ELEMENT_STATUS_PVOLTAG) {

                    ULONG index;

                    //
                    // Ensure that the tag info isn't all spaces. This indicates an error.
                    //

                    for (index = 0; index < MAX_VOLUME_ID_SIZE; index++) {
                        if (elementStatus->PrimaryVolumeID[index] != ' ') {
                            break;
                        }
                    }

                    //
                    // Determine if the volume id was all spaces. Do an extra check to see if media is
                    // actually present, for the unit will set the PVOLTAG flag whether media is present or not.
                    //

                    if ((index == MAX_VOLUME_ID_SIZE) && (elementStatus->Flags & ELEMENT_STATUS_FULL)) {

                        DebugPrint((1,
                                   "Starmatx.GetElementStatus: Setting exception to LABEL_UNREADABLE\n"));

                        elementStatus->Flags &= ~ELEMENT_STATUS_PVOLTAG;
                        elementStatus->Flags |= ELEMENT_STATUS_EXCEPT;
                        elementStatus->ExceptionCode = ERROR_LABEL_UNREADABLE;
                    }
                }

                //
                // Get next descriptor.
                //

                (PCHAR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                elementStatus += 1;

            }

            if (remainingElements) {

                //
                // Get next status page.
                //

                (PCHAR)statusPage = (PCHAR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                typeCount /= descriptorLength;

            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * totalElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue * 10;
        srb->DataTransferLength = 0;

    } else {

        ChangerClassFreePool(srb);
        return STATUS_INVALID_PARAMETER;

    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // For now do nothing
    //
    Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    return STATUS_SUCCESS;

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    destination += addressMapping->FirstElement[setPosition->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;


    srb->DataTransferLength = 0;
    srb->TimeOutValue = 200;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
   //
   // Not supported by this changer.
   // 
   return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport;
    USHORT source;
    USHORT destination;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    LONG                lockValue = 0;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     NULL,
                                     0,
                                     FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    } else {
        DebugPrint((1,
                   "MoveMedium: Status of Move %x\n",
                   status));
    }

    ChangerClassFreePool(srb);
    return status;
}


NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    //
    // Reinitialize not supported by this changer
    //
    Irp->IoStatus.Information = 0;
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
   PCHANGER_SEND_VOLUME_TAG_INFORMATION volTagInfo = Irp->AssociatedIrp.SystemBuffer;
   PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
   PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
   PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
   PCHANGER_ELEMENT    element = &volTagInfo->StartingElement;
   PSCSI_REQUEST_BLOCK srb;
   PVOID    tagBuffer;
   PVOID    statusBuffer;
   PCDB     cdb;
   NTSTATUS status;

   switch (volTagInfo->ActionCode) {
        case SEARCH_ALL      :
        case SEARCH_PRIMARY  :
        case SEARCH_ALTERNATE:
        case SEARCH_ALL_NO_SEQ:
        case SEARCH_PRI_NO_SEQ:
        case SEARCH_ALT_NO_SEQ:
        case UNDEFINE_PRIMARY:
        case UNDEFINE_ALTERNATE:
        case ASSERT_PRIMARY:
        case ASSERT_ALTERNATE:
             break;

        case REPLACE_PRIMARY:
        case REPLACE_ALTERNATE:

            //
            // Ensure that only one element is being specified.
            //

            if (element->ElementType == AllElements) {

                DebugPrint((1,
                           "QueryVolumeTags: Attempting REPLACE on AllElements\n"));

                return STATUS_INVALID_DEVICE_REQUEST;
            }
            break;
        default:

            DebugPrint((1,
                       "QueryVolumeTags: Unsupported operation. ActionCode %x\n",
                       volTagInfo->ActionCode));

            return STATUS_INVALID_DEVICE_REQUEST;
   }

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    tagBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, MAX_VOLUME_TEMPLATE_SIZE);

    if (!srb || !tagBuffer) {

        if (srb) {
            ChangerClassFreePool(srb);
        }
        if (tagBuffer) {
            ChangerClassFreePool(tagBuffer);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    RtlZeroMemory(tagBuffer, MAX_VOLUME_TEMPLATE_SIZE);

    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataTransferLength = MAX_VOLUME_TEMPLATE_SIZE;

    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->SEND_VOLUME_TAG.OperationCode = SCSIOP_SEND_VOLUME_TAG;


    if ((volTagInfo->ActionCode == SEARCH_ALL)        ||
        (volTagInfo->ActionCode == SEARCH_PRIMARY)    ||
        (volTagInfo->ActionCode == SEARCH_ALTERNATE)  ||
        (volTagInfo->ActionCode == SEARCH_ALL_NO_SEQ) ||
        (volTagInfo->ActionCode == SEARCH_PRI_NO_SEQ) ||
        (volTagInfo->ActionCode == SEARCH_ALT_NO_SEQ)) {

        //
        // This is reserved for all other action codes.
        //

        cdb->SEND_VOLUME_TAG.ElementType = (UCHAR)element->ElementType;

        cdb->SEND_VOLUME_TAG.ParameterListLength[0] = 0;
        cdb->SEND_VOLUME_TAG.ParameterListLength[1] = MAX_VOLUME_TEMPLATE_SIZE;

        //
        // Load buffer with template.
        //

        RtlMoveMemory(tagBuffer, volTagInfo->VolumeIDTemplate, MAX_VOLUME_TEMPLATE_SIZE);


    } else if ((volTagInfo->ActionCode == UNDEFINE_PRIMARY)   ||
               (volTagInfo->ActionCode == UNDEFINE_ALTERNATE)) {

        cdb->SEND_VOLUME_TAG.ParameterListLength[0] = 0;
        cdb->SEND_VOLUME_TAG.ParameterListLength[1] = 0;

    } else if ((volTagInfo->ActionCode == REPLACE_PRIMARY)   ||
               (volTagInfo->ActionCode == REPLACE_ALTERNATE) ||
               (volTagInfo->ActionCode == ASSERT_PRIMARY)    ||
               (volTagInfo->ActionCode == ASSERT_ALTERNATE)) {


        cdb->SEND_VOLUME_TAG.ParameterListLength[0] = 0;
        cdb->SEND_VOLUME_TAG.ParameterListLength[1] = MAX_VOLUME_TEMPLATE_SIZE;

        //
        // Load buffer with template.
        //

        RtlMoveMemory(tagBuffer, volTagInfo->VolumeIDTemplate, MAX_VOLUME_TEMPLATE_SIZE);
    }


    if (element->ElementType == AllElements) {
        cdb->SEND_VOLUME_TAG.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->SEND_VOLUME_TAG.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {
        cdb->SEND_VOLUME_TAG.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
        cdb->SEND_VOLUME_TAG.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

    }

    cdb->SEND_VOLUME_TAG.ActionCode = (UCHAR)volTagInfo->ActionCode;

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     tagBuffer,
                                     MAX_VOLUME_TEMPLATE_SIZE,
                                     TRUE);

    ChangerClassFreePool(tagBuffer);

    if (NT_SUCCESS(status)) {

        PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
        PREAD_ELEMENT_ADDRESS_INFO readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;
        ULONG returnElements = irpStack->Parameters.DeviceIoControl.OutputBufferLength / sizeof(READ_ELEMENT_ADDRESS_INFO);
        ULONG requestLength;
        PVOID statusBuffer;

        //
        // Size of buffer returned is based on the size of the user buffer. 
        // If it's incorrectly sized, the IoStatus.Information will be updated
        // to indicate how large it should really be.
        //

        requestLength = sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE) +
                              (sizeof(STARMATX_ELEMENT_DESCRIPTOR_PLUS) * returnElements);

        statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, requestLength);
        if (!statusBuffer) {
            ChangerClassFreePool(srb);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(statusBuffer, requestLength);

        //
        // Build read volume element command.
        //

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB12GENERIC_LENGTH;
        srb->DataTransferLength = requestLength;

        srb->TimeOutValue = fdoExtension->TimeOutValue;

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.OperationCode = SCSIOP_REQUEST_VOL_ELEMENT;
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.ElementType = (UCHAR)element->ElementType;

        if (element->ElementType == AllElements) {
            cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[0] =
                (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);
            cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[1] =
                (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

        } else {
            cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[0] =
                (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
            cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.StartingElementAddress[1] =
                (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
        }

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.NumberElements[0] = (UCHAR)(returnElements >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.NumberElements[1] = (UCHAR)(returnElements & 0xFF);

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.VolTag = 1;

        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.AllocationLength[0] = (UCHAR)(requestLength >> 8);
        cdb->REQUEST_VOLUME_ELEMENT_ADDRESS.AllocationLength[1] = (UCHAR)(requestLength & 0xFF);


        status = ChangerClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             statusBuffer,
                                             requestLength,
                                             TRUE);


        if ((status == STATUS_SUCCESS) || (status == STATUS_DATA_OVERRUN)) {

            PREAD_ELEMENT_ADDRESS_INFO readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;
            PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
            PELEMENT_STATUS_PAGE   statusPage;
            PCHANGER_ELEMENT_STATUS elementStatus;
            PELEMENT_DESCRIPTOR elementDescriptor;
            ULONG i;
            ULONG descriptorLength;
            ULONG numberElements;
            ULONG dataTransferLength = srb->DataTransferLength;

            //
            // Make it success.
            //

            status = STATUS_SUCCESS;

            //
            // Determine if ANY matches were found.
            //

            if (dataTransferLength <= sizeof(ELEMENT_STATUS_HEADER)) {
                numberElements = 0;
            } else {

                //
                // Subtract out header and page info.
                //

                dataTransferLength -= sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);
                numberElements = dataTransferLength / sizeof(STARMATX_ELEMENT_DESCRIPTOR_PLUS);

            }

            DebugPrint((1,
                       "QueryVolumeTags: Matches found - %x\n",
                       numberElements));

            //
            // Update IoStatus.Information to indicate the correct buffer size.
            // Account for the fact that READ_ELEMENT_ADDRESS_INFO is declared
            // with a one-element array of CHANGER_ELEMENT_STATUS.
            //

            Irp->IoStatus.Information = sizeof(READ_ELEMENT_ADDRESS_INFO) +
                                        ((numberElements - 1) *
                                         sizeof(CHANGER_ELEMENT_STATUS));

            //
            // Fill in user buffer.
            //

            readElementAddressInfo = Irp->AssociatedIrp.SystemBuffer;

            readElementAddressInfo->NumberOfElements = numberElements;

            if (numberElements) {

                ELEMENT_TYPE        elementType;

                //
                // The buffer is composed of a header, status page, and element descriptors.
                // Point each element to it's respective place in the buffer.
                //


                (PCHAR)statusPage = (PCHAR)statusHeader;
                (PCHAR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

                elementType = statusPage->ElementType;

                (PCHAR)elementDescriptor = (PCHAR)statusPage;
                (PCHAR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                elementStatus = &readElementAddressInfo->ElementStatus[0];

                //
                // Set values for each element descriptor.
                //

                for (i = 0; i < numberElements; i++ ) {

                    PSTARMATX_ELEMENT_DESCRIPTOR_PLUS tmpDescriptor =
                                                            (PSTARMATX_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor;

                    //
                    // Get the address for this element.
                    //

                    elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                    elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                    //
                    // Account for address mapping.
                    //

                    elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                    //
                    // Set the element type.
                    //

                    elementStatus->Element.ElementType = elementType;
                    elementStatus->Flags = 0;

                    //
                    // Source address
                    //

                    if (elementDescriptor->SValid) {

                        ULONG  j;
                        USHORT tmpAddress;


                        //
                        // Source address is valid. Determine the device specific address.
                        //

                        tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                        tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                        //
                        // Now convert to 0-based values.
                        //

                        for (j = 1; j <= ChangerDrive; j++) {
                            if (addressMapping->FirstElement[j] <= tmpAddress) {
                                if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                    elementStatus->SrcElementAddress.ElementType = j;
                                    break;
                                }
                            }
                        }

                        elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                        elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                    }


                    //
                    // Build Flags field.
                    //

                    elementStatus->Flags |= elementDescriptor->Full;
                    elementStatus->Flags |= (elementDescriptor->Exception << 2);
                    elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                    elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                    elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                    elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                    elementStatus->Flags |= (elementDescriptor->Invert << 22);
                    elementStatus->Flags |= (elementDescriptor->SValid << 23);

                    //
                    // Map any exceptions reported directly.
                    // If there is volume info returned ensure that it's not all spaces
                    // as this indicates that the label is missing or unreadable.
                    //

                    if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {

                        //
                        // Map the exception.
                        //

                        elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                    }

                    if (elementDescriptor->IdValid) {
                        elementStatus->Flags |= ELEMENT_STATUS_ID_VALID;
                        elementStatus->TargetId = elementDescriptor->BusAddress;
                    }

                    if (elementDescriptor->LunValid) {
                        elementStatus->Flags |= ELEMENT_STATUS_LUN_VALID;
                        elementStatus->Lun = elementDescriptor->Lun;
                    }

                    if (statusPage->PVolTag) {

                        RtlZeroMemory(elementStatus->PrimaryVolumeID, MAX_VOLUME_ID_SIZE);
                        RtlMoveMemory(elementStatus->PrimaryVolumeID, 
                                      (PUCHAR)&(tmpDescriptor->PrimaryVolumeTag), 
                                      sizeof(SCSI_VOLUME_TAG));

                        elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                    }
                    if (statusPage->AVolTag) {
                        RtlZeroMemory(elementStatus->AlternateVolumeID, MAX_VOLUME_ID_SIZE);
                        RtlMoveMemory(elementStatus->AlternateVolumeID, 
                                      (PUCHAR)&(tmpDescriptor->AlternateVolumeTag),
                                      sizeof(SCSI_VOLUME_TAG));

                        elementStatus->Flags |= ELEMENT_STATUS_AVOLTAG;
                    }

                    //
                    // Advance to the next entry in the user buffer and element descriptor array.
                    //

                    elementStatus += 1;
                    (PCHAR)elementDescriptor += descriptorLength;
                }
            }
        } else {
            DebugPrint((1,
                       "QueryVolumeTags: RequestElementAddress failed. %x\n",
                       status));
        }

        ChangerClassFreePool(statusBuffer);

    } else {
        DebugPrint((1,
                   "QueryVolumeTags: Send Volume Tag failed. %x\n",
                   status));
    }
    if (srb) {
        ChangerClassFreePool(srb);
    }
    return status;
}


NTSTATUS
StarMatxBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds
    an array of element addresses. These are used to translate between the 
    device-specific addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    ULONG                  bufferLength;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);


    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = STARMATX_NO_ELEMENT;
    }

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ChangerClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);

    elementAddressPage = modeBuffer;
    (PCHAR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];

        //
        // Determine lowest address of all elements.
        //


        addressMapping->LowAddress = STARMATX_NO_ELEMENT;
        for (i = 0; i <= ChangerDrive; i++) {
            if (addressMapping->LowAddress > addressMapping->FirstElement[i]) {
                addressMapping->LowAddress = addressMapping->FirstElement[i];
            }
        }

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 0;

        addressMapping->Initialized = TRUE;

    }

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}


ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{

    ULONG exceptionCode = 0;
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;


    switch (asc) {
        case 0x0:
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    DebugPrint((1,
               "StarMatx.MapExceptionCode: ASC %x, ASCQ %x, exceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;

}


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == STARMATX_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{
    changerDeviceError->ChangerProblemType = DeviceProblemNone;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\stkmc\stkmc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    stkmc.c

Abstract:

    This module contains device-specific routines for:
        - STK 9710 and 9714 DLT Libraries

Author:

    chuckp (Chuck Park)

Environment:

    kernel mode only

Revision History:


--*/

#include "ntddk.h"
#include "mcd.h"
#include "stkmc.h"


#define STK_DLT 1

#define STK971x 1

//
// Diagnostic test related defines
//
#define STKMC_DEVICE_PROBLEM_NONE   0x00
#define STKMC_HW_ERROR              0x01

typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Drive type, dlt.
    //

    ULONG DriveType;

    //
    // Drive Id. Based on inquiry.
    //

    ULONG DriveID;

    //
    // Device Status after diagnostics completes
    //
    ULONG DeviceStatus;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

#if defined(_WIN64)

    //
    // Force PVOID alignment of class extension
    //

    ULONG Reserved;

#endif
} CHANGER_DATA, *PCHANGER_DATA;



NTSTATUS
StkBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );


BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );


ULONG
ChangerAdditionalExtensionSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the additional device extension size
    needed by the exabyte changers.

Arguments:


Return Value:

    Size, in bytes.

--*/

{

    return sizeof(CHANGER_DATA);
}



NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA  changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    NTSTATUS       status;
    PINQUIRYDATA   dataBuffer;
    PCDB           cdb;
    ULONG          length;
    SCSI_REQUEST_BLOCK srb;

    changerData->Size = sizeof(CHANGER_DATA);


    //
    // Get inquiry data.
    //

    dataBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, sizeof(INQUIRYDATA));
    if (!dataBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now get the full inquiry information for the device.
    //

    RtlZeroMemory(&srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Set timeout value.
    //

    srb.TimeOutValue = 10;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb->CDB6INQUIRY.AllocationLength = sizeof(INQUIRYDATA);

    status = ClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         dataBuffer,
                                         sizeof(INQUIRYDATA),
                                         FALSE);

    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SUCCESS ||
        SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

        //
        // Updated the length actually transfered.
        //

        length = dataBuffer->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

        if (length > srb.DataTransferLength) {
            length = srb.DataTransferLength;
        }


        RtlMoveMemory(&changerData->InquiryData, dataBuffer, length);

    }

    //
    // Determine changer type.
    //

    if (RtlCompareMemory(dataBuffer->ProductId,"9710", 4) == 4) {
        changerData->DriveType = STK_DLT;
        changerData->DriveID = STK971x;
    } else if (RtlCompareMemory(dataBuffer->ProductId,"9714", 4) == 4) {
        changerData->DriveType = STK_DLT;
        changerData->DriveID = STK971x;
    } else if (RtlCompareMemory(dataBuffer->ProductId,"A4845A", 6) == 6) {
        changerData->DriveType = STK_DLT;
        changerData->DriveID = STK971x;
    } else if (RtlCompareMemory(dataBuffer->ProductId,"A4846A", 6) == 6) {
        changerData->DriveType = STK_DLT;
        changerData->DriveID = STK971x;
    }

    ChangerClassFreePool(dataBuffer);

    //
    // Build address mapping.
    //

    status = StkBuildAddressMapping(DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    return STATUS_SUCCESS;
}


BOOLEAN
ChangerVerifyInquiry(
    PINQUIRYDATA InquiryData
    )
/*++

Routine Description:

    This routine determines whether the device specified in InquiryData
    should be supported by this module.

Arguments:

    InquiryData - Pointer to inquiry data.

Return Value:

    TRUE - If this is a supported device.

--*/

{
    if (RtlCompareMemory(InquiryData->VendorId,"STK",3) == 3) {
        if (RtlCompareMemory(InquiryData->ProductId,"9710",4) == 4) {
            return TRUE;
        }
        if (RtlCompareMemory(InquiryData->ProductId,"9714",4) == 4) {
            return TRUE;
        }
    }

    if (RtlCompareMemory(InquiryData->VendorId,"HP",2) == 2) {
        if (RtlCompareMemory(InquiryData->ProductId,"A4845A",6) == 6) {
            return TRUE;
        }
        if (RtlCompareMemory(InquiryData->ProductId,"A4846A",6) == 6) {
            return TRUE;
        }
    }


    return FALSE;
}



VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

    This routine executes any device-specific error handling needed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {

        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_NOT_READY:

            if (senseBuffer->AdditionalSenseCode == 0x04) {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case 0x3:

                        *Retry = FALSE;
                        *Status = STATUS_DEVICE_DOOR_OPEN;
                        break;
                }
            }

            break;

        case SCSI_SENSE_HARDWARE_ERROR: {
           changerData->DeviceStatus = STKMC_HW_ERROR;
           break;
        }

        default:
            break;
        }
    }

    return;
}

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines and returns the "drive parameters" of the
    exabyte changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING   addressMapping = &(changerData->AddressMapping);
    PSCSI_REQUEST_BLOCK        srb;
    PGET_CHANGER_PARAMETERS    changerParameters;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PMODE_TRANSPORT_GEOMETRY_PAGE transportGeometryPage;
    PMODE_DEVICE_CAPABILITIES_PAGE capabilitiesPage;
    NTSTATUS status;
    ULONG    bufferLength;
    PVOID    modeBuffer;
    PCDB     cdb;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (srb == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    cdb->MODE_SENSE.Dbd = 1;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Fill in values.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);
    changerParameters->NumberTransportElements = elementAddressPage->NumberTransportElements[1];
    changerParameters->NumberTransportElements |= (elementAddressPage->NumberTransportElements[0] << 8);

    changerParameters->NumberStorageElements = elementAddressPage->NumberStorageElements[1];
    changerParameters->NumberStorageElements |= (elementAddressPage->NumberStorageElements[0] << 8);

    changerParameters->NumberIEElements = elementAddressPage->NumberIEPortElements[1];
    changerParameters->NumberIEElements |= (elementAddressPage->NumberIEPortElements[0] << 8);

    changerParameters->NumberDataTransferElements = elementAddressPage->NumberDataXFerElements[1];
    changerParameters->NumberDataTransferElements |= (elementAddressPage->NumberDataXFerElements[0] << 8);


    if (!addressMapping->Initialized) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        addressMapping->FirstElement[ChangerDoor] = 0;

        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = elementAddressPage->MediumTransportElementAddress[1];
        if (elementAddressPage->FirstDataXFerElementAddress[1] < addressMapping->LowAddress) {
            addressMapping->LowAddress = elementAddressPage->FirstDataXFerElementAddress[1];
        }
    }
    DebugPrint((1,"GetParams: First addresses\n"));
    DebugPrint((1,"Transport: %x\n",
                elementAddressPage->MediumTransportElementAddress[1]));
    DebugPrint((1,"Slot: %x\n",
                elementAddressPage->FirstStorageElementAddress[1]));
    DebugPrint((1,"Ieport: %x\n",
                elementAddressPage->FirstIEPortElementAddress[1]));
    DebugPrint((1,"Drive: %x\n",
                elementAddressPage->FirstDataXFerElementAddress[1]));
    DebugPrint((1,"LowAddress: %x\n",
                addressMapping->LowAddress));

    changerParameters->NumberOfDoors = 1;
    changerParameters->NumberCleanerSlots = 0;
    changerParameters->FirstSlotNumber = 0;
    changerParameters->MagazineSize = 0;
    changerParameters->FirstDriveNumber =  0;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;
    changerParameters->DriveCleanTimeout = 600;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_PAGE_TRANSPORT_GEOMETRY);
    cdb->MODE_SENSE.Dbd = 1;
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_TRANSPORT_GEOMETRY;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    transportGeometryPage = modeBuffer;
    (ULONG_PTR)transportGeometryPage += sizeof(MODE_PARAMETER_HEADER);

        
    // initialize Features1  
        changerParameters->Features1 = CHANGER_IEPORT_USER_CONTROL_OPEN |
                                   CHANGER_IEPORT_USER_CONTROL_CLOSE ;

    //
    // Determine if mc has 2-sided media.
    //

    changerParameters->Features0 = transportGeometryPage->Flip ? CHANGER_MEDIUM_FLIP : 0;

    //
    // Features based on manual, nothing programatic.
    //

    changerParameters->Features0 |= CHANGER_BAR_CODE_SCANNER_INSTALLED;
    changerParameters->Features0 |= CHANGER_INIT_ELEM_STAT_WITH_RANGE;
    changerParameters->Features0 |= CHANGER_LOCK_UNLOCK;
    changerParameters->Features0 |= CHANGER_DRIVE_CLEANING_REQUIRED;
    changerParameters->Features0 |= CHANGER_PREDISMOUNT_EJECT_REQUIRED;
    changerParameters->Features0 |= CHANGER_POSITION_TO_ELEMENT;

        // Only the IEPORT can be locked and unlocked
    changerParameters->LockUnlockCapabilities = LOCK_UNLOCK_IEPORT;

    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);

    //
    // build transport geometry mode sense.
    //


    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_DEVICE_CAPABILITIES_PAGE);
    cdb->MODE_SENSE.Dbd = 1;
    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        ChangerClassFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_DEVICE_CAPABILITIES;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (!NT_SUCCESS(status)) {
        ChangerClassFreePool(srb);
        ChangerClassFreePool(modeBuffer);
        return status;
    }

    //
    // Get the systembuffer and by-pass the mode header for the mode sense data.
    //

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    capabilitiesPage = modeBuffer;
    (ULONG_PTR)capabilitiesPage += sizeof(MODE_PARAMETER_HEADER);

    //
    // Fill in values in Features that are contained in this page.
    //

    changerParameters->Features0 |= capabilitiesPage->MediumTransport ? CHANGER_STORAGE_DRIVE : 0;
    changerParameters->Features0 |= capabilitiesPage->StorageLocation ? CHANGER_STORAGE_SLOT : 0;
    changerParameters->Features0 |= capabilitiesPage->IEPort ? CHANGER_STORAGE_IEPORT : 0;
    changerParameters->Features0 |= capabilitiesPage->DataXFer ? CHANGER_STORAGE_DRIVE : 0;

    changerParameters->MoveFromTransport = capabilitiesPage->MTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromTransport |= capabilitiesPage->MTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromSlot = capabilitiesPage->STtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->MoveFromSlot |= capabilitiesPage->STtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->MoveFromIePort = capabilitiesPage->IEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoST ? CHANGER_TO_SLOT : 0;
    // cannot move from IEPORT to IEPORT on the 9710 !
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoIE ? 0 : 0;
    changerParameters->MoveFromIePort |= capabilitiesPage->IEtoDT ? CHANGER_TO_DRIVE : 0;
        
    changerParameters->MoveFromDrive = capabilitiesPage->DTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoIE ? CHANGER_TO_IEPORT : 0;
    // STK does not support drive to drive exchange
    changerParameters->MoveFromDrive |= capabilitiesPage->DTtoDT ? 0 : 0;

    changerParameters->ExchangeFromTransport = capabilitiesPage->XMTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromTransport |= capabilitiesPage->XMTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromSlot = capabilitiesPage->XSTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoIE ? CHANGER_TO_IEPORT : 0;
    changerParameters->ExchangeFromSlot |= capabilitiesPage->XSTtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromIePort = capabilitiesPage->XIEtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoST ? CHANGER_TO_SLOT : 0;
    // cannot exchange from IEPORT to IEPORT on the STK !
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoIE ? 0 : 0;
    changerParameters->ExchangeFromIePort |= capabilitiesPage->XIEtoDT ? CHANGER_TO_DRIVE : 0;

    changerParameters->ExchangeFromDrive = capabilitiesPage->XDTtoMT ? CHANGER_TO_TRANSPORT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoST ? CHANGER_TO_SLOT : 0;
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoIE ? CHANGER_TO_IEPORT : 0;
    // STK does not support drive to drive exchange
    changerParameters->ExchangeFromDrive |= capabilitiesPage->XDTtoDT ? 0 : 0;


        
        // legal Position capabilities... 
        changerParameters->PositionCapabilities = 
                        CHANGER_TO_SLOT | 
                        CHANGER_TO_IEPORT | 
                        CHANGER_TO_DRIVE;
                
    ChangerClassFreePool(srb);
    ChangerClassFreePool(modeBuffer);

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);

    return STATUS_SUCCESS;
}



NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the status of the medium changer as determined through a TUR.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    NTSTATUS status;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    //
    // Build TUR.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    //
    // Send SCSI command (CDB) to device
    //

    status = ClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns fields from the inquiry data useful for
    identifying the particular device.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_PRODUCT_DATA productData = Irp->AssociatedIrp.SystemBuffer;

    //
    // Copy cached inquiry data fields into the system buffer.
    //
    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA)); 
    RtlMoveMemory(productData->VendorId, 
        changerData->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, 
        changerData->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, 
        changerData->InquiryData.ProductRevisionLevel, 4);
    RtlMoveMemory(productData->SerialNumber, "", 1);

    //
    // Indicate drive type and whether media is two-sided.
    //

    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}




NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the state of the Door, Keypad and IEPort.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = 
                                                &(changerData->AddressMapping);
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    NTSTATUS            status = STATUS_SUCCESS;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;

    // IEPORT is the only element that can really be locked
    // and unlocked, but since there is only one locking 
    // SCSI command for this device, funnel all requests to lock
    // any element into this Prevent/Allow. 

 
    // for the STK 9710 and 9714 units, only do prevent/allow
    // on IEPORTS. Doors have no locks and neither do keypads

    if (setAccess->Element.ElementType != ChangerIEPort) {
                return STATUS_INVALID_DEVICE_REQUEST;
    } else { 

        srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
        if (!srb) {
           return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        cdb = (PCDB)srb->Cdb;
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->DataTransferLength = 0;
        srb->TimeOutValue = 10;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

        if ((controlOperation == LOCK_ELEMENT) || 
            (controlOperation == RETRACT_IEPORT)) {
            cdb->MEDIA_REMOVAL.Prevent = 1;
        } else if ((controlOperation == UNLOCK_ELEMENT) || 
                   (controlOperation == EXTEND_IEPORT)){
            cdb->MEDIA_REMOVAL.Prevent = 0;
        } else {
            ChangerClassFreePool(srb);
            return STATUS_SUCCESS;
        }
 
        //
        // Issue the srb.
        //
        status = ClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
        ChangerClassFreePool(srb);
        if (NT_SUCCESS(status)) {
            Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
        }

        return status;
    }
}





NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine builds and issues a read element status command for either all elements or the
    specified element type. The buffer returned is used to build the user buffer.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA     changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING     addressMapping = &(changerData->AddressMapping);
    PCHANGER_READ_ELEMENT_STATUS readElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PCHANGER_ELEMENT_STATUS      elementStatus;
    PCHANGER_ELEMENT    element;
    ELEMENT_TYPE        elementType;
    PSCSI_REQUEST_BLOCK srb;
    PCDB     cdb;
    ULONG    length;
    ULONG    statusPages;
    NTSTATUS status;
    PVOID    statusBuffer;

    //
    // Determine the element type.
    //

    elementType = readElementStatus->ElementList.Element.ElementType;
    element = &readElementStatus->ElementList.Element;

    if (elementType == AllElements) 
    {

        ULONG i;

        statusPages = 0;

        //
        // Run through and determine number of statuspages, based on
        // whether this device claims it supports an element type.
        // As everything past ChangerDrive is artificial, stop there.
        //

        for (i = 0; i <= ChangerDrive; i++) {
            statusPages += (addressMapping->NumberOfElements[i]) ? 1 : 0;
        }

        //
        // Account for length of the descriptors expected for the drives.
        //


        if (readElementStatus->VolumeTagInfo) 
          {
            length = sizeof(STK_ELEMENT_DESCRIPTOR_PLUS) *
                            addressMapping->NumberOfElements[ChangerDrive];
            //
            // Add in length of descriptors for transport and IEPort (if applicable).
            //
            length += sizeof(STK_ELEMENT_DESCRIPTOR_PLUS) *
                          (readElementStatus->ElementList.NumberOfElements -
                          (addressMapping->NumberOfElements[ChangerDrive] +
                           addressMapping->NumberOfElements[ChangerSlot]));
            //
            // Add in length for slots.
            //
            length += sizeof(STK_ELEMENT_DESCRIPTOR_PLUS) * 
                        addressMapping->NumberOfElements[ChangerSlot];

            //
            // Add in header and status pages.
            //
            length += sizeof(ELEMENT_STATUS_HEADER) + 
                           (sizeof(ELEMENT_STATUS_PAGE) * statusPages);
        } 
        else  // no voltag requested... 
        {
                length = sizeof(STK_ELEMENT_DESCRIPTOR) *
                            addressMapping->NumberOfElements[ChangerDrive];
                //
            // Add in length of descriptors for transport and IEPort (if applicable).
            //
            length += sizeof(STK_ELEMENT_DESCRIPTOR) *
                          (readElementStatus->ElementList.NumberOfElements -
                          (addressMapping->NumberOfElements[ChangerDrive] +
                           addressMapping->NumberOfElements[ChangerSlot]));
            //
            // Add in length for slots.
            //
            length += sizeof(STK_ELEMENT_DESCRIPTOR) * 
                        addressMapping->NumberOfElements[ChangerSlot];

            //
            // Add in header and status pages.
            //
            length += sizeof(ELEMENT_STATUS_HEADER) + 
                           (sizeof(ELEMENT_STATUS_PAGE) * statusPages);
        }
    } 
    else // not all elements... 
    {
        if (readElementStatus->VolumeTagInfo) 
          {
          length = (sizeof(STK_ELEMENT_DESCRIPTOR_PLUS) * 
                                readElementStatus->ElementList.NumberOfElements);
        }
          else // not all elements and no voltag... 
        {
          length = (sizeof(STK_ELEMENT_DESCRIPTOR) * 
                        readElementStatus->ElementList.NumberOfElements);
          }

        //
        // Add in length of header and status page.
        //
        length += sizeof(ELEMENT_STATUS_HEADER) + sizeof(ELEMENT_STATUS_PAGE);
    }

    statusBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, length);

    if (!statusBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(statusBuffer, length);

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->DataBuffer = statusBuffer;
    srb->DataTransferLength = length;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->READ_ELEMENT_STATUS.OperationCode = SCSIOP_READ_ELEMENT_STATUS;
    cdb->READ_ELEMENT_STATUS.ElementType = (UCHAR)elementType;
    cdb->READ_ELEMENT_STATUS.VolTag = readElementStatus->VolumeTagInfo;

    //
    // Fill in element addressing info based on the mapping values.
    //

    if (elementType == AllElements) {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->LowAddress) & 0xFF);

    } else {

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);

        cdb->READ_ELEMENT_STATUS.StartingElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);
    }

    cdb->READ_ELEMENT_STATUS.NumberOfElements[0] = (UCHAR)(readElementStatus->ElementList.NumberOfElements >> 8);
    cdb->READ_ELEMENT_STATUS.NumberOfElements[1] = (UCHAR)(readElementStatus->ElementList.NumberOfElements & 0xFF);

    cdb->READ_ELEMENT_STATUS.AllocationLength[0] = (UCHAR)(length >> 16);
    cdb->READ_ELEMENT_STATUS.AllocationLength[1] = (UCHAR)(length >> 8);
    cdb->READ_ELEMENT_STATUS.AllocationLength[2] = (UCHAR)(length & 0xFF);

    //
    // Send SCSI command (CDB) to device
    //

    status = ClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    if (NT_SUCCESS(status) ||
        (status == STATUS_DATA_OVERRUN)) {

        PELEMENT_STATUS_HEADER statusHeader = statusBuffer;
        PELEMENT_STATUS_PAGE statusPage;
        PELEMENT_DESCRIPTOR elementDescriptor;
        ULONG numberElements = readElementStatus->ElementList.NumberOfElements;
        LONG remainingElements;
        LONG typeCount;
        BOOLEAN tagInfo = readElementStatus->VolumeTagInfo;
        LONG i;
        ULONG descriptorLength;

        //
        // Check if the error was really DATA_OVERRUN or was it 
        // DATA_UNDERRUN reported as DATA_OVERRUN
        //
        if (status == STATUS_DATA_OVERRUN) {
           if (srb->DataTransferLength < length) {
              DebugPrint((1, "Data Underrun reported as overrun.\n"));
              status = STATUS_SUCCESS;
           } else {
              DebugPrint((1, "Data Overrun in ChangerGetElementStatus.\n"));

              ChangerClassFreePool(srb);
              ChangerClassFreePool(statusBuffer);

              return status;
           }
        }

        //
        // Determine total number elements returned.
        //

        remainingElements = statusHeader->NumberOfElements[1];
        remainingElements |= (statusHeader->NumberOfElements[0] << 8);

        //
        // The buffer is composed of a header, status page, and element descriptors.
        // Point each element to it's respective place in the buffer.
        //

        (ULONG_PTR)statusPage = (ULONG_PTR)statusHeader;
        (ULONG_PTR)statusPage += sizeof(ELEMENT_STATUS_HEADER);

        elementType = statusPage->ElementType;

        (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
        (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

        descriptorLength = statusPage->ElementDescriptorLength[1];
        descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

        //
        // Determine the number of elements of this type reported.
        //

        typeCount =  statusPage->DescriptorByteCount[2];
        typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
        typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

        if (descriptorLength > 0) {
            typeCount /= descriptorLength;
        } else {
            typeCount = 0;
        }

        if ((typeCount == 0) &&
            (remainingElements > 0)) {
            --remainingElements;
        }

        //
        // Fill in user buffer.
        //

        elementStatus = Irp->AssociatedIrp.SystemBuffer;

        do {

            for (i = 0; i < typeCount; i++, remainingElements--) {

                //
                // Get the address for this element.
                //

                elementStatus->Element.ElementAddress = elementDescriptor->ElementAddress[1];
                elementStatus->Element.ElementAddress |= (elementDescriptor->ElementAddress[0] << 8);

                //
                // Account for address mapping.
                //

                elementStatus->Element.ElementAddress -= addressMapping->FirstElement[elementType];

                //
                // Set the element type.
                //

                elementStatus->Element.ElementType = elementType;
                elementStatus->Flags = 0;

                if (tagInfo) {

                    //
                    // For drive and slot types, copy the additional fields (vol tag info).
                    //

                    if (elementType == ChangerDrive) {
                        PSTK_ELEMENT_DESCRIPTOR_PLUS driveDescriptor =
                               (PSTK_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor;

                        if (statusPage->PVolTag) {
                        RtlMoveMemory(elementStatus->PrimaryVolumeID,                            driveDescriptor->VolumeTagInformation,                                         MAX_VOLUME_ID_SIZE);
                                elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                        }


                        if (elementDescriptor->IdValid) {
                            elementStatus->Flags |= ELEMENT_STATUS_ID_VALID;
                            elementStatus->TargetId = elementDescriptor->BusAddress;
                        }

                        if (elementDescriptor->LunValid) {
                            elementStatus->Flags |= ELEMENT_STATUS_LUN_VALID;
                            elementStatus->Lun = elementDescriptor->Lun;
                        }

                        //
                        // Source address
                        //

                        if (elementDescriptor->SValid) {

                            ULONG  j;
                            USHORT tmpAddress;


                            //
                            // Source address is valid. Determine the device specific address.
                            //

                            tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                            tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                            //
                            // Now convert to 0-based values.
                            //

                            for (j = 1; j <= ChangerDrive; j++) {
                                if (addressMapping->FirstElement[j] <= tmpAddress) {
                                    if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                        elementStatus->SrcElementAddress.ElementType = j;
                                        break;
                                    }
                                }
                            }

                            elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];

                            elementStatus->Flags |= ELEMENT_STATUS_SVALID;

                        }

                    } else if (elementType == ChangerSlot) {
                        PSTK_ELEMENT_DESCRIPTOR_PLUS slotDescriptor =
                                                         (PSTK_ELEMENT_DESCRIPTOR_PLUS)elementDescriptor;

                        if (statusPage->PVolTag) {
                           RtlMoveMemory(elementStatus->PrimaryVolumeID, slotDescriptor->VolumeTagInformation, MAX_VOLUME_ID_SIZE);
                                elementStatus->Flags |= ELEMENT_STATUS_PVOLTAG;
                        }  


                        if (elementDescriptor->SValid) {

                            ULONG  j;
                            USHORT tmpAddress;


                            //
                            // Source address is valid. Determine the device specific address.
                            //

                            tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                            tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                            //
                            // Now convert to 0-based values.
                            //

                            for (j = 1; j <= ChangerDrive; j++) {
                                if (addressMapping->FirstElement[j] <= tmpAddress) {
                                    if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                        elementStatus->SrcElementAddress.ElementType = j;
                                        break;
                                    }
                                }
                            }

                            elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];
                            elementStatus->Flags |= ELEMENT_STATUS_SVALID;
                        }
                    }

                } else {

                    if (elementType == ChangerDrive) {

                        //
                        // Source address
                        //

                        if (elementDescriptor->SValid) {
                            ULONG  j;
                            USHORT tmpAddress;


                            //
                            // Source address is valid. Determine the device specific address.
                            //

                            tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                            tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                            //
                            // Now convert to 0-based values.
                            //

                            for (j = 1; j <= ChangerDrive; j++) {
                                if (addressMapping->FirstElement[j] <= tmpAddress) {
                                    if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                        elementStatus->SrcElementAddress.ElementType = j;
                                        break;
                                    }
                                }
                            }

                            elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];
                            elementStatus->Flags |= ELEMENT_STATUS_SVALID;
                        }

                        if (elementDescriptor->IdValid) {
                            elementStatus->TargetId = elementDescriptor->BusAddress;
                        }
                        if (elementDescriptor->LunValid) {
                            elementStatus->Lun = elementDescriptor->Lun;
                        }
                    } else {

                        if (elementDescriptor->SValid) {

                            ULONG  j;
                            USHORT tmpAddress;


                            //
                            // Source address is valid. Determine the device specific address.
                            //

                            tmpAddress = elementDescriptor->SourceStorageElementAddress[1];
                            tmpAddress |= (elementDescriptor->SourceStorageElementAddress[0] << 8);

                            //
                            // Now convert to 0-based values.
                            //

                            for (j = 1; j <= ChangerDrive; j++) {
                                if (addressMapping->FirstElement[j] <= tmpAddress) {
                                    if (tmpAddress < (addressMapping->NumberOfElements[j] + addressMapping->FirstElement[j])) {
                                        elementStatus->SrcElementAddress.ElementType = j;
                                        break;
                                    }
                                }
                            }

                            elementStatus->SrcElementAddress.ElementAddress = tmpAddress - addressMapping->FirstElement[j];
                            elementStatus->Flags |= ELEMENT_STATUS_SVALID;
                        }
                    }
                }



                //
                // Build Flags field.
                //

                elementStatus->Flags |= elementDescriptor->Full;
                elementStatus->Flags |= (elementDescriptor->Accessible << 3);

                elementStatus->Flags |= (elementDescriptor->LunValid << 12);
                elementStatus->Flags |= (elementDescriptor->IdValid << 13);
                elementStatus->Flags |= (elementDescriptor->NotThisBus << 15);

                elementStatus->Flags |= (elementDescriptor->Invert << 22);
                elementStatus->Flags |= (elementDescriptor->SValid << 23);

 //
                // Map any exceptions reported directly.
                // If there is volume info returned ensure that it's not all spaces
                // as this indicates that the label is missing or unreadable.
                //

                if (elementStatus->Flags & ELEMENT_STATUS_EXCEPT) {

                    //
                    // The STK units don't have the capability of reporting exceptions
                    // in this manner except for - DataTransferElements on Optical
                    // DataXfer, Slot on DLT
                    //

                    elementStatus->ExceptionCode = MapExceptionCodes(elementDescriptor);
                } else if (elementStatus->Flags & ELEMENT_STATUS_PVOLTAG) {

                    ULONG index;

                    //
                    // Ensure that the tag info isn't all nulls. This indicates an error.
                    //

                    for (index = 0; index < MAX_VOLUME_ID_SIZE; index++) {
                        if (elementStatus->PrimaryVolumeID[index] != '\0') {
                            break;
                        }
                    }

                    //
                    // Determine if the volume id was all spaces. Do an extra check to see if media is
                    // actually present, for the unit will set the PVOLTAG flag whether media is present or not.
                    //

                    if ((index == MAX_VOLUME_ID_SIZE) && (elementStatus->Flags & ELEMENT_STATUS_FULL)) {

                        DebugPrint((1,
                                   "stkmc.GetElementStatus: Setting exception to LABEL_UNREADABLE\n"));

                        elementStatus->Flags &= ~ELEMENT_STATUS_PVOLTAG;
                        elementStatus->Flags |= ELEMENT_STATUS_EXCEPT;
                        elementStatus->ExceptionCode = ERROR_LABEL_UNREADABLE;
                    }
                }


                //
                // Get next descriptor.
                //

                (ULONG_PTR)elementDescriptor += descriptorLength;

                //
                // Advance to the next entry in the user buffer.
                //

                elementStatus += 1;

            }

            if (remainingElements > 0) {

                //
                // Get next status page.
                //

                (ULONG_PTR)statusPage = (ULONG_PTR)elementDescriptor;

                elementType = statusPage->ElementType;

                //
                // Point to decriptors.
                //

                (ULONG_PTR)elementDescriptor = (ULONG_PTR)statusPage;
                (ULONG_PTR)elementDescriptor += sizeof(ELEMENT_STATUS_PAGE);

                descriptorLength = statusPage->ElementDescriptorLength[1];
                descriptorLength |= (statusPage->ElementDescriptorLength[0] << 8);

                //
                // Determine the number of this element type reported.
                //

                typeCount =  statusPage->DescriptorByteCount[2];
                typeCount |=  (statusPage->DescriptorByteCount[1] << 8);
                typeCount |=  (statusPage->DescriptorByteCount[0] << 16);

                if (descriptorLength > 0) {
                    typeCount /= descriptorLength;
                } else {
                    typeCount = 0;
                }
        
                if ((typeCount == 0) &&
                    (remainingElements > 0)) {
                    --remainingElements;
                }
            }

        } while (remainingElements);

        Irp->IoStatus.Information = sizeof(CHANGER_ELEMENT_STATUS) * numberElements;

    }

    ChangerClassFreePool(srb);
    ChangerClassFreePool(statusBuffer);

    return status;
}




NTSTATUS
ChangerGetDisplay(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerSetDisplay(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the necessary command to either initialize all elements
    or the specified range of elements using the normal SCSI-2 command, or a vendor-unique
    range command.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    if (initElementStatus->ElementList.Element.ElementType == AllElements) {

        //
        // Build the normal SCSI-2 command for all elements.
        //

        srb->CdbLength = CDB6GENERIC_LENGTH;
        cdb->INIT_ELEMENT_STATUS.OperationCode = SCSIOP_INIT_ELEMENT_STATUS;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;

    } else {

        PCHANGER_ELEMENT_LIST elementList = &initElementStatus->ElementList;
        PCHANGER_ELEMENT element = &elementList->Element;

        //
        // Use the exabyte vendor-unique initialize with range command
        //

        srb->CdbLength = CDB10GENERIC_LENGTH;
        cdb->INITIALIZE_ELEMENT_RANGE.OperationCode = SCSIOP_INIT_ELEMENT_RANGE;
        cdb->INITIALIZE_ELEMENT_RANGE.Range = 1;

        //
        // Addresses of elements need to be mapped from 0-based to device-specific.
        //

        cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[0] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) >> 8);
        cdb->INITIALIZE_ELEMENT_RANGE.FirstElementAddress[1] =
            (UCHAR)((element->ElementAddress + addressMapping->FirstElement[element->ElementType]) & 0xFF);

        cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[0] = (UCHAR)(elementList->NumberOfElements >> 8);
        cdb->INITIALIZE_ELEMENT_RANGE.NumberOfElements[1] = (UCHAR)(elementList->NumberOfElements & 0xFF);

        //
        // Indicate whether to use bar code scanning.
        //

        cdb->INITIALIZE_ELEMENT_RANGE.NoBarCode = initElementStatus->BarCodeScan ? 0 : 1;

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        srb->DataTransferLength = 0;
    }

    //
    // Send SCSI command (CDB) to device
    //

    status = ClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine issues the appropriate command to set the robotic mechanism to the specified
    element address. Normally used to optimize moves or exchanges by pre-positioning the picker.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_SET_POSITION setPosition = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport, maxTransport;
    USHORT destination, maxDest;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    if ((setPosition->Destination.ElementType == ChangerKeypad) ||
        (setPosition->Destination.ElementType == ChangerDoor)   ||
        (setPosition->Destination.ElementType == ChangerMaxElement)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(setPosition->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerSetPosition: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(setPosition->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, setPosition->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerSetPosition: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }


    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;
    cdb->POSITION_TO_ELEMENT.OperationCode = SCSIOP_POSITION_TO_ELEMENT;

    //
    // Build device-specific addressing.
    //

    cdb->POSITION_TO_ELEMENT.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->POSITION_TO_ELEMENT.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->POSITION_TO_ELEMENT.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    //
    // Doesn't support two-sided media, but as a ref. source base, it should be noted.
    //

    cdb->POSITION_TO_ELEMENT.Flip = setPosition->Flip;


    srb->DataTransferLength = 0;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    //
    // Send SCSI command (CDB) to device
    //

    status = ClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         TRUE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_POSITION);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Moves the media at source to dest1 and dest1 to dest2.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_INVALID_DEVICE_REQUEST

--*/

{
    
    return STATUS_INVALID_DEVICE_REQUEST;

}



NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/


{
    PFUNCTIONAL_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA       changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &(changerData->AddressMapping);
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT transport, maxTransport;
    USHORT source, maxSource;
    USHORT destination, maxDest;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //
   // Verify transport, source, and dest. are within range.
    // Convert from 0-based to device-specific addressing.
    //

    transport = (USHORT)(moveMedium->Transport.ElementAddress);

    if (ElementOutOfRange(addressMapping, transport, ChangerTransport)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    source = (USHORT)(moveMedium->Source.ElementAddress);

    if (ElementOutOfRange(addressMapping, source, moveMedium->Source.ElementType)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    destination = (USHORT)(moveMedium->Destination.ElementAddress);

    if (ElementOutOfRange(addressMapping, destination, moveMedium->Destination.ElementType)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Convert to device addresses.
    //

    transport += addressMapping->FirstElement[ChangerTransport];
    source += addressMapping->FirstElement[moveMedium->Source.ElementType];
    destination += addressMapping->FirstElement[moveMedium->Destination.ElementType];


    //
    // Build srb and cdb.
    //

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

    if (!srb) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = fdoExtension->TimeOutValue;

    cdb->MOVE_MEDIUM.OperationCode = SCSIOP_MOVE_MEDIUM;

    //
    // Build addressing values based on address map.
    //

    cdb->MOVE_MEDIUM.TransportElementAddress[0] = (UCHAR)(transport >> 8);
    cdb->MOVE_MEDIUM.TransportElementAddress[1] = (UCHAR)(transport & 0xFF);

    cdb->MOVE_MEDIUM.SourceElementAddress[0] = (UCHAR)(source >> 8);
    cdb->MOVE_MEDIUM.SourceElementAddress[1] = (UCHAR)(source & 0xFF);

    cdb->MOVE_MEDIUM.DestinationElementAddress[0] = (UCHAR)(destination >> 8);
    cdb->MOVE_MEDIUM.DestinationElementAddress[1] = (UCHAR)(destination & 0xFF);

    cdb->MOVE_MEDIUM.Flip = moveMedium->Flip;

    srb->DataTransferLength = 0;

    //
    // Send SCSI command (CDB) to device
    //

    status = ClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_MOVE_MEDIUM);
    }

    ChangerClassFreePool(srb);
    return status;
}



NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    
    return STATUS_INVALID_DEVICE_REQUEST;

}



NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    return STATUS_INVALID_DEVICE_REQUEST;
}



NTSTATUS
StkBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine issues the appropriate mode sense commands and builds an
    array of element addresses. These are used to translate between the device-specific
    addresses and the zero-based addresses of the API.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/
{

    PFUNCTIONAL_DEVICE_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PCHANGER_DATA          changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);
    PCHANGER_ADDRESS_MAPPING addressMapping = &changerData->AddressMapping;
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    NTSTATUS               status;
    ULONG                  bufferLength;
    PMODE_ELEMENT_ADDRESS_PAGE elementAddressPage;
    PVOID modeBuffer;
    ULONG i;

    srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (!srb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set all FirstElements to NO_ELEMENT.
    //

    for (i = 0; i < ChangerMaxElement; i++) {
        addressMapping->FirstElement[i] = STK_NO_ELEMENT;
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    //
    // Build a mode sense - Element address assignment page.
    //

    bufferLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_ELEMENT_ADDRESS_PAGE);
    cdb->MODE_SENSE.Dbd = 1;

    modeBuffer = ChangerClassAllocatePool(NonPagedPoolCacheAligned, bufferLength);

    if (!modeBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    RtlZeroMemory(modeBuffer, bufferLength);
    srb->CdbLength = CDB6GENERIC_LENGTH;
    srb->TimeOutValue = 20;
    srb->DataTransferLength = bufferLength;
    srb->DataBuffer = modeBuffer;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_ELEMENT_ADDRESS;
    cdb->MODE_SENSE.AllocationLength = (UCHAR)srb->DataTransferLength;

    //
    // Send the request.
    //

    status = ClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         srb->DataBuffer,
                                         srb->DataTransferLength,
                                         FALSE);

    elementAddressPage = modeBuffer;
    (ULONG_PTR)elementAddressPage += sizeof(MODE_PARAMETER_HEADER);

    if (NT_SUCCESS(status)) {

        //
        // Build address mapping.
        //

        addressMapping->FirstElement[ChangerTransport] = (elementAddressPage->MediumTransportElementAddress[0] << 8) |
                                                          elementAddressPage->MediumTransportElementAddress[1];
        addressMapping->FirstElement[ChangerDrive] = (elementAddressPage->FirstDataXFerElementAddress[0] << 8) |
                                                      elementAddressPage->FirstDataXFerElementAddress[1];
        addressMapping->FirstElement[ChangerIEPort] = (elementAddressPage->FirstIEPortElementAddress[0] << 8) |
                                                       elementAddressPage->FirstIEPortElementAddress[1];
        addressMapping->FirstElement[ChangerSlot] = (elementAddressPage->FirstStorageElementAddress[0] << 8) |
                                                     elementAddressPage->FirstStorageElementAddress[1];


        //
        // Determine lowest address of all elements.
        //

        addressMapping->LowAddress = elementAddressPage->MediumTransportElementAddress[1];
        if (elementAddressPage->FirstDataXFerElementAddress[1] < addressMapping->LowAddress) {
            addressMapping->LowAddress = elementAddressPage->FirstDataXFerElementAddress[1];
        }

        addressMapping->FirstElement[ChangerDoor] = 0;
        addressMapping->FirstElement[ChangerKeypad] = 0;

        addressMapping->NumberOfElements[ChangerTransport] = elementAddressPage->NumberTransportElements[1];
        addressMapping->NumberOfElements[ChangerTransport] |= (elementAddressPage->NumberTransportElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDrive] = elementAddressPage->NumberDataXFerElements[1];
        addressMapping->NumberOfElements[ChangerDrive] |= (elementAddressPage->NumberDataXFerElements[0] << 8);

        addressMapping->NumberOfElements[ChangerIEPort] = elementAddressPage->NumberIEPortElements[1];
        addressMapping->NumberOfElements[ChangerIEPort] |= (elementAddressPage->NumberIEPortElements[0] << 8);

        addressMapping->NumberOfElements[ChangerSlot] = elementAddressPage->NumberStorageElements[1];
        addressMapping->NumberOfElements[ChangerSlot] |= (elementAddressPage->NumberStorageElements[0] << 8);

        addressMapping->NumberOfElements[ChangerDoor] = 1;
        addressMapping->NumberOfElements[ChangerKeypad] = 1;

        addressMapping->Initialized = TRUE;

    }


    //
    // Free buffer.
    //

    ChangerClassFreePool(modeBuffer);
    ChangerClassFreePool(srb);

    return status;
}



ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    )

/*++

Routine Description:

    This routine takes the sense data from the elementDescriptor and creates
    the appropriate bitmap of values.

Arguments:

   ElementDescriptor - pointer to the descriptor page.

Return Value:

    Bit-map of exception codes.

--*/

{
       
    ULONG exceptionCode = 0;
    UCHAR asc = ElementDescriptor->AdditionalSenseCode;
    UCHAR ascq = ElementDescriptor->AddSenseCodeQualifier;


    switch (asc) {
        case 0x0:
            break;

        default:
            exceptionCode = ERROR_UNHANDLED_ERROR;
    }

    DebugPrint((1,
               "stkmc.MapExceptionCode: ASC %x, ASCQ %x, exceptionCode %x\n",
               asc,
               ascq,
               exceptionCode));

    return exceptionCode;


}




BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    )
/*++

Routine Description:

    This routine determines whether the element address passed in is within legal range for
    the device.

Arguments:

    AddressMap - The dds' address map array
    ElementOrdinal - Zero-based address of the element to check.
    ElementType

Return Value:

    TRUE if out of range

--*/
{

    if (ElementOrdinal >= AddressMap->NumberOfElements[ElementType]) {

        DebugPrint((1,
                   "ElementOutOfRange: Type %x, Ordinal %x, Max %x\n",
                   ElementType,
                   ElementOrdinal,
                   AddressMap->NumberOfElements[ElementType]));
        return TRUE;
    } else if (AddressMap->FirstElement[ElementType] == STK_NO_ELEMENT) {

        DebugPrint((1,
                   "ElementOutOfRange: No Type %x present\n",
                   ElementType));

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    )
/*+++

Routine Description :

   This routine performs diagnostics tests on the changer
   to determine if the device is working fine or not. If
   it detects any problem the fields in the output buffer
   are set appropriately.

Arguments :

   DeviceObject         -   Changer device object
   changerDeviceError   -   Buffer in which the diagnostic information
                            is returned.
Return Value :

   NTStatus
--*/
{

   PSCSI_REQUEST_BLOCK srb;
   PCDB                cdb;
   NTSTATUS            status;
   PCHANGER_DATA       changerData;
   PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
   CHANGER_DEVICE_PROBLEM_TYPE changerProblemType;
   ULONG changerId;
   PUCHAR  resultBuffer;
   ULONG length;

   fdoExtension = DeviceObject->DeviceExtension;
   changerData = (PCHANGER_DATA)(fdoExtension->CommonExtension.DriverData);

   //
   // Initialize DeviceStatusin the device extension to 
   // STKMC_DEVICE_PROBLEM_NONE. If the changer returns sense code 
   // SCSI_SENSE_HARDWARE_ERROR on SelfTest, we'll set appropriate 
   // DeviceStatus in ChangerError routine.
   //
   changerData->DeviceStatus = STKMC_DEVICE_PROBLEM_NONE;

   changerDeviceError->ChangerProblemType = DeviceProblemNone;

   srb = ChangerClassAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);

   if (srb == NULL) {
      DebugPrint((1, "STKMC\\ChangerPerformDiagnostics : No memory\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
   cdb = (PCDB)srb->Cdb;

   //
   // Set the SRB for Send Diagnostic command
   //
   srb->CdbLength = CDB6GENERIC_LENGTH;
   srb->TimeOutValue = 600;

   cdb->CDB6GENERIC.OperationCode = SCSIOP_SEND_DIAGNOSTIC;

   //
   // Set SelfTest bit in the CDB
   //
   cdb->CDB6GENERIC.CommandUniqueBits = 0x2;

   status =  ClassSendSrbSynchronous(DeviceObject,
                                     srb,
                                     srb->DataBuffer,
                                     srb->DataTransferLength,
                                     FALSE);
   if (NT_SUCCESS(status)) {
      changerDeviceError->ChangerProblemType = DeviceProblemNone;
   } else if ((changerData->DeviceStatus) != STKMC_DEVICE_PROBLEM_NONE) {
      switch (changerData->DeviceStatus) {
         case STKMC_HW_ERROR: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }

         default: {
            changerDeviceError->ChangerProblemType = DeviceProblemHardware;
            break;
         }
      } // switch(changerData->DeviceStatus)
   }

   ChangerClassFreePool(srb);

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\stkmc\stkmc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    stkmc.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _STK_MC_
#define _STK_MC_


typedef struct _STK_ELEMENT_DESCRIPTOR {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR Reserved[8];
} STK_ELEMENT_DESCRIPTOR, *PSTK_ELEMENT_DESCRIPTOR;

typedef struct _STK_ELEMENT_DESCRIPTOR_PLUS {
    UCHAR ElementAddress[2];
    UCHAR Full : 1;
    UCHAR ImpExp : 1;
    UCHAR Exception : 1;
    UCHAR Accessible : 1;
    UCHAR InEnable : 1;
    UCHAR ExEnable : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5;
    UCHAR AdditionalSenseCode;
    UCHAR AddSenseCodeQualifier;
    UCHAR Lun : 3;
    UCHAR Reserved6 : 1;
    UCHAR LunValid : 1;
    UCHAR IdValid : 1;
    UCHAR Reserved7 : 1;
    UCHAR NotThisBus : 1;
    UCHAR BusAddress;
    UCHAR Reserved8;
    UCHAR Reserved9 : 6;
    UCHAR Invert : 1;
    UCHAR SValid : 1;
    UCHAR SourceStorageElementAddress[2];
    UCHAR VolumeTagInformation[36];
    UCHAR Reserved[8];
} STK_ELEMENT_DESCRIPTOR_PLUS, *PSTK_ELEMENT_DESCRIPTOR_PLUS;

#define SCSIOP_ROTATE_MAILSLOT 0x0C

#define HP_MAILSLOT_OPEN       0x01
#define HP_MAILSLOT_CLOSE      0x00

#define STK_NO_ELEMENT 0xFFFF

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mcd\drivers\starmatx\starmatx.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    starmatx.h

Abstract:

Authors:

Revision History:

--*/

#ifndef _STARMATX_H
#define _STARMATX_H

//
// Drive type
//
#define POWERFILE_DVD    1

#define STARMATX_NO_ELEMENT          0xFFFF

#define SCSI_VOLUME_ID_LENGTH    32
typedef struct _SCSI_VOLUME_TAG {
   UCHAR VolumeIdentificationField[SCSI_VOLUME_ID_LENGTH];
   UCHAR Reserved1[2];
   ULONG VolumeSequenceNumber;
} SCSI_VOLUME_TAG, *PSCSI_VOLUME_TAG;


typedef struct _STARMATX_ELEMENT_DESCRIPTOR {
 UCHAR ElementAddress[2];
 UCHAR Full : 1;
 UCHAR ImpExp : 1;
 UCHAR Except : 1;
 UCHAR Access : 1;
 UCHAR ExEnab : 1;
 UCHAR InEnab : 1;
 UCHAR Reserved1 : 2;
 UCHAR Reserved2;
 UCHAR AdditionalSenseCode;
 UCHAR AddSenseCodeQualifier;
 UCHAR Lun : 3;
 UCHAR Reserved3 : 1;
 UCHAR LUValid :1;
 UCHAR IDValid :1;
 UCHAR Reserved4 : 1;
 UCHAR NotBus : 1;
 UCHAR SCSIBusAddress;
 UCHAR Reserved5 ;
 UCHAR Reserved6 :6;
 UCHAR Invert : 1;
 UCHAR SValid : 1;
 UCHAR SourceStorageElementAddress[2];
 UCHAR Reserved7 [4];
} STARMATX_ELEMENT_DESCRIPTOR, *PSTARMATX_ELEMENT_DESCRIPTOR;
 
typedef struct _STARMATX_ELEMENT_DESCRIPTOR_PLUS {
   UCHAR ElementAddress[2];
   UCHAR Full : 1;
   UCHAR ImpExp : 1;
   UCHAR Except : 1;
   UCHAR Access : 1;
   UCHAR ExEnab : 1;
   UCHAR InEnab : 1;
   UCHAR Reserved1 : 2;
   UCHAR Reserved2;
   UCHAR AdditionalSenseCode;
   UCHAR AddSenseCodeQualifier;
   UCHAR Lun : 3;
   UCHAR Reserved3 : 1;
   UCHAR LUValid :1;
   UCHAR IDValid :1;
   UCHAR Reserved4 : 1;
   UCHAR NotBus : 1;
   UCHAR SCSIBusAddress;
   UCHAR Reserved5 ;
   UCHAR Reserved6 :6;
   UCHAR Invert : 1;
   UCHAR SValid : 1;
   UCHAR SourceStorageElementAddress[2];
   SCSI_VOLUME_TAG PrimaryVolumeTag;
   SCSI_VOLUME_TAG AlternateVolumeTag;
   UCHAR Reserved7 [4];
} STARMATX_ELEMENT_DESCRIPTOR_PLUS, *PSTARMATX_ELEMENT_DESCRIPTOR_PLUS;


typedef struct _CHANGER_ADDRESS_MAPPING {

    //
    // Indicates the first element for each element type.
    // Used to map device-specific values into the 0-based
    // values that layers above expect.
    //

    USHORT  FirstElement[ChangerMaxElement];

    //
    // Indicates the number of each element type.
    //

    USHORT  NumberOfElements[ChangerMaxElement];

    //
    // Indicates the lowest element address for the device.
    //

    USHORT LowAddress;

    //
    // Indicates that the address mapping has been
    // completed successfully.
    //

    BOOLEAN Initialized;

} CHANGER_ADDRESS_MAPPING, *PCHANGER_ADDRESS_MAPPING;

typedef struct _CHANGER_DATA {

    //
    // Size, in bytes, of the structure.
    //

    ULONG Size;

    //
    // Drive type
    //

    ULONG DriveType;

    //
    // Drive Id. Based on inquiry.
    //

    ULONG DriveID;

    //
    // Lock count
    //
    ULONG LockCount;

    //
    // See Address mapping structure above.
    //

    CHANGER_ADDRESS_MAPPING AddressMapping;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

} CHANGER_DATA, *PCHANGER_DATA;



NTSTATUS
StarMatxBuildAddressMapping(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
MapExceptionCodes(
    IN PELEMENT_DESCRIPTOR ElementDescriptor
    );

BOOLEAN
ElementOutOfRange(
    IN PCHANGER_ADDRESS_MAPPING AddressMap,
    IN USHORT ElementOrdinal,
    IN ELEMENT_TYPE ElementType
    );

#endif // _STARMATX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\control\makefile.inc ===
clean:
    del mpathwmi.h $(O)\mpath.bmf $(O)\mpath.mof

$(O)\mpath.bmf: $(O)\mpath.mof

$(O)\mpath.mof: mpath.mof
    
mpathwmi.h mpathwmi.x: $(O)\mpath.bmf
    wmimofck -hmpathwmi.h -xmpathwmi.x $(O)\mpath.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\control\mpio.h ===
#ifndef _MPATH_H_
#define _MPATH_H_

#include <ntddk.h>
#include <wmilib.h>
#include <ntdddisk.h>
#include "dsm.h"
#include "mpspf.h"
#include "mpdevf.h"
#include "mplib.h"
#include "wmi.h"
#include "stdarg.h"
#include "stdio.h"

//#define USE_BINARY_MOF_QUERY

#define DD_MULTIPATH_CONTROL_DEVICE_NAME   L"\\Device\\MPathControl"
#define DD_MULTIPATH_CONTROL_DOS_NAME      L"\\DosDevices\\MPathControl"
                                                        
#define MULTIPATH_CONTROL ((ULONG) 'mp')

//
// Internal IOCTL that control sends to it's children.
//
#define IOCTL_MPCTL_DEVFLTR_ARRIVED CTL_CODE (MULTIPATH_CONTROL, 0x20, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MPCTL_DEVFLTR_REMOVED CTL_CODE (MULTIPATH_CONTROL, 0x21, METHOD_BUFFERED, FILE_ANY_ACCESS)




//
// Internal device types.
//
#define MPIO_CONTROL  0x00000001
#define MPIO_MPDISK   0x00000002

//
// State Values.
//
#define MPIO_STATE_NORMAL          0x00000001
#define MPIO_STATE_WAIT1           0x00000002
#define MPIO_STATE_WAIT2           0x00000003
#define MPIO_STATE_WAIT3           0x00000004
#define MPIO_STATE_DEGRADED        0x00000005
#define MPIO_STATE_IN_FO           0x00000006

//
// Arbitrarly Maximum Paths handled by one MPDisk
//
#define MAX_NUMBER_PATHS     0x00000008

#define MAX_EMERGENCY_CONTEXT 32

//
// Inquiry data defines
//
#define VENDOR_ID_LENGTH   8
#define PRODUCT_ID_LENGTH 16
#define REVISION_LENGTH    4
#define PDO_NAME_LENGTH  100
#define FDO_NAME_LENGTH  128

#define MPIO_STRING_LENGTH (sizeof(WCHAR)*63)
//
// Various thread operations.
//
#define INITIATE_FAILOVER 0x00000001
#define SHUTDOWN          0x00000002
#define FORCE_RESCAN      0x00000003
#define PATH_REMOVAL      0x00000004
#define DEVICE_REMOVAL    0x00000005

extern PVOID CurrentFailurePath;

typedef struct _MP_QUEUE {
    LIST_ENTRY ListEntry;
    ULONG QueuedItems;
    KSPIN_LOCK SpinLock;
    ULONG QueueIndicator;
} MP_QUEUE, *PMP_QUEUE;

typedef struct _MPIO_ADDRESS {
    UCHAR Bus;
    UCHAR Device;
    UCHAR Function;
    UCHAR Pad;
} MPIO_ADDRESS, *PMPIO_ADDRESS;    
        
typedef struct _ID_ENTRY {
    LIST_ENTRY ListEntry;

    //
    // This is the path id. returned
    // from the DSM.
    // 
    PVOID PathID;

    //
    // The port driver fdo.
    //
    PDEVICE_OBJECT PortFdo;

    //
    // The filter DO
    //
    PDEVICE_OBJECT AdapterFilter;

    //
    // Constructed 64-bit value to pass
    // to user-mode for path Identification
    // 
    LONGLONG UID;

    //
    // The PCI Bus, Device, Function.
    //
    MPIO_ADDRESS Address;

    //
    // It's name.
    //
    UNICODE_STRING AdapterName;

    //
    // Indicates whether UID is valid.
    //
    BOOLEAN UIDValid;
    UCHAR Pad[3];

} ID_ENTRY, *PID_ENTRY;

typedef struct _DSM_ENTRY {
    LIST_ENTRY ListEntry;
    DSM_INQUIRE_DRIVER InquireDriver;
    DSM_COMPARE_DEVICES CompareDevices;
    DSM_SET_DEVICE_INFO SetDeviceInfo;
    DSM_GET_CONTROLLER_INFO GetControllerInfo;
    DSM_IS_PATH_ACTIVE IsPathActive;
    DSM_PATH_VERIFY PathVerify;
    DSM_INVALIDATE_PATH InvalidatePath;
    DSM_REMOVE_PENDING RemovePending;
    DSM_REMOVE_DEVICE RemoveDevice;
    DSM_REMOVE_PATH RemovePath;
    DSM_SRB_DEVICE_CONTROL SrbDeviceControl;
    DSM_REENABLE_PATH ReenablePath;
    DSM_LB_GET_PATH GetPath;
    DSM_INTERPRET_ERROR InterpretError;
    DSM_UNLOAD Unload;
    DSM_SET_COMPLETION SetCompletion;
    DSM_CATEGORIZE_REQUEST CategorizeRequest;
    DSM_BROADCAST_SRB BroadcastSrb;
    DSM_WMILIB_CONTEXT WmiContext;
    PVOID DsmContext;
    UNICODE_STRING DisplayName;
    
} DSM_ENTRY, *PDSM_ENTRY;

typedef struct _REAL_DEV_INFO {

    //
    // The adapter filter. Used as PathId.
    // 
    PDEVICE_OBJECT AdapterFilter;

    //
    // Port driver FDO.
    //
    PDEVICE_OBJECT PortFdo;

    //
    // Optionally, the DSM can update 'path', so
    // this PVOID contains either the DSM value
    // or AdapterFilter.
    //
    PVOID PathId;

    //
    // Number of requests on this device.
    //
    LONG Requests;

    //
    // Used to enable upper-layers to match
    // adapters/paths/luns
    //
    ULONGLONG Identifier;

    //
    // The associated controller's id.
    //
    ULONGLONG ControllerId;

    //
    // The real scsiport PDO.
    // 
    PDEVICE_OBJECT PortPdo;

    //
    // The device filter DO. Requests get sent
    // here.
    //
    PDEVICE_OBJECT DevFilter;

    //
    // The DSM's ID for the real DO
    // 
    PVOID DsmID;

    //
    // Indicates whether this is an active or passive path.
    //
    BOOLEAN PathActive;
    BOOLEAN PathFailed;
    BOOLEAN DSMInit;
    BOOLEAN PathUIDValue;
    BOOLEAN NeedsRemoval;
    UCHAR Pad[3];

    SCSI_ADDRESS ScsiAddress;

} REAL_DEV_INFO, *PREAL_DEV_INFO;    
    
typedef struct _MPDISK_EXTENSION {

    //
    // MPCtl's deviceObject.
    //
    PDEVICE_OBJECT ControlObject;

    //
    // The MPIO Disk Ordinal. Used in construction
    // of the device object and PnP IDs
    //
    ULONG DeviceOrdinal;

    //
    // Flags indicating:
    // whether a class driver has claimed the MPDisk.
    // Whether to run the State checking code.
    // Whether the device property name has been acquired (mpiowmi.c )
    // Whether the fail-over completed, and a new path has been set by the DSM.
    // Whether a transition to IN_FO is necessary.
    // Whether a missing path has come back.
    //
    BOOLEAN IsClaimed;
    BOOLEAN CheckState;
    BOOLEAN HasName;
    BOOLEAN NewPathSet;
    
    BOOLEAN FailOver;
    BOOLEAN PathBackOnLine;
    UCHAR Pad[2];

    //
    // Ref count of requests sent.
    //
    LONG OutstandingRequests;
    LONG ResubmitRequests;
    LONG FailOverRequests;

    //
    // List of requests that were outstanding at the time 
    // that a Fail-Over event occurred. As each comes back
    // they are put on this queue.
    // 
    MP_QUEUE ResubmitQueue;

    //
    // All new requests that arrive during the Fail-Over 
    // operations are put on this queue.
    // 
    MP_QUEUE FailOverQueue;

    //
    // Used to queue things to the thread.
    //
    LIST_ENTRY PendingWorkList;
    LIST_ENTRY WorkList;
    KSPIN_LOCK WorkListLock;
    KEVENT ThreadEvent;
    HANDLE Handle;

    //
    // Counter of items in the pending list.
    //
    ULONG PendingItems;
    
    //
    // Re-hash of the inquiry data + any serial number stuff
    // Used for PnP ID stuff and various WMI/IOCTLs
    // Just use the first one, as the other paths PDO all
    // are the same device.
    //
    PSTORAGE_DEVICE_DESCRIPTOR DeviceDescriptor;

    //
    // Indicates the max. number of paths that this
    // device object has seen.
    //
    ULONG MaxPaths;
    
    //
    // Bitmap used to show which array locations
    // are currently occupied.
    //
    ULONG DeviceMap;

    //
    // Indicates the path where the last request was sent.
    //
    PVOID CurrentPath;

    //
    // The most current failed path value.
    // Used to re-start the state machine after a F.O. completes.
    //
    PVOID FailedPath;

    //
    // Generic timer value inced by 1 sec. timer.
    // 
    ULONG TickCount;

    //
    // Indicates the base time for doing
    // a rescan on adapters with failed devices.
    //
    ULONG RescanCount;
    PVOID FailedAdapter;

    //
    // G.P. SpinLock.
    //
    KSPIN_LOCK SpinLock;

    //
    // Array of Dsm IDs. Passed to several
    // DSM functions. Though a copy of what's in TargetInfo,
    // it speeds up handling requests.
    //
    DSM_IDS DsmIdList;
    ULONG Buffer[32];

    //
    // Number of valid TargetInfo elements in the following array.
    //
    ULONG TargetInfoCount;
    
    //
    // This is a list of the device filter DO's and scsiport PDO's
    // being handled by this MPIO PDO.
    //
    REAL_DEV_INFO TargetInfo[MAX_NUMBER_PATHS];

    DSM_ENTRY DsmInfo;

    UNICODE_STRING PdoName;
} MPDISK_EXTENSION, *PMPDISK_EXTENSION;

typedef struct _DISK_ENTRY {
    LIST_ENTRY ListEntry;

    //
    // The MPDisk D.O.
    //
    PDEVICE_OBJECT PdoObject;
} DISK_ENTRY, *PDISK_ENTRY;

#define FLTR_FLAGS_QDR          0x00000001
#define FLTR_FLAGS_QDR_COMPLETE 0x00000002
#define FLTR_FLAGS_NEED_RESCAN  0x00000004
#define FLTR_FLAGS_RESCANNING   0x00000008

typedef struct _FLTR_ENTRY {
    LIST_ENTRY ListEntry;

    //
    // The D.O. of the filter
    //
    PDEVICE_OBJECT FilterObject;
    PDEVICE_OBJECT PortFdo;
    PDEVICE_RELATIONS CachedRelations;
    PFLTR_DEVICE_LIST FltrGetDeviceList;
    ULONG Flags;
} FLTR_ENTRY, *PFLTR_ENTRY;

typedef struct _CONTROLLER_ENTRY {
    LIST_ENTRY ListEntry;

    //
    // The DSM controlling the controller.
    // 
    PDSM_ENTRY Dsm;

    //
    // The actual info returned from the DSM.
    //
    PCONTROLLER_INFO ControllerInfo;

} CONTROLLER_ENTRY, *PCONTROLLER_ENTRY;

typedef struct _CONTROL_EXTENSION {

    //
    // Current number of MPDisk's
    //
    ULONG NumberDevices;

    //
    // Number Registered Adapter Filters.
    // 
    ULONG NumberFilters;

    //
    // Number registers DSMs.
    //
    ULONG NumberDSMs;

    //
    // Number of paths that have been
    // discovered. Note that this isn't
    // necessarily the real state of the world, due
    // to when the value is updated.
    //
    ULONG NumberPaths;

    //
    // The number of controllers found from all DSM's.
    //
    ULONG NumberControllers;
   
    //
    // The of fail-over packets currently being
    // handled.
    //
    ULONG NumberFOPackets;
    
    //
    // SpinLock for list manipulations.
    //
    KSPIN_LOCK SpinLock;

    //
    // List of MPDisks.
    //
    LIST_ENTRY DeviceList;

    //
    // List of Filters
    //
    LIST_ENTRY FilterList;

    //
    // List of DSM's.
    //
    LIST_ENTRY DsmList;

    //
    // List of PathIdentifer structs.
    //
    LIST_ENTRY IdList;

    //
    // List of controller structs.
    //
    LIST_ENTRY ControllerList;

    //
    // List of failover packets.
    //
    LIST_ENTRY FailPacketList;

} CONTROL_EXTENSION, *PCONTROL_EXTENSION;

typedef struct _DEVICE_EXTENSION {

    //
    // Pointer to the device object.
    //
    PDEVICE_OBJECT DeviceObject;

    //
    // The dev filter device object if this is a PDO.
    // The PnP PDO, if this is the FDO.
    // The object to which requests get sent.
    // 
    PDEVICE_OBJECT LowerDevice;

    //
    // Pdo (root)
    //
    PDEVICE_OBJECT Pdo;

    //
    // The driver object.
    //
    PDRIVER_OBJECT DriverObject;

    //
    // Identifies what type this is:
    // Control or pseudo disk.
    //
    ULONG Type;

    //
    // DeviceExtension - Either PDO or FDO depending
    // on value of Type.
    //
    PVOID TypeExtension;

    //
    // Request tracking tag.
    //
    LONG SequenceNumber;
    
    //
    // Current State of the world.
    // See defines above.
    //
    ULONG State;
    ULONG LastState;
    ULONG CompletionState;

    //
    // Some WMI stuff.
    //
    BOOLEAN FireLogEvent;
    UCHAR Reserved[3];
    WMILIB_CONTEXT WmiLib;
    
    //
    // Saved registry path string.
    //
    UNICODE_STRING RegistryPath;

    //
    // List of Completion Context structures.
    //
    NPAGED_LOOKASIDE_LIST ContextList;

    //
    // SpinLock for Emergency buffer handling.
    // 
    KSPIN_LOCK EmergencySpinLock;

    //
    // Array of emergency context buffers.
    //
    PVOID EmergencyContext[MAX_EMERGENCY_CONTEXT];

    //
    // Bitmap of buffer usage.
    //
    ULONG EmergencyContextMap;

    //
    // Remove lock.
    //
    IO_REMOVE_LOCK RemoveLock;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

typedef
NTSTATUS
(*PMPIO_COMPLETION_ROUTINE)(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID Context,
    IN OUT PBOOLEAN Retry,
    IN OUT PBOOLEAN Fatal
    );

typedef
VOID
(*MPIO_CALLBACK)(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Operation,
    IN NTSTATUS Status
    );
    

typedef struct _MPIO_CONTEXT {
    ULONG CurrentState;
    ULONG OriginalState;
    ULONG QueuedInto;
    BOOLEAN Allocated;
    BOOLEAN Freed;
    BOOLEAN ReIssued;
    UCHAR Reserved;
    ULONG EmergencyIndex;
    PIRP Irp;
    DSM_COMPLETION_INFO DsmCompletion;
    PREAL_DEV_INFO TargetInfo;
    SCSI_REQUEST_BLOCK Srb;
} MPIO_CONTEXT, *PMPIO_CONTEXT;

typedef struct _MPIO_THREAD_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PKEVENT Event;
} MPIO_THREAD_CONTEXT, *PMPIO_THREAD_CONTEXT;

typedef struct _MPIO_REQUEST_INFO {
    LIST_ENTRY ListEntry;
    MPIO_CALLBACK RequestComplete;
    ULONG Operation;
    PVOID OperationSpecificInfo;
    ULONG ErrorMask;
} MPIO_REQUEST_INFO, *PMPIO_REQUEST_INFO;

typedef struct _MPIO_DEVICE_REMOVAL {
    PDEVICE_OBJECT DeviceObject;
    PREAL_DEV_INFO TargetInfo;
} MPIO_DEVICE_REMOVAL, *PMPIO_DEVICE_REMOVAL;

typedef struct _MPIO_FAILOVER_INFO {
    LIST_ENTRY ListEntry;
    PDEVICE_OBJECT DeviceObject;
    PVOID PathId;
} MPIO_FAILOVER_INFO, *PMPIO_FAILOVER_INFO;

NTSTATUS
MPPdoGlobalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
MPIOResubmitCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

//
// Routines in utils.c
//
NTSTATUS
MPIOForwardRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPIOSyncCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

PREAL_DEV_INFO
MPIOGetTargetInfo(
    IN PMPDISK_EXTENSION DiskExtension,
    IN PVOID PathId,
    IN PDEVICE_OBJECT Filter
    );

PDISK_ENTRY
MPIOGetDiskEntry(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG DiskIndex
    );

BOOLEAN
MPIOFindLowerDevice(
    IN PDEVICE_OBJECT MPDiskObject,
    IN PDEVICE_OBJECT LowerDevice
    );

PDSM_ENTRY
MPIOGetDsm(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG DsmIndex
    );

PFLTR_ENTRY
MPIOGetFltrEntry(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT PortFdo,
    IN PDEVICE_OBJECT AdapterFilter
    );

NTSTATUS
MPIOHandleNewDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT FilterObject,
    IN PDEVICE_OBJECT PortObject,
    IN PADP_DEVICE_INFO DeviceInfo,
    IN PDSM_ENTRY DsmEntry,
    IN PVOID DsmExtension
    );

NTSTATUS
MPIOGetScsiAddress(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PSCSI_ADDRESS *ScsiAddress
    );

PMPIO_CONTEXT
MPIOAllocateContext(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
MPIOFreeContext(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PMPIO_CONTEXT Context
    );

VOID
MPIOCopyMemory(
   IN PVOID Destination,
   IN PVOID Source,
   IN ULONG Length
   );

VOID
MPIOCompleteRequest(
    IN PDEVICE_OBJECT DeviceObject,        
    IN PIRP Irp,
    IN CCHAR Boost
    );

NTSTATUS
MPIOQueueRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PMPIO_CONTEXT Context,
    IN PMP_QUEUE Queue
    );

NTSTATUS
MPIOFailOverHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG ErrorMask,
    IN PREAL_DEV_INFO FailingDevice
    );

VOID
MPIOSetRequestBusy(
    IN PSCSI_REQUEST_BLOCK Srb
    );

PDEVICE_RELATIONS
MPIOHandleDeviceRemovals(
    IN PDEVICE_OBJECT DeviceObject,
    IN PADP_DEVICE_LIST DeviceList,
    IN PDEVICE_RELATIONS Relations
    );

NTSTATUS
MPIOHandleDeviceArrivals(
    IN PDEVICE_OBJECT DeviceObject,
    IN PADP_DEVICE_LIST DeviceList,
    IN PDEVICE_RELATIONS CachedRelations,
    IN PDEVICE_RELATIONS Relations,
    IN PDEVICE_OBJECT PortObject,
    IN PDEVICE_OBJECT FilterObject,
    IN BOOLEAN NewList
    );

NTSTATUS
MPIORemoveDeviceAsync(
    IN PDEVICE_OBJECT DeviceObject,
    IN PREAL_DEV_INFO TargetInfo
    );

NTSTATUS
MPIOHandleRemoveAsync(
    IN PDEVICE_OBJECT DeviceObject,
    IN PREAL_DEV_INFO TargetInfo
    );

NTSTATUS
MPIORemoveSingleDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
MPIORemoveDevices(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT AdapterFilter
    );

NTSTATUS
MPIOSetNewPath(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID PathId
    );

VOID
MPIOSetFailed(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID PathId
    );

VOID
MPIOSetState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID PathId,
    IN ULONG State
    );

NTSTATUS
MPIOCreatePathEntry(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT FilterObject,
    IN PDEVICE_OBJECT PortFdo,
    IN PVOID PathID
    );

NTSTATUS
MPIOGetAdapterAddress(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PMPIO_ADDRESS Address
    );

LONGLONG
MPIOCreateUID(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID PathID
    );

ULONGLONG
MPIOBuildControllerInfo(
    IN PDEVICE_OBJECT ControlObect,
    IN PDSM_ENTRY Dsm,
    IN PVOID DsmID
    );

ULONG
MPIOHandleStateTransition(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
MPIOForceRescan(
    IN PDEVICE_OBJECT AdapterFilter
    );

NTSTATUS
MPIOCheckState(
    IN PDEVICE_OBJECT DeviceObject
    );

//
// Routines defined in fdo.c
//
NTSTATUS
MPIOFdoPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPIOFdoPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPIOFdoInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PDEVICE_RELATIONS
MPIOBuildRelations(
    IN PADP_DEVICE_LIST DeviceList
    );

//
// Routines defined in pdo.c
//
NTSTATUS
MPIOPdoRegistration(
    IN PDEVICE_OBJECT MPDiskObject,        
    IN PDEVICE_OBJECT FilterObject,
    IN PDEVICE_OBJECT LowerDevice,
    IN OUT PMPIO_PDO_INFO PdoInformation
    );

BOOLEAN
MPIOFindMatchingDevice(
    IN PDEVICE_OBJECT MPDiskObject,
    IN PADP_DEVICE_INFO DeviceInfo,
    IN PDSM_ENTRY DsmEntry,
    IN PVOID DsmId
    );

NTSTATUS
MPIOUpdateDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT AdapterFilter,
    IN PDEVICE_OBJECT PortObject,
    IN PADP_DEVICE_INFO DeviceInfo,
    IN PVOID DsmId
    );

NTSTATUS
MPIOCreateDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT FilterObject,
    IN PDEVICE_OBJECT PortObject,
    IN PADP_DEVICE_INFO DeviceInfo,
    IN PDSM_ENTRY DsmEntry,
    IN PVOID DsmId,
    IN OUT PDEVICE_OBJECT *NewDeviceObject
    );
            
NTSTATUS
MPIOPdoCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPIOPdoDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPIOPdoInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPIOPdoShutdownFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPIOPdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPIOPdoPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPIOPdoUnhandled(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
    
//
// Routines in pnp.c
//
NTSTATUS
MPIOPdoQdr(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPIOPdoQueryId(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPIOQueryDeviceText(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// Structs and Routines in queue.c
//

typedef struct _MPQUEUE_ENTRY {
    LIST_ENTRY ListEntry;
    PIRP Irp;
} MPQUEUE_ENTRY, *PMPQUEUE_ENTRY;

VOID
MPIOInitQueue(
    IN PMP_QUEUE Queue,
    IN ULONG QueueTag
    );

VOID
MPIOInsertQueue(
    IN PMP_QUEUE Queue,
    IN PMPQUEUE_ENTRY QueueEntry
    );

PMPQUEUE_ENTRY
MPIORemoveQueue(
    IN PMP_QUEUE Queue
    );

NTSTATUS
MPIOIssueQueuedRequests(
    IN PREAL_DEV_INFO TargetInfo,
    IN PMP_QUEUE Queue,
    IN ULONG State,
    IN PULONG RequestCount
    );

//
// Thread.c 
//
VOID
MPIORecoveryThread(
    IN PVOID Context
    );

//
// Wmi.c
//
VOID
MPIOSetupWmi(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
MPIOFdoWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPIOPdoWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPIOFireEvent(
    IN PDEVICE_OBJECT DeviceObject,        
    IN PWCHAR ComponentName,
    IN PWCHAR EventDescription,
    IN ULONG Severity
    );

#endif // _MPATH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\control\mpiowmi.c ===
#include <wdm.h>
#include <wmistr.h>
#include <wmiguid.h>
#include <wmilib.h>
#include "mpio.h"
#include "wmi.h"
#include "pdowmi.h"
#include <stdio.h>

#define USE_BINARY_MOF_QUERY
UCHAR MPIOBinaryMofData[] = 
{
#include "wmi.x"
};

UCHAR PdoBinaryMofData[] =
{
    #include "pdowmi.x"
};
//
// Guid Index Symbolic Names.
//
#define MPIO_DISK_INFOGuidIndex    0
#define MPIO_PATH_INFORMATIONGuidIndex    1
#define MPIO_CONTROLLER_CONFIGURATIONGuidIndex    2
#define MPIO_EventEntryGuidIndex   3 
#define MPIO_WmiBinaryMofGuidIndex 4

//
// Guid Index for Pdos
//
#define MPIO_GET_DESCRIPTORGuidIndex    0
#define BinaryMofGuidIndex   1
//
// List of supported Guids.
//
GUID MPIO_DISK_INFOGUID = MPIO_DISK_INFOGuid;
GUID MPIO_PATH_INFORMATIONGUID = MPIO_PATH_INFORMATIONGuid;
GUID MPIO_CONTROLLER_CONFIGURATIONGUID = MPIO_CONTROLLER_CONFIGURATIONGuid;
GUID MPIO_EventEntryGUID = MPIO_EventEntryGuid;
GUID MPIOWmiBinaryMofGUID = BINARY_MOF_GUID;

WMIGUIDREGINFO MPIOWmiGuidList[] =
{
    {
        &MPIO_DISK_INFOGUID,
        1,
        0
    },        
    {
        &MPIO_PATH_INFORMATIONGUID,
        1,
        0
    },
    {
        &MPIO_CONTROLLER_CONFIGURATIONGUID,
        1,
        0
    },
    {
        &MPIO_EventEntryGUID,
        1,
        0
    },
    {
        &MPIOWmiBinaryMofGUID,
        1,
        0
    }
};

#define MPIO_GUID_COUNT (sizeof(MPIOWmiGuidList) / sizeof(WMIGUIDREGINFO)) 


GUID MPIO_GET_DESCRIPTORGUID = MPIO_GET_DESCRIPTORGuid;
GUID PdowmiBinaryMofGUID =         BINARY_MOF_GUID;
WMIGUIDREGINFO PdowmiGuidList[] =
{
    {
        &MPIO_GET_DESCRIPTORGUID,
        1,
        0
    },
    {
        &PdowmiBinaryMofGUID,
        1,
        0
    }
};

#define PdowmiGuidCount (sizeof(PdowmiGuidList) / sizeof(WMIGUIDREGINFO))


NTSTATUS
MPIOQueryRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    UNICODE_STRING nameString;
    ANSI_STRING ansiString;
    UCHAR instanceName[] = "Multi-Path Disk";

    //
    // Return a pointer to the reg. path. Wmi needs this for some reason.
    // 
    *RegistryPath = &deviceExtension->RegistryPath;


    if (FALSE) { //deviceExtension->Type == MPIO_MPDISK) {

        RtlInitAnsiString(&ansiString, instanceName);
        RtlAnsiStringToUnicodeString(InstanceName, &ansiString, TRUE);

        *RegFlags = WMIREG_FLAG_INSTANCE_BASENAME;
        
    } else {
        //
        // Indicate that instance names should be auto-generated.
        //
        *RegFlags = WMIREG_FLAG_INSTANCE_PDO;

        //
        // Set the PDO.
        //
        *Pdo = deviceExtension->Pdo;
    }    

    return STATUS_SUCCESS;
}


ULONG
MPIOGetDriveInfoSize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PDSM_ENTRY dsm = &diskExtension->DsmInfo;
    ULONG length;
    WCHAR buffer[64];
    PUCHAR serialNumber;
    ULONG serialNumberLength;
    

    //
    // Determine name length.
    // \Device\MPIODisk(N)
    // 
    swprintf(buffer, L"MPIO Disk%0d", diskExtension->DeviceOrdinal);
    length = wcslen(buffer) + 1;
    length *= sizeof(WCHAR);

    //
    // Add in a USHORT to account for the 'Length' field.
    // 
    length += sizeof(USHORT);

    //
    // Add a ULONG size. (NumberPaths)
    //
    length += sizeof(ULONG);
    
    //
    // Determine SN size.
    //
    serialNumber = (PUCHAR)diskExtension->DeviceDescriptor;
    (ULONG_PTR)serialNumber += diskExtension->DeviceDescriptor->SerialNumberOffset;
    serialNumberLength = strlen(serialNumber) + 1;

    //
    // Length of the buffer.
    // 
    length += (serialNumberLength * sizeof(WCHAR));

    //
    // Length of the 'length' field.
    //
    length += sizeof(USHORT);

    //
    // Get the DSM Name.
    //
    length += dsm->DisplayName.Length;
    length += sizeof(USHORT);
    length += sizeof(UNICODE_NULL);

    if (length & 3) {

        length += sizeof(ULONG);
        length &= ~(sizeof(ULONG) - 1);
    }
    return length;
}


ULONG
MPIOBuildDriveInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PWCHAR Buffer
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PDSM_ENTRY dsm = &diskExtension->DsmInfo;
    PREAL_DEV_INFO targetInfo;
    WCHAR nameBuffer[64];
    PWCHAR buffer;
    PUCHAR serialNumber;
    ANSI_STRING ansiSerialNumber;
    UNICODE_STRING unicodeString;
    ULONG i;
    ULONG stringLength;
    ULONG totalLength;
    BOOLEAN freeBuffer = FALSE;

    buffer = Buffer;
    *((PULONG)buffer) = diskExtension->DsmIdList.Count;

    totalLength = sizeof(ULONG);
    (PUCHAR)buffer += sizeof(ULONG);
    
    //
    // Build the string locally.
    // 
    swprintf(nameBuffer, L"MPIO Disk%0d", diskExtension->DeviceOrdinal);

    //
    // Get the number of characters + 1 (for the terminating NULL).
    // 
    stringLength = wcslen(nameBuffer) + 1;

    //
    // Convert length to WCHAR sized.
    // 
    stringLength *= sizeof(WCHAR);

    //
    // The WMI strings are sort-of unicode strings. They have a length, but not
    // maximum length.
    // Indicate the Length.
    // 
    *((PUSHORT)buffer) = (USHORT)stringLength;
    (PUCHAR)buffer += sizeof(USHORT);
    
    MPDebugPrint((0,
                   "Buffer (%x) Length (%x)\n", buffer, stringLength));
            
    //
    // Copy the string.
    // 
    RtlCopyMemory(buffer,
                  nameBuffer,
                  stringLength);

    //
    // Return the length of the string (plus NULL term.) + the USHORT length field.
    //
    totalLength += stringLength + sizeof(USHORT);
    
    //
    // Build the serial Number.
    //
    (PUCHAR)buffer += stringLength;
   
    if (diskExtension->DeviceDescriptor->SerialNumberOffset == (ULONG)-1) {
        *((PUSHORT)Buffer) = 0;
        unicodeString.Length = sizeof(USHORT);

        //
        // No buffer to free.
        //
        freeBuffer = FALSE;
        
    } else {
        
        serialNumber = (PUCHAR)diskExtension->DeviceDescriptor;
        (ULONG_PTR)serialNumber += diskExtension->DeviceDescriptor->SerialNumberOffset;
        RtlInitAnsiString(&ansiSerialNumber, serialNumber);
        RtlAnsiStringToUnicodeString(&unicodeString, &ansiSerialNumber, TRUE);

        //
        // Set the serial Number Length, and move the pointer
        // to the string location.
        //
        *((PUSHORT)buffer) = unicodeString.Length + sizeof(UNICODE_NULL);
        (PUCHAR)buffer += sizeof(USHORT);
        MPDebugPrint((0,
                       "Buffer (%x) Length (%x)\n", buffer, unicodeString.Length));

        //
        // Copy the serialNumber.
        // 
        RtlCopyMemory(buffer,
                      unicodeString.Buffer,
                      unicodeString.Length);
        
        totalLength += unicodeString.Length + sizeof(USHORT);
        totalLength += sizeof(UNICODE_NULL);

        //
        // Indicate that the unicode buffer was actually allocated.
        //
        freeBuffer = TRUE;
    }

    //
    // Push the buffer to the next string location.
    //
    // CHUCKP - just added the sizeof(UNICOE_NULL)...
    //
    (PUCHAR)buffer += unicodeString.Length; 
    (PUCHAR)buffer += sizeof(UNICODE_NULL);

    //
    // Free up the Unicode string, as it's no longer needed.
    //
    if (freeBuffer) {
        RtlFreeUnicodeString(&unicodeString);
    }
    
    MPDebugPrint((0,
                   "Buffer (%x) Length (%x)\n", buffer, dsm->DisplayName.Length));
    //
    // Set the size of the DSM's name.
    //
    *((PUSHORT)buffer) = dsm->DisplayName.Length + sizeof(UNICODE_NULL);
    (PUCHAR)buffer += sizeof(USHORT);
    
    RtlCopyMemory(buffer,
                  dsm->DisplayName.Buffer,
                  dsm->DisplayName.Length);

    //
    // Need to account for a NULL at the end of this.
    //
    totalLength += sizeof(UNICODE_NULL);

    //
    // update the returned length for the Length field and
    // the string itself.
    //
    totalLength += dsm->DisplayName.Length + sizeof(USHORT);
    return totalLength;
}


MPIOGetPathInfoSize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PLIST_ENTRY entry;
    PID_ENTRY id;
    ULONG dataLength;
    ULONG stringLength;
    ULONG i;

    dataLength = sizeof(ULONG);
    entry = controlExtension->IdList.Flink;
    for (i = 0; i < controlExtension->NumberPaths; i++) {

        if (dataLength & 7) {
            dataLength += sizeof(LONGLONG);
            dataLength &= ~(sizeof(LONGLONG) - 1);
        }
        dataLength += sizeof(LONGLONG);
        dataLength += sizeof(UCHAR) * 4;

        id = CONTAINING_RECORD(entry, ID_ENTRY, ListEntry);
        stringLength = id->AdapterName.Length + sizeof(USHORT);
        if (stringLength & 3) {
            stringLength += sizeof(ULONG);
            stringLength &= ~(sizeof(ULONG) -1);
        }
        dataLength += stringLength;

    }
    return dataLength;
}


NTSTATUS
MPIOBuildPathInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUCHAR Buffer
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    ULONG dataLength;
    PLIST_ENTRY entry;
    PID_ENTRY id;
    ULONG i;
    USHORT stringLength;
    PUCHAR buffer = Buffer;
    
    *((PULONG)buffer) = controlExtension->NumberPaths;
    buffer += sizeof(ULONG);

    entry = controlExtension->IdList.Flink;
    for (i = 0; i < controlExtension->NumberPaths; i++) {

        if ((ULONG_PTR)buffer & 7) {
            (ULONG_PTR)buffer += sizeof(LONGLONG);
            (ULONG_PTR)buffer &= ~(sizeof(LONGLONG) - 1);
        }

        id = CONTAINING_RECORD(entry, ID_ENTRY, ListEntry);
        if (id->UIDValid == FALSE) {

            id->UID = MPIOCreateUID(DeviceObject,
                                    id->PathID);
        }
    
        *((PLONGLONG)buffer) = id->UID;

        //
        // Need the adapter location.
        // The Bus Number.
        //
        (ULONG_PTR)buffer += sizeof(LONGLONG);
        *buffer = id->Address.Bus; 

        //
        // The device.
        // 
        (ULONG_PTR)buffer += 1;
        *buffer = id->Address.Device;

        //
        // The function.
        // 
        (ULONG_PTR)buffer += 1;
        *buffer = id->Address.Function;

        //
        // Zero the padding byte.
        //
        (ULONG_PTR)buffer += 1;
        *buffer = 0;
        (ULONG_PTR)buffer += 1;
       
        //
        // Need the adapter friendly name...
        //
        stringLength =  id->AdapterName.Length;
        *((PUSHORT)buffer) = stringLength;
        (ULONG_PTR)buffer += sizeof(USHORT);
        RtlCopyMemory(buffer,
                      id->AdapterName.Buffer,
                      id->AdapterName.Length);
        (ULONG_PTR)buffer += stringLength;
        
        //
        // Get the next path struct.
        //
        entry = entry->Flink;
    }
    return STATUS_SUCCESS; 
}    


ULONG
MPIOGetControllerInfoSize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PLIST_ENTRY entry;
    PCONTROLLER_ENTRY controller;
    ULONG dataLength;
    ULONG stringLength;
    ULONG i;

    dataLength = sizeof(ULONG);
    entry = controlExtension->ControllerList.Flink;
    for (i = 0; i < controlExtension->NumberControllers; i++) {

        //
        // ControllerId.
        // 
        if (dataLength & 7) {
            dataLength += sizeof(LONGLONG);
            dataLength &= ~(sizeof(LONGLONG) - 1);
        }
        dataLength += sizeof(LONGLONG);

        //
        // ControllerSate.
        // 
        dataLength += sizeof(ULONG);

        controller = CONTAINING_RECORD(entry, CONTROLLER_ENTRY, ListEntry);
        stringLength = controller->Dsm->DisplayName.Length + sizeof(USHORT);
        if (stringLength & 3) {
            stringLength += sizeof(ULONG);
            stringLength &= ~(sizeof(ULONG) -1);
        }
        dataLength += stringLength;
        entry = entry->Flink;

    }
    return dataLength;
}


NTSTATUS
MPIOGetControllerInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUCHAR Buffer
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    ULONG dataLength;
    PLIST_ENTRY entry;
    PCONTROLLER_ENTRY controller;
    ULONG i;
    USHORT stringLength;
    PUCHAR buffer = Buffer;
    
    *((PULONG)buffer) = controlExtension->NumberControllers;
    buffer += sizeof(ULONG);

    entry = controlExtension->ControllerList.Flink;
    for (i = 0; i < controlExtension->NumberControllers; i++) {

        if ((ULONG_PTR)buffer & 7) {
            (ULONG_PTR)buffer += sizeof(LONGLONG);
            (ULONG_PTR)buffer &= ~(sizeof(LONGLONG) - 1);
        }

        controller = CONTAINING_RECORD(entry, CONTROLLER_ENTRY, ListEntry);
        *((PLONGLONG)buffer) = controller->ControllerInfo->ControllerIdentifier;

        (ULONG_PTR)buffer += sizeof(LONGLONG);
        *((PULONG)buffer) = controller->ControllerInfo->State;

        (ULONG_PTR)buffer += sizeof(ULONG);
       
        //
        // Build the dsm name.
        //
        stringLength = controller->Dsm->DisplayName.Length;
        *((PUSHORT)buffer) = stringLength;
        (ULONG_PTR)buffer += sizeof(USHORT);
        RtlCopyMemory(buffer,
                      controller->Dsm->DisplayName.Buffer,
                      controller->Dsm->DisplayName.Length);
        (ULONG_PTR)buffer += stringLength;
        
        //
        // Get the next path struct.
        //
        entry = entry->Flink;
    }
    return STATUS_SUCCESS; 

}


NTSTATUS
MPIOQueryDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvailable,
    OUT PUCHAR Buffer
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    NTSTATUS status;
    ULONG dataLength;
    ULONG i;
    PDISK_ENTRY diskEntry;
    
    switch (GuidIndex) {
        case MPIO_DISK_INFOGuidIndex: {
            PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
            PMPIO_DISK_INFO diskInfo;
            LARGE_INTEGER systemTime;
            ULONG stringLength;
            ULONG driveInfoLength;
            ULONG length2;
            
            //
            // Check data length to ensure buffer is large enough.
            // 
            dataLength = sizeof(ULONG);
            
            //
            // Add the length to handle the DRIVE_INFO structs for each
            // MPDisk.
            //
            for (i = 0; i < controlExtension->NumberDevices; i++) {
                diskEntry = MPIOGetDiskEntry(DeviceObject, i);
                driveInfoLength = MPIOGetDriveInfoSize(diskEntry->PdoObject);
                MPDebugPrint((0,
                              "QueryDataBlock: DriveInfoLength (%x)\n",
                              driveInfoLength));
                dataLength += driveInfoLength;
            }
            
            MPDebugPrint((0,
                         "MPIOQueryDataBlock: Length is (%x)\n", dataLength));

            if (dataLength > BufferAvailable) {

                //
                // It's not. Report the size needed back to WMI.
                // 
                status = STATUS_BUFFER_TOO_SMALL;
            } else {

                PWCHAR buffer;
                ULONG length;

                RtlZeroMemory(Buffer, dataLength);
                //
                // Indicate the number of PDO's we've created.
                //
                diskInfo = (PMPIO_DISK_INFO)Buffer;
                diskInfo->NumberDrives = controlExtension->NumberDevices;
                buffer = (PWCHAR)diskInfo->DriveInfo;
                for (i = 0; i < controlExtension->NumberDevices; i++) {
                    diskEntry = MPIOGetDiskEntry(DeviceObject, i);
                    
                    length = MPIOBuildDriveInfo(diskEntry->PdoObject,
                                                buffer);
                    MPDebugPrint((0,
                                 "BuildDriveInfo Length (%x) buffer (%x)\n", length, buffer));
                    (PUCHAR)buffer += length;
                    if ((ULONG_PTR)buffer & 3) {
                        (ULONG_PTR)buffer += sizeof(ULONG);
                        (ULONG_PTR)buffer &= ~(sizeof(ULONG) - 1);
                    }
                    MPDebugPrint((0,
                                 "After fixup buffer (%x)\n",buffer));
                    
                }
            
                *InstanceLengthArray = dataLength;
                status = STATUS_SUCCESS;
            }    
            break;    
        }        
        case MPIO_PATH_INFORMATIONGuidIndex: {
            dataLength = MPIOGetPathInfoSize(DeviceObject);
            if (dataLength > BufferAvailable) {
                status = STATUS_BUFFER_TOO_SMALL;
            } else {
                status = MPIOBuildPathInfo(DeviceObject,
                                           Buffer);
                *InstanceLengthArray = dataLength;
            }
            break;
        }                                                 
        case MPIO_CONTROLLER_CONFIGURATIONGuidIndex: {
            
            //
            // Determine the buffer size needed.
            //
            dataLength =  MPIOGetControllerInfoSize(DeviceObject);

            if (dataLength > BufferAvailable) {
                status = STATUS_BUFFER_TOO_SMALL;
            } else {

                status = MPIOGetControllerInfo(DeviceObject,
                                                 Buffer);
                *InstanceLengthArray = dataLength;
            }    

            break;
        }                                                         
        case MPIO_EventEntryGuidIndex:

            //
            // This is an event. Set zero info and 
            // return.
            //
            *InstanceLengthArray = 0;
            status = STATUS_SUCCESS;
            break;
            
        case MPIO_WmiBinaryMofGuidIndex:

            //
            // Need to copy over the mof data.
            //
            dataLength = sizeof(MPIOBinaryMofData);

            //
            // Ensure that the buffer is large enough.
            // 
            if (dataLength > BufferAvailable) {

                //
                // dataLength is passed back to the WmiLib
                // so it can adjust.
                //
                status = STATUS_BUFFER_TOO_SMALL;
                
            } else {

                RtlCopyMemory(Buffer, MPIOBinaryMofData, dataLength);
                *InstanceLengthArray = dataLength;
                status = STATUS_SUCCESS;
            }
            break;
        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
    }        
    
    //
    // Complete the request.
    //
    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                dataLength,
                                IO_NO_INCREMENT);
    return status;
}


NTSTATUS
MPIOWmiControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    switch (GuidIndex) {
        case MPIO_EventEntryGuidIndex:
            if (Enable) {

                //
                // Indicate that it's OK to fire the Log event.
                //
                deviceExtension->FireLogEvent = TRUE;
            } else {

                //
                // Turn off firing the logger.
                //
                deviceExtension->FireLogEvent = FALSE;
            }
            MPDebugPrint((0,
                          "MPIOWmiControl: Turning the Logger (%s) on (%x)\n",
                          Enable ? "ON" : "OFF",
                          DeviceObject));
            
            break;
            
        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
    }        

    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                0,
                                IO_NO_INCREMENT);
    return status;
}

//
// PDO Call-Backs.
//

        
ULONG
MPIOGetDescriptorSize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PREAL_DEV_INFO targetInfo = diskExtension->TargetInfo;
    ULONG dataLength = 0;
    NTSTATUS status;
    ULONG i;
    ULONG stringLength;
    ULONG bytesRequired;

    //
    // NumberPdos
    // 
    dataLength = sizeof(ULONG);

    if (diskExtension->HasName == FALSE) {
        
        //
        // Get the name of the first PortPdo - being as it's
        // the same device, the name remains the same for all.
        // 
        status = IoGetDeviceProperty(targetInfo->PortPdo,
                                     DevicePropertyFriendlyName,
                                     diskExtension->PdoName.MaximumLength,
                                     diskExtension->PdoName.Buffer,
                                     &bytesRequired);
        
        if (status == STATUS_SUCCESS) {
   
            MPDebugPrint((0,
                         "GetDescriptor: size of name is (%x)\n",
                         bytesRequired));
            //
            // The buffer is NULL terminated. Reduce it.
            //
            bytesRequired -= sizeof(UNICODE_NULL);

            stringLength = sizeof(USHORT);
            stringLength += bytesRequired;
            
            diskExtension->HasName = TRUE;
            
            //
            // Align the buffer size.
            //
            if (stringLength & 3) {
            
                MPDebugPrint((0,
                              "GetDescriptor: Need to align (%x\n",
                              stringLength));

                stringLength += sizeof(ULONG);
                stringLength &= ~(sizeof(ULONG) -1);
            }
            
            MPDebugPrint((0,
                         "GetDescriptor: size of name is now (%x). StrLeng (%x)\n",
                         bytesRequired,
                         stringLength));

            diskExtension->PdoName.Length = (USHORT)bytesRequired;

        } else {
            MPDebugPrint((0,
                          "MPIOGetDescriptor: Buffer not large enough (%lu)\n",
                          bytesRequired));
        }    
    } else {
        stringLength = sizeof(USHORT);
        stringLength += diskExtension->PdoName.Length;
        
        if (stringLength & 3) {
            stringLength += sizeof(ULONG);
            stringLength &= ~(sizeof(ULONG) -1);
        }
    }    

    //
    // Length of the string + the size field.
    // 
    dataLength += stringLength; 

    for (i = 0; i < diskExtension->DsmIdList.Count; i++) {

        //
        // Length of the scsi address.
        // 
        dataLength += sizeof(SCSI_ADDR);

        //
        // Path Identifier.
        //
        dataLength += sizeof(LONGLONG);

        //
        // Controller ID.
        //
        dataLength += sizeof(ULONGLONG);
        if (dataLength & 7) {
            dataLength += sizeof(LONGLONG);
            dataLength &= ~(sizeof(LONGLONG) - 1);
        }

        //
        // Get the next targetInfo.
        //
        targetInfo++;
    }

    MPDebugPrint((0,
                  "GetDescriptor: Total Length (%x)\n",
                  dataLength));

    return dataLength;
}    


NTSTATUS
MPIOBuildDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUCHAR Buffer
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PREAL_DEV_INFO targetInfo = diskExtension->TargetInfo;
    PMPIO_GET_DESCRIPTOR descriptor = (PMPIO_GET_DESCRIPTOR)Buffer;
    NTSTATUS status;
    PUCHAR buffer;
    ULONG i;
    PSCSI_ADDR scsiAddress;

    descriptor->NumberPdos = diskExtension->DsmIdList.Count;
    buffer = Buffer;
    buffer += sizeof(ULONG);

    //
    // Set the string length.
    // 
    *((PUSHORT)buffer) = diskExtension->PdoName.Length;
    buffer += sizeof(USHORT);

    //
    // Copy it over.
    //
    RtlCopyMemory(buffer,
                  diskExtension->PdoName.Buffer,
                  diskExtension->PdoName.Length);

    //
    // Push it to the end of the string.
    // 
    buffer += diskExtension->PdoName.Length;

    //
    // ULONG align.
    //
    if ((ULONG_PTR)buffer & 3) {

        (ULONG_PTR)buffer += sizeof(ULONG);
        (ULONG_PTR)buffer &= ~(sizeof(ULONG) - 1);
    }
    
    for (i = 0; i < diskExtension->DsmIdList.Count; i++) {

        scsiAddress = (PSCSI_ADDR)buffer;
        
        scsiAddress->PortNumber = targetInfo->ScsiAddress.PortNumber;
        scsiAddress->ScsiPathId = targetInfo->ScsiAddress.PathId;
        scsiAddress->TargetId = targetInfo->ScsiAddress.TargetId;
        scsiAddress->Lun = targetInfo->ScsiAddress.Lun;

        buffer += sizeof(SCSI_ADDR);

        if (targetInfo->PathUIDValue == FALSE) {
            targetInfo->Identifier = MPIOCreateUID(diskExtension->ControlObject,
                                                   targetInfo->PathId);
            ASSERT(targetInfo->Identifier != 0);
            targetInfo->PathUIDValue = TRUE;
        }

        //
        // Align the buffer
        //
        if ((ULONG_PTR)buffer & 7) {
            (ULONG_PTR)buffer += sizeof(LONGLONG);
            (ULONG_PTR)buffer &= ~(sizeof(LONGLONG) - 1);
        }
        *((PLONGLONG)buffer) = targetInfo->Identifier;
        buffer += sizeof(LONGLONG);

        //
        // Get the controllerID.
        //
        *((PULONGLONG)buffer) = targetInfo->ControllerId;
        buffer += sizeof(ULONGLONG);

        //
        // Handle the next device.
        //
        targetInfo++;
    }
    return STATUS_SUCCESS;
}

    

NTSTATUS
MPIOPdoQueryDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvailable,
    OUT PUCHAR Buffer
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PDSM_ENTRY dsm = &diskExtension->DsmInfo;
    NTSTATUS status;
    ULONG dataLength;
    
    switch(GuidIndex) {
        case MPIO_GET_DESCRIPTORGuidIndex: {

            dataLength = MPIOGetDescriptorSize(DeviceObject);
            
            if (dataLength > BufferAvailable) {
                status = STATUS_BUFFER_TOO_SMALL;
            } else {
                RtlZeroMemory(Buffer, dataLength);
                status = MPIOBuildDescriptor(DeviceObject,
                                             Buffer);
                *InstanceLengthArray = dataLength;
                status = STATUS_SUCCESS;
            }    
            break;
        }

        case BinaryMofGuidIndex: {
            //
            // TODO: If the driver supports reporting MOF dynamically, 
            //       change this code to handle multiple instances of the
            //       binary mof guid and return only those instances that
            //       should be reported to the schema
            //
            dataLength = sizeof(PdoBinaryMofData);

            if (BufferAvailable < dataLength)
            {
                status = STATUS_BUFFER_TOO_SMALL;
            } else {
                RtlCopyMemory(Buffer, PdoBinaryMofData, dataLength);
                *InstanceLengthArray = dataLength;
                status = STATUS_SUCCESS;
            }
            break;
        }

        default: {
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
        }
    }

    //
    // Complete the request.
    //
    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                dataLength,
                                IO_NO_INCREMENT);
    return status;
}


NTSTATUS
MPIOGetDiskDescriptorSize(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    ULONG dataLength;
    NTSTATUS status;
    ULONG i;

    //
    // Length is ULONG (NumberDisks) + sizeof(MPDISK_DESCRIPTOR)
    //
    dataLength = sizeof(ULONG);

    //
    // For the string length field.
    // 
    dataLength += sizeof(USHORT);
    
    //
    // Length of the  product/vendor/rev string
    // (8 + 16+ 4 + 2  (spaces between vendor/product/rev) + 1 (trailing NULL)) * sizeof(WCHAR)
    //
    dataLength += 0x3C; 

    //
    // Ensure that the start of each array entry is ULONG aligned.
    //
    dataLength += sizeof(ULONG);
    dataLength &= ~(sizeof(ULONG) - 1);

    for (i = 0; i < diskExtension->DsmIdList.Count; i++) {

        //
        // SCSI_ADDR (almost like SCSI_ADDRESS, but without the length field)
        //
        dataLength += sizeof(SCSI_ADDR);
        
        
    }
    return dataLength;
}


NTSTATUS
MPIOGetDiskDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUCHAR Buffer,
    IN ULONG BufferLength
    )

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PUCHAR buffer = Buffer;
    PREAL_DEV_INFO targetInfo;
    PSTORAGE_DEVICE_DESCRIPTOR deviceDescriptor;
    PUCHAR inquiryField;
    PUCHAR index;
    UCHAR inquiryData[32];
    ANSI_STRING ansiInquiry;
    UNICODE_STRING unicodeString;
    PSCSI_ADDR scsiAddress;
    ULONG i;
    NTSTATUS status;

    RtlZeroMemory(Buffer, BufferLength);

    *((PULONG)buffer) = diskExtension->DsmIdList.Count;
    targetInfo = diskExtension->TargetInfo;

    //
    // Set the number of drives underlying this mpdisk.
    // 
    (ULONG_PTR)buffer += sizeof(ULONG);

    
    //
    // Preload the inquiry buffer with spaces and a null-terminator.
    //
    for (i = 0; i < 32; i++) {
        inquiryData[i] = ' ';
    }
    inquiryData[30] = '\0';
    inquiryData[31] = '\0';
    
    //
    // Merge the ascii inquiry data into one long string.
    //
    deviceDescriptor  = diskExtension->DeviceDescriptor;
    inquiryField = (PUCHAR)deviceDescriptor;
    (ULONG_PTR)inquiryField += deviceDescriptor->VendorIdOffset;
    index = inquiryData;

    //
    // Copy the vendorId.
    // 
    RtlCopyMemory(index, inquiryField, 8);

    //
    // Account for vendorId + a space.
    // 
    index += 9;
    
    inquiryField = (PUCHAR)deviceDescriptor;
    (ULONG_PTR)inquiryField += deviceDescriptor->ProductIdOffset;
    
    //
    // Copy ProductId.
    //
    RtlCopyMemory(index, inquiryField, 16);

    //
    // Account for product + space.
    //
    index += 17;

    inquiryField = (PUCHAR)deviceDescriptor;
    (ULONG_PTR)inquiryField += deviceDescriptor->ProductRevisionOffset;
    RtlCopyMemory(index, inquiryField, 4);
    
    //
    // Convert to WCHAR.
    //
    RtlInitAnsiString(&ansiInquiry, inquiryData);
    RtlAnsiStringToUnicodeString(&unicodeString, &ansiInquiry, TRUE);

    //
    // Build the name string. First is the length.
    //
    // BUGBUG: Note the hack of +2
    //
    *((PUSHORT)buffer) = unicodeString.Length + 2;  
    (ULONG_PTR)buffer += sizeof(USHORT);

    //
    // Copy the serialNumber.
    // 
    RtlCopyMemory(buffer,
                  unicodeString.Buffer,
                  unicodeString.Length);
  
    //
    // Advance the pointer past the inquiry string.
    // 
    (ULONG_PTR)buffer += unicodeString.Length;
    
    RtlFreeUnicodeString(&unicodeString);

    //
    // ULONG align it.
    //
    (ULONG_PTR)buffer += sizeof(ULONG);
    (ULONG_PTR)buffer &= ~(sizeof(ULONG) - 1);
    
    for (i = 0; i < diskExtension->DsmIdList.Count; i++) {
        scsiAddress = (PSCSI_ADDR)buffer;

        scsiAddress->PortNumber = targetInfo->ScsiAddress.PortNumber;
        scsiAddress->ScsiPathId = targetInfo->ScsiAddress.PathId;
        scsiAddress->TargetId = targetInfo->ScsiAddress.TargetId;
        scsiAddress->Lun = targetInfo->ScsiAddress.Lun;
        targetInfo++;

        (ULONG_PTR)buffer += sizeof(SCSI_ADDR);
#if 0            
        
        //
        // Fake the WWN.
        // TODO get the real stuff.
        //
        *((PLONGLONG)buffer) = 0;

        (ULONG_PTR)buffer += sizeof(LONGLONG);
#endif    
    }
    return STATUS_SUCCESS;
}


NTSTATUS
MPIOExecuteMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:
Arguments:
'aReturn Value:

    status

--*/
{
    ULONG dataLength = 0;
    ULONG ordinal;
    PDISK_ENTRY diskEntry;
    NTSTATUS status;

    switch(GuidIndex) {
#if 0            
        case MPIO_GET_DESCRIPTORSGuidIndex: {
            switch(MethodId) {
                case MPIOGetMPIODiskDescriptor: {
                    //
                    // Check the input buffer size.
                    //
                    if (InBufferSize != sizeof(ULONG)) {
                        status = STATUS_INVALID_PARAMETER;
                        dataLength = 0;
                        break;
                        
                    }

                    //
                    // The input buffer is the ordinal of the device in which
                    // the caller has interest.
                    // 
                    ordinal = *((PULONG)Buffer);

                    //
                    // Ensure that ordinal is with-in range.
                    // TODO
                    diskEntry = MPIOGetDiskEntry(DeviceObject,
                                                 ordinal);
                    //
                    // Get the size of the return info.
                    //
                    dataLength = MPIOGetDiskDescriptorSize(diskEntry->PdoObject);

                    if (dataLength > OutBufferSize) {

                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }
                    
                    //
                    // 
                    status = MPIOGetDiskDescriptor(diskEntry->PdoObject,
                                                   Buffer,
                                                   OutBufferSize);

                    
                    
                    break;
                }

                default: {
                    status = STATUS_WMI_ITEMID_NOT_FOUND;
                    break;
                }
            }
            break;
        }
#endif
        default: {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
    }

    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                dataLength,
                                IO_NO_INCREMENT);

    return(status);
}

NTSTATUS
MPIOPdoWmiControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    switch (GuidIndex) {
        case MPIO_EventEntryGuidIndex:
            if (Enable) {

                //
                // Indicate that it's OK to fire the Log event.
                //
                deviceExtension->FireLogEvent = TRUE;
            } else {

                //
                // Turn off firing the logger.
                //
                deviceExtension->FireLogEvent = FALSE;
            }
            MPDebugPrint((0,
                          "MPIOWmiControl: Turning the Logger (%s) on (%x)\n",
                          Enable ? "ON" : "OFF",
                          DeviceObject));
            
            break;
            
        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
    }        

    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                0,
                                IO_NO_INCREMENT);
    return status;
}


VOID
MPIOSetupWmi(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension;
    PWMILIB_CONTEXT wmiLibContext = &deviceExtension->WmiLib;
    NTSTATUS status;
    PDSM_ENTRY dsm;
    PDSM_WMILIB_CONTEXT wmiContext;
    ULONG guids;
    ULONG guidListSize;
    PUCHAR index;

    //
    // This simply jams in all the fields of the wmilib context for
    // use by WmiSystemControl.
    // 

    if (deviceExtension->Type == MPIO_MPDISK) {

        //
        // TODO: Revisit piggybacking off of the PDO. It may be
        // better to use the FDO.
        //
        diskExtension = deviceExtension->TypeExtension;
        dsm = &diskExtension->DsmInfo;
        
        //
        // Get the DSM's Wmi Info and append it to ours.
        //
        //wmiContext =  &dsm->WmiContext;

        //
        // Currently, there are no PDO associated GUIDs. As soon as they are in place
        // this needs to be updated accordingly.
        // 
#if 0
        guids = wmiContext->GuidCount + MPIO_PDO_GUID_COUNT;
        guidListSize =  sizeof(MPIOPdoGuidList) + sizeof(wmiContext->GuidList);
        guidListSize =  sizeof(wmiContext->GuidList);
        deviceExtension->WmiLib.GuidList = ExAllocatePool(NonPagedPool,guidListSize);
        RtlZeroMemory(deviceExtension->WmiLib.GuidList, guidListSize);

        //
        // Copy over the pdo's list.
        //
        index = (PUCHAR)deviceExtension->WmiLib.GuidList;
        RtlCopyMemory(index,
                      MPIOPdoGuidList,
                      sizeof(MPIOPdoGuidList));
        index += sizeof(MPIOPdoGuidList);

        wmiLibContext->GuidCount = guids;

        //
        // copy over the DSM's.
        //
        RtlCopyMemory(index,
                      wmiContext->GuidList,
                      sizeof(wmiContext->GuidList));
        
#endif        
        wmiLibContext->GuidCount = PdowmiGuidCount;
        wmiLibContext->GuidList = PdowmiGuidList;
        wmiLibContext->QueryWmiRegInfo = MPIOQueryRegInfo;
        wmiLibContext->QueryWmiDataBlock = MPIOPdoQueryDataBlock;
        //wmiLibContext->SetWmiDataBlock = MPIOPdoSetDataBlock;
        //wmiLibContext->SetWmiDataItem = MPIOPdoSetDataItem;
        //wmiLibContext->ExecuteWmiMethod = MPIOPdoExecuteMethod;
        //wmiLibContext->WmiFunctionControl = MPIOPdoWmiControl;
   
    } else {
        
        wmiLibContext->GuidCount = MPIO_GUID_COUNT;
        wmiLibContext->GuidList = MPIOWmiGuidList;
        wmiLibContext->QueryWmiRegInfo = MPIOQueryRegInfo;
        wmiLibContext->QueryWmiDataBlock = MPIOQueryDataBlock;
        //wmiLibContext->SetWmiDataBlock = MPIOSetDataBlock;
        //wmiLibContext->SetWmiDataItem = MPIOSetDataItem;
        wmiLibContext->ExecuteWmiMethod = MPIOExecuteMethod;
        wmiLibContext->WmiFunctionControl = MPIOWmiControl;

    }   


    return;
}


NTSTATUS
MPIOPdoWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;

    //
    // Using the WMI Library, so call it with the request.
    // This will call the appropriate DpWmi function.
    //
    status = WmiSystemControl(&deviceExtension->WmiLib,
                              DeviceObject,
                              Irp,
                              &disposition);

    switch (disposition) {
        case IrpProcessed:
            
            //
            // Already handled by one of the DpWmi call-backs.
            //
            break;
        case IrpNotCompleted:

            //
            // Probably an error, or the IRP_MN_REGINFO
            //
            MPDebugPrint((0,
                          "MPIOrPdoWmi: Irp (%x) Mn (%x) Status (%x)\n",
                          Irp,
                          irpStack->MinorFunction,
                          status));
            
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        case IrpNotWmi:
        case IrpForward:
        default:
            //
            // Forward this irp. 
            //
            status = MPIOForwardRequest(DeviceObject, Irp);
            break;
    }        
                  
    return status;
}


NTSTATUS
MPIOFdoWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;

    //
    // Using the WMI Library, so call it with the request.
    // This will call the appropriate DpWmi function.
    //
    status = WmiSystemControl(&deviceExtension->WmiLib,
                              DeviceObject,
                              Irp,
                              &disposition);

    switch (disposition) {
        case IrpProcessed:
            
            //
            // Already handled by one of the DpWmi call-backs.
            //
            break;
        case IrpNotCompleted:

            //
            // Probably an error, or the IRP_MN_REGINFO
            //
            MPDebugPrint((0,
                          "MPIOFdoWmi: Irp (%x) Mn (%x) Status (%x)\n",
                          Irp,
                          irpStack->MinorFunction,
                          status));
            
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        case IrpNotWmi:
        case IrpForward:
        default:
            //
            // Forward this irp. 
            //
            status = MPIOForwardRequest(DeviceObject, Irp);
            break;
    }        
                  
    return status;

}    


NTSTATUS
MPIOFireEvent(
    IN PDEVICE_OBJECT DeviceObject,        
    IN PWCHAR ComponentName,
    IN PWCHAR EventDescription,
    IN ULONG Severity
    )
{
    PMPIO_EventEntry eventEntry;
    ULONG dataLength;
    PWCHAR nameString;
    LARGE_INTEGER systemTime;
    NTSTATUS status;
    USHORT componentLength;
    USHORT eventLength;
    PUCHAR index;

    //
    // Determine the total allocation length based on the
    // structure and string lengths.
    //
    componentLength = wcslen(ComponentName) * sizeof(WCHAR);
    componentLength += sizeof(UNICODE_NULL);
    eventLength = wcslen(EventDescription) * sizeof(WCHAR);
    eventLength += sizeof(UNICODE_NULL);

    if ((componentLength > MPIO_STRING_LENGTH) ||
        (eventLength > MPIO_STRING_LENGTH)) {
        return STATUS_INVALID_PARAMETER;
    }

    dataLength = sizeof(MPIO_EventEntry);

    //
    // Allocate the EventData.
    //
    eventEntry = ExAllocatePool(NonPagedPool, dataLength);
    if (eventEntry == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(eventEntry, dataLength);

    
    //
    // Set the severity of the event.
    //
    eventEntry->Severity = Severity;
    KeQuerySystemTime(&systemTime);
    eventEntry->TimeStamp = systemTime.QuadPart;

    //
    // Copy the Component Name.
    // 
    nameString = eventEntry->Component;
    *((PUSHORT)nameString) = componentLength;
    nameString++;
    wcscpy(nameString, ComponentName);

    MPDebugPrint((0,
                  "NameString (%x). Length (%d)\n",
                  nameString,
                  componentLength));

    //
    // Copy over the Object name.
    // 
    nameString = eventEntry->EventDescription;
    *((PUSHORT)nameString) = eventLength;
    nameString++;
    wcscpy(nameString, EventDescription);

    //
    // Send the event.
    //
    status = WmiFireEvent(DeviceObject,
                          &MPIO_EventEntryGUID,
                          0,
                          dataLength,
                          eventEntry);
    if (status != STATUS_SUCCESS) {
        MPDebugPrint((0,
                     "MPIOFireEvent: Status (%x)\n",
                     status));

        //
        // TODO: Queue these for when we get the Enable request.
        //
        ExFreePool(eventEntry);
        
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\control\pdowmi.h ===
#ifndef _pdowmi_h_
#define _pdowmi_h_

// CName - CName
#define CNameGuid \
    { 0x0cf26b63,0x4b08,0x426d, { 0xb1,0x71,0xcd,0xbb,0x1c,0xcd,0xd1,0x1a } }

DEFINE_GUID(CName_GUID, \
            0x0cf26b63,0x4b08,0x426d,0xb1,0x71,0xcd,0xbb,0x1c,0xcd,0xd1,0x1a);


typedef struct _CName
{
    // 
    CHAR VariableData[1];
    #define CName_CName_ID 1

} CName, *PCName;

// SCSI_ADDR - SCSI_ADDR
#define SCSI_ADDRGuid \
    { 0xc74aece4,0x468b,0x4113, { 0xb0,0x06,0x0c,0xec,0xdc,0x96,0x8a,0xc4 } }

DEFINE_GUID(SCSI_ADDR_GUID, \
            0xc74aece4,0x468b,0x4113,0xb0,0x06,0x0c,0xec,0xdc,0x96,0x8a,0xc4);


typedef struct _SCSI_ADDR
{
    // 
    UCHAR PortNumber;
    #define SCSI_ADDR_PortNumber_SIZE sizeof(UCHAR)
    #define SCSI_ADDR_PortNumber_ID 1

    // 
    UCHAR ScsiPathId;
    #define SCSI_ADDR_ScsiPathId_SIZE sizeof(UCHAR)
    #define SCSI_ADDR_ScsiPathId_ID 2

    // 
    UCHAR TargetId;
    #define SCSI_ADDR_TargetId_SIZE sizeof(UCHAR)
    #define SCSI_ADDR_TargetId_ID 3

    // 
    UCHAR Lun;
    #define SCSI_ADDR_Lun_SIZE sizeof(UCHAR)
    #define SCSI_ADDR_Lun_ID 4

} SCSI_ADDR, *PSCSI_ADDR;

// PDO_INFORMATION - PDO_INFORMATION
#define PDO_INFORMATIONGuid \
    { 0xe69e581d,0x6580,0x4bc2, { 0xba,0xd1,0x7e,0xee,0x85,0x98,0x90,0x86 } }

DEFINE_GUID(PDO_INFORMATION_GUID, \
            0xe69e581d,0x6580,0x4bc2,0xba,0xd1,0x7e,0xee,0x85,0x98,0x90,0x86);


typedef struct _PDO_INFORMATION
{
    // 
    SCSI_ADDR ScsiAddress;
    #define PDO_INFORMATION_ScsiAddress_SIZE sizeof(SCSI_ADDR)
    #define PDO_INFORMATION_ScsiAddress_ID 1

    // 
    ULONGLONG PathIdentifier;
    #define PDO_INFORMATION_PathIdentifier_SIZE sizeof(ULONGLONG)
    #define PDO_INFORMATION_PathIdentifier_ID 2

    // 
    ULONGLONG ControllerIdentifier;
    #define PDO_INFORMATION_ControllerIdentifier_SIZE sizeof(ULONGLONG)
    #define PDO_INFORMATION_ControllerIdentifier_ID 3

} PDO_INFORMATION, *PPDO_INFORMATION;

// MPIO_GET_DESCRIPTOR - MPIO_GET_DESCRIPTOR
// Retrieve Object Information about a Multi-Path Disk.
#define MPIO_GET_DESCRIPTORGuid \
    { 0x85134d46,0xd17c,0x4992, { 0x83,0xf9,0x07,0x0d,0xd4,0xc4,0x8e,0x0b } }

DEFINE_GUID(MPIO_GET_DESCRIPTOR_GUID, \
            0x85134d46,0xd17c,0x4992,0x83,0xf9,0x07,0x0d,0xd4,0xc4,0x8e,0x0b);


typedef struct _MPIO_GET_DESCRIPTOR
{
    // Number of Port Objects backing the device.
    ULONG NumberPdos;
    #define MPIO_GET_DESCRIPTOR_NumberPdos_SIZE sizeof(ULONG)
    #define MPIO_GET_DESCRIPTOR_NumberPdos_ID 1

    // Name of Device.
    CName DeviceName;
    #define MPIO_GET_DESCRIPTOR_DeviceName_SIZE sizeof(CName)
    #define MPIO_GET_DESCRIPTOR_DeviceName_ID 2

    // Array of Infomation classes describing the real device.
    PDO_INFORMATION PdoInformation[1];
    #define MPIO_GET_DESCRIPTOR_PdoInformation_ID 3

} MPIO_GET_DESCRIPTOR, *PMPIO_GET_DESCRIPTOR;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\control\fdo.c ===
#include "mpio.h"
#include <stdio.h>
#include <stdlib.h>

/*++

Routine Description:


Arguments:


Return Value:


--*/





NTSTATUS
MPIOStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles PnP Stop irps for the FDO (Control).
    Currently, it only sets status and forwards the Irp.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{

    //
    // TODO: Any stop stuff.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    return MPIOForwardRequest(DeviceObject, Irp);

}


NTSTATUS
MPIOStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles PnP Start requests for the FDO
    

Arguments:
    
    DeviceObject,
    Irp


Return Value:


--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    KEVENT event;
    NTSTATUS status;
    
    //
    // The above minor functions need status set to success, set a completion routine,
    // send to the next driver, and wait. Once the event is signaled, complete the request.
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Setup the initial status of the request.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // Clone the stack location.
    //
    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // Set the completion routine.
    //
    IoSetCompletionRoutine(Irp,
                           MPIOSyncCompletion,
                           &event, 
                           TRUE, 
                           TRUE, 
                           TRUE);

    //
    // Call down.
    //
    status = IoCallDriver(deviceExtension->LowerDevice, Irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        status = Irp->IoStatus.Status;
    }
    if (status == STATUS_SUCCESS) {

        //
        // TODO: Other 'start' stuff.
        //
        MPDebugPrint((2,
                      "MPIOStartDevice: Successful start on (%x)\n",
                      DeviceObject));
        status = Irp->IoStatus.Status;
    } else {

        MPDebugPrint((2,
                      "MPIOStartDevice: Failure (%x) start on (%x)\n",
                      status,
                      DeviceObject));
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;


}    


NTSTATUS
MPIOQDR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{

    PDEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_RELATIONS  deviceRelations;
    PLIST_ENTRY entry;
    PDISK_ENTRY diskEntry;
    NTSTATUS    status;
    ULONG allocationLength;
    ULONG i;

    if (irpStack->Parameters.QueryDeviceRelations.Type == BusRelations) {

        //
        // Allocate enough memory for NumberDevices.
        //
        allocationLength = (controlExtension->NumberDevices - 1) * sizeof(PDEVICE_OBJECT);
        allocationLength += sizeof(DEVICE_RELATIONS);

        deviceRelations = ExAllocatePool(PagedPool, allocationLength);
        if (deviceRelations == NULL) {
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(deviceRelations, allocationLength);

        //
        // Fill in the structure.
        //
        deviceRelations->Count = controlExtension->NumberDevices;
        
        for (i = 0; i < controlExtension->NumberDevices; i++) {
            diskEntry = MPIOGetDiskEntry(DeviceObject,
                                         i);
            ASSERT(diskEntry);
            deviceRelations->Objects[i] = diskEntry->PdoObject;
            ObReferenceObject(deviceRelations->Objects[i]);
        }

        //
        // Link it in and set status.
        //
        Irp->IoStatus.Information = (ULONG_PTR)deviceRelations;
        Irp->IoStatus.Status = STATUS_SUCCESS;

        MPDebugPrint((2,
                      "MPIOQDR: Returned %x children. List %x\n",
                      controlExtension->NumberDevices,
                      deviceRelations));

    } 

    //
    // Send it down.
    //
    return MPIOForwardRequest(DeviceObject, Irp);
}


NTSTATUS
MPIOQueryId(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles QueryId irps for the FDO (Control).
    Used by PnP to determine the id's used to locate the inf.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;
    PWCHAR idString;
    PWCHAR returnString;
    ULONG length;
    ULONG size;

    switch (irpStack->Parameters.QueryId.IdType) {
        case BusQueryHardwareIDs:
            idString = L"ROOT\\MPIO";
            break;

        case BusQueryDeviceID:
            idString = L"ROOT\\MPIO";
            break;

        case BusQueryInstanceID:
            idString = L"0000";
            break;
        default:
            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver(deviceExtension->LowerDevice, Irp);

    }

    status = STATUS_SUCCESS;

    length = wcslen(idString);
    size = (length + 2) * sizeof(WCHAR);

    //
    // Allocate storage for the id string
    // 
    returnString = ExAllocatePool(PagedPool, size);
    if (returnString == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
    } else {

        //
        // Copy it over
        //
        RtlZeroMemory(returnString, size);
        wcscpy(returnString, idString);
   
        //
        // Link it in, set status and send it down.
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = (ULONG_PTR)returnString;
    }
    Irp->IoStatus.Status = status;
    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(deviceExtension->LowerDevice, Irp);

}


NTSTATUS
MPIOFdoPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles PnP irps for the FDO (Control).

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    KEVENT event;
    NTSTATUS status;

    switch (irpStack->MinorFunction) {
        case IRP_MN_STOP_DEVICE:

            //
            // Call the Stop handler.
            //
            return MPIOStopDevice(DeviceObject,
                                  Irp);

        case IRP_MN_START_DEVICE:

            //
            // 'Start' the FDO.
            //
            return MPIOStartDevice(DeviceObject,
                                   Irp);

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            //
            // Build the list of children based on the current state of the world.
            //
            return MPIOQDR(DeviceObject,
                           Irp);

        case IRP_MN_QUERY_ID: 

            //
            // Call the QueryId routine. It will handle completion
            // of the request.
            //
            return MPIOQueryId(DeviceObject,
                               Irp);
        
        case IRP_MN_QUERY_DEVICE_TEXT:
            MPDebugPrint((2,
                         "Got QueryDeviceText\n"));
        default:
            MPDebugPrint((2,
                          "MPIOFdoPnP: Default handler for Control (%x)\n",
                          irpStack->MinorFunction));
            return MPIOForwardRequest(DeviceObject, Irp);
    }
}


NTSTATUS
MPIOFdoPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles Power irps for the FDO (Control). It'm main
    function is to sync up state with the adapter filter drivers.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    //
    // TODO: Everything.
    //
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    status = PoCallDriver(deviceExtension->LowerDevice, Irp);
    return status;
}


NTSTATUS
MPIOQueryPdo(
    IN PDEVICE_OBJECT ControlObject,    
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine determines whether the D.O. passed in the system buffer
    is one that mpctl created, or a real scsiport pdo.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_SUCCESS - if the D.O. is a child of mpctl
    

--*/
{
    PDEVICE_EXTENSION deviceExtension = ControlObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PMPIO_PDO_QUERY pdoQuery = Irp->AssociatedIrp.SystemBuffer;
    PDISK_ENTRY diskEntry;
    ULONG i;
    
    //
    // Run the disk list to see whether this one is real
    // or one of ours.
    //
    for (i = 0; i < controlExtension->NumberDevices; i++) {

        //
        // Get the next diskEntry.
        //
        diskEntry =  MPIOGetDiskEntry(ControlObject,
                                      i);

        MPDebugPrint((2,
                      "MPIOQueryPdo: Checking (%x) against QueryObject (%x)",
                      diskEntry->PdoObject,
                      pdoQuery->DeviceObject));
                      
        //
        // The PdoObject is the D.O. for an MPDisk, 
        // if the D.O. passed in from mpdev is the same, then
        // the filter should not load on this. Indicate the 'failure' 
        // as success.
        //
        if (diskEntry->PdoObject == pdoQuery->DeviceObject) {
            MPDebugPrint((2,
                          " -> Matched. Returning SUCCESS\n"));
            return STATUS_UNSUCCESSFUL;
        } else {

            MPDebugPrint((2,
                          " -> No Match\n"));
        }    
    }

    return STATUS_SUCCESS;
}


NTSTATUS
MPIODeviceRegistration(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles the initial registration of a device filter
    by matching up scsiport pdo, with MPDisk PDO.

Arguments:

    DeviceObject
    Irp

Return Value:

    STATUS_SUCCESS - if the LowerDevice was found in a MPDisk PDO's internal
                     structures.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PMPIO_REG_INFO deviceReg = Irp->AssociatedIrp.SystemBuffer;
    PMPIO_REG_INFO regInfo = Irp->AssociatedIrp.SystemBuffer;
    PDEVICE_OBJECT lowerDevice;
    PDEVICE_OBJECT targetDevice;
    PDISK_ENTRY diskEntry;
    NTSTATUS status;
    ULONG i;
    BOOLEAN found = FALSE;

    lowerDevice = deviceReg->LowerDevice;
    targetDevice = deviceReg->FilterObject;
    
    //
    // Find the corresponding MPDisk for the 'LowerDevice'.
    // Call the magic routine with each of the MP PDO's, along with LowerDevice
    // It will return TRUE is the MP PDO controls it.
    //
    for (i = 0; i < controlExtension->NumberDevices; i++) {

        //
        // Get the next diskEntry.
        //
        diskEntry =  MPIOGetDiskEntry(DeviceObject,
                                      i);

        //
        // Attempt to find a match for the newly arrived DO.
        //
        found = MPIOFindLowerDevice(diskEntry->PdoObject,
                                    lowerDevice);
        if (found == TRUE) {

            //
            // Indicate to the dev filter the MPDisk that
            // it talks to.
            //
            regInfo->MPDiskObject = diskEntry->PdoObject;
                
            break;
        }
    }

    if (found == FALSE) {
        status = STATUS_NO_SUCH_DEVICE;
    } else {
        status = STATUS_SUCCESS;
        
        //
        // Fill in the rest.
        // Defined in pdo.c
        //
        regInfo->DevicePdoRegister = MPIOPdoRegistration;
        Irp->IoStatus.Information = sizeof(MPIO_REG_INFO);
    }    

    //
    // The caller will fill in status and complete the request.
    //
    return status;
}


NTSTATUS
MPIOAdpPnpNotify(
    IN PDEVICE_OBJECT ControlObject,
    IN PDEVICE_OBJECT FilterObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles PnP notifications that originate from the Adapter Filter.
    It checks the Minor function and notifies the filter(s) on what action to take

Arguments:

    ControlObject - Mpctl's D.O.
    FilterObject - The filter D.O.
    Irp - The pnp irp sent to FilterObject

Return Value:

    

--*/
{

    //
    // TODO: Determine how best to handle this. 
    //
    return STATUS_SUCCESS;
}


NTSTATUS
MPIOAdpPowerNotify(
    IN PDEVICE_OBJECT ControlObject,
    IN PDEVICE_OBJECT FilterObject,
    IN PIRP Irp 
    )
/*++

Routine Description:

    This routine handles Power notifications that originate from the Adapter Filter.
    It checks the Minor function and notifies the filter(s) on what action to take

Arguments:

    ControlObject - Mpctl's D.O.
    FilterObject - The filter D.O.
    Irp - The power irp sent to FilterObject

Return Value:

    status of the helper routines.

--*/
{

    //
    // TODO: Determine how best to handle this. 
    //
    return STATUS_SUCCESS;
}


PDEVICE_RELATIONS
MPIOBuildRelations(
    IN PADP_DEVICE_LIST DeviceList
    )
{
    PDEVICE_RELATIONS relations;
    ULONG relationsSize;
    ULONG i;
    ULONG numberDevices = DeviceList->NumberDevices;

    //
    // Determine the size needed.
    // 
    relationsSize = sizeof(DEVICE_RELATIONS);
    relationsSize += (sizeof(PDEVICE_OBJECT) * numberDevices - 1);
    
    relations = ExAllocatePool(NonPagedPool, relationsSize);
    RtlZeroMemory(relations, relationsSize);

    //
    // Copy over the D.O.s
    // 
    relations->Count = DeviceList->NumberDevices;
    for (i = 0; i < numberDevices; i++) {
        relations->Objects[i] = DeviceList->DeviceList[i].DeviceObject;
    }
    return relations;
}    
    

BOOLEAN
MPIODetermineDeviceArrival(
    IN PADP_DEVICE_LIST DeviceList,
    IN PDEVICE_RELATIONS CachedRelations,
    IN PDEVICE_RELATIONS NewCachedRelations
    )
{
    ULONG oldCount;
    ULONG newCount;
    ULONG i;

    oldCount = CachedRelations->Count;
    newCount = NewCachedRelations->Count;

    if (newCount > oldCount) {

        //
        // This always indicates a new device(s).
        // 
        return TRUE;
    }

    //
    // Check the weird case where the objects are differnet,
    // but count remains the same (or is less).
    // TODO
    //
    return FALSE;
}


NTSTATUS
MPIOAdpDeviceNotify(
    IN PDEVICE_OBJECT ControlObject,
    IN PDEVICE_OBJECT FilterObject,
    IN PDEVICE_OBJECT PortObject,
    IN PADP_DEVICE_LIST DeviceList
    )
/*++

Routine Description:

    This routine is called by the FilterObject when a QDR has occurred. It passes in a list
    of disk PDO's for processing.
    
Arguments:

    ControlObject - The Mpctl DO
    FilterObject - The adapter filter's DO
    DeviceList - List of PDO's and associated structs.

Return Value:

   

--*/
{
    PDEVICE_EXTENSION deviceExtension = ControlObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PDSM_ENTRY entry;
    PDISK_ENTRY diskEntry;
    NTSTATUS status;
    PVOID dsmExtension;
    PFLTR_ENTRY fltrEntry;
    ULONG numberDevices = DeviceList->NumberDevices;
    PDEVICE_RELATIONS cachedRelations;
    PDEVICE_RELATIONS newCachedRelations;
    BOOLEAN newList = FALSE;
    BOOLEAN added = FALSE;
  
    //
    // First, run through the lists and find out if any devices
    // have been removed.
    // Round One will be handling a removed path - ALL devices are gone.
    //
 
    //
    // Get the cached info, to see whether something has been removed.
    //
    fltrEntry = MPIOGetFltrEntry(ControlObject,
                                 PortObject,
                                 NULL);

    ASSERT(fltrEntry);

    //
    // See whether there is already a relations struct.
    // 
    cachedRelations = fltrEntry->CachedRelations;
    if (cachedRelations == NULL) {

        cachedRelations = MPIOBuildRelations(DeviceList);
        
        //
        // Update the filter entry with the relations.
        // 
        fltrEntry->CachedRelations = cachedRelations;
        newCachedRelations = cachedRelations;
        
        //
        // Indicate that this is the 'original' list.
        //
        newList = TRUE;
        added = TRUE;

    } else {

        //
        // Determine if any devices need to be removed.
        // If so, this routine will handle it.
        //
        newCachedRelations = MPIOHandleDeviceRemovals(ControlObject,
                                                      DeviceList,
                                                      cachedRelations);
        //
        // Update the cachedRelations to reflect the new state.
        //
        fltrEntry->CachedRelations = newCachedRelations;

        //
        // This is an update.
        //
        newList = FALSE;

        //
        // Determine whether any devices have been added.
        //
        added = MPIODetermineDeviceArrival(DeviceList,
                                           cachedRelations,
                                           newCachedRelations);

    }


    if (added) {

        if (fltrEntry->Flags & FLTR_FLAGS_NEED_RESCAN) {
            
            //
            // Indicate that the rescan is complete.
            // 
            fltrEntry->Flags &= ~FLTR_FLAGS_RESCANNING;

            //
            // Clear the complete flags. The timer will handle
            // setting it.
            // 
            fltrEntry->Flags &= ~FLTR_FLAGS_QDR_COMPLETE;

            //
            // Indicate that this adapter had a QDR.
            //
            fltrEntry->Flags |= FLTR_FLAGS_QDR;
            MPDebugPrint((0,
                         "DeviceNotify: Flags (%x) on (%x)\n",
                         fltrEntry->Flags,
                         fltrEntry));
        }
        
        //
        // Handle dealing with any new objects.
        //
        status = MPIOHandleDeviceArrivals(ControlObject,
                                          DeviceList,
                                          cachedRelations,
                                          newCachedRelations,
                                          PortObject,
                                          FilterObject,
                                          newList);
    }

    if (newList == FALSE) {

        //
        // Free the old stuff.
        //
        ExFreePool(cachedRelations);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
MPIOAdapterRegistration(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the main dispatch routine for Internal Device Controls sent
    to the FDO (Control). The control codes are those known to the device and adapter
    filters and to the DSMs.

Arguments:

    DeviceObject
    Irp

Return Value:

    status of the helper routines.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PADAPTER_REGISTER adapterReg = Irp->AssociatedIrp.SystemBuffer;
    PFLTR_ENTRY fltrEntry;

    //
    // Allocate an entry for this filter.
    //
    fltrEntry = ExAllocatePool(NonPagedPool, sizeof(FLTR_ENTRY));
    if (fltrEntry == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(fltrEntry, sizeof(FLTR_ENTRY));

    fltrEntry->FilterObject = adapterReg->FilterObject;
    fltrEntry->PortFdo = adapterReg->PortFdo;
    fltrEntry->FltrGetDeviceList = adapterReg->FltrGetDeviceList;

    //
    // Add it to the list
    //
    ExInterlockedInsertTailList(&controlExtension->FilterList,
                                &fltrEntry->ListEntry,
                                &controlExtension->SpinLock);

    InterlockedIncrement(&controlExtension->NumberFilters);
    //
    // Fill in the entry points for the filter
    //
    adapterReg->PnPNotify = MPIOAdpPnpNotify;
    adapterReg->PowerNotify = MPIOAdpPowerNotify;
    adapterReg->DeviceNotify = MPIOAdpDeviceNotify;

    //
    // set Information
    //
    Irp->IoStatus.Information = sizeof(ADAPTER_REGISTER);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    
    return STATUS_SUCCESS;
}


NTSTATUS
MPIODsmRegistration(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PDSM_INIT_DATA initData = Irp->AssociatedIrp.SystemBuffer;
    PDSM_MPIO_CONTEXT context = Irp->AssociatedIrp.SystemBuffer;
    PDSM_ENTRY dsmEntry;
    PLIST_ENTRY oldEntry;
    PDSM_ENTRY oldDsm;
    WCHAR buffer[64];

    ASSERT(initData->InitDataSize == sizeof(DSM_INIT_DATA));

    //
    // Allocate an entry for the DSM Info.
    //
    dsmEntry = ExAllocatePool(NonPagedPool, sizeof(DSM_ENTRY));
    if (dsmEntry == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(dsmEntry, sizeof(DSM_ENTRY));

    //
    // Extract the info from the DSM's buffer.
    //
    dsmEntry->InquireDriver = initData->DsmInquireDriver;
    dsmEntry->CompareDevices = initData->DsmCompareDevices;
    dsmEntry->SetDeviceInfo = initData->DsmSetDeviceInfo;
    dsmEntry->GetControllerInfo = initData->DsmGetControllerInfo;
    dsmEntry->IsPathActive = initData->DsmIsPathActive;
    dsmEntry->InvalidatePath = initData->DsmInvalidatePath;
    dsmEntry->PathVerify = initData->DsmPathVerify;
    dsmEntry->RemovePending = initData->DsmRemovePending;
    dsmEntry->RemoveDevice = initData->DsmRemoveDevice;
    dsmEntry->RemovePath = initData->DsmRemovePath;
    dsmEntry->SrbDeviceControl = initData->DsmSrbDeviceControl;
    dsmEntry->ReenablePath = initData->DsmReenablePath;
    dsmEntry->GetPath = initData->DsmLBGetPath;
    dsmEntry->InterpretError = initData->DsmInterpretError;
    dsmEntry->Unload = initData->DsmUnload;
    dsmEntry->SetCompletion = initData->DsmSetCompletion;
    dsmEntry->CategorizeRequest = initData->DsmCategorizeRequest;
    dsmEntry->BroadcastSrb = initData->DsmBroadcastSrb;
    RtlCopyMemory(&dsmEntry->WmiContext,
                  &initData->DsmWmiInfo,
                  sizeof(DSM_WMILIB_CONTEXT));
            
    dsmEntry->DsmContext = initData->DsmContext;

    //
    // Build the Name string.
    //
    dsmEntry->DisplayName.Buffer = ExAllocatePool(NonPagedPool,
                                                  initData->DisplayName.MaximumLength);
    RtlZeroMemory(dsmEntry->DisplayName.Buffer, 
                  initData->DisplayName.MaximumLength);
    dsmEntry->DisplayName.Length = initData->DisplayName.Length;
    dsmEntry->DisplayName.MaximumLength = initData->DisplayName.MaximumLength;
    
    RtlCopyUnicodeString(&dsmEntry->DisplayName,
                         &initData->DisplayName);

    //
    // Add it to the list
    //
    if (initData->Reserved == (ULONG)-1) {

        //
        // Gendsm goes to the end of the list.
        //
        oldEntry = ExInterlockedInsertTailList(&controlExtension->DsmList,
                                    &dsmEntry->ListEntry,
                                    &controlExtension->SpinLock);
        MPDebugPrint((1,
                     "Loading it Last. dsmEntry was (%x)\n",
                     CONTAINING_RECORD(oldEntry, DSM_ENTRY, ListEntry)));
    } else {

        oldEntry = ExInterlockedInsertHeadList(&controlExtension->DsmList,
                                               &dsmEntry->ListEntry,
                                               &controlExtension->SpinLock);
        MPDebugPrint((1,
                     "Loading it first. dsmEntry was (%x)\n",
                     CONTAINING_RECORD(oldEntry, DSM_ENTRY, ListEntry)));
    }    
   
    //
    // Update the list count.
    //
    InterlockedIncrement(&controlExtension->NumberDSMs);
    
    //
    // Set-up the return buffer
    //
    context->MPIOContext = DeviceObject;

    //
    // Set Information
    //
    Irp->IoStatus.Information = sizeof(DSM_MPIO_CONTEXT);

    swprintf(buffer, L"DSM %ws, registered.", dsmEntry->DisplayName.Buffer);
    MPIOFireEvent(DeviceObject,        
                  L"MPIO", 
                  buffer,
                  MPIO_INFORMATION);
    
    return STATUS_SUCCESS;
}


NTSTATUS
MPIOFdoInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the main dispatch routine for Internal Device Controls sent
    to the FDO (Control). The control codes are those known to the device and adapter
    filters and to the DSMs.

Arguments:

    DeviceObject
    Irp

Return Value:

    status of the helper routines.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;


    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_MPDEV_QUERY_PDO:
            
            //
            // Mpdev sends this request to determine if the PDO given it
            // in it's AddDevice is a real D.O., or an MPDisk.
            // 
            status = MPIOQueryPdo(DeviceObject,
                                  Irp);
            break;
            
        case IOCTL_MPDEV_REGISTER:

            //
            // Mpdev sends this on an AddDevice to notify that
            // an instatiation of the filter has arrived.
            //
            status = MPIODeviceRegistration(DeviceObject,
                                            Irp);
            break;

        case IOCTL_MPADAPTER_REGISTER:

            //
            // Mpspfltr sens this on it's AddDevice to notify that
            // it has arrived.
            //
            status = MPIOAdapterRegistration(DeviceObject,
                                             Irp);
            break;

        case IOCTL_MPDSM_REGISTER:

            //
            // A DSM has loaded. Handle getting it's entry point info.
            //
            status = MPIODsmRegistration(DeviceObject,
                                         Irp);
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

    }        

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\control\mpio.c ===
/*++

Copyright (C) 1999-2000  Microsoft Corporation

Module Name:

    mpath.c

Abstract:

    The main multi-path module. Provides fault tolerance across adapter/path failures.

Author:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include <ntddk.h>
#include "stdarg.h"
#include "stdio.h"
#include "mpio.h"


//
// Entry point decl's.
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
MPIOGlobalDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPIOAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
MPIOCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPIOClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPIOWmiDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPIOUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );

typedef
NTSTATUS
(*PMPIO_DISPATCH) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PMPIO_CONTEXT Context
    );
// PMPIO_DISPATCH PdoDispatch[IRP_MJ_MAXIMUM_FUNCTION];
PDRIVER_DISPATCH PdoDispatch[IRP_MJ_MAXIMUM_FUNCTION];
PDRIVER_DISPATCH FdoDispatch[IRP_MJ_MAXIMUM_FUNCTION];

NTSTATUS
MPIOPdoDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG State
    );

BOOLEAN DoASSERT = TRUE;


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is called when the driver loads loads.

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS status;
    PDEVICE_OBJECT pdo;
    ULONG i;

    MPDebugPrint((0,
                  "MPIO: Driver Entry\n"));

    if (DontLoad) {
        return STATUS_NO_SUCH_DEVICE;
    }
    //
    // Register the entry points for all IRP_MJ's.
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE] = MPIOCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = MPIOClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = MPIOGlobalDispatch;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = MPIOGlobalDispatch;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = MPIOGlobalDispatch;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS] = MPIOGlobalDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP] = MPIOGlobalDispatch;
    DriverObject->MajorFunction[IRP_MJ_POWER] = MPIOGlobalDispatch;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = MPIOWmiDispatch;

    //
    // Register the Unload.
    //
    DriverObject->DriverUnload = MPIOUnload;

    ObReferenceObject(DriverObject);

    pdo = NULL;

    //
    // Notify PnP that this 'device' was found. 
    // Indicate no resources, no bus location, and lie that
    // resources were reported (as we need none).
    //
    status = IoReportDetectedDevice(DriverObject,
                                    InterfaceTypeUndefined,
                                    -1,
                                    -1,
                                    NULL,
                                    NULL,
                                    TRUE,
                                    &pdo);

    if (!NT_SUCCESS(status)) {
        MPDebugPrint((0,
                    "Multipath DriverEntry: IoReportDetectedDevice returned (%x)\n",
                    status));
        ObDereferenceObject(DriverObject);
        return status;
    }

    //
    // Create the fdo. Not really an AddDevice routine
    // but name it as such.
    //
    status = MPIOAddDevice(DriverObject,
                           pdo);

    if (!NT_SUCCESS(status)) {
        MPDebugPrint((0,
                    "MPIO DriverEntry: AddDevice failed (%x)\n",
                    status));
        ObDereferenceObject(DriverObject);
        return status;
    }

    //
    // Get deviceObject (fdo) and deviceExtension.
    //
    deviceObject = IoGetAttachedDeviceReference(pdo);
    ObDereferenceObject(deviceObject);

    deviceExtension = deviceObject->DeviceExtension;

    //
    // Setup the device extension.
    //
    deviceExtension->Pdo = pdo;
    deviceExtension->RegistryPath.Buffer = ExAllocatePool(NonPagedPool,
                                                          RegistryPath->MaximumLength);
    deviceExtension->RegistryPath.MaximumLength = RegistryPath->MaximumLength;
    RtlCopyUnicodeString(&deviceExtension->RegistryPath,
                         RegistryPath);

    //
    // Setup the Pdo's dispatch routines.
    //
    for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {
        PdoDispatch[i] = MPIOPdoUnhandled;
    }

    PdoDispatch[IRP_MJ_DEVICE_CONTROL] = MPIOPdoDeviceControl;
    PdoDispatch[IRP_MJ_INTERNAL_DEVICE_CONTROL] = MPIOPdoInternalDeviceControl;
    PdoDispatch[IRP_MJ_PNP] = MPIOPdoPnp;
    PdoDispatch[IRP_MJ_POWER] = MPIOPdoPower;

    MPathDebug = 1;
    return status;
}


NTSTATUS
MPIOAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates and initializes a new FDO for the corresponding
    PDO.

Arguments:

    DriverObject            - Supplies the driver object for mpath control.

    PhysicalDeviceObject    - Supplies the physical device object.

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    PCONTROL_EXTENSION controlExtension;
    UNICODE_STRING deviceName;
    UNICODE_STRING dosName;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS       status;

    RtlInitUnicodeString(&deviceName, DD_MULTIPATH_CONTROL_DEVICE_NAME);

    //
    // Create the fdo.
    //
    status = IoCreateDevice(DriverObject,
                            sizeof(DEVICE_EXTENSION),
                            &deviceName,
                            FILE_DEVICE_CONTROLLER,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &deviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    controlExtension = ExAllocatePool(NonPagedPool, sizeof(CONTROL_EXTENSION));
    if (controlExtension == NULL) {
        IoDeleteDevice(deviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(controlExtension, sizeof(CONTROL_EXTENSION));
            
    //
    // Create the symbolic link.
    //
    RtlInitUnicodeString(&dosName, DD_MULTIPATH_CONTROL_DOS_NAME);
    IoCreateSymbolicLink( &dosName, &deviceName);

    //
    // Save off devObj and build the device extension.
    //
    deviceExtension = deviceObject->DeviceExtension;
    deviceExtension->Type = MPIO_CONTROL;
    deviceExtension->DeviceObject = deviceObject;
    deviceExtension->DriverObject = DriverObject;

    //
    // Attach to the pdo.
    //
    deviceExtension->LowerDevice = IoAttachDeviceToDeviceStack(deviceObject,
                                                               PhysicalDeviceObject);
    if (deviceExtension->LowerDevice == NULL) {
        IoDeleteSymbolicLink(&dosName);
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }

    deviceExtension->Pdo = PhysicalDeviceObject;
    deviceExtension->TypeExtension = controlExtension;

    //
    // Initialize the 'control' portion of the device extension.
    //
    KeInitializeSpinLock(&controlExtension->SpinLock);
    InitializeListHead(&controlExtension->FilterList);
    InitializeListHead(&controlExtension->DeviceList);
    InitializeListHead(&controlExtension->DsmList);
    InitializeListHead(&controlExtension->IdList);
    InitializeListHead(&controlExtension->ControllerList);
    InitializeListHead(&controlExtension->FailPacketList);

    //
    // Set-up the WMILIB Context.
    // 
    MPIOSetupWmi(deviceObject);
    
    //
    // Register as a WMI provider.
    //
    IoWMIRegistrationControl(deviceObject,
                             WMIREG_ACTION_REGISTER);

    //
    // Indicate that this device is ready.
    //
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    return status;
}


NTSTATUS
MPIOCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_CREATE.

Arguments:

    DeviceObject - Supplies the device object.
    Irp          - Supplies the IO request block.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
MPIOClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_CLOSE

Arguments:

    DeviceObject - Supplies the device object.
    Irp          - Supplies the IO request block.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
MPIOUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )
/*++

Routine Description:

    This routine unloads.

Arguments:

    DriverObject    - Supplies the driver object.

Return Value:

    None.

--*/

{
    //
    // TODO: Release all allocations.
    // TODO: Ensure pdo's/DSMs have been torndown.
    //
    ObDereferenceObject(DriverObject);
    return STATUS_SUCCESS;
}



NTSTATUS
MPPdoGlobalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    All requests to the pdo's have this as the completion. It handles calling out to
    the function-specific completions and deals with errors.

Arguments:


Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDSM_ENTRY dsm = &diskExtension->DsmInfo; 
    PMPIO_CONTEXT context = Context;
    PSCSI_REQUEST_BLOCK srb = NULL;
    PMPIO_COMPLETION_ROUTINE specificCompletion;
    PKDEVICE_QUEUE_ENTRY entry;
    PREAL_DEV_INFO targetInfo;
    PREAL_DEV_INFO newTargetInfo;
    PDEVICE_OBJECT targetObject;
    NTSTATUS status;
    NTSTATUS status2;
    PVOID dsmId;
    PVOID dsmContext;
    DSM_COMPLETION_ROUTINE dsmCompletion;
    ULONG errorMask = 0;
    ULONG completionState =  context->CurrentState;
    ULONG state;
    ULONG state2;
    LONG outstandingRequests;
    LONG deviceRequests;
    BOOLEAN fatal = FALSE;
    BOOLEAN retry = FALSE;
    BOOLEAN needsRemoval = FALSE;
    BOOLEAN currentRequestHandled;
    

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }
   
    //
    // Get the targetInfo. This describes the device.
    //
    targetInfo = context->TargetInfo;

    //
    // Get the number of requests on THIS device (vs. the entire disk).
    //
    deviceRequests = InterlockedDecrement(&targetInfo->Requests);

    //
    // One less request below us.
    //
    outstandingRequests = InterlockedDecrement(&diskExtension->OutstandingRequests);
    ASSERT(diskExtension->OutstandingRequests >= 0);
    if ((outstandingRequests == 0) && (deviceRequests != 0)) {

        //
        // If there are no requests for the disk, then there shouldn't be any of this
        // deviceInfo.
        //
        if (DoASSERT) {
            MPDebugPrint((0,
                         "GlobalCompletion: DeviceRequests (%x)\n",
                         deviceRequests));

            ASSERT(deviceRequests == 0);
        }
    }

    //
    // Get the config. spinlock.
    //
    KeAcquireSpinLockAtDpcLevel(&diskExtension->SpinLock);

    //
    // See whether there is a remove pending on this targetInfo.
    //
    if (targetInfo->NeedsRemoval) {
        needsRemoval = TRUE;
    }
    KeReleaseSpinLockFromDpcLevel(&diskExtension->SpinLock);
    
    //
    // For scsi requests, need to ensure that frozen queues
    // get released.
    // 
    if (irpStack->MajorFunction == IRP_MJ_SCSI) {

        //
        // Get the srb.
        //
        srb = irpStack->Parameters.Scsi.Srb;
        
        //
        // Handle any frozen queue stuff.
        //
        if (srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {

            //
            // Get the target object for this request.
            // NOTE: This assumes that the Function-Specific handler
            // has set this up correctly.
            //
            targetObject = targetInfo->PortPdo;

            MPLibReleaseQueue(targetObject);
        }
    }

    //
    // Extract the DSM-Specific stuff from the context.
    //
    dsmId = targetInfo->DsmID;
    dsmContext = context->DsmCompletion.DsmContext;
    dsmCompletion = context->DsmCompletion.DsmCompletionRoutine;

    // 
    //
    // Determine the current state.
    //
    state = deviceExtension->State;
    if ((deviceExtension->CompletionState == MPIO_STATE_NORMAL) ||
        (deviceExtension->CompletionState == MPIO_STATE_DEGRADED)) {
        
        deviceExtension->CompletionState = state;
    }

    //
    // Indicate that this request hasn't been dealt with yet.
    //
    currentRequestHandled = FALSE;

    //
    // This call will update state information, but the request coming in
    // needs to be first handled with the current state.
    //
    state2 = MPIOHandleStateTransition(DeviceObject); 
    
runState:
    
    if ((state != MPIO_STATE_NORMAL) && (state != MPIO_STATE_DEGRADED)) {

        switch (state) {
            case MPIO_STATE_IN_FO:    

                //
                // The fail-over is being executed. Put on resubmit Queue. (unless
                // status == success.
                //
                status2 = MPIOQueueRequest(DeviceObject,
                                           Irp,
                                           Context,
                                           &diskExtension->ResubmitQueue);
               
                state = MPIOHandleStateTransition(DeviceObject);
                
                if (state != MPIO_STATE_IN_FO) {
                    MPDebugPrint((0,
                                  "GlobalCompletion: Going from IN_FO to (%x)\n",
                                  state));
                    
                    //
                    // See if we've gone into WAIT2 directly.
                    //
                    if (state == MPIO_STATE_WAIT2) {

                        //
                        // Get the targetInfo corresponding to the path set-up in the
                        // fail-over handler. Whatever was in the completion context is
                        // probably not valid.
                        // NOTE: This assumes that no-one is updating the CurrentPath
                        // in the diskExtension. Probably not a good assumption.
                        // TODO: Validate.
                        // 
                        targetInfo = MPIOGetTargetInfo(diskExtension,
                                                       diskExtension->CurrentPath,
                                                       NULL);

                        //
                        // Submit the queued requests. These Resubmit requests all go
                        // down "newPath". TODO: Indicate this behaviour in dsm.h
                        //
                        status = MPIOIssueQueuedRequests(targetInfo,
                                                         &diskExtension->ResubmitQueue,
                                                         MPIO_STATE_WAIT2,
                                                         &diskExtension->OutstandingRequests);
                    } else {
                
                        //
                        // Went into WAIT1. 
                        //
                        currentRequestHandled = TRUE;
                        goto runState;
                    }
                }    
                    
                if (needsRemoval && (deviceRequests == 0)) {

                    MPDebugPrint((0,
                                  "MPIOGlobalCompletion (IN_FO): Removing %x\n",
                                  targetInfo));
                    //
                    // This routine will queue a work item to handle the device removal.
                    // 
                    MPIOHandleRemoveAsync(DeviceObject,
                                          targetInfo);
                }

                return STATUS_MORE_PROCESSING_REQUIRED;
                break;

            case MPIO_STATE_WAIT1: {
                                       
                //
                // This indicates that the fail-over was successful, but there
                // are still outstanding requests (on the failed path).
                // Status should be flushed, or some error condition, though
                // conceivable, a successful completion could have occurred.
                // One less request below us.
                //
                if (currentRequestHandled == FALSE) {

                    //
                    // Enqueue this request on the Resubmit Queue.
                    // 
                    status2 = MPIOQueueRequest(DeviceObject,
                                               Irp,
                                               Context,
                                               &diskExtension->ResubmitQueue);
                    if (needsRemoval && (deviceRequests == 0)) {

                        MPDebugPrint((0,
                                      "MPIOGlobalCompletion (WAIT1): Removing %x\n",
                                      targetInfo));
                        //
                        // This routine will queue a work item to handle the device removal.
                        // 
                        MPIOHandleRemoveAsync(DeviceObject,
                                              targetInfo);
                    }
                }

                //
                // See if the has caused a move into a different state.
                // 
                state = MPIOHandleStateTransition(DeviceObject);
                if (state != MPIO_STATE_WAIT1) {
                    MPDebugPrint((0,
                                  "GlobalCompletion: Going from WAIT1 to (%x)\n",
                                  state));

                    //
                    // See if we've gone into WAIT2 directly.
                    //
                    if (state == MPIO_STATE_WAIT2) {

                        //
                        // Get the targetInfo corresponding to the path set-up in the
                        // fail-over handler. Whatever was in the completion context is
                        // probably not valid.
                        // NOTE: This assumes that no-one is updating the CurrentPath
                        // in the diskExtension. Probably not a good assumption.
                        // TODO: Validate.
                        // 
                        targetInfo = MPIOGetTargetInfo(diskExtension,
                                                       diskExtension->CurrentPath,
                                                       NULL);

                        //
                        // Submit the queued requests. These Resubmit requests all go
                        // down "newPath". TODO: Indicate this behaviour in dsm.h
                        //
                        status = MPIOIssueQueuedRequests(targetInfo,
                                                         &diskExtension->ResubmitQueue,
                                                         MPIO_STATE_WAIT2,
                                                         &diskExtension->OutstandingRequests);
                    } else {
                        
                        currentRequestHandled = TRUE;
                        goto runState;
                    }
                }
                

                return STATUS_MORE_PROCESSING_REQUIRED;
                break;
            }
            case MPIO_STATE_WAIT2: {
                                       
                // 
                // Dec the # of resubmit requests when zero, we go into WAIT3.
                // New requests on FOQ.
                // 
                outstandingRequests = InterlockedDecrement(&diskExtension->ResubmitRequests);
                ASSERT(diskExtension->ResubmitRequests >= 0);
           
                state = MPIOHandleStateTransition(DeviceObject);
                if (state != MPIO_STATE_WAIT2) {
                    MPDebugPrint((0,
                                  "GlobalCompletion: Going from WAIT2 to (%x)\n",
                                  state));

                    if (state == MPIO_STATE_WAIT3) {
                        
                        //
                        // Get the targetInfo corresponding to CurrentPath.
                        //
                        targetInfo = MPIOGetTargetInfo(diskExtension,
                                                       diskExtension->CurrentPath,
                                                       NULL);

                        //
                        // Process the Fail-Over queue.
                        // 
                        status2 = MPIOIssueQueuedRequests(targetInfo,
                                                          &diskExtension->FailOverQueue,
                                                          MPIO_STATE_WAIT3,
                                                          &diskExtension->OutstandingRequests);
                    }
                } 

                if (!NT_SUCCESS(Irp->IoStatus.Status)) {
                    MPDebugPrint((0,
                                  "MPIOCompletion: !Success while in WAIT2. Irp (%x) Status (%x)\n",
                                  Irp,
                                  Irp->IoStatus.Status));
                }
                
                //
                // Now, handle the request normally.
                // 
                break;
            }   
            case MPIO_STATE_WAIT3: {

                // 
                // Dec the # of fail-over requests. When zero, we go into DEGRADED.
                // 
                outstandingRequests = InterlockedDecrement(&diskExtension->FailOverRequests);
                ASSERT(diskExtension->FailOverRequests >= 0);

                state = MPIOHandleStateTransition(DeviceObject);

                
                //
                // Continue down and handle the request normally.
                //
                break;
            }                           
            default:
                //
                // Invalid state.
                //
                MPDebugPrint((0,
                              "MPIOCompletion: Unknown State (%x)\n",
                              state));
                DbgBreakPoint();
                break;
                
        }    
    } else {

        if (needsRemoval && (deviceRequests == 0)) {

            MPDebugPrint((0,
                          "MPIOGlobalCompletion (WAIT1): Removing %x\n",
                          targetInfo));
            //
            // This routine will queue a work item to handle the device removal.
            // 
            MPIOHandleRemoveAsync(DeviceObject,
                                  targetInfo);
        }
    }    
    
    status = Irp->IoStatus.Status;

    if (!NT_SUCCESS(status)) {

        fatal = FALSE;
        retry = FALSE;

        if (irpStack->MajorFunction == IRP_MJ_SCSI) {

            //
            // Invoke the DSM's InterpretError with preset fatal and retry
            // values.
            // 
            errorMask = dsm->InterpretError(dsm->DsmContext,
                                            dsmId,
                                            srb,
                                            &status,
                                            &retry);
            if (errorMask & DSM_FATAL_ERROR) {
                fatal = TRUE;
            }
        }
    }


    if (fatal) {

//        if ((deviceExtension->LastState == MPIO_STATE_NORMAL) ||
//            (deviceExtension->LastState == MPIO_STATE_DEGRADED)) {

            diskExtension->FailOver = TRUE;

            state = MPIOHandleStateTransition(DeviceObject);

 //       }
       
        //
        // Put the request on the resubmit queue.
        // This routine will also clean up the request and
        // prepare it for resubmission.
        //
        // BUGBUG: If we queue this, and the FailOver is unsuccessful, the request
        // will remain in the queue.
        // 
        status2 = MPIOQueueRequest(DeviceObject,
                                   Irp,
                                   Context,
                                   &diskExtension->ResubmitQueue);
        MPDebugPrint((1,
                      "MPIOCompletion: Irp (%x) Srb (%x) on resubmit queue of (%x). Status (%x)\n",
                      Irp,
                      srb,
                      DeviceObject,
                      status));
        // 
        // Call the Fail-over Handler.
        //
        status2 = MPIOFailOverHandler(DeviceObject,
                                      errorMask,
                                      targetInfo);

        
        //
        // If the fail-over was successful or pending, don't let Io get rid of this
        // request.
        // If it wasn't successful, pass the original status back.
        //
        if ((status2 == STATUS_SUCCESS) ||
            (status2 == STATUS_PENDING)) {
            status = STATUS_MORE_PROCESSING_REQUIRED;
        } else {
            ASSERT(FALSE);
        }    
        return status;

    } else if (retry) {

        //
        // If the DSM has requested a retry, clean-up the request and call PdoDispatch.
        //
        if (irpStack->MajorFunction == IRP_MJ_SCSI) {

            //
            // Need to rebuild the Srb.
            //
            RtlCopyMemory(irpStack->Parameters.Scsi.Srb,
                          &context->Srb,
                          sizeof(SCSI_REQUEST_BLOCK));
                          
            
        }

        //
        // Re-do status and information.
        //
        Irp->IoStatus.Status = 0;
        Irp->IoStatus.Information = 0;

        //
        // Rebuild port's stack location.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);
        
        //
        // Resend.
        //
        status2 = MPIOPdoDispatch(DeviceObject,
                                  Irp,
                                  deviceExtension->State);
        
        if (status2 == STATUS_PENDING) {
            status = STATUS_MORE_PROCESSING_REQUIRED;
        } else {
            status = status2;
        }   
        return status;
    }        

    //
    // If the DSM specified a completion routine, invoke it now.
    //
    if (dsmCompletion) {
        dsmCompletion(dsmId,
                      Irp,
                      srb,
                      dsmContext);
    }
    
    //
    // Free the context structure.
    //
    MPIOFreeContext(deviceExtension,
                    Context);

    return status;
}


NTSTATUS
MPIOPdoDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG State
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;
    ULONG sortKey = deviceExtension->SequenceNumber++;
    PMPIO_CONTEXT context;
    NTSTATUS status = STATUS_PENDING;
    KIRQL irql;
    UCHAR opCode = 0;

    ASSERT(deviceExtension->Type == MPIO_MPDISK);
    
    KeAcquireSpinLock(&diskExtension->SpinLock, &irql);
    
    //
    // Allocate the request context.
    // 
    context = MPIOAllocateContext(deviceExtension);
    RtlZeroMemory(context, sizeof(MPIO_CONTEXT));
    
    //
    // Indicate this I/O's sequence number. Used in tracking
    // requests during fail-over and also as a key into the device queue.
    //
    context->CurrentState = State;
    context->OriginalState = State;
    context->Irp = Irp;
    context->Allocated = TRUE;
   
    //
    // Clone the irpstack location.
    //
    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // Set the context in our stack.
    //
    irpStack->Parameters.Others.Argument4 = (PVOID)context;

    switch (State) {
        case MPIO_STATE_IN_FO:
        case MPIO_STATE_WAIT1: {

            //
            // As no requests will be submitted, release the lock now.
            //
            KeReleaseSpinLock(&diskExtension->SpinLock, irql);
            
            //
            // If in FO, or WAIT1 simply queue to the
            // Fail-Over Queue. Once the Fail-Over is complete and the
            // resubmit queue has been handled, the F.O.Q. will be dealt
            // with.
            //
            status = MPIOQueueRequest(DeviceObject,
                                      Irp,
                                      context,
                                      &diskExtension->FailOverQueue);

            //
            // This routine will only return success or insufficient resources.
            // 
            if (status == STATUS_INSUFFICIENT_RESOURCES) {

                MPDebugPrint((1,
                              "MPIOQueueRequest returned (%x). State (%x)\n",
                              status,
                              State));
                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return status;
            }

            //
            // Set pending.
            //
            IoMarkIrpPending(Irp);
        
            //
            // Return pending.
            //
            status = STATUS_PENDING;
            break;
        }    
        case MPIO_STATE_WAIT2: {

            //
            // As no requests will be submitted, release the lock now.
            //
            KeReleaseSpinLock(&diskExtension->SpinLock, irql);

            //
            // The resubmit queue is being handled. These (like IN_FO and WAIT1)
            // go onto the Fail-Over queue.
            // This is seperated from the above States merely for administrative
            // reasons. (Unless it gets changed...)
            // 
            status = MPIOQueueRequest(DeviceObject,
                                      Irp,
                                      context,
                                      &diskExtension->FailOverQueue);

            //
            // This routine will only return success or insufficient resources.
            // 
            if (status == STATUS_INSUFFICIENT_RESOURCES) {

                MPDebugPrint((1,
                              "MPIOQueueRequest returned (%x). State (%x)\n",
                              status,
                              State));
                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return status;
            }

            //
            // Set pending.
            //
            IoMarkIrpPending(Irp);
        
            //
            // Return pending.
            //
            status = STATUS_PENDING;
            break;                                    
        }
        case MPIO_STATE_WAIT3: {
            
            //
            // Draining the Fail-Over queue. Complete these requests
            // with busy, if they are Srb's (build sense data, so that they
            // are retried). Otherwise, just return BUSY and hope for the best.
            // BUGBUG: Revisit handling of non-Srb requests. Maybe put these
            // on the F.O.Q...
            //
            MPDebugPrint((0,
                         "PdoDispatch: Setting Irp(%x) Srb (%x) BUSY\n",
                         Irp,
                         srb));

            //
            // As no requests will be submitted, release the lock now.
            //
            KeReleaseSpinLock(&diskExtension->SpinLock, irql);
            
            if (irpStack->MajorFunction == IRP_MJ_SCSI) {
                
                RtlCopyMemory(&context->Srb,
                              srb,
                              sizeof(SCSI_REQUEST_BLOCK));
                //
                // This will build the appropriate sense data that indicates
                // to the class driver that the device is busy.
                // 
                MPIOSetRequestBusy(srb);
                
            }

            //
            // All requests will be completed as BUSY. 
            //
            status = STATUS_DEVICE_BUSY;
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
                
            break;                                       
        }
        case MPIO_STATE_NORMAL:
        case MPIO_STATE_DEGRADED: {

            //
            // All failure queues are empty and the new
            // path is functioning (DEGRADED) or all is working
            // fine (NORMAL).
            // Submit these requests normally.
            //
            // Indicate another request has been submitted.
            //
            InterlockedIncrement(&diskExtension->OutstandingRequests);

            //
            // Now it's safe to release the lock as the config. code checks
            // for outstanding requests.
            //
            KeReleaseSpinLock(&diskExtension->SpinLock, irql);
            
            //
            // Call FunctionSpecific handler. 
            // The function-specific handler will set-up it's private
            // completion routine, along with the DSM information.
            //
            status = PdoDispatch[irpStack->MajorFunction](DeviceObject,
                                                          Irp);
            break;                                          
        }                              
                                               
        default:   
                                  
            //
            // As no requests will be submitted, release the lock now.
            //
            KeReleaseSpinLock(&diskExtension->SpinLock, irql);

            //
            // TODO: Here only for  test. Remove it.
            // 
            MPDebugPrint((0,
                         "MPIOPdoDispatch: Unknown State (%x)\n",
                         State));
            DbgBreakPoint();
            break;
    }    
    return status;
}


NTSTATUS
MPIOFdoDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG State
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;

    //
    // State is less important for the FDO: Perhaps of no importance.
    // Maybe:
    //     Set Sequence #
    //     Set completion.
    //     Call FunctionSpecific Handler.
    // 
    switch (irpStack->MajorFunction) {
        case IRP_MJ_PNP:
            status = MPIOFdoPnP(DeviceObject,
                                Irp);
            break;
    
        case IRP_MJ_POWER:
            status = MPIOFdoPower(DeviceObject,
                                  Irp);
            break;
        case IRP_MJ_INTERNAL_DEVICE_CONTROL:

            status = MPIOFdoInternalDeviceControl(DeviceObject,
                                                  Irp);
            break;
        case IRP_MJ_SYSTEM_CONTROL:
            status = MPIOFdoWmi(DeviceObject,
                                Irp);
            break;

        case IRP_MJ_DEVICE_CONTROL:
        case IRP_MJ_SHUTDOWN:
        case IRP_MJ_FLUSH_BUFFERS:
        default:

            status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
    }        

    return status;
}


NTSTATUS
MPIOWmiDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    //
    // Determine whether this is for the FDO or one of the PDOs.
    //
    if (deviceExtension->Type == MPIO_MPDISK) {

        //
        // Call the Pdo-specific handler 
        // 
        status = MPIOPdoWmi(DeviceObject,
                            Irp);
        
    } else {

        //
        // Call the Fdo-specific handler (MPIO Control).
        //
        status = MPIOFdoDispatch(DeviceObject,
                                 Irp,
                                 deviceExtension->State);


    }    
    
    return status;
}
    

NTSTATUS
MPIOGlobalDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the global dispatch routine for all requests.

Arguments:

    DeviceObject - Supplies the device object.
    Irp          - Supplies the IO request block.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    //
    // Determine whether this is for the FDO or one of the PDOs.
    //
    if (deviceExtension->Type == MPIO_MPDISK) {

        //
        // Call the Pdo-specific handler (MPDISK). The routines under this will do 
        // everything needed, so just return the status.
        // 
        status = MPIOPdoDispatch(DeviceObject,
                                 Irp,
                                 deviceExtension->State);
        
    } else {

        //
        // Call the Fdo-specific handler (MPIO Control).
        //
        status = MPIOFdoDispatch(DeviceObject,
                                 Irp,
                                 deviceExtension->State);


    }    
    
    return status;
}

//
// Routines exported to the DSMs
//

VOID
DsmSendDeviceIoControlSynchronous(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    OUT PIO_STATUS_BLOCK IoStatus
    )
{
    MPLIBSendDeviceIoControlSynchronous(IoControlCode,
                                        TargetDeviceObject,
                                        InputBuffer,
                                        OutputBuffer,
                                        InputBufferLength,
                                        OutputBufferLength,
                                        InternalDeviceIoControl,
                                        IoStatus);
}    


PDSM_IDS
DsmGetAssociatedDevice(
    IN PVOID MPIOContext,        
    IN PDEVICE_OBJECT PortFdo,
    IN UCHAR DeviceType
    )
/*++

Routine Description:

    If the DSM needs to acquire information from other devices (such as a controller), this
    routine can be used to get a list of the PDO's associated with PortFdo.

Arguments:

    PortFdo - Port driver FDO passed to InquireDriver.
    DeviceType - Indicates the SCSI DeviceType to return.
    
Return Value:

    Pointer to a DSM_ID structure, where IdList entries are PDEVICE_OBJECT. It is the
    reponsibility of the DSM to free the buffer.

--*/
{
    PDEVICE_OBJECT deviceObject = MPIOContext;
    PDEVICE_EXTENSION deviceExtension = deviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PADP_ASSOCIATED_DEVICES filterDevices;
    PDSM_IDS deviceList;
    ULONG numberMatched = 0;
    ULONG i;
    ULONG j;
    ULONG length;
    PFLTR_ENTRY fltrEntry;
    PLIST_ENTRY entry;
    

    for (entry = controlExtension->FilterList.Flink;
         entry != &controlExtension->FilterList;
         entry = entry->Flink) {
        
        fltrEntry = CONTAINING_RECORD(entry, FLTR_ENTRY, ListEntry);
        if (fltrEntry->PortFdo == PortFdo) {

            //
            // Get the current list from the fdo filter.
            //
            filterDevices = fltrEntry->FltrGetDeviceList(fltrEntry->FilterObject);
            if (filterDevices) {

                for (i = 0; i < filterDevices->NumberDevices; i++) {
                    if (filterDevices->DeviceInfo[i].DeviceType == DeviceType) {
                        numberMatched++;
                    }
                }
                //
                // Allocate the dsm list.
                //
                length = sizeof(DSM_IDS) + (sizeof(PDEVICE_OBJECT) * (numberMatched - 1));
                deviceList = ExAllocatePool(NonPagedPool, length); 

                deviceList->Count = numberMatched;
                
                for (j = 0, i = 0; i < filterDevices->NumberDevices; i++) {
                    if (filterDevices->DeviceInfo[i].DeviceType == DeviceType) {
                        deviceList->IdList[j] = filterDevices->DeviceInfo[i].DeviceObject;
                        j++;
                    }
                }
                
            } else {
                deviceList = NULL;
            }

            ExFreePool(filterDevices);
            return deviceList;

        }    
    }

    return NULL;
}


NTSTATUS
DsmReleaseQueue(
    IN PDEVICE_OBJECT ChildDevice
    )
{
    return MPLibReleaseQueue(ChildDevice);
}    

NTSTATUS
DsmSendTUR(
    IN PDEVICE_OBJECT TargetDevice
    )
{
    return MPLibSendTUR(TargetDevice);
}    


NTSTATUS
DsmSendPassThroughDirect(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_PASS_THROUGH_DIRECT ScsiPassThrough,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )
{

    return MPLibSendPassThroughDirect(DeviceObject,
                                      ScsiPassThrough,
                                      InputBufferLength,
                                      OutputBufferLength);
}    


NTSTATUS
DsmGetDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTORAGE_PROPERTY_ID PropertyId,
    OUT PSTORAGE_DESCRIPTOR_HEADER *Descriptor
    )
{

    return MPLIBGetDescriptor(DeviceObject,
                              PropertyId,
                              Descriptor);
}    

VOID
DsmNotification(
    IN PVOID MPIOContext,
    IN DSM_NOTIFICATION_TYPE Type,
    IN PVOID AdditionalParameter
    )
{

    return;
}    


NTSTATUS
DsmWriteEvent(
    IN PVOID MPIOContext,
    IN PWCHAR ComponentName,
    IN PWCHAR EventDescription,
    IN ULONG Severity
    )
{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject = MPIOContext;

    status = MPIOFireEvent(deviceObject,
                           ComponentName,
                           EventDescription,
                           Severity);
    return status;
}

VOID
DsmDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
{
    MPathDebugPrint(DebugPrintLevel,
                 DebugMessage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\control\pnp.c ===
#include "mpio.h"
#include <stdio.h>
#include <stdlib.h>




NTSTATUS
MPIOQueryDeviceText(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles the QUERY_DEVICE_TEXT Irp for
    Pseudo disks.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PSTORAGE_DEVICE_DESCRIPTOR deviceDescriptor;
    NTSTATUS status = STATUS_NOT_SUPPORTED;
    UCHAR ansiBuffer[256];
    ANSI_STRING ansiString;
    UNICODE_STRING unicodeString;
    PUCHAR index;
    PUCHAR inquiryField;

    //
    // Get the Storage Descriptor from the type extension.
    // 
    deviceDescriptor = diskExtension->DeviceDescriptor;

    //
    // Set the inquiry data pointer to the front of the descriptor.
    //
    inquiryField = (PUCHAR)deviceDescriptor;

    //
    // Zero the string array.
    //
    RtlZeroMemory(ansiBuffer, sizeof(ansiBuffer));

    switch (irpStack->Parameters.QueryDeviceText.DeviceTextType) {
        case DeviceTextDescription:
            
            //
            // Build <Product><Vendor><"Multi-Path Disk Device">.
            //
            // Push the inquiry pointer to the VendorId.
            // 
            (ULONG_PTR)inquiryField += deviceDescriptor->VendorIdOffset;

            //
            // Copy the VendorId to the temp. buffer, and adjust indices.
            //
            index = ansiBuffer;
            RtlCopyMemory(index, inquiryField, 8);
            index += 7;

            //
            // go back and eat all the spaces except for one.
            //
            while (*index == ' ') {
                *index = '\0';
                index--;
            }
            index++;
            *index = ' ';
            index++;

            //
            // Handle the ProductID.
            // 
            inquiryField = (PUCHAR)deviceDescriptor;
            (ULONG_PTR)inquiryField += deviceDescriptor->ProductIdOffset;
            RtlCopyMemory(index, inquiryField, 16);
            index += 15;

            //
            // go back and eat all the spaces except for one.
            //
            while (*index == ' ') {
                *index = '\0';
                index--;
            }
            index++;
            *index = ' ';
            index++;

            //
            // Don't use rev or serial number (at least for now)
            // TODO: remove or reenable.
            //
            //inquiryField = (PUCHAR)deviceDescriptor;
            //(ULONG_PTR)inquiryField += deviceDescriptor->ProductRevisionOffset;
            //RtlCopyMemory(index, inquiryField, 4);
            //index += 4;

            //
            // Append this to the end to distinquish this from the regular scsi drive.
            //
            sprintf(index, "%s", " Multi-Path Disk Device");

            //
            // The real wchar buffer is built below.
            //
            status = STATUS_SUCCESS;
            break;
            
        case DeviceTextLocationInformation: {
            PSCSI_ADDRESS scsiAddress = NULL;
            ULONG i;
            PUCHAR index;
            UCHAR groupString[25];

            //
            // Build the group string. Each value in it is the port number of the 
            // device backing the pseudo disk.
            // Adapters(X,Y)
            // 
            RtlZeroMemory(groupString, sizeof(groupString));
            sprintf(groupString, "%s", "Port(");
            index = groupString;
            index += strlen(groupString);

            for (i = 0; i < diskExtension->TargetInfoCount; i++) {

                //
                // Get the SCSI Address for this scsiport PDO
                //
                status = MPIOGetScsiAddress(diskExtension->TargetInfo[i].PortPdo,
                                            &scsiAddress);

                diskExtension->TargetInfo[i].ScsiAddress.PortNumber = scsiAddress->PortNumber;
                diskExtension->TargetInfo[i].ScsiAddress.PathId = scsiAddress->PathId;
                diskExtension->TargetInfo[i].ScsiAddress.TargetId = scsiAddress->TargetId;
                diskExtension->TargetInfo[i].ScsiAddress.Lun = scsiAddress->Lun;
                
                if (status == STATUS_SUCCESS) {
                    
                    //
                    // Jam in the PortNumber for this device.
                    //
                    sprintf(index, "%d", scsiAddress->PortNumber);
                    index += strlen(index);

                    if ((i + 1) == diskExtension->TargetInfoCount) {

                        //
                        // Last one, finish off with the closing bracket.
                        //
                        sprintf(index,"%s", ")");

                    } else {

                        //
                        // Stick a comma in between each of the port
                        // numbers.
                        //
                        sprintf(index,"%s", ",");
                        index += strlen(index);

                        //
                        // Free the buffer that GetScsiAddress allocated.
                        //
                        ExFreePool(scsiAddress);
                        scsiAddress = NULL;
                    }
                }
            }


            //
            // Free the last one.
            //
            if (scsiAddress) {
              
                // NOTE: This was above the 'if'. TODO validate and remove this comment.
                //
                // The last scsiAddress buffer was not freed yet.
                // Add in Bus Target Lun based on this Scsi Address.
                // 
                sprintf(ansiBuffer, "%s Bus %d, Target ID %d, LUN %d", 
                        groupString,
                        scsiAddress->PathId,
                        scsiAddress->TargetId,
                        scsiAddress->Lun);

               ExFreePool(scsiAddress);
            }
            break;
        }    
           
        default:
            status =  STATUS_NOT_SUPPORTED;
            Irp->IoStatus.Information = (ULONG_PTR)NULL;
            break;
    }        

    if (status == STATUS_SUCCESS) {

        //
        // Finally, build the unicode string based on whatever text
        // was built above.
        //
        RtlInitAnsiString(&ansiString, ansiBuffer);
        status = RtlAnsiStringToUnicodeString(&unicodeString,
                                              &ansiString,
                                              TRUE);

        if (status == STATUS_SUCCESS) {
            Irp->IoStatus.Information = (ULONG_PTR)unicodeString.Buffer;
        }
    }
    return status;
}


NTSTATUS
MPIOPdoQdr(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles QueryDeviceRelations requests sent to the PDO (PseudoDisks).

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_RELATIONS deviceRelations;
    NTSTATUS status = Irp->IoStatus.Status;

    if (irpStack->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation) {

        //
        // Allocate the return buffer.
        //
        deviceRelations = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));
        if (deviceRelations == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            status = STATUS_SUCCESS;

            //
            // Indicate, of course, there is One, and it's us.
            //
            deviceRelations->Count = 1;
            deviceRelations->Objects[0] = DeviceObject;

            //
            // Reference our devObj so that it's not removed.
            // PnP will deref it when it's finished with the request.
            //
            ObReferenceObject(DeviceObject);

            Irp->IoStatus.Information = (ULONG_PTR)deviceRelations;
        }
    }

    Irp->IoStatus.Status = status;
    return status;
}


NTSTATUS
MPIOHardwareIDs(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    OUT PUNICODE_STRING UnicodeString
    )
/*++

Routine Description:

    This routine handles QueryHardwareId requests sent to the PDO (PseudoDisks).

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSTORAGE_DEVICE_DESCRIPTOR deviceDescriptor;
    NTSTATUS status;
    PUCHAR inquiryField;
    PUCHAR index;
    ULONG bufferLength;
    ULONG i;
    ANSI_STRING ansiString;
    UNICODE_STRING unicodeEntry;
    PSTR hwStrings[7];
    UCHAR hwId[64];
    UCHAR inquiryData[32];
    UCHAR savedInquiryData[32];


    deviceDescriptor = diskExtension->DeviceDescriptor; 
    inquiryField = (PUCHAR)deviceDescriptor;

    //
    // Zero the string array.
    //
    RtlZeroMemory(hwStrings, sizeof(hwStrings));
    RtlZeroMemory(inquiryData, sizeof(inquiryData));

    //
    // Build the full inquiry data for the device.
    // Go through each of the fields in raw data and get
    // their offsets. Copy the fields into the buffer.
    //
    (ULONG_PTR)inquiryField += deviceDescriptor->VendorIdOffset;
    index = inquiryData;
    RtlCopyMemory(index, inquiryField, 8);
    index += 8;

    inquiryField = (PUCHAR)deviceDescriptor;
    (ULONG_PTR)inquiryField += deviceDescriptor->ProductIdOffset;
    RtlCopyMemory(index, inquiryField, 16);
    index += 16;

    inquiryField = (PUCHAR)deviceDescriptor;
    (ULONG_PTR)inquiryField += deviceDescriptor->ProductRevisionOffset;
    RtlCopyMemory(index, inquiryField, 4);

    //
    // Run through and fixup spaces.
    //
    index = inquiryData;
    while (*index != '\0') {
        if (*index == ' ') {
            *index = '_';
        }
        index++;
    }

    //
    // Copy this to the saved buffer.
    // This is used below while building up each of the HW ID strings.
    //
    RtlCopyMemory(savedInquiryData, inquiryData, 32);

    for (i = 0; i < 6; i++) {

        //
        // Zero the buffer
        //
        RtlZeroMemory(hwId, sizeof(hwId));

        //
        // Each time through the loop, build one of the hardware id strings.
        //
        // (0) SCSI\DISK\Full Inquiry
        // (1) SCSI\Disk\Inquiry - Rev
        // (2) SCSI\Disk\Inquiry - Product and rev.
        // (3) SCSI\Inquiry with only one char of rev.
        // (4) Inquiry with only one char of rev.
        // (5) GenDisk
        //               
        switch (i) {
            case 0:

                //
                // Build the header (SCSI\Disk) plus the full inquiry data
                //
                sprintf(hwId, "%s", "MPIO\\Disk");
                index = hwId;
                index += strlen(hwId);
                RtlMoveMemory(index, inquiryData, strlen(inquiryData));

                break;

            case 1:

                //
                // Get rid of the product revision in the inquiryData.
                //
                index = inquiryData + 24;
                *index = '\0';

                sprintf(hwId, "%s", "MPIO\\Disk");
                index = hwId;
                index += strlen(hwId);
                RtlMoveMemory(index, inquiryData, strlen(inquiryData));
                break;

            case 2:

                //
                // Get rid of the product id.
                //
                index = inquiryData + 8;
                *index = '\0';

                sprintf(hwId, "%s", "MPIO\\Disk");
                index = hwId;
                index += strlen(hwId);
                RtlMoveMemory(index, inquiryData, strlen(inquiryData));
                break;

            case 3:

                //
                // Remake inquiryData.
                //
                RtlCopyMemory(inquiryData, savedInquiryData, 32);

                //
                // Need to strip off all but the first character of revision.
                //
                inquiryData[25] = '\0';

                sprintf(hwId, "%s", "MPIO\\");
                index = hwId;
                index += strlen(hwId);
                RtlMoveMemory(index, inquiryData, strlen(inquiryData));

                break;
            case 4:

                //
                // This is like 3, but no SCSI\ in front.
                //
                sprintf(hwId, "%s", inquiryData);
                break;
            case 5:

                //
                // Only the GenDisk
                //
                sprintf(hwId, "%s", "GenDisk");
                break;
            default:
                break;
        }

        //
        // Allocate and build the hwString entry.
        //
        hwStrings[i] = ExAllocatePool(PagedPool, strlen(hwId) + sizeof(UCHAR));
        if (hwStrings == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(hwStrings[i], strlen(hwId) + sizeof(UCHAR));
        RtlCopyMemory(hwStrings[i], hwId, strlen(hwId));

        MPDebugPrint((2,
                      "MPathHwIds: Hw String[%x] - %s\n",
                      i,
                      hwStrings[i]));

    }

    status = STATUS_SUCCESS;

    //
    // Convert the hwString entry into the unicode version that the caller wants.
    //
    for (i = 0, bufferLength = 0; i < 6; i++) {
        bufferLength += strlen(hwStrings[i]) * sizeof(WCHAR);

        //
        // Make room for the NULL after the string.
        //
        bufferLength += sizeof(UNICODE_NULL);
    }

    UnicodeString->Length = (USHORT)bufferLength;

    //
    // Add room for the final terminating NULL
    //
    bufferLength += sizeof(UNICODE_NULL);

    //
    // Allocate the buffer.
    //
    UnicodeString->Buffer = ExAllocatePool(PagedPool, bufferLength);
    if (UnicodeString->Buffer) {

        RtlZeroMemory(UnicodeString->Buffer, bufferLength);
        UnicodeString->MaximumLength = (USHORT)bufferLength;

        unicodeEntry = *UnicodeString;

        for (i = 0; i < 6; i++) {

            //
            // Convert ascii to ansi.
            //
            RtlInitAnsiString(&ansiString, hwStrings[i]);
            status = RtlAnsiStringToUnicodeString(&unicodeEntry,
                                                  &ansiString,
                                                  FALSE);
            if (!NT_SUCCESS(status)) {
                break;
            }

            //
            // update the unicode fields.
            //
            ((PSTR)unicodeEntry.Buffer) += unicodeEntry.Length + sizeof(WCHAR);
            unicodeEntry.MaximumLength -= unicodeEntry.Length + sizeof(WCHAR);

        }

    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


NTSTATUS
MPIODeviceId(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PUNICODE_STRING UnicodeString
    )
    //
    // Need to build up a name like MPATH#<DevType>&VenXXX&ProdXXX&RevXXX
    //
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PSTORAGE_DEVICE_DESCRIPTOR deviceDescriptor;
    ANSI_STRING ansiIdString;
    CHAR deviceStrings[4][255];
    UCHAR deviceId[256];
    PUCHAR scsiField;
    PUCHAR currentId;
    NTSTATUS status;
    ULONG i;
    ULONG deviceIndex = 0;

    RtlZeroMemory(deviceId, 256);
    currentId = deviceId;
    deviceDescriptor = diskExtension->DeviceDescriptor; 
    scsiField = (PUCHAR)deviceDescriptor;

    //
    // Preload the deviceId with MPIO\<deviceType>
    //
    sprintf(currentId, "%s", "MPIO\\Disk&Ven_");

    //
    // Push the current pointer past the above field.
    //
    currentId += strlen(currentId);

    //
    // Push the scsiField pointer to that of the vendor id.
    //
    ASSERT(deviceDescriptor->VendorIdOffset != 0);
    ASSERT(deviceDescriptor->ProductIdOffset != 0);
    ASSERT(deviceDescriptor->ProductRevisionOffset != 0);

    (ULONG_PTR)scsiField += deviceDescriptor->VendorIdOffset;

    //
    // Copy in the Vendor name.
    //
    for (i = 0; i < VENDOR_ID_LENGTH; i++) {
        *currentId = *scsiField;
        currentId++;
        scsiField++;
    }
    *currentId = '\0';
    currentId++;

    //
    // Bump the scsiField to that of the product id.
    //
    scsiField = (PUCHAR)deviceDescriptor;
    (ULONG_PTR)scsiField += deviceDescriptor->ProductIdOffset;

    //
    // Remove any trailing spaces
    //
    while (*currentId == ' ' || *currentId == '\0') {
        currentId--;
    }
    currentId++;

    //
    // Jam in &Prod
    //
    sprintf(currentId, "%s", "&Prod_");
    currentId += strlen(currentId);

    //
    // Copy in the Product Id.
    //
    for (i = 0; i < PRODUCT_ID_LENGTH; i++) {
        *currentId = *scsiField;
        currentId++;
        scsiField++;
    }

    *currentId = '\0';
    currentId++;

    //
    // Remove any trailing spaces
    //
    while (*currentId == ' ' || *currentId == '\0') {
        currentId--;
    }
    currentId++;

    //
    // Handle the revision.
    //
    scsiField = (PUCHAR)deviceDescriptor;
    (ULONG_PTR)scsiField += deviceDescriptor->ProductRevisionOffset;

    sprintf(currentId, "%s", "&Rev_");
    currentId += strlen(currentId);

    for (i = 0; i < REVISION_LENGTH; i++) {
        *currentId = *scsiField;
        currentId++;
        scsiField++;
    }
    *currentId = '\0';
    currentId++;


    //
    // Remove any trailing spaces
    //
    while (*currentId == ' ' || *currentId == '\0') {
        currentId--;
    }

    //
    // Run through and fixup spaces.
    //
    currentId = deviceId;
    while (*currentId != '\0') {
        if (*currentId == ' ') {
            *currentId = '_';
        }
        currentId++;
    }

    MPDebugPrint((2,
                  "MPathDeviceId - %s\n",
                  deviceId));

    //
    // Finally make the unicode string that will be returned to PnP.
    //
    RtlInitAnsiString(&ansiIdString,deviceId);

    status = RtlAnsiStringToUnicodeString(UnicodeString,
                                          &ansiIdString,
                                          TRUE);
    return status;
}



NTSTATUS
MPIOPdoQueryId(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles QueryId requests sent to the PDO (PseudoDisks).

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;
    UNICODE_STRING unicodeID;
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;
    UNICODE_STRING unicodeIndex;
    ULONG bufferLength = 0;
    UCHAR deviceId[256];

    RtlZeroMemory(deviceId, 256);

    switch (irpStack->Parameters.QueryId.IdType) {
        case BusQueryHardwareIDs: {

            status = MPIOHardwareIDs(DeviceObject,
                                     Irp,
                                     &unicodeString);
            if (NT_SUCCESS(status)) {

                //
                // Set the hardware ID buffer.
                //
                Irp->IoStatus.Information = (ULONG_PTR)unicodeString.Buffer;
            }
            break;
        }
        case BusQueryDeviceID: {

            status = MPIODeviceId(DeviceObject,
                                  Irp,
                                  &unicodeString);
            if (NT_SUCCESS(status)) {
                Irp->IoStatus.Information = (ULONG_PTR)unicodeString.Buffer;
            }
            break;
        }
        case BusQueryInstanceID: {
            PSTORAGE_DEVICE_DESCRIPTOR deviceDescriptor;
            ULONG serialNumberLength;
            PUCHAR serialNumber;
            UCHAR fakeSerialNumber[20];
            ANSI_STRING ansiSerialNumber;

            deviceDescriptor = diskExtension->DeviceDescriptor; 
            serialNumber = (PUCHAR)deviceDescriptor;

            //
            // If the device has no serial number, need to make something up.
            // TODO
            //
            if (deviceDescriptor->SerialNumberOffset == (ULONG)-1) {

                RtlZeroMemory(fakeSerialNumber, 20);
                sprintf(fakeSerialNumber, "00%d", diskExtension->DeviceOrdinal);
                serialNumber = fakeSerialNumber;
                
            } else {
                
                //
                // Move serialNumber to the correct position in RawData.
                //
                (ULONG_PTR)serialNumber += deviceDescriptor->SerialNumberOffset;
                
            }    

            //
            // Get it's length.
            //
            serialNumberLength = strlen(serialNumber);

            //
            // Build the ansi string based on the serial number information.
            // Then convert to unicode.
            //
            RtlInitAnsiString(&ansiSerialNumber, serialNumber);
            RtlAnsiStringToUnicodeString(&unicodeString, &ansiSerialNumber, TRUE);

            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = (ULONG_PTR)unicodeString.Buffer;

            break;
        }
        case BusQueryCompatibleIDs: {
            UNICODE_STRING unicodeString;
            ULONG i;
            PSTR deviceStrings[] = {"SCSI\\Disk", "SCSI\\RAW", NULL};
            
            //
            // Determine length needed for the unicode buffer.
            //
            for (i = 0; deviceStrings[i] != NULL; i++) {
                bufferLength += strlen(deviceStrings[i]) * sizeof(WCHAR);

                //
                // Make room for the NULL after the string.
                //
                bufferLength += sizeof(UNICODE_NULL);
            }

            unicodeString.Length = (USHORT)bufferLength;

            //
            // Add room for the final terminating NULL
            //
            bufferLength += sizeof(UNICODE_NULL);

            //
            // Allocate the buffer.
            //
            unicodeString.Buffer = ExAllocatePool(PagedPool, bufferLength);

            if (unicodeString.Buffer == NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                //
                // Finish initing the unicode string.
                //
                RtlZeroMemory(unicodeString.Buffer, bufferLength);
                unicodeString.MaximumLength = (USHORT)bufferLength;

                //
                // Set the index string to the front of the real unicode string.
                // This index will be pushed along so that the creation of the MULTI string
                // can be done.
                //
                unicodeIndex = unicodeString;

                for (i = 0, status = STATUS_SUCCESS; deviceStrings[i] != NULL; i++) {
                    RtlInitAnsiString(&ansiString, deviceStrings[i]);
                    status = RtlAnsiStringToUnicodeString(&unicodeIndex,
                                                          &ansiString,
                                                          FALSE);
                    if (NT_SUCCESS(status)) {

                        //
                        // push the index past the last unicode string built.
                        //
                        ((PSTR)unicodeIndex.Buffer) += unicodeIndex.Length + sizeof(WCHAR);

                        //
                        // Ensure the max length is correct.
                        //
                        unicodeIndex.MaximumLength -= unicodeIndex.Length + sizeof(WCHAR);

                    } else {

                        //
                        // TODO: Something.
                        //
                        break;
                    }
                }

                if (NT_SUCCESS(status)) {
                    Irp->IoStatus.Information = (ULONG_PTR)unicodeString.Buffer;
                } 
            }

            break;
        }

        default:

            status = Irp->IoStatus.Status;
            Irp->IoStatus.Information = 0;
            break;
    }

    return status;
}


NTSTATUS
MPIOPdoDeviceUsage(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{

    //
    // TODO
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\control\queue.c ===
#include <mpio.h>


VOID
MPIOInitQueue(
    IN PMP_QUEUE Queue,
    IN ULONG QueueTag
    )
{
    //
    // Initialize this queue's spinlock.
    //
    KeInitializeSpinLock(&Queue->SpinLock);

    //
    // Init the list entry.
    //
    InitializeListHead(&Queue->ListEntry);

    //
    // Set the number of items.
    //
    Queue->QueuedItems = 0;

    //
    // Set the queue marker.
    //
    Queue->QueueIndicator = QueueTag;

}   


VOID
MPIOInsertQueue(
    IN PMP_QUEUE Queue,
    IN PMPQUEUE_ENTRY QueueEntry
    )
{
    KIRQL irql;

    KeAcquireSpinLock(&Queue->SpinLock, &irql);

    //
    // Insert the entry on the queue.
    //
    InsertTailList(&Queue->ListEntry,
                   &QueueEntry->ListEntry);

    //
    // Indicate the additonal item.
    // 
    Queue->QueuedItems++;

    KeReleaseSpinLock(&Queue->SpinLock, irql);

}


PMPQUEUE_ENTRY
MPIORemoveQueue(
    IN PMP_QUEUE Queue
    )
{
    KIRQL irql;
    PLIST_ENTRY entry;
    
    KeAcquireSpinLock(&Queue->SpinLock, &irql);

    //
    // Get the next item on the list.
    // 
    entry = RemoveHeadList(&Queue->ListEntry);
    
    //
    // Indicate one less.
    //
    Queue->QueuedItems--;
    
    KeReleaseSpinLock(&Queue->SpinLock, irql);
    
    return CONTAINING_RECORD(entry, MPQUEUE_ENTRY, ListEntry);
}    


NTSTATUS
MPIOIssueQueuedRequests(
    IN PREAL_DEV_INFO TargetInfo,
    IN PMP_QUEUE Queue,
    IN ULONG State,
    IN PULONG RequestCount
    )
/*++

Routine Description:

    This routine runs Queue, extracts the requests and issues them
    to DeviceObject. 
    It is used to handle the various failure queue submissions.
    It assumes that the requests are ready to submit, context values
    updated, and all targetInfo,diskExtension, deviceExtension values to
    be correct.

Arguments:

    DeviceObject - The MPDev Object to which the request is to be sent.
    Queue - The failure queue to be drained.
    CompletionRoutine - The appropriate completion routine to be set-up.
    
Return Value:

    NTSTATUS

--*/
{
    PMPQUEUE_ENTRY queueEntry;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    NTSTATUS status = STATUS_SUCCESS;
    PMPIO_CONTEXT context;
    ULONG issued = 0;
    ULONG initialCount = Queue->QueuedItems;

    //
    // See if anything is actually in the queue.
    // 
    if (Queue->QueuedItems == 0) {
        MPDebugPrint((0,
                     "MPIOIssueQueuedRequests: Asked to issue Zero requests\n"));
        DbgBreakPoint();
        *RequestCount = 0;
        return STATUS_SUCCESS;
    }
   
    MPDebugPrint((0,
                  "IssueQueuedRequests: Handling (%x) in State (%x)\n",
                  Queue,
                  State));
    do {

        //
        // Get the next entry in the queue.
        // This also dec's QueuedItems.
        //
        queueEntry = MPIORemoveQueue(Queue);
        if (queueEntry) {
    
            //
            // Extract the irp, our stack location, and the
            // associated context.
            // 
            irp = queueEntry->Irp;
            irpStack = IoGetCurrentIrpStackLocation(irp);
            context = irpStack->Parameters.Others.Argument4;

            //
            // Update the state, so that the completion routine
            // can figure out when this was sent.
            //
            context->CurrentState = State;
            context->ReIssued = TRUE;

            //
            // Hack out the Dsm Completion info. 
            // Otherwise, we call them twice for this request.
            // BUGBUG: Or call set completion again.
            //
            context->DsmCompletion.DsmCompletionRoutine = NULL;
            context->DsmCompletion.DsmContext = NULL;
            context->TargetInfo = TargetInfo;

            InterlockedIncrement(&TargetInfo->Requests);

            //
            // Determine whether this contains an Srb or not.
            // 
            if (irpStack->MajorFunction == IRP_MJ_SCSI) {

                //
                // Need to rebuild the Srb.
                //
                RtlCopyMemory(irpStack->Parameters.Scsi.Srb,
                              &context->Srb,
                              sizeof(SCSI_REQUEST_BLOCK));
                              
                
            }

            //
            // Re-do status and information.
            //
            irp->IoStatus.Status = 0;
            irp->IoStatus.Information = 0;

            //
            // Rebuild port's stack location.
            //
            IoCopyCurrentIrpStackLocationToNext(irp);
            
            //
            // Set the appropriate completion routine.
            //
            IoSetCompletionRoutine(irp,
                                   MPPdoGlobalCompletion,
                                   context,
                                   TRUE,
                                   TRUE,
                                   TRUE);
            //
            // Send it to "DeviceObject".
            // 
            status = IoCallDriver(TargetInfo->DevFilter, irp);

            issued++;
            
            //
            // Update the caller's number of requests.
            // TODO: This is updating the value that is already set.
            // Either remove the parameter and this count update, or
            // have callers use a different variable (not the diskExtension->XXXCount);
            //
            InterlockedIncrement(RequestCount);
            
            //
            // Status should be pending or success.
            // 
            if ((status != STATUS_PENDING) &&
                (status != STATUS_SUCCESS)){

                //
                // Completion routine will handle this, but make a 
                // note of the failure. TODO firgure out a better way to
                // do this.
                // 
                MPDebugPrint((0,
                              "MPIOIssueQueuedRequests: Irp (%x) sent to (%x) - Status (%x)\n",
                              irp,
                              TargetInfo->DevFilter,
                              status));
                //
                // LOG
                //
                ASSERT(status == STATUS_SUCCESS);
            }

            //
            // Free the allocaiton.
            // NOTE: These queueEntries should be on a LookasideList.
            //
            ExFreePool(queueEntry);
            
        } else {

            //
            // Ensure that the queue is actually empty.
            //
            ASSERT(Queue->QueuedItems == 0);
        }

        //
        // BUGBUG: There is no throttling mechanism here. It would be easy
        // to overload the underlying adapter in some cases.
        //
        // NOTE: It may be better to re-categorize all the requests instead of
        // just sending all to the "newPath" that the DSM indicated.
        //
        // Need to note this behaviour to DSM authors!
        //
    } while (Queue->QueuedItems);

    MPDebugPrint((0,
                 "IssueQueuedRequests: Issued (%x) out of (%x)\n",
                 issued,
                 initialCount));
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\control\pdo.c ===
#include "mpio.h"


VOID
MPIOTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
{
    PDEVICE_EXTENSION deviceExtension = (PDEVICE_EXTENSION)Context;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PFLTR_ENTRY fltrEntry;
    ULONG tickDiff;
    ULONG numberDevices;
    PMPIO_REQUEST_INFO requestInfo;
    PREAL_DEV_INFO deviceInfo;
    PDEVICE_OBJECT currentAdapter;
    ULONG i;
    ULONG j;
    PDEVICE_OBJECT controlObject = diskExtension->ControlObject;
    PDEVICE_EXTENSION devExt = controlObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = devExt->TypeExtension;
    PLIST_ENTRY listEntry;

    //
    // Inc current tickcount.
    //
    diskExtension->TickCount++;

    if ((deviceExtension->State != MPIO_STATE_IN_FO) && 
        (deviceExtension->State != MPIO_STATE_WAIT1)) {
        
        //
        // Check for any pending work items to start.
        //
        if (diskExtension->PendingItems) {
            PLIST_ENTRY listEntry;

            //
            // Yank the packet from the pending list...
            //
            listEntry = ExInterlockedRemoveHeadList(&diskExtension->PendingWorkList,
                                                    &diskExtension->WorkListLock);

            if (listEntry) {

                //
                // ...and jam it on the work list.
                // 
                ExInterlockedInsertTailList(&diskExtension->WorkList,
                                            listEntry,
                                            &diskExtension->WorkListLock);

                InterlockedDecrement(&diskExtension->PendingItems);

                //
                // Signal the thread to initiate the F.O.
                //
                KeSetEvent(&diskExtension->ThreadEvent,
                           8,
                           FALSE);

            } else {
                MPDebugPrint((0,
                             "MPIOTimer: PendingItems set, but entry == NULL\n"));
                ASSERT(FALSE);
            }    
        }
    }


    return;            
}    


BOOLEAN
MPIOFindMatchingDevice(
    IN PDEVICE_OBJECT MPDiskObject,
    IN PADP_DEVICE_INFO DeviceInfo,
    IN PDSM_ENTRY DsmEntry,
    IN PVOID DsmId
    )
{
    PDEVICE_EXTENSION deviceExtension = MPDiskObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    ULONG i;

    //
    // Hand off each real pdo and the new one to the DSM to see
    // if they are really the same device (accessed via different paths)
    // 
    for (i = 0; i < diskExtension->TargetInfoCount; i++) {

        if (DsmEntry->CompareDevices(DsmEntry->DsmContext,
                                     diskExtension->TargetInfo[i].DsmID,
                                     DsmId)) {
            //
            // Have a match.
            //
            return TRUE;
        }
    }

    return FALSE;
}


NTSTATUS
MPIOCreateDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT FilterObject,
    IN PDEVICE_OBJECT PortObject,
    IN PADP_DEVICE_INFO DeviceInfo,
    IN PDSM_ENTRY DsmEntry,
    IN PVOID DsmId,
    IN OUT PDEVICE_OBJECT *NewDeviceObject
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PDEVICE_OBJECT diskObject;
    PDEVICE_EXTENSION newExtension;
    PMPDISK_EXTENSION diskExtension;
    UNICODE_STRING unicodeDeviceName;
    PUNICODE_STRING regString;
    PREAL_DEV_INFO targetInfo;
    PMPIO_THREAD_CONTEXT threadContext;
    WCHAR deviceName[30];
    NTSTATUS status;
    ULONG i;
    ULONG numberDevices = controlExtension->NumberDevices;
    
    //
    // Build the new name.
    //
    swprintf(deviceName,
            L"\\Device\\MPathDisk%0d",
            numberDevices);

    RtlInitUnicodeString(&unicodeDeviceName, deviceName);

    //
    // Create the device object.
    //
    status = IoCreateDevice(deviceExtension->DriverObject,
                            sizeof(DEVICE_EXTENSION),
                            &unicodeDeviceName,
                            FILE_DEVICE_MASS_STORAGE,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &diskObject);

    if (status == STATUS_SUCCESS) {

        MPDebugPrint((0,
                    "MPIOCreateDevice: New PDO %x\n",
                    diskObject));
        
        //
        // TODO, break this up into some helper functions that 
        // can be used by both this routine and UpdateDevice
        //
        // 
        // Setup the various devObj stuff to be like the real PDO.
        //
        diskObject->StackSize = DeviceInfo->DeviceObject->StackSize + 1;
        diskObject->Flags = DeviceInfo->DeviceObject->Flags;
        diskObject->Flags |= DO_DEVICE_INITIALIZING;
        diskObject->AlignmentRequirement = DeviceInfo->DeviceObject->AlignmentRequirement;
        
        //
        // Allocate the type extension.
        //
        diskExtension = ExAllocatePool(NonPagedPool, sizeof(MPDISK_EXTENSION));
        RtlZeroMemory(diskExtension, sizeof(MPDISK_EXTENSION));

        //
        // Allocate storage for the device descriptor.
        //
        diskExtension->DeviceDescriptor = ExAllocatePool(NonPagedPool, 
                                                         DeviceInfo->DeviceDescriptor->Size);
        //
        // Set-up the device extension.
        //
        newExtension = diskObject->DeviceExtension;
        newExtension->TypeExtension = diskExtension;

        newExtension->DeviceObject = diskObject;
        newExtension->Pdo = diskObject;
        newExtension->LowerDevice = DeviceObject;
        newExtension->DriverObject = deviceExtension->DriverObject;
        newExtension->Type = MPIO_MPDISK;

        //
        // Since there is only one path, set the original state to DEGRADED, as we
        // can't fail-over yet.
        //
        newExtension->State = MPIO_STATE_NORMAL;
        newExtension->LastState = MPIO_STATE_NORMAL;
        newExtension->CompletionState = MPIO_STATE_NORMAL;
        diskExtension->CheckState = TRUE;
      
        //
        // Set-up the Lookaside List of context structs.
        //
        ExInitializeNPagedLookasideList(&newExtension->ContextList,
                                        NULL,
                                        NULL,
                                        0,
                                        sizeof(MPIO_CONTEXT),
                                        'oCPM',
                                        0);

        //
        // Set-up emergency buffers
        //
        KeInitializeSpinLock(&newExtension->EmergencySpinLock);

        for (i = 0; i < MAX_EMERGENCY_CONTEXT; i++) {
            newExtension->EmergencyContext[i] = ExAllocatePool(NonPagedPool,
                                                               sizeof(MPIO_CONTEXT));
        }
       
        //
        // Copy the reg. path from the control object.
        //
        regString = &deviceExtension->RegistryPath;
        newExtension->RegistryPath.Buffer = ExAllocatePool(NonPagedPool,
                                                           regString->MaximumLength);
        newExtension->RegistryPath.MaximumLength = regString->MaximumLength;
        RtlCopyUnicodeString(&newExtension->RegistryPath,
                             regString);
        //
        // Save off the important DSM Info.
        //
        RtlCopyMemory(&diskExtension->DsmInfo,
                      DsmEntry,
                      sizeof(DSM_ENTRY));
          
        //
        // Prepare this D.O. to handle WMI requests.
        //
        MPIOSetupWmi(diskObject);

        //
        // Set-up the new DO's type extension.
        // 
        diskExtension->ControlObject = DeviceObject;
        diskExtension->DeviceOrdinal = numberDevices;

        //
        // Copy the device descriptor. Used for PnP ID stuff. 
        // 
        RtlCopyMemory(diskExtension->DeviceDescriptor,
                      DeviceInfo->DeviceDescriptor,
                      DeviceInfo->DeviceDescriptor->Size);
        //
        // Prepare all of the queues.
        //
        MPIOInitQueue(&diskExtension->ResubmitQueue, 1);
        MPIOInitQueue(&diskExtension->FailOverQueue, 2);

        //
        // Set-up the thread stuff.
        //
        KeInitializeSpinLock(&diskExtension->SpinLock);
        KeInitializeSpinLock(&diskExtension->WorkListLock);
        InitializeListHead(&diskExtension->WorkList);
        InitializeListHead(&diskExtension->PendingWorkList);
        KeInitializeEvent(&diskExtension->ThreadEvent,
                          NotificationEvent,
                          FALSE);
                
        threadContext = ExAllocatePool(NonPagedPool, sizeof(MPIO_THREAD_CONTEXT));
        
        threadContext->DeviceObject = diskObject;
        threadContext->Event = &diskExtension->ThreadEvent;
            
        status = PsCreateSystemThread(&diskExtension->Handle,
                                      (ACCESS_MASK)0,
                                      NULL,
                                      NULL,
                                      NULL,
                                      MPIORecoveryThread,
                                      threadContext);
        if (status != STATUS_SUCCESS) {
            diskExtension->Handle = NULL;
        }
       
        status = IoInitializeTimer(diskObject,
                                   MPIOTimer,
                                   newExtension);
                                   
        //
        // Add in the info for the first target device.
        // Note that the DevFilter and PathId fields are
        // set to the Port PDO and Adapter Filter.
        // When the DevFilter registers, these get copied over
        // to the correct values and DSMInit flag is set.
        //
        targetInfo = diskExtension->TargetInfo;
        targetInfo->AdapterFilter = FilterObject;
        targetInfo->PathId = FilterObject;
        targetInfo->PortPdo = DeviceInfo->DeviceObject;
        targetInfo->PortFdo = PortObject;
        targetInfo->DsmID = DsmId;
        targetInfo->DevFilter = DeviceInfo->DeviceObject;
        targetInfo->DSMInit = FALSE;

        diskExtension->DsmIdList.IdList[0] = DsmId;
        diskExtension->DsmIdList.Count = 1;
        diskExtension->TargetInfoCount = 1;
        diskExtension->MaxPaths = 1;
        diskExtension->HasName = FALSE;
        diskExtension->PdoName.Buffer = ExAllocatePool(NonPagedPool, PDO_NAME_LENGTH);
        RtlZeroMemory(diskExtension->PdoName.Buffer, PDO_NAME_LENGTH);
        diskExtension->PdoName.MaximumLength = PDO_NAME_LENGTH;

        //
        // Indicate that this slot is taken.
        //
        diskExtension->DeviceMap |= 1;

        *NewDeviceObject = diskObject;
    } else {
        MPDebugPrint((0,
                    "MPIOCreateDevice: Error creating new PDO %x\n",
                    status));
    }    

    return status;
}    


NTSTATUS
MPIOUpdateDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT AdapterFilter,
    IN PDEVICE_OBJECT PortObject,
    IN PADP_DEVICE_INFO DeviceInfo,
    IN PVOID DsmId
    )
/*++

Routine Description:

    This routine updates the PDO extension to include
    a newly arrived device.

Arguments:


Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PREAL_DEV_INFO devInfo;
    ULONG allocatedMap = diskExtension->DeviceMap;
    ULONG i;
    ULONG j;
    ULONG currentState;
    ULONG newState;
    WCHAR componentName[64];

    //
    // Find a free spot in the array.
    //
    for (i = 0; i < MAX_NUMBER_PATHS; i++) {
        if (!(allocatedMap & (1 << i))) {
            diskExtension->DeviceMap |= (1 << i);
            break;
        }
    }
    
    //
    // Indicate that one more path is available.
    //
    diskExtension->DsmIdList.IdList[diskExtension->DsmIdList.Count] = DsmId;
    diskExtension->DsmIdList.Count++;
    diskExtension->TargetInfoCount++;

    ASSERT(diskExtension->DsmIdList.Count <= MAX_NUMBER_PATHS);

    //
    // See if we are transitioning from degraded to normal.
    //
    currentState = deviceExtension->State;
    
    if ((diskExtension->TargetInfoCount == diskExtension->MaxPaths) &&
        (currentState == MPIO_STATE_DEGRADED)) {

        //
        // This indicates that a path that went missing, has returned.
        //
        diskExtension->PathBackOnLine = TRUE;
    }

    //
    // Update MaxPaths, if necessary. It's the count of the most
    // paths we have seen.
    // 
    if (diskExtension->TargetInfoCount > diskExtension->MaxPaths) {
        diskExtension->MaxPaths++;
    }

    //
    // Determine the state info.
    //
    newState = MPIOHandleStateTransition(DeviceObject);

    if ((currentState == MPIO_STATE_DEGRADED) && (newState == MPIO_STATE_NORMAL)) {

        //
        // Did make that tranistion. Fire an event to notify any listeners.
        //
        MPDebugPrint((0,
                      "MPIOUpdateDevice: Moving to NORMAL (%x)\n",
                      DeviceObject));
        
        swprintf(componentName, L"MPIO Disk(%02d)", diskExtension->DeviceOrdinal);
        MPIOFireEvent(DeviceObject,
                      componentName,
                      L"Moved to STATE_NORMAL",
                      MPIO_INFORMATION);
                       
    }
    
    //
    // Get the structure pertaining to the device being updated.
    //
    devInfo = &diskExtension->TargetInfo[i];
    RtlZeroMemory(devInfo, sizeof(REAL_DEV_INFO));
    
    //
    // Add the FilterObject as being the PathID for the new device.
    //
    devInfo->AdapterFilter = AdapterFilter;
    devInfo->PathId = AdapterFilter;
    
    //
    // Point the DevFilter entry to the Port PDO for now.
    // It is set when the device filter registers.
    //
    devInfo->DevFilter = DeviceInfo->DeviceObject;

    //
    // Add the Scsiport PDO.
    //
    devInfo->PortPdo = DeviceInfo->DeviceObject;
    devInfo->PortFdo = PortObject;

    for (j = 0; j < diskExtension->TargetInfoCount; j++) {
        if (diskExtension->TargetInfo[j].DsmID == DsmId) {
            MPDebugPrint((0,
                          "UpdateDevice: Matching DSM IDs\n"));
            DbgBreakPoint();
        }
    }
    //
    // Add the DSM Id that corresponds to the Scsiport PDO.
    //
    devInfo->DsmID = DsmId;
    devInfo->DSMInit = FALSE;

    return STATUS_SUCCESS;
}



NTSTATUS
MPIOPdoPowerNotification(
    IN PDEVICE_OBJECT MPDiskObject,
    IN PDEVICE_OBJECT FilterObject,
    IN PIRP Irp
    )
{

    return STATUS_SUCCESS;
}


NTSTATUS
MPIOPdoPnPNotification(
    IN PDEVICE_OBJECT MPDiskObject,
    IN PDEVICE_OBJECT FilterObject,
    IN PIRP Irp
    )
{
    
    return STATUS_SUCCESS;
}
            

NTSTATUS
MPIODsmFinalInit(
    IN PMPDISK_EXTENSION DiskExtension,
    IN PDEVICE_OBJECT DevFilter,
    IN PREAL_DEV_INFO TargetInfo
    )
/*++

Routine Description:

    This routine handles giving the dsm the remaining info. that it
    needs (PathId, it's own DSMID, and target object matchup). Also,
    determines whether the path is active.

Arguments:

    DiskExtension - The type extension for the pseudo-disk
    DevFilter - MPDev's object - the target object for I/O
    TargetInfo - Collection of DSM related info.

Return Value:

    NTSTATUS

--*/
{
    PDSM_ENTRY dsm = &DiskExtension->DsmInfo;
    ULONGLONG controllerId;
    NTSTATUS status;
    BOOLEAN active;

    //
    // Need to give info about this to the DSM
    //
    TargetInfo->PathId = TargetInfo->AdapterFilter;
    status = dsm->SetDeviceInfo(dsm->DsmContext,
                                DevFilter,
                                TargetInfo->DsmID,
                                &TargetInfo->PathId);
    if (!NT_SUCCESS(status)) {

        //
        // LOG
        // NOTE: This is really a fatal error, as there is no mapping
        // in the DSM for Path, DsmID, and the target D.O.
        // Figure out how to go into limp-home mode.
        //
    } else {

        //
        // If the DSM updated "pathID" need to encapsulate this and
        // the AdapterFilter. Be sure and use
        //
        if (TargetInfo->PathId != TargetInfo->AdapterFilter) {
            MPDebugPrint((2,
                          "MPIODsmFinalInit: DSM updated PathID (%x) -> (%x)\n",
                          TargetInfo->AdapterFilter,
                          TargetInfo->PathId));
        }    

        //
        // Have everything needed now, so create a path entry.
        //
        status = MPIOCreatePathEntry(DiskExtension->ControlObject,
                                     TargetInfo->AdapterFilter,
                                     TargetInfo->PortFdo,
                                     TargetInfo->PathId);
        if (NT_SUCCESS(status)) {

            //
            // See if there is already an ID for this path.
            // This routine will create it, if not.
            // 
            TargetInfo->Identifier = MPIOCreateUID(DiskExtension->ControlObject,
                                                   TargetInfo->PathId);
            if (TargetInfo->Identifier != 0) {
                TargetInfo->PathUIDValue = TRUE;
            }
        } else {
            MPDebugPrint((0,
                          "MPIODsmFinalInit: Couldn't create the path entry (%x)\n",
                          status));
            //
            // LOG
            //
        }    

        //
        // Verify the path before going on.
        //
        status = dsm->PathVerify(dsm->DsmContext,
                                 TargetInfo->DsmID,
                                 TargetInfo->PathId);
        
        if (status != STATUS_SUCCESS) {
            MPDebugPrint((0,
                          "MPIODsmFinalInit: PathVerify failed. Dsm (%x). TargetInfo (%x)\n",
                          dsm,
                          TargetInfo));
            DbgBreakPoint();

            //
            // Can't use this. Tear down this entry.
            //
            //TODO
            //
            status = STATUS_SUCCESS;
        }
        //
        // Determine if this path is active.
        // 
        active = dsm->IsPathActive(dsm->DsmContext,
                                   TargetInfo->PathId);
        if (active) {

            //
            // Indicate this.
            //
            TargetInfo->PathActive = TRUE;
        }

        //
        // Get the controller info for the DSM ID on this device.
        // 
        controllerId = MPIOBuildControllerInfo(DiskExtension->ControlObject,
                                               dsm,
                                               TargetInfo->DsmID);

        TargetInfo->ControllerId = controllerId;

        MPDebugPrint((1,
                      "DsmFinalInit: TargetInfo (%x) now fully init'ed\n",
                      TargetInfo));
                     
        TargetInfo->DSMInit = TRUE;
    }

    return status;
}


NTSTATUS
MPIOPdoRegistration(
    IN PDEVICE_OBJECT MPDiskObject,        
    IN PDEVICE_OBJECT FilterObject,
    IN PDEVICE_OBJECT LowerDevice,
    IN OUT PMPIO_PDO_INFO PdoInformation
    )
/*++

Routine Description:

    This routine handles setting up communication and passing of info.
    between the device filter and the mpdisk.
    

Arguments:

    MPDiskObject - Pseudo-disk that contains the real device.
    FilterObject - MPDev's object
    LowerDevice - The real pdo.
    PdoInformation - Entry points for the filter to call.

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION deviceExtension = MPDiskObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    ULONG i;
    NTSTATUS status;
    
    //
    // Ensure that the passed in MPDiskObject and LowerDevice
    // are correct.
    // The DsmIdList is the list of scisport pdo's. This is just
    // to ensure that the device id'ed by LowerDevice is in the list
    // and to get it's index for use below.
    //
    for (i = 0; i < diskExtension->TargetInfoCount; i++) {
        if (diskExtension->TargetInfo[i].PortPdo == LowerDevice) {
            break;
        }
    }

    if (i == diskExtension->TargetInfoCount) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Capture the dev filter's object. This is the target for
    // I/O's.
    //
    diskExtension->TargetInfo[i].DevFilter = FilterObject;

    //
    // Now indicate that we are ready.
    //
    MPDiskObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Finish setting up the DSM.
    //
    status = MPIODsmFinalInit(diskExtension,
                              FilterObject,
                              &diskExtension->TargetInfo[i]);
   
    ASSERT(status == STATUS_SUCCESS);

    //
    // Fill in the routines that the dev filter can use for
    // power and pnp.
    //
    PdoInformation->DevicePowerNotify = MPIOPdoPowerNotification;
    PdoInformation->DevicePnPNotify = MPIOPdoPnPNotification;
    PdoInformation->PdoObject = MPDiskObject;

    return STATUS_SUCCESS;
}    



NTSTATUS
MPIOPdoDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PMPIO_CONTEXT context = irpStack->Parameters.Others.Argument4;
    ULONG controlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;
    PDEVICE_OBJECT targetObject;

    //
    // These should just be IOCTL_STORAGE_XXX and IOCTL_SCSI_XXX
    //
    if ((controlCode == IOCTL_STORAGE_QUERY_PROPERTY) ||
        (controlCode == IOCTL_SCSI_GET_ADDRESS) ||
        (controlCode == IOCTL_SCSI_GET_ADDRESS) ||
        (controlCode == IOCTL_SCSI_PASS_THROUGH) ||
        (controlCode == IOCTL_SCSI_PASS_THROUGH_DIRECT) ||
        (controlCode == IOCTL_DISK_GET_DRIVE_GEOMETRY) ||
        (controlCode == IOCTL_DISK_GET_MEDIA_TYPES)) {

    } else {
        MPDebugPrint((0,
                      "PdoDeviceControl: Unhandled IOCTL Code (%x)\n",
                      controlCode));
    }    
   
    IoMarkIrpPending(Irp);

    //
    // Set-up the completion routine.
    // TODO: Yank this and setting up of context into single routine.
    //
    IoSetCompletionRoutine(Irp,
                           MPPdoGlobalCompletion,
                           context,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // Categorization of these should be unneccesary.
    // NOTE: Verify this assertion, and also ensure that the only requests
    // coming here are the ones noted above.
    //
    // Send these to the first device in the multi-path group.
    //
    targetObject = diskExtension->TargetInfo[0].DevFilter;

    //
    // Save the real pdo in the context.
    //
    context->TargetInfo = (diskExtension->TargetInfo);

    MPDebugPrint((3,
                "MPIOPdoDeviceControl: Context (%x) TargetInfo (%x)\n",
                context,
                context->TargetInfo));

    //
    // Set-up our context info. 
    // NOTE: Validate whether the DSM will need the opportunity to set it's
    // completion.
    //
    context->DsmCompletion.DsmCompletionRoutine = NULL;
    context->DsmCompletion.DsmContext = NULL;

    //
    // Indicate that a request is outstanding to this device.
    //
    InterlockedIncrement(&diskExtension->TargetInfo[0].Requests);
    
    //
    // Send the request to the device filter.
    //
    IoCallDriver(targetObject, Irp);
    return STATUS_PENDING;
}


NTSTATUS
MPIOReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION  diskExtension = deviceExtension->TypeExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;
    PMPIO_CONTEXT context = irpStack->Parameters.Others.Argument4;
    PREAL_DEV_INFO targetInfo = NULL;
    PDSM_ENTRY dsm;
    NTSTATUS   status;
    PVOID pathId;
    ULONG i;

    IoMarkIrpPending(Irp);

    //
    // Set-up the completion routine.
    //
    IoSetCompletionRoutine(Irp,
                           MPPdoGlobalCompletion,
                           context,
                           TRUE,
                           TRUE,
                           TRUE);

    dsm = &diskExtension->DsmInfo;
    targetInfo = diskExtension->TargetInfo;

    //
    // Ensure that the DSM has been fully init'ed.
    //
    if (targetInfo->DSMInit) {
       
        //
        // Call into the DSM to find the path to which the request should be sent.
        //
        pathId = dsm->GetPath(dsm->DsmContext,
                              srb,
                              &diskExtension->DsmIdList,
                              diskExtension->CurrentPath,
                              &status);

        if (pathId == NULL) {

            //
            // LOG
            // This is fatal. Figure out what to do.
            // Attempt a fail-over, though this probably won't fix anything (all the paths
            // are dead according to the DSM. TODO
            // 
            //  BUGBUG need to CompleteRequest with an error to cause a fail-over.
            //  Will first have to setup Context.
            //  and remove the following 
            //
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, 8);

            return status;
            
        } else {

            //
            // Determine which target info the path is in.
            //
            targetInfo = MPIOGetTargetInfo(diskExtension,
                                           pathId,
                                           NULL);
        }    
    } else {
        
        pathId = targetInfo->AdapterFilter;
        
        //
        // Determine which target info the path is in.
        //
        targetInfo = MPIOGetTargetInfo(diskExtension,
                                       NULL,
                                       pathId);
    }    

    //
    // If this path isn't marked active, this indicates a fail-over.
    //
    if (targetInfo->PathActive == FALSE) {

        //
        // LOG - Run the F.O. Handler.
        //
    }
    if (targetInfo->PathFailed) {

        MPDebugPrint((0,
                      "MPIOReadWrite: Got back a failed path. (%x)\n",
                      targetInfo));

        ASSERT(targetInfo->PathFailed == FALSE);
    }
    
    //
    // Indicate the new path that is active.
    //
    diskExtension->CurrentPath = targetInfo->PathId;

    //
    // Save the real pdo in the context.
    //
    context->TargetInfo = targetInfo;

    //
    // Get a copy of the original srb. 
    //
    RtlCopyMemory(&context->Srb,
                  srb,
                  sizeof(SCSI_REQUEST_BLOCK));

    if (targetInfo->DSMInit) {
        //
        //  Now have determined the correct path, allow the DSM
        //  to set-up it's context and completion.
        //
        dsm->SetCompletion(dsm->DsmContext,
                           targetInfo->DsmID,
                           Irp,
                           srb,
                           &context->DsmCompletion);

    }

    //
    // Indicate that a request is outstanding to this device.
    //
    InterlockedIncrement(&targetInfo->Requests);
    
    //
    //  Call the device Filter with the request.
    //
    IoCallDriver(targetInfo->DevFilter, Irp);
    return STATUS_PENDING;
}


NTSTATUS
MPIOPdoHandleRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION  diskExtension = deviceExtension->TypeExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PMPIO_CONTEXT context = irpStack->Parameters.Others.Argument4;
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;
    PREAL_DEV_INFO targetInfo;
    PDSM_ENTRY dsm;
    NTSTATUS status;
    KEVENT   event;
    UCHAR    opCode;
    PVOID    pathId;
    ULONG    action;
    KIRQL    irql;

    // 
    // Categorize the I/O
    //
    opCode = srb->Cdb[0];

    if ((opCode == SCSIOP_READ) ||
        (opCode == SCSIOP_WRITE) ||
        (opCode == SCSIOP_VERIFY)) {
        
        //
        // Call the Read/Write Handler.
        //
        return MPIOReadWrite(DeviceObject,
                             Irp);
    }

    //
    // The request is something other than a read/write request.
    // Get the DSM information.
    //
    dsm = &diskExtension->DsmInfo; 
    targetInfo = diskExtension->TargetInfo;
    
    if (targetInfo->DSMInit == FALSE) {

        //
        // Not fully initialized yet.
        //
        context->DsmCompletion.DsmCompletionRoutine = NULL;
        context->DsmCompletion.DsmContext = NULL;

        //
        // Indicate the current path.
        // 
        diskExtension->CurrentPath = targetInfo->PathId;

        //
        // Save the real pdo in the context.
        //
        context->TargetInfo = targetInfo;

        IoMarkIrpPending(Irp);

        //
        // Set-up the completion routine.
        //
        IoSetCompletionRoutine(Irp,
                               MPPdoGlobalCompletion,
                               context,
                               TRUE,
                               TRUE,
                               TRUE);

        //
        // Get a copy of the original srb. 
        //
        RtlCopyMemory(&context->Srb,
                      srb,
                      sizeof(SCSI_REQUEST_BLOCK));

        //
        // Indicate that a request is outstanding to this device.
        //
        InterlockedIncrement(&targetInfo->Requests);

        //
        // Issue request to pathId specified.
        //
        return IoCallDriver(targetInfo->DevFilter, Irp);
    }

    action = dsm->CategorizeRequest(dsm->DsmContext,
                                    &diskExtension->DsmIdList,
                                    Irp,
                                    srb,
                                    diskExtension->CurrentPath,
                                    &pathId,
                                    &status);
   
    if (action == DSM_PATH_SET) {
       
        IoMarkIrpPending(Irp);

        //
        // Set-up the completion routine.
        //
        IoSetCompletionRoutine(Irp,
                               MPPdoGlobalCompletion,
                               context,
                               TRUE,
                               TRUE,
                               TRUE);


        //
        // DSM has set the path to which the request should be sent.
        //
        // Get the target info corresponding to the pathId returned
        // by the DSM.
        //
        targetInfo = MPIOGetTargetInfo(diskExtension,
                                       pathId,
                                       NULL);
        
        if (targetInfo->PathFailed) {

            MPDebugPrint((0,
                          "MPIOHandleRequest: Got back a failed path. (%x)\n",
                          targetInfo));

            ASSERT(targetInfo->PathFailed == FALSE);
        }

        //
        // Save the real pdo in the context.
        //
        context->TargetInfo = targetInfo;

        //
        // Get a copy of the original srb. 
        //
        RtlCopyMemory(&context->Srb,
                      srb,
                      sizeof(SCSI_REQUEST_BLOCK));

        MPDebugPrint((2,
                    "Categorize: Context (%x). TargetInfo (%x)\n",
                    context,
                    context->TargetInfo));

        //
        // Allow the DSM to set-up completion info.
        // The DSM has the responsibility for the allocation and free
        // of it's own context.
        //
        dsm->SetCompletion(dsm->DsmContext,
                           targetInfo->DsmID,
                           Irp,
                           srb,
                           &context->DsmCompletion);
        
        //
        // Indicate the current path.
        // 
        diskExtension->CurrentPath = targetInfo->PathId;

        //
        // Indicate that a request is outstanding to this device.
        //
        InterlockedIncrement(&targetInfo->Requests);

        //
        // Issue request to pathId specified.
        //
        status = IoCallDriver(targetInfo->DevFilter, Irp);

    } else {

        //
        // DSM wants to handle it internally.
        //
        // Init the event. We wait below, and the DSM
        // sets it when it's finished handling the request.
        //
        KeInitializeEvent(&event,
                          NotificationEvent,
                          FALSE);

        if (action == DSM_BROADCAST) {
   
            
            //
            // Give it to the DSM's Broadcast routine. The request
            // will be sent down all paths, and possibly be modified
            // from the original OpCode.
            // 
            status = dsm->BroadcastSrb(dsm->DsmContext,
                                       &diskExtension->DsmIdList,
                                       Irp,
                                       srb,
                                       &event);
            
        } else if (action == DSM_WILL_HANDLE) {

            //
            // Hand the request off to the DSM. 
            //
            status = dsm->SrbDeviceControl(dsm->DsmContext,
                                           &diskExtension->DsmIdList,
                                           Irp,
                                           srb,
                                           &event);
            
        } else {
            //
            // It's broken (DSM_ERROR).
            //
            // TODO handle this
            // Call InterpretError to see if it's a fail-over.
            // Set-up a bogus assert for the time being, until
            // this case is actually handled.
            //
            // Status is set by the DSM. Go ahead and propogate that
            // back.
            //
            ASSERT(action == DSM_BROADCAST); 
        }         
        
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
            status = Irp->IoStatus.Status;
        } else {

            //
            // Ensure that the DSM is returning status
            // correctly.
            //
            ASSERT(status == Irp->IoStatus.Status);
        }    

        //
        // The calling routine expects these to be completed here.
        //
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        InterlockedDecrement(&diskExtension->OutstandingRequests);
    }

    return status;
}


NTSTATUS
MPIOExecuteNone(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PMPIO_CONTEXT context = irpStack->Parameters.Others.Argument4;
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;
    NTSTATUS status;
    PREAL_DEV_INFO targetInfo = diskExtension->TargetInfo;

    //
    // If the path UID isn't set, try again.
    //
    if (targetInfo->PathUIDValue == FALSE) {

        targetInfo->Identifier = MPIOCreateUID(diskExtension->ControlObject,
                                               targetInfo->PathId);
        if (targetInfo->Identifier != 0) {
            targetInfo->PathUIDValue = TRUE;
        }
    }
    //
    // Set-up NULL context info as none of these requires
    // a special completion routine.
    //
    context->DsmCompletion.DsmCompletionRoutine = NULL;
    context->DsmCompletion.DsmContext = NULL;

    switch (srb->Function) {

        //
        // If it's a Claim ore Release, handle it here.
        // TODO: Lock these accesses.
        //
        case SRB_FUNCTION_CLAIM_DEVICE:

            //
            // Determine if a claim has already been made.
            // 
            if (diskExtension->IsClaimed) {
            
                //
                // Already been claimed. Return that the device
                // is busy.
                //
                srb->SrbStatus = SRB_STATUS_BUSY;
                status = STATUS_DEVICE_BUSY;

            } else {

                //
                // Indicate that the claim has been made
                // and return this deviceObject.
                //
                diskExtension->IsClaimed = TRUE;
                srb->DataBuffer = DeviceObject;
                status = STATUS_SUCCESS;
            }
            break;
            
        case SRB_FUNCTION_RELEASE_DEVICE:

            //
            // This is always successful.
            //
            srb->SrbStatus = SRB_STATUS_SUCCESS;
            status = STATUS_SUCCESS;
            break;
        default:

            //
            // These aren't handled - check to
            // see whether any do end up here.
            // LOG the error.
            //
            srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            status = STATUS_INVALID_DEVICE_REQUEST;

            MPDebugPrint((1,
                          "MPIOInternalDevControl: Unhandled Srb Function (%x)\n",
                          srb->Function));
            DbgBreakPoint();
            break;
    }
    return status;
}


NTSTATUS
MPIOPdoInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PMPIO_CONTEXT context = irpStack->Parameters.Others.Argument4;
    NTSTATUS status;
    BOOLEAN completeRequest = TRUE;
   
    //
    // Determine the what the request is.
    // The only requests handled here are EXECUTE_NONE
    //
    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_SCSI_EXECUTE_NONE:

            //
            // Handle all of the EXECUTE_NONE requests here.
            // This routine won't complete the request, so
            // do it below.
            //
            status = MPIOExecuteNone(DeviceObject,
                                     Irp);
            
            break;
            
        default:

            //
            // This routine will categorise the I/O and execute
            // the appropriate handler.
            //
            status = MPIOPdoHandleRequest(DeviceObject,
                                          Irp);

            //
            // Don't complete these
            //
            completeRequest = FALSE;
            break;
    }        


    if (completeRequest) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        InterlockedDecrement(&diskExtension->OutstandingRequests);
    }
                    

    return status; 
}


NTSTATUS
MPIOPdoUnhandled(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PMPIO_CONTEXT context = irpStack->Parameters.Others.Argument4;
   
    //
    // See what IRP_MJ the request is.
    //
    MPDebugPrint((1,
                  "MPIOPdoUnhandled: Major %x, Minor %x\n",
                  irpStack->MajorFunction,
                  irpStack->MinorFunction));
    
    context->DsmCompletion.DsmCompletionRoutine = NULL;
    context->DsmCompletion.DsmContext = NULL;

    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    InterlockedDecrement(&diskExtension->OutstandingRequests);
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
MPIOPdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PMPIO_CONTEXT context = irpStack->Parameters.Others.Argument4;
    NTSTATUS status;
    
    context->DsmCompletion.DsmCompletionRoutine = NULL;
    context->DsmCompletion.DsmContext = NULL;

    //
    // Determine the MinorFunction and call the appropriate
    // helper function.
    //
    switch (irpStack->MinorFunction) {
        case IRP_MN_QUERY_DEVICE_RELATIONS:

            //
            // Call the Qdr handler.
            //
            status = MPIOPdoQdr(DeviceObject, Irp);
            break;

        case IRP_MN_QUERY_ID:

            //
            // Call the QueryId routine.
            //
            status = MPIOPdoQueryId(DeviceObject, Irp);
            break;

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:

            //
            // Adjust the various counters depending upon the
            // Type of Usage Notification.
            //
            // Invalidate the device state
            //
            // complete the request.
            //
            //status = MPIODeviceUsage(DeviceObject,
            //                         Irp);
            status = STATUS_INVALID_DEVICE_REQUEST;
            
            break;
            
        case IRP_MN_QUERY_DEVICE_TEXT:

            //
            // Get the device text or location.
            //
            status = MPIOQueryDeviceText(DeviceObject, Irp);

            break;

        case IRP_MN_QUERY_CAPABILITIES: {
            PDEVICE_CAPABILITIES capabilities;

            capabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;

            //
            // Indicate no function driver is really necessary, suppress PnP Pop-ups
            // and the MPDisk's Id
            //
            capabilities->RawDeviceOK = 1;
            capabilities->SilentInstall = 1;
            capabilities->Address = diskExtension->DeviceOrdinal;

            status = STATUS_SUCCESS;

            break;
        }
                                        
        case IRP_MN_QUERY_PNP_DEVICE_STATE: {
            PPNP_DEVICE_STATE deviceState = (PPNP_DEVICE_STATE) &(Irp->IoStatus.Information);

            status = STATUS_SUCCESS;

            //
            // TODO: This depends on whether this is in the hibernate/page path.
            // Implement the check, and implement the IRP_MN_DEVICE_USAGE_NOTIFICATION
            //
            *deviceState |= PNP_DEVICE_NOT_DISABLEABLE;
            break;
        }

        case IRP_MN_QUERY_RESOURCES:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:

            //
            // Don't need resources and don't have a boot config.
            // Complete it successfully with a NULL buffer.
            //
            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = (ULONG_PTR)NULL;
            break;

        case IRP_MN_STOP_DEVICE:
            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = (ULONG_PTR) NULL;
            break;

        case IRP_MN_START_DEVICE:

            //
            // Register as a WMI provider.
            // 
            IoWMIRegistrationControl(DeviceObject,
                                     WMIREG_ACTION_REGISTER);

            //
            // Start the per-disk timer.
            //
            IoStartTimer(DeviceObject);
            status = STATUS_SUCCESS;
            break;
            
        case IRP_MN_QUERY_REMOVE_DEVICE:
            MPDebugPrint((1,
                        "MPIOPdoPnp: QueryRemove on (%x)\n",
                        DeviceObject));
            status = STATUS_DEVICE_BUSY;
            break;
            
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
        case IRP_MN_CANCEL_REMOVE_DEVICE:
        case IRP_MN_CANCEL_STOP_DEVICE:
        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_SURPRISE_REMOVAL:
        case IRP_MN_REMOVE_DEVICE:

            //
            // TODO
            //
            status = STATUS_SUCCESS;
            break;


                                            
        //
        // Send these down 
        //
        case IRP_MN_READ_CONFIG:
        case IRP_MN_WRITE_CONFIG:
        case IRP_MN_EJECT:
        case IRP_MN_SET_LOCK:
        case IRP_MN_QUERY_BUS_INFORMATION:

            InterlockedDecrement(&diskExtension->OutstandingRequests); 
            return MPIOForwardRequest(DeviceObject, Irp);
            break;

        //
        // The following requests are completed without status
        // being updated.
        //
        case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
            status = Irp->IoStatus.Status;
            break;

        case IRP_MN_QUERY_INTERFACE:
            MPDebugPrint((2,
                          "MPIOPdoPnP: Query Interface\n"));
        default:
            MPDebugPrint((2,
                          "MPIOPdoPnP: Not handled - (%x)\n",
                          irpStack->MinorFunction));
            DbgBreakPoint();
            status = Irp->IoStatus.Status;
            break;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    InterlockedDecrement(&diskExtension->OutstandingRequests); 
    return status;
}


NTSTATUS
MPIOPdoPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }
   
    PoStartNextPowerIrp(Irp);
    InterlockedDecrement(&diskExtension->OutstandingRequests); 
    return STATUS_SUCCESS;
}    

NTSTATUS
MPIOPdoPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PMPIO_CONTEXT context = irpStack->Parameters.Others.Argument4;
   
    MPDebugPrint((2,
                  "MPIOPdoPower: Got a %x power irp\n",
                  irpStack->MinorFunction));
    
    context->DsmCompletion.DsmCompletionRoutine = NULL;
    context->DsmCompletion.DsmContext = NULL;
    
    IoSetCompletionRoutine(Irp,
                           MPIOPdoPowerCompletion,
                           context,
                           TRUE,
                           TRUE,
                           TRUE);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    PoCallDriver(deviceExtension->LowerDevice, Irp);
    
    return STATUS_PENDING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\control\recover.c ===
/*++

Copyright (C) 1999-2000  Microsoft Corporation

Module Name:

    recover.c

Abstract:

    This module contains the code that carries out recovery operations for
    a failed path.

Author:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "mpath.h"

typedef struct _DSM_COMPLETION_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PSCSI_REQUEST_BLOCK Srb;
    PSENSE_DATA SenseBuffer;
    KEVENT Event;
    NTSTATUS Status;
} DSM_COMPLETION_CONTEXT, *PDSM_COMPLETION_CONTEXT;

NTSTATUS
MPathSendTUR(
    IN PDEVICE_OBJECT ChildDevice
    );

NTSTATUS
MPathAsynchronousCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );


VOID
MPathDelayRequest(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine handles delaying new requests when a failover is occurring.

Arguments:

    Context - The Irp to delay and complete with busy.

Return Value:

    None.

--*/
{
    PIRP irp = (PIRP)Context;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;
    LARGE_INTEGER delay;
    NTSTATUS status;

    MPDebugPrint((0,
                  "MPDelayRequest: Delaying completion of (%x)\n",
                  irp));

    //
    // Delay for at least 1 second.
    //
    delay.QuadPart = (LONGLONG)( - 10 * 1000 * (LONGLONG)1000);

    //
    // Stall while the failover is completed.
    //
    KeDelayExecutionThread(KernelMode, FALSE, &delay);

    //
    // In the process of failing over. Complete the request with busy status.
    //
    srb->SrbStatus = SRB_STATUS_ERROR;
    srb->ScsiStatus = SCSISTAT_BUSY;

    //
    // Complete the request. If all goes well, class will retry this.
    //
    status = STATUS_DEVICE_BUSY;
    irp->IoStatus.Status = status;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
    PsTerminateSystemThread(STATUS_SUCCESS);
}


VOID
MPathRecoveryThread(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is the thread proc that is started when a path is failed.
    It will check to see if the path is actually dead, or if it was merely a transient
    condition. If the path is dead, start the procedure to tear down the stack.

Arguments:

    Context - The device object of the pdisk containing the failed path + failure information.

Return Value:

    None.

--*/
{
    PMPATH_FAILURE_INFO failureInfo = Context;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    PPSEUDO_DISK_EXTENSION diskExtension;
    PPHYSICAL_PATH_DESCRIPTOR pathDescriptor;
    PDSM_INIT_DATA dsmData;
    LARGE_INTEGER delay;
    NTSTATUS status;
    ULONG index;
    ULONG retries;
    ULONG dsmError;
    KIRQL irql;

    //
    // Capture the relevant information concerning the failed path.
    //
    deviceObject = failureInfo->DeviceObject;
    deviceExtension = deviceObject->DeviceExtension;
    diskExtension = &deviceExtension->PseudoDiskExtension;
    index = failureInfo->FailedPathIndex;
    dsmData = &diskExtension->DsmData;
    pathDescriptor = diskExtension->DeviceDescriptors[index].PhysicalPath;


    //
    // TODO: Split this out into the DSMs 'recovery routine'.
    // TODO: Call DsmRecovery routine




    //
    // Send a TUR to each of the devices on the path.
    // This will help in determining whether it's a device or path
    // failure.
    //
    // For now, just send it to the failed device.
    // TODO: Set retries based on WMI information - default to 30.
    // TODO: Determine the number of devices on the path.
    //
    retries = 30;
    for (; retries > 0; retries--) {

        status = MPathSendTUR(diskExtension->DeviceDescriptors[index].TargetDevice);
        if (!NT_SUCCESS(status)) {

            MPDebugPrint((0,
                          "RecoveryThread: TUR returned %x\n",
                          status));

            //
            // If any failed, wait a bit, then retry.
            // Setup the delay for at least 1 second.
            //
            delay.QuadPart = (LONGLONG)( - 10 * 1000 * (LONGLONG)1000);
            KeDelayExecutionThread(KernelMode, FALSE, &delay);
        } else {

            //
            // Round two. Inquire whether this path is valid.
            //
            dsmError = 0;
            status = dsmData->DsmReenablePath(pathDescriptor->PhysicalPathId,
                                              &dsmError);
            if (status == STATUS_SUCCESS) {
                ULONG flags = 0;

                MPDebugPrint((0,
                              "RecoveryThread: Path is now Valid!\n"));

                //
                // Call the DSM to see whether this path is considered active.
                //
                if (dsmData->DsmIsPathActive(pathDescriptor->PhysicalPathId)) {
                    flags = PFLAGS_ACTIVE_PATH;

                }

                //
                // The path is good. Mark up the extension to indicate this.
                //
                KeAcquireSpinLock(&diskExtension->SpinLock,
                                  &irql);
                diskExtension->FailOver = 0;
                pathDescriptor->PathFlags &= ~PFLAGS_RECOVERY;
                pathDescriptor->PathFlags |= flags;

                KeReleaseSpinLock(&diskExtension->SpinLock, irql);

                //
                // TODO: Set the WMI event.
                //

                //
                // Terminate.
                //
                goto terminateThread;
            }
        }
    }

    //
    // Too many retries. Consider it dead.
    // Mark up the path flags to indicate so.
    //
    KeAcquireSpinLock(&diskExtension->SpinLock,
                      &irql);

    pathDescriptor->PathFlags |= PFLAGS_PATH_FAILED;

    KeReleaseSpinLock(&diskExtension->SpinLock, irql);


    //
    // TODO: Notify WMI of the failure.
    //

    MPDebugPrint((0,
                  "RecoveryThread: Giving up on the path.\n"));
    DbgBreakPoint();


    //
    // TODO: Do magic, to get the stack torn down.
    //

terminateThread:
    //
    // Commit suicide.
    //
    PsTerminateSystemThread(status);

}



NTSTATUS
MPathSendTUR(
    IN PDEVICE_OBJECT ChildDevice
    )

/*++

Routine Description:

Arguments:


Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION irpStack;
    PDSM_COMPLETION_CONTEXT completionContext;
    PIRP irp;
    PSCSI_REQUEST_BLOCK srb;
    PSENSE_DATA senseData;
    NTSTATUS status;
    PCDB cdb;

    //
    // Allocate an srb, the sense buffer, and context block for the request.
    //
    srb = ExAllocatePool(NonPagedPool,sizeof(SCSI_REQUEST_BLOCK));
    senseData = ExAllocatePool(NonPagedPoolCacheAligned, sizeof(SENSE_DATA));
    completionContext = ExAllocatePool(NonPagedPool, sizeof(DSM_COMPLETION_CONTEXT));

    if ((srb == NULL) || (senseData == NULL) || (completionContext == NULL)) {
        if (srb) {
            ExFreePool(srb);
        }
        if (senseData) {
            ExFreePool(senseData);
        }
        if (completionContext) {
            ExFreePool(completionContext);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Setup the context.
    //
    completionContext->DeviceObject = ChildDevice;
    completionContext->Srb = srb;
    completionContext->SenseBuffer = senseData;
    KeInitializeEvent(&completionContext->Event, NotificationEvent, FALSE);

    //
    // Zero out srb and sense data.
    //
    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    RtlZeroMemory(senseData, sizeof(SENSE_DATA));

    //
    // Build the srb.
    //
    srb->Length = SCSI_REQUEST_BLOCK_SIZE;
    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->TimeOutValue = 4;
    srb->SrbFlags = SRB_FLAGS_NO_DATA_TRANSFER;
    srb->SenseInfoBufferLength = sizeof(SENSE_DATA);
    srb->SenseInfoBuffer = senseData;

    //
    // Build the TUR CDB.
    //
    srb->CdbLength = 6;
    cdb = (PCDB)srb->Cdb;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

    //
    // Build the asynchronous request to be sent to the port driver.
    // Since this routine is called from a DPC the IRP should always be
    // available.
    //
    irp = IoAllocateIrp(ChildDevice->StackSize + 1, FALSE);

    if(irp == NULL) {

        ExFreePool(srb);
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    irpStack = IoGetNextIrpStackLocation(irp);
    irpStack->MajorFunction = IRP_MJ_SCSI;
    srb->OriginalRequest = irp;

    //
    // Store the SRB address in next stack for port driver.
    //
    irpStack->Parameters.Scsi.Srb = srb;


    IoSetCompletionRoutine(irp,
                           (PIO_COMPLETION_ROUTINE)MPathAsynchronousCompletion,
                           completionContext,
                           TRUE,
                           TRUE,
                           TRUE);


    //
    // Call the port driver with the IRP.
    //
    status = IoCallDriver(ChildDevice, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&completionContext->Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        status = completionContext->Status;
    }

    //
    // Free the allocations.
    //
    ExFreePool(completionContext);
    ExFreePool(srb);
    ExFreePool(senseData);

    return status;
}


NTSTATUS
MPathAsynchronousCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )
/*++

Routine Description:

    This routine is called when an asynchronous I/O request
    which was issused by the dsm completes.  Examples of such requests
    are release queue or test unit ready. This routine releases the queue if
    necessary.  It then frees the context and the IRP.

Arguments:

    DeviceObject - The device object for the logical unit; however since this
        is the top stack location the value is NULL.

    Irp - Supplies a pointer to the Irp to be processed.

    Context - Supplies the context to be used to process this request.

Return Value:

    None.

--*/

{
    PDSM_COMPLETION_CONTEXT context = Context;
    PSCSI_REQUEST_BLOCK srb;

    srb = context->Srb;

    //
    // If this is an execute srb, then check the return status and make sure.
    // the queue is not frozen.
    //

    if (srb->Function == SRB_FUNCTION_EXECUTE_SCSI) {

        //
        // Check for a frozen queue.
        //
        if (srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {

            //
            // Unfreeze the queue getting the device object from the context.
            //
            MPDebugPrint((1,
                         "DsmCompletion: Queue is frozen!!!!\n"));

            MPathReleaseQueue(context->DeviceObject);
        }
    }

    context->Status = Irp->IoStatus.Status;

    MPDebugPrint((0,
                  "DsmTURCompletion: Status %x, srbStatus %x Irp %x\n",
                  context->Status,
                  srb->SrbStatus,
                  Irp));

    //
    // Free the Irp.
    //
    IoFreeIrp(Irp);

    KeSetEvent(&context->Event, 0, FALSE);

    //
    // Indicate the I/O system should stop processing the Irp completion.
    //
    return STATUS_MORE_PROCESSING_REQUIRED;

}


VOID
MPathWorkerThread(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is the thread proc that is started during initialization.
    It will wait for an event, dequeue the event package, then start the appropriate thread to handle
    the condition.

Arguments:

    Context - The device object of the pdisk.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT deviceObject = (PDEVICE_OBJECT)Context;
    PDEVICE_EXTENSION deviceExtension = deviceObject->DeviceExtension;
    PPSEUDO_DISK_EXTENSION diskExtension = &deviceExtension->PseudoDiskExtension;
    PMPATH_WORKITEM workItem;
    HANDLE handle;
    PMPATH_FAILURE_INFO failureInfo;
    PLIST_ENTRY entry;
    NTSTATUS status;
    NTSTATUS threadStatus;

    while (TRUE) {
        workItem = NULL;

        //
        // Wait for something to be queued.
        //
        KeWaitForSingleObject(&diskExtension->WorkerEvent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        //
        // Clear the event.
        //
        KeClearEvent(&diskExtension->WorkerEvent);

        //
        // Extract the event package.
        //
        entry = ExInterlockedRemoveHeadList(&diskExtension->EventList,
                                            &diskExtension->SpinLock);

        ASSERT(entry);

        workItem = CONTAINING_RECORD(entry, MPATH_WORKITEM, ListEntry);
        if (workItem->EventId == MPATH_WI_UNLOAD) {

            //
            // TODO: If any threads running, shut them down.
            //

            //
            // Notification of shutdown.
            //
            PsTerminateSystemThread(STATUS_SUCCESS);
            return;

        } else if (workItem->EventId == MPATH_DELAYED_REQUEST) {
            PIRP irp = (PIRP)workItem->EventData;

            threadStatus = PsCreateSystemThread(&handle,
                                                (ACCESS_MASK)0,
                                                NULL,
                                                NULL,
                                                NULL,
                                                MPathDelayRequest,
                                                irp);
            if (!NT_SUCCESS(threadStatus)) {
                PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(irp);
                PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;

                MPDebugPrint((0,
                              "MPathWorker: DelayThread creation failed (%x) - Completing %x\n",
                              threadStatus,
                              irp));
                //
                // In the process of failing over. Complete the request with busy status.
                //
                srb->SrbStatus = SRB_STATUS_ERROR;
                srb->ScsiStatus = SCSISTAT_BUSY;

                //
                // Complete the request. If all goes well, class will retry this.
                //
                status = STATUS_DEVICE_BUSY;
                irp->IoStatus.Status = status;
                IoCompleteRequest(irp, IO_NO_INCREMENT);
            }

        } else if (workItem->EventId == MPATH_WI_FAILURE) {

            failureInfo = (PMPATH_FAILURE_INFO)workItem->EventData;

            //
            // Notification of a failover. Start the recovery thread.
            //
            threadStatus = PsCreateSystemThread(&handle,
                                                (ACCESS_MASK)0,
                                                NULL,
                                                NULL,
                                                NULL,
                                                MPathRecoveryThread,
                                                failureInfo);

            if (!NT_SUCCESS(threadStatus)) {
                KIRQL irql;

                //
                // TODO: Log an event, but don't puke.
                //

                //
                // Mark the path as being dead.
                //

                KeAcquireSpinLock(&diskExtension->SpinLock,
                                  &irql);

                diskExtension->DeviceDescriptors[failureInfo->FailedPathIndex].PhysicalPath->PathFlags |= PFLAGS_PATH_FAILED;

                KeReleaseSpinLock(&diskExtension->SpinLock, irql);

            }
        }
        if (workItem) {
            ExFreePool(workItem);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\control\thread.c ===
#include "mpio.h"


NTSTATUS
MPIOInitiateFailOver(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID FailingPath,
    IN ULONG ErrorMask
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PDSM_ENTRY dsm = &diskExtension->DsmInfo;
    PREAL_DEV_INFO targetInfo;
    PVOID newPath = NULL;
    NTSTATUS status;
    WCHAR buffer[64];


    MPDebugPrint((0,
                "InitiateFailOver: Invalidating %x\n",
                FailingPath));
    //
    // Initiate the fail-over.
    //
    status = dsm->InvalidatePath(dsm->DsmContext,
                                 ErrorMask,
                                 FailingPath,
                                 &newPath);

    MPDebugPrint((0,
                  "InitiateFailOver: New Path (%x)\n",
                  newPath));

    //
    // TODO - Put in real Path identiifiers.
    //
    swprintf(buffer,L"Path (%x) Failed Over to (%x)", FailingPath, newPath);
    MPIOFireEvent(DeviceObject,        
                  L"MPIO WrkerThrd", 
                  buffer,
                  MPIO_WARNING);
    
    //
    // If successful, go into DEGRADED
    //
    if ((status == STATUS_SUCCESS) && newPath) {

        //
        // Ensure that newPath actually is found in one of the TargetInfo
        // structures that make up this mpdisk.
        //
        targetInfo = MPIOGetTargetInfo(diskExtension,
                                       newPath,
                                       NULL);

        if (targetInfo == NULL) {
            MPDebugPrint((0,
                        "MPIOInitiateFailOver: No match for path (%x)\n",
                        newPath));
            DbgBreakPoint();
            return STATUS_NO_SUCH_DEVICE;
        }
       
        ASSERT(newPath == targetInfo->PathId);

        //
        // Verify that this path/device combo. is ready.
        // 
        status = dsm->PathVerify(dsm->DsmContext,
                                 targetInfo->DsmID,
                                 targetInfo->PathId);
        if (!NT_SUCCESS(status)) {
            MPDebugPrint((0,
                          "MPIOInitiateFailOver: PathVerify failed (%x)\n",
                          status));
            //
            // Log.
            //
            return status;
        }

        //
        // Ensure the new path is active.
        // Invalidate path should have done everything to assure that
        // the new device(s) are ready.
        //
        targetInfo->PathActive = dsm->IsPathActive(dsm->DsmContext,
                                                   newPath);
        ASSERT(targetInfo->PathActive);
       
        //
        // Set CurrentPath to this new one.
        //
        diskExtension->CurrentPath = newPath;

        //
        // Update all that are using this path, that it has changed.
        //
        MPIOSetNewPath(diskExtension->ControlObject,
                       newPath);
    } else {
        if (newPath == NULL) {
            MPDebugPrint((0,
                          "MPIOInitiateFailOver: DSM returned NULL path\n"));
          
        }

        if (status != STATUS_SUCCESS) {

            //
            // LOG
            //
            MPDebugPrint((0,
                          "MPIOInitiateFailOver: DSM returned (%x)\n",
                          status));
        }

        //
        // Set the path to NULL. The callback will key off this and the bad status.
        //
        diskExtension->CurrentPath = NULL;
        DbgBreakPoint();
    }    
    return status;
}


VOID
MPIORecoveryThread(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is the thread proc that is started upon creation of an mpdisk. 
    When signaled, it will initiate the fail-over, insure that the new path is
    ready, then call-back the mpdisk to indicate success or failure of the operation.
    
Arguments:

    Context - Info needed to handle the fail-over. 

Return Value:

    None.

--*/
{
    PMPIO_THREAD_CONTEXT context = Context;
    PDEVICE_OBJECT deviceObject = context->DeviceObject;
    PDEVICE_EXTENSION deviceExtension = deviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PKEVENT event = context->Event;
    PVOID failingPath;
    MPIO_CALLBACK RequestComplete;
    PMPIO_REQUEST_INFO requestInfo;
    PLIST_ENTRY entry;
    NTSTATUS status;
    ULONG i;

    KeSetPriorityThread(KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

    while (TRUE) {
        
        //
        // Wait on the event.
        //
        KeWaitForSingleObject(event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        KeClearEvent(event);

        //
        // Yank the packet.
        //
        entry = ExInterlockedRemoveHeadList(&diskExtension->WorkList,
                                            &diskExtension->WorkListLock);
        ASSERT(entry);

        //
        // Get the actual work item.
        //
        requestInfo = CONTAINING_RECORD(entry, MPIO_REQUEST_INFO, ListEntry);

        //
        // Get the call-back proc.
        //
        RequestComplete = requestInfo->RequestComplete;
        
        //
        // Determine the operation.
        //
        if (requestInfo->Operation == INITIATE_FAILOVER) {

            //
            // Get the device that indicated the failure.
            // 
            failingPath = requestInfo->OperationSpecificInfo;

            //
            // Asking for a fail-over. Call the handler.
            // 
            status = MPIOInitiateFailOver(deviceObject,
                                          failingPath,
                                          requestInfo->ErrorMask);
            

        } else if (requestInfo->Operation == SHUTDOWN) {

            //
            // Being signaled to die.
            //
            ExFreePool(requestInfo);
            goto terminateThread;

        } else if (requestInfo->Operation == FORCE_RESCAN) {
            PFLTR_ENTRY fltrEntry;
            
            fltrEntry = (PFLTR_ENTRY)(requestInfo->OperationSpecificInfo);
            MPIOForceRescan(fltrEntry->FilterObject);

            //
            // Indicate that the rescan is complete.
            // 
            fltrEntry->Flags &= ~FLTR_FLAGS_RESCANNING;

        } else if (requestInfo->Operation == PATH_REMOVAL) {

            PDSM_ENTRY dsm = &diskExtension->DsmInfo;

            MPDebugPrint((0,
                         "RecoveryThread: Removing Path (%x)\n",
                         requestInfo->OperationSpecificInfo));

            //
            // Call the dsm to clean up. All of the devices have been
            // removed, and any pending actions have been completed, so
            // it's safe to do this now.
            //
            dsm->RemovePath(dsm->DsmContext,
                            requestInfo->OperationSpecificInfo);
       
        } else if (requestInfo->Operation == DEVICE_REMOVAL) {
       
            PMPIO_DEVICE_REMOVAL deviceRemoval = requestInfo->OperationSpecificInfo;

            MPDebugPrint((0,
                        "RecoveryThread: Removing Device (%x) DsmID (%x)\n",
                        deviceRemoval->TargetInfo,
                        deviceRemoval->TargetInfo->DsmID));
            //
            // Invoke the remove routine.
            //
            status = MPIORemoveDeviceAsync(deviceRemoval->DeviceObject,
                                           deviceRemoval->TargetInfo);

            //
            // Free this allocation.
            //
            ExFreePool(deviceRemoval);
        
        } else {
            MPDebugPrint((0,
                         "MPIORecoveryThread: Invalid operation (%x) in (%x)\n",
                         requestInfo->Operation,
                         requestInfo));
            ASSERT(FALSE);
        }    
        
        if (RequestComplete) {

            //
            // Invoke the call-back routine to indicate
            // completion.
            // 
            RequestComplete(deviceObject,
                            requestInfo->Operation,
                            status);

            if (requestInfo->Operation == INITIATE_FAILOVER) {

                //
                // Force a rescan on the disks adapters.
                //
                for (i = 0; i < diskExtension->TargetInfoCount; i++ ) {
                    MPIOForceRescan(diskExtension->TargetInfo[i].DevFilter);
                }
            }
        }

        //
        // Dispose of the work item.
        //
        ExFreePool(requestInfo);
        
    }
    
terminateThread:    
    PsTerminateSystemThread(STATUS_SUCCESS);
            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\control\wmi.h ===
#ifndef _wmi_h_
#define _wmi_h_

// MPIO_DRIVE_INFO - MPIO_DRIVE_INFO
#define MPIO_DRIVE_INFOGuid \
    { 0xcb9d55b2,0xd833,0x4a4c, { 0x8c,0xaa,0x4a,0xee,0x3f,0x24,0x0e,0x9a } }

DEFINE_GUID(MPIO_DRIVE_INFO_GUID, \
            0xcb9d55b2,0xd833,0x4a4c,0x8c,0xaa,0x4a,0xee,0x3f,0x24,0x0e,0x9a);


typedef struct _MPIO_DRIVE_INFO
{
    // 
    ULONG NumberPaths;
    #define MPIO_DRIVE_INFO_NumberPaths_SIZE sizeof(ULONG)
    #define MPIO_DRIVE_INFO_NumberPaths_ID 1

    // 
    WCHAR Name[63 + 1];
    #define MPIO_DRIVE_INFO_Name_ID 2

    // 
    WCHAR SerialNumber[63 + 1];
    #define MPIO_DRIVE_INFO_SerialNumber_ID 3

    // 
    WCHAR DsmName[63 + 1];
    #define MPIO_DRIVE_INFO_DsmName_ID 4

} MPIO_DRIVE_INFO, *PMPIO_DRIVE_INFO;

// MPIO_DISK_INFO - MPIO_DISK_INFO
// Multi-Path Device List
#define MPIO_DISK_INFOGuid \
    { 0x9f9765ed,0xc3a0,0x451f, { 0x86,0xc1,0x47,0x0a,0x1d,0xdd,0x32,0x17 } }

DEFINE_GUID(MPIO_DISK_INFO_GUID, \
            0x9f9765ed,0xc3a0,0x451f,0x86,0xc1,0x47,0x0a,0x1d,0xdd,0x32,0x17);


typedef struct _MPIO_DISK_INFO
{
    // Number of Multi-Path Drives.
    ULONG NumberDrives;
    #define MPIO_DISK_INFO_NumberDrives_SIZE sizeof(ULONG)
    #define MPIO_DISK_INFO_NumberDrives_ID 1

    // Multi-Path Drive Info Array.
    MPIO_DRIVE_INFO DriveInfo[1];
    #define MPIO_DISK_INFO_DriveInfo_ID 2

} MPIO_DISK_INFO, *PMPIO_DISK_INFO;

// MPIO_ADAPTER_INFORMATION - MPIO_ADAPTER_INFORMATION
#define MPIO_ADAPTER_INFORMATIONGuid \
    { 0xb87c0fec,0x88b7,0x451d, { 0xa3,0x78,0x38,0x7b,0xa6,0x1a,0xeb,0x89 } }

DEFINE_GUID(MPIO_ADAPTER_INFORMATION_GUID, \
            0xb87c0fec,0x88b7,0x451d,0xa3,0x78,0x38,0x7b,0xa6,0x1a,0xeb,0x89);


typedef struct _MPIO_ADAPTER_INFORMATION
{
    // 
    ULONGLONG PathId;
    #define MPIO_ADAPTER_INFORMATION_PathId_SIZE sizeof(ULONGLONG)
    #define MPIO_ADAPTER_INFORMATION_PathId_ID 1

    // 
    UCHAR BusNumber;
    #define MPIO_ADAPTER_INFORMATION_BusNumber_SIZE sizeof(UCHAR)
    #define MPIO_ADAPTER_INFORMATION_BusNumber_ID 2

    // 
    UCHAR DeviceNumber;
    #define MPIO_ADAPTER_INFORMATION_DeviceNumber_SIZE sizeof(UCHAR)
    #define MPIO_ADAPTER_INFORMATION_DeviceNumber_ID 3

    // 
    UCHAR FunctionNumber;
    #define MPIO_ADAPTER_INFORMATION_FunctionNumber_SIZE sizeof(UCHAR)
    #define MPIO_ADAPTER_INFORMATION_FunctionNumber_ID 4

    // 
    UCHAR Pad;
    #define MPIO_ADAPTER_INFORMATION_Pad_SIZE sizeof(UCHAR)
    #define MPIO_ADAPTER_INFORMATION_Pad_ID 5

    // 
    WCHAR AdapterName[63 + 1];
    #define MPIO_ADAPTER_INFORMATION_AdapterName_ID 6

} MPIO_ADAPTER_INFORMATION, *PMPIO_ADAPTER_INFORMATION;

// MPIO_PATH_INFORMATION - MPIO_PATH_INFORMATION
// Multi-Path Path Information.
#define MPIO_PATH_INFORMATIONGuid \
    { 0xb3a05997,0x2077,0x40a3, { 0xbf,0x36,0xeb,0xd9,0x1f,0xf8,0xb2,0x54 } }

DEFINE_GUID(MPIO_PATH_INFORMATION_GUID, \
            0xb3a05997,0x2077,0x40a3,0xbf,0x36,0xeb,0xd9,0x1f,0xf8,0xb2,0x54);


typedef struct _MPIO_PATH_INFORMATION
{
    // Number of Paths in use
    ULONG NumberPaths;
    #define MPIO_PATH_INFORMATION_NumberPaths_SIZE sizeof(ULONG)
    #define MPIO_PATH_INFORMATION_NumberPaths_ID 1

    // Array of Adapter/Path Information.
    MPIO_ADAPTER_INFORMATION PathList[1];
    #define MPIO_PATH_INFORMATION_PathList_ID 2

} MPIO_PATH_INFORMATION, *PMPIO_PATH_INFORMATION;

// MPIO_CONTROLLER_INFO - MPIO_CONTROLLER_INFO
#define MPIO_CONTROLLER_INFOGuid \
    { 0xe732405b,0xb15e,0x4872, { 0xaf,0xd0,0x0d,0xf6,0x9d,0xc1,0xbb,0x01 } }

DEFINE_GUID(MPIO_CONTROLLER_INFO_GUID, \
            0xe732405b,0xb15e,0x4872,0xaf,0xd0,0x0d,0xf6,0x9d,0xc1,0xbb,0x01);


typedef struct _MPIO_CONTROLLER_INFO
{
    // 
    ULONGLONG ControllerId;
    #define MPIO_CONTROLLER_INFO_ControllerId_SIZE sizeof(ULONGLONG)
    #define MPIO_CONTROLLER_INFO_ControllerId_ID 1

    // 
    ULONG ControllerState;
    #define MPIO_CONTROLLER_INFO_ControllerState_SIZE sizeof(ULONG)
    #define MPIO_CONTROLLER_INFO_ControllerState_ID 2

    // 
    WCHAR AssociatedDsm[63 + 1];
    #define MPIO_CONTROLLER_INFO_AssociatedDsm_ID 3

} MPIO_CONTROLLER_INFO, *PMPIO_CONTROLLER_INFO;

// MPIO_CONTROLLER_CONFIGURATION - MPIO_CONTROLLER_CONFIGURATION
// Array Controller Information.
#define MPIO_CONTROLLER_CONFIGURATIONGuid \
    { 0xcf07da2c,0xe598,0x45d2, { 0x9d,0x78,0x75,0xc3,0x8b,0x81,0x64,0xe8 } }

DEFINE_GUID(MPIO_CONTROLLER_CONFIGURATION_GUID, \
            0xcf07da2c,0xe598,0x45d2,0x9d,0x78,0x75,0xc3,0x8b,0x81,0x64,0xe8);


typedef struct _MPIO_CONTROLLER_CONFIGURATION
{
    // Number of Controllers.
    ULONG NumberControllers;
    #define MPIO_CONTROLLER_CONFIGURATION_NumberControllers_SIZE sizeof(ULONG)
    #define MPIO_CONTROLLER_CONFIGURATION_NumberControllers_ID 1

    // Array of Controller Information Structures.
    MPIO_CONTROLLER_INFO ControllerInfo[1];
    #define MPIO_CONTROLLER_CONFIGURATION_ControllerInfo_ID 2

} MPIO_CONTROLLER_CONFIGURATION, *PMPIO_CONTROLLER_CONFIGURATION;

// MPIO_EventEntry - MPIO_EventEntry
// MultiPath Event Logger
#define MPIO_EventEntryGuid \
    { 0x2abb031a,0x71aa,0x46d4, { 0xa5,0x3f,0xea,0xe3,0x40,0x51,0xe3,0x57 } }

DEFINE_GUID(MPIO_EventEntry_GUID, \
            0x2abb031a,0x71aa,0x46d4,0xa5,0x3f,0xea,0xe3,0x40,0x51,0xe3,0x57);


typedef struct _MPIO_EventEntry
{
    // Time Stamp
    ULONGLONG TimeStamp;
    #define MPIO_EventEntry_TimeStamp_SIZE sizeof(ULONGLONG)
    #define MPIO_EventEntry_TimeStamp_ID 1


// Fatal Error
#define MPIO_FATAL_ERROR 1
// Error
#define MPIO_ERROR 2
// Warning
#define MPIO_WARNING 3
// Information
#define MPIO_INFORMATION 4

    // 
    ULONG Severity;
    #define MPIO_EventEntry_Severity_SIZE sizeof(ULONG)
    #define MPIO_EventEntry_Severity_ID 2

    // Component
    WCHAR Component[63 + 1];
    #define MPIO_EventEntry_Component_ID 3

    // Event Description
    WCHAR EventDescription[63 + 1];
    #define MPIO_EventEntry_EventDescription_ID 4

} MPIO_EventEntry, *PMPIO_EventEntry;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\control\utils.c ===
#include "mpio.h"
#include <stdio.h>
#include <ntddk.h> 

ULONG CheckState = 0;


PDEVICE_OBJECT
IoGetLowerDeviceObject(
    IN PDEVICE_OBJECT DeviceObject
    );

PREAL_DEV_INFO
MPIOGetTargetInfo(
    IN PMPDISK_EXTENSION DiskExtension,
    IN PVOID PathId,
    IN PDEVICE_OBJECT Filter
    )
{
    PREAL_DEV_INFO targetInfo = DiskExtension->TargetInfo;
    ULONG i;

    MPDebugPrint((3,
                  "MPIOGetTargetInfo: PathId(%x) Filter (%x) TargetInfo (%x)\n",
                  PathId,
                  Filter,
                  targetInfo));
    //
    // If PathId was passed in, the caller is looking for
    // the targetInfo match based on Path.
    //
    if (PathId) {
        //
        // Check each of the targetInfo structs for the
        // appropriate PathId.
        //
        for (i = 0; i < DiskExtension->TargetInfoCount; i++) {
            if (targetInfo->PathId == PathId) {
                return targetInfo;
            }

            //
            // Go to the next targetInfo.
            //
            targetInfo++;
        }
    } else if (Filter) {
       
        //
        // Looking for a DsmId match.
        // 
        for (i = 0; i < DiskExtension->TargetInfoCount; i++) {
            if (targetInfo->AdapterFilter == Filter) {
                return targetInfo;
            }
            targetInfo++;
        }
    } else {
        ASSERT(PathId || Filter);
    }    

    ASSERT(FALSE);
    
    //
    // PathId and DsmId were not found.
    //
    return NULL;
}


PDISK_ENTRY
MPIOGetDiskEntry(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG DiskIndex
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PLIST_ENTRY entry;
    ULONG i;

    //
    // Ensure that the Index is in range.
    //
    if ((DiskIndex + 1) > controlExtension->NumberDevices) {
        return NULL;
    }

    //
    // Run the list of MPDisk entries up to DiskIndex.
    //
    entry = controlExtension->DeviceList.Flink;
    for (i = 0; i < DiskIndex; entry = entry->Flink, i++) {
#if DBG
        PDISK_ENTRY diskEntry;

        diskEntry = CONTAINING_RECORD(entry, DISK_ENTRY, ListEntry);
        ASSERT(diskEntry);
    
        MPDebugPrint((2,
                     "MPIOGetDiskEntry: Index (%x) diskEntry (%x)\n",
                     i,
                     diskEntry));
#endif        
    }

    //
    // Return the DISK_ENTRY
    //
    return CONTAINING_RECORD(entry, DISK_ENTRY, ListEntry);
}    


BOOLEAN
MPIOFindLowerDevice(
    IN PDEVICE_OBJECT MPDiskObject,
    IN PDEVICE_OBJECT LowerDevice
    )
{
    PDEVICE_EXTENSION deviceExtension = MPDiskObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    ULONG i;

    //
    // Search for LowerDevice in array of underlying PDO's.
    //
    for (i = 0; i < diskExtension->TargetInfoCount; i++) {
        if (diskExtension->TargetInfo[i].PortPdo == LowerDevice) {
            return TRUE;
        }
    }
   
    return FALSE;
}    



PDSM_ENTRY
MPIOGetDsm(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG DsmIndex
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PLIST_ENTRY entry;
    ULONG i;

    //
    // See if requested index is in range. 
    // 
    if ((DsmIndex + 1) > controlExtension->NumberDSMs) {
        return NULL;
    }
    
    //
    // Get the first entry.
    // 
    entry = controlExtension->DsmList.Flink;

    //
    // Run the list to DsmIndex.
    //
    for (i = 0; i < DsmIndex; entry = entry->Flink, i++) {
#if DBG
        PDSM_ENTRY dsmEntry;

        dsmEntry = CONTAINING_RECORD(entry, DSM_ENTRY, ListEntry);
        ASSERT(dsmEntry);
    
        MPDebugPrint((2,
                     "MPIOGetDsm: Index (%x) dsmEntry (%x)\n",
                     i,
                     dsmEntry));
#endif        
    }

    //
    // Return the entry.
    //
    return CONTAINING_RECORD(entry, DSM_ENTRY, ListEntry);
}    


PCONTROLLER_ENTRY
MPIOFindController(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT ControllerObject,
    IN ULONGLONG Id
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PCONTROLLER_ENTRY controllerEntry;
    PLIST_ENTRY entry;

    //
    // Run the list of controller entries looking 
    //
    for (entry = controlExtension->ControllerList.Flink;
         entry != &controlExtension->ControllerList;
         entry = entry->Flink) {

        controllerEntry = CONTAINING_RECORD(entry, CONTROLLER_ENTRY, ListEntry);
        if ((controllerEntry->ControllerInfo->ControllerIdentifier == Id) &&
            (controllerEntry->ControllerInfo->DeviceObject == ControllerObject)){
            return controllerEntry;
        }
    }
    return NULL;
}
   

PFLTR_ENTRY
MPIOGetFltrEntry(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT PortFdo,
    IN PDEVICE_OBJECT AdapterFilter
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PFLTR_ENTRY fltrEntry;
    PLIST_ENTRY entry;
    
    for (entry = controlExtension->FilterList.Flink;
         entry != &controlExtension->FilterList;
         entry = entry->Flink) {
        
        fltrEntry = CONTAINING_RECORD(entry, FLTR_ENTRY, ListEntry);
        if (PortFdo) {

            if (fltrEntry->PortFdo == PortFdo) {
                return fltrEntry;

            }
        } else if (AdapterFilter) {

            if (fltrEntry->FilterObject == AdapterFilter) {
                return fltrEntry;

            }
        }
    }
    return NULL;
}


ULONG
MPIOGetPathCount(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID PathId
    )
{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PDEVICE_EXTENSION mpdiskExtension;
    PMPDISK_EXTENSION diskExtension;
    PREAL_DEV_INFO deviceInfo;
    PDEVICE_OBJECT diskObject;
    PDISK_ENTRY diskEntry;
    ULONG deviceCount = 0;
    ULONG i;
    ULONG j;

    //
    // Get each mpdisk in turn.
    //
    for (i = 0; i < controlExtension->NumberDevices; i++) {
        diskEntry = MPIOGetDiskEntry(DeviceObject,
                                     i);

        diskObject = diskEntry->PdoObject;
        mpdiskExtension = diskObject->DeviceExtension;
        diskExtension = mpdiskExtension->TypeExtension;
        deviceInfo = diskExtension->TargetInfo;

        //
        // Find the path on this disk.
        //
        for (j = 0; j < diskExtension->TargetInfoCount; j++) {
            if (deviceInfo->PathId == PathId) {

                //
                // Found it, bump the total.
                //
                deviceCount++;
                
            }

            //
            // Go to the next deviceInfo.
            //
            deviceInfo++;
        }
    }

    MPDebugPrint((1,
                  "MPIOGetPathCount: %u devices on Path (%x)\n",
                  deviceCount,
                  PathId));
    
    return deviceCount;
}


NTSTATUS
MPIOAddSingleDevice(
    IN PDEVICE_OBJECT ControlObject,
    IN PADP_DEVICE_INFO DeviceInfo,
    IN PDEVICE_OBJECT PortObject,
    IN PDEVICE_OBJECT FilterObject
    )
{
    PDSM_ENTRY entry;
    ULONG i;
    PVOID dsmExtension;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN claimed = FALSE;

    //
    // Run through each of the registered DSMs. The DO and
    // associated info will be passed to each, where they have
    // the opportunity to claim ownership.
    //
    i = 0;
    do {

        //
        // Get the next DSM entry.
        // 
        entry = MPIOGetDsm(ControlObject, i);
        if (entry) {

            //
            // See if the DSM wants this device.
            // 
            status = entry->InquireDriver(entry->DsmContext,
                                          DeviceInfo->DeviceObject,
                                          PortObject,
                                          DeviceInfo->DeviceDescriptor,
                                          DeviceInfo->DeviceIdList,
                                          &dsmExtension);
            
            if (status == STATUS_SUCCESS) {

                //
                // Ensure the DSM returned something.
                //
                ASSERT(dsmExtension);

                //
                // The DSM has indicated that it wants control of this device.
                // 
                claimed = TRUE;

                //
                // Get more DSM info and handle setting up the MPDisk
                //
                status = MPIOHandleNewDevice(ControlObject,
                                             FilterObject,
                                             PortObject,
                                             DeviceInfo,
                                             entry,
                                             dsmExtension);
                if (!NT_SUCCESS(status)) {

                    //
                    // LOG an error. TODO.
                    // 
                    claimed = FALSE;
                }
            }
        }
        i++;

    } while ((claimed == FALSE) && entry);

    return status;
}


NTSTATUS
MPIOHandleDeviceArrivals(
    IN PDEVICE_OBJECT DeviceObject,
    IN PADP_DEVICE_LIST DeviceList,
    IN PDEVICE_RELATIONS CachedRelations,
    IN PDEVICE_RELATIONS Relations,
    IN PDEVICE_OBJECT PortObject,
    IN PDEVICE_OBJECT FilterObject,
    IN BOOLEAN NewList
    )
{
    NTSTATUS status;
    ULONG devicesAdded = 0;
    ULONG i;
    ULONG j;
    ULONG k;
    BOOLEAN matched = FALSE;

    ASSERT(DeviceList->NumberDevices == Relations->Count);
    
    //
    // The list in Relations and DeviceList contain the same objects
    // at this point. CachedRelations contains the state prior to this call.
    // 
    if (NewList == FALSE) {

        //
        // Compare the two relations structs to find the added devices.
        //
        for (i = 0; i < Relations->Count; i++) {

            for (j = 0; j < CachedRelations->Count; j++) {
                if (Relations->Objects[i] == CachedRelations->Objects[j]) {
                    matched = TRUE;
                    break;
                }
            }
            if (matched == FALSE) {

                //
                // Find it in the DeviceList.
                //
                for (k = 0; k < DeviceList->NumberDevices; k++) {

                    if (Relations->Objects[i] == DeviceList->DeviceList[k].DeviceObject) {

                        //
                        // Add this one.
                        // 
                        status = MPIOAddSingleDevice(DeviceObject,
                                                     &DeviceList->DeviceList[k], 
                                                     PortObject,
                                                     FilterObject);
                        devicesAdded++;
                        break;
                    }    
                }
                
            } else {
                matched = FALSE;
            }    
        }            

    } else {

        //
        // All devices need to be added.
        //
        //
        for (i = 0; i < Relations->Count; i++) {

            //
            // Add this one.
            // 
            status = MPIOAddSingleDevice(DeviceObject,
                                         &DeviceList->DeviceList[i],
                                         PortObject,
                                         FilterObject);
            devicesAdded++;
        }
    }

    MPDebugPrint((1,
                 "HandleDeviceArrivals: Added (%u)\n", devicesAdded));
    return STATUS_SUCCESS;
}


PDEVICE_RELATIONS
MPIOHandleDeviceRemovals(
    IN PDEVICE_OBJECT DeviceObject,
    IN PADP_DEVICE_LIST DeviceList,
    IN PDEVICE_RELATIONS Relations
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PDEVICE_RELATIONS newRelations;
    ULONG i;
    ULONG j;
    ULONG k;
    ULONG devicesRemoved = 0;
    BOOLEAN matched = FALSE;
    BOOLEAN removed = FALSE;
    PDISK_ENTRY diskEntry;
    NTSTATUS status;

    
    //
    // For each device in the device relations (the current list), try to
    // find it in the DeviceList (the new list)
    //
    for (i = 0; i < Relations->Count; i++) {
        for (j = 0; j < DeviceList->NumberDevices; j++) {
            if (Relations->Objects[i] == DeviceList->DeviceList[j].DeviceObject) {
                matched = TRUE;
                MPDebugPrint((1,
                              "HandleDeviceRemoval: Found (%x)\n",
                              Relations->Objects[i]));
                break;
            }
        }
        if (matched == FALSE) {

            //
            // Remove Relations->Objects[i].
            // 
            MPDebugPrint((1,
                          "HandleDeviceRemoval: Removing (%x)\n",
                          Relations->Objects[i]));

            //
            // Find the correct mpdisk object.
            //
            for (k = 0; k < controlExtension->NumberDevices; k++) {
                diskEntry = MPIOGetDiskEntry(DeviceObject,
                                             k);

                if (MPIOFindLowerDevice(diskEntry->PdoObject,
                                        Relations->Objects[i])) {

                    status = MPIORemoveSingleDevice(diskEntry->PdoObject,
                                                    Relations->Objects[i]);
                    if (status == STATUS_PENDING) {

                        //
                        // This indicates that the device has outstanding IO's.
                        // It will be removed once these complete.
                        //
                        continue;
                    }
                    devicesRemoved++;
                    removed = TRUE;
                    
                }    
            }
            if ((removed == FALSE) && (status != STATUS_PENDING)) {
                MPDebugPrint((0,"HandleDeviceRemoval: Device marked for removal wasn't (%x)\n",
                            Relations->Objects[i]));
                ASSERT(removed);
            }
        }
        matched = FALSE;
        removed = FALSE;
    }

    MPDebugPrint((0,
                 "HandleDeviceRemoval: Removed (%u) devices\n",
                 devicesRemoved));

    newRelations = MPIOBuildRelations(DeviceList);
    return newRelations;
}


NTSTATUS
MPIORemoveDeviceEntry(
    IN PDEVICE_OBJECT DeviceObject,
    IN PREAL_DEV_INFO TargetInfo
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PVOID pathId;
    ULONG count;
    ULONG moveCount;
    ULONG newMask;
    ULONG i;
    ULONG k;
    NTSTATUS status;


    MPDebugPrint((0,
                  "RemoveDeviceEntry: Removing %x from %x\n",
                  TargetInfo,
                  DeviceObject));
    //
    // The caller should be holding the config spinlock.
    // 
    //
    // Determine the array entry for this deviceInfo.
    //
    count = diskExtension->TargetInfoCount;
    for (i = 0; i < count; i++) {
        MPDebugPrint((1,
                    "RemoveDeviceEntry: Checking %x vs. %x\n",
                    diskExtension->TargetInfo[i].PortPdo,
                    TargetInfo->PortPdo));
                
        if (diskExtension->TargetInfo[i].PortPdo == TargetInfo->PortPdo) {
            diskExtension->DeviceMap &= ~ (1 << i);

            //
            // Move only those AFTER the removed entry.
            // 
            moveCount = count - i;
            moveCount -= 1;
            
            //
            // Collapse the targetInfo array.
            //
            RtlMoveMemory(&diskExtension->TargetInfo[i],
                          &diskExtension->TargetInfo[i+1],
                          (moveCount * sizeof(REAL_DEV_INFO)));
           
            //
            // Indicate that there is one less entry.
            //
            diskExtension->TargetInfoCount--;

            //
            // Update the device map to reflect the new state of the world.
            //
            for (k = 0, newMask = 0; k < diskExtension->TargetInfoCount; k++) {
                newMask |= (1 << k);
            }

            MPDebugPrint((1,
                          "RemoveDeviceEntry: Old Mask (%x) new mask (%x)\n",
                          diskExtension->DeviceMap,
                          newMask));

            InterlockedExchange(&diskExtension->DeviceMap, newMask);

            //
            // Zero out the last vacated entry.
            //
            RtlZeroMemory(&diskExtension->TargetInfo[count - 1], sizeof(REAL_DEV_INFO));
            break;
        }
    }
    return STATUS_SUCCESS;

}    

NTSTATUS
MPIORemoveSingleDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT Pdo
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PREAL_DEV_INFO deviceInfo;
    PDEVICE_OBJECT diskObject;
    PDSM_ENTRY dsm;
    PVOID pathId = NULL;
    ULONG i;
    ULONG k;
    ULONG count;
    ULONG moveCount;
    ULONG removedIndex = (ULONG)-1;
    ULONG newMask;
    ULONG remainingDevices; 
    NTSTATUS status;
    KIRQL irql;
    BOOLEAN matched = FALSE;

    dsm = &diskExtension->DsmInfo;

    //
    // Grab this disk's spinlock. The submit path does the same.
    // 
    KeAcquireSpinLock(&diskExtension->SpinLock, &irql);
    
    //
    // Find the corresponding targetInfo.
    //
    count = diskExtension->TargetInfoCount;
    deviceInfo = diskExtension->TargetInfo;
    for (i = 0; i < count; i++) {
                
        //
        // If this deviceInfo has Pdo, then break.
        //
        if (deviceInfo->PortPdo == Pdo) {
            matched = TRUE; 
            break;
        } else {
            deviceInfo++;
        }    
    }
    ASSERT(matched == TRUE);
    
    if ((deviceInfo == NULL) || (matched == FALSE)) {
        MPDebugPrint((0,
                     "RemoveSingleDevice: Device not found\n"));
       
        //
        // For some reason, the device has already been removed.
        //
        KeReleaseSpinLock(&diskExtension->SpinLock, irql);

        return STATUS_DEVICE_NOT_CONNECTED;
    }

    MPDebugPrint((0,
                 "RemoveSingleDevice: Removing %x from %x. DsmID %x\n",
                 deviceInfo,
                 DeviceObject,
                 deviceInfo->DsmID));
                 
    //
    // Tell the DSM that this device is about to go away.
    //
    status = dsm->RemovePending(dsm->DsmContext,
                                deviceInfo->DsmID);

    //
    // Collapse our DsmId list so that we are in sync with the dsm.
    // Do this even though we may not remove the targetInfo entry.
    //
    count = diskExtension->DsmIdList.Count;
    for (i = 0; i < count; i++) {
                
        if (diskExtension->DsmIdList.IdList[i] == deviceInfo->DsmID) {

            //
            // Set the index. This is used if we can actually remove the device from
            // our and the DSM's lists.
            //
            removedIndex = i;
            
            //
            // One less DsmId in the list.
            //
            diskExtension->DsmIdList.Count--;

            //
            // Determine the number of entries to move in order to collapse 
            // all the entries after this one. 
            //
            moveCount = count - i;
            moveCount -= 1;

            //
            // Collapse the array.
            //
            RtlMoveMemory(&diskExtension->DsmIdList.IdList[i],
                          &diskExtension->DsmIdList.IdList[i + 1],
                          (moveCount * sizeof(PVOID)));
                          
            diskExtension->DsmIdList.IdList[count - 1] = NULL;
            break;
        }
    }

    //
    // The DSM ID has to have been in the list.
    //
    ASSERT(removedIndex != (ULONG)-1);
    
    //
    // If there are any outstanding IO's, then we can't remove this yet.
    //
    if (deviceInfo->Requests) {
        MPDebugPrint((0,
                      "RemoveSingleDevice: Pending removal for DeviceInfo (%x). DsmID (%x)\n",
                      deviceInfo,
                      deviceInfo->DsmID));

        //
        // The completion path will check this if outstanding requests go to zero and
        // handle the removal there.
        //
        deviceInfo->NeedsRemoval = TRUE;
    
        KeReleaseSpinLock(&diskExtension->SpinLock, irql);
        return STATUS_PENDING;
    }
    
    MPDebugPrint((1,
                  "RemoveSingleDevice: Removing (%x). DeviceInfo (%x). DsmID (%x)\n",
                  Pdo,
                  deviceInfo,
                  deviceInfo->DsmID));
    
    //
    // Call the DSM to remove this DsmID.
    // 
    dsm = &diskExtension->DsmInfo;
    status = dsm->RemoveDevice(dsm->DsmContext,
                               deviceInfo->DsmID,
                               deviceInfo->PathId);

    if (!NT_SUCCESS(status)) {

        //
        // LOG
        // 
    }

    //
    // Save off the pathId.
    //
    pathId = deviceInfo->PathId;
   
    //
    // Remove the deviceInfo element.
    //
    status = MPIORemoveDeviceEntry(DeviceObject,
                                   deviceInfo);
   
    //
    // Release the config spinlock.
    //
    KeReleaseSpinLock(&diskExtension->SpinLock, irql);

    //
    // Determine whether pathId needs to be removed.
    //
    remainingDevices = MPIOGetPathCount(diskExtension->ControlObject,
                                        pathId);
    if (remainingDevices == 0) {

        //
        // Can't remove the path if we aren't in a steady-state condition.
        // If not normal or degraded, mark the remove as pending.
        // queue a work-item and the state transition logic will fire the remove
        // when it's OK.
        //
        //if ((deviceExtension->State == MPIO_STATE_NORMAL) ||
        //    (deviceExtension->State == MPIO_STATE_DEGRADED)) {
        if (FALSE) {

            MPDebugPrint((0,
                          "RemoveSingleDevice: Removing path (%x). Disk (%x) in State (%x)\n",
                          pathId,
                          DeviceObject,
                          deviceExtension->State));
            //
            // All devices on this path have been removed,
            // Go ahead and remove the path.
            //
            dsm->RemovePath(dsm->DsmContext,
                            pathId);
        } else {
            PMPIO_REQUEST_INFO requestInfo;

            MPDebugPrint((0,
                         "RemoveSingle: Queuing removal of path (%x). Disk (%x) in State (%x)\n",
                         pathId,
                         DeviceObject,
                         deviceExtension->State));
                         
            //
            // Allocate a work item
            // Fill it in to indicate a path removal. 
            // 
            requestInfo = ExAllocatePool(NonPagedPool, sizeof(MPIO_REQUEST_INFO));

            requestInfo->RequestComplete = NULL;
            requestInfo->Operation = PATH_REMOVAL;

            //
            // Set the Path that should be removed.
            // 
            requestInfo->OperationSpecificInfo = pathId;
            requestInfo->ErrorMask = 0;

            ExInterlockedInsertTailList(&diskExtension->PendingWorkList,
                                        &requestInfo->ListEntry,
                                        &diskExtension->WorkListLock);

            //
            // Indicate that an item is in the pending list.
            //
            diskExtension->PendingItems++;
        }

    }
    return STATUS_SUCCESS;
}


NTSTATUS
MPIOHandleRemoveAsync(
    IN PDEVICE_OBJECT DeviceObject,
    IN PREAL_DEV_INFO TargetInfo
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PMPIO_REQUEST_INFO requestInfo;
    PMPIO_DEVICE_REMOVAL deviceRemoval;

    //
    // Allocate the request packet and the removal info struct.
    // 
    requestInfo = ExAllocatePool(NonPagedPool, sizeof(MPIO_REQUEST_INFO));
    deviceRemoval = ExAllocatePool(NonPagedPool, sizeof(MPIO_DEVICE_REMOVAL));
    
    //
    // No completion callback necessary.
    // 
    requestInfo->RequestComplete = NULL;

    //
    // Indicate that this is a remove operation.
    // 
    requestInfo->Operation = DEVICE_REMOVAL;

    //
    // Setup the removal info.
    // 
    deviceRemoval->DeviceObject = DeviceObject;
    deviceRemoval->TargetInfo = TargetInfo;

    //
    // Set the removal info as SpecificInfo
    // 
    requestInfo->OperationSpecificInfo = deviceRemoval;
    requestInfo->ErrorMask = 0;

    //
    // Queue it to the pending work list. The tick handler will put this
    // on the thread's work queue.
    //
    ExInterlockedInsertTailList(&diskExtension->PendingWorkList,
                                &requestInfo->ListEntry,
                                &diskExtension->WorkListLock);

    //
    // Tell the tick handler that there is work to do.
    //
    diskExtension->PendingItems++;

    return STATUS_SUCCESS;

}


NTSTATUS
MPIORemoveDeviceAsync(
    IN PDEVICE_OBJECT DeviceObject,
    IN PREAL_DEV_INFO TargetInfo
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PDSM_ENTRY dsm;
    KIRQL irql;
    NTSTATUS status;
    PVOID dsmId;
    PVOID pathId;
    ULONG remainingDevices;

    //
    // BUGBUG: Need to document fully that RemoveDevice will be called
    // at DPC. If there is push-back from IHV's, then this will need to
    // be put on a thread.
    //
    //
    // Capture the dsm and path ID's as the call to RemoveDeviceEntry
    // will invalidate the TargetInfo structure.
    //
    dsmId = TargetInfo->DsmID;
    pathId = TargetInfo->PathId;
    
    KeAcquireSpinLock(&diskExtension->SpinLock, &irql);

    //
    // Remove our info structure.
    // 
    MPIORemoveDeviceEntry(DeviceObject,
                          TargetInfo);

    KeReleaseSpinLock(&diskExtension->SpinLock, irql);

    //
    // Call the DSM to remove this DsmID.
    // 
    dsm = &diskExtension->DsmInfo;
    status = dsm->RemoveDevice(dsm->DsmContext,
                               dsmId,
                               pathId);
    //
    // Determine whether pathId needs to be removed.
    //
    remainingDevices = MPIOGetPathCount(diskExtension->ControlObject,
                                        pathId);
    if (remainingDevices == 0) {

        PMPIO_REQUEST_INFO requestInfo;

        MPDebugPrint((0,
                     "RemoveSingleAsync: Queuing removal of path (%x). Disk (%x) in State (%x)\n",
                     pathId,
                     DeviceObject,
                     deviceExtension->State));
                     
        //
        // Allocate a work item
        // Fill it in to indicate a path removal. 
        // 
        requestInfo = ExAllocatePool(NonPagedPool, sizeof(MPIO_REQUEST_INFO));

        requestInfo->RequestComplete = NULL;
        requestInfo->Operation = PATH_REMOVAL;

        //
        // Set the Path that should be removed.
        // 
        requestInfo->OperationSpecificInfo = pathId;
        requestInfo->ErrorMask = 0;

        ExInterlockedInsertTailList(&diskExtension->PendingWorkList,
                                    &requestInfo->ListEntry,
                                    &diskExtension->WorkListLock);

        //
        // Indicate that an item is in the pending list.
        //
        diskExtension->PendingItems++;
#if 0        
        //
        // All devices on this path have been removed,
        // Go ahead and remove the path.
        //
        dsm->RemovePath(dsm->DsmContext,
                        pathId);
#endif        

    }
    return status;
}


NTSTATUS
MPIOHandleNewDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT FilterObject,
    IN PDEVICE_OBJECT PortObject,
    IN PADP_DEVICE_INFO DeviceInfo,
    IN PDSM_ENTRY DsmEntry,
    IN PVOID DsmExtension
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PDEVICE_OBJECT diskObject;
    PDISK_ENTRY diskEntry;
    NTSTATUS status;
    ULONG i;
    BOOLEAN matched = FALSE;
  
    //
    // Run the list of MPDisk PDO's to see whether the new 
    // device corresponds to an already existing one.
    // 
    for (i = 0; i < controlExtension->NumberDevices; i++) {

        //
        // Get the next disk entry.
        // 
        diskEntry = MPIOGetDiskEntry(DeviceObject,
                                     i);
        if (diskEntry) {

            //
            // Feed the MPDisk object to this routine, which will call
            // the DSMCompareRoutine to see if an MP state is present.
            // 
            if (MPIOFindMatchingDevice(diskEntry->PdoObject,
                                       DeviceInfo,
                                       DsmEntry,
                                       DsmExtension)) {

                matched = TRUE;
                
                //
                // Got a match. Update the MPDisk.
                // PdoObject IS the mpdisk D.O.
                //
                status = MPIOUpdateDevice(diskEntry->PdoObject,
                                          FilterObject,
                                          PortObject,
                                          DeviceInfo,
                                          DsmExtension);
                return status; 
            }
        } else {
            MPDebugPrint((1,
                        "MPIOHandleNew: Some error.\n"));
            DbgBreakPoint();
            //
            // This certainly shouldn't happen, unless the internal
            // state is hosed.
            // 
            // Log Error. TODO
            //
            status = STATUS_UNSUCCESSFUL;
        }
    }

    if (matched == FALSE) {

        //
        // Didn't match up any. Build a new PDO.
        //
        status = MPIOCreateDevice(DeviceObject,
                                  FilterObject,
                                  PortObject,
                                  DeviceInfo,
                                  DsmEntry,
                                  DsmExtension,
                                  &diskObject);

        if (status == STATUS_SUCCESS) {

            //
            //  Indicate that one more multi-path disk
            //  has been created.
            //
            controlExtension->NumberDevices++;

            
            //
            // Build a disk entry
            //
            diskEntry = ExAllocatePool(NonPagedPool, sizeof(DISK_ENTRY));
            ASSERT(diskEntry);

            RtlZeroMemory(diskEntry, sizeof(DISK_ENTRY));
        
            //
            // Set the new mp disk's DO.
            //
            diskEntry->PdoObject = diskObject;

            //
            // Add it to the list of mpdisks
            //
            ExInterlockedInsertTailList(&controlExtension->DeviceList,
                                        &diskEntry->ListEntry,
                                        &controlExtension->SpinLock);

            IoInvalidateDeviceRelations(deviceExtension->Pdo, BusRelations);
        }
    } else {

        MPDebugPrint((2,
                    "MPIOHandleNew: Not creating a disk.\n"));
    }    
    
    return status;
}    


NTSTATUS
MPIOForwardRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine sends the Irp to the next driver in line
    when the Irp is not processed by this driver.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(deviceExtension->LowerDevice, Irp);
}


NTSTATUS
MPIOSyncCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    General-purpose completion routine, used for handling 'sync' requests
    such as PnP.

Arguments:

    DeviceObject
    Irp
    Context - The event on which the caller is waiting.

Return Value:

    NTSTATUS

--*/

{
    PKEVENT event = Context;

    MPDebugPrint((2,
                  "MPIOSyncCompletion: Irp %x\n",
                  Irp));

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }
    KeSetEvent(event, 0, FALSE);


    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
MPIOGetScsiAddress(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PSCSI_ADDRESS *ScsiAddress
    )
/*++

Routine Description:

    This routine issues the appropriate IOCTL to get the scsi address of DeviceObject.
    The storage allocated becomes the responsibility of the caller.

Arguments:

    DeviceObject - Device Object for a scsiport pdo returned in QDR.
    ScsiAddress - pointer for the scsi address buffer.

Return Value:

    Status of the request

--*/
{
    PSCSI_ADDRESS scsiAddress;
    PIO_STATUS_BLOCK ioStatus;
    PIRP irp;
    NTSTATUS status;

    //
    // Initialize the return values. This routine will only return success or
    // insufficient resources.
    //
    *ScsiAddress = NULL;
    status = STATUS_INSUFFICIENT_RESOURCES;

    //
    // Allocate storage. It's the caller's responsibility to free
    // it.
    // 
    scsiAddress = ExAllocatePool(NonPagedPool, sizeof(SCSI_ADDRESS));
    if (scsiAddress) {

        //
        // Don't use a stack variable, as we could switch to a different
        // thread.
        //
        ioStatus = ExAllocatePool(NonPagedPool, sizeof(IO_STATUS_BLOCK));

        //
        // Send the request
        // 
        MPLIBSendDeviceIoControlSynchronous(IOCTL_SCSI_GET_ADDRESS,
                                            DeviceObject,
                                            NULL,
                                            scsiAddress,
                                            0,
                                            sizeof(SCSI_ADDRESS),
                                            FALSE,
                                            ioStatus);
        status = ioStatus->Status;
        if (status == STATUS_SUCCESS) {

            //
            // Update the caller's pointer with the returned
            // information.
            //
            *ScsiAddress = scsiAddress;
        }
    }
    ExFreePool(ioStatus);
    return status;
}


PMPIO_CONTEXT
MPIOAllocateContext(
    IN PDEVICE_EXTENSION DeviceExtension
    )
{
    PMPIO_CONTEXT context;
    ULONG freeIndex;
    ULONG i;
    KIRQL irql;
   
    //
    // Try to get the context structure from the list.
    // 
    context = ExAllocateFromNPagedLookasideList(&DeviceExtension->ContextList);
    if (context == NULL) {

        //
        // No/Low memory condition. Use one of the emergency buffers.
        //
        KeAcquireSpinLock(&DeviceExtension->EmergencySpinLock,
                          &irql);
        
        //
        // Find a clear bit. Never use '0', as the check in the FreeContext
        // routine keys off the value of EmergencyIndex;
        //
        for (i = 1; i < MAX_EMERGENCY_CONTEXT; i++) {
            if (!(DeviceExtension->EmergencyContextMap & (1 << i))) {

                //
                // Set the bit to indicate that this buffer is being used.
                // 
                DeviceExtension->EmergencyContextMap |= (1 << i);
                freeIndex = i;
                break;
            }
        }
        if (i == MAX_EMERGENCY_CONTEXT) {

            //
            // LOG something.
            //
            
        } else {

            //
            // Pull one from the reserved buffer.
            //
            context = DeviceExtension->EmergencyContext[freeIndex];
            context->EmergencyIndex = freeIndex;
        }    
        
        KeReleaseSpinLock(&DeviceExtension->EmergencySpinLock,
                          irql);

    } else {

        //
        // Indicate that this came from the Lookaside List.
        //
        context->EmergencyIndex = 0;
    }    
        
    return context;
}   


VOID
MPIOFreeContext(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PMPIO_CONTEXT Context
    )
{
    KIRQL irql;
   
    if (Context->Freed) {
        MPDebugPrint((0,
                     "FreeContext: Trying to free already freed context (%x)\n",
                     Context));
        DbgBreakPoint();
    }
    
    Context->Freed = TRUE;

    //
    // Determine is this came from the emergency list or from the lookaside list
    //
    if (Context->EmergencyIndex == 0) {
        ExFreeToNPagedLookasideList(&DeviceExtension->ContextList,
                                    Context);
    } else {

        KeAcquireSpinLock(&DeviceExtension->EmergencySpinLock,
                          &irql);

        //
        // Indicate that the buffer is now available.
        //
        DeviceExtension->EmergencyContextMap &= ~(1 << Context->EmergencyIndex);

        KeReleaseSpinLock(&DeviceExtension->EmergencySpinLock,
                          irql);

    }    

    return;
}   

VOID
MPIOCopyMemory(
   IN PVOID Destination,
   IN PVOID Source,
   IN ULONG Length
   )
{

    MPDebugPrint((0,
                  "MPIOCopyMemory: Dest %x, Src %x, Length %x\n",
                  Destination,
                  Source,
                  Length));
    RtlCopyMemory(Destination,
                  Source,
                  Length);
}


NTSTATUS
MPIOQueueRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PMPIO_CONTEXT Context,
    IN PMP_QUEUE Queue
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb;
    PMPQUEUE_ENTRY queueEntry;
    NTSTATUS status;
    KIRQL irql;

    //
    // Get a queue entry to package the request.
    // BUGBUG: Use LookAsideList, backed by pre-allocated entries.
    //
    queueEntry = ExAllocatePool(NonPagedPool, sizeof(MPQUEUE_ENTRY));
    if (queueEntry == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(queueEntry, sizeof(MPQUEUE_ENTRY));
    
    //
    // If this was a scsi request (vs. DeviceIoControl), the srb
    // was saved in the context.
    //
    if (irpStack->MajorFunction == IRP_MJ_SCSI) {
        
        //
        // Rebuild the srb using the saved request in the context.
        //
        srb = irpStack->Parameters.Scsi.Srb;
        
        RtlCopyMemory(srb,
                      &Context->Srb,
                      sizeof(SCSI_REQUEST_BLOCK));
    }

    //
    // Indicate the Queue.
    //
    Context->QueuedInto = Queue->QueueIndicator;
    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;

    //
    // Save the irp address.
    //
    queueEntry->Irp = Irp;
   
    //
    // Jam onto the queue.
    //
    MPIOInsertQueue(Queue,
                    queueEntry);
    
    return STATUS_SUCCESS;
}


PMPIO_FAILOVER_INFO
MPIODequeueFailPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID PathId
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PMPIO_FAILOVER_INFO failPacket = NULL;
    PLIST_ENTRY entry;
    KIRQL irql;

    KeAcquireSpinLock(&controlExtension->SpinLock, &irql);

    for (entry = controlExtension->FailPacketList.Flink;
         entry != &controlExtension->FailPacketList;
         entry = entry->Flink) {

        failPacket = CONTAINING_RECORD(entry, MPIO_FAILOVER_INFO, ListEntry);
        if (failPacket->PathId == PathId) {
            break;
        } else {
            failPacket = NULL;
        }    
    }

    if (failPacket) {

        //
        // Yank it out of the queue.
        // 
        RemoveEntryList(entry);

        //
        // Dec the number of entries.
        //
        InterlockedDecrement(&controlExtension->NumberFOPackets);
    }

    KeReleaseSpinLock(&controlExtension->SpinLock, irql);

    MPDebugPrint((1,
                 "DequeueFailPacket: Returning (%x). CurrentCount (%x)\n",
                 failPacket,
                 controlExtension->NumberFOPackets));

    return failPacket;
}    

PVOID CurrentFailurePath = NULL;


VOID
MPIOFailOverCallBack(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Operation,
    IN NTSTATUS Status
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PREAL_DEV_INFO targetInfo;
    NTSTATUS status;
    PDEVICE_OBJECT failDevice;
    PDEVICE_EXTENSION failDevExt;
    PMPDISK_EXTENSION failDiskExt;
    PMPIO_FAILOVER_INFO failPacket;
    ULONG state;
    ULONG numberPackets = 0;
    PLIST_ENTRY listEntry;
    WCHAR componentName[32];
    
    //
    // The thread successfully handled the fail-over and we are in WAIT1
    // or it was unsuccessfull and we are still IN_FO.
    // TODO: Handle failure case.
    //
    ASSERT(Status == STATUS_SUCCESS);
    ASSERT(Operation == INITIATE_FAILOVER);
    ASSERT(diskExtension->CurrentPath);

    MPDebugPrint((0,
                  "FailOverCallBack: Fail-Over on (%x) complete.\n",
                  DeviceObject));

    //
    // TODO remove hack.
    //
    CurrentFailurePath = NULL;

    //
    // Check to see whether the F.O. was successful. 
    //
    if ((Status != STATUS_SUCCESS) || (diskExtension->CurrentPath == NULL)) {

        //
        // Need to flush all of the queues and update State to STATE_FULL_FAILURE.
        // TODO BUGBUG.
        //
        MPDebugPrint((0,
                      "FailOverCallBack: Status (%x). Path (%x)\n",
                      Status,
                      diskExtension->CurrentPath));
        DbgBreakPoint();
        
    }

    //
    // Run through the failOver list and extract all entries that match "PathId"
    //
    // For each one, run the code below.
    //
    do {

        failPacket = MPIODequeueFailPacket(diskExtension->ControlObject,
                                           diskExtension->FailedPath);
        if (failPacket) {
            failDevice = failPacket->DeviceObject;
            failDevExt = failDevice->DeviceExtension;
            failDiskExt = failDevExt->TypeExtension;

            numberPackets++;

            state = MPIOHandleStateTransition(failDevice);
           
            MPDebugPrint((0,
                         "FailOverCallBack: Handling (%x). CurrentState (%x)\n",
                         failDevice,
                         state));
            //
            // Get the target based on the new path that the fail-over handler
            // setup.
            // 
            targetInfo = MPIOGetTargetInfo(failDiskExt,
                                           failDiskExt->CurrentPath,
                                           NULL);
            if (state == MPIO_STATE_WAIT2) {
                
                //
                // Queue a request for the timer to run rescans after the fail-back 
                // period expires.
                //
                failDiskExt->RescanCount = 15; 

                //
                // Issue all requests down the new path.
                //
                status = MPIOIssueQueuedRequests(targetInfo,
                                                 &failDiskExt->ResubmitQueue,
                                                 MPIO_STATE_WAIT2,
                                                 &failDiskExt->OutstandingRequests);
                
            } else if (state == MPIO_STATE_WAIT3) {

                //
                // Issue all requests down the new path.
                //
                status = MPIOIssueQueuedRequests(targetInfo,
                                                 &failDiskExt->FailOverQueue,
                                                 MPIO_STATE_WAIT3,
                                                 &failDiskExt->OutstandingRequests);
                
            } else if (state == MPIO_STATE_DEGRADED) {
                
                status = STATUS_SUCCESS;

            } else {

                ASSERT(state == MPIO_STATE_WAIT1);
                ASSERT(failDiskExt->OutstandingRequests);
                status = STATUS_SUCCESS;

            }    

            ASSERT((status == STATUS_SUCCESS) || (status == STATUS_PENDING));

            swprintf(componentName, L"MPIO Disk(%02d)", failDiskExt->DeviceOrdinal);
            status = MPIOFireEvent(failDevice,        
                                   componentName, 
                                   L"Fail-Over Complete",
                                   MPIO_INFORMATION);
            ExFreePool(failPacket);
            
        }
    } while (failPacket);
            
    if (numberPackets == 0) {
        MPDebugPrint((0,
                     "FailoverCallBack: No fail-over packets for %x\n",
                     diskExtension->FailedPath));
        ASSERT(FALSE);
    }
#if 0
    //
    // Check for any pending work items to start.
    //
    if (failDiskExt->PendingItems) {

        //
        // Yank the packet from the pending list...
        //
        listEntry = ExInterlockedRemoveHeadList(&diskExtension->PendingWorkList,
                                                &diskExtension->WorkListLock);

        //
        // ...and jam it on the work list.
        // 
        ExInterlockedInsertTailList(&failDiskExt->WorkList,
                                    listEntry,
                                    &failDiskExt->WorkListLock);

        InterlockedDecrement(&failDiskExt->PendingItems);

        //
        // Signal the thread to initiate the F.O.
        //
        KeSetEvent(&diskExtension->ThreadEvent,
                   8,
                   FALSE);
        

    }
#endif           
    return;
}



BOOLEAN
MPIOPathInFailOver(
    IN PVOID PathId,
    IN BOOLEAN Query
    )
{
    //
    // REDO THIS HACK. TODO.
    //
    if (Query) {
        return (PathId == CurrentFailurePath);
    } else {
        CurrentFailurePath = PathId;
    }
    return TRUE;
}


NTSTATUS
MPIOQueueFailPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT FailingDevice,
    IN PVOID PathId
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PMPIO_FAILOVER_INFO failPacket;
    
    //
    // Allocate a fail-over packet.
    //
    failPacket = ExAllocatePool(NonPagedPool, sizeof(MPIO_FAILOVER_INFO));
    if (failPacket == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Set the path, the d.o.
    //
    failPacket->DeviceObject = FailingDevice;
    failPacket->PathId = PathId;

    //
    // Inc the number of entries.
    //
    InterlockedIncrement(&controlExtension->NumberFOPackets);

    //
    // Put it on the list.
    //
    ExInterlockedInsertTailList(&controlExtension->FailPacketList,
                                &failPacket->ListEntry,
                                &controlExtension->SpinLock);
    return STATUS_SUCCESS;
}


NTSTATUS
MPIOFailOverHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG ErrorMask,
    IN PREAL_DEV_INFO FailingDevice
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    PMPIO_REQUEST_INFO requestInfo;
    NTSTATUS status;
    ULONG i;
    PFLTR_ENTRY fltrEntry;
    WCHAR componentName[32];
   
    ASSERT(FailingDevice->PathFailed == FALSE);
    //
    // Mark it as failed. TODO - Ensure if it's
    // brought back alive to update that.
    // 
    FailingDevice->PathFailed = TRUE;
    diskExtension->FailedPath = FailingDevice->PathId;
    
    //
    // Check to see whether there is only one path.
    // It's not necessarily a bad thing, the DSM could be controlling
    // hardware that hides the alternate path until a fail-over.
    // BUT, this is currently not supported.
    //
    // Alternatively, one or more devices could have already been removed.
    // In this case, allow the FailOver to happen.
    // TODO: Figure out how to best handle this. Perhaps always allow a single path
    // fail-over and handle the error on the other side...
    //
    if (diskExtension->DsmIdList.Count <= 1) {
        MPDebugPrint((0,
                      "MPIOFailOverHandler: Initiating F.O. on single path\n"));
        //
        // LOG
        //
    }
    

    //
    // Put this on the fail-over list. All of these devices will get notified
    // once the first F.O. completes. They will then start running the state-machine
    // to get any queued requests issued.
    //
    status = MPIOQueueFailPacket(diskExtension->ControlObject,
                                 DeviceObject,
                                 FailingDevice->PathId);
    if (!NT_SUCCESS(status)) {
        
        //
        // LOG the failure.
        //
        return status;
    }
   
    //
    // If the fail-over on this path has already been started,
    // don't do it again. There is a window where state is set by the first
    // failing device, but this one is in the completion routine.
    // 
    if (MPIOPathInFailOver(FailingDevice->PathId, 1)) {
        return STATUS_SUCCESS;
    }    

    MPDebugPrint((0,
                  "MPIOFailOverHandler: Failing Device (%x) on (%x). Failing Path (%x)\n",
                  FailingDevice,
                  DeviceObject,
                  FailingDevice->PathId));

    //
    // Set this as the current failing path.
    //
    MPIOPathInFailOver(FailingDevice->PathId, 0);
    
    //
    // Get all of the fltrEntry's for this disk.
    //
    for (i = 0; i < diskExtension->TargetInfoCount; i++) {
        fltrEntry = MPIOGetFltrEntry(diskExtension->ControlObject,
                                     diskExtension->TargetInfo[i].PortFdo,
                                     NULL);
        if (fltrEntry) {
            fltrEntry->Flags |= FLTR_FLAGS_NEED_RESCAN;
            fltrEntry->Flags &= ~(FLTR_FLAGS_QDR_COMPLETE | FLTR_FLAGS_QDR);
        }
    }

    //
    // Log the failure. TODO: Build a request and submit to thread.
    //
#if 0
    swprintf(componentName, L"MPIO Disk(%02d)", diskExtension->DeviceOrdinal);
    status = MPIOFireEvent(DeviceObject,        
                           componentName,
                           L"Fail-Over Initiated",
                           MPIO_FATAL_ERROR);
    MPDebugPrint((0,
                  "MPIOFailOver: Failing Device (%x) Path (%x) Status of Event (%x)\n",
                  FailingDevice,
                  FailingDevice->PathId,
                  status));
#endif    

    //
    // Allocate a work item
    // Fill it in to indicate a fail-over.
    // 
    requestInfo = ExAllocatePool(NonPagedPool, sizeof(MPIO_REQUEST_INFO));

    requestInfo->RequestComplete = MPIOFailOverCallBack;
    requestInfo->Operation = INITIATE_FAILOVER;

    //
    // Set the Path that should be failed.
    // 
    requestInfo->OperationSpecificInfo = FailingDevice->PathId;
    requestInfo->ErrorMask = ErrorMask;

    ExInterlockedInsertTailList(&diskExtension->WorkList,
                                &requestInfo->ListEntry,
                                &diskExtension->WorkListLock);

    //
    // Signal the thread to initiate the F.O.
    //
    KeSetEvent(&diskExtension->ThreadEvent,
               8,
               FALSE);
    
    return STATUS_SUCCESS;
}



VOID
MPIOSetRequestBusy(
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    PSENSE_DATA senseBuffer;
    
    //
    // Ensure that there is a sense buffer.
    //
    Srb->SrbStatus = SRB_STATUS_ERROR;
    Srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
    if ((Srb->SenseInfoBufferLength) && (Srb->SenseInfoBuffer)) {

        //
        // Build a sense buffer that will coerce the class drivers
        // into setting a delay, and retrying the request.
        //
        senseBuffer = Srb->SenseInfoBuffer;

        senseBuffer->ErrorCode = 0x70;
        senseBuffer->Valid = 1;
        senseBuffer->AdditionalSenseLength = 0xb;
        senseBuffer->SenseKey = SCSI_SENSE_NOT_READY;
        senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_LUN_NOT_READY;
        senseBuffer->AdditionalSenseCodeQualifier = SCSI_SENSEQ_BECOMING_READY;
        Srb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;
        
    } else {

        //
        // Hack based on class driver interpretation of errors. Returning this
        // will allow a retry interval.
        //
        Srb->ScsiStatus = SCSISTAT_BUSY;
    }
    return;
}


NTSTATUS
MPIOSetNewPath(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID PathId
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PDEVICE_EXTENSION diskExtension;
    PMPDISK_EXTENSION mpdiskExt;
    PDEVICE_OBJECT diskObject;
    PDISK_ENTRY diskEntry;
    NTSTATUS status;
    ULONG i;

    //
    // Go through each of the mpdisks and notify them that FailingPath
    // is considered dead. 
    //
    for (i = 0; i < controlExtension->NumberDevices; i++) {
        diskEntry = MPIOGetDiskEntry(DeviceObject,
                                     i);
        
        diskObject = diskEntry->PdoObject;
        diskExtension = diskObject->DeviceExtension;
        mpdiskExt = diskExtension->TypeExtension;
        mpdiskExt->NewPathSet = TRUE;

        InterlockedExchange(&(ULONG)mpdiskExt->CurrentPath, (ULONG)PathId);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
MPIOGetAdapterAddress(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PMPIO_ADDRESS Address
    )
{
    ULONG bus = 0;
    ULONG deviceFunction = 0;
    NTSTATUS status;
    ULONG bytesReturned;

    status = IoGetDeviceProperty(DeviceObject,
                                 DevicePropertyBusNumber,
                                 sizeof(ULONG),
                                 &bus,
                                 &bytesReturned);
    if (NT_SUCCESS(status)) {
        status = IoGetDeviceProperty(DeviceObject,
                                     DevicePropertyAddress,
                                     sizeof(ULONG),
                                     &deviceFunction,
                                     &bytesReturned);
    }
    if (NT_SUCCESS(status)) {

        Address->Bus = (UCHAR)bus;
        Address->Device = (UCHAR)(deviceFunction >> 16);
        Address->Function = (UCHAR)(deviceFunction & 0x0000FFFF);
        Address->Pad = 0;
    }
    return status;
}


NTSTATUS
MPIOCreatePathEntry(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT FilterObject,
    IN PDEVICE_OBJECT PortFdo,
    IN PVOID PathID
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PLIST_ENTRY entry;
    PID_ENTRY id;
    MPIO_ADDRESS address;
    ULONG bytesReturned;
    NTSTATUS status;
    PDEVICE_OBJECT tempDO;

    //
    // See whether the pathId already exists.
    // 
    for (entry = controlExtension->IdList.Flink;
         entry != &controlExtension->IdList;
         entry = entry->Flink) {
        
        id = CONTAINING_RECORD(entry, ID_ENTRY, ListEntry);
        if (id->PathID == PathID) {

            //
            // Already have an entry. Just return.
            //
            return STATUS_SUCCESS;
        }    
    }
    
    //
    // Didn't find it. Allocate an entry.
    //
    id = ExAllocatePool(NonPagedPool, sizeof(ID_ENTRY));
    if (id == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(id, sizeof(ID_ENTRY));
    id->AdapterName.Buffer = ExAllocatePool(NonPagedPool, FDO_NAME_LENGTH);
    RtlZeroMemory(id->AdapterName.Buffer, FDO_NAME_LENGTH);

    //
    // Set the max. length of the name.
    // 
    id->AdapterName.MaximumLength = FDO_NAME_LENGTH;

    //
    // Capture the rest of the values.
    //
    id->PathID = PathID;
    id->AdapterFilter = FilterObject;
    id->PortFdo = PortFdo;
    tempDO = IoGetLowerDeviceObject(PortFdo);
    
    //
    // Get the name.
    //
    status = IoGetDeviceProperty(tempDO,
                                 DevicePropertyDeviceDescription,
                                 id->AdapterName.MaximumLength,
                                 id->AdapterName.Buffer,
                                 &bytesReturned);
   
    //
    // Set the length - the terminating NULL.
    //
    id->AdapterName.Length = (USHORT)(bytesReturned - sizeof(UNICODE_NULL));
    
    //
    // Get the address.
    //
    status = MPIOGetAdapterAddress(tempDO,
                                   &id->Address);
    // 
    //
    // Jam this into the list.
    // 
    ExInterlockedInsertTailList(&controlExtension->IdList,
                                &id->ListEntry,
                                &controlExtension->SpinLock);

    //
    // Indicate the number of entries.
    //
    InterlockedIncrement(&controlExtension->NumberPaths);
    return STATUS_SUCCESS;

}


LONGLONG
MPIOCreateUID(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID PathID
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PLIST_ENTRY entry;
    PID_ENTRY id;
    UUID uuid;
    PUCHAR index;
    NTSTATUS status;
    LONGLONG collapsedUID;
    ULONG retryCount = 10;
    
    for ( entry = controlExtension->IdList.Flink;
          entry != &controlExtension->IdList;
          entry = entry->Flink) {
        
        id = CONTAINING_RECORD(entry, ID_ENTRY, ListEntry);
        if (id->PathID == PathID) {
            if (id->UID == 0) {

                //
                // Wasn't found. Create a new one.
                //
                status = ExUuidCreate(&uuid);
            
                if (status == STATUS_SUCCESS) {

                    //
                    // Collapse this down into a 64-bit value.
                    //
                    index = (PUCHAR)&uuid;
                    collapsedUID = (*((PLONGLONG) index)) ^ (*((PLONGLONG)(index + sizeof(LONGLONG))));

                    //
                    // Set the value.
                    // 
                    id->UID = collapsedUID;
                    id->UIDValid = TRUE;
                
                }
            }    
            return id->UID;
        }
    }
    
    return 0; 
}


ULONGLONG
MPIOBuildControllerInfo(
    IN PDEVICE_OBJECT ControlObject,
    IN PDSM_ENTRY Dsm,
    IN PVOID DsmID
    )
{
    PDEVICE_EXTENSION deviceExtension = ControlObject->DeviceExtension;
    PCONTROL_EXTENSION controlExtension = deviceExtension->TypeExtension;
    PCONTROLLER_INFO controllerInfo;
    PCONTROLLER_ENTRY tmpInfo;
    PCONTROLLER_ENTRY controllerEntry;
    ULONGLONG id = 0;
    NTSTATUS status;

    ASSERT(Dsm->GetControllerInfo);

    status =  Dsm->GetControllerInfo(Dsm->DsmContext,
                                     DsmID,
                                     DSM_CNTRL_FLAGS_ALLOCATE | DSM_CNTRL_FLAGS_CHECK_STATE,
                                     &controllerInfo);
    if (NT_SUCCESS(status)) {
        ASSERT(controllerInfo);

        //
        // grab the ID.
        // 
        id = controllerInfo->ControllerIdentifier;

        //
        // See whether the controller ID is part of the list.
        //
        tmpInfo = MPIOFindController(ControlObject,
                                     controllerInfo->DeviceObject,
                                     controllerInfo->ControllerIdentifier);
        if (tmpInfo) {

            //
            // The entry already exists so just update the state.
            // 
            tmpInfo->ControllerInfo->State = controllerInfo->State;

            //
            // Free the DSM's allocation.
            // 
            ExFreePool(controllerInfo);

        } else {

            //
            // Allocate an entry.
            //
            controllerEntry = ExAllocatePool(NonPagedPool, sizeof(CONTROLLER_ENTRY));
            if (controllerEntry) {
        
                RtlZeroMemory(controllerEntry, sizeof(CONTROLLER_ENTRY));

                //
                // Save this copy.
                // 
                controllerEntry->ControllerInfo = controllerInfo;
                
                //
                // Save the dsm entry. It will be used in the WMI
                // handling routines to get it's name.
                //
                controllerEntry->Dsm = Dsm;
   
                //
                // Jam it into the list.
                // 
                ExInterlockedInsertTailList(&controlExtension->ControllerList,
                                            &controllerEntry->ListEntry,
                                            &controlExtension->SpinLock);
                
                //
                // Indicate the additional entry.
                // 
                InterlockedIncrement(&controlExtension->NumberControllers);
                
            } else {
                id = 0;
            }    
        }    
    }
    
    return id;
}


ULONG
MPIOHandleStateTransition(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PMPDISK_EXTENSION diskExtension = deviceExtension->TypeExtension;
    ULONG currentState;
    ULONG requests;
    KIRQL irql;
    BOOLEAN complete = FALSE;

    KeAcquireSpinLock(&diskExtension->SpinLock, &irql);

    //
    // Capture the current state.
    // 
    currentState = deviceExtension->State;

    //
    // Run the state machine until there are no more 'events'.
    //
    do {
        switch (currentState) {
            case MPIO_STATE_IN_FO:

                //
                // See if the new path has been indicated.
                // 
                if (diskExtension->NewPathSet) {
                    MPDebugPrint((0,
                                 "HandleStateTransition: IN_FO moving to WAIT1\n"));

                    //
                    // Can now go to WAIT1
                    //
                    currentState = MPIO_STATE_WAIT1;

                    //
                    // Reset the flags.
                    //
                    diskExtension->NewPathSet = FALSE;
                    diskExtension->FailOver = FALSE;
                    
                } else {
                    complete = TRUE;
                }   
                break;
                
            case MPIO_STATE_WAIT1:

                //
                // The DSM has set the new path. See if all of the outstanding
                // requests have come back (and are on the resubmit queue).
                // 
                if (diskExtension->OutstandingRequests == 0) {
                    MPDebugPrint((0,
                                 "HandleStateTransition: WAIT1 moving to WAIT2\n"));
                
                    //
                    // Go to WAIT2
                    //
                    currentState = MPIO_STATE_WAIT2;
                    diskExtension->ResubmitRequests = diskExtension->ResubmitQueue.QueuedItems;
                    
                } else {
                    complete = TRUE;
                }
                break;
                
            case MPIO_STATE_WAIT2:

                //
                // Resubmit queue is being handled in this state.
                // Check to see if it's empty.
                //
                requests = diskExtension->ResubmitRequests;
                if (requests == 0) {

                    MPDebugPrint((0,
                                 "HandleStateTransition: WAIT2 moving to WAIT3\n"));
                    //
                    // Can go to WAIT3
                    //
                    currentState = MPIO_STATE_WAIT3;
                    diskExtension->FailOverRequests = diskExtension->FailOverQueue.QueuedItems;
                } else {

                    //
                    // Still draining the resubmit queue.
                    //
                    complete = TRUE;
                }
                break;
                
            case MPIO_STATE_WAIT3:

                //
                // The fail-over queue is being handled in WAIT3
                //
                requests = diskExtension->FailOverRequests;
                if (requests == 0) {
                    MPDebugPrint((0,
                                 "HandleStateTransition: WAIT3 moving to DEGRADED\n"));

                    //
                    // Can go to DEGRADED.
                    //
                    currentState = MPIO_STATE_DEGRADED;
                } else {

                    //
                    // Still have requests in the fail-over queue.
                    //
                    complete = TRUE;
                }
                break;
                
            case MPIO_STATE_DEGRADED:

                //
                // This indicates that we are minus at least one path.
                // Check to see whether it's been repaired.
                //
                if (diskExtension->PathBackOnLine) {

                    //
                    // Reset the flag.
                    // 
                    diskExtension->PathBackOnLine = FALSE;

                    //
                    // See if that puts us back to where we were. 
                    // 

                    if (diskExtension->TargetInfoCount == diskExtension->MaxPaths) {

                        //
                        // Go to NORMAL.
                        //
                        currentState = MPIO_STATE_NORMAL;
                    }    
                } else {

                    //
                    // Stay in DEGRADED.
                    //
                    complete = TRUE;
                }    
                break;
                
            case MPIO_STATE_NORMAL:

                //
                // Check the Fail-Over flag.
                //
                if (diskExtension->FailOver) {

                    //
                    // Go to FAIL-OVER.
                    //
                    currentState = MPIO_STATE_IN_FO;
                } else {
                    complete = TRUE;
                }    
                break;
                
            default:
                ASSERT(currentState == MPIO_STATE_NORMAL);
                complete = TRUE;
                break;
        }            


    } while (complete == FALSE);        

    //
    // Update the state.
    //
    deviceExtension->LastState = deviceExtension->State;
    deviceExtension->State = currentState;

    KeReleaseSpinLock(&diskExtension->SpinLock, irql);

    return currentState;
}


NTSTATUS
MPIOForceRescan(
    IN PDEVICE_OBJECT AdapterFilter
    )
{
    IO_STATUS_BLOCK ioStatus;
    
    MPDebugPrint((0,
                 "ForceRescan: Issueing rescan to (%x)\n",
                 AdapterFilter));

    MPLIBSendDeviceIoControlSynchronous(IOCTL_SCSI_RESCAN_BUS,
                                        AdapterFilter,
                                        NULL,
                                        NULL,
                                        0,
                                        0,
                                        FALSE,
                                        &ioStatus);
    MPDebugPrint((0,
                  "ForceRescan: Rescan on (%x) status (%x)\n",
                  AdapterFilter,
                  ioStatus.Status));
    
    return ioStatus.Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\control\wmi.c ===
#include "mpath.h"
#include <wmistr.h>
#include <wmidata.h>
#include <stdio.h>


#ifdef USE_BINARY_MOF_QUERY
//
// MOF data can be reported by a device driver via a resource attached to
// the device drivers image file or in response to a query on the binary
// mof data guid. Here we define global variables containing the binary mof
// data to return in response to a binary mof guid query. Note that this
// data is defined to be in a PAGED data segment since it does not need to
// be in nonpaged memory. Note that instead of a single large mof file
// we could have broken it into multiple individual files. Each file would
// have its own binary mof data buffer and get reported via a different
// instance of the binary mof guid. By mixing and matching the different
// sets of binary mof data buffers a "dynamic" composite mof would be created.

#ifdef ALLOC_DATA_PRAGMA
   #pragma data_seg("PAGED")
#endif

#pragma message ("USE_BINARY defined ChuckP")
UCHAR MPathBinaryMofData[] =
{
    #include "mpathwmi.x"
};
#ifdef ALLOC_DATA_PRAGMA
   #pragma data_seg()
#endif
#endif


WMIGUIDREGINFO MPathWmiGuidList[] = {
    {
        &MPath_Disk_Info_GUID, 
        1,
        0
    },
    {
        &MPath_Test_GUID,
        1,
        0
    },
    
    {
        &MSWmi_MofData_GUID,
        1,
#ifdef USE_BINARY_MOF_QUERY
        0
#else
        WMIREG_FLAG_REMOVE_GUID
#endif
    }
};    

#define DiskInformation 0
#define MPathTest    1
#define BinaryMofGuid   2

#define MPathGuidCount (sizeof(MPathWmiGuidList) / sizeof(WMIGUIDREGINFO))

//#define MPATH_GUID_PDISK_INFO      0
//#define MPATH_BINARY_MOF           1
//#define MPATH_GUID_FAILOVER_INFO   1
//#define MPATH_GUID_CONFIG_INFO     2
//#define MPATH_GUID_DSM_NAME        3
//#define MPATH_GUID_PATH_MAINTENACE 4
//
// Always update this for any guid additions.
// This indicates the dividing line between our and DSM
// guids.
//
//#define MPATH_MAX_GUID_INDEX MPATH_BINARY_MOF
//


NTSTATUS
MPathFdoWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);
    
    return IoCallDriver(deviceExtension->TargetObject, Irp);

}


NTSTATUS
MPathQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &deviceExtension->RegistryPath;
    *Pdo = deviceExtension->DeviceObject; 
    MPDebugPrint((0,
                "MPathQueryWmiRegInfo: *Pdo (%x), DeviceObject (%x)\n",
                *Pdo,
                DeviceObject));
#ifndef USE_BINARY_MOF_QUERY
#pragma message ("BIN NOT - ChuckP")
    //
    // Return the name specified in the .rc file of the resource which
    // contains the bianry mof data. By default WMI will look for this
    // resource in the driver image (.sys) file, however if the value
    // MofImagePath is specified in the driver's registry key
    // then WMI will look for the resource in the file specified there.
    RtlInitUnicodeString(MofResourceName, L"MofResourceName");
#endif

    return STATUS_SUCCESS;
}


NTSTATUS
MPathQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PPSEUDO_DISK_EXTENSION diskExtension = &deviceExtension->PseudoDiskExtension;
    NTSTATUS status;
    ULONG i;
    ULONG bytesReturned = 0;

    if (TRUE) { //(GuidIndex <= MPATH_MAX_GUID_INDEX) {

        //
        // This is for the pdisk
        // Ensure that this is a QUERY_SINGLE_INSTANCE, as these data blocks
        // are defined as having only one instance.
        //
        if (InstanceIndex != 0 || InstanceCount != 1) {
            status = STATUS_INVALID_DEVICE_REQUEST;
        } else {
            switch (GuidIndex) {
                case MPathTest:
                    bytesReturned = sizeof(ULONG);
                    if (bytesReturned > BufferAvail) {
                        status = STATUS_BUFFER_TOO_SMALL;
                    } else {
                        ULONG theValue = 0xaa55aa55;
                        
                      RtlCopyMemory(Buffer,
                                    &theValue,
                                    sizeof(ULONG));
                      status = STATUS_SUCCESS;
                                    
                    }
                    break;
                case DiskInformation: {
                    PMPath_Disk_Info diskInfo = (PMPath_Disk_Info)Buffer;
                    PSTORAGE_DEVICE_DESCRIPTOR storageDescriptor;
                    ULONG serialNumberLength;
                    ULONG totalStringLength;
                    PUCHAR serialNumber;
                    ANSI_STRING ansiSerialNumber;
                    UNICODE_STRING unicodeString;
                    
                    bytesReturned = sizeof(MPath_Disk_Info);

                    //
                    // Determine the serial number length.
                    //
                    storageDescriptor = 
                        diskExtension->DeviceDescriptors[0].StorageDescriptor; 
                    serialNumber = (PUCHAR)storageDescriptor;

                    //
                    // Move serialNumber to the correct position in RawData.
                    //
                    (ULONG_PTR)serialNumber += storageDescriptor->SerialNumberOffset;

                    //
                    // Get it's length.
                    //
                    serialNumberLength = strlen(serialNumber);
                    totalStringLength = serialNumberLength * sizeof(WCHAR);
                    totalStringLength += sizeof(USHORT);
                    totalStringLength *= diskExtension->NumberPhysicalPaths;
                    
 
                    bytesReturned += totalStringLength;
                    bytesReturned += (diskExtension->NumberPhysicalPaths - 1) *
                                     sizeof(PHYSICAL_DISK_INFO);
                    
                    
                    if (bytesReturned > BufferAvail) {
                        status = STATUS_BUFFER_TOO_SMALL;
                    } else {
                        PWCHAR index;
                        PDEVICE_DESCRIPTOR deviceDescriptor;
                        PPHYSICAL_DISK_INFO deviceInfo = diskInfo->DeviceInfo;
                        
                        diskInfo->NumberDrives = diskExtension->NumberPhysicalPaths;
                        diskInfo->IsLoadBalance = FALSE;

                        RtlInitAnsiString(&ansiSerialNumber, serialNumber);
                        RtlAnsiStringToUnicodeString(&unicodeString, &ansiSerialNumber, TRUE);

                        for (i = 0; i < diskExtension->NumberPhysicalPaths; i++) {

                            deviceDescriptor =
                                &diskExtension->DeviceDescriptors[i];
                            deviceInfo->BusType = 1;
                            deviceInfo->PortNumber =
                                deviceDescriptor->ScsiAddress->PortNumber;
                            deviceInfo->TargetId = 
                                deviceDescriptor->ScsiAddress->TargetId;
                            deviceInfo->Lun = 
                                deviceDescriptor->ScsiAddress->Lun;
                           
                            deviceInfo->CorrespondingPathId = 
                                (ULONG)deviceDescriptor->PhysicalPath->PhysicalPathId;
                            index = (PWCHAR)deviceInfo->VariableData;
                            *index++ = unicodeString.Length;
                            
                            RtlCopyMemory(index,
                                          unicodeString.Buffer,
                                          unicodeString.Length);
                            (ULONG_PTR)deviceInfo += 
                                   sizeof(PHYSICAL_DISK_INFO) + unicodeString.Length;
                        }

                        status = STATUS_SUCCESS;
                    }    
                    break;
                }                                           
#ifdef USE_BINARY_MOF_QUERY
                case BinaryMofGuid:
                {
                    bytesReturned = sizeof(MPathBinaryMofData);
                    MPDebugPrint((0,
                                "MPathQueryDataBlock: BinaryMofGuid\n"));
                    DbgBreakPoint();
                    if (BufferAvail < bytesReturned)
                    {
                        status = STATUS_BUFFER_TOO_SMALL;
                    } else {
                        RtlCopyMemory(Buffer, MPathBinaryMofData, bytesReturned);
                        status = STATUS_SUCCESS;
                    }
                    break;
                }
#endif
                default:
                    status = STATUS_WMI_GUID_NOT_FOUND;
                    break;
            }
        }    
    } else {

        //
        // This is for the DSM
        //
        status = STATUS_WMI_GUID_NOT_FOUND;
    }
    MPDebugPrint((0,
                "MpathQueryDataBlock: Buffer (%x) BytesReturned (%x). Status (%x)\n",
                Buffer,
                bytesReturned,
                status));

    //
    // Indicate the data length.
    // 
    *InstanceLengthArray = bytesReturned;
    
    status = WmiCompleteRequest(DeviceObject,
                              Irp,
                              status,
                              bytesReturned,
                              IO_NO_INCREMENT);
    return status;
}    


NTSTATUS
MPathSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
{
    NTSTATUS status;
    ULONG bytesReturned = 0;

    if (FALSE) { // (GuidIndex <= MPATH_MAX_GUID_INDEX) {
        status = STATUS_WMI_READ_ONLY;
    } else {
        //
        // DSM Guid
        // If there is a GUID match, call the dsm. It will have to call
        // DsmCompleteWMIRequest to finish the request.
        // DONOT complete it here, rather return the status from the DSM routine
        // TODO
        status = STATUS_WMI_GUID_NOT_FOUND;
    }
    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                bytesReturned,
                                IO_NO_INCREMENT);
    return status;
}    



NTSTATUS
MPathSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
{
    NTSTATUS status;
    ULONG bytesReturned = 0;

    if (TRUE) { // (GuidIndex <= MPATH_MAX_GUID_INDEX) {
        status = STATUS_WMI_READ_ONLY;
    } else {
        //
        // DSM Guid
        // TODO
        status = STATUS_WMI_GUID_NOT_FOUND;
    }
    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                bytesReturned,
                                IO_NO_INCREMENT);
    return status;
}    


NTSTATUS
MPathExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBuffersize,
    IN ULONG OutBufferSize,
    IN OUT PUCHAR Buffer
    )
{
    NTSTATUS status;
    ULONG bytesReturned = 0;
   
    if (TRUE) { //(GuidIndex <= MPATH_MAX_GUID_INDEX ) {
        switch (GuidIndex) {
            //case MPATH_GUID_PATH_MAINTENACE: {


                //
                // Need to verify the parameters.
                // TODO: Need data block that lists adapter
                //       (path) ids.
                //
                //status = MPathFailOver(id1, id2);
            //    status = STATUS_WMI_ITEMID_NOT_FOUND;
           // }
           // break;
            
        default:
            status = STATUS_WMI_ITEMID_NOT_FOUND;
            break;

        }    
    } else {
        
        status = STATUS_WMI_ITEMID_NOT_FOUND;
    }
    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                bytesReturned,
                                IO_NO_INCREMENT);
    return status;
       
}


NTSTATUS
MPathWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PPSEUDO_DISK_EXTENSION diskExtension = &deviceExtension->PseudoDiskExtension;
    NTSTATUS status;

    //
    // Handle the enabling/disabling of the datablocks/events
    //
#if 0
    if (GuidIndex == MPATH_GUID_FAILOVER_INFO) {
        if (Enable) {
            diskExtension->WmiEventsEnabled = TRUE;
        } else {

            diskExtension->WmiEventsEnabled = FALSE;
        }    

    } else {
#endif        
        status = STATUS_WMI_GUID_NOT_FOUND;
    //}    
    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                0,
                                IO_NO_INCREMENT);
    return status;
}


VOID
MPathSetupWmi(
    IN PDEVICE_EXTENSION DeviceExtension
    )
{
    if (DeviceExtension->Type == DEV_MPATH_CONTROL) {
       MPDebugPrint((0,
                   "MPathSetWmi: Control Object\n"));
       DbgBreakPoint();
    } else {
        PPSEUDO_DISK_EXTENSION diskExtension = &DeviceExtension->PseudoDiskExtension;

        diskExtension->WmiInfo.GuidCount = MPathGuidCount; 
        diskExtension->WmiInfo.GuidList = MPathWmiGuidList;
        diskExtension->WmiInfo.QueryWmiRegInfo = MPathQueryWmiRegInfo;
        diskExtension->WmiInfo.QueryWmiDataBlock = MPathQueryWmiDataBlock;
        diskExtension->WmiInfo.SetWmiDataBlock = MPathSetWmiDataBlock;
        diskExtension->WmiInfo.SetWmiDataItem = MPathSetWmiDataItem;
        diskExtension->WmiInfo.ExecuteWmiMethod = MPathExecuteWmiMethod;
        diskExtension->WmiInfo.WmiFunctionControl = MPathWmiFunctionControl;

    }    

}


NTSTATUS
MPathWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PUCHAR wmiBuffer = irpStack->Parameters.WMI.Buffer;
    ULONG bufferSize = irpStack->Parameters.WMI.BufferSize;
    ULONG savedLength = Irp->IoStatus.Information;
    PPSEUDO_DISK_EXTENSION diskExtension;
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;

    MPDebugPrint((0,
                 "MPathWmi: Irp (%x), MJ (%x), MN (%x)",
                 Irp,
                 irpStack->MajorFunction,
                 irpStack->MinorFunction));
    
    
    diskExtension = &deviceExtension->PseudoDiskExtension;

    status = WmiSystemControl(&diskExtension->WmiInfo,
                              DeviceObject,
                              Irp,
                              &disposition);

    MPDebugPrint((0,
                "Disposition is (%x). Status (%x)\n",
                disposition,
                status));
    switch (disposition) {
        case IrpProcessed:

            //
            // Already processed and the DpWmiXXX routines specified in WmiInfo will 
            // complete it.
            //
            break;
            
        case IrpNotCompleted:

            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
            
        case IrpNotWmi:
        case IrpForward:    
        default:
            //
            // Need to ensure this is the pseudodisk
            //
            if (deviceExtension->Type == DEV_MPATH_CONTROL) {

                MPDebugPrint((0,
                            " for Control\n"));
                //
                // Call the 'control' (FDO) handler.
                //
                return MPathFdoWmi(DeviceObject, Irp);
            } else {
                //
                // This is the PDO, so just complete it without touching anything. 
                //
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }    
            break;

    }
    
    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\dsm\gendsm.h ===
#ifndef _GEN_DSM_H_
#define _GEN_DSM_H_

#include <ntddscsi.h>
#include <scsi.h>
#include "dsm.h"

//
// Set an arbitrary limit of 4 paths.
//
#define MAX_PATHS 4

//
// Device State defines.
//
#define DEV_ACTIVE         0x00000001
#define DEV_PASSIVE        0x00000002
#define DEV_FAILED         0x00000003
#define DEV_PENDING_REMOVE 0x00000004
#define DEV_REMOVED        0x00000005

//
// Multi-path Group State
//
//
// Fail-Over Group State
//
#define FG_NORMAL   0x00000001
#define FG_PENDING  0x00000002
#define FG_FAILBACK 0x00000003
#define FG_FAILED   0x00000004

//
// Load-Balance Types
//
#define LB_ACTIVE_PASSIVE 0x01
#define LB_STATIC         0x02
#define LB_MIN_QUEUE      0x03
#define LB_ROUNDROBIN     0x04

#define DSM_DEVICE_SIG    0xAAAAAAAA
#define DSM_GROUP_SIG     0x55555555
#define DSM_FOG_SIG       0x88888888

//
// Internal structures.
//
//
// Statistics structure. Used by the device
// and path routines.
//
typedef struct _DSM_STATS {
    ULONG NumberReads;
    LARGE_INTEGER BytesRead;
    ULONG NumberWrites;
    LARGE_INTEGER BytesWritten;
} DSM_STATS, *PDSM_STATS;

//
// Dsm Context is the global driver
// context that gets pushed to each of
// the dsm entry points.
// 
typedef struct _DSM_CONTEXT {
    UNICODE_STRING SupportedDevices;
    KSPIN_LOCK SpinLock;
    ULONG NumberDevices;
    ULONG NumberGroups;
    ULONG NumberFOGroups;
    LIST_ENTRY DeviceList;
    LIST_ENTRY GroupList;
    LIST_ENTRY FailGroupList;
    PVOID MPIOContext;
    ULONG ControllerId;
    NPAGED_LOOKASIDE_LIST ContextList;
} DSM_CONTEXT, *PDSM_CONTEXT;

typedef struct _GROUP_ENTRY;
typedef struct _FAILOVER_GROUP;

//
// Information about each device that's
// supported.
// 
typedef struct _DEVICE_INFO {
    LIST_ENTRY ListEntry;
    ULONG DeviceSig;
    PVOID DsmContext;
    PDEVICE_OBJECT PortPdo;
    PDEVICE_OBJECT TargetObject;
    struct _GROUP_ENTRY *Group;
    struct _FAILOVER_GROUP *FailGroup;
    ULONG State;
    BOOLEAN NeedsVerification;
    UCHAR Reserved[3];
    LONG Requests;
    DSM_STATS Stats;
    PUCHAR SerialNumber;
    STORAGE_DEVICE_DESCRIPTOR Descriptor;
} DEVICE_INFO, *PDEVICE_INFO;

//
// Information about multi-path groups:
// The same device found via multiple paths.
//
typedef struct _GROUP_ENTRY {
    LIST_ENTRY ListEntry;
    ULONG GroupSig;
    ULONG GroupNumber;
    BOOLEAN LoadBalanceInit;
    UCHAR LoadBalanceType;
    UCHAR Reserved[2];
    ULONG NumberDevices;
    PDEVICE_INFO DeviceList[MAX_PATHS];
} GROUP_ENTRY, *PGROUP_ENTRY;

//
// The collection of devices on one path.
// These fail-over as a unit.
//
typedef struct _FAILOVER_GROUP {
    LIST_ENTRY ListEntry;
    ULONG FailOverSig;
    PVOID PathId;
    PDEVICE_OBJECT MPIOPath;
    PVOID AlternatePath;
    ULONG State;
    ULONG Count;

    //
    // BUGBUG: Revisit using an array
    //
    PDEVICE_INFO DeviceList[32];
} FAILOVER_GROUP, *PFAILOVER_GROUP;

//
// Completion context structure.
//
typedef struct _COMPLETION_CONTEXT {
    LARGE_INTEGER TickCount;
    PDEVICE_INFO DeviceInfo;
    PDSM_CONTEXT DsmContext;
} COMPLETION_CONTEXT, *PCOMPLETION_CONTEXT;

NTSTATUS
DsmInquire (
    IN PVOID DsmContext,
    IN PDEVICE_OBJECT TargetDevice,
    IN PDEVICE_OBJECT PortObject,
    IN PSTORAGE_DEVICE_DESCRIPTOR Descriptor,
    IN PSTORAGE_DEVICE_ID_DESCRIPTOR DeviceIdList,
    OUT PVOID *DsmIdentifier
    );

BOOLEAN
DsmCompareDevices(
    IN PVOID DsmContext,
    IN PVOID DsmId1,
    IN PVOID DsmId2
    );

NTSTATUS
DsmSetDeviceInfo(
    IN PVOID DsmContext,
    IN PDEVICE_OBJECT TargetObject,
    IN PVOID DsmId,
    IN OUT PVOID *PathId
    );

NTSTATUS
DsmGetControllerInfo(
    IN PVOID DsmContext,
    IN PVOID DsmId,
    IN ULONG Flags,
    IN OUT PCONTROLLER_INFO *ControllerInfo
    );

BOOLEAN
DsmIsPathActive(
    IN PVOID DsmContext,
    IN PVOID PathId
    );

NTSTATUS
DsmPathVerify(
    IN PVOID DsmContext,                       
    IN PVOID DsmId,
    IN PVOID PathId
    );

NTSTATUS
DsmInvalidatePath(
    IN PVOID DsmContext,
    IN ULONG ErrorMask,
    IN PVOID PathId,
    IN OUT PVOID *NewPathId
    );

NTSTATUS
DsmMoveDevice(
    IN PVOID DsmContext,
    IN PDSM_IDS DsmIds,
    IN PVOID MPIOPath,
    IN PVOID SuggestedPath,
    IN ULONG Flags
    );

NTSTATUS
DsmRemovePending(
    IN PVOID DsmContext,
    IN PVOID DsmId
    );

NTSTATUS
DsmRemoveDevice(
    IN PVOID DsmContext,
    IN PVOID DsmId,
    IN PVOID PathId
    );

NTSTATUS
DsmRemovePath(
    IN PDSM_CONTEXT DsmContext,
    IN PVOID PathId
    );

NTSTATUS
DsmBringPathOnLine(
    IN PVOID DsmContext,
    IN PVOID PathId,
    OUT PULONG DSMError
    );

PVOID
DsmLBGetPath(
    IN PVOID DsmContext,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PDSM_IDS DsmList,
    IN PVOID CurrentPath,
    OUT NTSTATUS *Status
    );

ULONG
DsmCategorizeRequest(
    IN PVOID DsmContext,
    IN PDSM_IDS DsmIds,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID CurrentPath,
    OUT PVOID *PathId,
    OUT NTSTATUS *Status
    );

NTSTATUS
DsmBroadcastRequest(
    IN PVOID DsmContext,
    IN PDSM_IDS DsmIds,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PKEVENT Event
    );

NTSTATUS
DsmSrbDeviceControl(
    IN PVOID DsmContext,
    IN PDSM_IDS DsmIds,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PKEVENT Event
    );

VOID
DsmSetCompletion(
    IN PVOID DsmContext,
    IN PVOID DsmId,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PDSM_COMPLETION_INFO DsmCompletion
    );

ULONG
DsmInterpretError(
    IN PVOID DsmContext,
    IN PVOID DsmId,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT NTSTATUS *Status,
    OUT PBOOLEAN Retry
    );

NTSTATUS
DsmUnload(
    IN PVOID DsmContext
    );

//
// Various utility functions.
//
VOID
DsmWmiInitialize(
    IN PDSM_WMILIB_CONTEXT WmiInfo
    );

PGROUP_ENTRY
DsmFindDevice(
    IN PDSM_CONTEXT DsmContext,
    IN PDEVICE_INFO DeviceInfo
    );

PGROUP_ENTRY
DsmBuildGroupEntry (
    IN PDSM_CONTEXT DsmContext,
    IN PDEVICE_INFO deviceInfo
    );

NTSTATUS
DsmAddGroupEntry(
    IN PDSM_CONTEXT DsmContext,
    IN PGROUP_ENTRY Group
    );

NTSTATUS
DsmAddDeviceEntry(
    IN PDSM_CONTEXT DsmContext,
    IN PGROUP_ENTRY Group,
    IN PDEVICE_INFO DeviceInfo,
    IN ULONG DeviceState
    );

VOID
DsmRemoveDeviceEntry(
    IN PDSM_CONTEXT DsmContext,
    IN PGROUP_ENTRY Group,
    IN PDEVICE_INFO DeviceInfo
    );

PFAILOVER_GROUP
DsmFindFOGroup(
    IN PDSM_CONTEXT DsmContext,
    IN PVOID PathId
    );

PFAILOVER_GROUP
DsmBuildFOGroup(
    IN PDSM_CONTEXT DsmContext,
    IN PDEVICE_INFO DeviceInfo,
    IN PVOID PathId
    );

NTSTATUS
DsmUpdateFOGroup(
    IN PDSM_CONTEXT DsmContext,
    IN PFAILOVER_GROUP FailGroup,
    IN PDEVICE_INFO DeviceInfo
    );

VOID
DsmRemoveDeviceFailGroup(
    IN PDSM_CONTEXT DsmContext,
    IN PFAILOVER_GROUP FailGroup,
    IN PDEVICE_INFO DeviceInfo
    );

PFAILOVER_GROUP
DsmSetNewPath(
    IN PDSM_CONTEXT DsmContext,
    IN PGROUP_ENTRY Group,
    IN PDEVICE_INFO FailingDevice,
    IN PFAILOVER_GROUP SelectedPath
    );

VOID
DsmLBInit(
    IN PDSM_CONTEXT DsmContext,
    IN PGROUP_ENTRY Group
    );


#define DEBUG_BUFFER_LENGTH 255
UCHAR DebugBuffer[DEBUG_BUFFER_LENGTH + 1];
ULONG GenDSMDebug = 1;
VOID
DsmDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );
#ifdef DebugPrint
#undef DebugPrint
#define DebugPrint(x) DsmDebugPrint x
#endif
#endif // _GEN_DSM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\device\mpdev.c ===
/*++

Copyright (C) 1999  Microsoft Corporation

Module Name:

    mpdev.c

Abstract:

    This driver acts as a lower-filter over the device pdo's and provides the support necessary for multipathing.
    It's main function is keep mpctl.sys (main multipath module) informed of system state.

Author:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include <ntddk.h>
#include <stdio.h>
#include <stdarg.h>
#include "mpdevf.h"
#include "scsi.h"
#include "mplib.h"


typedef struct _DEVICE_EXTENSION {
    //
    // Backpointer to our device object.
    //
    PDEVICE_OBJECT DeviceObject;

    //
    // Pointer to the lower object.
    //
    PDEVICE_OBJECT TargetDevice;

    //
    // The PDisk device object information.
    //
    MPIO_PDO_INFO PdoInfo;

    //
    // MpCtl's Control device Object.
    //
    PDEVICE_OBJECT ControlDevice;

    //
    // State flags of this (and the lower device).
    //
    ULONG DeviceState;

    //
    // General purpose event.
    //
    KEVENT Event;

    //
    // Counters for IOs
    //
    ULONG NumberReads;
    ULONG NumberWrites;
    BOOLEAN FailureSimulation;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Entry point decls
//
NTSTATUS
MpDevDefaultDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MpDevInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MpDevDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MpDevPnPDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MpDevPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MpDevAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
MpDevUnload(
    IN PDRIVER_OBJECT DriverObject
    );



//
// Internal function decls
//
NTSTATUS
MpDevStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


//
// The code.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine is called when the driver loads loads.

Arguments:

    DriverObject    - Supplies the driver object.
    RegistryPath    - Supplies the registry path.

Return Value:

    NTSTATUS

--*/
{
    ULONG i;

    MPDebugPrint((0,
                  "MpDev: DriverEntry\n"));

    //
    // Setup forwarder for ALL Irp functions.
    //
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = MpDevDefaultDispatch;
    }

    //
    // Specify those that we are interested in.
    //
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = MpDevInternalDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = MpDevDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP] = MpDevPnPDispatch;
    DriverObject->MajorFunction[IRP_MJ_POWER] = MpDevPowerDispatch;
    
    DriverObject->DriverUnload = MpDevUnload;
    DriverObject->DriverExtension->AddDevice = MpDevAddDevice;

    return STATUS_SUCCESS;
}


NTSTATUS
MpDevDefaultDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine sends the Irp to the next driver in line
    when the Irp is not processed by this driver.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(deviceExtension->TargetDevice, Irp);
}




NTSTATUS
MpDevClaimDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Claim
    )
/*++

Routine Description:

    This is used to claim the underlying port pdo, so that only the mpdisk will be used
    by the class drivers.

Arguments:

    DeviceObject - Supplies the scsiport device object.
    Claim - Indica0tes whether the device should be claimed or released.

Return Value:

    Returns a status indicating success or failure of the operation.

--*/

{
    IO_STATUS_BLOCK    ioStatus;
    PIRP               irp;
    PIO_STACK_LOCATION irpStack;
    KEVENT             event;
    NTSTATUS           status;
    SCSI_REQUEST_BLOCK srb;

    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion
    //
    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // Build synchronous request with no transfer.
    //
    irp = IoBuildDeviceIoControlRequest(IOCTL_SCSI_EXECUTE_NONE,
                                        DeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        TRUE,
                                        &event,
                                        &ioStatus);

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Save SRB address in next stack for port driver.
    //
    irpStack->Parameters.Scsi.Srb = &srb;

    //
    // Setup the SRB.
    //
    srb.Length = SCSI_REQUEST_BLOCK_SIZE;
    srb.Function = Claim ? SRB_FUNCTION_CLAIM_DEVICE : SRB_FUNCTION_RELEASE_DEVICE;
    srb.OriginalRequest = irp;

    //
    // Call the port driver with the request and wait for it to complete.
    //
    status = IoCallDriver(DeviceObject, irp);
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    return status;
}



NTSTATUS
MpDevInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles IRM_MJ_INTERNAL_DEVICE_CONTROL and IRP_MJ_SCSI requests.
    It's main function is to simulate failed devices or adapters, based on IOCTLs
    sent from test applications.

Arguments:

    DeviceObject    - Supplies the device object.
    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;

    return MpDevDefaultDispatch(DeviceObject, Irp);
}



NTSTATUS
MpDevDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This device control routine handles only the interactions between this driver and mpctl.
    The rest are passed down to scsiport.

Arguments:

    DeviceObject    - Supplies the device object.
    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {
            
        default:
            return MpDevDefaultDispatch(DeviceObject, Irp);

    }
    return status;
}


NTSTATUS
MpDevPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for Power Irps.

Arguments:

    DeviceObject    - Supplies the device object.
    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // TODO: Snoop these, and if the device is changing state notify mpctl.sys
    //
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);

    return PoCallDriver(deviceExtension->TargetDevice, Irp);
}


NTSTATUS
MpDevPnPDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for PNP Irps.

Arguments:

    DeviceObject    - Supplies the device object.
    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;

    KeClearEvent(&deviceExtension->Event);

    MPDebugPrint((2,
                  "MpDevPnPDispatch: Minor Function (%x) for (%x)\n",
                  irpStack->MinorFunction,
                  DeviceObject));

    //
    // TODO: signal the associated pdisk of all power and pnp events.
    //
    switch (irpStack->MinorFunction) {
        case IRP_MN_QUERY_REMOVE_DEVICE:
            MPDebugPrint((2,
                        "MPDevPnP: QueryRemove (%x)\n",
                        DeviceObject));
            status = STATUS_DEVICE_BUSY;
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;
            
        case IRP_MN_STOP_DEVICE:
            MPDebugPrint((2,
                          "MpDevPnP: StopDevice (%x)\n",
                          DeviceObject));
            break;
        case IRP_MN_REMOVE_DEVICE:
        case IRP_MN_SURPRISE_REMOVAL:
            MPDebugPrint((2,
                          "MpDevPnP: RemoveDevice (%x)\n",
                          DeviceObject));
            //status = STATUS_SUCCESS;
            //Irp->IoStatus.Status = status;
            //IoCompleteRequest(Irp, IO_NO_INCREMENT);
            //return status;
            break;
            
        case IRP_MN_START_DEVICE:
            return MpDevStartDevice(DeviceObject, Irp);

        case IRP_MN_QUERY_CAPABILITIES:
        case IRP_MN_QUERY_ID:
        default:
            return MpDevDefaultDispatch(DeviceObject, Irp);
    }
    return MpDevDefaultDispatch(DeviceObject, Irp);

}


NTSTATUS
MpDevAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++
Routine Description:

    Creates and initializes a new filter device object for the
    corresponding PDO.  Then it attaches the device object to the device
    stack of the drivers for the device.

Arguments:

    DriverObject
    PhysicalDeviceObject - Physical Device Object from the underlying layered driver

Return Value:

    NTSTATUS
--*/
{
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT controlDeviceObject;
    PDEVICE_EXTENSION deviceExtension;
    IO_STATUS_BLOCK ioStatus;
    UNICODE_STRING unicodeName;
    PFILE_OBJECT fileObject;
    WCHAR dosDeviceName[40];
    MPIO_REG_INFO ctlRegInfo;
    NTSTATUS status;
    PIRP irp;
    PDEVICE_OBJECT attachedDevice;

    //
    // Build the mpctl name.
    //
    swprintf(dosDeviceName, L"\\DosDevices\\MPathControl");
    RtlInitUnicodeString(&unicodeName, dosDeviceName);

    //
    // Get mpctl's deviceObject.
    //
    status = IoGetDeviceObjectPointer(&unicodeName,
                                      FILE_READ_ATTRIBUTES,
                                      &fileObject,
                                      &controlDeviceObject);

    if (NT_SUCCESS(status)) {
        MPIO_PDO_QUERY pdoQuery;

        pdoQuery.DeviceObject = PhysicalDeviceObject;

        //
        // Call mpctl to determine whether PhysicalDeviceObject is
        // one of it's children or a 'real' scsiport pdo.
        //
        MPLIBSendDeviceIoControlSynchronous(IOCTL_MPDEV_QUERY_PDO,
                                            controlDeviceObject,
                                            &pdoQuery,
                                            NULL,
                                            sizeof(MPIO_PDO_QUERY),
                                            0,
                                            TRUE,
                                            &ioStatus);
        status = ioStatus.Status;

        MPDebugPrint((2,
                    "MPDevAddDevice: Query on (%x). Status (%x)\n",
                    PhysicalDeviceObject,
                    status));
#if 0
        if (status == STATUS_SUCCESS) {

            //
            // This indicates that PhysicalDeviceObject is really an MPDisk.
            // Don't want to load on this.
            //
            status = STATUS_NO_SUCH_DEVICE;
        } else {

            //
            // This indicates that PhysicalDeviceObject is a real one.
            // 
            status = STATUS_SUCCESS;
        }    
#endif        
    }

    if (!NT_SUCCESS(status)) {

        //
        // This indicates that PhysicalDeviceObject is really an MPDisk object or
        // that getting the control object failed.
        //
        return status;
    }
        

    if (DontLoad) {
        return STATUS_NO_SUCH_DEVICE;
    }

    status = IoCreateDevice(DriverObject,
                            sizeof(DEVICE_EXTENSION),
                            NULL,
                            FILE_DEVICE_DISK,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &deviceObject);

    if (!NT_SUCCESS(status)) {

        MPDebugPrint((0,
                      "MpDevAddDevice: Couldn't create device object (%x)\n",
                      status));
        return status;
    }

    //
    // Start building the deviceExtension and attach to the lower device.
    //
    deviceExtension = deviceObject->DeviceExtension;
    deviceExtension->DeviceObject = deviceObject;

    deviceExtension->TargetDevice = IoAttachDeviceToDeviceStack(deviceObject, 
                                                                PhysicalDeviceObject);
    if (deviceExtension->TargetDevice == NULL) {

        MPDebugPrint((0,
                      "MpDevAddDevice: Couldn't attach to device stack\n"));
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Build IOCTL_MPDEV_REGISTER. This gives the port pdo to
    // mpctl to match up with one of it's children.
    // Mpctl then returns the PdoRegistration routine
    //
    ctlRegInfo.FilterObject = deviceObject;
    ctlRegInfo.LowerDevice = deviceExtension->TargetDevice;
    
    MPLIBSendDeviceIoControlSynchronous(IOCTL_MPDEV_REGISTER,
                                        controlDeviceObject,
                                        &ctlRegInfo,
                                        &ctlRegInfo,
                                        sizeof(MPIO_REG_INFO),
                                        sizeof(MPIO_REG_INFO),
                                        TRUE,
                                        &ioStatus);
    status = ioStatus.Status;

    //
    // Save off mpctls deviceObject.
    //
    deviceExtension->ControlDevice = controlDeviceObject;

    //
    // Update the flags by ORing in all of the set flags below.
    //
    deviceObject->Flags |= deviceExtension->TargetDevice->Flags & (DO_DIRECT_IO     |
                                                                   DO_BUFFERED_IO   |
                                                                   DO_POWER_PAGABLE |
                                                                   DO_POWER_INRUSH);
    //
    // Sync up other devObj stuff. 
    //
    deviceObject->DeviceType = deviceExtension->TargetDevice->DeviceType;
    deviceObject->Characteristics = deviceExtension->TargetDevice->Characteristics; 

    if (status == STATUS_SUCCESS) {

        //
        // Register with the MPDisk PDO. It will give back some notification
        // functions and update it's own internal structures to match
        // this filter with it's knowledge of scsiport's children.
        //
        status = ctlRegInfo.DevicePdoRegister(ctlRegInfo.MPDiskObject,
                                              deviceObject,
                                              PhysicalDeviceObject,
                                              &deviceExtension->PdoInfo);
        MPDebugPrint((2,
                     "MpDevAddDevice: Status of PdoRegister (%x)\n",
                     status));
        
        if (status == STATUS_SUCCESS) {
            status = MpDevClaimDevice(deviceExtension->TargetDevice,
                                      TRUE);
            if (status == STATUS_SUCCESS) {
                MPDebugPrint((2,
                             "MpDevAddDevice: Claim of (%x) successful.\n",
                             deviceExtension->TargetDevice));
            } else {

                MPDebugPrint((1,
                             "MpDevAddDevice: Claim of (%x) not successful. Status (%x)\n",
                             deviceExtension->TargetDevice,
                             status));
            }    
        }

    }

    //
    // Indicate that we are ready.
    //
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    MPDebugPrint((2,
                "MPDevAddDevice: Returning (%x) on D.O. (%x)\n",
                status,
                PhysicalDeviceObject));
    return status;
}


NTSTATUS
MpDevUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    return STATUS_SUCCESS;
}


NTSTATUS
MpDevSyncCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Completion routine for sync forwarding of Irps.

Arguments:

    DeviceObject
    Irp
    Context

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    PDEVICE_EXTENSION deviceExtension = (PDEVICE_EXTENSION)Context;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;

    UNREFERENCED_PARAMETER(DeviceObject);

    //
    // Set the event on which the dispatch handler is waiting.
    //
    KeSetEvent(&deviceExtension->Event, 
               0,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;

}


NTSTATUS
MpDevStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handles Start requests by sending the start down to scsiport. The completion will signal
    the event and then device object flags and characteristics are updated.

Arguments:

    DeviceObject    - Supplies the device object.
    Irp             - Supplies the I/O request packet.

Return Value:

    Status of the operations.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    //
    // Setup initial status.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // Clone the stack location.
    //
    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // Setup the completion routine. It will set the event that we wait on below.
    //
    IoSetCompletionRoutine(Irp, 
                           MpDevSyncCompletion,
                           deviceExtension,
                           TRUE,
                           TRUE,
                           TRUE);

    KeInitializeEvent(&deviceExtension->Event,
                      NotificationEvent,
                      FALSE);

    //
    // Call port with the request.
    //
    status = IoCallDriver(deviceExtension->TargetDevice, Irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&deviceExtension->Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        status = Irp->IoStatus.Status;
    }

    if (NT_SUCCESS(status)) {

        //
        // Sync up our stuff with scsiport's.
        //
        DeviceObject->Flags |= deviceExtension->TargetDevice->Flags;
        DeviceObject->Characteristics |= deviceExtension->TargetDevice->Characteristics;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\dsm\gendsm.c ===
/*++

Copyright (C) 2000  Microsoft Corporation

Module Name:

    dsm.c

Abstract:

    This driver is the generic DSM for FC disks and exports behaviours that
    mpctl.sys will use to determine how to multipath these devices.

Author:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include <ntddk.h>
#include <stdio.h>
#include <stdarg.h>
#include "dsm.h"
#include "gendsm.h"
#include "wmi.h"


#define USE_BINARY_MOF_QUERY

//
// MOF data can be reported by a device driver via a resource attached to
// the device drivers image file or in response to a query on the binary
// mof data guid. As the mpio pdo handles these requests partially for the DSM
// it is easier to handle via a Query-response.  
// 
#ifdef ALLOC_DATA_PRAGMA
   #pragma data_seg("PAGED")
#endif

UCHAR DsmBinaryMofData[] =
{
    #include "dsm.x"
};
#ifdef ALLOC_DATA_PRAGMA
   #pragma data_seg()
#endif

//
// Define symbolic names for the guid indexes
// 
#define GENDSM_CONFIGINFOGuidIndex    0
#define BinaryMofGuidIndex   1

//
// List of guids supported
//
GUID GENDSM_CONFIGINFOGUID = GENDSM_CONFIGINFOGuid;
GUID DsmBinaryMofGUID = BINARY_MOF_GUID;

WMIGUIDREGINFO DsmGuidList[] =
{
    {
        &GENDSM_CONFIGINFOGUID,
        1,
        0
    },
    {
        &DsmBinaryMofGUID,
        1,
        0
    }
};

#define DsmGuidCount (sizeof(DsmGuidList) / sizeof(WMIGUIDREGINFO))

NTSTATUS
DsmGetDeviceList(
    IN PDSM_CONTEXT Context
    );


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine is called when the driver loads loads.

Arguments:

    DriverObject    - Supplies the driver object.
    RegistryPath    - Supplies the registry path.

Return Value:

    NTSTATUS

--*/
{
    DSM_INIT_DATA initData;
    WCHAR dosDeviceName[40];
    UNICODE_STRING mpUnicodeName;
    PDEVICE_OBJECT deviceObject;
    PFILE_OBJECT fileObject;
    NTSTATUS status;
    PDSM_CONTEXT dsmContext;
    PDSM_MPIO_CONTEXT mpctlContext;
    PVOID buffer;

    //
    // Build the init data structure.
    //
    dsmContext = ExAllocatePool(NonPagedPool, sizeof(DSM_CONTEXT));
    if (dsmContext == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(dsmContext, sizeof(DSM_CONTEXT));

    buffer = &initData;

    //
    // Set-up the init data
    //
    initData.DsmContext = (PVOID)dsmContext;
    initData.InitDataSize = sizeof(DSM_INIT_DATA);

    initData.DsmInquireDriver = DsmInquire;
    initData.DsmCompareDevices = DsmCompareDevices;
    initData.DsmSetDeviceInfo = DsmSetDeviceInfo;
    initData.DsmGetControllerInfo = DsmGetControllerInfo;
    initData.DsmIsPathActive = DsmIsPathActive;
    initData.DsmPathVerify = DsmPathVerify;
    initData.DsmInvalidatePath = DsmInvalidatePath;
    initData.DsmMoveDevice = DsmMoveDevice;
    initData.DsmRemovePending = DsmRemovePending;
    initData.DsmRemoveDevice = DsmRemoveDevice;
    initData.DsmRemovePath = DsmRemovePath; 
    initData.DsmReenablePath = DsmBringPathOnLine;

    initData.DsmCategorizeRequest = DsmCategorizeRequest;
    initData.DsmBroadcastSrb = DsmBroadcastRequest;
    initData.DsmSrbDeviceControl = DsmSrbDeviceControl;
    initData.DsmSetCompletion = DsmSetCompletion;
    initData.DsmLBGetPath = DsmLBGetPath;
    initData.DsmInterpretError = DsmInterpretError; 
    initData.DsmUnload = DsmUnload;

    //
    // Set-up the WMI Info.
    //
    DsmWmiInitialize(&initData.DsmWmiInfo);
    
    //
    // Set the DriverObject. Used by MPIO for Unloading.
    // 
    initData.DriverObject = DriverObject;
    RtlInitUnicodeString(&initData.DisplayName, L"Generic Device-Specific Module");

    //
    // Initialize the context objects.
    //
    KeInitializeSpinLock(&dsmContext->SpinLock);
    InitializeListHead(&dsmContext->GroupList);
    InitializeListHead(&dsmContext->DeviceList);
    InitializeListHead(&dsmContext->FailGroupList);
    ExInitializeNPagedLookasideList(&dsmContext->ContextList,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(COMPLETION_CONTEXT),
                                    'MSDG',
                                    0);
    //
    // Build the mpctl name.
    //
    swprintf(dosDeviceName, L"\\DosDevices\\MPathControl");
    RtlInitUnicodeString(&mpUnicodeName, dosDeviceName);
    
    //
    // Get mpctl's deviceObject.
    //
    status = IoGetDeviceObjectPointer(&mpUnicodeName,
                                      FILE_READ_ATTRIBUTES,
                                      &fileObject,
                                      &deviceObject);
    if (NT_SUCCESS(status)) {
        KEVENT event;
        PIRP irp;
        IO_STATUS_BLOCK ioStatus;

        //
        // Send the IOCTL to mpctl.sys to register ourselves.
        //
        DsmSendDeviceIoControlSynchronous(IOCTL_MPDSM_REGISTER,
                                            deviceObject,
                                            &initData,
                                            &initData,
                                            sizeof(DSM_INIT_DATA),
                                            sizeof(DSM_MPIO_CONTEXT),
                                            TRUE,
                                            &ioStatus);
        status = ioStatus.Status;
        ObDereferenceObject(fileObject);
    }

    if (status == STATUS_SUCCESS) {


        //
        // Grab the context value passed back by mpctl.
        //
        mpctlContext = buffer;
        dsmContext->MPIOContext = mpctlContext->MPIOContext;

        //
        // Query the registry to find out what devices are being supported
        // on this machine.
        //
        DsmGetDeviceList(dsmContext);
        
    } else {

        //
        // Need to LOG this.
        //
    }

    return status;
}


PUCHAR
DsmGetSerialNumber(
    IN PDEVICE_OBJECT DeviceObject
    )
{

    IO_STATUS_BLOCK ioStatus;
    PSCSI_PASS_THROUGH passThrough;
    PVPD_SERIAL_NUMBER_PAGE serialPage;
    ULONG length;
    PCDB cdb;
    PUCHAR serialNumber;
    ULONG serialNumberOffset;

    //
    // Build an inquiry command with EVPD and pagecode of 0x80 (serial number).
    //
    length = sizeof(SCSI_PASS_THROUGH) + SENSE_BUFFER_SIZE + 0xFF;

    passThrough = ExAllocatePool(NonPagedPool, length);
    if (passThrough == NULL) {
        return NULL;
    }

    RtlZeroMemory(passThrough, length);

    //
    // build the cdb.
    //
    cdb = (PCDB)passThrough->Cdb;
    cdb->CDB6INQUIRY3.OperationCode = SCSIOP_INQUIRY;
    cdb->CDB6INQUIRY3.EnableVitalProductData = 1;
    cdb->CDB6INQUIRY3.PageCode = VPD_SERIAL_NUMBER;
    cdb->CDB6INQUIRY3.AllocationLength = 255;

    passThrough->Length = sizeof(SCSI_PASS_THROUGH);
    passThrough->CdbLength = 6;
    passThrough->SenseInfoLength = SENSE_BUFFER_SIZE;
    passThrough->DataIn = 1;
    passThrough->DataTransferLength = 0xFF;
    passThrough->TimeOutValue = 20;
    passThrough->SenseInfoOffset = sizeof(SCSI_PASS_THROUGH);
    passThrough->DataBufferOffset = sizeof(SCSI_PASS_THROUGH) + 18;

    DsmSendDeviceIoControlSynchronous(IOCTL_SCSI_PASS_THROUGH,
                                      DeviceObject,
                                      passThrough,
                                      passThrough,
                                      length,
                                      length,
                                      FALSE,
                                      &ioStatus);
    
    if ((passThrough->ScsiStatus) || (ioStatus.Status != STATUS_SUCCESS)) {
        DebugPrint((0,
                     "DsmGetSerialNumber: Status (%x) ScsiStatus (%x)\n",
                     ioStatus.Status,
                     passThrough->ScsiStatus));
        ExFreePool(passThrough);
        return NULL;
        
    } else {
        ULONG i;

        DebugPrint((0,
                      "GetDeviceDescriptor: Got the serial number page\n"));

        //
        // Get the returned data.
        // 
        (ULONG_PTR)serialPage = (ULONG_PTR)passThrough;
        (ULONG_PTR)serialPage += passThrough->DataBufferOffset;

        //
        // Allocate a buffer to hold just the serial number.
        // 
        serialNumber = ExAllocatePool(NonPagedPool, serialPage->PageLength + 1);
        RtlZeroMemory(serialNumber, serialPage->PageLength + 1);

        //
        // Copy it over.
        // 
        RtlCopyMemory(serialNumber,
                      serialPage->SerialNumber,
                      serialPage->PageLength);
        
        //
        // Convert 0x00 to spaces.
        //
        for (i = 0; i < serialPage->PageLength; i++) {
            if (serialNumber[i] == '\0') {
                serialNumber[i] = ' ';
            }
        }

        //
        // Free the passthrough + data buffer.
        //
        ExFreePool(passThrough);

        //
        // Return the sn.
        //
        return serialNumber;
    }    
}


NTSTATUS
DsmQueryCallBack(
    IN PWSTR ValueName,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG Length,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    PVOID *value = EntryContext;

    if (Type == REG_MULTI_SZ) {
        *value = ExAllocatePool(PagedPool, Length);
        if (*value) {
            RtlMoveMemory(*value, Data, Length);
            return STATUS_SUCCESS;
        }
    }
   
    return STATUS_UNSUCCESSFUL;
}



NTSTATUS
DsmGetDeviceList(
    IN PDSM_CONTEXT Context
    )
{
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    WCHAR registryKeyName[56];
    UNICODE_STRING inquiryStrings;
    WCHAR defaultIDs[] = { L"\0" };
    NTSTATUS status;
    
    RtlZeroMemory(registryKeyName, 56);
    RtlZeroMemory(&queryTable, sizeof(queryTable));
    RtlInitUnicodeString(&inquiryStrings, NULL);
    
    swprintf(registryKeyName, L"gendsm\\parameters");

    //
    // The query table has two entries. One for the supporteddeviceList and
    // the second which is the 'NULL' terminator.
    // 
    queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOEXPAND;
    queryTable[0].Name = L"SupportedDeviceList";
    queryTable[0].EntryContext = &Context->SupportedDevices;
    queryTable[0].DefaultType = REG_MULTI_SZ;
    queryTable[0].DefaultData = defaultIDs;
    queryTable[0].DefaultLength = sizeof(defaultIDs);

    status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    registryKeyName,
                                    queryTable,
                                    NULL,
                                    NULL);

    return status;
}


BOOLEAN
DsmFindSupportedDevice(
    IN PUNICODE_STRING DeviceName,
    IN PUNICODE_STRING SupportedDevices
    )
{
    PWSTR devices = SupportedDevices->Buffer;
    UNICODE_STRING unicodeString;
    LONG compare;

    while (devices[0]) {

        //
        // Make the current entry into a unicode string.
        //
        RtlInitUnicodeString(&unicodeString, devices);

        //
        // Compare this one with the current device.
        //
        compare = RtlCompareUnicodeString(&unicodeString, DeviceName, TRUE);
        if (compare == 0) {
            return TRUE;
        }

        //
        // Advance to next entry in the MULTI_SZ.
        //
        devices += (unicodeString.MaximumLength / sizeof(WCHAR));
    }        
  
    return FALSE;
}


BOOLEAN
DsmDeviceSupported(
    IN PDSM_CONTEXT Context,
    IN PUCHAR VendorId,
    IN PUCHAR ProductId
    )
{
    UNICODE_STRING deviceName;
    UNICODE_STRING productName;
    ANSI_STRING ansiVendor;
    ANSI_STRING ansiProduct;
    NTSTATUS status;
    BOOLEAN supported = FALSE;
    
    if (Context->SupportedDevices.MaximumLength == 0) {
        return FALSE;
    }

    //
    // Convert the inquiry fields into ansi strings.
    // 
    RtlInitAnsiString(&ansiVendor, VendorId);
    RtlInitAnsiString(&ansiProduct, ProductId);

    //
    // Allocate the deviceName buffer. Needs to be 8+16 plus NULL.
    // (productId length + vendorId length + NULL).
    // 
    deviceName.MaximumLength = 25 * sizeof(WCHAR);
    deviceName.Buffer = ExAllocatePool(PagedPool, deviceName.MaximumLength);
    
    //
    // Convert the vendorId to unicode.
    // 
    RtlAnsiStringToUnicodeString(&deviceName, &ansiVendor, FALSE);

    //
    // Convert the productId to unicode.
    // 
    RtlAnsiStringToUnicodeString(&productName, &ansiProduct, TRUE);

    //
    // 'cat' them.
    // 
    status = RtlAppendUnicodeStringToString(&deviceName, &productName);

    if (status == STATUS_SUCCESS) {

        // 
        // Run the list of supported devices that was captured from the registry
        // and see if this one is in the list.
        // 
        supported = DsmFindSupportedDevice(&deviceName,
                                           &Context->SupportedDevices);


    } 
    return supported;
}


NTSTATUS
DsmInquire (
    IN PVOID DsmContext,
    IN PDEVICE_OBJECT TargetDevice,
    IN PDEVICE_OBJECT PortObject,
    IN PSTORAGE_DEVICE_DESCRIPTOR Descriptor,
    IN PSTORAGE_DEVICE_ID_DESCRIPTOR DeviceIdList,
    OUT PVOID *DsmIdentifier
    )
{
    PDSM_CONTEXT dsmContext = DsmContext;
    PDEVICE_INFO deviceInfo;
    PGROUP_ENTRY group;
    NTSTATUS status;
    ULONG deviceState;
    ULONG allocationLength;
    PDSM_IDS controllerObjects;
    PUCHAR vendorId = "SEAGATE ";
    PUCHAR productId = "ST39102FC";
    PUCHAR vendorIndex;
    PUCHAR productIndex;
    PUCHAR serialNumber;
    BOOLEAN supported;

    
    vendorIndex = (PUCHAR)Descriptor;
    productIndex = (PUCHAR)Descriptor;
     (ULONG_PTR)vendorIndex += Descriptor->VendorIdOffset;
    (ULONG_PTR)productIndex += Descriptor->ProductIdOffset;
    
    supported = DsmDeviceSupported((PDSM_CONTEXT)DsmContext,
                                   vendorIndex,
                                   productIndex);
    if (supported == FALSE) {
        return STATUS_NOT_SUPPORTED;
    }
#if 0    
    //
    // Determine if the device is supported. 
    //
    if ((!RtlEqualMemory(vendorId, vendorIndex, 8)) ||
        (!RtlEqualMemory(productId, productIndex, 9))) {
    
        return STATUS_NOT_SUPPORTED;
    }
#endif    
    //
    // Ensure that the device's serial number is present. If not, can't claim
    // support for this drive.
    //
    if ((Descriptor->SerialNumberOffset == (ULONG)-1) ||
        (Descriptor->SerialNumberOffset == 0)) {

        PUCHAR index;
        //
        // The port driver currently doesn't get the VPD page 0x80, if the
        // device doesn't support GET_SUPPORTED_PAGES. Check to see whether
        // there actually is a serial number.
        // 
        serialNumber = DsmGetSerialNumber(TargetDevice);

        if (serialNumber == NULL) {
            return STATUS_NOT_SUPPORTED;
        }
        DebugPrint((0,"SerialNumber: "));
        index = serialNumber;
        while (*index) {
            DebugPrint((0,"%02x", *index));
            index++;
        }    
        DebugPrint((0,"\n"));
    } else {

        //
        // Get a pointer to the embedded serial number info.
        // 
        serialNumber = (PUCHAR)Descriptor;
        (ULONG_PTR)serialNumber += Descriptor->SerialNumberOffset;
        
    }        
    
    //
    // Allocate the descriptor. This is also used as DsmId.
    //
    allocationLength = sizeof(DEVICE_INFO);
    allocationLength += Descriptor->Size - sizeof(STORAGE_DEVICE_DESCRIPTOR);
    
    deviceInfo = ExAllocatePool(NonPagedPool, allocationLength);
    if (deviceInfo == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(deviceInfo, allocationLength);
   
    //
    // Copy over the StorageDescriptor.
    // 
    RtlCopyMemory(&deviceInfo->Descriptor,
                  Descriptor,
                  Descriptor->Size);

    //
    // As an example - if the storage enclosure contains controller-type devices (or others)
    // they can be found via this routine.
    // 
    controllerObjects = DsmGetAssociatedDevice(dsmContext->MPIOContext,
                                               PortObject,
                                               0x0C);
    if (controllerObjects) {

        //
        // Currently not used by this driver, so just free the memory.
        //
        ExFreePool(controllerObjects);
    }

    //
    // Set the serial number.
    //
    deviceInfo->SerialNumber = serialNumber;

    //
    // Save the PortPdo Object.
    //
    deviceInfo->PortPdo = TargetDevice;

    //
    // Set the signature.
    //
    deviceInfo->DeviceSig = DSM_DEVICE_SIG;
    
    //
    // See if there is an existing Muli-path group to which this belongs.
    // (same serial number). 
    // 
    group = DsmFindDevice(DsmContext,
                          deviceInfo);

    if (group == NULL) {
    
        //
        // Build a multi-path group entry.
        //
        group = DsmBuildGroupEntry(DsmContext,
                                   deviceInfo);
        if (group == NULL) {
            ExFreePool(deviceInfo);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // This is the first in the group, so make it the active
        // device. The actual active/passive devices will be set-up
        // later when the first call to LBGetPath is made.
        // 
        deviceState = DEV_ACTIVE;

    } else {
        
        //
        // Already something active, this will be the fail-over 
        // device until the load-balance groups are set-up.
        //
        deviceState = DEV_PASSIVE;
    }    
    
    //
    // Add it to the list.
    //
    status = DsmAddDeviceEntry(DsmContext,
                               group,
                               deviceInfo,
                               deviceState);
    
    *DsmIdentifier = deviceInfo;
    return status;
}


BOOLEAN
DsmCompareDevices(
    IN PVOID DsmContext,
    IN PVOID DsmId1,
    IN PVOID DsmId2
    )
{
    PDEVICE_INFO deviceInfo = DsmId1;
    PDEVICE_INFO comparedDevice = DsmId2;
    ULONG length;
    PUCHAR serialNumber;
    PUCHAR comparedSerialNumber;

    //
    // Get the two serial numbers.
    // They were either embedded in the STORAGE_DEVICE_DESCRIPTOR or built
    // by directly issuing the VPD request.
    //
    serialNumber = deviceInfo->SerialNumber;
    comparedSerialNumber = comparedDevice->SerialNumber;

    //
    // Get the length of the base-device Serial Number.
    //
    length = strlen(serialNumber);

    //
    // If the lengths match, compare the contents.
    //
    if (length == strlen(comparedSerialNumber)) {
        if (RtlEqualMemory(serialNumber,
                           comparedSerialNumber,
                           length)) {
            return TRUE;
        }
    }
    return FALSE;
}


VOID
DsmSetupAlternatePath(
    IN PDSM_CONTEXT DsmContext,
    IN PGROUP_ENTRY Group
    )
{
    PFAILOVER_GROUP currentGroup;
    PFAILOVER_GROUP failGroup;
    PDEVICE_INFO deviceInfo;
    PDEVICE_INFO currentDevInfo;
    ULONG i;
    ULONG j;
    BOOLEAN pathSet = FALSE;
    
    //
    // Check for single-pathed groups.
    //
    if (Group->NumberDevices > 2) {
        return;
    }
    
    for (i = 0; i < Group->NumberDevices; i++) {

        //
        // Get the device.
        // 
        deviceInfo = Group->DeviceList[i];

        //
        // Get it's FOG.
        //
        currentGroup = deviceInfo->FailGroup;
        if (currentGroup == NULL) {

            //
            // This deviceInfo isn't fully intitialised yet.
            //
            continue;
        }

        //
        // Run through all the devices again.
        //
        for (j = 0; j < Group->NumberDevices; j++) {

            currentDevInfo = Group->DeviceList[j];

            if (currentDevInfo == deviceInfo) {

                //
                // Find one that's a different path.
                // 
                continue;
            }

            failGroup = currentDevInfo->FailGroup;
            if (failGroup) {
                if (failGroup->PathId) {
                    DebugPrint((0,
                                "SetAlternatePath: FOG (%x) using (%x) as Alt\n",
                                currentGroup,
                                failGroup));
                    
                    currentGroup->AlternatePath = failGroup->PathId;
                    pathSet = TRUE;
                }
            }
        }
        if (pathSet == FALSE) {
            DebugPrint((0,
                        "SetAlternatePath: No alternate set for (%x)\n",
                        currentGroup));
        } else {
            pathSet = FALSE;
        }    
    }
}


NTSTATUS
DsmSetDeviceInfo(
    IN PVOID DsmContext,
    IN PDEVICE_OBJECT TargetObject,
    IN PVOID DsmId,
    IN OUT PVOID *PathId
    )
{
    PDEVICE_INFO deviceInfo = DsmId;
    PGROUP_ENTRY group = deviceInfo->Group;
    PFAILOVER_GROUP failGroup;
    NTSTATUS status;

    //
    // TargetObject is the destination for any requests created by this driver.
    // Save this for future reference.
    //
    deviceInfo->TargetObject = TargetObject;

    //
    // PathId indicates the path on which this device resides. Meaning
    // that when a Fail-Over occurs all device's on the same path fail together.
    // Search for a matching F.O. Group
    //
    failGroup = DsmFindFOGroup(DsmContext,
                               *PathId);
    //
    // if not found, create a new f.o. group 
    //
    if (failGroup == NULL) {
        failGroup = DsmBuildFOGroup(DsmContext,
                                    DsmId,
                                    *PathId);
        if (failGroup == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // add this deviceInfo to the f.o. group.
    // 
    status = DsmUpdateFOGroup(DsmContext,
                              failGroup,
                              deviceInfo);
    
    DsmSetupAlternatePath(DsmContext,
                          group);
    return status;
}


NTSTATUS
DsmGetControllerInfo(
    IN PVOID DsmContext,
    IN PVOID DsmId,
    IN ULONG Flags,
    IN OUT PCONTROLLER_INFO *ControllerInfo
    )
{
    PDSM_CONTEXT dsmContext = DsmContext;
    PCONTROLLER_INFO controllerInfo;
    LARGE_INTEGER time;

    if (!dsmContext->ControllerId) {

        //
        // Make one up.
        //
        KeQuerySystemTime(&time);

        //
        // Use only the bottom 32-bits.
        //
        dsmContext->ControllerId = time.LowPart;
    }
    
    if (Flags & DSM_CNTRL_FLAGS_ALLOCATE) {
        controllerInfo = ExAllocatePool(NonPagedPool, sizeof(CONTROLLER_INFO));
        if (controllerInfo == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        
        RtlZeroMemory(controllerInfo, sizeof(CONTROLLER_INFO));

        //
        // Indicate that there are no specific controllers.
        // 
        controllerInfo->State = DSM_CONTROLLER_NO_CNTRL;

        //
        // Set the identifier to the value generated earlier.
        // 
        controllerInfo->ControllerIdentifier = (ULONGLONG)dsmContext->ControllerId;
        *ControllerInfo = controllerInfo;

    } else {

        controllerInfo = *ControllerInfo;

        //
        // If the enclosures supported by this DSM actually had controllers, there would
        // be a list of them and a search based on ControllerIdentifier would be made.
        //
        controllerInfo->State = DSM_CONTROLLER_NO_CNTRL;
    }
    return STATUS_SUCCESS;
}


BOOLEAN
DsmIsPathActive(
    IN PVOID DsmContext,        
    IN PVOID PathId
    )
{
    PFAILOVER_GROUP group;
    
    // 
    // NOTE: Internal callers of this assume certain behaviours. If it's changed,
    // those functions need to be updated appropriately.
    // 
    //
    // Get the F.O. Group information.
    //
    group = DsmFindFOGroup(DsmContext,
                           PathId);
    //
    // If there are any devices on this path, and
    // it's not in a failed state: it's capable of handling requests
    // so it's active.
    //
    if ((group->Count >= 1) && (group->State == FG_NORMAL)) {
        return TRUE;
    }
    return FALSE;
}


NTSTATUS
DsmPathVerify(
    IN PVOID DsmContext,                       
    IN PVOID DsmId,
    IN PVOID PathId
    )
{
    PDEVICE_INFO deviceInfo = DsmId;
    PFAILOVER_GROUP group;
    NTSTATUS status;
    ULONG i;

    //
    // Get the F.O. group
    //
    group = DsmFindFOGroup(DsmContext,
                           PathId);
    if (group == NULL) {
        DbgBreakPoint();
        return STATUS_DEVICE_NOT_CONNECTED;
    }
   
    //
    // Check the Path state to ensure all is normal.
    // Should be in FAILBACK state. This indicates that either
    // an admin utility told us we are O.K. or the AutoRecovery detected
    // the error was transitory.
    // BUGBUG: Need to implement both of the above assumptions.
    //
    if ((group->Count >= 1) && group->State == FG_FAILBACK) {
        
        // 
        // Ensure that the device is still there
        // 
        for (i = 0; i < group->Count; i++) {
            if (group->DeviceList[i] == deviceInfo) {

                //
                // Send it a TUR. 
                //
                status = DsmSendTUR(deviceInfo->TargetObject);
            }
        }
    } else {

        status = STATUS_UNSUCCESSFUL;

        //
        // Find the device.
        // 
        for (i = 0; i < group->Count; i++) {
            if (group->DeviceList[i] == deviceInfo) {

                //
                // Issue a TUR to see if it's OK.
                // 
                status = DsmSendTUR(deviceInfo->TargetObject);
            }
        }
#if DBG
        if (status == STATUS_SUCCESS) {
            DebugPrint((2,
                        "DsmPathVerify: Successful TUR to (%x)\n",
                        deviceInfo));
        
        } else {

            //
            // Either the device is not in the group, or the TUR was not successful.
            //
            if (i == group->Count) {
                DebugPrint((0,
                           "PathVerify: (%x) not in group (%x)\n",
                           deviceInfo,
                           group));
            } else {
                DebugPrint((0,
                           "PathVerify: TUR to (%x) failed. (%x)\n",
                           deviceInfo,
                           status));
            }
        }   
#endif        
    } 
    
    //
    // Update the group State, depending upon the outcome.
    // TODO
    //
    if (status == STATUS_SUCCESS) {

        //
        // This lets the LBInit run to properly set-up this device.
        //
        deviceInfo->NeedsVerification = FALSE;
    }

    return status;
}


NTSTATUS
DsmInvalidatePath(
    IN PVOID DsmContext,
    IN ULONG ErrorMask,
    IN PVOID PathId,
    IN OUT PVOID *NewPathId
    )
{
    PFAILOVER_GROUP failGroup;
    PFAILOVER_GROUP hintPath;
    PGROUP_ENTRY group;
    PDEVICE_INFO deviceInfo;
    NTSTATUS status;
    ULONG i;

    ASSERT(ErrorMask & DSM_FATAL_ERROR);
   
    //
    // Get the fail-over group corresponding to the PathId.
    // 
    failGroup = DsmFindFOGroup(DsmContext,
                               PathId);
    
    //
    // Mark the path as failed.
    //
    failGroup->State = FG_FAILED;
   
    DebugPrint((0,
                "DsmInvalidatePath: Path (%x) FOG (%x) failing\n",
                PathId,
                failGroup));

    //
    // First interation, the hint will be NULL. This allows the 
    // GetNewPath routine the opportunity to select the best new path
    // Subsequent calls will be fed the updated value.
    //
    hintPath = NULL; 

    if (failGroup->Count == 0) {

        //
        // This indicates that all of the devices have already
        // been removed. Just return the alternate path.
        //
        *NewPathId = failGroup->AlternatePath;
        return STATUS_SUCCESS;
    }

    //
    // Process each device in the fail-over group
    //
    for (i = 0; i < failGroup->Count; i++) {

        //
        // Get the deviceInfo.
        //
        deviceInfo = failGroup->DeviceList[i];

        // 
        // Set the state of the Failing Devicea
        //
        deviceInfo->State = DEV_FAILED;

        //
        // Get it's Multi-Path Group entry.
        //
        group = deviceInfo->Group;

        //
        // Get a new path for this failed device.
        // 
        hintPath = DsmSetNewPath(DsmContext,
                                 group,
                                 deviceInfo,
                                 hintPath);
        
    }

    if (hintPath == NULL) {

        //
        // This indicates that no acceptable paths
        // were found. Return the error to mpctl.
        //
        status = STATUS_NO_SUCH_DEVICE; 
        *NewPathId = NULL;

    } else {

    
        //
        // return the new path.
        //
        *NewPathId = hintPath->PathId;

        DebugPrint((0,
                      "DsmInvalidatePath: Returning (%x) as newPath\n",
                      hintPath->PathId));

        status = STATUS_SUCCESS;
    }    

    return status;
}


NTSTATUS
DsmMoveDevice(
    IN PVOID DsmContext,
    IN PDSM_IDS DsmIds,
    IN PVOID MPIOPath,
    IN PVOID SuggestedPath,
    IN ULONG Flags
    )
{

    return STATUS_SUCCESS;
}


NTSTATUS
DsmRemovePending(
    IN PVOID DsmContext,
    IN PVOID DsmId
    )
{
    PDSM_CONTEXT dsmContext = DsmContext;
    PDEVICE_INFO deviceInfo = DsmId;
    KIRQL irql;

    DebugPrint((0,
                "RemovePending: Marking %x as PENDING_REMOVED\n",
                deviceInfo));

    KeAcquireSpinLock(&dsmContext->SpinLock, &irql);

    //
    // Mark the device as being unavailable, as a remove will be
    // coming shortly.
    //
    deviceInfo->State = DEV_PENDING_REMOVE;
    
    KeReleaseSpinLock(&dsmContext->SpinLock, irql);

    return STATUS_SUCCESS;
    
}


NTSTATUS
DsmRemoveDevice(
    IN PVOID DsmContext,
    IN PVOID DsmId,
    IN PVOID PathId
    )
{
    PDSM_CONTEXT dsmContext = DsmContext; 
    PDEVICE_INFO deviceInfo;
    PFAILOVER_GROUP failGroup;
    PGROUP_ENTRY group;
    ULONG state;
    WCHAR buffer[64];

    DebugPrint((0,
                "DsmRemoveDevice: Removing %x\n",
                DsmId));
    //
    // DsmId is our deviceInfo structure.
    //
    deviceInfo = DsmId;
    
    //
    // Get it's Multi-Path Group entry.
    //
    group = deviceInfo->Group;

    //
    // Get the Fail-over group.
    //
    failGroup = deviceInfo->FailGroup;

    //
    // If it's active, need to 'Fail-Over' to another device in
    // the group.
    //
    state = deviceInfo->State;

    // 
    // Set the state of the Failing Devicea
    //
    deviceInfo->State = DEV_FAILED;
    
    if (state == DEV_ACTIVE) {

        //
        // Find the next available device.
        // This is basically a fail-over for just
        // this device.
        //
        DsmSetNewPath(DsmContext,
                      group,
                      deviceInfo,
                      NULL);
    }

    //
    // Remove it's entry from the Fail-Over Group.
    //
    DsmRemoveDeviceFailGroup(DsmContext,
                             failGroup,
                             deviceInfo);

    //
    // Remove it from it's multi-path group. This has the side-effect
    // of cleaning up the Group if the number of devices goes to zero.
    // 
    DsmRemoveDeviceEntry(DsmContext,
                         group,
                         deviceInfo);
   
    swprintf(buffer, L"Removing Device (%ws)", L"It's Name");
    DsmWriteEvent(dsmContext->MPIOContext,
                  L"GenDsm",
                  buffer,
                  2);
    return STATUS_SUCCESS;
}


NTSTATUS
DsmRemovePath(
    IN PDSM_CONTEXT DsmContext,
    IN PVOID PathId
    )
{
    PFAILOVER_GROUP failGroup;
    KIRQL irql;
    
    failGroup = DsmFindFOGroup(DsmContext,
                               PathId);

    if (failGroup == NULL) {

        //
        // It's already been removed. 
        // LOG though.
        //
        return STATUS_SUCCESS;
    }

    //
    // The claim is that a path won't be removed, until all
    // the devices on it are.
    //
    ASSERT(failGroup->Count == 0);

    KeAcquireSpinLock(&DsmContext->SpinLock, &irql);

    //
    // Need to find any other FOG's using this as their alternate path and
    // update them to use something else (if available).
    // BUGBUG: that it's not done.
    //
    //
    // Yank it from the list.
    //
    RemoveEntryList(&failGroup->ListEntry);
    DsmContext->NumberFOGroups--;

    //
    // Zero the entry.
    //
    RtlZeroMemory(failGroup, sizeof(FAILOVER_GROUP));
    KeReleaseSpinLock(&DsmContext->SpinLock, irql);

    //
    // Free the allocation.
    //
    ExFreePool(failGroup);

    return STATUS_SUCCESS;
}


NTSTATUS
DsmBringPathOnLine(
    IN PVOID DsmContext,
    IN PVOID PathId,
    OUT PULONG DSMError
    )
{
    PFAILOVER_GROUP failGroup;

    //
    // PathVerify has been called already, so if
    // it came back successfully, then this is O.K.
    //
    failGroup = DsmFindFOGroup(DsmContext,
                               PathId);

    if (failGroup == NULL) {

        //
        // LOG
        //
        *DSMError = 0;
        
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    //
    // Should be in FG_PENDING
    //
    ASSERT(failGroup->State == FG_PENDING);

    //
    // Indicate that it's ready to go.
    // 
    failGroup->State = FG_NORMAL;

    return STATUS_SUCCESS;
}


PVOID
DsmLBGetPath(
    IN PVOID DsmContext,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PDSM_IDS DsmList,
    IN PVOID CurrentPath,
    OUT NTSTATUS *Status
    )
{
    PDSM_CONTEXT dsmContext = DsmContext;
    PDEVICE_INFO deviceInfo;
    PGROUP_ENTRY group;
    PFAILOVER_GROUP failGroup = NULL;
    ULONG i;
    KIRQL irql;

    KeAcquireSpinLock(&dsmContext->SpinLock, &irql);
    
    //
    // Up-front checking to minimally validate
    // the list of DsmId's being passed in.
    // 
    ASSERT(DsmList->Count);
    ASSERT(DsmList->IdList[0]);

    //
    // Grab the first device from the list.
    // 
    deviceInfo = DsmList->IdList[0];
    ASSERT(deviceInfo->DeviceSig == DSM_DEVICE_SIG);

    //
    // Get the multi-path group.
    //
    group = deviceInfo->Group;
    
    //
    // See if Load-Balancing has been initialized.
    //
    if (group->LoadBalanceInit == FALSE) {
        PDEVICE_INFO lbDevice;
        BOOLEAN doInit = TRUE;
        
        //
        // Check to see whether we are really ready to run
        // the LBInit. If any of the list aren't verified, then
        // we will hold off.
        //
        for (i = 0; i < DsmList->Count; i++) {
            lbDevice = DsmList->IdList[i];

            //
            // Check to see whether pathVerify has been invoked
            // on this device. Due to how PnP builds the device stacks
            // there is a period of time between the PDO showing up, and
            // when the FDO (mpdev.sys) gets loaded and registers.
            // 
            if (lbDevice->NeedsVerification) {
                DebugPrint((0,
                            "LBGetPath: (%x) needs verify\n",
                            lbDevice));
                doInit = FALSE;
                break;
            }
        }

        if (doInit) {

            //
            // Set-up the load-balancing. This routine
            // builds a static assignment of multi-path group to
            // a particular path.
            //
            DsmLBInit(DsmContext,
                      group);
        }
    }
   
#if DBG

    //
    // Ensure that mpctl and this dsm are in sync.
    // 
    if (DsmList->Count != group->NumberDevices) {
        BOOLEAN doAssert = TRUE;

        for (i = 0; i <group->NumberDevices; i++) {
            deviceInfo = group->DeviceList[i];
            
            if ((deviceInfo->State == DEV_PENDING_REMOVE) ||
                (deviceInfo->State == DEV_FAILED)) {

                //
                // The reason the lists are off is that this one
                // has been marked for removal. mpio has already
                // adjusted it's structures to show it not being used.
                // 
                doAssert = FALSE;
            }
        }
        if (doAssert) {
            ASSERT(DsmList->Count == group->NumberDevices);
        }
    }
#endif    
    
    // 
    // Find the active device.
    //
    //for (i = 0; i < group->NumberDevices; i++) {
    for (i = 0; i < DsmList->Count; i++) {

        //
        // Get each of the DsmId's, in reality the deviceInfo.
        //
        deviceInfo = DsmList->IdList[i];
        ASSERT(deviceInfo->DeviceSig == DSM_DEVICE_SIG);
        
        //
        // Ensure that the device is in our list.
        //
        ASSERT(DsmFindDevice(DsmContext, deviceInfo));
      
        //
        // NOTE: This assumes 'static' Load-Balancing. Once others
        // are implemented, this section will have to be updated.
        //
        // Return the path on which the ACTIVE device resides.
        // 
        if (deviceInfo->State == DEV_ACTIVE) {

            //
            // Get the F.O.Group, as it contains the
            // correct PathId for this device.
            // 
            failGroup = deviceInfo->FailGroup;

            *Status = STATUS_SUCCESS;

            KeReleaseSpinLock(&dsmContext->SpinLock, irql);
            return failGroup->PathId;
        }
    }

    KeReleaseSpinLock(&dsmContext->SpinLock, irql);

    //
    // Should never have gotten here.
    //
    DebugPrint((0,
                "LBGetPath: Returning STATUS_DEVICE_NOT_CONNECTED\n"));
    DbgBreakPoint();
    ASSERT(failGroup);
    *Status = STATUS_DEVICE_NOT_CONNECTED;
    return NULL;
}


ULONG
DsmCategorizeRequest(
    IN PVOID DsmContext,
    IN PDSM_IDS DsmIds,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID CurrentPath,
    OUT PVOID *PathId,
    OUT NTSTATUS *Status
    )
{
    ULONG dsmStatus;
    NTSTATUS status;

    //
    // Requests to broadcast
    //    Reset
    //    Reserve
    //    Release
    //
    // Requests to Handle
    //    None for now.
    //

    //
    // For all other requests, punt it back to the bus-driver.
    // Need to get a path for the request first, so call the Load-Balance
    // function.
    //
    *PathId = DsmLBGetPath(DsmContext,
                           Srb,
                           DsmIds,
                           CurrentPath,
                           &status);
    
    if (NT_SUCCESS(status)) {

        //
        // Indicate that the path is updated, and mpctl should handle the request.
        // 
        dsmStatus = DSM_PATH_SET;

    } else {

        //
        // Indicate the error back to mpctl.
        // 
        dsmStatus = DSM_ERROR;

        //
        // Mark-up the Srb to show that a failure has occurred.
        // This value is really only for this DSM to know what to do
        // in the InterpretError routine - Fatal Error.
        // It could be something more meaningful.
        // 
        Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
    }
    
    //
    // Pass back status info to mpctl.
    //
    *Status = status;
    return dsmStatus;
    
}


NTSTATUS
DsmBroadcastRequest(
    IN PVOID DsmContext,
    IN PDSM_IDS DsmIds,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PKEVENT Event
    )
{
    PDSM_CONTEXT dsmContext = DsmContext;
    KIRQL irql;

    KeAcquireSpinLock(&dsmContext->SpinLock, &irql);
    //
    // BUGBUG: Need to handle Reset, Reserve, and Release.
    //
    KeReleaseSpinLock(&dsmContext->SpinLock, irql);
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
DsmSrbDeviceControl(
    IN PVOID DsmContext,
    IN PDSM_IDS DsmIds,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PKEVENT Event
    )
{
    PDSM_CONTEXT dsmContext = DsmContext;
    KIRQL irql;

    KeAcquireSpinLock(&dsmContext->SpinLock, &irql);

    //
    // BUGBUG: Need to handle ?? 
    //
    KeReleaseSpinLock(&dsmContext->SpinLock, irql);
    return STATUS_INVALID_DEVICE_REQUEST;
}



VOID
DsmXCompletion(
    IN PVOID DsmId,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID DsmContext
    )
{
    PCOMPLETION_CONTEXT completionContext = DsmContext;
    PDEVICE_INFO deviceInfo;
    PDSM_CONTEXT dsmContext;
    UCHAR opCode;

    //
    // If it's read or write, save stats.
    // Categorize set-up the Context to have path, target info.
    // TODO
    //
    ASSERT(DsmContext);

    dsmContext = completionContext->DsmContext;
    deviceInfo = completionContext->DeviceInfo;
    opCode = Srb->Cdb[0];
    
    //
    // Indicate one less request on this device.
    //
    InterlockedDecrement(&deviceInfo->Requests);

    //
    // TODO: Use the timestamp.
    // Path/Device up-time, ave. time/request...
    //
    
    //
    // If it's a read or a write, update the stats.
    //
    if (opCode == SCSIOP_READ) {

        deviceInfo->Stats.NumberReads++;
        deviceInfo->Stats.BytesRead.QuadPart += Srb->DataTransferLength;
            
    } else if (opCode == SCSIOP_WRITE) {
        
        deviceInfo->Stats.NumberWrites++;
        deviceInfo->Stats.BytesWritten.QuadPart += Srb->DataTransferLength;
    }
    
    //
    // Release the allocation.
    //
    ExFreeToNPagedLookasideList(&dsmContext->ContextList,
                                DsmContext);
}    


VOID
DsmSetCompletion(
    IN PVOID DsmContext,
    IN PVOID DsmId,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PDSM_COMPLETION_INFO DsmCompletion
    )
{
    PCOMPLETION_CONTEXT completionContext;
    PDSM_CONTEXT dsmContext = DsmContext;
    PDEVICE_INFO deviceInfo = DsmId;
    
    //
    // Save the DeviceInfo as being the target for this request.
    // Get a timestamp
    // TODO Determine other data.
    //
    completionContext = ExAllocateFromNPagedLookasideList(&dsmContext->ContextList);
    if (completionContext == NULL) {

        //
        // LOG
        //
    }

    //
    // Time stamp this.
    //
    KeQueryTickCount(&completionContext->TickCount);

    //
    // Indicate the target for this request.
    //
    completionContext->DeviceInfo = deviceInfo;
    completionContext->DsmContext = DsmContext;

    //
    // Indicate one more request on this device.
    // LB may use this.
    //
    InterlockedIncrement(&deviceInfo->Requests);
    
    DsmCompletion->DsmCompletionRoutine = DsmXCompletion;
    DsmCompletion->DsmContext = completionContext;
    return;
}


ULONG
DsmInterpretError(
    IN PVOID DsmContext,
    IN PVOID DsmId,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT NTSTATUS *Status,
    OUT PBOOLEAN Retry
    )
{
    ULONG errorMask = 0;
    PSENSE_DATA senseData = Srb->SenseInfoBuffer;
    BOOLEAN failover = FALSE;
    BOOLEAN retry = FALSE;
    BOOLEAN handled = FALSE;
    
    //
    // Check the NT Status first.
    // Several are clearly failover conditions.
    //
     switch (*Status) {
        case STATUS_DEVICE_NOT_CONNECTED:
        case STATUS_DEVICE_DOES_NOT_EXIST:
        case STATUS_NO_SUCH_DEVICE:

            //
            // The port pdo has either been removed or is 
            // very broken. A fail-over is necessary.
            //
            handled = TRUE;
            failover = TRUE;
            break;

        case STATUS_IO_DEVICE_ERROR:

            //
            // See if it's a unit attention.
            //
            if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
                if (senseData->SenseKey == SCSI_SENSE_UNIT_ATTENTION) {
                    retry = TRUE;
                    handled = TRUE;
                }
            }    
            break;
            
        default:
            break;
    }            

    if (handled == FALSE) {

        if (Srb) {

            //
            // The ntstatus didn't indicate a fail-over condition, but
            // check various srb status for failover-class error.
            //
            switch (Srb->SrbStatus) {
                case SRB_STATUS_SELECTION_TIMEOUT:
                case SRB_STATUS_INVALID_LUN:
                case SRB_STATUS_INVALID_TARGET_ID:
                case SRB_STATUS_NO_DEVICE:
                case SRB_STATUS_NO_HBA:
                case SRB_STATUS_INVALID_PATH_ID:

                    //
                    // All of these are fatal.
                    //
                    failover = TRUE;
                    break;
                default:
                    break;

            }
        }
    }
    if (failover) {
        DebugPrint((0,
                    "InterpretError: Marking Fatal. Srb (%x). *Status (%x)\n",
                    Srb,
                    *Status));
        errorMask = DSM_FATAL_ERROR;
    }

    //
    // TODO: Gather a list of status that indicate a retry is necessary.
    // Look at InterpretSenseInfo.
    //
    *Retry = retry;
    return errorMask;
}


NTSTATUS
DsmUnload(
    IN PVOID DsmContext
    )
{

    //
    // It's the responsibility of the mpio bus driver to have already
    // destroyed all devices and paths.
    // As those functions free allocations for the objects, the only thing
    // needed here is to free the DsmContext.
    //
    ExFreePool(DsmContext);
    return STATUS_SUCCESS;
}

//
// Utility functions.
//

PGROUP_ENTRY
DsmFindDevice(
    IN PDSM_CONTEXT DsmContext,
    IN PDEVICE_INFO DeviceInfo
    )
{
    PDEVICE_INFO deviceInfo;
    PLIST_ENTRY entry;
    ULONG i;

    //
    // Run through the DeviceInfo List
    //
    entry = DsmContext->DeviceList.Flink;
    for (i = 0; i < DsmContext->NumberDevices; i++, entry = entry->Flink) {

        //
        // Extract the deviceInfo structure.
        // 
        deviceInfo = CONTAINING_RECORD(entry, DEVICE_INFO, ListEntry);
        ASSERT(deviceInfo);

        //
        // Call the Serial Number compare routine.
        //
        if (DsmCompareDevices(DsmContext,
                              DeviceInfo,
                              deviceInfo)) {
    

            return deviceInfo->Group;
        }
    }
   
    DebugPrint((0,
                  "DsmFindDevice: DsmContext (%x), DeviceInfo (%x)\n",
                  DsmContext,
                  DeviceInfo));
    return NULL;
}



PGROUP_ENTRY
DsmBuildGroupEntry(
    IN PDSM_CONTEXT DsmContext,
    IN PDEVICE_INFO DeviceInfo
    )
{
    PGROUP_ENTRY group;

    //
    // Allocate the memory for the multi-path group.
    // 
    group = ExAllocatePool(NonPagedPool, sizeof(GROUP_ENTRY));
    if (group == NULL) {
        return NULL;
    }

    RtlZeroMemory(group, sizeof(GROUP_ENTRY));
    
    //
    // Add it to the list of multi-path groups.
    //
    ExInterlockedInsertTailList(&DsmContext->GroupList,
                              &group->ListEntry,
                              &DsmContext->SpinLock);

    group->GroupNumber = InterlockedIncrement(&DsmContext->NumberGroups);
    group->GroupSig = DSM_GROUP_SIG;

    ASSERT(group->GroupNumber >= 1);
    return group;
}


NTSTATUS
DsmAddDeviceEntry(
    IN PDSM_CONTEXT DsmContext,
    IN PGROUP_ENTRY Group,
    IN PDEVICE_INFO DeviceInfo,
    IN ULONG DeviceState 
    )
{
    ULONG numberDevices;
    ULONG i;
    KIRQL irql;
    
    //
    // Ensure that this is a valid config - namely, it hasn't
    // exceeded the number of paths supported.
    // 
    numberDevices = Group->NumberDevices;
    if (numberDevices >= MAX_PATHS) {
        return STATUS_UNSUCCESSFUL;
    }
    
    KeAcquireSpinLock(&DsmContext->SpinLock, &irql);
    
#if DBG

    //
    // Ensure that this isn't a second copy of the same pdo.
    //
    for (i = 0; i < numberDevices; i++) {
        if (Group->DeviceList[i]->PortPdo == DeviceInfo->PortPdo) {
            DebugPrint((0,
                          "DsmAddDeviceEntry: Received same PDO twice\n"));
            DbgBreakPoint();
        }
    }
    
#endif    
    //
    // Indicate one device is present in
    // this group.
    // 
    Group->DeviceList[numberDevices] = DeviceInfo;

    //
    // Indicate one more in the list.
    // 
    Group->NumberDevices++;

    //
    // Set-up this device's group id.
    //
    DeviceInfo->Group = Group;

    //
    // Set-up whether this is an active/passive member of the
    // group.
    //
    DeviceInfo->State = DeviceState;
   
    //
    // One more deviceInfo entry.
    //
    DsmContext->NumberDevices++;
    
    //
    // Finally, add it to the global list of devices.
    //
    InsertTailList(&DsmContext->DeviceList,
                   &DeviceInfo->ListEntry);

    KeReleaseSpinLock(&DsmContext->SpinLock, irql);
    
    return STATUS_SUCCESS;
}


VOID
DsmRemoveDeviceEntry(
    IN PDSM_CONTEXT DsmContext,
    IN PGROUP_ENTRY Group,
    IN PDEVICE_INFO DeviceInfo
    )
{
    KIRQL irql;
    NTSTATUS status;
    ULONG i;
    ULONG j;
    BOOLEAN freeGroup = FALSE;

    KeAcquireSpinLock(&DsmContext->SpinLock, &irql);

    //
    // Find it's offset in the array of devices.
    // 
    for (i = 0; i < Group->NumberDevices; i++) {
        
        if (Group->DeviceList[i] == DeviceInfo) {

            //
            // Zero out it's entry.
            // 
            Group->DeviceList[i] = NULL;

            //
            // Reduce the number in the group.
            //
            Group->NumberDevices--;

            //
            // Collapse the array.
            //
            // BUGBUG: If any requests come in during this time, it's
            // possible to either bugcheck or get an incorrect deviceInfo
            // structure.
            // 
            for (j = i; j < Group->NumberDevices; j++) {

                //
                // Shuffle all entries down to fill the hole.
                //
                Group->DeviceList[j] = Group->DeviceList[j + 1];
            }
           
            //
            // Zero out the last one.
            //
            Group->DeviceList[j] = NULL;
            break;
        }
    }

    //
    // See if anything is left in the Group.
    // 
    if (Group->NumberDevices == 0) {

        //
        // Yank it from the Group list.
        //
        RemoveEntryList(&Group->ListEntry);
        DsmContext->NumberGroups--;

        //
        // Zero it.
        //
        RtlZeroMemory(Group,
                      sizeof(GROUP_ENTRY));
        
        freeGroup = TRUE;
    }

    //
    // Yank the device out of the Global list.
    //
    RemoveEntryList(&DeviceInfo->ListEntry);
    DsmContext->NumberDevices--;
    
    //
    // Zero it.
    //
    RtlZeroMemory(DeviceInfo,
                  sizeof(DEVICE_INFO));

    KeReleaseSpinLock(&DsmContext->SpinLock, irql);
    
    //
    // Free the allocation.
    //
    ExFreePool(DeviceInfo);

    if (freeGroup) {

        //
        // Free the allocation.
        //
        ExFreePool(Group);
    }
}



PFAILOVER_GROUP
DsmFindFOGroup(
    IN PDSM_CONTEXT DsmContext,
    IN PVOID PathId
    )
{
    PFAILOVER_GROUP failOverGroup;
    PLIST_ENTRY entry;
    ULONG i;

    //
    // Run through the list of Fail-Over Groups
    //
    entry = DsmContext->FailGroupList.Flink;
    for (i = 0; i < DsmContext->NumberFOGroups; i++, entry = entry->Flink) {

        //
        // Extract the fail-over group structure.
        // 
        failOverGroup = CONTAINING_RECORD(entry, FAILOVER_GROUP, ListEntry);
        ASSERT(failOverGroup);

        //
        // Check for a match of the PathId.
        //
        if (failOverGroup->PathId == PathId) {
            return failOverGroup;
        }
    }
    
    return NULL;
}


PFAILOVER_GROUP
DsmBuildFOGroup(
    IN PDSM_CONTEXT DsmContext,
    IN PDEVICE_INFO DeviceInfo,
    IN PVOID PathId
    )
{
    PFAILOVER_GROUP failOverGroup;
    KIRQL irql;
    ULONG numberGroups;
    
    //
    // Allocate an entry.
    // 
    failOverGroup = ExAllocatePool(NonPagedPool, sizeof(FAILOVER_GROUP));
    if (failOverGroup == NULL) {
        return NULL; 
    }

    RtlZeroMemory(failOverGroup, sizeof(FAILOVER_GROUP));

    KeAcquireSpinLock(&DsmContext->SpinLock, &irql);

    //
    // Get the current number of groups, and add the one that's
    // being created.
    //
    numberGroups = DsmContext->NumberFOGroups++;
    
    //
    // Set the PathId - All devices on the same PathId will
    // failover together.
    //
    failOverGroup->PathId = PathId;
   
    //
    // Set the initial state to NORMAL.
    //
    failOverGroup->State = FG_NORMAL;

    failOverGroup->FailOverSig = DSM_FOG_SIG;

    //
    // Add it to the global list.
    //
    InsertTailList(&DsmContext->FailGroupList,
                   &failOverGroup->ListEntry);

    KeReleaseSpinLock(&DsmContext->SpinLock, irql);

    return failOverGroup;
                   
}    


NTSTATUS
DsmUpdateFOGroup(
    IN PDSM_CONTEXT DsmContext,
    IN PFAILOVER_GROUP FailGroup,
    IN PDEVICE_INFO DeviceInfo
    )
{
    PGROUP_ENTRY group;
    ULONG count;
    ULONG i;
    KIRQL irql;

    KeAcquireSpinLock(&DsmContext->SpinLock, &irql);
    
    //
    // Add the device to the list of devices that are on this path.
    //
    count = FailGroup->Count++;
    FailGroup->DeviceList[count] = DeviceInfo;

    //
    // Get the MultiPath group for this device.
    //
    group = DeviceInfo->Group;

    //
    // Indicate that the L.B. policy needs to be updated. 
    // The next call to LBGetPath will cause the re-shuffle to
    // take place.
    // 
    group->LoadBalanceInit = FALSE;

    //
    // Indicate the need to wait for PathVerify
    // This just eliminates the need to handle unit attentions
    // on this device when LoadBalancing is set-up.
    //
    DeviceInfo->NeedsVerification = TRUE;

    //
    // Set the device's F.O. Group.
    //
    DeviceInfo->FailGroup = FailGroup;
    
    KeReleaseSpinLock(&DsmContext->SpinLock, irql);

    return STATUS_SUCCESS;
}    


VOID
DsmRemoveDeviceFailGroup(
    IN PDSM_CONTEXT DsmContext,
    IN PFAILOVER_GROUP FailGroup,
    IN PDEVICE_INFO DeviceInfo
    )
{
    ULONG count;
    KIRQL irql;
    ULONG i;
    ULONG j;

    KeAcquireSpinLock(&DsmContext->SpinLock, &irql);
    
    //
    // Find it's offset in the array of devices.
    // 
    for (i = 0; i < FailGroup->Count; i++) {

        if (FailGroup->DeviceList[i] == DeviceInfo) {

            //
            // Zero out it's entry.
            // 
            FailGroup->DeviceList[i] = NULL;

            //
            // Reduce the number in the group.
            //
            FailGroup->Count--;

            //
            // Collapse the array.
            //
            for (j = i; j < FailGroup->Count; j++) {

                //
                // Shuffle all entries down to fill the hole.
                //
                FailGroup->DeviceList[j] = FailGroup->DeviceList[j + 1];
            }
           
            //
            // Zero out the last one.
            //
            FailGroup->DeviceList[j] = NULL;
            break;
        }
    }

    KeReleaseSpinLock(&DsmContext->SpinLock, irql);
    return;
}    



PFAILOVER_GROUP
DsmSetNewPath(
    IN PDSM_CONTEXT DsmContext,
    IN PGROUP_ENTRY Group,
    IN PDEVICE_INFO FailingDevice,
    IN PFAILOVER_GROUP SelectedPath
    )
{
    PFAILOVER_GROUP failGroup;
    PGROUP_ENTRY group;
    PDEVICE_INFO device;
    ULONG i;
    NTSTATUS status;
    BOOLEAN matched = FALSE;

    if (SelectedPath) {

        //
        // This indicates that a new path has already been selected
        // for at least one device in the Fail-Over Group.
        // Run the list of new devices and find the matching
        // multi-path group.
        //
        for (i = 0; i < SelectedPath->Count; i++) {

            //
            // Get the device from the newly selected Path.
            // 
            device = SelectedPath->DeviceList[i];

            //
            // Determine if the device's group matches the failing
            // device's group.
            // 
            if (device->Group == Group) {

                //
                // The new device should be either ACTIVE or PASSIVE
                //
                if ((device->State == DEV_ACTIVE) ||
                    (device->State == DEV_PASSIVE)) {

                    //
                    // Set it to ACTIVE.
                    //
                    device->State = DEV_ACTIVE;

                    //
                    // Ensure that it's ready.
                    //
                    status = DsmSendTUR(device->TargetObject);
                    ASSERT(status == STATUS_SUCCESS);
                    
                    matched = TRUE;
                    break;
                }
            }
        }

        //
        // When the first call was made and a path selected, all devices
        // on the path were checked for validity.
        // 
        ASSERT(matched == TRUE);

        //
        // Just return the SelectedPath
        //
        failGroup = SelectedPath;
        
    } else {
        
        //
        // Go through Group, looking for an available device.
        //
        for (i = 0; i < Group->NumberDevices; i++) {
            
            //
            // Look for any that are Passive. They are the best
            // choice. This would indicate either an ActiveN/PassiveN arrangement.
            //
            device = Group->DeviceList[i];
            if (device->State == DEV_PASSIVE) {
                matched = TRUE;
                break;
            }
        }
        
        if (matched) {

            //
            // Mark the device as active.
            //
            device->State = DEV_ACTIVE;

            //
            // Ensure that it's ready.
            //
            status = DsmSendTUR(device->TargetObject);
            if (status != STATUS_SUCCESS) {
                DebugPrint((0,
                             "SetNewPath: SendTUR (%x) (%x)\n",
                             status,
                             device->TargetObject));
            }
            ASSERT(status == STATUS_SUCCESS);

            // 
            // Get the Fail-Over group from the selected device.
            //
            failGroup = device->FailGroup;
            
        } else {

            //
            // No passive devices. This indicates either an Active/Active arrangement,
            // or everything is failed.
            // Look for active devices.
            //
            for (i = 0; i < Group->NumberDevices; i++) {
                
                device = Group->DeviceList[i];
                if (device->State == DEV_ACTIVE) {
                    matched = TRUE;
                    break;
                }
            }
            if (matched) {
                
                //
                // The device is already active, just return the
                // new path info.
                //
                failGroup = device->FailGroup;

                //
                // Ensure that it's ready.
                //
                status = DsmSendTUR(device->TargetObject);
                
            } else {

                //
                // Everything has failed. Should try to do something?? TODO
                //
                failGroup = NULL;
            }    
        }       

        if (failGroup) {

            //
            // Run through all the devices to ensure that they are
            // in a reasonable state.
            //
            for (i = 0; i < failGroup->Count; i++) {
                device = failGroup->DeviceList[i];
                if ((device->State != DEV_ACTIVE) &&
                    (device->State != DEV_PASSIVE)) {

                    //
                    // Really need to find a new fail-over group.
                    // TODO.
                    // This isn't necessarily a valid assert. If static lb is in
                    // effect and this is one of the first to fail-over, others
                    // could be considered bad.
                    //
                    ASSERT(device->State == DEV_ACTIVE);
                }
            }
        }
    }        
    return failGroup;
}


VOID
DsmLBInit(
    IN PDSM_CONTEXT DsmContext,
    IN PGROUP_ENTRY Group
    )
{
    PFAILOVER_GROUP failGroup;
    PDEVICE_INFO device;
    PLIST_ENTRY entry;
    ULONG numberPaths;
    ULONG assignedPath;
    ULONG i;
    BOOLEAN found;
   
    //
    // TODO: Once the Wmi support is here, this will be configurable
    // Need to add code to handle each of the different policies.
    //
    //
    // Doing 'static' LB. Out of each Multi-Path Group, one
    // device will be active and assigned to a particular path.
    // The assignment is based on the group ordinal modulus the total
    // number of paths.
    //
    numberPaths = DsmContext->NumberFOGroups;
    assignedPath = Group->GroupNumber % numberPaths;
//    assignedPath = 0;

    DebugPrint((2,
                  "DsmLBInit: NumberFOGs (%x), Group Number (%x), assignedPath (%x)\n",
                  DsmContext->NumberFOGroups,
                  Group->GroupNumber,
                  assignedPath));
    
    //
    // Get the Fail-Over Group with the correct path.
    //
    i = 0;
    found = FALSE;
    
    //
    // Get the first entry.
    // 
    entry = DsmContext->FailGroupList.Flink;
    
    do {

        //
        // Extract the F.O. Group entry.
        // 
        failGroup = CONTAINING_RECORD(entry, FAILOVER_GROUP, ListEntry);
        ASSERT(failGroup);

        if (i == assignedPath) {

            //
            // This is the one.
            //
            found = TRUE;
            
        } else {

            //
            // Advance to the next entry.
            //
            entry = entry->Flink;
            i++;
        }       
        //
        // BUGBUG: Need to terminate this loop based on #of FG's.
        //
    } while (found == FALSE);        
   
    
    //
    // It may occur that though there are multiple paths/groups, not
    // all devices have been put into the DeviceList.
    // If there is only 1, special case this. It will get fixed up
    // when the second device arrives.
    //
    if (Group->NumberDevices == 1) {

        //
        // LOG. Indicates something "might" be wrong - definitely
        // not multi-pathing this device, so could lead to disaster
        // 
        //
        // Grab device 0 and set it active.
        //
        device = Group->DeviceList[0];
        device->State = DEV_ACTIVE;
    
        //
        // Go ahead state that this is init'ed. If/when another
        // device shows up, we will re-do this.
        //
        Group->LoadBalanceInit = TRUE;
        Group->LoadBalanceType = LB_STATIC;
       
        DebugPrint((0,
                     "DsmLBInit: Only One Device (%x) currently in group. Setting it Active\n",
                     device));
        return;
    }

        
    //
    // Find the device with the same F.O. Group
    // in the mulit-path group.
    //
    for (i = 0; i < Group->NumberDevices; i++) {
        
        //
        // Get the device info.
        //
        device = Group->DeviceList[i];

        //
        // See if there is a match.
        // 
        if (device->FailGroup == failGroup) {
            
            //
            // Set the device to active.
            //
            device->State = DEV_ACTIVE;

            //
            // Done setting up this multi-path group.
            // Indicate that it's so, and that we are using
            // STATIC Load-Balancing.
            //
            Group->LoadBalanceInit = TRUE;
            Group->LoadBalanceType = LB_STATIC;
            return;

        } else {

            //
            // This makes the assumption, once again that Static LB is in
            // effect. As this entire routine would need to be changes for
            // any other policy, it's OK.
            //
            if (device->State == DEV_ACTIVE) {
                device->State = DEV_PASSIVE;

            } else {

                //
                // Don't muck with the state. It could be REMOVE_PENDING or FAILED
                // and just waiting for the cleanup.
                //
                NOTHING;
            }    
        }    
    }
}


NTSTATUS
DsmQueryData(
    IN PVOID DsmContext,    
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer,
    OUT PULONG DataLength
    )
{
    PDSM_CONTEXT context = DsmContext;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    ULONG dataLength;

    switch(GuidIndex) {
        case GENDSM_CONFIGINFOGuidIndex: {
            PGENDSM_CONFIGINFO configInfo;
                
            dataLength = sizeof(GENDSM_CONFIGINFO);
            if (dataLength > BufferAvail) {

                //
                // Buffer is too small. Indicate this back
                // to the mpio driver.
                // 
                *DataLength = dataLength;
                status = STATUS_BUFFER_TOO_SMALL;
            } else {

                //
                // Get the buffer.
                // 
                configInfo = (PGENDSM_CONFIGINFO)Buffer;

                //
                // Set-up the necessary info.
                //
                configInfo->NumberFOGroups = context->NumberFOGroups;
                configInfo->NumberMPGroups = context->NumberGroups;
                configInfo->LoadBalancePolicy = DSM_LB_STATIC;

                //
                // Indicate the size of returned data to
                // WMI and MPIO.
                //
                *DataLength = dataLength;
                *InstanceLengthArray = dataLength;
                status = STATUS_SUCCESS;
            }    
            break;
        }

        case BinaryMofGuidIndex: {
            //
            // Check that the buffer size can handle the binary
            // mof data.
            // 
            dataLength = sizeof(DsmBinaryMofData);

            if (dataLength > BufferAvail) {

                // 
                // Buffer is too small.
                // Indicate such with status.
                // 
                status = STATUS_BUFFER_TOO_SMALL;

                //
                // Update DataLength, so that the mpio pdo knows
                // the correct size to report back to Wmi.
                //
                *DataLength = dataLength;
            } else {
                
                RtlCopyMemory(Buffer, DsmBinaryMofData, dataLength);

                //
                // Set both of these on all successful operations.
                // InstanceLengthArray gives wMI it's info and DataLength
                // gives the mpio pdo it's info.
                //
                *InstanceLengthArray = dataLength;
                *DataLength = dataLength;
                status = STATUS_SUCCESS;
            }
            break;
        }

        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
    }

    return status;
}


VOID
DsmWmiInitialize(
    IN PDSM_WMILIB_CONTEXT WmiInfo
    )
{

    RtlZeroMemory(WmiInfo, sizeof(DSM_WMILIB_CONTEXT));

    //
    // This will jam in the entry points and guids for
    // supported WMI operations.
    //
    WmiInfo->GuidCount = DsmGuidCount;
    WmiInfo->GuidList = DsmGuidList;
    WmiInfo->QueryWmiDataBlock = DsmQueryData;
    
    //
    // SetDataBlock and Item, Execute, and FunctionControl are currently
    // not needed, so leave them set to zero.
    //
    return;
}



VOID
DsmDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for the DSM

Arguments:

Return Value:

    None

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= GenDSMDebug) {

        _vsnprintf(DebugBuffer, DEBUG_BUFFER_LENGTH, DebugMessage, ap);

        DbgPrint(DebugBuffer);
    }

    va_end(ap);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\dsm\wmi.h ===
#ifndef _dsmmof_h_
#define _dsmmof_h_

// GENDSM_CONFIGINFO - GENDSM_CONFIGINFO
// GenDSM Configuration Information.
#define GENDSM_CONFIGINFOGuid \
    { 0xd6dc1bf0,0x95fa,0x4246, { 0xaf,0xd7,0x40,0xa0,0x30,0x45,0x8f,0x48 } }

DEFINE_GUID(GENDSM_CONFIGINFO_GUID, \
            0xd6dc1bf0,0x95fa,0x4246,0xaf,0xd7,0x40,0xa0,0x30,0x45,0x8f,0x48);


typedef struct _GENDSM_CONFIGINFO
{
    // Number of Fail-Over Groups.
    ULONG NumberFOGroups;
    #define GENDSM_CONFIGINFO_NumberFOGroups_SIZE sizeof(ULONG)
    #define GENDSM_CONFIGINFO_NumberFOGroups_ID 1

    // Number of Multi-Path Groups
    ULONG NumberMPGroups;
    #define GENDSM_CONFIGINFO_NumberMPGroups_SIZE sizeof(ULONG)
    #define GENDSM_CONFIGINFO_NumberMPGroups_ID 2


// Fail-Over Only
#define DSM_LB_FAILOVER 1
// Static
#define DSM_LB_STATIC 2
// Dynamic Least-Queue
#define DSM_LB_DYN_LEAST_QUEUE 3
// Dynamic Other
#define DSM_LB_DYN_OTHER 4

    // Current Load-Balance Policy.
    ULONG LoadBalancePolicy;
    #define GENDSM_CONFIGINFO_LoadBalancePolicy_SIZE sizeof(ULONG)
    #define GENDSM_CONFIGINFO_LoadBalancePolicy_ID 3

} GENDSM_CONFIGINFO, *PGENDSM_CONFIGINFO;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\hpdsm\hpdsm.c ===
/*++

Copyright (C) 2000-2001  Microsoft Corporation

Module Name:

    hpdsm.c

Abstract:

    This driver is the DSM for HP XP-256/512

Author:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include <ntddk.h>
#include <stdio.h>
#include <stdarg.h>
#include "dsm.h"
#include "hpdsm.h"



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine is called when the driver loads loads.

Arguments:

    DriverObject    - Supplies the driver object.
    RegistryPath    - Supplies the registry path.

Return Value:

    NTSTATUS

--*/
{
    DSM_INIT_DATA initData;
    WCHAR dosDeviceName[40];
    UNICODE_STRING mpUnicodeName;
    PDEVICE_OBJECT deviceObject;
    PFILE_OBJECT fileObject;
    NTSTATUS status;
    PDSM_CONTEXT dsmContext;
    PDSM_MPIO_CONTEXT mpctlContext;
    PVOID buffer;

    //
    // Build the init data structure.
    //
    dsmContext = ExAllocatePool(NonPagedPool, sizeof(DSM_CONTEXT));
    if (dsmContext == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(dsmContext, sizeof(DSM_CONTEXT));

    buffer = &initData;

    //
    // Set-up the init data
    //
    initData.DsmContext = (PVOID)dsmContext;
    initData.InitDataSize = sizeof(DSM_INIT_DATA);

    initData.DsmInquireDriver = HPInquire;
    initData.DsmCompareDevices = HPCompareDevices;
    initData.DsmSetDeviceInfo = HPSetDeviceInfo;
    initData.DsmGetControllerInfo = HPGetControllerInfo;
    initData.DsmIsPathActive = HPIsPathActive;
    initData.DsmPathVerify = HPPathVerify;
    initData.DsmInvalidatePath = HPInvalidatePath;
    initData.DsmRemoveDevice = HPRemoveDevice;
    initData.DsmRemovePath = HPRemovePath; 
    initData.DsmReenablePath = HPBringPathOnLine;

    initData.DsmCategorizeRequest = HPCategorizeRequest;
    initData.DsmBroadcastSrb = HPBroadcastRequest;
    initData.DsmSrbDeviceControl = HPSrbDeviceControl;
    initData.DsmSetCompletion = HPSetCompletion;
    initData.DsmLBGetPath = HPLBGetPath;
    initData.DsmInterpretError = HPInterpretError; 
    initData.DsmUnload = HPUnload;

    //
    // Need to also set-up the WMI info. TODO 
    //
    
    //
    // Set the DriverObject. Used by MPIO for Unloading.
    // 
    initData.DriverObject = DriverObject;
    RtlInitUnicodeString(&initData.DisplayName, L"HP FC-12 Device-Specific Module");

    //
    // Initialize the context objects.
    //
    KeInitializeSpinLock(&dsmContext->SpinLock);
    InitializeListHead(&dsmContext->GroupList);
    InitializeListHead(&dsmContext->DeviceList);
    InitializeListHead(&dsmContext->FailGroupList);
    ExInitializeNPagedLookasideList(&dsmContext->ContextList,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(COMPLETION_CONTEXT),
                                    'MSDG',
                                    0);
    //
    // Build the mpctl name.
    //
    swprintf(dosDeviceName, L"\\DosDevices\\MPathControl");
    RtlInitUnicodeString(&mpUnicodeName, dosDeviceName);
    
    //
    // Get mpctl's deviceObject.
    //
    status = IoGetDeviceObjectPointer(&mpUnicodeName,
                                      FILE_READ_ATTRIBUTES,
                                      &fileObject,
                                      &deviceObject);
    if (NT_SUCCESS(status)) {
        KEVENT event;
        PIRP irp;
        IO_STATUS_BLOCK ioStatus;

        //
        // Send the IOCTL to mpctl.sys to register ourselves.
        //
        DsmSendDeviceIoControlSynchronous(IOCTL_MPDSM_REGISTER,
                                            deviceObject,
                                            &initData,
                                            &initData,
                                            sizeof(DSM_INIT_DATA),
                                            sizeof(DSM_MPIO_CONTEXT),
                                            TRUE,
                                            &ioStatus);
        status = ioStatus.Status;
        ObDereferenceObject(fileObject);
    }

    if (status == STATUS_SUCCESS) {


        //
        // Grab the context value passed back by mpctl.
        //
        mpctlContext = buffer;
        dsmContext->MPIOContext = mpctlContext->MPIOContext;

    } else {
        DebugPrint((0,
                     "HPDsm: Failed to register (%x)\n",
                     status));
        //
        // Stay loaded, perhaps mpctl will come up later.
        // Will need to implement a mechanism to poll for mpio to arrive.
        //
        status = STATUS_SUCCESS;
    }

    return status;
}


NTSTATUS
HPInquire (
    IN PVOID DsmContext,
    IN PDEVICE_OBJECT TargetDevice,
    IN PDEVICE_OBJECT PortObject,
    IN PSTORAGE_DEVICE_DESCRIPTOR Descriptor,
    IN PSTORAGE_DEVICE_ID_DESCRIPTOR DeviceIdList,
    OUT PVOID *DsmIdentifier
    )
{
    PDEVICE_INFO deviceInfo;
    PGROUP_ENTRY group;
    NTSTATUS status;
    ULONG deviceState;
    ULONG allocationLength;
    PHP_ENQUIRY enquiry;
    PHP_DAC_STATUS dacStatus;
    UCHAR majorRev;
    UCHAR minorRev;
    ULONG loadBal;
    PUCHAR vendorIndex;
    PUCHAR productIndex;
    BOOLEAN needInquiry = FALSE;
    UCHAR nativeSlot;
    UCHAR portNumber;
    UCHAR logicalPort;
    PUCHAR vendorId = "HP      ";
    PUCHAR productId = "FCArray";

    //
    // Ensure that the device's serial number is present. If not, can't claim
    // support for this drive.
    //
    if ((Descriptor->SerialNumberOffset == (ULONG)-1) ||
        (Descriptor->SerialNumberOffset == 0)) {

        // TODO : remove after FW update...
        // 
        //return STATUS_NOT_SUPPORTED;
        needInquiry = TRUE;
    }
    
    vendorIndex = (PUCHAR)Descriptor;
    productIndex = (PUCHAR)Descriptor;
    (ULONG_PTR)vendorIndex += Descriptor->VendorIdOffset;
    (ULONG_PTR)productIndex += Descriptor->ProductIdOffset;
    
    //
    // Determine if the device is supported. 
    //
    if ((!RtlEqualMemory(vendorId, vendorIndex, 8)) ||
        (!RtlEqualMemory(productId, productIndex, 7))) {
    
        
        return STATUS_NOT_SUPPORTED;
    }
    
    //
    // Allocate the descriptor. This is also used as DsmId.
    //
    allocationLength = sizeof(DEVICE_INFO);
    allocationLength += Descriptor->Size - sizeof(STORAGE_DEVICE_DESCRIPTOR);
    deviceInfo = ExAllocatePool(NonPagedPool, allocationLength);
    if (deviceInfo == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(deviceInfo, allocationLength);
   
    //
    // Copy over the StorageDescriptor.
    // 
    RtlCopyMemory(&deviceInfo->Descriptor,
                  Descriptor,
                  Descriptor->Size);

    //
    // Save the PortPdo Object.
    //
    deviceInfo->PortPdo = TargetDevice;


    //
    // Send the enquire command to get the FW revs. Based on the revision
    // we can either do fail-over only or active lb.
    //
    enquiry = ExAllocatePool(NonPagedPoolCacheAligned, sizeof(HP_ENQUIRY));
    if (enquiry == NULL) {
        
        ExFreePool(deviceInfo);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    RtlZeroMemory(enquiry, sizeof(HP_ENQUIRY));
    
    status = HPSendDirectCommand(TargetDevice,
                                 (PUCHAR)enquiry,
                                 sizeof(HP_ENQUIRY),
                                 DCMD_ENQUIRY);

    if (NT_SUCCESS(status)) {

        majorRev = enquiry->FwMajorRev;
        minorRev = enquiry->FwMinorRev;

        DebugPrint((0,
                    "HPDSM: FirmWare Major (%u) Minor (%u)\n",
                    majorRev,
                    minorRev));
        
        //
        // Free the buffer.
        //
        ExFreePool(enquiry);
        
        if (majorRev > 5 || (majorRev == 5 && minorRev >= 46)) {

            //
            // Supports dual active/active.
            //
            loadBal = LB_MIN_QUEUE;

        } else if (majorRev == 5 && minorRev >= 41) {

            //
            // Fail-over only.
            //
            loadBal = LB_ACTIVE_PASSIVE;
            
        } else {

            //
            // Not supported. LOG.
            //
            ExFreePool(deviceInfo);
           
            return STATUS_NOT_SUPPORTED;
        }    
    } else {

        ExFreePool(enquiry);
        ExFreePool(deviceInfo);
        return status;
    }    
    
    //
    // Send the Get Controller Status command so that the port
    // on which this device lives can be determined.
    //
    dacStatus = ExAllocatePool(NonPagedPoolCacheAligned, sizeof(HP_DAC_STATUS));
    if (dacStatus == NULL) {
        ExFreePool(deviceInfo);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    RtlZeroMemory(dacStatus, sizeof(HP_DAC_STATUS));
    status = HPSendDirectCommand(TargetDevice,
                                 (PUCHAR)dacStatus,
                                 sizeof(HP_DAC_STATUS),
                                 DCMD_GET_DAC_STATUS);

    if (NT_SUCCESS(status)) {

        //
        // Build a logical port value (1-4) based on the NativeSlot and PortNumber 
        // values. NativeSlot 0 or 1, and portNumber 0 or 1 for 4 possibilities.
        // NativeSlot refers to the controller and portNumber to the port.
        // 
        nativeSlot = dacStatus->DACInfo[0] >> 4;
        portNumber = (dacStatus->DACInfo[1] >> 5) & 0x01;

        logicalPort = ((nativeSlot & 1) << 1) + (portNumber + 1);

        //
        // Set the port number for this device.
        // Used to help create the FOGroups and as the index into
        // the path array.
        //  
        deviceInfo->Controller = logicalPort;
        
    } else {

        ExFreePool(deviceInfo);
        return status;
    }    

    
    //
    // Build the controller serial number.
    // Bytes 40-47 of the inquiry data have the Node Name of Controller 0.
    // Use this as a 64-bit identifier.
    //
    if (needInquiry) {
        CDB cdb;
        PINQUIRYDATA inquiryBuffer;

        RtlZeroMemory(&cdb, sizeof(CDB));
                
        cdb.START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
        cdb.START_STOP.Start = 1;
       
        status = HPSendScsiCommand(TargetDevice,
                                   NULL,
                                   0,
                                   6,
                                   &cdb,
                                   1);
        
        RtlZeroMemory(&cdb, sizeof(CDB));
            
        cdb.CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;
        cdb.CDB6INQUIRY.AllocationLength = 56;
        
        inquiryBuffer = ExAllocatePool(NonPagedPoolCacheAligned, 56);

        status = HPSendScsiCommand(TargetDevice,
                                   (PUCHAR)inquiryBuffer,
                                   56,
                                   6,
                                   &cdb,
                                   1);
        if (NT_SUCCESS(status)) {
            UCHAR controllerSerialNumber[9];
            UCHAR driveNumber[11];

            RtlZeroMemory(controllerSerialNumber, 9);
            RtlZeroMemory(driveNumber, 11);

            //
            // Copy the serial number over into the deviceInfo.
            // SerialNumber is built from the Node Name of the Controller +
            // the SystemDrive Number.
            //
            RtlCopyMemory(controllerSerialNumber,
                          &inquiryBuffer->VendorSpecific[4],
                          8);
            //
            // Get the drive Number.
            //
            driveNumber[0] = inquiryBuffer->VendorSpecific[0];
            driveNumber[1] = inquiryBuffer->VendorSpecific[1];

            //
            // cat the driveNumber & controller serial number into 10-byte binary value.
            //
            RtlCopyMemory(&driveNumber[2],
                          controllerSerialNumber,
                          8);

            //
            // Convert to ascii.
            //
            HPConvertHexToAscii(driveNumber,
                                deviceInfo->SerialNumber,
                                10);

            DebugPrint((0,
                        "HPInquiry: SerialNumber: %s\n", deviceInfo->SerialNumber));

        }

    }
    
    //
    // See if there is an existing Muli-path group to which this belongs.
    // (same serial number). 
    // 
    group = FindDevice(DsmContext,
                       deviceInfo);

    if (group == NULL) {
    
        //
        // Build a multi-path group entry.
        //
        group = BuildGroupEntry(DsmContext,
                                deviceInfo);
        if (group == NULL) {
            ExFreePool(deviceInfo);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // This is the first in the group, so make it the active
        // device. The actual active/passive devices will be set-up
        // later when the first call to LBGetPath is made.
        // 
        deviceState = DEV_ACTIVE;

    } else {
        
        //
        // Already something active, this will be the fail-over 
        // device until the load-balance groups are set-up.
        //
        deviceState = DEV_PASSIVE;
    }    
    
    //
    // Add it to the list.
    //
    status = AddDeviceEntry(DsmContext,
                            group,
                            deviceInfo,
                            deviceState);
    
    *DsmIdentifier = deviceInfo;
    return status;
}


VOID
HPConvertHexToAscii(
    IN PUCHAR HexString,
    IN OUT PUCHAR AsciiString,
    IN ULONG Count
    )
{
    ULONG i;
    ULONG j;
    UCHAR value;
  
    DebugPrint((0,
                "ConvertHexToAscii: "));
    for (i = 0, j = 0; i < Count; i++, j++) {
        
        value = HexString[i];
        DebugPrint((0,
                    "%x ", value));
        if (value <= 9) {
            AsciiString[j] = value + '0';
        } else {
            AsciiString[j] = value - 10 + 'A';
        }
    }
    DebugPrint((0,"\n"));
}
    

BOOLEAN
HPCompareDevices(
    IN PVOID DsmContext,
    IN PVOID DsmId1,
    IN PVOID DsmId2
    )
{
    PDEVICE_INFO deviceInfo = DsmId1;
    PDEVICE_INFO comparedDevice = DsmId2;
    ULONG length;
    PUCHAR serialNumber;
    PUCHAR comparedSerialNumber;

    //
    // If this is an RS12, then no serial number in the device descriptor.
    //
    if (deviceInfo->Descriptor.SerialNumberOffset == (ULONG)-1) {

        //
        // Use the one's built from inquiry Data.
        //
        serialNumber = deviceInfo->SerialNumber;
        comparedSerialNumber = comparedDevice->SerialNumber;
        
    } else {

        //
        // Get the two serial numbers.
        // They reside at SNOffset from the front of the
        // descriptor buffer.
        //
        serialNumber = (PUCHAR)&deviceInfo->Descriptor;
        serialNumber += deviceInfo->Descriptor.SerialNumberOffset;

        comparedSerialNumber = (PUCHAR)&comparedDevice->Descriptor;
        comparedSerialNumber += comparedDevice->Descriptor.SerialNumberOffset;
    
    }    

    //
    // Get the length of the base-device Serial Number.
    //
    length = strlen(serialNumber);

    //
    // If the lengths match, compare the contents.
    //
    if (length == strlen(comparedSerialNumber)) {
        if (RtlEqualMemory(serialNumber,
                           comparedSerialNumber,
                           length)) {
            return TRUE;
        }
    }
    return FALSE;
}


NTSTATUS
HPSetDeviceInfo(
    IN PVOID DsmContext,
    IN PDEVICE_OBJECT TargetObject,
    IN PVOID DsmId,
    IN OUT PVOID *PathId
    )
{
    PDEVICE_INFO deviceInfo = DsmId;
    PGROUP_ENTRY group = deviceInfo->Group;
    PFAILOVER_GROUP failGroup;
    NTSTATUS status;

    //
    // TargetObject is the destination for any requests created by this driver.
    // Save this for future reference.
    //
    deviceInfo->TargetObject = TargetObject;

    //
    // PathId indicates the path on which this device resides. Meaning
    // that when a Fail-Over occurs all device's on the same path fail together.
    // Search for a matching F.O. Group
    //
    failGroup = FindFOGroup(DsmContext,
                            *PathId);
    //
    // if not found, create a new f.o. group 
    //
    if (failGroup == NULL) {
        failGroup = BuildFOGroup(DsmContext,
                                 DsmId,
                                 *PathId);
        
        if (failGroup == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // add this deviceInfo to the f.o. group.
    // 
    status = UpdateFOGroup(DsmContext,
                           failGroup,
                           deviceInfo);
    return status;
}


NTSTATUS
HPGetControllerInfo(
    IN PVOID DsmContext,
    IN PVOID DsmId,
    IN ULONG Flags,
    IN OUT PCONTROLLER_INFO *ControllerInfo
    )
{
    PCONTROLLER_INFO controllerInfo;

    if (Flags & DSM_CNTRL_FLAGS_ALLOCATE) {
        controllerInfo = ExAllocatePool(NonPagedPool, sizeof(CONTROLLER_INFO));
        if (controllerInfo == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        
        RtlZeroMemory(controllerInfo, sizeof(CONTROLLER_INFO));

        //
        // TODO Get the ID etc.
        //
        controllerInfo->State = DSM_CONTROLLER_NO_CNTRL;
        *ControllerInfo = controllerInfo;

    } else {

        controllerInfo = *ControllerInfo;

        //
        // TODO Get the state.
        //
        controllerInfo->State = DSM_CONTROLLER_NO_CNTRL;
    }
    return STATUS_SUCCESS;
}


BOOLEAN
HPIsPathActive(
    IN PVOID DsmContext,        
    IN PVOID PathId
    )
{
    PFAILOVER_GROUP group;
    
    // 
    // NOTE: Internal callers of this assume certain behaviours. If it's changed,
    // those functions need to be updated appropriately.
    // 
    //
    // Get the F.O. Group information.
    //
    group = FindFOGroup(DsmContext,
                        PathId);
    //
    // If there are any devices on this path, and
    // it's not in a failed state: it's capable of handling requests
    // so it's active.
    //
    if ((group->Count >= 1) && (group->State == FG_NORMAL)) {
        return TRUE;
    }
    return FALSE;
}


NTSTATUS
HPPathVerify(
    IN PVOID DsmContext,                       
    IN PVOID DsmId,
    IN PVOID PathId
    )
{
    PDEVICE_INFO deviceInfo = DsmId;
    PFAILOVER_GROUP group;
    NTSTATUS status;
    ULONG i;

    //
    // Get the F.O. group
    //
    group = FindFOGroup(DsmContext,
                        PathId);
    if (group == NULL) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }
   
    //
    // Check the Path state to ensure all is normal.
    // Should be in FAILBACK state. This indicates that either
    // an admin utility told us we are O.K. or the AutoRecovery detected
    // the error was transitory.
    // BUGBUG: Need to implement both of the above assumptions.
    //
    if ((group->Count >= 1) && group->State == FG_FAILBACK) {
        
        // 
        // Ensure that the device is still there
        // 
        for (i = 0; i < group->Count; i++) {
            if (group->DeviceList[i] == deviceInfo) {

                //
                // Send it a TUR. 
                //
                status = DsmSendTUR(deviceInfo->TargetObject);
            }
        }
    } else {

        //
        // What really has to happen:
        // Ensure the device is in our structs
        // Send it a TUR.
        // Depending upon prior state - update to the new, appropriate state.
        // return status.
        //
        status = STATUS_UNSUCCESSFUL;
        for (i = 0; i < group->Count; i++) {
            if (group->DeviceList[i] == deviceInfo) {
                status = DsmSendTUR(deviceInfo->TargetObject);
            }
        }

        if (!NT_SUCCESS(status)) {

            //
            // Either the device is not in the group, or the TUR was not successful.
            // TODO - Something.
            //
        }   
    }       
    //
    // Update the group State, depending upon the outcome.
    // TODO
    //
    ASSERT(status == STATUS_SUCCESS);
    if (status == STATUS_SUCCESS) {

        //
        // This lets the LBInit run to properly set-up this device.
        //
        deviceInfo->NeedsVerification = FALSE;
    }

    return status;
}


NTSTATUS
HPInvalidatePath(
    IN PVOID DsmContext,
    IN ULONG ErrorMask,
    IN PVOID PathId,
    IN OUT PVOID *NewPathId
    )
{
    PFAILOVER_GROUP failGroup;
    PFAILOVER_GROUP hintPath;
    PGROUP_ENTRY group;
    PDEVICE_INFO deviceInfo;
    NTSTATUS status;
    ULONG i;

    ASSERT((ErrorMask & DSM_FATAL_ERROR) || (ErrorMask & DSM_ADMIN_FO));
    
    failGroup = FindFOGroup(DsmContext,
                            PathId);
    
    //
    // Mark the path as failed.
    //
    failGroup->State = FG_FAILED;
   
    //
    // First interation, the hint will be NULL. This allows the 
    // GetNewPath routine the opportunity to select the best new path
    // Subsequent calls will be fed the updated value.
    //
    hintPath = NULL; 

    //
    // Process each device in the fail-over group
    //
    for (i = 0; i < failGroup->Count; i++) {

        //
        // Get the deviceInfo.
        //
        deviceInfo = failGroup->DeviceList[i];

        // 
        // Set the state of the Failing Devicea
        //
        deviceInfo->State = DEV_FAILED;

        //
        // Get it's Multi-Path Group entry.
        //
        group = deviceInfo->Group;

        //
        // Get a new path for this failed device.
        // 
        hintPath = SetNewPath(DsmContext,
                              group,
                              deviceInfo,
                              hintPath);
        
    }

    if (hintPath == NULL) {

        //
        // This indicates that no acceptable paths
        // were found. Return the error to mpctl.
        //
        status = STATUS_NO_SUCH_DEVICE; 
        *NewPathId = NULL;

    } else {

    
        //
        // return the new path.
        //
        *NewPathId = hintPath->PathId;
        status = STATUS_SUCCESS;
    }    

    return status;
}


NTSTATUS
HPRemoveDevice(
    IN PVOID DsmContext,
    IN PVOID DsmId,
    IN PVOID PathId
    )
{
    PDSM_CONTEXT dsmContext = DsmContext; 
    PDEVICE_INFO deviceInfo;
    PFAILOVER_GROUP failGroup;
    PGROUP_ENTRY group;
    ULONG state;
    WCHAR buffer[64];

    //
    // DsmId is our deviceInfo structure.
    //
    deviceInfo = DsmId;
    
    //
    // Get it's Multi-Path Group entry.
    //
    group = deviceInfo->Group;

    //
    // Get the Fail-over group.
    //
    failGroup = deviceInfo->FailGroup;

    //
    // If it's active, need to 'Fail-Over' to another device in
    // the group.
    //
    state = deviceInfo->State;

    // 
    // Set the state of the Failing Devicea
    //
    deviceInfo->State = DEV_FAILED;
    
    if (state == DEV_ACTIVE) {

        //
        // Find the next available device.
        // This is basically a fail-over for just
        // this device.
        //
        SetNewPath(DsmContext,
                   group,
                   deviceInfo,
                   NULL);
    }

    //
    // Remove it's entry from the Fail-Over Group.
    //
    RemoveDeviceFailGroup(DsmContext,
                          failGroup,
                          deviceInfo);

    //
    // Remove it from it's multi-path group. This has the side-effect
    // of cleaning up the Group if the number of devices goes to zero.
    // 
    RemoveDeviceEntry(DsmContext,
                      group,
                      deviceInfo);
   
    swprintf(buffer, L"Removing Device");
    DsmWriteEvent(dsmContext->MPIOContext,
                  L"HpDsm",
                  buffer,
                  2);
    return STATUS_SUCCESS;
}


NTSTATUS
HPRemovePath(
    IN PDSM_CONTEXT DsmContext,
    IN PVOID PathId
    )
{
    PFAILOVER_GROUP failGroup;
    KIRQL irql;
    
    failGroup = FindFOGroup(DsmContext,
                            PathId);

    if (failGroup == NULL) {

        //
        // It's already been removed. 
        // LOG though.
        //
        return STATUS_SUCCESS;
    }

    //
    // The claim is that a path won't be removed, until all
    // the devices on it are.
    //
    ASSERT(failGroup->Count == 0);

    KeAcquireSpinLock(&DsmContext->SpinLock, &irql);
    //
    // Yank it from the list.
    //
    RemoveEntryList(&failGroup->ListEntry);
    DsmContext->NumberFOGroups--;

    //
    // Zero the entry.
    //
    RtlZeroMemory(failGroup, sizeof(FAILOVER_GROUP));
    KeReleaseSpinLock(&DsmContext->SpinLock, irql);

    //
    // Free the allocation.
    //
    ExFreePool(failGroup);

    return STATUS_SUCCESS;
}


NTSTATUS
HPBringPathOnLine(
    IN PVOID DsmContext,
    IN PVOID PathId,
    OUT PULONG DSMError
    )
{
    PFAILOVER_GROUP failGroup;

    //
    // PathVerify has been called already, so if
    // it came back successfully, then this is O.K.
    //
    failGroup = FindFOGroup(DsmContext,
                            PathId);

    if (failGroup == NULL) {

        //
        // LOG
        //
        *DSMError = 0;
        
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    //
    // Should be in FG_PENDING
    //
    ASSERT(failGroup->State == FG_PENDING);

    //
    // Indicate that it's ready to go.
    // 
    failGroup->State = FG_NORMAL;

    return STATUS_SUCCESS;
}


PVOID
HPLBGetPath(
    IN PVOID DsmContext,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PDSM_IDS DsmList,
    IN PVOID CurrentPath,
    OUT NTSTATUS *Status
    )
{
    PDEVICE_INFO deviceInfo;
    PGROUP_ENTRY group;
    PFAILOVER_GROUP failGroup = NULL;
    ULONG i;

    //
    // Up-front checking to minimally validate
    // the list of DsmId's being passed in.
    // 
    ASSERT(DsmList->Count);
    ASSERT(DsmList->IdList[0]);

    //
    // Grab the first device from the list.
    // 
    deviceInfo = DsmList->IdList[0];

    //
    // Get the multi-path group.
    //
    group = deviceInfo->Group;
    
    //
    // See if Load-Balancing has been initialized.
    //
    if (group->LoadBalanceInit == FALSE) {
        PDEVICE_INFO lbDevice;
        BOOLEAN doInit = TRUE;
        
        //
        // Check to see whether we are really ready to run
        // the LBInit. If any of the list aren't verified, then
        // we will hold off.
        //
        for (i = 0; i < DsmList->Count; i++) {
            lbDevice = DsmList->IdList[i];
            if (lbDevice->NeedsVerification) {
                DebugPrint((0,
                            "LBGetPath: (%x) needs verify\n",
                            lbDevice));
                doInit = FALSE;
                break;
            }
        }

        if (doInit) {

            //
            // Set-up the load-balancing. This routine
            // builds a static assignment of multi-path group to
            // a particular path.
            //
            LBInit(DsmContext,
                   group);
        }
    }
   
    //
    // Ensure that mpctl and this dsm are in sync.
    // 
    ASSERT(DsmList->Count == group->NumberDevices);
    
    // 
    // Find the active device.
    //
    for (i = 0; i < DsmList->Count; i++) {

        //
        // Get each of the DsmId's, in reality the deviceInfo.
        //
        deviceInfo = DsmList->IdList[i];
        
        //
        // Ensure that the device is in our list.
        //
        ASSERT(FindDevice(DsmContext, deviceInfo));
      
        //
        // NOTE: This assumes 'static' Load-Balancing. Once others
        // are implemented, this section will have to be updated.
        //
        // Return the path on which the ACTIVE device resides.
        // 
        if (deviceInfo->State == DEV_ACTIVE) {

            //
            // Get the F.O.Group, as it contains the
            // correct PathId for this device.
            // 
            failGroup = deviceInfo->FailGroup;

            *Status = STATUS_SUCCESS;
            return failGroup->PathId;
        }
    }

    //
    // Should never have gotten here.
    //
    DebugPrint((0,
                "LBGetPath: Returning STATUS_DEVICE_NOT_CONNECTED\n"));
    DbgBreakPoint();
    ASSERT(failGroup);
    *Status = STATUS_DEVICE_NOT_CONNECTED;
    return NULL;
}


ULONG
HPCategorizeRequest(
    IN PVOID DsmContext,
    IN PDSM_IDS DsmIds,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID CurrentPath,
    OUT PVOID *PathId,
    OUT NTSTATUS *Status
    )
{
    ULONG dsmStatus;
    NTSTATUS status;

    //
    // Requests to broadcast
    //    Reset
    //    Reserve
    //    Release
    //
    // Requests to Handle
    //    None for now.
    //

    //
    // For all other requests, punt it back to the bus-driver.
    // Need to get a path for the request first, so call the Load-Balance
    // function.
    //
    *PathId = HPLBGetPath(DsmContext,
                          Srb,
                          DsmIds,
                          CurrentPath,
                          &status);
    
    if (NT_SUCCESS(status)) {

        //
        // Indicate that the path is updated, and mpctl should handle the request.
        // 
        dsmStatus = DSM_PATH_SET;

    } else {

        //
        // Indicate the error back to mpctl.
        // 
        dsmStatus = DSM_ERROR;

        //
        // Mark-up the Srb to show that a failure has occurred.
        // This value is really only for this DSM to know what to do
        // in the InterpretError routine - Fatal Error.
        // It could be something more meaningful.
        // 
        Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
    }
    
    //
    // Pass back status info to mpctl.
    //
    *Status = status;
    return dsmStatus;
    
}


NTSTATUS
HPBroadcastRequest(
    IN PVOID DsmContext,
    IN PDSM_IDS DsmIds,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PKEVENT Event
    )
{
    //
    // BUGBUG: Need to handle Reset, Reserve, and Release.
    //
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
HPSrbDeviceControl(
    IN PVOID DsmContext,
    IN PDSM_IDS DsmIds,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PKEVENT Event
    )
{
    //
    // BUGBUG: Need to handle ?? 
    //
    return STATUS_INVALID_DEVICE_REQUEST;
}



VOID
HPCompletion(
    IN PVOID DsmId,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID DsmContext
    )
{
    PCOMPLETION_CONTEXT completionContext = DsmContext;
    PDEVICE_INFO deviceInfo;
    PDSM_CONTEXT dsmContext;
    UCHAR opCode;

    //
    // If it's read or write, save stats.
    // Categorize set-up the Context to have path, target info.
    // TODO
    //
    ASSERT(DsmContext);

    dsmContext = completionContext->DsmContext;
    deviceInfo = completionContext->DeviceInfo;
    opCode = Srb->Cdb[0];
    
    //
    // Indicate one less request on this device.
    //
    InterlockedDecrement(&deviceInfo->Requests);

    //
    // TODO: Use the timestamp.
    // Path/Device up-time, ave. time/request...
    //
    
    //
    // If it's a read or a write, update the stats.
    //
    if (opCode == SCSIOP_READ) {

        deviceInfo->Stats.NumberReads++;
        deviceInfo->Stats.BytesRead.QuadPart += Srb->DataTransferLength;
            
    } else if (opCode == SCSIOP_WRITE) {
        
        deviceInfo->Stats.NumberWrites++;
        deviceInfo->Stats.BytesWritten.QuadPart += Srb->DataTransferLength;
    }
    
    //
    // Release the allocation.
    //
    ExFreeToNPagedLookasideList(&dsmContext->ContextList,
                                DsmContext);
}    


VOID
HPSetCompletion(
    IN PVOID DsmContext,
    IN PVOID DsmId,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PDSM_COMPLETION_INFO DsmCompletion
    )
{
    PCOMPLETION_CONTEXT completionContext;
    PDSM_CONTEXT dsmContext = DsmContext;
    PDEVICE_INFO deviceInfo = DsmId;
    
    //
    // Save the DeviceInfo as being the target for this request.
    // Get a timestamp
    // TODO Determine other data.
    //
    completionContext = ExAllocateFromNPagedLookasideList(&dsmContext->ContextList);
    if (completionContext == NULL) {

        //
        // LOG
        //
    }

    //
    // Time stamp this.
    //
    KeQueryTickCount(&completionContext->TickCount);

    //
    // Indicate the target for this request.
    //
    completionContext->DeviceInfo = deviceInfo;
    completionContext->DsmContext = DsmContext;

    //
    // Indicate one more request on this device.
    // LB may use this.
    //
    InterlockedIncrement(&deviceInfo->Requests);
    
    DsmCompletion->DsmCompletionRoutine = HPCompletion;
    DsmCompletion->DsmContext = completionContext;
    return;
}


ULONG
HPInterpretError(
    IN PVOID DsmContext,
    IN PVOID DsmId,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT NTSTATUS *Status,
    OUT PBOOLEAN Retry
    )
{
    ULONG errorMask = 0;
    BOOLEAN failover = FALSE;
    BOOLEAN retry = FALSE;
    BOOLEAN handled = FALSE;
    
    //
    // Check the NT Status first.
    // Several are clearly failover conditions.
    //
     switch (*Status) {
        case STATUS_DEVICE_NOT_CONNECTED:
        case STATUS_DEVICE_DOES_NOT_EXIST:
        case STATUS_NO_SUCH_DEVICE:

            //
            // The port pdo has either been removed or is 
            // very broken. A fail-over is necessary.
            //
            handled = TRUE;
            failover = TRUE;
            break;
            
        default:
            break;
    }            

    if (handled == FALSE) {

        if (Srb) {

            //
            // The ntstatus didn't indicate a fail-over condition, but
            // check various srb status for failover-class error.
            //
            switch (Srb->SrbStatus) {
                case SRB_STATUS_SELECTION_TIMEOUT:
                case SRB_STATUS_INVALID_LUN:
                case SRB_STATUS_INVALID_TARGET_ID:
                case SRB_STATUS_NO_DEVICE:
                case SRB_STATUS_NO_HBA:
                case SRB_STATUS_INVALID_PATH_ID:

                    //
                    // All of these are fatal.
                    //
                    failover = TRUE;
                    break;
                default:
                    break;

            }
        }
    }
    if (failover) {
        DebugPrint((0,
                    "InterpretError: Marking Fatal. Srb (%x). *Status (%x)\n",
                    Srb,
                    *Status));
        errorMask = DSM_FATAL_ERROR;
    }

    //
    // TODO: Gather a list of status that indicate a retry is necessary.
    // Look at InterpretSenseInfo.
    //
    *Retry = retry;
    return errorMask;
}


NTSTATUS
HPUnload(
    IN PVOID DsmContext
    )
{

    //
    // It's the responsibility of the mpio bus driver to have already
    // destroyed all devices and paths.
    // As those functions free allocations for the objects, the only thing
    // needed here is to free the DsmContext.
    //
    ExFreePool(DsmContext);
    return STATUS_SUCCESS;
}

//
// Utility functions.
//

NTSTATUS
HPSendDirectCommand(			
    IN PDEVICE_OBJECT DeviceObject,
    IN PUCHAR Buffer,
    IN ULONG BufferSize,
    IN UCHAR Opcode
    )
{
    PSCSI_PASS_THROUGH_DIRECT passThrough;
    ULONG length;
    NTSTATUS status;
    PCDB cdb;
    IO_STATUS_BLOCK ioStatus;

    DsmSendTUR(DeviceObject);

    //
    // Allocate the pass through plus sense info buffer.
    // 
    length = sizeof(SCSI_PASS_THROUGH_DIRECT) + sizeof(SENSE_DATA);
    passThrough = ExAllocatePool(NonPagedPool, 
                                 length);
    if (passThrough == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    RtlZeroMemory(passThrough, length);
    
    //
    // These are always 10-byte CDB, guess on the timeout.
    // Buffer is allocated by the caller and is it's responsibility to be correctly
    // sized and aligned.
    //
    passThrough->Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
    passThrough->CdbLength = 10;
    passThrough->SenseInfoLength = sizeof(SENSE_DATA);
    passThrough->DataIn = 1;
    passThrough->DataTransferLength = BufferSize;
    passThrough->TimeOutValue = 20;
    passThrough->DataBuffer = Buffer;
    passThrough->SenseInfoOffset = sizeof(SCSI_PASS_THROUGH_DIRECT);
   
    cdb = (PCDB)passThrough->Cdb;

    //
    // These are always 0x20.
    // 
    cdb->CDB10.OperationCode = 0x20;

    //
    // The sub-code (DCMD OpCode) 
    // 
    cdb->CDB10.LogicalBlockByte0 = Opcode;

    //
    // Allocation length.
    //
    cdb->CDB10.TransferBlocksLsb = (UCHAR)(BufferSize & 0xFF);
    cdb->CDB10.TransferBlocksMsb = (UCHAR)(BufferSize >> 8);

    //
    // Submit the command.
    //
    DsmSendDeviceIoControlSynchronous(IOCTL_SCSI_PASS_THROUGH_DIRECT,
                                      DeviceObject,
                                      passThrough,
                                      passThrough,
                                      length,
                                      length,
                                      FALSE,
                                      &ioStatus);

    status = ioStatus.Status;

//    status = DsmSendPassThroughDirect(DeviceObject,
//                                      passThrough,
//                                      length,
//                                      BufferSize);
    if (!NT_SUCCESS(status)) {

        //
        // The call above has already 'interpreted' the senseInfo, but check
        // to see if it is correct.
        // 
        if (Opcode == 0x5) {

            //
            // No error conditions reported with this command, so trust the interpretation.
            //
            // 
        }
    }

    if (passThrough->ScsiStatus) {
        DebugPrint((0,
                    "SendDirect: ScsiStatus (%x)\n",
                    passThrough->ScsiStatus));
    }
    ExFreePool(passThrough);
    return status;
}


NTSTATUS
HPSendScsiCommand(			
    IN PDEVICE_OBJECT DeviceObject,
    IN PUCHAR Buffer,
    IN ULONG BufferSize,
    IN ULONG CdbLength,
    IN PCDB Cdb,
    IN BOOLEAN DataIn
    )
{
    PSCSI_PASS_THROUGH_DIRECT passThrough;
    ULONG length;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;

    //
    // Allocate the pass through plus sense info buffer.
    // 
    length = sizeof(SCSI_PASS_THROUGH_DIRECT) + sizeof(SENSE_DATA);
    passThrough = ExAllocatePool(NonPagedPool, 
                                 length);
    if (passThrough == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    RtlZeroMemory(passThrough, length);
    
    //
    // These are always 10-byte CDB, guess on the timeout.
    // Buffer is allocated by the caller and is it's responsibility to be correctly
    // sized and aligned.
    //
    passThrough->Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
    passThrough->CdbLength = (UCHAR)CdbLength;
    passThrough->SenseInfoLength = sizeof(SENSE_DATA);
    passThrough->DataIn = DataIn;
    passThrough->DataTransferLength = BufferSize;
    passThrough->TimeOutValue = 20;
    passThrough->DataBuffer = Buffer;
    passThrough->SenseInfoOffset = sizeof(SCSI_PASS_THROUGH_DIRECT);
   
    RtlCopyMemory(passThrough->Cdb,
                  Cdb,
                  CdbLength);

    //
    // Submit the command.
    //
    DsmSendDeviceIoControlSynchronous(IOCTL_SCSI_PASS_THROUGH_DIRECT,
                                      DeviceObject,
                                      passThrough,
                                      passThrough,
                                      length,
                                      length,
                                      FALSE,
                                      &ioStatus);

    status = ioStatus.Status;

//    status = DsmSendPassThroughDirect(DeviceObject,
//                                      passThrough,
//                                      length,
//                                      BufferSize);
    return status;
}


PGROUP_ENTRY
FindDevice(
    IN PDSM_CONTEXT DsmContext,
    IN PDEVICE_INFO DeviceInfo
    )
{
    PDEVICE_INFO deviceInfo;
    PLIST_ENTRY entry;
    ULONG i;

    //
    // Run through the DeviceInfo List
    //
    entry = DsmContext->DeviceList.Flink;
    for (i = 0; i < DsmContext->NumberDevices; i++, entry = entry->Flink) {

        //
        // Extract the deviceInfo structure.
        // 
        deviceInfo = CONTAINING_RECORD(entry, DEVICE_INFO, ListEntry);
        ASSERT(deviceInfo);

        //
        // Call the Serial Number compare routine.
        //
        if (HPCompareDevices(DsmContext,
                             DeviceInfo,
                             deviceInfo)) {
    

            return deviceInfo->Group;
        }
    }
   
    DebugPrint((0,
                  "DsmFindDevice: DsmContext (%x), DeviceInfo (%x)\n",
                  DsmContext,
                  DeviceInfo));
    return NULL;
}



PGROUP_ENTRY
BuildGroupEntry(
    IN PDSM_CONTEXT DsmContext,
    IN PDEVICE_INFO DeviceInfo
    )
{
    PGROUP_ENTRY group;

    //
    // Allocate the memory for the multi-path group.
    // 
    group = ExAllocatePool(NonPagedPool, sizeof(GROUP_ENTRY));
    if (group == NULL) {
        return NULL;
    }

    RtlZeroMemory(group, sizeof(GROUP_ENTRY));
    
    //
    // Add it to the list of multi-path groups.
    //
    ExInterlockedInsertTailList(&DsmContext->GroupList,
                              &group->ListEntry,
                              &DsmContext->SpinLock);

    group->GroupNumber = InterlockedIncrement(&DsmContext->NumberGroups);

    ASSERT(group->GroupNumber >= 1);
    return group;
}


NTSTATUS
AddDeviceEntry(
    IN PDSM_CONTEXT DsmContext,
    IN PGROUP_ENTRY Group,
    IN PDEVICE_INFO DeviceInfo,
    IN ULONG DeviceState 
    )
{
    ULONG numberDevices;
    ULONG i;
    KIRQL irql;
    
    //
    // Ensure that this is a valid config - namely, it hasn't
    // exceeded the number of paths supported.
    // 
    numberDevices = Group->NumberDevices;
    if (numberDevices >= MAX_PATHS) {
        return STATUS_UNSUCCESSFUL;
    }
    
    KeAcquireSpinLock(&DsmContext->SpinLock, &irql);
    
#if DBG

    //
    // Ensure that this isn't a second copy of the same pdo.
    //
    for (i = 0; i < numberDevices; i++) {
        if (Group->DeviceList[i]->PortPdo == DeviceInfo->PortPdo) {
            DebugPrint((0,
                          "DsmAddDeviceEntry: Received same PDO twice\n"));
            DbgBreakPoint();
        }
    }
    
#endif    
    //
    // Indicate one device is present in
    // this group.
    // 
    Group->DeviceList[numberDevices] = DeviceInfo;

    //
    // Indicate one more in the list.
    // 
    Group->NumberDevices++;

    //
    // Set-up this device's group id.
    //
    DeviceInfo->Group = Group;

    //
    // Set-up whether this is an active/passive member of the
    // group.
    //
    DeviceInfo->State = DeviceState;
   
    //
    // One more deviceInfo entry.
    //
    DsmContext->NumberDevices++;
    
    //
    // Finally, add it to the global list of devices.
    //
    InsertTailList(&DsmContext->DeviceList,
                   &DeviceInfo->ListEntry);

    KeReleaseSpinLock(&DsmContext->SpinLock, irql);
    
    return STATUS_SUCCESS;
}


VOID
RemoveDeviceEntry(
    IN PDSM_CONTEXT DsmContext,
    IN PGROUP_ENTRY Group,
    IN PDEVICE_INFO DeviceInfo
    )
{
    KIRQL irql;
    NTSTATUS status;
    ULONG i;
    ULONG j;
    BOOLEAN freeGroup = FALSE;

    KeAcquireSpinLock(&DsmContext->SpinLock, &irql);

    //
    // Find it's offset in the array of devices.
    // 
    for (i = 0; i < Group->NumberDevices; i++) {
        
        if (Group->DeviceList[i] == DeviceInfo) {

            //
            // Zero out it's entry.
            // 
            Group->DeviceList[i] = NULL;

            //
            // Reduce the number in the group.
            //
            Group->NumberDevices--;

            //
            // Collapse the array.
            //
            // BUGBUG: If any requests come in during this time, it's
            // possible to either bugcheck or get an incorrect deviceInfo
            // structure.
            // 
            for (j = i; j < Group->NumberDevices; j++) {

                //
                // Shuffle all entries down to fill the hole.
                //
                Group->DeviceList[j] = Group->DeviceList[j + 1];
            }
           
            //
            // Zero out the last one.
            //
            Group->DeviceList[j] = NULL;
            break;
        }
    }

    //
    // See if anything is left in the Group.
    // 
    if (Group->NumberDevices == 0) {

        //
        // Yank it from the Group list.
        //
        RemoveEntryList(&Group->ListEntry);
        DsmContext->NumberGroups--;

        //
        // Zero it.
        //
        RtlZeroMemory(Group,
                      sizeof(GROUP_ENTRY));
        
        freeGroup = TRUE;
    }

    //
    // Yank the device out of the Global list.
    //
    RemoveEntryList(&DeviceInfo->ListEntry);
    DsmContext->NumberDevices--;
    
    //
    // Zero it.
    //
    RtlZeroMemory(DeviceInfo,
                  sizeof(DEVICE_INFO));

    KeReleaseSpinLock(&DsmContext->SpinLock, irql);
    
    //
    // Free the allocation.
    //
    ExFreePool(DeviceInfo);

    if (freeGroup) {

        //
        // Free the allocation.
        //
        ExFreePool(Group);
    }
}



PFAILOVER_GROUP
FindFOGroup(
    IN PDSM_CONTEXT DsmContext,
    IN PVOID PathId
    )
{
    PFAILOVER_GROUP failOverGroup;
    PLIST_ENTRY entry;
    ULONG i;

    //
    // Run through the list of Fail-Over Groups
    //
    entry = DsmContext->FailGroupList.Flink;
    for (i = 0; i < DsmContext->NumberFOGroups; i++, entry = entry->Flink) {

        //
        // Extract the fail-over group structure.
        // 
        failOverGroup = CONTAINING_RECORD(entry, FAILOVER_GROUP, ListEntry);
        ASSERT(failOverGroup);

        //
        // Check for a match of the PathId.
        //
        if (failOverGroup->PathId == PathId) {
            return failOverGroup;
        }
    }
    
    return NULL;
}


PFAILOVER_GROUP
BuildFOGroup(
    IN PDSM_CONTEXT DsmContext,
    IN PDEVICE_INFO DeviceInfo,
    IN PVOID PathId
    )
{
    PFAILOVER_GROUP failOverGroup;
    KIRQL irql;
    ULONG numberGroups;
    
    //
    // Allocate an entry.
    // 
    failOverGroup = ExAllocatePool(NonPagedPool, sizeof(FAILOVER_GROUP));
    if (failOverGroup == NULL) {
        return NULL; 
    }

    RtlZeroMemory(failOverGroup, sizeof(FAILOVER_GROUP));

    KeAcquireSpinLock(&DsmContext->SpinLock, &irql);

    //
    // Get the current number of groups, and add the one that's
    // being created.
    //
    numberGroups = DsmContext->NumberFOGroups++;
    
    //
    // Set the PathId - All devices on the same PathId will
    // failover together.
    //
    failOverGroup->PathId = PathId;
   
    //
    // Set the initial state to NORMAL.
    //
    failOverGroup->State = FG_NORMAL;

    //
    // Add it to the global list.
    //
    InsertTailList(&DsmContext->FailGroupList,
                   &failOverGroup->ListEntry);

    KeReleaseSpinLock(&DsmContext->SpinLock, irql);

    return failOverGroup;
                   
}    


NTSTATUS
UpdateFOGroup(
    IN PDSM_CONTEXT DsmContext,
    IN PFAILOVER_GROUP FailGroup,
    IN PDEVICE_INFO DeviceInfo
    )
{
    PGROUP_ENTRY group;
    ULONG count;
    KIRQL irql;

    KeAcquireSpinLock(&DsmContext->SpinLock, &irql);
    
    //
    // Add the device to the list of devices that are on this path.
    //
    count = FailGroup->Count++;
    FailGroup->DeviceList[count] = DeviceInfo;

    //
    // Get the MultiPath group for this device.
    //
    group = DeviceInfo->Group;

    //
    // Indicate that the L.B. policy needs to be updated. 
    // The next call to LBGetPath will cause the re-shuffle to
    // take place.
    // 
    group->LoadBalanceInit = FALSE;
    DeviceInfo->NeedsVerification = TRUE;

    //
    // Set the device's F.O. Group.
    //
    DeviceInfo->FailGroup = FailGroup;
    
    KeReleaseSpinLock(&DsmContext->SpinLock, irql);

    return STATUS_SUCCESS;
}    


VOID
RemoveDeviceFailGroup(
    IN PDSM_CONTEXT DsmContext,
    IN PFAILOVER_GROUP FailGroup,
    IN PDEVICE_INFO DeviceInfo
    )
{
    ULONG count;
    KIRQL irql;
    ULONG i;
    ULONG j;

    KeAcquireSpinLock(&DsmContext->SpinLock, &irql);
    
    //
    // Find it's offset in the array of devices.
    // 
    for (i = 0; i < FailGroup->Count; i++) {

        if (FailGroup->DeviceList[i] == DeviceInfo) {

            //
            // Zero out it's entry.
            // 
            FailGroup->DeviceList[i] = NULL;

            //
            // Reduce the number in the group.
            //
            FailGroup->Count--;

            //
            // Collapse the array.
            //
            for (j = i; j < FailGroup->Count; j++) {

                //
                // Shuffle all entries down to fill the hole.
                //
                FailGroup->DeviceList[j] = FailGroup->DeviceList[j + 1];
            }
           
            //
            // Zero out the last one.
            //
            FailGroup->DeviceList[j] = NULL;
            break;
        }
    }

    KeReleaseSpinLock(&DsmContext->SpinLock, irql);
    return;
}    



PFAILOVER_GROUP
SetNewPath(
    IN PDSM_CONTEXT DsmContext,
    IN PGROUP_ENTRY Group,
    IN PDEVICE_INFO FailingDevice,
    IN PFAILOVER_GROUP SelectedPath
    )
{
    PFAILOVER_GROUP failGroup;
    PGROUP_ENTRY group;
    PDEVICE_INFO device;
    ULONG i;
    NTSTATUS status;
    BOOLEAN matched = FALSE;

    if (SelectedPath) {

        //
        // This indicates that a new path has already been selected
        // for at least one device in the Fail-Over Group.
        // Run the list of new devices and find the matching
        // multi-path group.
        //
        for (i = 0; i < SelectedPath->Count; i++) {

            //
            // Get the device from the newly selected Path.
            // 
            device = SelectedPath->DeviceList[i];

            //
            // Determine if the device's group matches the failing
            // device's group.
            // 
            if (device->Group == Group) {

                //
                // The new device should be either ACTIVE or PASSIVE
                //
                if ((device->State == DEV_ACTIVE) ||
                    (device->State == DEV_PASSIVE)) {

                    //
                    // Set it to ACTIVE.
                    //
                    device->State = DEV_ACTIVE;

                    //
                    // Ensure that it's ready.
                    //
                    status = DsmSendTUR(device->TargetObject);
                    ASSERT(status == STATUS_SUCCESS);
                    
                    matched = TRUE;
                    break;
                }
            }
        }

        //
        // When the first call was made and a path selected, all devices
        // on the path were checked for validity.
        // 
        ASSERT(matched == TRUE);

        //
        // Just return the SelectedPath
        //
        failGroup = SelectedPath;
        
    } else {
        
        //
        // Go through Group, looking for an available device.
        //
        for (i = 0; i < Group->NumberDevices; i++) {
            
            //
            // Look for any that are Passive. They are the best
            // choice. This would indicate either an ActiveN/PassiveN arrangement.
            //
            device = Group->DeviceList[i];
            if (device->State == DEV_PASSIVE) {
                matched = TRUE;
                break;
            }
        }
        
        if (matched) {

            //
            // Mark the device as active.
            //
            device->State = DEV_ACTIVE;

            //
            // Ensure that it's ready.
            //
            status = DsmSendTUR(device->TargetObject);
            ASSERT(status == STATUS_SUCCESS);

            // 
            // Get the Fail-Over group from the selected device.
            //
            failGroup = device->FailGroup;
            
        } else {

            //
            // No passive devices. This indicates either an Active/Active arrangement,
            // or everything is failed.
            // Look for active devices.
            //
            for (i = 0; i < Group->NumberDevices; i++) {
                
                device = Group->DeviceList[i];
                if (device->State == DEV_ACTIVE) {
                    matched = TRUE;
                    break;
                }
            }
            if (matched) {
                
                //
                // The device is already active, just return the
                // new path info.
                //
                failGroup = device->FailGroup;
                
            } else {

                //
                // Everything has failed. Should try to do something?? TODO
                //
                failGroup = NULL;
            }    
        }       

        if (failGroup) {

            //
            // Run through all the devices to ensure that they are
            // in a reasonable state.
            //
            for (i = 0; i < failGroup->Count; i++) {
                device = failGroup->DeviceList[i];
                if ((device->State != DEV_ACTIVE) &&
                    (device->State != DEV_PASSIVE)) {

                    //
                    // Really need to find a new fail-over group.
                    // TODO.
                    // This isn't necessarily a valid assert. If static lb is in
                    // effect and this is one of the first to fail-over, others
                    // could be considered bad.
                    //
                    ASSERT(device->State == DEV_ACTIVE);
                }
            }
        }
    }        
    return failGroup;
}


VOID
LBInit(
    IN PDSM_CONTEXT DsmContext,
    IN PGROUP_ENTRY Group
    )
{
    PFAILOVER_GROUP failGroup;
    PDEVICE_INFO device;
    PLIST_ENTRY entry;
    ULONG numberPaths;
    ULONG assignedPath;
    ULONG i;
    BOOLEAN found;
   
    //
    // TODO: Once the Wmi support is here, this will be configurable
    // Need to add code to handle each of the different policies.
    //
    //
    // Doing 'static' LB. Out of each Multi-Path Group, one
    // device will be active and assigned to a particular path.
    // The assignment is based on the group ordinal modulus the total
    // number of paths.
    //
    numberPaths = DsmContext->NumberFOGroups;
    assignedPath = Group->GroupNumber % numberPaths;

    DebugPrint((0,
                  "DsmLBInit: NumberFOGs (%x), Group Number (%x), assignedPath (%x)\n",
                  DsmContext->NumberFOGroups,
                  Group->GroupNumber,
                  assignedPath));
    
    //
    // Get the Fail-Over Group with the correct path.
    //
    i = 0;
    found = FALSE;
    
    //
    // Get the first entry.
    // 
    entry = DsmContext->FailGroupList.Flink;
    
    do {

        //
        // Extract the F.O. Group entry.
        // 
        failGroup = CONTAINING_RECORD(entry, FAILOVER_GROUP, ListEntry);
        ASSERT(failGroup);

        DebugPrint((0,
                      "DsmLBInit: Trying %x. at (%x) of (%x)\n",
                      failGroup,
                      i,
                      assignedPath));
        
        if (i == assignedPath) {

            //
            // This is the one.
            //
            found = TRUE;
            
        } else {

            //
            // Advance to the next entry.
            //
            entry = entry->Flink;
            i++;
        }       
        //
        // BUGBUG: Need to terminate this loop based on #of FG's.
        //
    } while (found == FALSE);        
   
    DebugPrint((0,
                  "DsmLBInit: Using FOG (%x)\n",
                  failGroup));
    
    //
    // It may occur that though there are multiple paths/groups, not
    // all devices have been put into the DeviceList.
    // If there is only 1, special case this. It will get fixed up
    // when the second device arrives.
    //
    if (Group->NumberDevices == 1) {

        //
        // LOG. Indicates something "might" be wrong - definitely
        // not multi-pathing this device, so could lead to disaster
        // 
        //
        // Grab device 0 and set it active.
        //
        device = Group->DeviceList[0];
        device->State = DEV_ACTIVE;
    
        //
        // Go ahead state that this is init'ed. If/when another
        // device shows up, we will re-do this.
        //
        Group->LoadBalanceInit = TRUE;
        Group->LoadBalanceType = LB_STATIC;
       
        DebugPrint((0,
                     "DsmLBInit: Only One Device (%x) currently in group. Setting it Active\n",
                     device));
        return;
    }
    
    //
    // Find the device with the same F.O. Group
    // in the mulit-path group.
    //
    for (i = 0; i < Group->NumberDevices; i++) {
        
        //
        // Get the device info.
        //
        device = Group->DeviceList[i];

        //
        // See if there is a match.
        // 
        if (device->FailGroup == failGroup) {
            
            //
            // Set the device to active.
            //
            device->State = DEV_ACTIVE;

            DebugPrint((0,
                          "DsmLBInit: Marking (%x) as active device\n",
                          device));

            //
            // Done setting up this multi-path group.
            // Indicate that it's so, and that we are using
            // STATIC Load-Balancing.
            //
            Group->LoadBalanceInit = TRUE;
            Group->LoadBalanceType = LB_STATIC;
            return;
        } else {

            DebugPrint((0,
                         "DsmLBInit: Marking (%x) as stand-by device\n",
                         device));
            device->State = DEV_PASSIVE;
        }    
    }
}



VOID
DsmDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for the DSM

Arguments:

Return Value:

    None

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= HPDSMDebug) {

        _vsnprintf(DebugBuffer, DEBUG_BUFFER_LENGTH, DebugMessage, ap);

        DbgPrint(DebugBuffer);
    }

    va_end(ap);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\hpdsm\hpdsm.h ===
#ifndef _HP_DSM_H_
#define _HP_DSM_H_

#include <ntddscsi.h>
#include <scsi.h>
#include "dsm.h"

//
// Set an arbitrary limit of 4 paths.
//
#define MAX_PATHS 4

//
// Device State defines.
//
#define DEV_ACTIVE      0x00000001
#define DEV_PASSIVE     0x00000002
#define DEV_FAILED      0x00000003

//
// Multi-path Group State
//
//
// Fail-Over Group State
//
#define FG_NORMAL   0x00000001
#define FG_PENDING  0x00000002
#define FG_FAILBACK 0x00000003
#define FG_FAILED   0x00000004

//
// Load-Balance Types
//
#define LB_ACTIVE_PASSIVE 0x01
#define LB_STATIC         0x02
#define LB_MIN_QUEUE      0x03
#define LB_ROUNDROBIN     0x04

//
// Internal structures.
//
//
// Statistics structure. Used by the device
// and path routines.
//
typedef struct _DSM_STATS {
    ULONG NumberReads;
    LARGE_INTEGER BytesRead;
    ULONG NumberWrites;
    LARGE_INTEGER BytesWritten;
} DSM_STATS, *PDSM_STATS;

//
// Dsm Context is the global driver
// context that gets pushed to each of
// the dsm entry points.
// 
typedef struct _DSM_CONTEXT {
    KSPIN_LOCK SpinLock;
    ULONG NumberDevices;
    ULONG NumberGroups;
    ULONG NumberFOGroups;
    LIST_ENTRY DeviceList;
    LIST_ENTRY GroupList;
    LIST_ENTRY FailGroupList;
    PVOID MPIOContext;
    NPAGED_LOOKASIDE_LIST ContextList;
} DSM_CONTEXT, *PDSM_CONTEXT;

typedef struct _GROUP_ENTRY;
typedef struct _FAILOVER_GROUP;

//
// Information about each device that's
// supported.
// 
typedef struct _DEVICE_INFO {
    LIST_ENTRY ListEntry;
    PVOID DsmContext;
    PDEVICE_OBJECT PortPdo;
    PDEVICE_OBJECT TargetObject;
    struct _GROUP_ENTRY *Group;
    struct _FAILOVER_GROUP *FailGroup;
    ULONG State;
    ULONG Controller;
    BOOLEAN NeedsVerification;
    UCHAR Reserved[3];
    LONG Requests;
    DSM_STATS Stats;
    UCHAR SerialNumber[20];
    STORAGE_DEVICE_DESCRIPTOR Descriptor;
} DEVICE_INFO, *PDEVICE_INFO;

//
// Information about multi-path groups:
// The same device found via multiple paths.
//
typedef struct _GROUP_ENTRY {
    LIST_ENTRY ListEntry;
    ULONG GroupNumber;
    BOOLEAN LoadBalanceInit;
    UCHAR LoadBalanceType;
    UCHAR Reserved[2];
    ULONG NumberDevices;
    PDEVICE_INFO DeviceList[MAX_PATHS];
} GROUP_ENTRY, *PGROUP_ENTRY;

//
// The collection of devices on one path.
// These fail-over as a unit.
//
typedef struct _FAILOVER_GROUP {
    LIST_ENTRY ListEntry;
    PVOID PathId;
    ULONG State;
    ULONG Count;

    //
    // BUGBUG: Revisit using an array
    //
    PDEVICE_INFO DeviceList[32];
} FAILOVER_GROUP, *PFAILOVER_GROUP;

//
// Completion context structure.
//
typedef struct _COMPLETION_CONTEXT {
    LARGE_INTEGER TickCount;
    PDEVICE_INFO DeviceInfo;
    PDSM_CONTEXT DsmContext;
} COMPLETION_CONTEXT, *PCOMPLETION_CONTEXT;

//
// Direct-Commands
//
#pragma pack(1)

typedef struct _HP_ENQUIRY {
    UCHAR NumberSysDrives;
    UCHAR SDFlags;
    UCHAR EventChangeCounter;
    UCHAR Reserved;
    UCHAR DriveSizes[32];
    UCHAR ROMProgCount[2];
    UCHAR StatusFlag;
    UCHAR FreeStateChangeCount;
    UCHAR FwMinorRev;
    UCHAR FwMajorRev;
    UCHAR Fill[56];
} HP_ENQUIRY, *PHP_ENQUIRY;

typedef struct _HP_DAC_STATUS {
    UCHAR Format;
    UCHAR LUN;
    UCHAR SysDrive;
    UCHAR InformationLength;
    UCHAR MasterSlaveState[4];
    UCHAR MSAdditionalInfo[4];
    UCHAR PartnerStatus[4];
    UCHAR DACInfo[4];
} HP_DAC_STATUS, *PHP_DAC_STATUS;    

#pragma pack()

#define DCMD_ENQUIRY        0x05
#define DCMD_GET_DAC_STATUS 0x55

NTSTATUS
HPSendDirectCommand(			
    IN PDEVICE_OBJECT DeviceObject,
    IN PUCHAR Buffer,
    IN ULONG BufferSize,
    IN UCHAR Opcode
    );

NTSTATUS
HPSendScsiCommand(			
    IN PDEVICE_OBJECT DeviceObject,
    IN PUCHAR Buffer,
    IN ULONG BufferSize,
    IN ULONG CdbLength,
    IN PCDB Cdb,
    IN BOOLEAN DataIn
    );
//
// Export functions.
// 
NTSTATUS
HPInquire (
    IN PVOID DsmContext,
    IN PDEVICE_OBJECT TargetDevice,
    IN PDEVICE_OBJECT PortObject,
    IN PSTORAGE_DEVICE_DESCRIPTOR Descriptor,
    IN PSTORAGE_DEVICE_ID_DESCRIPTOR DeviceIdList,
    OUT PVOID *DsmIdentifier
    );

BOOLEAN
HPCompareDevices(
    IN PVOID DsmContext,
    IN PVOID DsmId1,
    IN PVOID DsmId2
    );

NTSTATUS
HPSetDeviceInfo(
    IN PVOID DsmContext,
    IN PDEVICE_OBJECT TargetObject,
    IN PVOID DsmId,
    IN OUT PVOID *PathId
    );

NTSTATUS
HPGetControllerInfo(
    IN PVOID DsmContext,
    IN PVOID DsmId,
    IN ULONG Flags,
    IN OUT PCONTROLLER_INFO *ControllerInfo
    );

BOOLEAN
HPIsPathActive(
    IN PVOID DsmContext,
    IN PVOID PathId
    );

NTSTATUS
HPPathVerify(
    IN PVOID DsmContext,                       
    IN PVOID DsmId,
    IN PVOID PathId
    );

NTSTATUS
HPInvalidatePath(
    IN PVOID DsmContext,
    IN ULONG ErrorMask,
    IN PVOID PathId,
    IN OUT PVOID *NewPathId
    );

NTSTATUS
HPRemoveDevice(
    IN PVOID DsmContext,
    IN PVOID DsmId,
    IN PVOID PathId
    );

NTSTATUS
HPRemovePath(
    IN PDSM_CONTEXT DsmContext,
    IN PVOID PathId
    );

NTSTATUS
HPBringPathOnLine(
    IN PVOID DsmContext,
    IN PVOID PathId,
    OUT PULONG DSMError
    );

PVOID
HPLBGetPath(
    IN PVOID DsmContext,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PDSM_IDS DsmList,
    IN PVOID CurrentPath,
    OUT NTSTATUS *Status
    );

ULONG
HPCategorizeRequest(
    IN PVOID DsmContext,
    IN PDSM_IDS DsmIds,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID CurrentPath,
    OUT PVOID *PathId,
    OUT NTSTATUS *Status
    );

NTSTATUS
HPBroadcastRequest(
    IN PVOID DsmContext,
    IN PDSM_IDS DsmIds,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PKEVENT Event
    );

NTSTATUS
HPSrbDeviceControl(
    IN PVOID DsmContext,
    IN PDSM_IDS DsmIds,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PKEVENT Event
    );

VOID
HPSetCompletion(
    IN PVOID DsmContext,
    IN PVOID DsmId,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PDSM_COMPLETION_INFO DsmCompletion
    );

ULONG
HPInterpretError(
    IN PVOID DsmContext,
    IN PVOID DsmId,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT NTSTATUS *Status,
    OUT PBOOLEAN Retry
    );

NTSTATUS
HPUnload(
    IN PVOID DsmContext
    );

//
// Various utility functions.
//
PGROUP_ENTRY
FindDevice(
    IN PDSM_CONTEXT DsmContext,
    IN PDEVICE_INFO DeviceInfo
    );

PGROUP_ENTRY
BuildGroupEntry (
    IN PDSM_CONTEXT DsmContext,
    IN PDEVICE_INFO deviceInfo
    );

NTSTATUS
AddGroupEntry(
    IN PDSM_CONTEXT DsmContext,
    IN PGROUP_ENTRY Group
    );

NTSTATUS
AddDeviceEntry(
    IN PDSM_CONTEXT DsmContext,
    IN PGROUP_ENTRY Group,
    IN PDEVICE_INFO DeviceInfo,
    IN ULONG DeviceState
    );

VOID
RemoveDeviceEntry(
    IN PDSM_CONTEXT DsmContext,
    IN PGROUP_ENTRY Group,
    IN PDEVICE_INFO DeviceInfo
    );

PFAILOVER_GROUP
FindFOGroup(
    IN PDSM_CONTEXT DsmContext,
    IN PVOID PathId
    );

PFAILOVER_GROUP
BuildFOGroup(
    IN PDSM_CONTEXT DsmContext,
    IN PDEVICE_INFO DeviceInfo,
    IN PVOID PathId
    );

NTSTATUS
UpdateFOGroup(
    IN PDSM_CONTEXT DsmContext,
    IN PFAILOVER_GROUP FailGroup,
    IN PDEVICE_INFO DeviceInfo
    );

VOID
RemoveDeviceFailGroup(
    IN PDSM_CONTEXT DsmContext,
    IN PFAILOVER_GROUP FailGroup,
    IN PDEVICE_INFO DeviceInfo
    );

PFAILOVER_GROUP
SetNewPath(
    IN PDSM_CONTEXT DsmContext,
    IN PGROUP_ENTRY Group,
    IN PDEVICE_INFO FailingDevice,
    IN PFAILOVER_GROUP SelectedPath
    );

VOID
LBInit(
    IN PDSM_CONTEXT DsmContext,
    IN PGROUP_ENTRY Group
    );


VOID
HPConvertHexToAscii(
    IN PUCHAR HexString,
    IN OUT PUCHAR AsciiString,
    IN ULONG Count
    );


#define DEBUG_BUFFER_LENGTH 255
UCHAR DebugBuffer[DEBUG_BUFFER_LENGTH + 1];
ULONG HPDSMDebug = 1;
VOID
DsmDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );
#ifdef DebugPrint
#undef DebugPrint
#define DebugPrint(x) DsmDebugPrint x
#endif
#endif // _HP_DSM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\include\mpspf.h ===
#ifndef _MPSPF_H_
#define _MPSPF_H_


#define MULTIPATH_CONTROL ((ULONG) 'mp')

//
// SP Filter's registration IOCTL.
// 
//
#define IOCTL_MPADAPTER_REGISTER CTL_CODE (MULTIPATH_CONTROL, 0x01, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Input structure for DEVICE_NOTIFICATION
//
typedef struct _ADP_DEVICE_INFO {
    
    //
    // Scsiport's PDO
    //
    PDEVICE_OBJECT DeviceObject;

    //
    // The associated device descriptor.
    //
    PSTORAGE_DEVICE_DESCRIPTOR DeviceDescriptor;

    //
    // The page 0x83 info.
    //
    PSTORAGE_DEVICE_ID_DESCRIPTOR DeviceIdList;

} ADP_DEVICE_INFO, *PADP_DEVICE_INFO;

typedef struct _ADP_DEVICE_LIST {

    //
    // Number of children in list.
    //
    ULONG NumberDevices;

    //
    // Array of child devices.
    //
    ADP_DEVICE_INFO DeviceList[1];

} ADP_DEVICE_LIST, *PADP_DEVICE_LIST;

typedef struct _ADP_ASSOCIATED_DEVICE_INFO {
    PDEVICE_OBJECT DeviceObject;
    UCHAR DeviceType;
} ADP_ASSOCIATED_DEVICE_INFO, *PADP_ASSOCIATED_DEVICE_INFO;

typedef struct _ADP_ASSOCIATED_DEVICES {
    //
    // Number of entries.
    //
    ULONG NumberDevices;

    //
    // Array of device + type
    //
    ADP_ASSOCIATED_DEVICE_INFO DeviceInfo[1];
} ADP_ASSOCIATED_DEVICES, *PADP_ASSOCIATED_DEVICES;

typedef
PADP_ASSOCIATED_DEVICES
(*PFLTR_DEVICE_LIST) (
    IN PDEVICE_OBJECT FilterObject
    );

typedef
NTSTATUS
(*PADP_POWER_NOTIFICATION) (
    IN PDEVICE_OBJECT ControlObject,
    IN PDEVICE_OBJECT FilterObject,
    IN PIRP Irp 
    );

typedef
NTSTATUS
(*PADP_PNP_NOTIFICATION) (
    IN PDEVICE_OBJECT ControlObject,
    IN PDEVICE_OBJECT FilterObject,
    IN PIRP Irp
    );

typedef
NTSTATUS
(*PADP_DEVICE_NOTIFICATION) (
    IN PDEVICE_OBJECT ControlObject,
    IN PDEVICE_OBJECT FilterObject,
    IN PDEVICE_OBJECT PortObject,
    IN PADP_DEVICE_LIST DeviceList
    );

typedef struct _ADAPTER_REGISTER {
    PDEVICE_OBJECT FilterObject;
    PDEVICE_OBJECT PortFdo; 
    PFLTR_DEVICE_LIST FltrGetDeviceList;
    PADP_PNP_NOTIFICATION PnPNotify;
    PADP_POWER_NOTIFICATION PowerNotify;
    PADP_DEVICE_NOTIFICATION DeviceNotify;
} ADAPTER_REGISTER, *PADAPTER_REGISTER;    


#endif // _MPSPF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\include\mpdevf.h ===
#ifndef _MP_DEVF_H_
#define _MP_DEVF_H_

#include <initguid.h>


#define MULTIPATH_CONTROL ((ULONG) 'mp')

//
// IOCTLS that the MultiPath driver sends.
//

//
// IOCTLS that the Device Filter sends.
//
#define IOCTL_MPDEV_QUERY_PDO CTL_CODE (MULTIPATH_CONTROL, 0x12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MPDEV_REGISTER  CTL_CODE (MULTIPATH_CONTROL, 0x13, METHOD_BUFFERED, FILE_ANY_ACCESS)


//
// QueryPDO input structure.
//
typedef struct _MPIO_PDO_QUERY {
    PDEVICE_OBJECT DeviceObject;
} MPIO_PDO_QUERY, *PMPIO_PDO_QUERY;

//
// PDO Registration function that the device filter
// will call to set-up side-band comms.
// 
typedef
NTSTATUS
(*PDEV_POWER_NOTIFICATION) (
    IN PDEVICE_OBJECT MPDiskObject,
    IN PDEVICE_OBJECT FilterObject,
    IN PIRP Irp 
    );

typedef
NTSTATUS
(*PDEV_PNP_NOTIFICATION) (
    IN PDEVICE_OBJECT MPDiskObject,
    IN PDEVICE_OBJECT FilterObject,
    IN PIRP Irp
    );

typedef struct _MPIO_PDO_INFO {

    //
    // MP Disk PDO.
    // 
    PDEVICE_OBJECT PdoObject;

    //
    // Routine for Power Irp handling.
    // 
    PDEV_POWER_NOTIFICATION DevicePowerNotify;

    //
    // Routine for PnP Irp handling.
    //
    PDEV_PNP_NOTIFICATION DevicePnPNotify;
} MPIO_PDO_INFO, *PMPIO_PDO_INFO;

typedef
NTSTATUS
(*PDEV_PDO_REGISTRATION)(
    IN PDEVICE_OBJECT MPDiskObject,                         
    IN PDEVICE_OBJECT FilterObject,
    IN PDEVICE_OBJECT LowerDevice,
    IN OUT PMPIO_PDO_INFO PdoInformation
    );

//
// Output structure for the DEV_REGISTRATION IOCTL.
// 
typedef struct _MPIO_REG_INFO {

    //
    // The filter's D.O.
    //
    PDEVICE_OBJECT FilterObject;

    //
    // The target PDO aka Scsiport's PDO.
    //
    PDEVICE_OBJECT LowerDevice;

    //
    // The PDO that corresponds to the real device
    // that the dev. filter is layer over. (ie. the MPDisk)
    // 
    PDEVICE_OBJECT MPDiskObject;

    //
    // A routine to call to register with
    // the MPIO PDO.
    // 
    PDEV_PDO_REGISTRATION DevicePdoRegister;
} MPIO_REG_INFO, *PMPIO_REG_INFO;




#endif // _MP_DEV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\include\dsm.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    dsm.h

Abstract:

    This file defines the interface between Multipath Device-Specific drivers and the
    Main Multipath driver.

Author:

Notes:

Revision History:

--*/

#ifndef _DSM_H_
#define _DSM_H_

#include <ntddk.h>
#include <scsi.h>
#include <ntddscsi.h>
#include <ntddstor.h>
#include <wmistr.h>
#include <wmiguid.h>
#include <wmilib.h>

//
// List of DSM Identifiers passed to several
// of the dsm entry-points.
// 
typedef struct _DSM_IDS {

    //
    // Number of ID's in the List.
    // 
    ULONG Count;

    //
    // Array of DsmIdentiifiers
    //
    PVOID IdList[1];
} DSM_IDS, *PDSM_IDS;    

//    
// Identification and initialization routines (other than DSM registration with MPCTL.sys)
//
typedef 
NTSTATUS
(*DSM_INQUIRE_DRIVER) (
    IN PVOID DsmContext,
    IN PDEVICE_OBJECT TargetDevice,
    IN PDEVICE_OBJECT PortFdo,
    IN PSTORAGE_DEVICE_DESCRIPTOR Descriptor,
    IN PSTORAGE_DEVICE_ID_DESCRIPTOR DeviceIdList,
    OUT PVOID *DsmIdentifier
    );
/*++

Routine Description:

    This routine is used to determine if TargetDevice belongs to the DSM. 
    If the device is owned by the driver, then DsmIdentifier will be updated with a
    DSM-derived value.

Arguments:

    DsmContext   - Context value given to the multipath driver during registration.
    TargetDevice - DeviceObject for the child device.
    PortFdo      - The Port driver FDO on which TargetDevice resides. 
    Descriptor   - Pointer the device descriptor corresponding to TargetDevice. Rehash of inquiry
                   data, plus serial number information (if applicable).
    DeviceIdList - VPD Page 0x83 information.                   
    DsmIdentifier - Pointer to be filled in by the DSM on success.

Return Value:

    NTSTATUS of the operation. This may be STATUS_SUCCESS even if the disk is not owned by the DSM.

--*/

typedef 
BOOLEAN
(*DSM_COMPARE_DEVICES) (
    IN PVOID DsmContext,
    IN PVOID DsmId1,
    IN PVOID DsmId2
    );
/*++

Routine Description:

    This routine is called to determine if the device ids represent the same underlying
    physical device.
    Additional ids (more than 2) can be tested by repeatedly calling this function.
    It is the DSM responsibility to keep the necessary information to identify the device(s).

Arguments:

    DsmContext - Context value given to the multipath driver during registration.
    DsmId1/2 - Identifers returned from DMS_INQUIRE_DRIVER.

Return Value:

    TRUE if DsmIds correspond to the same underlying device.

--*/

//
// This controller is active.
// 
#define DSM_CONTROLLER_ACTIVE   0x00000001
//
// This controller is a stand-by controller.
// 
#define DSM_CONTROLLER_STANDBY  0x00000002
//
// This controller has failed.
// 
#define DSM_CONTROLLER_FAILED   0x00000003
//
// There are no controllers (JBOD, for example)
// 
#define DSM_CONTROLLER_NO_CNTRL 0x00000004

typedef struct _CONTROLLER_INFO {
    //
    // The device object of the controller.
    // Retrieved by DsmGetAssociatedDevices.
    // 
    PDEVICE_OBJECT DeviceObject;

    //
    // 64-bit identifier. WWN, for example.
    // 
    ULONGLONG ControllerIdentifier;

    //
    // Controller state. See above.
    //
    ULONG State;
} CONTROLLER_INFO, *PCONTROLLER_INFO;

//
// Informs the DSM that ControllerInfo must be allocated.
// 
#define DSM_CNTRL_FLAGS_ALLOCATE    0x00000001

//
// ControllerInfo is valid. The DSM should update 'State'.
//
#define DSM_CNTRL_FLAGS_CHECK_STATE 0x00000002

//
// Possible future expansion.
//
#define DSM_CNTRL_FLAGS_RESERVED   0xFFFFFFFC

typedef 
NTSTATUS
(*DSM_GET_CONTROLLER_INFO) (
    IN PVOID DsmContext,
    IN PVOID DsmId,
    IN ULONG Flags,
    IN OUT PCONTROLLER_INFO *ControllerInfo
    );
/*++

Routine Description:

    This routine is used to get information about the controller that the device 
    corresponding to DsmId in on.
    The Dsm shall allocate the necessary memory for the buffer (mpio has the responsibility
    to free it) and fill in the information.
    If the DSM controls hardware that uses no controllers, set State to NO_CNTRL.
    This information is used mainly by whatever WMI admin. utilities want if.

    This routine will be called initially after SetDeviceInfo, but also to retrieve
    the controller's state when an WMI request is received, after a fail-over/fail-back, etc.

Arguments:

    DsmContext - Context value given to the multipath driver during registration.
    DsmId - Identifer returned from DMS_INQUIRE_DRIVER.
    Flags - Bitfield of modifiers. If ALLOCATE is not set, ControllerInfo will have
            a valid buffer for the DSM to operate on.
    ControllerInfo - Pointer  for  the DSM to place the allocated controller info
                     pertaining to DsmId
    

Return Value:

    NTSTATUS 

--*/


typedef 
NTSTATUS
(*DSM_SET_DEVICE_INFO) (
    IN PVOID DsmContext,
    IN PDEVICE_OBJECT TargetObject,
    IN PVOID DsmId,
    IN OUT PVOID *PathId
    );
/*++

Routine Description:

    This routine associates a returned DsmId to the controlling MPDisk PDO
    the targetObject for DSM-initiated requests, and to a Path (given by PathId).
    The Path ID is a unique per-path value and will be the same value for ALL devices that
    are on the same physical path.

Arguments:

    DsmContext - Context value given to the multipath driver during registration.
    TargetObject - The D.O. to which DSM-initiated requests should be sent.
                   This is the Filter D.O. over the port PDO.
    DsmId - Value returned from DMSInquireDriver.
    PathId - Id that represents the path. The value passed in may be used as is, or the DSM
             optionally can update it if it requires additional state info to be kept.
             

Return Value:

    DSM should return SUCCESS. Other errors may be returned in event of failed
    allocations, etc. These other errors are fatal.

--*/

typedef 
BOOLEAN
(*DSM_IS_PATH_ACTIVE) (
    IN PVOID DsmContext,                       
    IN PVOID PathId
    );
/*++

Routine Description:

    This routine is used to determine whether the path is active (ie. able to handle requests
    without a failover).
    NOTE: This is used by the main module to determine load balance groups. If multiple
    paths are active to the same device then it is considered that requests can be
    submitted freely to ALL active paths, though the DSM is the determinator for path
    selection.

    In addition, after a failover, the path validity will be queried. If the path error 
    was transitory and the DSM feels that the path is good, then this request will be
    re-issued to determine it's ACTIVE/PASSIVE state.

Arguments:

    DsmContext - Context value given to the multipath driver during registration.
    PathId - Value set in SetPathId.

Return Value:

    TRUE - if path is active. Otherwise, FALSE.

--*/



//
// Error Handling, Failover and recovery routines.
//
// When a fatal error occurs, the Path is invalidated and a new one
// selected. 
// After the fail-over is complete, mpctl will invoke the DSM's Recovery routine
// (if one is specified). Once the error has been dealt with, the DSM should notify
// mpctl of the success of the operation.
// PathVerify will be called with each DsmId that was on the path.
// If this is successful, ReenablePath is invoked to allow the DSM any final preperations
// before considering the path normal.
// IsActive is called to build the load-balance associations.
//
#define DSM_FATAL_ERROR          0x80000000
#define DSM_ADMIN_FO             0x40000000
#define DSM_FATAL_ERROR_OEM_MASK 0x0000FFFF
#define DSM_FATAL_ERROR_RESERVED 0x7FFF0000

typedef
ULONG
(*DSM_INTERPRET_ERROR) (
    IN PVOID DsmContext,
    IN PVOID DsmId,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PNTSTATUS Status,
    OUT PBOOLEAN Retry
    );
/*++

Routine Description:

    This routine informs the DSM that Srb has an error indicated with Srb->SrbStatus and/or Status.
    IF Srb->SrbFlags & SRB_FLAGS_AUTOSENSE_VALID is set, sense data will be available.

    The DSM should examine these, carry out any vendor-unique activities and update Retry and Status
    (if applicable). A determination should be made whether these errors constitute a fail over.
    Setting the high-bit of the return value indicates a fatal error. The DSM may additionally
    set any of the bits in the lower USHORT to facilitate information passing between this and
    the InvalidatePath routine.
    The Multipath driver (mpctl) will not override these return values.

Arguments:

    DsmId - Identifers returned from DMS_INQUIRE_DRIVER.
    Srb - The Srb with an error.
    Status - NTSTATUS of the operation. Can be updated.
    Retry - Allows the DSM to indicate whether to retry the IO.

Return Value:

    Setting DSM_FATAL_ERROR indicates a fatal error. DSM-specific info. can be kept in 
    the lower WORD, which will be passed to InvalidatePath.

--*/
 
typedef 
NTSTATUS
(*DSM_INVALIDATE_PATH) (
    IN PVOID DsmContext,
    IN ULONG ErrorMask,
    IN PVOID PathId,
    IN OUT PVOID *NewPathId
    );
/*++

Routine Description:

    This routine invalidates the given path and assigns the devices to the new path. 
    NewPath is set to either an existing path or if all paths are dead, NULL.

    After this call, the DSM can attempt any recovery operations it can. Mpctl will start
    a recovery thread and if the DSM supports it (indication via the init data) will call
    the DSM autorecovery routine. After the timeout specified (in init data) or via 
    DSMNotification, reenable path will be called. If this fails, mpctl will initiate
    teardown of the failed path's stack.

Arguments:

    DsmContext - Context value given to the multipath driver during registration.
    ErrorMask - Value returned from InterpretError.
    PathId - The failing path.
    NewPathId - Pointer to the new path. 

Return Value:

    NTSTATUS of the operation. 

--*/

typedef
NTSTATUS
(*DSM_PATH_VERIFY) (
    IN PVOID DsmContext,                      
    IN PVOID DsmId,
    IN PVOID PathId
    );
/*++

Routine Description:

    This routine is polled at a configurable interval and is used to determine the 
    health of the device indicated by DsmId on PathId. The DSM makes the determination of
    validity using supplied library functions, or by issuing vendor-unique commands.

    After a fail-over condition has been dealt with, this is used as part of the fail-back 
    mechanism.

Arguments:

    DsmContext - Context value given to the multipath driver during registration.
    DsmId - Value returned from DMSInquireDriver.
    PathId - Value set in SetPathId.

Return Value:

    NTSTATUS
--*/


typedef
NTSTATUS
(*DSM_PATH_RECOVERY) (
    IN PVOID DsmContext,
    IN PVOID PathId
    );

/*++

Routine Description:

    This OPTIONAL routine allows the DSM to carry out whatever path recovery logic it deems
    appropriate. It is up to the DSM to determine what constitutes the repair:
        private Admin WMI notification,
        vendor-unique commands to controller, device, adapter,
        ...

    Note that DsmNotification can be used in place of this routine to indicate a path
    repair, and is the preferred method.

Arguments:

    DsmContext - Context value given to the multipath driver during registration.
    PathId - Path to re-enable.

Return Value:

    NTSTATUS - STATUS_SUCCESS if condition that led to the fail-over has been repaired.
    Otherwise appropriate status.

--*/


typedef 
NTSTATUS
(*DSM_REENABLE_PATH) (
    IN PVOID DsmContext,                      
    IN PVOID PathId,
    OUT PULONG DSMErrorId
    );
/*++

Routine Description:

    This routine allows the DSM to bring a previously failed path back online. 
    Mpctl has determined that it believes the error condition was transitory (via an admin utility
    of DSMNotification) or has been repaired.

    The DSM should return success, only if the path can handle requests to it's devices.
    This will be issued after a failover and subsequent autorecovery/admin notification.
    If the error was transitory, or the DSM/Device was able to repair 
    the problem, this gives the DSM the opportunity to bring the failed path back online
    (as far as mpctl is concerned).

Arguments:

    DsmContext - Context value given to the multipath driver during registration.
    PathId - Path to re-enable.
    DSMErrorId - DSM specific error value - not interpreted, rather used for logging.

Return Value:

    NTSTATUS - STATUS_SUCCESS if path is now capable of handling requests. 
    Otherwise appropriate status.

--*/

//
// PERMANENT indicates that SuggestedPath should be the device's preferred path.
// PENDING_REMOVAL indicates that the path is about to go away.
// OEM_MASK values specific to the DSM
// RESERVED future expansion
// ADMIN_REQUEST indicates that the request originated from some user-mode utility.
// 
#define DSM_MOVE_PERMANENT       0x00000001
#define DSM_MOVE_PENDING_REMOVAL 0x00000002
#define DSM_MOVE_OEM_MASK        0x0000FF00
#define DSM_MOVE_RESERVED        0x7FFF0000 
#define DSM_MOVE_ADMIN_REQUEST   0x80000000

typedef
NTSTATUS
(*DSM_MOVE_DEVICE) (
    IN PVOID DsmContext,
    IN PDSM_IDS DsmIds, 
    IN PVOID MPIOPath,
    IN PVOID SuggestedPath,
    IN ULONG Flags
    );
/*++

Routine Description:

    This routine is invoked (usually) in response to an administrative request.
    The DSM will associate the Device described by DsmId to the SuggestedPath, or may
    select another available. As this request will usually be followed by an adapter
    removal, or can be used to set-up static load-balancing.

Arguments:

    DsmContext - Context value given to the multipath driver during registration.
    DsmIds - The collection of DSM IDs that pertain to the MPDisk.
    MPIOPath - The original path value passed to SetDeviceInfo.
    SuggestedPath - The path which should become the active path.
    Flags - Bitmask indicating the intent of the move. 

Return Value:

    NTSTATUS - STATUS_SUCCESS, some error status if there are no good alternate paths.
    
--*/    
   
typedef
NTSTATUS
(*DSM_REMOVE_PENDING) (
    IN PVOID DsmContext,
    IN PVOID DsmId
    );
/*++

Routine Description:

    This routine indicates that the device represented by DsmId will be removed, though
    due to outstanding I/Os or other conditions, it can't be removed immediately.
    The DSM_ID list passed to other functions will no longer contain DsmId, so internal
    structures should be updated accordingly.

Arguments:

    DsmContext - Context value given to the multipath driver during registration.
    DsmId - Value referring to the failed device.

Return Value:

    NTSTATUS of the operation. 

--*/


typedef 
NTSTATUS
(*DSM_REMOVE_DEVICE) (
    IN PVOID DsmContext,
    IN PVOID DsmId,
    IN PVOID PathId
    );
/*++

Routine Description:

    This routine indicates that the main path has determined or been notified that thedevice
    has failed and should be removed from PathId. 

Arguments:

    DsmContext - Context value given to the multipath driver during registration.
    DsmId - Value referring to the failed device.
    PathId - The path on which the Device lives.

Return Value:

    NTSTATUS of the operation. 

--*/

typedef 
NTSTATUS
(*DSM_REMOVE_PATH) (
    IN PVOID DsmContext,
    IN PVOID PathId
    );
/*++

Routine Description:

    This routine indicates that the path is no longer valid, and that the DSM should update
    it's internal state appropriately (tear down the structure, free allocations, ...).
    It is the responsibility of mpctl.sys to have already removed the devices (via RemoveDevice) 
    that are attached to this path.

Arguments:

    DsmContext - Context value given to the multipath driver during registration.
    PathId - The path to remove.

Return Value:

    NTSTATUS of the operation. 

--*/

 


#define DSM_BROADCAST   0x00000001
#define DSM_WILL_HANDLE 0x00000002
#define DSM_PATH_SET    0x00000003
#define DSM_ERROR       0x00000004

//
// IOCTL handling routines.
//
typedef
ULONG
(*DSM_CATEGORIZE_REQUEST) (
    IN PVOID DsmContext,                            
    IN PDSM_IDS DsmIds, 
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID CurrentPath,
    OUT PVOID *PathId,
    OUT NTSTATUS *Status
    );
/*++

Routine Description:

    The routine is called when a request other than R/W is being handled.
    The DSM indicates whether the request should be handled by it's DsmBroadcastRequest,
    DsmSrbDeviceControl, or that the PathID indicated should be used.

Arguments:

    DsmIds - The collection of DSM IDs that pertain to the MPDisk.
    Irp - The Irp containing Srb.
    Srb - Scsi request block
    CurrentPath - Path to which last request was sent
    PathId - Updated to the PathId where the request should be sent if return value
             is DSM_PATH_SET.
    Status - Storage for status in the event that DSM_ERROR is returned.

Return Value:

    DSM_BROADCAST - If BroadcastRequest should be used.
    DSM_WILL_HANDLE - If SrbDeviceControl should be used.
    DSM_PATH_SET - If the Srb should just be sent to PathId
    DSM_ERROR - Indicates that an error occurred where by the request can't be handled.
                Status is updated, along with Srb->SrbStatus.

--*/

typedef
NTSTATUS
(*DSM_BROADCAST_SRB) (
    IN PVOID DsmContext,                      
    IN PDSM_IDS DsmIds,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PKEVENT Event
    );
/*++

Routine Description:

    This routine is called when the DSM has indicated that Srb should be sent to the device
    down all paths. The DSM will update IoStatus information and status, but not complete the
    request.

Arguments:

    DsmIds - The collection of DSM IDs that pertain to the MPDisk.
    Irp - Irp containing SRB.
    Srb - Scsi request block
    Event - DSM sets this once all sub-requests have completed and the original request's
            IoStatus has been setup.

Return Value:

    NTSTATUS of the operation.

--*/


typedef
NTSTATUS
(*DSM_SRB_DEVICE_CONTROL) (
    IN PVOID DsmContext,
    IN PDSM_IDS DsmIds,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PKEVENT Event
    );
/*++

Routine Description:
    
    This routine is called when the DSM has indicated that it wants to handle it internally
    (via CATEGORIZE_REQUEST). 
    It should set IoStatus (Status and Information) and the Event, but not complete the request. 

Arguments:

    DsmIds - The collection of DSM IDs that pertain to the MPDISK.
    Irp - Irp containing SRB.
    Srb - Scsi request block
    Event - Event to be set when the DSM is finished if DsmHandled is TRUE

Return Value:

    NTSTATUS of the request.

--*/

typedef
VOID
(*DSM_COMPLETION_ROUTINE) (
    IN PVOID DsmId,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID DsmContext
    );

typedef struct _DSM_COMPLETION_INFO {

    //
    // Routine to be invoked on request completion.
    //
    DSM_COMPLETION_ROUTINE DsmCompletionRoutine;

    //
    // Context to be supplied.
    //
    PVOID DsmContext;

} DSM_COMPLETION_INFO, *PDSM_COMPLETION_INFO;

typedef
VOID
(*DSM_SET_COMPLETION) (
    IN PVOID DsmContext,
    IN PVOID DsmId,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PDSM_COMPLETION_INFO DsmCompletion
    );
/*++

Routine Description:

    This routine is called before the actual submission of a request, but after the categorisation
    of the I/O. This will be called only for those requests not handled by the DSM directly:
         Read/Write
         Other requests not handled by SrbControl or Broadcast
    The DSM can supply a completion routine and context which will be invoked when the
    request completion is being handled. It is not necessary to set completions on any or all
    requests.

Arguments:
    DsmId - Identifer that was indicated when the request was categorized (or be LBGetPath)
    Irp - Irp containing Srb.
    Srb - The request
    DsmCompletion - Completion info structure to be filled out by DSM. 


Return Value:

    None

--*/

#define NUMA_MAX_WEIGHT 10

typedef
PVOID
(*DSM_LB_GET_PATH) (
    IN PVOID DsmContext,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PDSM_IDS DsmList,
    IN PVOID CurrentPath,
    OUT NTSTATUS *Status
    );
/*++

Routine Description:

    This routine is called once per I/O and gives the DSM the ability to indicate
    to which path the request should be submitted. If the DSM returns a Path that was
    not active, this constitutes a Fail-over condition.

Arguments:

    Srb - The request that needs to be submitted
    DsmList - Ids of the devices that make up the multipath group.
    CurrentPath - Path to which last request was sent
    Status - Storage for an error status, if returning NULL path.

Return Value:

    PathId to where the request should be sent. NULL if all current paths are failed.

--*/

//
// WMI structs, defines, routines.
//

typedef
NTSTATUS
(*DSM_QUERY_DATABLOCK) (
    IN PVOID DsmContext,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer,
    OUT PULONG DsmDataLength
    );
/*++

Routine Description:

Arguments:

Return Value:

    status

--*/

typedef
NTSTATUS
(*DSM_SET_DATABLOCK) (
    IN PVOID DsmContext,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

typedef
NTSTATUS
(*DSM_SET_DATAITEM) (
    IN PVOID DsmContext,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

typedef
NTSTATUS
(*DSM_EXECUTE_METHOD) (
    IN PVOID DsmContext,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN OUT PUCHAR Buffer
    );

typedef
NTSTATUS
(*DSM_FUNCTION_CONTROL) (
    IN PVOID DsmContext,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    );

typedef struct _DSM_WMILIB_CONTEXT {
    ULONG GuidCount;
    PWMIGUIDREGINFO GuidList;

    DSM_QUERY_DATABLOCK QueryWmiDataBlock;
    DSM_SET_DATABLOCK SetWmiDataBlock;
    DSM_SET_DATAITEM SetWmiDataItem;
    DSM_EXECUTE_METHOD ExecuteWmiMethod;
    DSM_FUNCTION_CONTROL WmiFunctionControl;
} DSM_WMILIB_CONTEXT, *PDSM_WMILIB_CONTEXT;


//
// Unload routine.
//
typedef 
NTSTATUS
(*DSM_UNLOAD) (
    IN PVOID DsmContext
    );
/*++

Routine Description:

    This routine is called when the main module requires the DSM to be unloaded
    (ie. prior to the main module unload).

Arguments:

    DsmContext - Context value passed to DsmInitialize()

Return Value:

    NTSTATUS - Had best be STATUS_SUCCESS;

--*/

//
// Registration routines.
//
// Called in the DSM's DriverEntry.
// The DSM will register with the main module by filling in the following structure
// and sending the REGISTER IOCTL 
//
typedef struct _DSM_INIT_DATA {

    //
    // Size, in bytes.
    //
    ULONG InitDataSize;

    //
    // DSM entry points.
    //
    DSM_INQUIRE_DRIVER DsmInquireDriver;
    DSM_COMPARE_DEVICES DsmCompareDevices;
    DSM_GET_CONTROLLER_INFO DsmGetControllerInfo;
    DSM_SET_DEVICE_INFO DsmSetDeviceInfo;
    DSM_IS_PATH_ACTIVE DsmIsPathActive;
    DSM_PATH_VERIFY DsmPathVerify;
    DSM_INVALIDATE_PATH DsmInvalidatePath;
    DSM_MOVE_DEVICE DsmMoveDevice;
    DSM_REMOVE_PENDING DsmRemovePending;
    DSM_REMOVE_DEVICE DsmRemoveDevice;
    DSM_REMOVE_PATH DsmRemovePath;
    DSM_SRB_DEVICE_CONTROL DsmSrbDeviceControl;
    DSM_REENABLE_PATH DsmReenablePath;
    DSM_LB_GET_PATH DsmLBGetPath;
    DSM_INTERPRET_ERROR DsmInterpretError;
    DSM_UNLOAD DsmUnload;
    DSM_SET_COMPLETION DsmSetCompletion;
    DSM_CATEGORIZE_REQUEST DsmCategorizeRequest;
    DSM_BROADCAST_SRB DsmBroadcastSrb;

    //
    // Wmi entry point and guid information.
    //
    DSM_WMILIB_CONTEXT DsmWmiInfo;

    //
    // Context value.
    //
    PVOID DsmContext;

    //
    // DriverObject for the DSM.
    //
    PDRIVER_OBJECT DriverObject;

    //
    // Friendly name for the DSM.
    //
    UNICODE_STRING DisplayName;

    //
    // Reserved.
    //
    ULONG Reserved;

} DSM_INIT_DATA, *PDSM_INIT_DATA;

//
// Output structure for the registration. The DSM needs to keep this value for certain
// routines such as DsmNotification and DsmGetTargetObject.
// 
typedef struct _DSM_MPIO_CONTEXT {
    PVOID MPIOContext;
} DSM_MPIO_CONTEXT, *PDSM_MPIO_CONTEXT;

#define MPIO_DSM ((ULONG) 'dsm')

//
// IOCTL handled by the DSM that the MultiPath Control driver sends to get entry point info.
// Output structure defined above (DSM_INIT_DATA).
//
#define IOCTL_MPDSM_REGISTER CTL_CODE (MPIO_DSM, 0x01, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)


//
// DSM library routines.
//
VOID
DsmSendDeviceIoControlSynchronous(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    OUT PIO_STATUS_BLOCK IoStatus
    );

/*++

Routine Description:

    This routine is used by the DSM to send IoDeviceControls.  
    Buffer must be of the appropriate size to encapsulate both input and output.
    This routine handles errors/retries.

Arguments:

    IoControlCode - The DeviceIoControl code.
    TargetDevice - DeviceObject to which the request should be sent.
    Buffer - The input/output buffer for the request.
    InputBufferLength - Length of the input parameters buffer.
    OutputBufferLength - Length of the output buffer
    InternalDeviceIoControl - Indicates whether the IOCTL is marked as Internal or public.
    IoStatus - IO STATUS BLOCK to receive the final status/information fields.

Return Value:

   NONE
   
--*/

NTSTATUS
DsmGetDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTORAGE_PROPERTY_ID PropertyId,
    OUT PSTORAGE_DESCRIPTOR_HEADER *Descriptor
    );


NTSTATUS
DsmSendPassThroughDirect(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_PASS_THROUGH_DIRECT ScsiPassThrough,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

PDSM_IDS
DsmGetAssociatedDevice(
    IN PVOID MPIOContext,
    IN PDEVICE_OBJECT PortFdo,
    IN UCHAR DeviceType
    );
/*++

Routine Description:

    If the DSM needs to acquire information from other devices (such as a controller), this
    routine can be used to get a list of the PDO's associated with PortFdo.

Arguments:

    PortFdo - Port driver FDO passed to InquireDriver.
    DeviceType - Indicates the SCSI DeviceType to return.
    
Return Value:

    Pointer to a DSM_ID structure, where IdList entries are PDEVICE_OBJECT. It is the
    reponsibility of the DSM to free the buffer.

--*/


NTSTATUS
DsmReleaseQueue(
    IN PDEVICE_OBJECT TargetDevice
    );
/*++

Routine Description:

    In the event that a DSM-originated request freezes the queue (SRB_STATUS_QUEUE_FROZEN), this
    must be used to un-freeze the queue.
    DSM's must check the SRB_STATUS_XXX values upon request completion for those requests that
    they sent.
    
Arguments:

    TargetDevice - DeviceObject to which the release queue should be sent.

Return Value:

    Status of of the ReleaseQueue IOCTL.
    
--*/


NTSTATUS
DsmSendTUR(
    IN PDEVICE_OBJECT TargetDevice
    );
/*++

Routine Description:

    Sends a Test Unit Ready to TargetDevice.
    
Arguments:

    TargetDevice - DeviceObject to which the TUR should be sent.

Return Value:

    Status of of the TUR.
    
--*/

NTSTATUS
DsmSendRequest(
    IN PDEVICE_OBJECT TargetDevice,
    IN PIRP Irp,
    IN PVOID DsmId
    );
/*++

Routine Description:

    This routine is used by the DSM to send it's OOB, Broadcast, or any other DSM built requests 
    to TargetDevice. Not to be used for Irps sent to the DSM by the MPIO driver. Using this
    routine allows MPIO to maintain the necessary state info so that Power and PnP requests
    can be handled correctly. 

Arguments:

    TargetDevice - DeviceObject to which Irp should be sent.
    Irp - The request to send.
    DsmId - DSM value referring to the port PDO.

Return Value:

    Status of IoCallDriver or an error status if one is detected.
    
--*/

ULONG
DsmGetSystemWeight(
    IN PVOID MPIOContext,
    IN PIRP Irp,
    IN PVOID PathId
    );
/*++

Routine Description:

    This routine is used by the DSM to determine the cost associated with issuing the
    request to PathId for the system.  For example, cross node accesses on a NUMA system.

Arguments:

    MPIOContext - Value given to the DSM during initialization.
    Irp - The request to send.
    PathId - One of the PathId values for the MPDisk. (SetDeviceInfo).
    
Return Value:

    Relative system cost of issuing Irp to PathId. (ULONG)-1 indicates this Path is
    unreachable.
    
--*/


typedef enum _DSM_NOTIFICATION_TYPE {
     DeviceFailure,
     PathFailure,
     PathOnLine,
     ThrottleIO,
     ResumeIO,
     MaxDsmNotificationType
} DSM_NOTIFICATION_TYPE, *PDSM_NOTIFICATION_TYPE;


VOID
DsmNotification(
    IN PVOID MpctlContext,
    IN DSM_NOTIFICATION_TYPE NotificationType,
    IN PVOID AdditionalParameters
    );
/*++

Routine Description:

    This routine is called by the DSM to inform mpctl of certain events such as
    Device/Path failure, Device/Path coming back online after a failure, WMI Events, or TBD....

Arguments:

    MpctlContext - Value given to the DSM during initialization.
    NotificationType - Specifies the type of notification.
    Additional Parameters depend on NotificationType
        DeviceFailure - DsmId
        PathFailure - PathId
        PathOnLine - PathId
        ThrottleIO - PathId
        ResumeIO - PathId

Return Value:

    None

--*/


NTSTATUS
DsmWriteEvent(
    IN PVOID MPIOContext,
    IN PWCHAR ComponentName,
    IN PWCHAR EventDescription,
    IN ULONG Severity
    );
/*++

Routine Description:

    The will cause a WMI Event to be fired, containing the Paramter information as
    the event data.

Arguments:

    MpctlContext - Value given to the DSM during initialization.
    ComponentName - Name of the object effected.
    EventDescription - Description of the event.
    Severity - Lower is worse.

Return Value:

    None

--*/


#endif // _DSM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\include\mplib.h ===
#ifndef _MPLIB_H_
#define _MPLIB_H_

#include <ntddk.h>
#include <ntddstor.h>
#include "ntddscsi.h"


//
// Functions exported by mplib
//
VOID
MPLIBSendDeviceIoControlSynchronous(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    OUT PIO_STATUS_BLOCK IoStatus
    );


NTSTATUS
MPLibSendPassThroughDirect(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_PASS_THROUGH_DIRECT ScsiPassThrough,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
MPLIBGetDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTORAGE_PROPERTY_ID PropertyId,
    OUT PSTORAGE_DESCRIPTOR_HEADER *Descriptor
    );

NTSTATUS
MPLibReleaseQueue(
    IN PDEVICE_OBJECT ChildDevice
    );

NTSTATUS
MPLibSendTUR(
    IN PDEVICE_OBJECT TargetDevice
    );

VOID
MPathDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );


#if 1

#define DEBUG_BUFFER_LENGTH 255
extern UCHAR DebugBuffer[];
extern ULONG MPathDebug;

#define MPDebugPrint(x) MPathDebugPrint x
#else
#define MPDebugPrint(x)
#endif


extern ULONG DontLoad;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\lib\mplib.c ===
#include <ntddk.h>
#include "mplib.h"
#include <stdio.h>
#include <stdarg.h>
#include <ntddscsi.h>
#include <scsi.h>

typedef struct _MPLIB_COMPLETION_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    KEVENT Event;
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;
    PSENSE_DATA SenseBuffer;
} MPLIB_COMPLETION_CONTEXT, *PMPLIB_COMPLETION_CONTEXT;    

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))

ULONG DontLoad = 0;


NTSTATUS
MPLIBSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )

/*++

Routine Description:

    This completion routine will signal the event given as context and then
    return STATUS_MORE_PROCESSING_REQUIRED to stop event completion.  It is
    the responsibility of the routine waiting on the event to complete the
    request and free the event.

Arguments:

    DeviceObject - a pointer to the device object
    Irp - a pointer to the irp
    Event - a pointer to the event to signal

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }
    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
MPLIBSendIrpSynchronous(
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine issues an irp synchronously.

Arguments:

    TargetDeviceObject - Recepient of the request.
    Irp - Irp to send.

Return Value:

    Status of the request

--*/
{
    KEVENT event;
    NTSTATUS status;

    //
    // Ensure enough stack locations are available.
    //
    ASSERT(Irp->StackCount >= TargetDeviceObject->StackSize);

    //
    // Initialize the event that will be set by the completion
    // routine.
    //
    KeInitializeEvent(&event,
                      SynchronizationEvent,
                      FALSE);

    //
    // Set the completion routine - the event is the context.
    //
    IoSetCompletionRoutine(Irp,
                           MPLIBSignalCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // Submit the request.
    //
    status = IoCallDriver(TargetDeviceObject, Irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = Irp->IoStatus.Status;
    }

    return status;
}


VOID
MPLIBSendDeviceIoControlSynchronous(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    This routine builds and sends the IOCTL specified by IoControlCode to
    TargetDeviceObject.

Arguments:
    IoControlCode - IOCTL to send.
    TargetDeviceObject - Recepient of the request.
    Buffer - Input/output buffer.
    InputBufferLength - Size, in bytes of the inputbuffer.
    OutputBufferLength - Size, in bytes of the output buffer.
    InternalDeviceIocontrol - Specifies whethers it's internal or not.
    IoStatus - Pointer to caller's iostatus block.

Return Value:

    Status of the request

--*/
{
    PIRP irp = NULL;
    PIO_STACK_LOCATION irpStack;

    ASSERT((IoControlCode & 3) == METHOD_BUFFERED);
    ASSERT(ARGUMENT_PRESENT(IoStatus));

    //
    // Ensure that if either buffer length is set, that there is actually
    // a buffer.
    //
    if (InputBufferLength) {

        if (InputBuffer == NULL) {
            (*IoStatus).Status = STATUS_BUFFER_TOO_SMALL;
            (*IoStatus).Information = 0;
            return;
        }
    }

    if (OutputBufferLength) {
        if (OutputBuffer == NULL) {
            (*IoStatus).Status = STATUS_BUFFER_TOO_SMALL;
            (*IoStatus).Information = 0;
            return;
        }
    }

    //
    // Allocate an irp.
    //
    irp = IoAllocateIrp(TargetDeviceObject->StackSize, FALSE);
    if (irp == NULL) {
        (*IoStatus).Information = 0;
        (*IoStatus).Status = STATUS_INSUFFICIENT_RESOURCES;
        return;
    }

    //
    // Get the recipient's irpstack location.
    //
    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Set the major function code based on the type of device I/O control
    // function the caller has specified.
    //
    if (InternalDeviceIoControl) {
        irpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    } else {
        irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    }

    //
    // Fill in the ioControl parameters.
    //
    irpStack->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpStack->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
    irpStack->Parameters.DeviceIoControl.IoControlCode = IoControlCode;


    //
    // Allocate the SystemBuffer, if needed.
    //
    if (InputBufferLength || OutputBufferLength) {

        irp->AssociatedIrp.SystemBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                                         max(InputBufferLength, OutputBufferLength));

        if (irp->AssociatedIrp.SystemBuffer == NULL) {
            IoFreeIrp(irp);
            (*IoStatus).Information = 0;
            (*IoStatus).Status = STATUS_INSUFFICIENT_RESOURCES;
            return;
        }

        //
        // If passing info to TargetDevice, copy the caller's data
        // into the system buffer.
        //
        if (InputBufferLength) {
            RtlCopyMemory(irp->AssociatedIrp.SystemBuffer,
                          InputBuffer,
                          InputBufferLength);
        }
    }

    irp->UserBuffer = OutputBuffer;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // send the irp synchronously
    //
    MPLIBSendIrpSynchronous(TargetDeviceObject, irp);

    //
    // copy the iostatus block for the caller
    //
    *IoStatus = irp->IoStatus;

    //
    // If there's an ouputbuffer, copy the results.
    //
    if (OutputBufferLength && (IoControlCode != IOCTL_SCSI_PASS_THROUGH_DIRECT)) {
        RtlCopyMemory(OutputBuffer,
                      irp->AssociatedIrp.SystemBuffer,
                      OutputBufferLength
                      );
    }

    //
    // Free the allocations.
    //
    if (InputBufferLength || OutputBufferLength) {
        ExFreePool(irp->AssociatedIrp.SystemBuffer);
        irp->AssociatedIrp.SystemBuffer = NULL;
    }

    IoFreeIrp(irp);
    irp = (PIRP) NULL;

    return;
}


NTSTATUS
MPLIBGetDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTORAGE_PROPERTY_ID PropertyId,
    OUT PSTORAGE_DESCRIPTOR_HEADER *Descriptor
    )

/*++

Routine Description:

    This routine will perform a query for the specified property id and will
    allocate a non-paged buffer to store the data in.  It is the responsibility
    of the caller to ensure that this buffer is freed.


Arguments:

    DeviceObject - the device to query
    DeviceInfo - a location to store a pointer to the buffer we allocate

Return Value:

    status. 

--*/
{
    STORAGE_PROPERTY_QUERY query;
    PIO_STATUS_BLOCK ioStatus;
    PSTORAGE_DESCRIPTOR_HEADER descriptor = NULL;
    ULONG length;

    //
    // Poison the passed in descriptor.
    //
    *Descriptor = NULL;

    //
    // Setup the query buffer.
    //
    query.PropertyId = *PropertyId;
    query.QueryType = PropertyStandardQuery;
    query.AdditionalParameters[0] = 0;

    ioStatus = ExAllocatePool(NonPagedPool, sizeof(IO_STATUS_BLOCK));
    ASSERT(ioStatus);
    ioStatus->Status = 0;
    ioStatus->Information = 0;

    //
    // On the first call, just need to get the length of the descriptor.
    //
    descriptor = (PVOID)&query;
    MPLIBSendDeviceIoControlSynchronous(IOCTL_STORAGE_QUERY_PROPERTY,
                                        DeviceObject,
                                        &query,
                                        &query,
                                        sizeof(STORAGE_PROPERTY_QUERY),
                                        sizeof(STORAGE_DESCRIPTOR_HEADER),
                                        FALSE,
                                        ioStatus);

    if(!NT_SUCCESS(ioStatus->Status)) {

        MPDebugPrint((0,
                      "MPLIBGetDescriptor: Query failed (%x) on attempt 1\n",
                       ioStatus->Status));
        return ioStatus->Status;
    }

    ASSERT(descriptor->Size);
    if (descriptor->Size == 0) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // This time we know how much data there is so we can
    // allocate a buffer of the correct size
    //

    length = descriptor->Size;

    descriptor = ExAllocatePoolWithTag(NonPagedPool, length, 'BLPM');

    if(descriptor == NULL) {

        MPDebugPrint((0, 
                     "MPLIBGetDescriptor: Couldn't allocate descriptor of %ld\n",
                     length));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // setup the query again.
    //
    query.PropertyId = *PropertyId;
    query.QueryType = PropertyStandardQuery;
    query.AdditionalParameters[0] = 0;

    //
    // copy the input to the new outputbuffer
    //
    RtlCopyMemory(descriptor,
                  &query,
                  sizeof(STORAGE_PROPERTY_QUERY));

    MPLIBSendDeviceIoControlSynchronous(IOCTL_STORAGE_QUERY_PROPERTY,
                                        DeviceObject,
                                        descriptor,
                                        descriptor,
                                        sizeof(STORAGE_PROPERTY_QUERY),
                                        length,
                                        0,
                                        ioStatus);

    if(!NT_SUCCESS(ioStatus->Status)) {

        MPDebugPrint((0,
                      "MPLIBGetDescriptor: Query Failed (%x) on attempt 2\n",
                      ioStatus->Status));
        ExFreePool(descriptor);
        return ioStatus->Status;
    }

    //
    // return the memory we've allocated to the caller
    //
    *Descriptor = descriptor;
    return ioStatus->Status;
}


NTSTATUS
MPLibReleaseQueueCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )
/*++

Routine Description:


Arguments:

    DeviceObject - The device object for the logical unit; however since this
        is the top stack location the value is NULL.

    Irp - Supplies a pointer to the Irp to be processed.

    Context - Supplies the context to be used to process this request.

Return Value:

    None.

--*/

{
    PKEVENT event = Context;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }
    KeSetEvent(event, 0 , FALSE);

    //
    // Free the Irp.
    //
    IoFreeIrp(Irp);

    //
    // Indicate the I/O system should stop processing the Irp completion.
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
MPLibReleaseQueue(
    IN PDEVICE_OBJECT ChildDevice
    )
/*++

Routine Description:

    This routine issues a Release Queue to the port driver for Child device.

Arguments:

    ChildDevice - Device Object for a scsiport child returned in QDR.

Return Value:

    Status of the request

--*/
{
    PIRP               irp;
    PIO_STACK_LOCATION irpStack;
    KEVENT             event;
    NTSTATUS           status;
    PSCSI_REQUEST_BLOCK srb;

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion
    //
    KeInitializeEvent(&event, SynchronizationEvent, FALSE);


    irp = IoAllocateIrp((CCHAR)(ChildDevice->StackSize),
                        FALSE);
    if (irp) {
        srb = ExAllocatePool(NonPagedPool, sizeof(SCSI_REQUEST_BLOCK));
        if (srb) {

            RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

            //
            // Construct the IRP stack for the lower level driver.
            //
            irpStack = IoGetNextIrpStackLocation(irp);
            irpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            irpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_SCSI_EXECUTE_NONE;
            irpStack->Parameters.Scsi.Srb = srb;
            IoSetCompletionRoutine(irp,
                                   MPLibReleaseQueueCompletion,
                                   &event,
                                   TRUE,
                                   TRUE,
                                   TRUE);


            //
            // Setup the SRB.
            //
            srb->Length = SCSI_REQUEST_BLOCK_SIZE;
            srb->Function = SRB_FUNCTION_FLUSH_QUEUE;
            srb->OriginalRequest = irp;

        } else {
            IoFreeIrp(irp);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Call the port driver with the request and wait for it to complete.
    //
    status = IoCallDriver(ChildDevice, irp);
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }

    ExFreePool(srb);
    return status;

}


NTSTATUS
MPLibTURCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )
/*++

Routine Description:

    This routine is called when an asynchronous I/O request
    which was issused by the dsm completes.  Examples of such requests
    are release queue or test unit ready. This routine releases the queue if
    necessary.  It then frees the context and the IRP.

Arguments:

    DeviceObject - The device object for the logical unit; however since this
        is the top stack location the value is NULL.

    Irp - Supplies a pointer to the Irp to be processed.

    Context - Supplies the context to be used to process this request.

Return Value:

    None.

--*/

{
    PMPLIB_COMPLETION_CONTEXT context = Context;
    PSCSI_REQUEST_BLOCK srb;

    srb = context->Srb;

    //
    // If this is an execute srb, then check the return status and make sure.
    // the queue is not frozen.
    //

    if (srb->Function == SRB_FUNCTION_EXECUTE_SCSI) {

        //
        // Check for a frozen queue.
        //
        if (srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {

            //
            // Unfreeze the queue getting the device object from the context.
            //
            MPDebugPrint((2,
                         "DsmCompletion: Queue is frozen!!!!\n"));

            MPLibReleaseQueue(context->DeviceObject);
        }
    }

    context->Status = Irp->IoStatus.Status;

    //
    // Free the Irp.
    //
    IoFreeIrp(Irp);

    KeSetEvent(&context->Event, 0, FALSE);

    //
    // Indicate the I/O system should stop processing the Irp completion.
    //
    return STATUS_MORE_PROCESSING_REQUIRED;

}


NTSTATUS
InterpretSenseInfo(
    IN PSENSE_DATA SenseData,
    IN ULONG SenseLength
    )
{
    UCHAR senseKey = SenseData->SenseKey & 0xF;
    UCHAR asc = SenseData->AdditionalSenseCode;
    UCHAR ascq = SenseData->AdditionalSenseCodeQualifier;

    switch (senseKey) {
        case SCSI_SENSE_NOT_READY:
            return STATUS_DEVICE_NOT_READY;
        case SCSI_SENSE_DATA_PROTECT:
            return STATUS_MEDIA_WRITE_PROTECTED;
        case SCSI_SENSE_MEDIUM_ERROR:
            return STATUS_DEVICE_DATA_ERROR;
        case SCSI_SENSE_ILLEGAL_REQUEST:
            return STATUS_INVALID_DEVICE_REQUEST;
            
        case SCSI_SENSE_BLANK_CHECK:
            return STATUS_NO_DATA_DETECTED;
        case SCSI_SENSE_RECOVERED_ERROR:
            return STATUS_SUCCESS;
            
        case SCSI_SENSE_HARDWARE_ERROR:
        case SCSI_SENSE_UNIT_ATTENTION:
        case SCSI_SENSE_NO_SENSE:    
        case SCSI_SENSE_ABORTED_COMMAND:
        default:    
            return STATUS_IO_DEVICE_ERROR;
    }        

    return STATUS_IO_DEVICE_ERROR;
    
}


NTSTATUS
InterpretScsiStatus(
    IN PUCHAR SenseBuffer,
    IN ULONG SenseLength,
    IN UCHAR ScsiStatus
    )
{
    NTSTATUS status;

    switch (ScsiStatus) {

        case SCSISTAT_CHECK_CONDITION: {
            if (SenseBuffer && SenseLength) {
                status = InterpretSenseInfo((PSENSE_DATA)SenseBuffer,
                                             SenseLength);                
            } else {
               status = STATUS_IO_DEVICE_ERROR; 
            }                
            break;
        }       
        case SCSISTAT_BUSY:
            status = STATUS_DEVICE_NOT_READY;
            break;
        case SCSISTAT_RESERVATION_CONFLICT:
            status = STATUS_DEVICE_BUSY;
            break;
        default:
            status = STATUS_IO_DEVICE_ERROR;
            break;
    }        

    return status;

}


NTSTATUS
MPLibSendPassThroughDirect(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_PASS_THROUGH_DIRECT ScsiPassThrough,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )
{
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;
    UCHAR scsiStatus;
    
    MPLIBSendDeviceIoControlSynchronous(IOCTL_SCSI_PASS_THROUGH_DIRECT,
                                        DeviceObject,
                                        ScsiPassThrough,
                                        ScsiPassThrough->DataBuffer,
                                        InputBufferLength, 
                                        OutputBufferLength,
                                        FALSE,
                                        &ioStatus);
    //
    // Check the iostatus. STATUS_SUCCESS really only means that the request
    // was sent successfully, not that it did what it was supposed to.
    //
    status = ioStatus.Status;
    if (NT_SUCCESS(status)) {

        //
        // Get the scsi status. 
        //
        scsiStatus = ScsiPassThrough->ScsiStatus;
        if (scsiStatus == SCSISTAT_GOOD) {
            status = STATUS_SUCCESS;
        } else {
            PUCHAR senseBuffer;            
            ULONG senseLength;

            senseBuffer = (PUCHAR)ScsiPassThrough;
            (ULONG_PTR)senseBuffer += ScsiPassThrough->SenseInfoOffset;
            senseLength = ScsiPassThrough->SenseInfoLength;
            
            status = InterpretScsiStatus(senseBuffer, senseLength, scsiStatus);

        }    
        
    }
    return status;

}


NTSTATUS
MPLibSendTUR(
    IN PDEVICE_OBJECT TargetDevice
    )

/*++

Routine Description:

Arguments:


Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION irpStack;
    PMPLIB_COMPLETION_CONTEXT completionContext;
    PIRP irp;
    PSCSI_REQUEST_BLOCK srb;
    PSENSE_DATA senseData;
    NTSTATUS status;
    PCDB cdb;
    ULONG retry = 4;

    //
    // Allocate an srb, the sense buffer, and context block for the request.
    //
    srb = ExAllocatePool(NonPagedPool,sizeof(SCSI_REQUEST_BLOCK));
    senseData = ExAllocatePool(NonPagedPoolCacheAligned, sizeof(SENSE_DATA));
    completionContext = ExAllocatePool(NonPagedPool, sizeof(MPLIB_COMPLETION_CONTEXT));

    if ((srb == NULL) || (senseData == NULL) || (completionContext == NULL)) {
        if (srb) {
            ExFreePool(srb);
        }
        if (senseData) {
            ExFreePool(senseData);
        }
        if (completionContext) {
            ExFreePool(completionContext);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Setup the context.
    //
    completionContext->DeviceObject = TargetDevice;
    completionContext->Srb = srb;
    completionContext->SenseBuffer = senseData;
    
retryRequest:    
    KeInitializeEvent(&completionContext->Event, NotificationEvent, FALSE);

    //
    // Zero out srb and sense data.
    //
    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    RtlZeroMemory(senseData, sizeof(SENSE_DATA));

    //
    // Build the srb.
    //
    srb->Length = SCSI_REQUEST_BLOCK_SIZE;
    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->TimeOutValue = 4;
    srb->SrbFlags = SRB_FLAGS_NO_DATA_TRANSFER;
    srb->SenseInfoBufferLength = sizeof(SENSE_DATA);
    srb->SenseInfoBuffer = senseData;

    //
    // Build the TUR CDB.
    //
    srb->CdbLength = 6;
    cdb = (PCDB)srb->Cdb;
    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

    //
    // Build the asynchronous request to be sent to the port driver.
    // Since this routine is called from a DPC the IRP should always be
    // available.
    //
    irp = IoAllocateIrp(TargetDevice->StackSize + 1, FALSE);

    if(irp == NULL) {

        ExFreePool(srb);
        ExFreePool(senseData);
        ExFreePool(completionContext);
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    irpStack = IoGetNextIrpStackLocation(irp);
    irpStack->MajorFunction = IRP_MJ_SCSI;
    srb->OriginalRequest = irp;

    //
    // Store the SRB address in next stack for port driver.
    //
    irpStack->Parameters.Scsi.Srb = srb;

    IoSetCompletionRoutine(irp,
                           (PIO_COMPLETION_ROUTINE)MPLibTURCompletion,
                           completionContext,
                           TRUE,
                           TRUE,
                           TRUE);


    //
    // Call the port driver with the IRP.
    //
    status = IoCallDriver(TargetDevice, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&completionContext->Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        status = completionContext->Status;
    }

    if ((status != STATUS_SUCCESS) && retry--) {
        goto retryRequest;
    }
    
    //
    // Free the allocations.
    //
    ExFreePool(completionContext);
    ExFreePool(srb);
    ExFreePool(senseData);

    return status;
}


#if 1

UCHAR DebugBuffer[DEBUG_BUFFER_LENGTH + 1];
ULONG MPathDebug = 1;


VOID
MPathDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for multi-path components.

Arguments:

Return Value:

    None

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= MPathDebug) {

        _vsnprintf(DebugBuffer, DEBUG_BUFFER_LENGTH, DebugMessage, ap);

        DbgPrint(DebugBuffer);
    }

    va_end(ap);

}

#else
VOID
MPathDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\spfilter\mpspfltr.h ===
#ifndef _MPSPFLTR_H_
#define _MPSPFLTR_H_

#include <ntddstor.h>
#include "scsi.h"
#include "mpspf.h"
#include "mplib.h"

#define RL_TAG 'lrPM'
#define RL_MAXT 1
#define RL_HW_MARK 200


typedef struct _FLTR_DEVICE_ENTRY {
    
    LIST_ENTRY ListEntry;

    //
    // The scsiport PDO
    //
    PDEVICE_OBJECT DeviceObject;

    //
    // The scsiport FDO
    // 
    PDEVICE_OBJECT AdapterDeviceObject;

    //
    // Device descriptor for this device.
    //
    PSTORAGE_DEVICE_DESCRIPTOR Descriptor;

    //
    // Page 0x83 info.
    //
    PSTORAGE_DEVICE_ID_DESCRIPTOR DeviceIdPages;

} FLTR_DEVICE_ENTRY, *PFLTR_DEVICE_ENTRY;

typedef struct _DEVICE_EXTENSION {

    //
    // Back pointer to the device object.
    //
    PDEVICE_OBJECT DeviceObject;

    //
    // The underlying port device.
    //
    PDEVICE_OBJECT TargetDevice;

    //
    // MPCtl's device Object.
    //
    PDEVICE_OBJECT ControlObject;

    //
    // Notificaiton routines supplied by mpctl.
    //
    PADP_PNP_NOTIFICATION PnPNotify;
    PADP_POWER_NOTIFICATION PowerNotify;
    PADP_DEVICE_NOTIFICATION DeviceNotify;
    
    //
    // Flags indicating state of connection between
    // this driver instance and mpctl
    // See below for flag bit defines.
    //
    ULONG MPCFlags;

    //
    // Number of devices currently enumerated by scsiport.
    //
    ULONG NumberChildren;

    //
    // Number of actual disk pdo's scsiport created.
    //
    ULONG NumberDiskDevices;

    //
    // SpinLock for the List of devices.
    //
    KSPIN_LOCK ListLock;

    //
    // List of structures describing the children.
    //
    LIST_ENTRY ChildList;

    PADP_ASSOCIATED_DEVICES CachedList;

    //
    // G.P. Event.
    //
    KEVENT Event;
    IO_STATUS_BLOCK IoStatus;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Flag values.
//
#define MPCFLAG_REGISTRATION_COMPLETE       0x00000001
#define MPCFLAG_DEVICE_NOTIFICATION         0x00000004
#define MPCFLAG_DEVICE_NOTIFICATION_FAILURE 0x00000008


//
// Internal functions
//
NTSTATUS
MPSPSendToNextDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PADP_ASSOCIATED_DEVICES
MPSPGetDeviceList(
    IN PDEVICE_OBJECT DeviceObject
    );

//
// Routines defined in pnp.c
//
NTSTATUS
MPSPStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPSPStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP
    );

NTSTATUS
MPSPQueryDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPSPQueryID(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPSPRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPSPSyncCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#endif // _MPSPFLTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\newft\espprot.cxx ===
extern "C" {
    #include <ntosp.h>
    #include <zwapi.h>
}

#include <ftdisk.h>


NTSTATUS
FtpApplyESPProtection(
    IN  PUNICODE_STRING PartitionName
    )

{
    ULONG               length;
    PACL                acl;
    NTSTATUS            status;
    SECURITY_DESCRIPTOR sd;
    OBJECT_ATTRIBUTES   oa;
    HANDLE              h;
    IO_STATUS_BLOCK     ioStatus;

    //SeEnableAccessToExports();

    length = sizeof(ACL) + 2*sizeof(ACCESS_ALLOWED_ACE) +
             RtlLengthSid(SeExports->SeLocalSystemSid) +
             RtlLengthSid(SeExports->SeAliasAdminsSid) +
             8; // The 8 is just for good measure.

    acl = (PACL) ExAllocatePool(PagedPool, length);
    if (!acl) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = RtlCreateAcl(acl, length, ACL_REVISION2);
    if (!NT_SUCCESS(status)) {
        ExFreePool(acl);
        return status;
    }

    status = RtlAddAccessAllowedAce(acl, ACL_REVISION2, GENERIC_ALL,
                                    SeExports->SeLocalSystemSid);
    if (!NT_SUCCESS(status)) {
        ExFreePool(acl);
        return status;
    }

    status = RtlAddAccessAllowedAce(acl, ACL_REVISION2, GENERIC_READ |
                                    GENERIC_WRITE | GENERIC_EXECUTE |
                                    READ_CONTROL, SeExports->SeAliasAdminsSid);
    if (!NT_SUCCESS(status)) {
        ExFreePool(acl);
        return status;
    }

    status = RtlCreateSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    if (!NT_SUCCESS(status)) {
        ExFreePool(acl);
        return status;
    }

    status = RtlSetDaclSecurityDescriptor(&sd, TRUE, acl, FALSE);
    if (!NT_SUCCESS(status)) {
        ExFreePool(acl);
        return status;
    }

    InitializeObjectAttributes(&oa, PartitionName, OBJ_CASE_INSENSITIVE, NULL,
                               NULL);

    status = ZwOpenFile(&h, WRITE_DAC, &oa, &ioStatus, FILE_SHARE_READ |
                        FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_ALERT);
    if (!NT_SUCCESS(status)) {
        ExFreePool(acl);
        return status;
    }

    status = ZwSetSecurityObject(h, DACL_SECURITY_INFORMATION, &sd);

    ZwClose(h);
    ExFreePool(acl);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\spfilter\pnp.c ===
/*++

Copyright (C) 1999  Microsoft Corporation

Module Name:

    mpspfltr.c

Abstract:

    This module contains the routines handling pnp irps for the multipath scsiport filter driver.

Author:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include <ntddk.h>
#include <stdio.h>
#include <stdarg.h>
#include "mpspfltr.h"
#include <ntddscsi.h>

#define MPSP_INQUIRY_SIZE 255

//
// Internal routine decl's
//
NTSTATUS
MPSPSyncCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
MPSPQueryDeviceRelationsCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
MPSPGetDeviceInfo(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PDEVICE_OBJECT ChildDevice,
    IN STORAGE_PROPERTY_ID PropertyId,
    OUT PSTORAGE_DESCRIPTOR_HEADER *Descriptor
    );

NTSTATUS
MPSPNotifyCtl(
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
MPSPMergeList(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_RELATIONS NewRelations,
    IN OUT PBOOLEAN NeedUpdate
    );



//
// The code.
//

NTSTATUS
MPSPStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handles Start requests by sending the start down to scsiport. The completion will signal
    the event and then device object flags and characteristics are updated.

Arguments:

    DeviceObject    - Supplies the device object.
    Irp             - Supplies the I/O request packet.

Return Value:

    Status of the operations.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    MPDebugPrint((0,
                "MPSPStartDevice: Starting (%x)\n",
                DeviceObject));
    //
    // Setup initial status.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // Clone the stack location.
    //
    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // Setup the completion routine. It will set the event that we wait on below.
    //
    IoSetCompletionRoutine(Irp, 
                           MPSPSyncCompletion,
                           deviceExtension,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // Call port with the request.
    //
    status = IoCallDriver(deviceExtension->TargetDevice, Irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&deviceExtension->Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        status = Irp->IoStatus.Status;
    }

    if (NT_SUCCESS(status)) {

        //
        // Sync up our stuff with scsiport's.
        //
        DeviceObject->Flags |= deviceExtension->TargetDevice->Flags;
        DeviceObject->Characteristics |= deviceExtension->TargetDevice->Characteristics;

    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}


NTSTATUS
MPSPStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handles Stop requests by sending the start down to scsiport.
    Mpctl is notified that we got a stop on this adapter.

Arguments:

    DeviceObject    - Supplies the device object.
    Irp             - Supplies the I/O request packet.

Return Value:

    Status of the operations.

--*/
{  
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    //
    // TODO Signal mpctl.sys
    //
    //
    // 
    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(deviceExtension->TargetDevice, Irp);
}



NTSTATUS
MPSPQueryDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handles QDR by setting completion routine which will snoop the return buffer.
    Then it signals mpctl.sys that new relations are present.

Arguments:

    DeviceObject    - Supplies the device object.
    Irp             - Supplies the I/O request packet.

Return Value:

    Status of the operations.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    //
    // Mark pending.
    //
    IoMarkIrpPending(Irp);

    //
    // Move the stack.
    //
    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // Set the completion routine. This will be where the real work happens.
    //
    IoSetCompletionRoutine(Irp,
                           MPSPQueryDeviceRelationsCompletion,
                           deviceExtension,
                           TRUE,
                           TRUE,
                           TRUE);
    //
    // Send the request to port.
    //
    status = IoCallDriver(deviceExtension->TargetDevice, Irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&deviceExtension->Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        status = Irp->IoStatus.Status;
    }

    //
    // Complete the request and return
    //
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    
    MPSPNotifyCtl(deviceExtension);
    return status;
}


PSTORAGE_DEVICE_DESCRIPTOR
MPSPBuildDeviceDescriptor (
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTORAGE_DEVICE_DESCRIPTOR Descriptor
    )
{
    IO_STATUS_BLOCK ioStatus;
    PSCSI_PASS_THROUGH passThrough;
    PVPD_SERIAL_NUMBER_PAGE serialPage;
    PSTORAGE_DEVICE_DESCRIPTOR updateDescriptor;
    ULONG length;
    PCDB cdb;

    PUCHAR serialNumber;
    ULONG serialNumberOffset;
    ULONG descriptorLength;

    //
    // For the default case (meaning some error) return what was passed in.
    //
    updateDescriptor = Descriptor;
    
    //
    // Build an inquiry command with EVPD and pagecode of 0x80 (serial number).
    //
    length = sizeof(SCSI_PASS_THROUGH) + SENSE_BUFFER_SIZE + 0xFF;

    passThrough = ExAllocatePool(NonPagedPool, length);
    if (passThrough == NULL) {
        return Descriptor;
    }

    RtlZeroMemory(passThrough, length);

    //
    // build the cdb.
    //
    cdb = (PCDB)passThrough->Cdb;
    cdb->CDB6INQUIRY3.OperationCode = SCSIOP_INQUIRY;
    cdb->CDB6INQUIRY3.EnableVitalProductData = 1;
    cdb->CDB6INQUIRY3.PageCode = VPD_SERIAL_NUMBER;
    cdb->CDB6INQUIRY3.AllocationLength = 255;

    passThrough->Length = sizeof(SCSI_PASS_THROUGH);
    passThrough->CdbLength = 6;
    passThrough->SenseInfoLength = SENSE_BUFFER_SIZE;
    passThrough->DataIn = 1;
    passThrough->DataTransferLength = 0xFF;
    passThrough->TimeOutValue = 20;
    passThrough->SenseInfoOffset = sizeof(SCSI_PASS_THROUGH);
    passThrough->DataBufferOffset = sizeof(SCSI_PASS_THROUGH) + 18;

    MPLIBSendDeviceIoControlSynchronous(IOCTL_SCSI_PASS_THROUGH,
                                        DeviceObject,
                                        passThrough,
                                        passThrough,
                                        length,
                                        length,
                                        FALSE,
                                        &ioStatus);
    
    if ((passThrough->ScsiStatus) || (ioStatus.Status != STATUS_SUCCESS)) {
        MPDebugPrint((0,
                     "MPSPGetDeviceDescriptor: Status (%x) ScsiStatus (%x)\n",
                     ioStatus.Status,
                     passThrough->ScsiStatus));
    } else {

        MPDebugPrint((0,
                      "GetDeviceDescriptor: Got the serial number page\n"));

        //
        // Get the returned data.
        // 
        (ULONG_PTR)serialPage = (ULONG_PTR)passThrough;
        (ULONG_PTR)serialPage += passThrough->DataBufferOffset;

        //
        // Determine the size of the new allocation.
        // 
        descriptorLength = Descriptor->Size;
        descriptorLength += serialPage->PageLength;

        //
        // Leave a trailing NULL.
        //
        descriptorLength += 1;

        //
        // Allocate a new descriptor that's the size of the current one, plus
        // the size of the returned serial number.
        // 
        updateDescriptor = ExAllocatePool(NonPagedPool, descriptorLength);
        if (updateDescriptor) {

            RtlZeroMemory(updateDescriptor, descriptorLength);

            //
            // Copy over the current descriptor.
            // 
            RtlCopyMemory(updateDescriptor,
                          Descriptor,
                          Descriptor->Size);
            
            //
            // Set the offset for the serial number.
            // 
            serialNumberOffset = Descriptor->Size;
            updateDescriptor->SerialNumberOffset = serialNumberOffset;

            //
            // Get an index to the location of the serial number.
            // 
            serialNumber = (PUCHAR)updateDescriptor;
            serialNumber += serialNumberOffset;

            //
            // Copy it over.
            //
            RtlCopyMemory(serialNumber,
                          serialPage->SerialNumber,
                          serialPage->PageLength);

            ExFreePool(Descriptor);
        }
    }
   
    ExFreePool(passThrough);

    return Descriptor;
}


NTSTATUS
MPSPBuildDeviceList(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PDEVICE_RELATIONS DeviceRelations
    )
{
    PSTORAGE_DESCRIPTOR_HEADER header = NULL;
    PSTORAGE_DESCRIPTOR_HEADER deviceIdHeader = NULL;
    PSTORAGE_DEVICE_ID_DESCRIPTOR deviceIdDescriptor;
    PSTORAGE_DEVICE_DESCRIPTOR descriptor;
    PFLTR_DEVICE_ENTRY deviceEntry;
    NTSTATUS status;
    ULONG i;

    for (i = 0; i < DeviceRelations->Count; i++) {

        //
        // Get the inquiry data for this device.
        //
        status = MPSPGetDeviceInfo(DeviceExtension,
                                   DeviceRelations->Objects[i],
                                   StorageDeviceProperty,
                                   &header);


        if (NT_SUCCESS(status)) {
            descriptor = (PSTORAGE_DEVICE_DESCRIPTOR)header;


            //
            // Ensure this is one we want.
            //
            if (descriptor->DeviceType != DIRECT_ACCESS_DEVICE) {

                //
                // It's not. Free the inquiry data and continue on this bus
                //
                ExFreePool(descriptor);
                continue;
            }

            //
            // Allocate a child device entry.
            //
            deviceEntry = ExAllocatePool(NonPagedPool, sizeof(FLTR_DEVICE_ENTRY));
            if (deviceEntry) {

                RtlZeroMemory(deviceEntry, sizeof(FLTR_DEVICE_ENTRY));

                //
                // Save the inquiry data.
                //
                deviceEntry->Descriptor = descriptor;

                //
                // Get the page 0x83 info.
                //
                status = MPSPGetDeviceInfo(DeviceExtension,
                                           DeviceRelations->Objects[i],
                                           StorageDeviceIdProperty,
                                           &deviceIdHeader);

                if (NT_SUCCESS(status)) {
                    deviceIdDescriptor = (PSTORAGE_DEVICE_ID_DESCRIPTOR)deviceIdHeader;
                    

                    MPDebugPrint((0,
                                  "BuildDeviceList: Page 0x83 (%x). Number of entries (%x)\n",
                                  deviceIdDescriptor,
                                  deviceIdDescriptor->NumberOfIdentifiers));

                    deviceEntry->DeviceIdPages = deviceIdDescriptor;
                } else {

                    //
                    // Don't really care if the page 0x83 data isn't there, though
                    // a DSM might.
                    // 
                    status = STATUS_SUCCESS;

                    //
                    // TODO build a deviceIdDescriptor.
                    //

                }    

                //
                // Update the child's devObj pointers.
                //
                deviceEntry->DeviceObject = DeviceRelations->Objects[i];
                deviceEntry->AdapterDeviceObject = DeviceExtension->TargetDevice;

                //
                // link it in.
                //
                ExInterlockedInsertTailList(&DeviceExtension->ChildList,
                                            &deviceEntry->ListEntry,
                                            &DeviceExtension->ListLock);
                //
                // update count.
                //
                InterlockedIncrement(&DeviceExtension->NumberDiskDevices);

            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (status != STATUS_SUCCESS) {

            //
            // TODO: Log this.
            // Continue on, we may be able to pick up some of the other
            // devices.
            // 
        }
    }

    return STATUS_SUCCESS;

}    


PADP_ASSOCIATED_DEVICES
MPSPBuildCachedList(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_RELATIONS Relations
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSTORAGE_DESCRIPTOR_HEADER header = NULL;
    PSTORAGE_DEVICE_DESCRIPTOR descriptor;
    PADP_ASSOCIATED_DEVICES list;
    NTSTATUS status;
    ULONG i;
    ULONG length;
    //
    // Allocate storage for the cached list.
    //
    length = sizeof(ADP_ASSOCIATED_DEVICES) + 
                 (sizeof(ADP_ASSOCIATED_DEVICE_INFO) * (Relations->Count - 1));
    
    list = ExAllocatePool(NonPagedPool, length);
    
    list->NumberDevices = Relations->Count;
    
    for (i = 0; i < Relations->Count; i++) {
        list->DeviceInfo[i].DeviceObject = Relations->Objects[i];

        //
        // Get the inquiry data for this device.
        //
        status = MPSPGetDeviceInfo(deviceExtension,
                                   Relations->Objects[i],
                                   StorageDeviceProperty,
                                   &header);


        if (NT_SUCCESS(status)) {
            descriptor = (PSTORAGE_DEVICE_DESCRIPTOR)header;
            list->DeviceInfo[i].DeviceType = descriptor->DeviceType;

            ExFreePool(descriptor);
        } else {
            list->DeviceInfo[i].DeviceType = 0xFF;
        }    
    }

    return list;
}



NTSTATUS
MPSPQueryDeviceRelationsCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Completion routine for the query device relations irp.
    This will snoop the return buffer looking for disk devices and 
    notify mpctl if any are found.

Arguments:

    DeviceObject
    Irp
    Context

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    PDEVICE_EXTENSION deviceExtension = (PDEVICE_EXTENSION)Context;
    PDEVICE_RELATIONS deviceRelations = (PDEVICE_RELATIONS)Irp->IoStatus.Information;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = Irp->IoStatus.Status;
    ULONG i;
    BOOLEAN update = FALSE;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    if (Irp->IoStatus.Status == STATUS_SUCCESS) {
        if (irpStack->Parameters.QueryDeviceRelations.Type == BusRelations) {

            //
            // Check to see whether a list has been created already.
            //
            if (IsListEmpty(&deviceExtension->ChildList)) {

                deviceExtension->CachedList = MPSPBuildCachedList(DeviceObject,
                                                                  deviceRelations);
                                                             
                //
                // Indicate number of children being returned.
                //
                deviceExtension->NumberChildren = deviceRelations->Count;

                //
                // Save off the necessary information.
                // 
                status = MPSPBuildDeviceList(deviceExtension,
                                             deviceRelations);

                Irp->IoStatus.Status = status;

                if (deviceExtension->NumberDiskDevices) {

                    //
                    // Indicate that the completion routine should
                    // tell mpio about this.
                    //
                    deviceExtension->MPCFlags |= MPCFLAG_DEVICE_NOTIFICATION;

                    //
                    // There are disk devices present, so hand these
                    // to mpctl
                    //
                    //status = MPSPNotifyCtl(deviceExtension);
                }

            } else {

                ExFreePool(deviceExtension->CachedList);
                deviceExtension->CachedList = MPSPBuildCachedList(DeviceObject,
                                                                  deviceRelations);

                //
                // Compare and merge lists.
                //
                deviceExtension->NumberChildren = deviceRelations->Count;

                //
                // Run through the list and find additions/deletions. 
                //
                status = MPSPMergeList(DeviceObject,
                                       deviceRelations,
                                       &update);
                //
                // If devices arrived or were removed, inform mpctl of the 
                // changes.
                //
                if (NT_SUCCESS(status) && update) {
                    deviceExtension->MPCFlags |= MPCFLAG_DEVICE_NOTIFICATION;
                }
            }
        }
    }
    
    KeSetEvent(&deviceExtension->Event, 
               0,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
MPSPMergeList(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_RELATIONS NewRelations,
    IN OUT PBOOLEAN NeedUpdate
    )
/*++

Routine Description:

    This routine handles comparing and merging of our list of children based on
    old vs. new device relations.

Arguments:

    DeviceObject - Our device Object.
    NewRelations - New device relations buffer.

Return Value:

    Status of the operations.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PFLTR_DEVICE_ENTRY deviceEntry;
    PDEVICE_RELATIONS tmpRelations;
    ULONG matchedDevices = 0;
    ULONG currentDiskDevices;
    ULONG newDeviceCount;
    NTSTATUS status;
    PLIST_ENTRY entry;
    KIRQL irql;
    ULONG i;
    ULONG j;
    BOOLEAN deviceFound = FALSE;
    BOOLEAN deviceRemoved = FALSE;

    //
    // Setup bitmask of available devices.
    //
    newDeviceCount = NewRelations->Count;
    for (i = 0; i < NewRelations->Count; i++) {
        matchedDevices |= (1 << i);
    }

    //
    // Check to see whether the new objects are in the current list.
    //
    for (entry = deviceExtension->ChildList.Flink; 
         entry != &deviceExtension->ChildList; 
         entry = entry->Flink) {

        deviceEntry = CONTAINING_RECORD(entry, FLTR_DEVICE_ENTRY, ListEntry);

        //
        // Run through the relations objects to see if there's a match.
        //
        for (i = 0, deviceFound = FALSE; i < NewRelations->Count; i++) {

            if (deviceEntry->DeviceObject == NewRelations->Objects[i]) {

                //
                // found the entry, indicate as such.
                //
                deviceFound = TRUE;
                matchedDevices &= ~(1 << i);
                newDeviceCount--;
                break;
            }
        }

        if (deviceFound == FALSE) {

            //
            // Used to indicate that a device has been removed
            // so that the caller can update MPCtl's list.
            //
            deviceRemoved = TRUE;
            
            // 
            // A device that was present has been removed.
            // Free the child's allocations
            //
            ExFreePool(deviceEntry->Descriptor);

            //
            // Remove this entry from our list.
            //
            KeAcquireSpinLock(&deviceExtension->ListLock, &irql);
            RemoveEntryList(entry);
            deviceExtension->NumberDiskDevices--;
            KeReleaseSpinLock(&deviceExtension->ListLock, irql);
        }
    }

    if (matchedDevices) {

        i = 0;
        j = 0;
        
        //
        // Indicate that an update is needed.
        //
        *NeedUpdate = TRUE;

        //
        // Build a private DeviceRelations buffer based on the new devices.
        //
        tmpRelations = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS) + 
                                                 (sizeof(PDEVICE_OBJECT) * (newDeviceCount - 1)));
        tmpRelations->Count = newDeviceCount;
       
        //
        // Run through all the new devices and fill in the rest
        // of the device relations struct.
        //
        while (newDeviceCount) {

            if (matchedDevices & (1 << i)) {

                //
                // Indicates that earlier, a match couldn't be found (it's a new device).
                // Jam it's deviceObject into the array.
                //
                tmpRelations->Objects[j] = NewRelations->Objects[i];
                j++;
                newDeviceCount--;
            }
            
            //
            // Go to next device.
            //
            i++;
        }

        //
        // Save off the current number of disks.
        // 
        currentDiskDevices = deviceExtension->NumberDiskDevices;
       
        //
        // Add disk entries to the device list if there are any. 
        //
        status = MPSPBuildDeviceList(deviceExtension,
                                     tmpRelations);
        
        //
        // If nothing was removed, and the number of disks remains the same
        // then no update is necessary.
        //
        if ((currentDiskDevices == deviceExtension->NumberDiskDevices) &&
            (deviceRemoved == FALSE)) {

            *NeedUpdate = FALSE;
        }

        //
        // Free the deviceRelations buffer.
        //
        ExFreePool(tmpRelations);
        
    } else {

        *NeedUpdate = deviceRemoved;
        status = STATUS_SUCCESS;
    }

    return status;
}


NTSTATUS
MPSPNotifyCtl(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    This routine handles notification of events to mpctl.sys

Arguments:

    DeviceExtension - This device extension

Return Value:

    Status of the operations.

--*/
{
    PFLTR_DEVICE_ENTRY deviceEntry;
    PADP_DEVICE_LIST deviceList;
    PLIST_ENTRY entry;
    ULONG allocationLength;
    NTSTATUS status;
    KIRQL irql;
    ULONG i;

    if (DeviceExtension->MPCFlags & MPCFLAG_DEVICE_NOTIFICATION) {
        DeviceExtension->MPCFlags &= ~MPCFLAG_DEVICE_NOTIFICATION;
    } else {
        return STATUS_SUCCESS;
    }    

    //
    // Determine the allocation size.
    //
    allocationLength = sizeof(ADP_DEVICE_LIST);
    allocationLength += sizeof(ADP_DEVICE_INFO) * (DeviceExtension->NumberDiskDevices - 1);

    //
    // Allocate a buffer and zero it.
    //
    deviceList = ExAllocatePool(NonPagedPool, allocationLength);
    RtlZeroMemory(deviceList, allocationLength);

    //
    // Grab the list spinlock.
    //
    KeAcquireSpinLock(&DeviceExtension->ListLock, &irql);

    //
    // Indicate the number of DeviceList entries.
    //
    deviceList->NumberDevices = DeviceExtension->NumberDiskDevices;

    //
    // Run the list and extract each of the device objects.
    //
    for (entry = DeviceExtension->ChildList.Flink, i = 0; 
         entry != &DeviceExtension->ChildList; 
         entry = entry->Flink, i++) {

        //
        // Get the device entry and setup the entry for mpctl.
        //
        deviceEntry = CONTAINING_RECORD(entry, FLTR_DEVICE_ENTRY, ListEntry);
#if 0

        if (deviceEntry->Descriptor->SerialNumberOffset == (ULONG)-1) {
            MPDebugPrint((0,
                          "NotifyControl: Getting Serial Number for %x\n",
                          deviceEntry->DeviceObject));
            deviceEntry->Descriptor = MPSPBuildDeviceDescriptor(deviceEntry->DeviceObject,
                                                                deviceEntry->Descriptor);
        }
#endif
        
        deviceList->DeviceList[i].DeviceObject = deviceEntry->DeviceObject;
        deviceList->DeviceList[i].DeviceDescriptor = deviceEntry->Descriptor;
        deviceList->DeviceList[i].DeviceIdList = deviceEntry->DeviceIdPages;

        ASSERT(i < DeviceExtension->NumberDiskDevices);
    }

    KeReleaseSpinLock(&DeviceExtension->ListLock, irql);

    //
    // Call mpctl with the information.
    //
    status = DeviceExtension->DeviceNotify(DeviceExtension->ControlObject,
                                           DeviceExtension->DeviceObject,
                                           DeviceExtension->TargetDevice,
                                           deviceList);
    return status;
}


NTSTATUS
MPSPQueryDeviceIDCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Completion routine for the query device id irp.
    This will snoop the return buffer looking for GenDisk and 
    updating that to GMPDisk

Arguments:

    DeviceObject
    Irp
    Context

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    PDEVICE_EXTENSION deviceExtension = (PDEVICE_EXTENSION)Context;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PWCHAR hardwareIds;
    PWCHAR diskId;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    if (Irp->IoStatus.Status == STATUS_SUCCESS) {

        //
        // The Information field has the buffer that scsiport built.
        //
        (ULONG_PTR)hardwareIds = Irp->IoStatus.Information;

        //
        // Need to iterate through, looking for GenDisk.
        //
        diskId = wcsstr(hardwareIds, L"GenDisk");
        if (diskId != NULL) {
            wcscpy(diskId, L"GMPDisk");
        }
        
    }
    
    KeSetEvent(&deviceExtension->Event, 
               0,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
MPSPQueryID(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;

    if (irpStack->Parameters.QueryId.IdType == BusQueryHardwareIDs) {
        
        //
        // Mark pending.
        //
        IoMarkIrpPending(Irp);

        //
        // Move the stack.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);

        //
        // Set the completion routine. This will be where the real work happens.
        //
        IoSetCompletionRoutine(Irp,
                               MPSPQueryDeviceIDCompletion,
                               deviceExtension,
                               TRUE,
                               TRUE,
                               TRUE);
        //
        // Send the request to port.
        //
        status = IoCallDriver(deviceExtension->TargetDevice, Irp);

        if (status == STATUS_PENDING) {

            KeWaitForSingleObject(&deviceExtension->Event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
            status = Irp->IoStatus.Status;
        }

        //
        // Complete the request and return
        //
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        
    } else {

        //
        // Not touching any of the rest, so just send it down.
        //
        status = MPSPSendToNextDriver(DeviceObject, Irp);
    }        
    return status;
}


NTSTATUS
MPSPRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handles necessary items to delete this device.

Arguments:

    DeviceObject    - Supplies the device object.
    Irp             - Supplies the I/O request packet.

Return Value:

    Status of the operations.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    MPDebugPrint((0,
                "MPSPRemoveDevice: Removing (%x)\n",
                DeviceObject));

    //
    // Send a notification to mpctl
    // TODO

    //
    // Clone the stack location.
    //
    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // Setup the completion routine. It will set the event that we wait on below.
    //
    IoSetCompletionRoutine(Irp, 
                           MPSPSyncCompletion,
                           deviceExtension,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // Call port with the request.
    //
    status = IoCallDriver(deviceExtension->TargetDevice, Irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&deviceExtension->Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        status = Irp->IoStatus.Status;
    }

    //
    // Detach from the port device object.
    //
    IoDetachDevice(deviceExtension->TargetDevice);

    //
    // Commit suicide.
    //
    IoDeleteDevice(DeviceObject);

    return status;
}


NTSTATUS
MPSPSyncCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Completion routine for sync forwarding of Irps.

Arguments:

    DeviceObject
    Irp
    Context

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    PDEVICE_EXTENSION deviceExtension = (PDEVICE_EXTENSION)Context;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;

    UNREFERENCED_PARAMETER(DeviceObject);

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //
    // Set the event on which the dispatch handler is waiting.
    //
    KeSetEvent(&deviceExtension->Event, 
               0,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;

}


NTSTATUS
MPSPGetDeviceInfo(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PDEVICE_OBJECT ChildDevice,
    IN STORAGE_PROPERTY_ID PropertyId,
    OUT PSTORAGE_DESCRIPTOR_HEADER *Descriptor
    )
/*++

Routine Description:

    This routine issues an inquiry to the Child device and returns
    the info in the buffer provided.

Arguments:

    DeviceExtension
    ChildDevice - Device Object for a scsiport child returned in QDR.
    InquiryData - Caller supplied buffer for the inquiry data.

Return Value:

    Status of the request

--*/
{
    PSTORAGE_DESCRIPTOR_HEADER descriptor = NULL;
    STORAGE_PROPERTY_QUERY query;
    IO_STATUS_BLOCK   ioStatus;
    KEVENT   event;
    NTSTATUS status;
    ULONG length = sizeof(STORAGE_DESCRIPTOR_HEADER);
    ULONG i;
    PIRP irp;



    status = MPLIBGetDescriptor(ChildDevice,
                                &PropertyId,
                                Descriptor);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\newft\ftdisk.h ===
/*++

Copyright (C) 1991-5 Microsoft Corporation

Module Name:

    ftdisk.h

Abstract:

    These are the structures that FtDisk driver
    uses to support IO to NTFT volumes.

Notes:

Revision History:

--*/

extern "C" {
    #include "stdio.h"
    #include <ntdskreg.h>
    #include <ntddft.h>
    #include <ntddft2.h>
    #include <ntdddisk.h>
    #include "ftlog.h"
    #include <wdmguid.h>
    #include <devguid.h>
    #include <stdarg.h>
    #include <volmgr.h>
    #include <mountdev.h>
    #include <ntddvol.h>
    #include <wmilib.h>
}

#if DBG

extern "C" {
    VOID
    FtDebugPrint(
        ULONG  DebugPrintLevel,
        PCCHAR DebugMessage,
        ...
        );

    extern ULONG FtDebug;
}

#define DebugPrint(X) FtDebugPrint X
#else
#define DebugPrint(X)
#endif // DBG

#ifdef POOL_TAGGING
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'tFcS')
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,'tFcS')

#define FTDISK_TAG_IOCTL_BUFFER 'iFcS'

#endif

#define STRIPE_SIZE ((ULONG) 0x00010000)

#define DISK_REGISTRY_KEY_W     L"\\Registry\\Machine\\System\\DISK"
#define FT_STATE_REGISTRY_KEY   L"\\Registry\\Machine\\System\\DISK\\FtState"

//
// NEC98 machines have drive-letter A and B which are non FD too.
//
#define FirstDriveLetter (IsNEC_98 ? 'A' : 'C')
#define LastDriveLetter  'Z'

class TRANSFER_PACKET;
typedef TRANSFER_PACKET* PTRANSFER_PACKET;

typedef
VOID
(*FT_TRANSFER_COMPLETION_ROUTINE)(
    IN  PTRANSFER_PACKET    TransferPacket
    );

typedef
VOID
(*FT_COMPLETION_ROUTINE)(
    IN  PVOID       Context,
    IN  NTSTATUS    Status
    );

class FT_VOLUME;
typedef FT_VOLUME* PFT_VOLUME;

typedef struct _FT_COMPLETION_ROUTINE_CONTEXT {
    KSPIN_LOCK              SpinLock;
    NTSTATUS                Status;
    LONG                    RefCount;
    FT_COMPLETION_ROUTINE   CompletionRoutine;
    PVOID                   Context;
    PFT_VOLUME              ParentVolume;
} FT_COMPLETION_ROUTINE_CONTEXT, *PFT_COMPLETION_ROUTINE_CONTEXT;

class FT_BASE_CLASS;
typedef FT_BASE_CLASS* PFT_BASE_CLASS;
class FT_BASE_CLASS {

    public:

        static
        PVOID
        operator new(
            IN  size_t    Size
            );

        static
        VOID
        operator delete(
            IN  PVOID   MemPtr
            );

};

class VOLUME_EXTENSION;
typedef VOLUME_EXTENSION* PVOLUME_EXTENSION;

class ROOT_EXTENSION;
typedef ROOT_EXTENSION* PROOT_EXTENSION;

#include <ondisk.hxx>

class TRANSFER_PACKET : public FT_BASE_CLASS {

    public:

        static
        PVOID
        operator new(
            IN  size_t    Size
            );

        static
        VOID
        operator delete(
            IN  PVOID   MemPtr
            );

        TRANSFER_PACKET(
            ) { _freeMdl = FALSE; _freeBuffer = FALSE; SpecialRead = 0;
                OriginalIrp = NULL; };

        virtual
        ~TRANSFER_PACKET(
            );

        BOOLEAN
        AllocateMdl(
            IN  PVOID   Buffer,
            IN  ULONG   Length
            );

        BOOLEAN
        AllocateMdl(
            IN  ULONG   Length
            );

        VOID
        FreeMdl(
            );

        // These fields must be filled in by the caller.

        PMDL                            Mdl;
        PIRP                            OriginalIrp;
        ULONG                           Length;
        LONGLONG                        Offset;
        FT_TRANSFER_COMPLETION_ROUTINE  CompletionRoutine;
        PFT_VOLUME                      TargetVolume;
        PETHREAD                        Thread;
        UCHAR                           IrpFlags;
        BOOLEAN                         ReadPacket;
        UCHAR                           SpecialRead;

        // A spin lock which may be used to resolve contention for the
        // fields below.  This spin lock must be initialized by the callee.

        KSPIN_LOCK                      SpinLock;

        // This field must be filled in by the callee.

        IO_STATUS_BLOCK                 IoStatus;

        // These fields are for use by the callee.

        LONG                            RefCount;
        LIST_ENTRY                      QueueEntry;

    private:

        BOOLEAN _freeMdl;
        BOOLEAN _freeBuffer;
        UCHAR   _allocationType;

};

#define TP_SPECIAL_READ_PRIMARY     (1)
#define TP_SPECIAL_READ_SECONDARY   (2)

#define TP_ALLOCATION_STRIPE_POOL   (1)
#define TP_ALLOCATION_MIRROR_POOL   (2)

class DISPATCH_TP;
typedef DISPATCH_TP* PDISPATCH_TP;
class DISPATCH_TP : public TRANSFER_PACKET {

    public:

        DISPATCH_TP(
            ) {};

        PIRP                Irp;
        PVOLUME_EXTENSION   Extension;

};

class VOLUME_SET;
typedef VOLUME_SET* PVOLUME_SET;

class VOLSET_TP;
typedef VOLSET_TP* PVOLSET_TP;
class VOLSET_TP : public TRANSFER_PACKET {

    public:

        VOLSET_TP(
            ) {};

        PTRANSFER_PACKET    MasterPacket;
        PVOLUME_SET         VolumeSet;
        USHORT              WhichMember;

};

class STRIPE;
typedef STRIPE* PSTRIPE;

class STRIPE_TP;
typedef STRIPE_TP* PSTRIPE_TP;
class STRIPE_TP : public TRANSFER_PACKET {

    public:

        STRIPE_TP(
            ) {};

        PTRANSFER_PACKET    MasterPacket;
        PSTRIPE             Stripe;
        USHORT              WhichMember;

};

class OVERLAPPED_IO_MANAGER;
typedef OVERLAPPED_IO_MANAGER* POVERLAPPED_IO_MANAGER;

class OVERLAP_TP;
typedef OVERLAP_TP* POVERLAP_TP;
class OVERLAP_TP : public TRANSFER_PACKET {

    friend class OVERLAPPED_IO_MANAGER;

    public:

        OVERLAP_TP(
            ) { InQueue = FALSE; };

        virtual
        ~OVERLAP_TP(
            );

    private:

        BOOLEAN                 AllMembers;
        BOOLEAN                 InQueue;
        LIST_ENTRY              OverlapQueue;
        LIST_ENTRY              CompletionList;
        POVERLAPPED_IO_MANAGER  OverlappedIoManager;

};

class MIRROR;
typedef MIRROR* PMIRROR;

class MIRROR_TP;
typedef MIRROR_TP* PMIRROR_TP;
class MIRROR_TP : public OVERLAP_TP {

    public:

        MIRROR_TP(
            ) { OneReadFailed = FALSE; };

        PTRANSFER_PACKET                MasterPacket;
        PMIRROR                         Mirror;
        USHORT                          WhichMember;
        BOOLEAN                         OneReadFailed;
        PMIRROR_TP                      SecondWritePacket;
        FT_TRANSFER_COMPLETION_ROUTINE  SavedCompletionRoutine;

};

class MIRROR_RECOVER_TP;
typedef MIRROR_RECOVER_TP* PMIRROR_RECOVER_TP;
class MIRROR_RECOVER_TP : public MIRROR_TP {

    public:

        MIRROR_RECOVER_TP(
            ) { PartialMdl = NULL; VerifyMdl = NULL; };

        virtual
        ~MIRROR_RECOVER_TP(
            );

        BOOLEAN
        AllocateMdls(
            IN  ULONG   Length
            );

        VOID
        FreeMdls(
            );

        PMDL    PartialMdl;
        PMDL    VerifyMdl;

};

class PARITY_IO_MANAGER;
typedef PARITY_IO_MANAGER* PPARITY_IO_MANAGER;

class PARITY_TP;
typedef PARITY_TP* PPARITY_TP;
class PARITY_TP : public TRANSFER_PACKET {

    friend class PARITY_IO_MANAGER;

    friend
    VOID
    UpdateParityCompletionRoutine(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    ParityCarefulWritePhase1(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    public:

        PARITY_TP(
            ) {};

    private:

        BOOLEAN                         Idle;
        BOOLEAN                         OneWriteFailed;
        LIST_ENTRY                      OverlapQueue;
        LIST_ENTRY                      UpdateQueue;
        PPARITY_IO_MANAGER              ParityIoManager;
        LONGLONG                        BucketNumber;

};

class PARITY_RECOVER_TP;
typedef PARITY_RECOVER_TP* PPARITY_RECOVER_TP;
class PARITY_RECOVER_TP : public PARITY_TP {

    public:

        PARITY_RECOVER_TP(
            ) {};

        PPARITY_TP  MasterPacket;

};

class STRIPE_WP;
typedef STRIPE_WP* PSTRIPE_WP;

class SWP_TP;
typedef SWP_TP* PSWP_TP;
class SWP_TP : public OVERLAP_TP {

    public:

        SWP_TP(
            ) {};

        PTRANSFER_PACKET                MasterPacket;
        PSTRIPE_WP                      StripeWithParity;
        USHORT                          WhichMember;
        FT_TRANSFER_COMPLETION_ROUTINE  SavedCompletionRoutine;
        BOOLEAN                         OneReadFailed;

};

class SWP_RECOVER_TP;
typedef SWP_RECOVER_TP* PSWP_RECOVER_TP;
class SWP_RECOVER_TP : public SWP_TP {

    public:

        SWP_RECOVER_TP(
            ) { PartialMdl = NULL; VerifyMdl = NULL; };

        virtual
        ~SWP_RECOVER_TP(
            );

        BOOLEAN
        AllocateMdls(
            IN  ULONG   Length
            );

        VOID
        FreeMdls(
            );

        PMDL        PartialMdl;
        PMDL        VerifyMdl;
        PARITY_TP   ParityPacket;

};

class SWP_WRITE_TP;
typedef SWP_WRITE_TP* PSWP_WRITE_TP;
class SWP_WRITE_TP : public SWP_TP {

    public:

        SWP_WRITE_TP(
            ) { ReadAndParityMdl = NULL; WriteMdl = NULL; };

        virtual
        ~SWP_WRITE_TP(
            );

        BOOLEAN
        AllocateMdls(
            IN  ULONG   Length
            );

        VOID
        FreeMdls(
            );

        PMDL            ReadAndParityMdl;
        PMDL            WriteMdl;
        FT_MEMBER_STATE TargetState;
        USHORT          ParityMember;
        SWP_TP          ReadWritePacket;
        PARITY_TP       ParityPacket;

};

class SWP_REGENERATE_TP;
typedef SWP_REGENERATE_TP *PSWP_REGENERATE_TP;
class SWP_REGENERATE_TP : public TRANSFER_PACKET {

    public:

        SWP_REGENERATE_TP(
            ) {};

        PSWP_TP     MasterPacket;
        USHORT      WhichMember;
        LIST_ENTRY  RegenPacketList;

};

class SWP_REBUILD_TP;
typedef SWP_REBUILD_TP *PSWP_REBUILD_TP;
class SWP_REBUILD_TP : public SWP_TP {

    public:

        SWP_REBUILD_TP(
            ) {};

        PFT_COMPLETION_ROUTINE_CONTEXT  Context;
        BOOLEAN                         Initialize;

};

class REDISTRIBUTION;
typedef REDISTRIBUTION *PREDISTRIBUTION;

class REDISTRIBUTION_TP;
typedef REDISTRIBUTION_TP* PREDISTRIBUTION_TP;
class REDISTRIBUTION_TP : public TRANSFER_PACKET {

    public:

        REDISTRIBUTION_TP(
            ) {};

        PTRANSFER_PACKET        MasterPacket;
        PREDISTRIBUTION         Redistribution;
        USHORT                  WhichMember;

};

class REDISTRIBUTION_LOCK_TP;
typedef REDISTRIBUTION_LOCK_TP* PREDISTRIBUTION_LOCK_TP;
class REDISTRIBUTION_LOCK_TP : public OVERLAP_TP {

    public:

        REDISTRIBUTION_LOCK_TP(
            ) {};

        PTRANSFER_PACKET    MasterPacket;
        PREDISTRIBUTION     Redistribution;

};

class REDISTRIBUTION_SYNC_TP;
typedef REDISTRIBUTION_SYNC_TP* PREDISTRIBUTION_SYNC_TP;
class REDISTRIBUTION_SYNC_TP : public OVERLAP_TP {

    public:

        REDISTRIBUTION_SYNC_TP(
            ) {};

        PFT_COMPLETION_ROUTINE_CONTEXT  Context;
        PREDISTRIBUTION                 Redistribution;
        REDISTRIBUTION_TP               IoPacket;

};

class REDISTRIBUTION_CW_TP;
typedef REDISTRIBUTION_CW_TP* PREDISTRIBUTION_CW_TP;
class REDISTRIBUTION_CW_TP : public REDISTRIBUTION_TP {

    public:

        REDISTRIBUTION_CW_TP(
            ) { PartialMdl = NULL; VerifyMdl = NULL; };

        virtual
        ~REDISTRIBUTION_CW_TP(
            );

        BOOLEAN
        AllocateMdls(
            IN  ULONG   Length
            );

        VOID
        FreeMdls(
            );

        PMDL    PartialMdl;
        PMDL    VerifyMdl;

};

class OVERLAPPED_IO_MANAGER : public FT_BASE_CLASS {

    public:

        NTSTATUS
        Initialize(
            IN  ULONG   BucketSize
            );

        VOID
        AcquireIoRegion(
            IN OUT  POVERLAP_TP TransferPacket,
            IN      BOOLEAN     AllMembers
            );

        VOID
        ReleaseIoRegion(
            IN OUT  POVERLAP_TP TransferPacket
            );

        VOID
        PromoteToAllMembers(
            IN OUT  POVERLAP_TP TransferPacket
            );

        OVERLAPPED_IO_MANAGER(
            ) { _spinLock = NULL; _ioQueue = NULL; };

        ~OVERLAPPED_IO_MANAGER(
            );

    private:

        ULONG       _numQueues;
        ULONG       _bucketSize;
        PKSPIN_LOCK _spinLock;
        PLIST_ENTRY _ioQueue;

};

class PARITY_IO_MANAGER : public FT_BASE_CLASS {

    friend
    VOID
    UpdateParityCompletionRoutine(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    ParityCarefulWritePhase1(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    public:

        NTSTATUS
        Initialize(
            IN  ULONG   BucketSize,
            IN  ULONG   SectorSize
            );

        VOID
        StartReadForUpdateParity(
            IN  LONGLONG    Offset,
            IN  ULONG       Length,
            IN  PFT_VOLUME  TargetVolume,
            IN  PETHREAD    Thread,
            IN  UCHAR       IrpFlags
            );

        VOID
        UpdateParity(
            IN OUT  PPARITY_TP  TransferPacket
            );

        PARITY_IO_MANAGER(
            ) { _spinLock = NULL; _ioQueue = NULL; _ePacket = NULL; };

        ~PARITY_IO_MANAGER(
            );

    private:

        VOID
        CarefulWrite(
            IN OUT  PPARITY_TP  TransferPacket
            );

        ULONG       _numQueues;
        ULONG       _bucketSize;
        ULONG       _sectorSize;
        PKSPIN_LOCK _spinLock;
        PLIST_ENTRY _ioQueue;

        //
        // Emergency packet.
        //

        PPARITY_TP  _ePacket;
        BOOLEAN     _ePacketInUse;
        BOOLEAN     _ePacketQueueBeingServiced;
        LIST_ENTRY  _ePacketQueue;
        KSPIN_LOCK  _ePacketSpinLock;

};

class PARTITION;
typedef PARTITION* PPARTITION;

class FT_VOLUME : public FT_BASE_CLASS {

    friend
    VOID
    SetMemberStateWorker(
        IN  PVOID   Context
        );

    friend
    VOID
    FtVolumeNotifyWorker(
        IN  PVOID   FtVolume
        );

    public:

        VOID
        Initialize(
            IN OUT  PROOT_EXTENSION     RootExtension,
            IN      FT_LOGICAL_DISK_ID  LogicalDiskId
            );

        FT_LOGICAL_DISK_ID
        QueryLogicalDiskId(
            );

        VOID
        SetLogicalDiskId(
            IN  FT_LOGICAL_DISK_ID  NewLogicalDiskId
            );

        virtual
        VOID
        Notify(
            );

        virtual
        FT_LOGICAL_DISK_TYPE
        QueryLogicalDiskType(
            ) = 0;

        virtual
        USHORT
        QueryNumberOfMembers(
            ) = 0;

        virtual
        PFT_VOLUME
        GetMember(
            IN  USHORT  MemberNumber
            ) = 0;

        virtual
        NTSTATUS
        OrphanMember(
            IN  USHORT                  MemberNumber,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            ) = 0;

        virtual
        NTSTATUS
        RegenerateMember(
            IN      USHORT                  MemberNumber,
            IN OUT  PFT_VOLUME              NewMember,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            ) = 0;

        virtual
        VOID
        Transfer(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            ) = 0;

        virtual
        VOID
        ReplaceBadSector(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            ) = 0;

        virtual
        VOID
        StartSyncOperations(
            IN      BOOLEAN                 RegenerateOrphans,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            ) = 0;

        virtual
        VOID
        StopSyncOperations(
            ) = 0;

        virtual
        VOID
        BroadcastIrp(
            IN  PIRP                    Irp,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            ) = 0;

        virtual
        ULONG
        QuerySectorSize(
            ) = 0;

        virtual
        LONGLONG
        QueryVolumeSize(
            ) = 0;

        virtual
        PFT_VOLUME
        GetContainedLogicalDisk(
            IN  FT_LOGICAL_DISK_ID  LogicalDiskId
            ) = 0;

        virtual
        PFT_VOLUME
        GetContainedLogicalDisk(
            IN  PDEVICE_OBJECT  TargetObject
            ) = 0;

        virtual
        PFT_VOLUME
        GetContainedLogicalDisk(
            IN  ULONG       Signature,
            IN  LONGLONG    Offset
            ) = 0;

        virtual
        PFT_VOLUME
        GetParentLogicalDisk(
            IN  PFT_VOLUME  Volume
            ) = 0;

        virtual
        VOID
        SetDirtyBit(
            IN  BOOLEAN                 IsDirty,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            ) = 0;

        virtual
        VOID
        SetMember(
            IN  USHORT      MemberNumber,
            IN  PFT_VOLUME  Member
            ) = 0;

        virtual
        BOOLEAN
        IsComplete(
            IN  BOOLEAN IoPending
            ) = 0;

        virtual
        VOID
        CompleteNotification(
            IN  BOOLEAN IoPending
            ) = 0;

        virtual
        NTSTATUS
        CheckIo(
            OUT PBOOLEAN    IsIoOk
            ) = 0;

        virtual
        ULONG
        QueryNumberOfPartitions(
            ) = 0;

        virtual
        NTSTATUS
        SetPartitionType(
            IN  UCHAR   PartitionType
            ) = 0;

        virtual
        UCHAR
        QueryPartitionType(
            ) = 0;

        virtual
        UCHAR
        QueryStackSize(
            ) = 0;

        virtual
        VOID
        CreateLegacyNameLinks(
            IN  PUNICODE_STRING DeviceName
            ) = 0;

        virtual
        BOOLEAN
        IsVolumeSuitableForRegenerate(
            IN  USHORT      MemberNumber,
            IN  PFT_VOLUME  Volume
            );

        virtual
        VOID
        NewStateArrival(
            IN  PVOID   NewStateInstance
            );

        virtual
        PDEVICE_OBJECT
        GetLeftmostPartitionObject(
            ) = 0;

        virtual
        NTSTATUS
        QueryDiskExtents(
            OUT PDISK_EXTENT*   DiskExtents,
            OUT PULONG          NumberOfDiskExtents
            ) = 0;

        virtual
        BOOLEAN
        QueryVolumeState(
            IN  PFT_VOLUME          Volume,
            OUT PFT_MEMBER_STATE    State
            ) = 0;

        virtual
        NTSTATUS
        QueryPhysicalOffsets(
            IN  LONGLONG                    LogicalOffset,
            OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
            OUT PULONG                      NumberOfPhysicalOffsets
            ) = 0;

        virtual
        NTSTATUS
        QueryLogicalOffset(
            IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
            OUT PLONGLONG               LogicalOffset
            ) = 0;

        virtual
        VOID
        ModifyStateForUser(
            IN OUT  PVOID   State
            );

        virtual
        ~FT_VOLUME(
            );

        FT_VOLUME(
            ) { _refCount = 1; };

        LONG                                _refCount;

    protected:

        KSPIN_LOCK                          _spinLock;
        PFT_LOGICAL_DISK_INFORMATION_SET    _diskInfoSet;
        PROOT_EXTENSION                     _rootExtension;

    private:

        FT_LOGICAL_DISK_ID                  _logicalDiskId;

};

#define TRANSFER(a) ((a)->TargetVolume->Transfer((a)))

class PARTITION : public FT_VOLUME {

    friend
    NTSTATUS
    PartitionTransferCompletionRoutine(
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PIRP            Irp,
        IN  PVOID           TransferPacket
        );

    public:

        PARTITION(
            ) { _emergencyIrp = NULL; };

        virtual
        ~PARTITION(
            );

        NTSTATUS
        Initialize(
            IN OUT  PROOT_EXTENSION     RootExtension,
            IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
            IN OUT  PDEVICE_OBJECT      TargetObject,
            IN OUT  PDEVICE_OBJECT      WholeDiskPdo
            );

        virtual
        FT_LOGICAL_DISK_TYPE
        QueryLogicalDiskType(
            );

        virtual
        USHORT
        QueryNumberOfMembers(
            );

        virtual
        PFT_VOLUME
        GetMember(
            IN  USHORT  MemberNumber
            );

        virtual
        NTSTATUS
        OrphanMember(
            IN  USHORT                  MemberNumber,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        virtual
        NTSTATUS
        RegenerateMember(
            IN      USHORT                  MemberNumber,
            IN OUT  PFT_VOLUME              NewMember,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            );

        virtual
        VOID
        Transfer(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        VOID
        ReplaceBadSector(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        VOID
        StartSyncOperations(
            IN      BOOLEAN                 RegenerateOrphans,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            );

        virtual
        VOID
        StopSyncOperations(
            );

        virtual
        VOID
        BroadcastIrp(
            IN  PIRP                    Irp,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        virtual
        ULONG
        QuerySectorSize(
            );

        virtual
        LONGLONG
        QueryVolumeSize(
            );

        virtual
        PFT_VOLUME
        GetContainedLogicalDisk(
            IN  FT_LOGICAL_DISK_ID  LogicalDiskId
            );

        virtual
        PFT_VOLUME
        GetContainedLogicalDisk(
            IN  PDEVICE_OBJECT  TargetObject
            );

        virtual
        PFT_VOLUME
        GetContainedLogicalDisk(
            IN  ULONG       Signature,
            IN  LONGLONG    Offset
            );

        virtual
        PFT_VOLUME
        GetParentLogicalDisk(
            IN  PFT_VOLUME  Volume
            );

        virtual
        VOID
        SetDirtyBit(
            IN  BOOLEAN                 IsDirty,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        virtual
        VOID
        SetMember(
            IN  USHORT      MemberNumber,
            IN  PFT_VOLUME  Member
            );

        virtual
        BOOLEAN
        IsComplete(
            IN  BOOLEAN IoPending
            );

        virtual
        VOID
        CompleteNotification(
            IN  BOOLEAN IoPending
            );

        virtual
        NTSTATUS
        CheckIo(
            OUT PBOOLEAN    IsIoOk
            );

        virtual
        ULONG
        QueryNumberOfPartitions(
            );

        virtual
        NTSTATUS
        SetPartitionType(
            IN  UCHAR   PartitionType
            );

        virtual
        UCHAR
        QueryPartitionType(
            );

        virtual
        UCHAR
        QueryStackSize(
            );

        virtual
        VOID
        CreateLegacyNameLinks(
            IN  PUNICODE_STRING DeviceName
            );

        virtual
        PDEVICE_OBJECT
        GetLeftmostPartitionObject(
            );

        virtual
        NTSTATUS
        QueryDiskExtents(
            OUT PDISK_EXTENT*   DiskExtents,
            OUT PULONG          NumberOfDiskExtents
            );

        virtual
        BOOLEAN
        QueryVolumeState(
            IN  PFT_VOLUME          Volume,
            OUT PFT_MEMBER_STATE    State
            );

        virtual
        NTSTATUS
        QueryPhysicalOffsets(
            IN  LONGLONG                    LogicalOffset,
            OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
            OUT PULONG                      NumberOfPhysicalOffsets
            );

        virtual
        NTSTATUS
        QueryLogicalOffset(
            IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
            OUT PLONGLONG               LogicalOffset
            );

        PDEVICE_OBJECT
        GetTargetObject(
            ) { return _targetObject; };

        PDEVICE_OBJECT
        GetWholeDiskPdo(
            ) { return _wholeDiskPdo; };

    private:

        PDEVICE_OBJECT  _targetObject;
        PDEVICE_OBJECT  _wholeDiskPdo;
        ULONG           _sectorSize;
        LONGLONG        _partitionOffset;
        LONGLONG        _partitionLength;

        PIRP            _emergencyIrp;
        BOOLEAN         _emergencyIrpInUse;
        LIST_ENTRY      _emergencyIrpQueue;

};

class COMPOSITE_FT_VOLUME;
typedef COMPOSITE_FT_VOLUME *PCOMPOSITE_FT_VOLUME;
class COMPOSITE_FT_VOLUME : public FT_VOLUME {

    public:

        virtual
        NTSTATUS
        Initialize(
            IN OUT  PROOT_EXTENSION     RootExtension,
            IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
            IN OUT  PFT_VOLUME*         VolumeArray,
            IN      USHORT              ArraySize,
            IN      PVOID               ConfigInfo,
            IN      PVOID               StateInfo
            );

        virtual
        FT_LOGICAL_DISK_TYPE
        QueryLogicalDiskType(
            ) = 0;

        virtual
        USHORT
        QueryNumberOfMembers(
            );

        virtual
        PFT_VOLUME
        GetMember(
            IN  USHORT  MemberNumber
            );

        virtual
        NTSTATUS
        OrphanMember(
            IN  USHORT                  MemberNumber,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        virtual
        NTSTATUS
        RegenerateMember(
            IN      USHORT                  MemberNumber,
            IN OUT  PFT_VOLUME              NewMember,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            );

        virtual
        VOID
        Transfer(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            ) = 0;

        virtual
        VOID
        ReplaceBadSector(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            ) = 0;

        virtual
        VOID
        StartSyncOperations(
            IN      BOOLEAN                 RegenerateOrphans,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            );

        virtual
        VOID
        StopSyncOperations(
            );

        virtual
        VOID
        BroadcastIrp(
            IN  PIRP                    Irp,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        virtual
        ULONG
        QuerySectorSize(
            );

        virtual
        LONGLONG
        QueryVolumeSize(
            ) = 0;

        virtual
        PFT_VOLUME
        GetContainedLogicalDisk(
            IN  FT_LOGICAL_DISK_ID  LogicalDiskId
            );

        virtual
        PFT_VOLUME
        GetContainedLogicalDisk(
            IN  PDEVICE_OBJECT  TargetObject
            );

        virtual
        PFT_VOLUME
        GetContainedLogicalDisk(
            IN  ULONG       Signature,
            IN  LONGLONG    Offset
            );

        virtual
        PFT_VOLUME
        GetParentLogicalDisk(
            IN  PFT_VOLUME  Volume
            );

        virtual
        VOID
        SetDirtyBit(
            IN  BOOLEAN                 IsDirty,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        virtual
        VOID
        SetMember(
            IN  USHORT      MemberNumber,
            IN  PFT_VOLUME  Member
            );

        virtual
        BOOLEAN
        IsComplete(
            IN  BOOLEAN IoPending
            );

        virtual
        VOID
        CompleteNotification(
            IN  BOOLEAN IoPending
            );

        virtual
        NTSTATUS
        CheckIo(
            OUT PBOOLEAN    IsIoOk
            ) = 0;

        virtual
        ULONG
        QueryNumberOfPartitions(
            );

        virtual
        NTSTATUS
        SetPartitionType(
            IN  UCHAR   PartitionType
            );

        virtual
        UCHAR
        QueryPartitionType(
            );

        virtual
        UCHAR
        QueryStackSize(
            );

        virtual
        VOID
        CreateLegacyNameLinks(
            IN  PUNICODE_STRING DeviceName
            );

        virtual
        PDEVICE_OBJECT
        GetLeftmostPartitionObject(
            );

        virtual
        NTSTATUS
        QueryDiskExtents(
            OUT PDISK_EXTENT*   DiskExtents,
            OUT PULONG          NumberOfDiskExtents
            );

        virtual
        BOOLEAN
        QueryVolumeState(
            IN  PFT_VOLUME          Volume,
            OUT PFT_MEMBER_STATE    State
            );

        virtual
        NTSTATUS
        QueryPhysicalOffsets(
            IN  LONGLONG                    LogicalOffset,
            OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
            OUT PULONG                      NumberOfPhysicalOffsets
            ) = 0;

        virtual
        NTSTATUS
        QueryLogicalOffset(
            IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
            OUT PLONGLONG               LogicalOffset
            ) = 0;

        COMPOSITE_FT_VOLUME(
           ) { _volumeArray = NULL; };

        virtual
        ~COMPOSITE_FT_VOLUME(
            );

    protected:

        PFT_VOLUME
        GetMemberUnprotected(
            IN  USHORT  MemberNumber
            ) { return _volumeArray[MemberNumber]; };

        VOID
        SetMemberUnprotected(
            IN  USHORT      MemberNumber,
            IN  PFT_VOLUME  NewVolume
            ) { _volumeArray[MemberNumber] = NewVolume; };

        USHORT
        QueryNumMembers(
            ) { return _arraySize; };

        VOID
        SetSectorSize(
            IN  ULONG   SectorSize
            ) { _sectorSize = SectorSize; };

    private:

        PFT_VOLUME* _volumeArray;
        USHORT      _arraySize;
        ULONG       _sectorSize;

};

class VOLUME_SET : public COMPOSITE_FT_VOLUME {

    friend
    VOID
    VolsetTransferSequentialCompletionRoutine(
        IN  PTRANSFER_PACKET    TransferPacket
        );

    public:

        VOLUME_SET(
            ) { _ePacket = NULL; };

        virtual
        ~VOLUME_SET(
            );

        virtual
        NTSTATUS
        Initialize(
            IN OUT  PROOT_EXTENSION     RootExtension,
            IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
            IN OUT  PFT_VOLUME*         VolumeArray,
            IN      USHORT              ArraySize,
            IN      PVOID               ConfigInfo,
            IN      PVOID               StateInfo
            );

        virtual
        FT_LOGICAL_DISK_TYPE
        QueryLogicalDiskType(
            );

        virtual
        VOID
        Transfer(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        VOID
        ReplaceBadSector(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        LONGLONG
        QueryVolumeSize(
            );

        virtual
        VOID
        CompleteNotification(
            IN  BOOLEAN IoPending
            );

        virtual
        NTSTATUS
        CheckIo(
            OUT PBOOLEAN    IsIoOk
            );

        virtual
        NTSTATUS
        QueryPhysicalOffsets(
            IN  LONGLONG                    LogicalOffset,
            OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
            OUT PULONG                      NumberOfPhysicalOffsets
            );

        virtual
        NTSTATUS
        QueryLogicalOffset(
            IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
            OUT PLONGLONG               LogicalOffset
            );

    private:

        BOOLEAN
        LaunchParallel(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        VOID
        LaunchSequential(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        LONGLONG    _volumeSize;

        PVOLSET_TP  _ePacket;
        BOOLEAN     _ePacketInUse;
        LIST_ENTRY  _ePacketQueue;

};

class STRIPE : public COMPOSITE_FT_VOLUME {

    friend
    VOID
    StripeSequentialTransferCompletionRoutine(
        IN  PTRANSFER_PACKET    TransferPacket
        );

    public:

        STRIPE(
            ) { _ePacket = NULL; };

        virtual
        ~STRIPE(
            );

        virtual
        NTSTATUS
        Initialize(
            IN OUT  PROOT_EXTENSION     RootExtension,
            IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
            IN OUT  PFT_VOLUME*         VolumeArray,
            IN      USHORT              ArraySize,
            IN      PVOID               ConfigInfo,
            IN      PVOID               StateInfo
            );

        virtual
        FT_LOGICAL_DISK_TYPE
        QueryLogicalDiskType(
            );

        virtual
        VOID
        Transfer(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        VOID
        ReplaceBadSector(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        LONGLONG
        QueryVolumeSize(
            );

        virtual
        VOID
        CompleteNotification(
            IN  BOOLEAN IoPending
            );

        virtual
        NTSTATUS
        CheckIo(
            OUT PBOOLEAN    IsIoOk
            );

        virtual
        NTSTATUS
        QueryPhysicalOffsets(
            IN  LONGLONG                    LogicalOffset,
            OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
            OUT PULONG                      NumberOfPhysicalOffsets
            );

        virtual
        NTSTATUS
        QueryLogicalOffset(
            IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
            OUT PLONGLONG               LogicalOffset
            );

    private:

        BOOLEAN
        LaunchParallel(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        VOID
        LaunchSequential(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        ULONG       _stripeSize;
        ULONG       _stripeShift;
        ULONG       _stripeMask;
        LONGLONG    _memberSize;
        LONGLONG    _volumeSize;

        PSTRIPE_TP  _ePacket;
        BOOLEAN     _ePacketInUse;
        LIST_ENTRY  _ePacketQueue;

};

class MIRROR : public COMPOSITE_FT_VOLUME {

    friend
    VOID
    FinishRegenerate(
        IN  PMIRROR                         Mirror,
        IN  PFT_COMPLETION_ROUTINE_CONTEXT  RegenContext,
        IN  PMIRROR_TP                      TransferPacket
        );

    friend
    VOID
    MirrorRegenerateCompletionRoutine(
        IN  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StartRegeneration(
        IN  PVOID       Context,
        IN  NTSTATUS    Status
        );

    friend
    VOID
    MirrorTransferCompletionRoutine(
        IN  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorRecoverPhase8(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorRecoverPhase7(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorRecoverPhase6(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorRecoverPhase5(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorRecoverPhase4(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorRecoverPhase3(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorRecoverPhase2(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorRecoverEmergencyCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorRecoverPhase1(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorMaxTransferCompletionRoutine(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorMaxTransferEmergencyCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorPropogateStateChangesWorker(
        IN  PVOID   Mirror
        );

    friend
    VOID
    MirrorCarefulWritePhase1(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorCarefulWritePhase2(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    MirrorCarefulWriteEmergencyCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    public:

        virtual
        ~MIRROR(
            );

        virtual
        NTSTATUS
        Initialize(
            IN OUT  PROOT_EXTENSION     RootExtension,
            IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
            IN OUT  PFT_VOLUME*         VolumeArray,
            IN      USHORT              ArraySize,
            IN      PVOID               ConfigInfo,
            IN      PVOID               StateInfo
            );

        virtual
        FT_LOGICAL_DISK_TYPE
        QueryLogicalDiskType(
            );

        virtual
        NTSTATUS
        OrphanMember(
            IN  USHORT                  MemberNumber,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        virtual
        NTSTATUS
        RegenerateMember(
            IN      USHORT                  MemberNumber,
            IN OUT  PFT_VOLUME              NewMember,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            );

        virtual
        VOID
        Transfer(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        VOID
        ReplaceBadSector(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        VOID
        StartSyncOperations(
            IN      BOOLEAN                 RegenerateOrphans,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            );

        virtual
        VOID
        StopSyncOperations(
            );

        virtual
        LONGLONG
        QueryVolumeSize(
            );

        virtual
        VOID
        SetDirtyBit(
            IN  BOOLEAN                 IsDirty,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        virtual
        BOOLEAN
        IsComplete(
            IN  BOOLEAN IoPending
            );

        virtual
        VOID
        CompleteNotification(
            IN  BOOLEAN IoPending
            );

        virtual
        NTSTATUS
        CheckIo(
            OUT PBOOLEAN    IsIoOk
            );

        virtual
        BOOLEAN
        IsVolumeSuitableForRegenerate(
            IN  USHORT      MemberNumber,
            IN  PFT_VOLUME  Volume
            );

        virtual
        VOID
        NewStateArrival(
            IN  PVOID   NewStateInstance
            );

        virtual
        PDEVICE_OBJECT
        GetLeftmostPartitionObject(
            );

        virtual
        BOOLEAN
        QueryVolumeState(
            IN  PFT_VOLUME          Volume,
            OUT PFT_MEMBER_STATE    State
            );

        virtual
        NTSTATUS
        QueryPhysicalOffsets(
            IN  LONGLONG                    LogicalOffset,
            OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
            OUT PULONG                      NumberOfPhysicalOffsets
            );

        virtual
        NTSTATUS
        QueryLogicalOffset(
            IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
            OUT PLONGLONG               LogicalOffset
            );

        virtual
        VOID
        ModifyStateForUser(
            IN OUT  PVOID   State
            );

        MIRROR(
            ) { _ePacket = NULL; _ePacket2 = NULL; _eRecoverPacket = NULL; };

    private:

        FT_MEMBER_STATE
        QueryMemberState(
            IN  USHORT  MemberNumber
            ) { return MemberNumber == _state.UnhealthyMemberNumber ?
                       _state.UnhealthyMemberState : FtMemberHealthy; }

        BOOLEAN
        SetMemberState(
            IN  USHORT          MemberNumber,
            IN  FT_MEMBER_STATE MemberState
            );

        BOOLEAN
        LaunchRead(
            IN OUT  PTRANSFER_PACKET    TransferPacket,
            IN OUT  PMIRROR_TP          Packet1
            );

        BOOLEAN
        LaunchWrite(
            IN OUT  PTRANSFER_PACKET    TransferPacket,
            IN OUT  PMIRROR_TP          Packet1,
            IN OUT  PMIRROR_TP          Packet2
            );

        VOID
        Recycle(
            IN OUT  PMIRROR_TP  TransferPacket,
            IN      BOOLEAN     ServiceEmergencyQueue
            );

        VOID
        Recover(
            IN OUT  PMIRROR_TP  TransferPacket
            );

        VOID
        MaxTransfer(
            IN OUT  PMIRROR_TP  TransferPacket
            );

        VOID
        PropogateStateChanges(
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        VOID
        CarefulWrite(
            IN OUT  PMIRROR_TP  TransferPacket
            );

        LONGLONG    _volumeSize;

        //
        // Keep track of requests for load balancing.
        //
        LONG _requestCount[2];
        LONGLONG _lastPosition[2];

        //
        // The dynamic state of this volume.
        //

        FT_MIRROR_AND_SWP_STATE_INFORMATION _state;
        BOOLEAN _originalDirtyBit;
        BOOLEAN _orphanedBecauseOfMissingMember;

        //
        // Indicates whether or not 'StartSyncOperations' or
        // 'RegenerateMember' is ok.
        //

        BOOLEAN _syncOk;

        //
        // Indicate whether or not balanced reads are allowed.
        //

        BOOLEAN _balancedReads;

        //
        // Indicates whether or not to stop syncs.
        //

        BOOLEAN _stopSyncs;

        //
        // Emergency packet.
        //

        PMIRROR_TP  _ePacket, _ePacket2;
        BOOLEAN     _ePacketInUse;
        LIST_ENTRY  _ePacketQueue;

        //
        // Emergency recover packet.
        //

        PMIRROR_RECOVER_TP  _eRecoverPacket;
        BOOLEAN             _eRecoverPacketInUse;
        LIST_ENTRY          _eRecoverPacketQueue;

        //
        // Overlapped io manager.
        //

        OVERLAPPED_IO_MANAGER   _overlappedIoManager;

};

class STRIPE_WP : public COMPOSITE_FT_VOLUME {

    friend
    VOID
    StripeWpSyncFinalCompletion(
        IN  PVOID       Context,
        IN  NTSTATUS    Status
        );

    friend
    VOID
    StripeWpSyncCompletionRoutine(
        IN  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StartStripeRegeneration(
        IN  PVOID       Context,
        IN  NTSTATUS    Status
        );

    friend
    VOID
    StripeWpParallelTransferCompletionRoutine(
        IN  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpSequentialTransferCompletionRoutine(
        IN  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpWritePhase31(
        IN OUT  PTRANSFER_PACKET    Packet
        );

    friend
    VOID
    StripeWpWritePhase30(
        IN OUT  PTRANSFER_PACKET    Packet
        );

    friend
    VOID
    StripeWpWriteRecover(
        IN OUT  PTRANSFER_PACKET    MasterPacket
        );

    friend
    VOID
    StripeWpWritePhase2(
        IN OUT  PTRANSFER_PACKET    ReadPacket
        );

    friend
    VOID
    StripeWpWritePhase1(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpSequentialRegenerateCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpSequentialEmergencyCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpParallelRegenerateCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpRegeneratePacketPhase1(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpRecoverPhase8(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpRecoverPhase7(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpRecoverPhase6(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpRecoverPhase5(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpRecoverPhase4(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpRecoverPhase3(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpRecoverPhase2(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpRecoverEmergencyCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpRecoverPhase1(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpMaxTransferCompletionRoutine(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpMaxTransferEmergencyCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpPropogateStateChangesWorker(
        IN  PVOID   StripeWp
        );

    friend
    VOID
    StripeWpCompleteWritePhase4(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpCompleteWritePhase3(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpCompleteWritePhase2(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpCompleteWritePhase1(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpCarefulWritePhase2(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpCarefulWritePhase1(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpCarefulWriteEmergencyCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpCarefulUpdateCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    StripeWpCarefulUpdateEmergencyCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    public:

        virtual
        NTSTATUS
        Initialize(
            IN OUT  PROOT_EXTENSION     RootExtension,
            IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
            IN OUT  PFT_VOLUME*         VolumeArray,
            IN      USHORT              ArraySize,
            IN      PVOID               ConfigInfo,
            IN      PVOID               StateInfo
            );

        virtual
        FT_LOGICAL_DISK_TYPE
        QueryLogicalDiskType(
            );

        virtual
        NTSTATUS
        OrphanMember(
            IN  USHORT                  MemberNumber,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        virtual
        NTSTATUS
        RegenerateMember(
            IN      USHORT                  MemberNumber,
            IN OUT  PFT_VOLUME              NewMember,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            );

        virtual
        VOID
        Transfer(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        VOID
        ReplaceBadSector(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        VOID
        StartSyncOperations(
            IN      BOOLEAN                 RegenerateOrphans,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            );

        virtual
        VOID
        StopSyncOperations(
            );

        virtual
        LONGLONG
        QueryVolumeSize(
            );

        virtual
        VOID
        SetDirtyBit(
            IN  BOOLEAN                 IsDirty,
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        virtual
        BOOLEAN
        IsComplete(
            IN  BOOLEAN IoPending
            );

        virtual
        VOID
        CompleteNotification(
            IN  BOOLEAN IoPending
            );

        virtual
        NTSTATUS
        CheckIo(
            OUT PBOOLEAN    IsIoOk
            );

        virtual
        BOOLEAN
        IsVolumeSuitableForRegenerate(
            IN  USHORT      MemberNumber,
            IN  PFT_VOLUME  Volume
            );

        virtual
        VOID
        NewStateArrival(
            IN  PVOID   NewStateInstance
            );

        virtual
        BOOLEAN
        QueryVolumeState(
            IN  PFT_VOLUME          Volume,
            OUT PFT_MEMBER_STATE    State
            );

        virtual
        NTSTATUS
        QueryPhysicalOffsets(
            IN  LONGLONG                    LogicalOffset,
            OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
            OUT PULONG                      NumberOfPhysicalOffsets
            );

        virtual
        NTSTATUS
        QueryLogicalOffset(
            IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
            OUT PLONGLONG               LogicalOffset
            );

        virtual
        VOID
        ModifyStateForUser(
            IN OUT  PVOID   State
            );

        STRIPE_WP(
            );

        virtual
        ~STRIPE_WP(
            );

    private:

        FT_MEMBER_STATE
        QueryMemberState(
            IN  USHORT  MemberNumber
            ) { return MemberNumber == _state.UnhealthyMemberNumber ?
                       _state.UnhealthyMemberState : FtMemberHealthy; }

        BOOLEAN
        SetMemberState(
            IN  USHORT          MemberNumber,
            IN  FT_MEMBER_STATE MemberState
            );

        BOOLEAN
        LaunchParallel(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        VOID
        LaunchSequential(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        VOID
        ReadPacket(
            IN OUT  PSWP_TP TransferPacket
            );

        VOID
        WritePacket(
            IN OUT  PSWP_WRITE_TP   TransferPacket
            );

        VOID
        RegeneratePacket(
            IN OUT  PSWP_TP TransferPacket,
            IN      BOOLEAN AllocateRegion
            );

        VOID
        Recover(
            IN OUT  PSWP_TP TransferPacket,
            IN      BOOLEAN NeedAcquire
            );

        VOID
        MaxTransfer(
            IN OUT  PSWP_TP TransferPacket
            );

        VOID
        RecycleRecoverTp(
            IN OUT  PSWP_RECOVER_TP TransferPacket
            );

        VOID
        PropogateStateChanges(
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        VOID
        CompleteWrite(
            IN OUT  PSWP_WRITE_TP   TransferPacket
            );

        VOID
        CarefulWrite(
            IN OUT  PSWP_TP TransferPacket
            );

        VOID
        CarefulUpdate(
            IN OUT  PSWP_TP ParityPacket
            );

        ULONG               _stripeSize;
        LONGLONG            _memberSize;
        LONGLONG            _volumeSize;

        //
        // The dynamic state of this volume.
        //

        FT_MIRROR_AND_SWP_STATE_INFORMATION _state;
        BOOLEAN _originalDirtyBit;
        BOOLEAN _orphanedBecauseOfMissingMember;

        //
        // Indicates whether or not 'StartSyncOperations' or
        // 'RegenerateMember' is ok.
        //

        BOOLEAN                     _syncOk;

        //
        // Indicates whether or not to stop syncs.
        //

        BOOLEAN                     _stopSyncs;

        //
        // State for keeping track of overlapping write requests.
        // One OVERLAPPED_IO_MANAGER for each member.
        //

        OVERLAPPED_IO_MANAGER       _overlappedIoManager;

        //
        // State for serializing parity I/O.
        //

        PARITY_IO_MANAGER           _parityIoManager;

        //
        // Emergency read/write packet.
        //

        PSWP_WRITE_TP               _ePacket;
        BOOLEAN                     _ePacketInUse;
        BOOLEAN                     _ePacketQueueBeingServiced;
        LIST_ENTRY                  _ePacketQueue;

        //
        // Emergency regenerate packet.
        //

        PSWP_REGENERATE_TP          _eRegeneratePacket;
        BOOLEAN                     _eRegeneratePacketInUse;
        LIST_ENTRY                  _eRegeneratePacketQueue;

        //
        // Emergency recover packet.
        //

        PSWP_RECOVER_TP             _eRecoverPacket;
        BOOLEAN                     _eRecoverPacketInUse;
        LIST_ENTRY                  _eRecoverPacketQueue;

};

class REDISTRIBUTION : public COMPOSITE_FT_VOLUME {

    friend
    VOID
    RedistributionSyncPhase6(
        IN OUT  PVOID       SyncPacket,
        IN      NTSTATUS    Status
        );

    friend
    VOID
    RedistributionSyncPhase5(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    RedistributionSyncPhase4(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    RedistributionSyncPhase3(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    RedistributionSyncPhase2(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    RedistributionSyncPhase1(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    RedistributionRegionLockCompletion(
        IN OUT  PTRANSFER_PACKET    LockPacket
        );

    friend
    VOID
    RedistributionLockReplaceCompletion(
        IN OUT  PTRANSFER_PACKET    TransferPacket
        );

    friend
    VOID
    RedistributionPropogateStateChangesWorker(
        IN  PVOID   WorkItem
        );

    public:

        virtual
        ~REDISTRIBUTION(
            );

        virtual
        NTSTATUS
        Initialize(
            IN OUT  PROOT_EXTENSION     RootExtension,
            IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
            IN OUT  PFT_VOLUME*         VolumeArray,
            IN      USHORT              ArraySize,
            IN      PVOID               ConfigInfo,
            IN      PVOID               StateInfo
            );

        virtual
        FT_LOGICAL_DISK_TYPE
        QueryLogicalDiskType(
            );

        virtual
        VOID
        Transfer(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        VOID
        ReplaceBadSector(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        virtual
        VOID
        StartSyncOperations(
            IN      BOOLEAN                 RegenerateOrphans,
            IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN      PVOID                   Context
            );

        virtual
        VOID
        StopSyncOperations(
            );

        virtual
        LONGLONG
        QueryVolumeSize(
            );

        virtual
        VOID
        CompleteNotification(
            IN  BOOLEAN IoPending
            );

        virtual
        NTSTATUS
        CheckIo(
            OUT PBOOLEAN    IsIoOk
            );

        virtual
        VOID
        NewStateArrival(
            IN  PVOID   NewStateInstance
            );

        virtual
        NTSTATUS
        QueryPhysicalOffsets(
            IN  LONGLONG                    LogicalOffset,
            OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
            OUT PULONG                      NumberOfPhysicalOffsets
            );

        virtual
        NTSTATUS
        QueryLogicalOffset(
            IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
            OUT PLONGLONG               LogicalOffset
            );

    private:

        VOID
        RedistributeTransfer(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        VOID
        RedistributeReplaceBadSector(
            IN OUT  PTRANSFER_PACKET    TransferPacket
            );

        VOID
        PropogateStateChanges(
            IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
            IN  PVOID                   Context
            );

        VOID
        MaxTransfer(
            IN OUT  PREDISTRIBUTION_TP  TransferPacket
            );

        VOID
        VerifyWrite(
            IN OUT  PREDISTRIBUTION_TP  TransferPacket
            );

        VOID
        CarefulWrite(
            IN OUT  PREDISTRIBUTION_TP  TransferPacket
            );

        ULONG       _stripeSize;
        USHORT      _firstWidth;
        USHORT      _totalWidth;
        LONGLONG    _firstSize;
        LONGLONG    _totalSize;
        BOOLEAN     _syncOk;
        BOOLEAN     _stopSyncs;

        FT_REDISTRIBUTION_STATE_INFORMATION _state;
        BOOLEAN                             _redistributionComplete;

        OVERLAPPED_IO_MANAGER   _overlappedIoManager;

};

typedef struct _FTP_GPT_ATTRIBUTE_REVERT_ENTRY {
    GUID        PartitionUniqueId;
    ULONGLONG   GptAttributes;
    ULONG       MbrSignature;
    ULONG       Reserved;
} FTP_GPT_ATTRIBUTE_REVERT_ENTRY, *PFTP_GPT_ATTRIBUTE_REVERT_ENTRY;

struct DEVICE_EXTENSION {

    //
    // Pointer to the device object for this extension.
    //

    PDEVICE_OBJECT DeviceObject;    // 00

    //
    // Pointer to the root device extension.
    //

    PROOT_EXTENSION Root; // 04

    //
    // The type of device extension.
    //

    ULONG DeviceExtensionType;  // 08

    //
    // A spinlock for synchronization.
    //

    KSPIN_LOCK SpinLock;    // 0C

};

class ROOT_EXTENSION : public DEVICE_EXTENSION {

    public:

        //
        // Pointer to the driver object.
        //

        PDRIVER_OBJECT DriverObject;    // 10

        //
        // Pointer to the next device in the stack.
        //

        PDEVICE_OBJECT TargetObject;    // 14

        //
        // Pointer to the PDO.
        //

        PDEVICE_OBJECT Pdo; // 18

        //
        // List of volumes in the system.  Protect with 'Semaphore'.
        //

        LIST_ENTRY VolumeList;  // 1C

        //
        // List of dead volumes.  Protect with 'Semaphore'.
        //

        LIST_ENTRY DeadVolumeList;  // 2C

        //
        // The next volume number.  Protect with 'Semaphore'.
        //

        ULONG NextVolumeNumber; // 34

        //
        // The disk information set for the on disk storage of FT sets.
        // Protect with 'Semaphore'.
        //

        PFT_LOGICAL_DISK_INFORMATION_SET DiskInfoSet;   // 38

        //
        // Private worker thread and queue.  Protect queue with 'SpinLock'.
        //

        PVOID WorkerThread;         // 3C
        LIST_ENTRY WorkerQueue;     // 40
        KSEMAPHORE WorkerSemaphore; // 44
        LONG TerminateThread;       // 58

        //
        // Change notify Irp list.  Protect with cancel spin lock.
        //

        LIST_ENTRY ChangeNotifyIrpList; // 5C

        //
        // A semaphore for synchronization.
        //

        KSEMAPHORE Mutex;   // 64

        //
        // Device Interface name.
        //

        UNICODE_STRING VolumeManagerInterfaceName; // 78

        //
        // Whether or not we are past the boot reinitialize code.
        //

        BOOLEAN PastBootReinitialize; // 80

        //
        // Whether or not the FT specific code has been locked down.
        //

        BOOLEAN FtCodeLocked;   // 81

        //
        // Whether or not we are past the reinitialize code.
        //

        BOOLEAN PastReinitialize;   // 82

        //
        // Registry Path.
        //

        UNICODE_STRING DiskPerfRegistryPath;

        //
        // Table of PmWmiCounter Functions.
        //

        PMWMICOUNTERLIB_CONTEXT PmWmiCounterLibContext;

        //
        // The Unique partition type GUID of the ESP.
        //

        GUID ESPUniquePartitionGUID;

        //
        // An array of gpt attribute revert records retrieved from the
        // registry at boot up.
        //

        ULONG NumberOfAttributeRevertEntries;
        PFTP_GPT_ATTRIBUTE_REVERT_ENTRY GptAttributeRevertEntries;

        //
        // The number of pre-exposures.  Protect with 'Semaphore'.
        //

        ULONG PreExposureCount;

};

typedef DEVICE_EXTENSION *PDEVICE_EXTENSION;

typedef
VOID
(*ZERO_REF_CALLBACK)(
    IN  PVOLUME_EXTENSION   VolumeExtension
    );

class VOLUME_EXTENSION : public DEVICE_EXTENSION {

    public:

        //
        // A pointer to the target object or the FT volume for this
        // volume.  Protect these with 'SpinLock'.
        //

        PDEVICE_OBJECT TargetObject;        // 10
        PFT_VOLUME FtVolume;                // 14
        LONG RefCount;                      // 18
        ZERO_REF_CALLBACK ZeroRefCallback;  // 1C
        PVOID ZeroRefContext;               // 20
        LIST_ENTRY ZeroRefHoldQueue;        // 24
        BOOLEAN IsStarted;                  // 2C
        BOOLEAN IsComplete;                 // 2D
        BOOLEAN InPagingPath;               // 2E
        BOOLEAN RemoveInProgress;           // 2F
        BOOLEAN IsOffline;                  // 30
        BOOLEAN DeadToPnp;                  // 31
        BOOLEAN DeviceDeleted;              // 32
        BOOLEAN IsPreExposure;              // 33
        BOOLEAN IsGpt;                      // 34
        BOOLEAN IsHidden;                   // 35
        BOOLEAN IsSuperFloppy;              // 36
        BOOLEAN IsReadOnly;                 // 37
        BOOLEAN IsEspType;                  // 38
        BOOLEAN IsInstalled;
        LONG AllSystemsGo;                  // 38

        //
        // List entry for volume list or dead volume list.
        // Protect with 'Root->Semaphore'.
        //

        LIST_ENTRY ListEntry;   // 3C

        //
        // The volume number.
        //

        ULONG VolumeNumber; // 44

        //
        // Emergency queue for a transfer packet.  Protect with 'SpinLock'.
        //

        PDISPATCH_TP EmergencyTransferPacket;       // 48
        LIST_ENTRY EmergencyTransferPacketQueue;    // 4C
        BOOLEAN EmergencyTransferPacketInUse;       // 54

        //
        // List of unique id change notify IRPs.
        //

        LIST_ENTRY ChangeNotifyIrps; // 58

        //
        // The dev node name for this device.
        //

        UNICODE_STRING DeviceNodeName;  // 60

        //
        // Whole disk PDO, if this extension is a partition and
        // not an FT volume.
        //

        PDEVICE_OBJECT WholeDiskPdo;    // 68
        PDEVICE_OBJECT WholeDisk;       // 6C
        LONGLONG PartitionOffset;       // 70
        LONGLONG PartitionLength;       // 78

        //
        // Device Interface name.
        //

        UNICODE_STRING MountedDeviceInterfaceName;  // 80

        //
        // A semaphore to protect 'ZeroRefCallback'.
        //

        KSEMAPHORE Semaphore;   // 8C

        //
        // Old whole disk PDO to facilitate debugging.
        //

        PDEVICE_OBJECT OldWholeDiskPdo; // A0

        //
        // Unique Id Guid in the GPT case.
        //

        GUID UniqueIdGuid;  // A4

        //
        // A copy of the current power state.  Protect with 'SpinLock'.
        //

        DEVICE_POWER_STATE PowerState;  // B4

        //
        // Whether or not the counters are running.
        //

        BOOLEAN CountersEnabled;

        //
        // Leave counters always enabled if we see IOCTL_DISK_PERFORMANCE
        //

        LONG EnableAlways;

        //
        // Counter structure.
        //

        PVOID PmWmiCounterContext;

        //
        // Table of Wmi Functions.
        //

        PWMILIB_CONTEXT WmilibContext;

        //
        // State for reverting GPT attributes.  Protect with 'Root->Semaphore'.
        //

        ULONGLONG GptAttributesToRevertTo;
        PFILE_OBJECT RevertOnCloseFileObject;
        BOOLEAN ApplyToAllConnectedVolumes;

        //
        // Cached MBR GPT attributes.
        //

        ULONGLONG MbrGptAttributes;

};

#define DEVICE_EXTENSION_ROOT   (0)
#define DEVICE_EXTENSION_VOLUME (1)

BOOLEAN
FtpIsWorseStatus(
    IN  NTSTATUS    Status1,
    IN  NTSTATUS    Status2
    );

VOID
FtpComputeParity(
    IN  PVOID   TargetBuffer,
    IN  PVOID   SourceBuffer,
    IN  ULONG   BufferLength
    );

VOID
FtpLogError(
    IN  PDEVICE_EXTENSION   Extension,
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  NTSTATUS            SpecificIoStatus,
    IN  NTSTATUS            FinalStatus,
    IN  ULONG               UniqueErrorValue
    );

VOID
FtpQueueWorkItem(
    IN  PROOT_EXTENSION     RootExtension,
    IN  PWORK_QUEUE_ITEM    WorkItem
    );

VOID
FtpNotify(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      PVOLUME_EXTENSION   Extension
    );

VOID
FtpAcquire(
    IN OUT  PROOT_EXTENSION RootExtension
    );

NTSTATUS
FtpAcquireWithTimeout(
    IN OUT  PROOT_EXTENSION RootExtension
    );

VOID
FtpRelease(
    IN OUT  PROOT_EXTENSION RootExtension
    );

VOID
FtpDecrementRefCount(
    IN OUT  PVOLUME_EXTENSION   Extension
    );

FT_LOGICAL_DISK_ID
GenerateNewLogicalDiskId(
    );

NTSTATUS
FtpQueryPartitionInformation(
    IN  PROOT_EXTENSION RootExtension,
    IN  PDEVICE_OBJECT  Partition,
    OUT PULONG          DiskNumber,
    OUT PLONGLONG       Offset,
    OUT PULONG          PartitionNumber,
    OUT PUCHAR          PartitionType,
    OUT PLONGLONG       PartitionLength,
    OUT GUID*           PartitionTypeGuid,
    OUT GUID*           PartitionUniqueIdGuid,
    OUT PBOOLEAN        IsGpt,
    OUT PULONGLONG      GptAttributes
    );

ULONG
FtpQueryDiskSignature(
    IN  PDEVICE_OBJECT  WholeDiskPdo
    );

NTSTATUS
FtpDiskRegistryQueryRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    );

PDISK_PARTITION
FtpFindDiskPartition(
    IN  PDISK_REGISTRY  DiskRegistry,
    IN  ULONG           Signature,
    IN  LONGLONG        Offset
    );

VOID
FtpCopyStateToRegistry(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  PVOID               LogicalDiskState,
    IN  USHORT              LogicalDiskStateSize
    );

BOOLEAN
FtpQueryStateFromRegistry(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  PVOID               LogicalDiskState,
    IN  USHORT              BufferSize,
    OUT PUSHORT             LogicalDiskStateSize
    );

VOID
FtpDeleteStateInRegistry(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    );

PVOLUME_EXTENSION
FtpFindExtensionCoveringDiskId(
    IN  PROOT_EXTENSION     RootExtension,
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    );

NTSTATUS
FtpReadPartitionTableEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDRIVE_LAYOUT_INFORMATION_EX* DriveLayout
    );

NTSTATUS
FtpApplyESPProtection(
    IN  PUNICODE_STRING PartitionName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\mpath\spfilter\mpspfltr.c ===
/*++

Copyright (C) 1999  Microsoft Corporation

Module Name:

    mpspfltr.c

Abstract:

    This driver acts as an upper-filter over scsiport and provides the support
    necessary for multipathing. It's main function is keep mpctl.sys (main multipath module)
    informed of system state.

Author:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include <ntddk.h>
#include <stdio.h>
#include <stdarg.h>
#include "mpspfltr.h"

//
// Entry point function decl's.
//
NTSTATUS
MPSPDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPSPDispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPSPDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MPSPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

VOID
MPSPUnload(
    IN PDRIVER_OBJECT DriverObject
    );




//
// The code.
//


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine is called when the driver loads loads.

Arguments:

    DriverObject    - Supplies the driver object.
    RegistryPath    - Supplies the registry path.

Return Value:

    NTSTATUS

--*/
{
    PDRIVER_DISPATCH  *dispatch;
    ULONG i;

    MPDebugPrint((0,
                "MPSP DriverEntry.\n"));

    //
    // Cover all bases.
    //
    for (i = 0, dispatch = DriverObject->MajorFunction;
         i <= IRP_MJ_MAXIMUM_FUNCTION; i++, dispatch++) {

        *dispatch = MPSPSendToNextDriver;
    }

    //
    // Set up the entry points that we are really interested in handling.
    //
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = MPSPDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP] = MPSPDispatchPnP;
    DriverObject->MajorFunction[IRP_MJ_POWER] = MPSPDispatchPower;

    DriverObject->DriverExtension->AddDevice = MPSPAddDevice;
    DriverObject->DriverUnload = MPSPUnload;

    return STATUS_SUCCESS;
}


NTSTATUS
MPSPDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Currently, this routine just sends the request to scsiport.

Arguments:

    DeviceObject    - Supplies the device object.
    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/
{

    return MPSPSendToNextDriver(DeviceObject, Irp);
}


NTSTATUS
MPSPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++
Routine Description:

    Creates and initializes a new filter device object for the
    corresponding PDO.  Then it attaches the device object to the device
    stack of the drivers for the device.

Arguments:

    DriverObject
    PhysicalDeviceObject - Physical Device Object from the underlying layered driver

Return Value:

    NTSTATUS
--*/
{
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT controlDeviceObject;
    PDEVICE_EXTENSION deviceExtension;
    IO_STATUS_BLOCK ioStatus;
    UNICODE_STRING unicodeName;
    PFILE_OBJECT fileObject;
    WCHAR dosDeviceName[40];
    ADAPTER_REGISTER filterRegistration;
    NTSTATUS status;
    ULONG i;

    if (DontLoad) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Create an un-named device object.
    //
    status = IoCreateDevice(DriverObject,
                            sizeof(DEVICE_EXTENSION),
                            NULL,
                            FILE_DEVICE_CONTROLLER,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &deviceObject);
    if (!NT_SUCCESS(status)) {
        MPDebugPrint((0,
                    "MPSPAddDevice: Couldn't create deviceObject (%x)\n",
                    status));
        return status;
    }

    //
    // Start building the device extension, and attach to scsiport
    //
    deviceExtension = deviceObject->DeviceExtension;
    deviceExtension->DeviceObject = deviceObject;
    deviceExtension->TargetDevice = IoAttachDeviceToDeviceStack(deviceObject,
                                                                PhysicalDeviceObject);
    
    if (deviceExtension->TargetDevice == NULL) {
        IoDeleteDevice(deviceObject);
        MPDebugPrint((0,
                    "MPSPAddDevice: Attach to ScsiPort failed\n"));
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Update the flags by ORing in all of the set flags below.
    //
    deviceObject->Flags |= deviceExtension->TargetDevice->Flags & (DO_DIRECT_IO     |
                                                                   DO_BUFFERED_IO   |
                                                                   DO_POWER_PAGABLE |
                                                                   DO_POWER_INRUSH);

    //
    // Update type and characteristics based on whatever scsiport setup.
    //
    deviceObject->DeviceType = deviceExtension->TargetDevice->DeviceType;
    deviceObject->Characteristics = deviceExtension->TargetDevice->Characteristics; 

    //
    // Init. the generic event.
    //
    KeInitializeEvent(&deviceExtension->Event,
                      NotificationEvent,
                      FALSE);

    //
    // Init the child list objects.
    //
    InitializeListHead(&deviceExtension->ChildList);
    KeInitializeSpinLock(&deviceExtension->ListLock);

    //
    // Register with mpctl. 
    //
    // Build the mpctl name.
    //
    swprintf(dosDeviceName, L"\\DosDevices\\MPathControl");
    RtlInitUnicodeString(&unicodeName, dosDeviceName);

    //
    // Get mpctl's deviceObject.
    //
    status = IoGetDeviceObjectPointer(&unicodeName,
                                      FILE_READ_ATTRIBUTES,
                                      &fileObject,
                                      &controlDeviceObject);

    if (NT_SUCCESS(status)) {

        //
        // Tell mpctl that this filter has arrived.
        //
        filterRegistration.FilterObject = deviceObject;
        filterRegistration.FltrGetDeviceList = MPSPGetDeviceList;
        filterRegistration.PortFdo = deviceExtension->TargetDevice;

        MPLIBSendDeviceIoControlSynchronous(IOCTL_MPADAPTER_REGISTER,
                                            controlDeviceObject,
                                            &filterRegistration,
                                            &filterRegistration,
                                            sizeof(ADAPTER_REGISTER),
                                            sizeof(ADAPTER_REGISTER),
                                            TRUE,
                                            &ioStatus);
        status = ioStatus.Status;
        if (status == STATUS_SUCCESS) {

            //
            // Copy the info from the registration buffer.
            //
            deviceExtension->PnPNotify = filterRegistration.PnPNotify;
            deviceExtension->PowerNotify = filterRegistration.PowerNotify;
            deviceExtension->DeviceNotify = filterRegistration.DeviceNotify;

            deviceExtension->ControlObject = controlDeviceObject;
        }    
    } else {

        //
        // Stay loaded, but log an error and figure out a way to
        // handle this case (if needed) TODO
        //
        status = STATUS_SUCCESS;
    }    

    //
    // Indicate that we are ready.
    //
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    
    return status;

}


NTSTATUS
MPSPDispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for PNP Irps.

Arguments:

    DeviceObject    - Supplies the device object.
    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;

    //
    // Ensure the state of the event is 0.
    //
    KeClearEvent(&deviceExtension->Event);

    //////////
    // TODO

    // IRP_MN_STOP_DEVICE
    // IRP_MN_QUERY_INTERFACE
    // IRP_MN_QUERY_PNP_DEVICE_STATE
    //
    switch (irpStack->MinorFunction) {
        case IRP_MN_START_DEVICE:

            //
            // Call start, then finish up below.
            //
            status = MPSPStartDevice(DeviceObject, Irp);
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            //
            // Return here, as QDR releases the remove lock.
            //
            status = MPSPQueryDeviceRelations(DeviceObject, Irp);
            break;

        case IRP_MN_REMOVE_DEVICE:

            //
            // Return from here as not to run the removelock code below.
            //
            status = MPSPRemoveDevice(DeviceObject, Irp);
            break;

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            MPDebugPrint((0,
                         "MPSPDispatchPnP(%x): Device usage notification\n"));
            DbgBreakPoint();
            //
            // Fall through.
            //
        case IRP_MN_QUERY_ID:
            status = MPSPQueryID(DeviceObject, Irp);
            break;

        default:

        status = MPSPSendToNextDriver(DeviceObject, Irp);
        break;
    }

    return status;
}


NTSTATUS
MPSPDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for Power Irps.

Arguments:

    DeviceObject    - Supplies the device object.
    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;

    MPDebugPrint((1,
                "MPSPDispatchPower (%x): Irp (%x)Sending MN(%x) to (%x)\n",
                DeviceObject,
                 Irp,
                irpStack->MinorFunction,
                deviceExtension->TargetDevice));

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);

    status = PoCallDriver(deviceExtension->TargetDevice, Irp);

    return status;

}



VOID
MPSPUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{

    MPDebugPrint((0,
                "MPSPUnload: Getting unloaded\n"));
    return;
}


NTSTATUS
MPSPSendToNextDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sends the Irp to the next driver in line
    when the Irp is not processed by this driver.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(deviceExtension->TargetDevice, Irp);
}


PADP_ASSOCIATED_DEVICES
MPSPGetDeviceList(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PADP_ASSOCIATED_DEVICES cachedList = deviceExtension->CachedList;
    PADP_ASSOCIATED_DEVICES deviceList;
    ULONG numberDevices;
    ULONG i;
    ULONG length;

    numberDevices = deviceExtension->CachedList->NumberDevices;
    length = sizeof(ADP_ASSOCIATED_DEVICES) *
                 (sizeof(ADP_ASSOCIATED_DEVICE_INFO) * (numberDevices - 1));
                 
    deviceList = ExAllocatePool(NonPagedPool, length);
    
    RtlCopyMemory(deviceList,
                  cachedList,
                  length);
    
    return deviceList;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\newft\composit.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    composit.cxx

Abstract:

    This module contains the code specific to all composite volume objects.

Author:

    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

    This code assumes that the volume array is static.  If these values
    changes (as in Stripes or Mirrors) then it is up to the subclass to
    provide the proper synchronization.

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>

VOID
SimpleFtCompletionRoutine(
    IN  PVOID       CompletionContext,
    IN  NTSTATUS    Status
    );


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
COMPOSITE_FT_VOLUME::Initialize(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN OUT  PFT_VOLUME*         VolumeArray,
    IN      USHORT              ArraySize,
    IN      PVOID               ConfigInfo,
    IN      PVOID               StateInfo
    )

/*++

Routine Description:

    Initialize routine for FT_VOLUME of type COMPOSITE_FT_VOLUME.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id for this volume.

    VolumeArray     - Supplies the array of volumes for this volume set.

    ArraySize       - Supplies the number of volumes in the volume array.

    ConfigInfo      - Supplies the configuration information.

    StateInfo       - Supplies the state information.

Return Value:

    STATUS_SUCCESS

--*/

{
    ULONG   i, secsize;

    FT_VOLUME::Initialize(RootExtension, LogicalDiskId);

    _volumeArray = VolumeArray;
    _arraySize = ArraySize;

    _sectorSize = 0;
    for (i = 0; i < _arraySize; i++) {
        if (_volumeArray[i]) {
            secsize = _volumeArray[i]->QuerySectorSize();
            if (_sectorSize < secsize) {
                _sectorSize = secsize;
            }
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
COMPOSITE_FT_VOLUME::OrphanMember(
    IN  USHORT                  MemberNumber,
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine tries to orphan the given member of this logical disk.
    A completion routine will be called if and only if this attempt is successful.

Arguments:

    MemberNumber        - Supplies the member number to orphan.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the completion routine context.

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_PARAMETER;
}

NTSTATUS
COMPOSITE_FT_VOLUME::RegenerateMember(
    IN      USHORT                  MemberNumber,
    IN OUT  PFT_VOLUME              NewMember,
    IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN      PVOID                   Context
    )

/*++

Routine Description:

    This routine regenerates the given member of this volume with
    the given volume.

Arguments:

    MemberNumber        - Supplies the member number to regenerate.

    NewMember           - Supplies the new member to regenerate to.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the completion routine context.

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_PARAMETER;
}

VOID
COMPOSITE_FT_VOLUME::StopSyncOperations(
    )

/*++

Routine Description:

    This routine stops all sync operations.

Arguments:

    None.

Return Value:

    None.

--*/

{
    USHORT     i;
    PFT_VOLUME vol;

    for (i = 0; i < _arraySize; i++) {
        if (vol = GetMember(i)) {
            vol->StopSyncOperations();
        }
    }
}

VOID
COMPOSITE_FT_VOLUME::BroadcastIrp(
    IN  PIRP                    Irp,
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )


/*++

Routine Description:

    This routine broadcasts a copy of the given IRP to every partition that
    is a member of the logical disk.

Arguments:

    Irp                 - Supplies the I/O request packet.

    CompletionRoutine   - Supplies the routine to be called when the operation
                            completes.

    Context             - Supplies the completion routine context.

Return Value:

    None.

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  completionContext;
    USHORT                          i;
    PFT_VOLUME                      vol;

    completionContext = (PFT_COMPLETION_ROUTINE_CONTEXT)
                        ExAllocatePool(NonPagedPool,
                                       sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
    if (!completionContext) {
        CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    KeInitializeSpinLock(&completionContext->SpinLock);
    completionContext->Status = STATUS_SUCCESS;
    completionContext->RefCount = _arraySize;
    completionContext->CompletionRoutine = CompletionRoutine;
    completionContext->Context = Context;

    for (i = 0; i < _arraySize; i++) {
        if (vol = GetMember(i)) {
            vol->BroadcastIrp(Irp, SimpleFtCompletionRoutine,
                              completionContext);
        } else {
            SimpleFtCompletionRoutine(completionContext, STATUS_SUCCESS);
        }
    }
}

PFT_VOLUME
COMPOSITE_FT_VOLUME::GetParentLogicalDisk(
    IN  PFT_VOLUME  Volume
    )

/*++

Routine Description:

    This routine returns the parent of the given logical disk within
    this volume.

Arguments:

    Volume  - Supplies the sub-volume of which we are looking for the parent.

Return Value:

    The parent volume or NULL;

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        if (!(vol = GetMember(i))) {
            continue;
        }

        if (vol == Volume) {
            return this;
        }

        vol = vol->GetParentLogicalDisk(Volume);
        if (vol) {
            return vol;
        }
    }

    return NULL;
}

NTSTATUS
COMPOSITE_FT_VOLUME::SetPartitionType(
    IN  UCHAR   PartitionType
    )

/*++

Routine Description:

    This routine sets the partition type on all the members of the
    FT set.

Arguments:

    PartitionType   - Supplies the partition type.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS    status, finalStatus;
    USHORT      n, i;
    PFT_VOLUME  vol;

    finalStatus = STATUS_SUCCESS;
    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        if (!(vol = GetMember(i))) {
            continue;
        }

        status = vol->SetPartitionType(PartitionType);
        if (!NT_SUCCESS(status)) {
            finalStatus = status;
        }
    }

    return finalStatus;
}

UCHAR
COMPOSITE_FT_VOLUME::QueryPartitionType(
    )

/*++

Routine Description:

    This routine queries the partition type.

Arguments:

    None.

Return Value:

    The partition type.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;
    UCHAR       type;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        if (!(vol = GetMember(i))) {
            continue;
        }

        type = vol->QueryPartitionType();
        if (type) {
            return type;
        }
    }

    return 0;
}

UCHAR
COMPOSITE_FT_VOLUME::QueryStackSize(
    )

/*++

Routine Description:

    This routine queries IRP stack size.

Arguments:

    None.

Return Value:

    The IRP stack size.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;
    UCHAR       stackSize, t;

    stackSize = 0;
    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        if (!(vol = GetMember(i))) {
            continue;
        }

        t = vol->QueryStackSize();
        if (t > stackSize) {
            stackSize = t;
        }
    }

    return stackSize;
}

VOID
COMPOSITE_FT_VOLUME::CreateLegacyNameLinks(
    IN  PUNICODE_STRING DeviceName
    )

/*++

Routine Description:

    This routine creates the \Device\HarddiskN\PartitionM links for
    this object to the given device name.

Arguments:

    DeviceName  - Supplies the device name.

Return Value:

    None.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        if (!(vol = GetMember(i))) {
            continue;
        }

        vol->CreateLegacyNameLinks(DeviceName);
    }
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

USHORT
COMPOSITE_FT_VOLUME::QueryNumberOfMembers(
    )

/*++

Routine Description:

    This routine returns the number of members in this volume.

Arguments:

    None.

Return Value:

    The number of members in this volume.

--*/

{
    return _arraySize;
}

VOID
COMPOSITE_FT_VOLUME::SetDirtyBit(
    IN  BOOLEAN                 IsDirty,
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine sets the dirty bit on the volume.  This bit is used at
    startup to determine whether or not there was a clean shutdown.

Arguments:

    IsDirty - Supplies the value of the dirty bit.

Return Value:

    None.

--*/

{
    USHORT                          n, i;
    PFT_VOLUME                      vol;
    PFT_COMPLETION_ROUTINE_CONTEXT  completionContext;

    if (!CompletionRoutine) {
        n = QueryNumMembers();
        for (i = 0; i < n; i++) {
            if (vol = GetMember(i)) {
                vol->SetDirtyBit(IsDirty, NULL, NULL);
            }
        }
        return;
    }

    completionContext = (PFT_COMPLETION_ROUTINE_CONTEXT)
                        ExAllocatePool(NonPagedPool,
                                       sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
    if (!completionContext) {
        CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    KeInitializeSpinLock(&completionContext->SpinLock);
    completionContext->Status = STATUS_SUCCESS;
    completionContext->RefCount = _arraySize;
    completionContext->CompletionRoutine = CompletionRoutine;
    completionContext->Context = Context;

    for (i = 0; i < _arraySize; i++) {
        if (vol = GetMember(i)) {
            vol->SetDirtyBit(IsDirty, SimpleFtCompletionRoutine,
                             completionContext);
        } else {
            SimpleFtCompletionRoutine(completionContext, STATUS_SUCCESS);
        }
    }
}

PFT_VOLUME
COMPOSITE_FT_VOLUME::GetMember(
    IN  USHORT  MemberNumber
    )

/*++

Routine Description:

    This routine returns the 'MemberNumber'th member of this volume.

Arguments:

    MemberNumber    - Supplies the zero based member number desired.

Return Value:

    A pointer to the 'MemberNumber'th member or NULL if no such member.

--*/

{
    KIRQL       irql;
    PFT_VOLUME  r;

    ASSERT(MemberNumber < _arraySize);

    KeAcquireSpinLock(&_spinLock, &irql);
    r = _volumeArray[MemberNumber];
    KeReleaseSpinLock(&_spinLock, irql);
    return r;
}

VOID
SimpleFtCompletionRoutine(
    IN  PVOID       CompletionContext,
    IN  NTSTATUS    Status
    )

/*++

Routine Description:

    This is a simple completion routine that expects the CompletionContext
    to be a FT_COMPLETION_ROUTINE_CONTEXT.  It decrements the ref count and
    consolidates all of the status codes.  When the ref count goes to zero it
    call the original completion routine with the result.

Arguments:

    CompletionContext   - Supplies the completion context.

    Status              - Supplies the status of the request.

Return Value:

    None.

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  completionContext;
    KIRQL                           oldIrql;
    LONG                            count;

    completionContext = (PFT_COMPLETION_ROUTINE_CONTEXT) CompletionContext;

    KeAcquireSpinLock(&completionContext->SpinLock, &oldIrql);

    if (!NT_SUCCESS(Status) &&
        FtpIsWorseStatus(Status, completionContext->Status)) {

        completionContext->Status = Status;
    }

    count = --completionContext->RefCount;

    KeReleaseSpinLock(&completionContext->SpinLock, oldIrql);

    if (!count) {
        completionContext->CompletionRoutine(completionContext->Context,
                                             completionContext->Status);
        ExFreePool(completionContext);
    }
}

VOID
COMPOSITE_FT_VOLUME::StartSyncOperations(
    IN      BOOLEAN                 RegenerateOrphans,
    IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN      PVOID                   Context
    )

/*++

Routine Description:

    This routine restarts any regenerate and initialize requests that were
    suspended because of a reboot.  The volume examines the member state of
    all of its constituents and restarts any regenerations pending.

Arguments:

    RegenerateOrphans   - Supplies whether or not to try and regenerate
                            orphaned members.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the context for the completion routine.

Return Value:

    None.

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  completionContext;
    USHORT                          i;
    PFT_VOLUME                      vol;

    completionContext = (PFT_COMPLETION_ROUTINE_CONTEXT)
                        ExAllocatePool(NonPagedPool,
                                       sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
    if (!completionContext) {
        CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    KeInitializeSpinLock(&completionContext->SpinLock);
    completionContext->Status = STATUS_SUCCESS;
    completionContext->RefCount = _arraySize;
    completionContext->CompletionRoutine = CompletionRoutine;
    completionContext->Context = Context;

    for (i = 0; i < _arraySize; i++) {
        if (vol = GetMember(i)) {
            vol->StartSyncOperations(RegenerateOrphans,
                                     SimpleFtCompletionRoutine,
                                     completionContext);
        } else {
            SimpleFtCompletionRoutine(completionContext, STATUS_SUCCESS);
        }
    }
}

ULONG
COMPOSITE_FT_VOLUME::QuerySectorSize(
    )

/*++

Routine Description:

    Returns the sector size for the volume.

Arguments:

    None.

Return Value:

    The volume sector size in bytes.

--*/

{
    return _sectorSize;
}

PFT_VOLUME
COMPOSITE_FT_VOLUME::GetContainedLogicalDisk(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine returns TRUE if the given logical disk id
    represents this logical disk or if this logical disk contains
    the given logical disk id either directly or indirectly.

Arguments:

    LogicalDiskId   - Supplies the logical disk id that we are searching for.

Return Value:

    FALSE   - The given logical disk id is not contained in this logical disk.

    TRUE    - The given logical disk id is contained in this logical disk.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;

    if (LogicalDiskId == QueryLogicalDiskId()) {
        return this;
    }

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        if ((vol = GetMember(i)) &&
            (vol = vol->GetContainedLogicalDisk(LogicalDiskId))) {

            return vol;
        }
    }

    return NULL;
}

PFT_VOLUME
COMPOSITE_FT_VOLUME::GetContainedLogicalDisk(
    IN  PDEVICE_OBJECT  TargetObject
    )

/*++

Routine Description:

    This routine returns TRUE if the given logical disk id
    represents this logical disk or if this logical disk contains
    the given logical disk id either directly or indirectly.

Arguments:

    TargetObject    - Supplies the target object.

Return Value:

    FALSE   - The given logical disk id is not contained in this logical disk.

    TRUE    - The given logical disk id is contained in this logical disk.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        if ((vol = GetMember(i)) &&
            (vol = vol->GetContainedLogicalDisk(TargetObject))) {

            return vol;
        }
    }

    return NULL;
}

PFT_VOLUME
COMPOSITE_FT_VOLUME::GetContainedLogicalDisk(
    IN  ULONG       Signature,
    IN  LONGLONG    Offset
    )

/*++

Routine Description:

    This routine returns TRUE if the given logical disk id
    represents this logical disk or if this logical disk contains
    the given logical disk id either directly or indirectly.

Arguments:

    TargetObject    - Supplies the target object.

Return Value:

    FALSE   - The given logical disk id is not contained in this logical disk.

    TRUE    - The given logical disk id is contained in this logical disk.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            continue;
        }

        vol = vol->GetContainedLogicalDisk(Signature, Offset);
        if (vol) {
            return vol;
        }
    }

    return NULL;
}

VOID
COMPOSITE_FT_VOLUME::SetMember(
    IN  USHORT      MemberNumber,
    IN  PFT_VOLUME  Member
    )

/*++

Routine Description:

    This routine sets the given member in this volume.

Arguments:

    MemberNumber    - Supplies the member number.

    Member          - Supplies the member.

Return Value:

    None.

--*/

{
    KIRQL   irql;

    KeAcquireSpinLock(&_spinLock, &irql);
    SetMemberUnprotected(MemberNumber, Member);
    KeReleaseSpinLock(&_spinLock, irql);
}

BOOLEAN
COMPOSITE_FT_VOLUME::IsComplete(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine computes whether or not this volume has either all
    (if IoPending is FALSE) of its members or enough (if IoPending is TRUE) of
    its members.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;
    ULONG       secsize;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol || !vol->IsComplete(IoPending)) {
            return FALSE;
        }
    }

    return TRUE;
}

VOID
COMPOSITE_FT_VOLUME::CompleteNotification(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine is called to notify the volume that it is complete and
    to therefore prepare for incoming requests.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;
    ULONG       secsize;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            continue;
        }
        if (vol->IsComplete(IoPending)) {
            vol->CompleteNotification(IoPending);
            secsize = vol->QuerySectorSize();
            if (secsize > _sectorSize) {
                _sectorSize = secsize;
            }
        }
    }
}

ULONG
COMPOSITE_FT_VOLUME::QueryNumberOfPartitions(
    )

/*++

Routine Description:

    This routine returns the number of partitions covered by this volume
    set.

Arguments:

    None.

Return Value:

    The number of partitions covered by this volume set.

--*/

{
    ULONG       r;
    USHORT      n, i;
    PFT_VOLUME  vol;

    r = 0;
    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        if (!(vol = GetMember(i))) {
            continue;
        }

        r += vol->QueryNumberOfPartitions();
    }

    return r;
}

PDEVICE_OBJECT
COMPOSITE_FT_VOLUME::GetLeftmostPartitionObject(
    )

{
    USHORT      n, i;
    PFT_VOLUME  vol;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (vol) {
            return vol->GetLeftmostPartitionObject();
        }
    }

    return NULL;
}

NTSTATUS
COMPOSITE_FT_VOLUME::QueryDiskExtents(
    OUT PDISK_EXTENT*   DiskExtents,
    OUT PULONG          NumberOfDiskExtents
    )

/*++

Routine Description:

    This routine returns an array of disk extents that describe the
    location of this volume.

Arguments:

    DiskExtents         - Returns the disk extents.

    NumberOfDiskExtents - Returns the number of disk extents.

Return Value:

    NTSTATUS

--*/

{
    ULONG           totalExtents, numExtents, newTotal;
    USHORT          n, i;
    PFT_VOLUME      vol;
    NTSTATUS        status;
    PDISK_EXTENT    extents, allExtents;

Restart:

    totalExtents = 0;
    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        if (!(vol = GetMember(i))) {
            continue;
        }

        status = vol->QueryDiskExtents(&extents, &numExtents);
        if (!NT_SUCCESS(status)) {
            return status;
        }
        ExFreePool(extents);

        totalExtents += numExtents;
    }

    allExtents = (PDISK_EXTENT) ExAllocatePool(PagedPool, totalExtents*
                                               sizeof(DISK_EXTENT));
    if (!allExtents) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    newTotal = 0;
    for (i = 0; i < n; i++) {
        if (!(vol = GetMember(i))) {
            continue;
        }

        status = vol->QueryDiskExtents(&extents, &numExtents);
        if (!NT_SUCCESS(status)) {
            ExFreePool(allExtents);
            return status;
        }

        if (newTotal + numExtents > totalExtents) {
            ExFreePool(extents);
            ExFreePool(allExtents);
            goto Restart;
        }

        RtlCopyMemory(&allExtents[newTotal], extents,
                      numExtents*sizeof(DISK_EXTENT));
        ExFreePool(extents);

        newTotal += numExtents;
    }

    *DiskExtents = allExtents;
    *NumberOfDiskExtents = newTotal;

    return STATUS_SUCCESS;
}

BOOLEAN
COMPOSITE_FT_VOLUME::QueryVolumeState(
    IN  PFT_VOLUME          Volume,
    OUT PFT_MEMBER_STATE    State
    )

/*++

Routine Description:

    This routine returns the state of the given volume considered as a
    member of this volume.

Arguments:

    Volume  - Supplies the volume to query the state for.

    State   - Returns the state.

Return Value:

    FALSE   - The given Volume is not a member of this volume.

    TRUE    - The state was successfully computed.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            continue;
        }

        if (vol->QueryVolumeState(Volume, State)) {
            return TRUE;
        }
    }

    return FALSE;
}

COMPOSITE_FT_VOLUME::~COMPOSITE_FT_VOLUME(
    )

/*++

Routine Description:

    Routine called to cleanup resources being used by the object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (_volumeArray) {
        ExFreePool(_volumeArray);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\newft\ftdisk.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    ftdisk.c

Abstract:

    This driver provides fault tolerance through disk mirroring and striping.
    This module contains routines that support calls from the NT I/O system.

Author:

    Bob Rinne   (bobri)  2-Feb-1992
    Mike Glass  (mglass)
    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntosp.h>
    #include <ntddscsi.h>
    #include <initguid.h>
    #include <mountmgr.h>
    #include <ioevent.h>
    #include <partmgrp.h>
    #include <zwapi.h>
    #include <ntioapi.h>

}

#include <ftdisk.h>

extern "C" {

#include "wmiguid.h"
#include "ntdddisk.h"
#include "ftwmireg.h"

}

//
// Global Sequence number for error log.
//

ULONG FtErrorLogSequence = 0;

extern "C" {

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
FtDiskAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

}

NTSTATUS
FtpCreateLogicalDiskHelper(
    IN OUT  PROOT_EXTENSION         RootExtension,
    IN      FT_LOGICAL_DISK_TYPE    LogicalDiskType,
    IN      USHORT                  NumberOfMembers,
    IN      PFT_LOGICAL_DISK_ID     ArrayOfMembers,
    IN      USHORT                  ConfigurationInformationSize,
    IN      PVOID                   ConfigurationInformation,
    IN      USHORT                  StateInformationSize,
    IN      PVOID                   StateInformation,
    OUT     PFT_LOGICAL_DISK_ID     NewLogicalDiskId
    );

NTSTATUS
FtpBreakLogicalDiskHelper(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  RootLogicalDiskId
    );

NTSTATUS
FtpCreatePartitionLogicalDiskHelper(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN      LONGLONG            PartitionSize,
    OUT     PFT_LOGICAL_DISK_ID NewLogicalDiskId
    );

NTSTATUS
FtpAddPartition(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PDEVICE_OBJECT      Partition,
    IN  PDEVICE_OBJECT      WholeDiskPdo
    );

NTSTATUS
FtpPartitionRemovedHelper(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN      PDEVICE_OBJECT  Partition,
    IN      PDEVICE_OBJECT  WholeDiskPdo
    );

NTSTATUS
FtpSignalCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Event
    );

VOID
FtpRefCountCompletion(
    IN  PVOID       Extension,
    IN  NTSTATUS    Status
    );

VOID
FtpDecrementRefCount(
    IN OUT  PVOLUME_EXTENSION   Extension
    );

NTSTATUS
FtpAllSystemsGo(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp,
    IN  BOOLEAN             MustBeComplete,
    IN  BOOLEAN             MustHaveVolume,
    IN  BOOLEAN             MustBeOnline
    );

NTSTATUS
FtpSetGptAttributesOnDisk(
    IN  PDEVICE_OBJECT  Partition,
    IN  ULONGLONG       GptAttributes
    );

typedef struct _SET_TARGET_CONTEXT {
    KEVENT          Event;
    PDEVICE_OBJECT  TargetObject;
    PFT_VOLUME      FtVolume;
    PDEVICE_OBJECT  WholeDiskPdo;
} SET_TARGET_CONTEXT, *PSET_TARGET_CONTEXT;

VOID
FtpSetTargetCallback(
    IN  PVOLUME_EXTENSION   Extension
    );

VOID
FtpVolumeReadOnlyCallback(
    IN  PVOLUME_EXTENSION   Extension
    );

VOID
FtpZeroRefCallback(
    IN  PVOLUME_EXTENSION   Extension,
    IN  ZERO_REF_CALLBACK   ZeroRefCallback,
    IN  PVOID               ZeroRefContext,
    IN  BOOLEAN             AcquireSemaphore
    );

NTSTATUS
FtpRefCountCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Extension
    );

VOID
FtDiskShutdownFlushCompletionRoutine(
    IN  PVOID       Irp,
    IN  NTSTATUS    Status
    );

typedef struct _FT_PARTITION_OFFLINE_CONTEXT {

    PFT_VOLUME      Root;
    PFT_VOLUME      Parent;
    PFT_VOLUME      Child;
    PKEVENT         Event;

} FT_PARTITION_OFFLINE_CONTEXT, *PFT_PARTITION_OFFLINE_CONTEXT;

VOID
FtpMemberOfflineCallback(
    IN  PVOLUME_EXTENSION   Extension
    );

NTSTATUS
FtpChangeNotify(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    );

VOID
FtpReadWriteCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    );

typedef struct _INSERT_MEMBER_CONTEXT {
    KEVENT      Event;
    PFT_VOLUME  Parent;
    USHORT      MemberNumber;
    PFT_VOLUME  Member;
} INSERT_MEMBER_CONTEXT, *PINSERT_MEMBER_CONTEXT;

VOID
FtpInsertMemberCallback(
    IN  PVOLUME_EXTENSION   Extension
    );

VOID
FtpVolumeOnlineCallback(
    IN  PVOLUME_EXTENSION   Extension
    );

VOID
FtpVolumeOfflineCallback(
    IN  PVOLUME_EXTENSION   Extension
    );

VOID
FtpPropogateRegistryState(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PFT_VOLUME          Volume
    );

VOID
FtpQueryRemoveCallback(
    IN  PVOLUME_EXTENSION   Extension
    );

VOID
FtDiskShutdownCompletionRoutine(
    IN  PVOID       Context,
    IN  NTSTATUS    Status
    );

NTSTATUS
FtpCheckForQueryRemove(
    IN OUT  PVOLUME_EXTENSION   Extension
    );

BOOLEAN
FtpCheckForCancelRemove(
    IN OUT  PVOLUME_EXTENSION   Extension
    );

VOID
FtpRemoveHelper(
    IN OUT  PVOLUME_EXTENSION   Extension
    );

VOID
FtpStartCallback(
    IN  PVOLUME_EXTENSION   Extension
    );

VOID
FtpWorkerThread(
    IN  PVOID   RootExtension
    );

VOID
FtpEventSignalCompletion(
    IN  PVOID       Event,
    IN  NTSTATUS    Status
    );

NTSTATUS
FtWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FtWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    );

NTSTATUS
FtpPmWmiCounterLibContext(
    IN OUT PROOT_EXTENSION RootExtension,
    IN     PIRP            Irp
    );

NTSTATUS
FtpCheckForCompleteVolume(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PFT_VOLUME          FtVolume
    );

VOID
FtpCancelChangeNotify(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PVOLUME_EXTENSION
FtpFindExtensionCoveringPartition(
    IN  PROOT_EXTENSION RootExtension,
    IN  PDEVICE_OBJECT  Partition
    );

VOID
FtpCleanupVolumeExtension(
    IN OUT  PVOLUME_EXTENSION   Extension
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, FtDiskAddDevice)
#endif

#define IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS_ADMIN  CTL_CODE(IOCTL_VOLUME_BASE, 0, METHOD_BUFFERED, FILE_READ_ACCESS)

#define UNIQUE_ID_MAX_BUFFER_SIZE           50
#define REVERT_GPT_ATTRIBUTES_REGISTRY_NAME (L"GptAttributeRevertEntries")


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
FtpAcquireWithTimeout(
    IN OUT  PROOT_EXTENSION RootExtension
    )

/*++

Routine Description:

    This routine grabs the root semaphore.  This routine will timeout
    after 10 seconds.

Arguments:

    RootExtension   - Supplies the root extension.

Return Value:

    None.

--*/

{
    LARGE_INTEGER   timeout;
    NTSTATUS        status;

    timeout.QuadPart = -10*(10*1000*1000);
    status = KeWaitForSingleObject(&RootExtension->Mutex, Executive,
                                   KernelMode, FALSE, &timeout);
    if (status == STATUS_TIMEOUT) {
        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}

VOID
FtpDeleteVolume(
    IN  PFT_VOLUME  Volume
    )

{
    USHORT      n, i;
    PFT_VOLUME  vol;

    n = Volume->QueryNumberOfMembers();
    for (i = 0; i < n; i++) {
        vol = Volume->GetMember(i);
        if (vol) {
            FtpDeleteVolume(vol);
        }
    }

    if (!InterlockedDecrement(&Volume->_refCount)) {
        delete Volume;
    }
}

PFT_VOLUME
FtpBuildFtVolume(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN OUT  PDEVICE_OBJECT      Partition,
    IN OUT  PDEVICE_OBJECT      WholeDiskPdo
    )

/*++

Routine Description:

    This routine builds up an FT volume object for the given logical
    disk id.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id.

    Partition       - Supplies the first partition for this volume.

    WholeDiskPdo    - Supplies the whole disk PDO.

Return Value:

    A new FT volume object or NULL.

--*/

{
    PFT_LOGICAL_DISK_INFORMATION_SET    diskInfoSet = RootExtension->DiskInfoSet;
    FT_LOGICAL_DISK_TYPE                diskType;
    LONGLONG                            offset;
    ULONG                               sectorSize;
    PPARTITION                          partition;
    NTSTATUS                            status;
    USHORT                              numMembers, i;
    PFT_VOLUME*                         volArray;
    PCOMPOSITE_FT_VOLUME                comp;

    if (!LogicalDiskId) {
        return NULL;
    }

    diskType = diskInfoSet->QueryLogicalDiskType(LogicalDiskId);
    if (diskType == FtPartition) {

        partition = new PARTITION;
        if (!partition) {
            return NULL;
        }

        status = partition->Initialize(RootExtension, LogicalDiskId,
                                       Partition, WholeDiskPdo);
        if (!NT_SUCCESS(status)) {
            delete partition;
            return NULL;
        }

        return partition;
    }

    switch (diskType) {

        case FtVolumeSet:
            comp = new VOLUME_SET;
            break;

        case FtStripeSet:
            comp = new STRIPE;
            break;

        case FtMirrorSet:
            comp = new MIRROR;
            break;

        case FtStripeSetWithParity:
            comp = new STRIPE_WP;
            break;

        case FtRedistribution:
            comp = new REDISTRIBUTION;
            break;

        default:
            comp = NULL;
            break;

    }

    if (!comp) {
        return comp;
    }

    numMembers = diskInfoSet->QueryNumberOfMembersInLogicalDisk(LogicalDiskId);
    ASSERT(numMembers);

    volArray = (PFT_VOLUME*)
               ExAllocatePool(NonPagedPool, numMembers*sizeof(PFT_VOLUME));
    if (!volArray) {
        delete comp;
        return NULL;
    }

    for (i = 0; i < numMembers; i++) {
        volArray[i] = FtpBuildFtVolume(RootExtension,
                      diskInfoSet->QueryMemberLogicalDiskId(LogicalDiskId, i),
                      Partition, WholeDiskPdo);
    }

    status = comp->Initialize(RootExtension, LogicalDiskId, volArray,
                              numMembers, diskInfoSet->
                              GetConfigurationInformation(LogicalDiskId),
                              diskInfoSet->GetStateInformation(LogicalDiskId));

    if (!NT_SUCCESS(status)) {
        for (i = 0; i < numMembers; i++) {
            if (volArray[i]) {
                FtpDeleteVolume(volArray[i]);
            }
        }
        delete comp;
        return NULL;
    }

    return comp;
}

VOID
FtpCheckForRevertGptAttributes(
    IN  PROOT_EXTENSION                 RootExtension,
    IN  PDEVICE_OBJECT                  Partition,
    IN  ULONG                           MbrSignature,
    IN  GUID*                           GptPartitionGuid,
    IN  PFT_LOGICAL_DISK_INFORMATION    DiskInfo
    )

{
    ULONG                           i, n;
    PFTP_GPT_ATTRIBUTE_REVERT_ENTRY p;

    n = RootExtension->NumberOfAttributeRevertEntries;
    p = RootExtension->GptAttributeRevertEntries;
    for (i = 0; i < n; i++) {

        if (MbrSignature) {
            if (MbrSignature == p[i].MbrSignature) {
                break;
            }
        } else {
            if (IsEqualGUID(p[i].PartitionUniqueId, *GptPartitionGuid)) {
                break;
            }
        }
    }

    if (i == n) {
        return;
    }

    if (MbrSignature) {
        DiskInfo->SetGptAttributes(p[i].GptAttributes);
    } else {
        FtpSetGptAttributesOnDisk(Partition, p[i].GptAttributes);
    }

    RootExtension->NumberOfAttributeRevertEntries--;

    if (i + 1 == n) {
        if (!RootExtension->NumberOfAttributeRevertEntries) {
            ExFreePool(RootExtension->GptAttributeRevertEntries);
            RootExtension->GptAttributeRevertEntries = NULL;
        }
        return;
    }

    RtlMoveMemory(&p[i], &p[i + 1],
                  (n - i - 1)*sizeof(FTP_GPT_ATTRIBUTE_REVERT_ENTRY));
}

NTSTATUS
FtpQueryPartitionInformation(
    IN  PROOT_EXTENSION RootExtension,
    IN  PDEVICE_OBJECT  Partition,
    OUT PULONG          DiskNumber,
    OUT PLONGLONG       Offset,
    OUT PULONG          PartitionNumber,
    OUT PUCHAR          PartitionType,
    OUT PLONGLONG       PartitionLength,
    OUT GUID*           PartitionTypeGuid,
    OUT GUID*           PartitionUniqueIdGuid,
    OUT PBOOLEAN        IsGpt,
    OUT PULONGLONG      GptAttributes
    )

/*++

Routine Description:

    This routine returns the disk number and offset for the given partition.

Arguments:

    Partition       - Supplies the partition.

    DiskNumber      - Returns the disk number.

    Offset          - Returns the offset.

    PartitionNumber - Returns the partition number.

    PartitionType   - Returns the partition type.

    PartitionLength - Returns the partition length.

Return Value:

    NTSTATUS

--*/

{
    KEVENT                      event;
    PIRP                        irp;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;
    STORAGE_DEVICE_NUMBER       number;
    PLIST_ENTRY                 l;
    PARTITION_INFORMATION_EX    partInfo;

    if (DiskNumber || PartitionNumber) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        irp = IoBuildDeviceIoControlRequest(IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                            Partition, NULL, 0, &number,
                                            sizeof(number), FALSE, &event,
                                            &ioStatus);
        if (!irp) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = IoCallDriver(Partition, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (DiskNumber) {
            *DiskNumber = number.DeviceNumber;
        }

        if (PartitionNumber) {
            *PartitionNumber = number.PartitionNumber;
        }
    }

    if (Offset || PartitionType || PartitionLength || PartitionTypeGuid ||
        PartitionUniqueIdGuid || IsGpt || GptAttributes) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO_EX,
                                            Partition, NULL, 0, &partInfo,
                                            sizeof(partInfo), FALSE, &event,
                                            &ioStatus);
        if (!irp) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = IoCallDriver(Partition, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (Offset) {
            *Offset = partInfo.StartingOffset.QuadPart;
        }

        if (PartitionType) {
            if (partInfo.PartitionStyle == PARTITION_STYLE_MBR) {
                *PartitionType = partInfo.Mbr.PartitionType;
            } else {
                *PartitionType = 0;
            }
        }

        if (PartitionLength) {
            *PartitionLength = partInfo.PartitionLength.QuadPart;
        }

        if (PartitionTypeGuid) {
            if (partInfo.PartitionStyle == PARTITION_STYLE_GPT) {
                *PartitionTypeGuid = partInfo.Gpt.PartitionType;
            }
        }

        if (PartitionUniqueIdGuid) {
            if (partInfo.PartitionStyle == PARTITION_STYLE_GPT) {
                *PartitionUniqueIdGuid = partInfo.Gpt.PartitionId;
            }
        }

        if (IsGpt) {
            if (partInfo.PartitionStyle == PARTITION_STYLE_GPT) {
                *IsGpt = TRUE;
            } else {
                *IsGpt = FALSE;
            }
        }

        if (GptAttributes) {
            if (partInfo.PartitionStyle == PARTITION_STYLE_GPT) {
                *GptAttributes = partInfo.Gpt.Attributes;
            } else {
                *GptAttributes = 0;
            }
        }
    }

    return STATUS_SUCCESS;
}

PVOLUME_EXTENSION
FtpFindExtensionCoveringDiskId(
    IN  PROOT_EXTENSION     RootExtension,
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine finds the device extension for the given root logical
    disk id.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id.

Return Value:

    A volume extension or NULL.

--*/

{
    PLIST_ENTRY         l;
    PVOLUME_EXTENSION   extension;

    for (l = RootExtension->VolumeList.Flink; l != &RootExtension->VolumeList;
         l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        if (extension->FtVolume &&
            extension->FtVolume->GetContainedLogicalDisk(LogicalDiskId)) {

            return extension;
        }
    }

    return NULL;
}

PVOLUME_EXTENSION
FtpFindExtension(
    IN  PROOT_EXTENSION     RootExtension,
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine finds the device extension for the given root logical
    disk id.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id.

Return Value:

    A volume extension or NULL.

--*/

{
    PLIST_ENTRY         l;
    PVOLUME_EXTENSION   extension;

    for (l = RootExtension->VolumeList.Flink; l != &RootExtension->VolumeList;
         l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        if (extension->FtVolume &&
            extension->FtVolume->QueryLogicalDiskId() == LogicalDiskId) {

            return extension;
        }
    }

    return NULL;
}

class EMPTY_IRP_QUEUE_WORK_ITEM : public WORK_QUEUE_ITEM {

    public:

        LIST_ENTRY          IrpQueue;
        PVOLUME_EXTENSION   Extension;

};

typedef EMPTY_IRP_QUEUE_WORK_ITEM *PEMPTY_IRP_QUEUE_WORK_ITEM;

VOID
FtpEmptyQueueWorkerRoutine(
    IN  PVOID   WorkItem
    )

/*++

Routine Description:

    This routine empties the given queue of irps by calling their respective
    dispatch routines.

Arguments:

    WorkItem    - Supplies the work item.

Return Value:

    None.

--*/

{
    PEMPTY_IRP_QUEUE_WORK_ITEM  workItem = (PEMPTY_IRP_QUEUE_WORK_ITEM) WorkItem;
    PLIST_ENTRY                 q, l;
    PDRIVER_OBJECT              driverObject;
    PDEVICE_OBJECT              deviceObject;
    PIRP                        irp;
    PIO_STACK_LOCATION          irpSp;

    q = &workItem->IrpQueue;
    driverObject = workItem->Extension->Root->DriverObject;
    deviceObject = workItem->Extension->DeviceObject;

    while (!IsListEmpty(q)) {
        l = RemoveHeadList(q);
        irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
        irpSp = IoGetCurrentIrpStackLocation(irp);
        driverObject->MajorFunction[irpSp->MajorFunction](deviceObject, irp);
    }

    ExFreePool(WorkItem);
}

ULONG
FtpQueryDiskSignature(
    IN  PDEVICE_OBJECT  WholeDiskPdo
    )

/*++

Routine Description:

    This routine queries the disk signature for the given disk.

Arguments:

    WholeDisk   - Supplies the whole disk.

Return Value:

    The disk signature.

--*/

{
    PDEVICE_OBJECT              wholeDisk;
    KEVENT                      event;
    PIRP                        irp;
    PARTMGR_DISK_SIGNATURE      partSig;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;

    wholeDisk = IoGetAttachedDeviceReference(WholeDiskPdo);
    if (!wholeDisk) {
        return 0;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_PARTMGR_QUERY_DISK_SIGNATURE,
                                        wholeDisk, NULL, 0, &partSig,
                                        sizeof(partSig), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        ObDereferenceObject(wholeDisk);
        return 0;
    }

    status = IoCallDriver(wholeDisk, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        ObDereferenceObject(wholeDisk);
        return 0;
    }

    ObDereferenceObject(wholeDisk);

    return partSig.Signature;
}

BOOLEAN
FtpQueryUniqueIdBuffer(
    IN  PVOLUME_EXTENSION   Extension,
    OUT PUCHAR              UniqueId,
    OUT PUSHORT             UniqueIdLength
    )

{
    GUID                uniqueGuid;
    ULONG               signature;
    NTSTATUS            status;
    LONGLONG            offset;
    FT_LOGICAL_DISK_ID  diskId;

    if (Extension->IsGpt) {
        *UniqueIdLength = sizeof(GUID) + 8;
    } else if (Extension->TargetObject) {
        *UniqueIdLength = sizeof(ULONG) + sizeof(LONGLONG);
    } else if (Extension->FtVolume) {
        *UniqueIdLength = sizeof(FT_LOGICAL_DISK_ID);
    } else {
        return FALSE;
    }

    if (!UniqueId) {
        return TRUE;
    }

    if (Extension->IsGpt) {

        RtlCopyMemory(UniqueId, "DMIO:ID:", 8);
        RtlCopyMemory(UniqueId + 8, &Extension->UniqueIdGuid, sizeof(GUID));

    } else if (Extension->TargetObject) {

        ASSERT(Extension->WholeDiskPdo);

        signature = FtpQueryDiskSignature(Extension->WholeDiskPdo);
        if (!signature) {
            return FALSE;
        }

        status = FtpQueryPartitionInformation(Extension->Root,
                                              Extension->TargetObject,
                                              NULL, &offset, NULL, NULL, NULL,
                                              NULL, NULL, NULL, NULL);

        if (!NT_SUCCESS(status)) {
            return FALSE;
        }

        RtlCopyMemory(UniqueId, &signature, sizeof(signature));
        RtlCopyMemory(UniqueId + sizeof(signature), &offset, sizeof(offset));

    } else {
        diskId = Extension->FtVolume->QueryLogicalDiskId();
        RtlCopyMemory(UniqueId, &diskId, sizeof(diskId));
    }

    return TRUE;
}

UCHAR
FtpQueryMountLetter(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine queries the drive letter from the mount point manager.

Arguments:

    Extension   - Supplies the volume extension.

    Delete      - Supplies whether or not to delete the drive letter.

Return Value:

    A mount point drive letter or 0.

--*/

{
    USHORT                  uniqueIdLength;
    ULONG                   mountPointSize;
    PMOUNTMGR_MOUNT_POINT   mountPoint;
    UNICODE_STRING          name;
    NTSTATUS                status;
    PFILE_OBJECT            fileObject;
    PDEVICE_OBJECT          deviceObject;
    KEVENT                  event;
    PIRP                    irp;
    MOUNTMGR_MOUNT_POINTS   points;
    IO_STATUS_BLOCK         ioStatus;
    ULONG                   mountPointsSize;
    PMOUNTMGR_MOUNT_POINTS  mountPoints;
    BOOLEAN                 freeMountPoints;
    UNICODE_STRING          dosDevices;
    UCHAR                   driveLetter;
    ULONG                   i;
    UNICODE_STRING          subString;
    WCHAR                   c;

    if (!FtpQueryUniqueIdBuffer(Extension, NULL, &uniqueIdLength)) {
        return 0;
    }

    mountPointSize = sizeof(MOUNTMGR_MOUNT_POINT) + uniqueIdLength;
    mountPoint = (PMOUNTMGR_MOUNT_POINT)
                 ExAllocatePool(PagedPool, mountPointSize);
    if (!mountPoint) {
        return 0;
    }

    if (!FtpQueryUniqueIdBuffer(Extension, (PUCHAR) (mountPoint + 1),
                                &uniqueIdLength)) {

        ExFreePool(mountPoint);
        return 0;
    }

    RtlZeroMemory(mountPoint, sizeof(MOUNTMGR_MOUNT_POINT));
    mountPoint->UniqueIdOffset = (USHORT) sizeof(MOUNTMGR_MOUNT_POINT);
    mountPoint->UniqueIdLength = uniqueIdLength;

    RtlInitUnicodeString(&name, MOUNTMGR_DEVICE_NAME);
    status = IoGetDeviceObjectPointer(&name, FILE_READ_ATTRIBUTES, &fileObject,
                                      &deviceObject);
    if (!NT_SUCCESS(status)) {
        ExFreePool(mountPoint);
        return 0;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTMGR_QUERY_POINTS,
                                        deviceObject, mountPoint,
                                        mountPointSize, &points,
                                        sizeof(points), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        ObDereferenceObject(fileObject);
        ExFreePool(mountPoint);
        return 0;
    }

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (status == STATUS_BUFFER_OVERFLOW) {

        mountPointsSize = points.Size;
        mountPoints = (PMOUNTMGR_MOUNT_POINTS)
                      ExAllocatePool(PagedPool, mountPointsSize);
        if (!mountPoints) {
            ObDereferenceObject(fileObject);
            ExFreePool(mountPoint);
            return 0;
        }

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTMGR_QUERY_POINTS,
                                            deviceObject, mountPoint,
                                            mountPointSize, mountPoints,
                                            mountPointsSize, FALSE, &event,
                                            &ioStatus);
        if (!irp) {
            ExFreePool(mountPoints);
            ObDereferenceObject(fileObject);
            ExFreePool(mountPoint);
            return 0;
        }

        status = IoCallDriver(deviceObject, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        freeMountPoints = TRUE;

    } else {
        mountPoints = &points;
        freeMountPoints = FALSE;
    }

    ExFreePool(mountPoint);
    ObDereferenceObject(fileObject);

    if (!NT_SUCCESS(status)) {
        if (freeMountPoints) {
            ExFreePool(mountPoints);
        }
        return 0;
    }

    RtlInitUnicodeString(&dosDevices, L"\\DosDevices\\");

    driveLetter = 0;
    for (i = 0; i < mountPoints->NumberOfMountPoints; i++) {

        if (mountPoints->MountPoints[i].SymbolicLinkNameLength !=
            dosDevices.Length + 2*sizeof(WCHAR)) {

            continue;
        }

        subString.Length = subString.MaximumLength = dosDevices.Length;
        subString.Buffer = (PWSTR) ((PCHAR) mountPoints +
                mountPoints->MountPoints[i].SymbolicLinkNameOffset);

        if (RtlCompareUnicodeString(&dosDevices, &subString, TRUE)) {
            continue;
        }

        c = subString.Buffer[subString.Length/sizeof(WCHAR) + 1];

        if (c != ':') {
            continue;
        }

        c = subString.Buffer[subString.Length/sizeof(WCHAR)];

        if (c < FirstDriveLetter || c > LastDriveLetter) {
            continue;
        }

        driveLetter = (UCHAR) c;
        break;
    }

    if (freeMountPoints) {
        ExFreePool(mountPoints);
    }

    return driveLetter;
}

NTSTATUS
FtpDiskRegistryQueryRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine is a query routine for the disk registry entry.  It allocates
    space for the disk registry and copies it to the given context.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Returns the disk registry entry.

    EntryContext    - Returns the disk registry size.

Return Value:

    NTSTATUS

--*/

{
    PVOID                   p;
    PDISK_CONFIG_HEADER*    reg;
    PULONG                  size;

    p = ExAllocatePool(PagedPool, ValueLength);
    if (!p) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(p, ValueData, ValueLength);

    reg = (PDISK_CONFIG_HEADER*) Context;
    *reg = (PDISK_CONFIG_HEADER) p;

    size = (PULONG) EntryContext;
    if (size) {
        *size = ValueLength;
    }

    return STATUS_SUCCESS;
}

PDISK_PARTITION
FtpFindDiskPartition(
    IN  PDISK_REGISTRY  DiskRegistry,
    IN  ULONG           Signature,
    IN  LONGLONG        Offset
    )

{
    PDISK_DESCRIPTION   diskDescription;
    USHORT              i, j;
    PDISK_PARTITION     diskPartition;
    LONGLONG            tmp;

    diskDescription = &DiskRegistry->Disks[0];
    for (i = 0; i < DiskRegistry->NumberOfDisks; i++) {
        if (diskDescription->Signature == Signature) {
            for (j = 0; j < diskDescription->NumberOfPartitions; j++) {
                diskPartition = &diskDescription->Partitions[j];
                RtlCopyMemory(&tmp, &diskPartition->StartingOffset.QuadPart,
                              sizeof(LONGLONG));
                if (tmp == Offset) {
                    return diskPartition;
                }
            }
        }

        diskDescription = (PDISK_DESCRIPTION) &diskDescription->
                          Partitions[diskDescription->NumberOfPartitions];
    }

    return NULL;
}

UCHAR
FtpQueryDriveLetterFromRegistry(
    IN  PROOT_EXTENSION RootExtension,
    IN  PDEVICE_OBJECT  TargetObject,
    IN  PDEVICE_OBJECT  WholeDiskPdo,
    IN  BOOLEAN         DeleteLetter
    )

/*++

Routine Description:

    This routine queries the sticky drive letter from the old registry.

Arguments:

    RootExtension   - Supplies the root extension.

    TargetObject    - Supplies the device object for the partition.

    WholeDiskPdo    - Supplies the whole disk PDO.

    DeleteLetter    - Supplies whether or not to delete the drive letter.

Return Value:

    A sticky drive letter.
    0 to represent no drive letter.

--*/

{
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    ULONG                       registrySize;
    NTSTATUS                    status;
    PDISK_CONFIG_HEADER         registry;
    PDISK_REGISTRY              diskRegistry;
    ULONG                       signature;
    LONGLONG                    offset;
    PDISK_PARTITION             diskPartition;
    UCHAR                       driveLetter;

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = FtpDiskRegistryQueryRoutine;
    queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = L"Information";
    queryTable[0].EntryContext = &registrySize;

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, DISK_REGISTRY_KEY_W,
                                    queryTable, &registry, NULL);
    if (!NT_SUCCESS(status)) {
        return 0;
    }

    diskRegistry = (PDISK_REGISTRY)
                   ((PUCHAR) registry + registry->DiskInformationOffset);

    signature = FtpQueryDiskSignature(WholeDiskPdo);
    if (!signature) {
        ExFreePool(registry);
        return 0;
    }

    status = FtpQueryPartitionInformation(RootExtension, TargetObject,
                                          NULL, &offset, NULL, NULL, NULL,
                                          NULL, NULL, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        ExFreePool(registry);
        return 0;
    }

    diskPartition = FtpFindDiskPartition(diskRegistry, signature, offset);
    if (!diskPartition) {
        ExFreePool(registry);
        return 0;
    }

    if (diskPartition->AssignDriveLetter) {
        driveLetter = diskPartition->DriveLetter;
    } else {
        driveLetter = 0xFF;
    }

    if (DeleteLetter) {
        diskPartition->DriveLetter = 0;
        diskPartition->AssignDriveLetter = TRUE;
        RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, DISK_REGISTRY_KEY_W,
                              L"Information", REG_BINARY, registry,
                              registrySize);
    }

    ExFreePool(registry);

    return driveLetter;
}

UCHAR
FtpQueryDriveLetterFromRegistry(
    IN  PVOLUME_EXTENSION   Extension,
    IN  BOOLEAN             DeleteLetter
    )

/*++

Routine Description:

    This routine queries the sticky drive letter from the old registry.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    A sticky drive letter.
    0 to represent no drive letter.

--*/

{
    if (Extension->TargetObject) {
        return FtpQueryDriveLetterFromRegistry(Extension->Root,
                                               Extension->TargetObject,
                                               Extension->WholeDiskPdo,
                                               DeleteLetter);
    }

    return 0;
}

BOOLEAN
FtpSetMountLetter(
    IN  PVOLUME_EXTENSION   Extension,
    IN  UCHAR               DriveLetter
    )

/*++

Routine Description:

    This routine sets a drive letter to the given device in the mount table.

Arguments:

    Extension   - Supplies the volume extension.

    DriveLetter - Supplies the drive letter.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    WCHAR                           dosBuffer[30];
    UNICODE_STRING                  dosName;
    WCHAR                           ntBuffer[40];
    UNICODE_STRING                  ntName;
    ULONG                           createPointSize;
    PMOUNTMGR_CREATE_POINT_INPUT    createPoint;
    UNICODE_STRING                  name;
    NTSTATUS                        status;
    PFILE_OBJECT                    fileObject;
    PDEVICE_OBJECT                  deviceObject;
    KEVENT                          event;
    PIRP                            irp;
    IO_STATUS_BLOCK                 ioStatus;

    swprintf(dosBuffer, L"\\DosDevices\\%c:", DriveLetter);
    RtlInitUnicodeString(&dosName, dosBuffer);

    swprintf(ntBuffer, L"\\Device\\HarddiskVolume%d", Extension->VolumeNumber);
    RtlInitUnicodeString(&ntName, ntBuffer);

    createPointSize = sizeof(MOUNTMGR_CREATE_POINT_INPUT) +
                      dosName.Length + ntName.Length;

    createPoint = (PMOUNTMGR_CREATE_POINT_INPUT)
                  ExAllocatePool(PagedPool, createPointSize);
    if (!createPoint) {
        return FALSE;
    }

    createPoint->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
    createPoint->SymbolicLinkNameLength = dosName.Length;
    createPoint->DeviceNameOffset = createPoint->SymbolicLinkNameOffset +
                                    createPoint->SymbolicLinkNameLength;
    createPoint->DeviceNameLength = ntName.Length;

    RtlCopyMemory((PCHAR) createPoint + createPoint->SymbolicLinkNameOffset,
                  dosName.Buffer, dosName.Length);
    RtlCopyMemory((PCHAR) createPoint + createPoint->DeviceNameOffset,
                  ntName.Buffer, ntName.Length);

    RtlInitUnicodeString(&name, MOUNTMGR_DEVICE_NAME);
    status = IoGetDeviceObjectPointer(&name, FILE_READ_ATTRIBUTES, &fileObject,
                                      &deviceObject);
    if (!NT_SUCCESS(status)) {
        ExFreePool(createPoint);
        return 0;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTMGR_CREATE_POINT,
                                        deviceObject, createPoint,
                                        createPointSize, NULL, 0, FALSE,
                                        &event, &ioStatus);
    if (!irp) {
        ObDereferenceObject(fileObject);
        ExFreePool(createPoint);
        return FALSE;
    }

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ObDereferenceObject(fileObject);
    ExFreePool(createPoint);

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    return TRUE;
}

VOID
FtpCreateOldNameLinks(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine creates a \Device\Harddisk%d\Partition%d name for the
    given target device for legacy devices.  If successful, it stores the
    name in the device extension.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    None.

--*/

{
    WCHAR           deviceNameBuffer[64];
    UNICODE_STRING  deviceName;
    NTSTATUS        status;
    ULONG           diskNumber, partitionNumber, i;
    WCHAR           oldNameBuffer[80];
    UNICODE_STRING  oldName;

    swprintf(deviceNameBuffer, L"\\Device\\HarddiskVolume%d", Extension->VolumeNumber);
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);

    if (Extension->TargetObject) {

        status = FtpQueryPartitionInformation(Extension->Root,
                                              Extension->TargetObject,
                                              &diskNumber, NULL,
                                              &partitionNumber, NULL, NULL,
                                              NULL, NULL, NULL, NULL);
        if (!NT_SUCCESS(status)) {
            return;
        }

        swprintf(oldNameBuffer, L"\\Device\\Harddisk%d\\Partition%d",
                 diskNumber, partitionNumber);
        RtlInitUnicodeString(&oldName, oldNameBuffer);

        IoDeleteSymbolicLink(&oldName);
        for (i = 0; i < 1000; i++) {
            status = IoCreateSymbolicLink(&oldName, &deviceName);
            if (NT_SUCCESS(status)) {
                break;
            }
        }

    } else {
        Extension->FtVolume->CreateLegacyNameLinks(&deviceName);
    }
}

NTSTATUS
FtpQuerySuperFloppyDevnodeName(
    IN  PVOLUME_EXTENSION   Extension,
    OUT PWCHAR*             DevnodeName
    )

{
    NTSTATUS        status;
    UNICODE_STRING  string;
    PWCHAR          result;
    ULONG           n, i;
    WCHAR           c;

    status = IoRegisterDeviceInterface(Extension->WholeDiskPdo, &DiskClassGuid,
                                       NULL, &string);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    result = (PWCHAR) ExAllocatePool(PagedPool, string.Length + sizeof(WCHAR));
    if (!result) {
        ExFreePool(string.Buffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    n = string.Length/sizeof(WCHAR);
    for (i = 0; i < n; i++) {
        c = string.Buffer[i];
        if (c <= ' ' || c >= 0x80 || c == ',' || c == '\\') {
            c = '_';
        }
        result[i] = c;
    }
    result[n] = 0;
    ExFreePool(string.Buffer);

    *DevnodeName = result;

    return STATUS_SUCCESS;
}

BOOLEAN
FtpCreateNewDevice(
    IN  PROOT_EXTENSION     RootExtension,
    IN  PDEVICE_OBJECT      TargetObject,
    IN  PFT_VOLUME          FtVolume,
    IN  PDEVICE_OBJECT      WholeDiskPdo,
    IN  ULONG               AlignmentRequirement,
    IN  BOOLEAN             IsPreExposure,
    IN  BOOLEAN             IsHidden,
    IN  BOOLEAN             IsReadOnly,
    IN  BOOLEAN             IsEspType,
    IN  ULONGLONG           MbrGptAttributes
    )

/*++

Routine Description:

    This routine creates a new device object with the next available
    device name using the given target object of ft volume.

Arguments:

    RootExtension   - Supplies the root extension.

    TargetObject    - Supplies the partition.

    FtVolume        - Supplies the FT volume.

    WholeDiskPdo    - Supplies the whole disk PDO.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    WCHAR               volumeName[30];
    UNICODE_STRING      volumeString;
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject;
    PVOLUME_EXTENSION   extension, e;
    PWCHAR              buf;
    ULONG               signature;
    LONGLONG            offset, size;
    PLIST_ENTRY         l;
    LONG                r;
    GUID                uniqueGuid;
    UNICODE_STRING      guidString;
    BOOLEAN             IsGpt;

    ASSERT(TargetObject || FtVolume);
    ASSERT(!(TargetObject && FtVolume));
    ASSERT(!TargetObject || WholeDiskPdo);

    swprintf(volumeName, L"\\Device\\HarddiskVolume%d",
             RootExtension->NextVolumeNumber);
    RtlInitUnicodeString(&volumeString, volumeName);

    status = IoCreateDevice(RootExtension->DriverObject,
                            sizeof(VOLUME_EXTENSION),
                            &volumeString, FILE_DEVICE_DISK, 0,
                            FALSE, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    extension = (PVOLUME_EXTENSION) deviceObject->DeviceExtension;
    RtlZeroMemory(extension, sizeof(VOLUME_EXTENSION));
    extension->DeviceObject = deviceObject;
    extension->Root = RootExtension;
    extension->DeviceExtensionType = DEVICE_EXTENSION_VOLUME;
    KeInitializeSpinLock(&extension->SpinLock);
    extension->TargetObject = TargetObject;
    extension->FtVolume = FtVolume;
    extension->RefCount = 1;
    InitializeListHead(&extension->ZeroRefHoldQueue);
    extension->IsStarted = FALSE;
    extension->IsOffline = TRUE;
    extension->IsHidden = IsHidden;
    extension->IsReadOnly = IsReadOnly;
    extension->IsEspType = IsEspType;
    extension->VolumeNumber = RootExtension->NextVolumeNumber++;
    extension->EmergencyTransferPacket = new DISPATCH_TP;
    InitializeListHead(&extension->EmergencyTransferPacketQueue);
    extension->MbrGptAttributes = MbrGptAttributes;

    if (!extension->EmergencyTransferPacket) {
        IoDeleteDevice(deviceObject);
        return FALSE;
    }

    InitializeListHead(&extension->ChangeNotifyIrps);

    buf = (PWCHAR) ExAllocatePool(PagedPool, 80*sizeof(WCHAR));
    if (!buf) {
        delete extension->EmergencyTransferPacket;
        IoDeleteDevice(deviceObject);
        return FALSE;
    }

    if (TargetObject) {

        extension->WholeDiskPdo = WholeDiskPdo;
        extension->WholeDisk = IoGetAttachedDeviceReference(WholeDiskPdo);
        ObDereferenceObject(extension->WholeDisk);

        status = FtpQueryPartitionInformation(RootExtension, TargetObject,
                                              NULL, &offset, NULL, NULL,
                                              &size, NULL, &uniqueGuid,
                                              &IsGpt, NULL);
        if (!NT_SUCCESS(status)) {
            delete extension->EmergencyTransferPacket;
            IoDeleteDevice(deviceObject);
            return FALSE;
        }

        extension->PartitionOffset = offset;
        extension->PartitionLength = size;

        if (IsGpt) {
            extension->IsGpt = TRUE;
            extension->UniqueIdGuid = uniqueGuid;

            if (IsEspType &&
                IsEqualGUID(uniqueGuid,
                            RootExtension->ESPUniquePartitionGUID)) {

                IoSetSystemPartition(&volumeString);
            }

            status = RtlStringFromGUID(uniqueGuid, &guidString);
            if (!NT_SUCCESS(status)) {
                delete extension->EmergencyTransferPacket;
                IoDeleteDevice(deviceObject);
                return FALSE;
            }

            swprintf(buf, L"GptPartition%s", guidString.Buffer);
            ExFreePool(guidString.Buffer);

        } else if (offset == 0) {

            extension->IsSuperFloppy = TRUE;
            ExFreePool(buf);

            status = FtpQuerySuperFloppyDevnodeName(extension, &buf);
            if (!NT_SUCCESS(status)) {
                delete extension->EmergencyTransferPacket;
                IoDeleteDevice(deviceObject);
                return FALSE;
            }

        } else {

            signature = FtpQueryDiskSignature(extension->WholeDiskPdo);
            if (!signature) {
                delete extension->EmergencyTransferPacket;
                IoDeleteDevice(deviceObject);
                return FALSE;
            }

            swprintf(buf, L"Signature%XOffset%I64XLength%I64X", signature,
                     offset, size);
        }

    } else {
        swprintf(buf, L"Ft%I64X", FtVolume->QueryLogicalDiskId());
    }

    RtlInitUnicodeString(&extension->DeviceNodeName, buf);
    KeInitializeSemaphore(&extension->Semaphore, 1, 1);
    InsertTailList(&RootExtension->VolumeList, &extension->ListEntry);

    deviceObject->Flags |= DO_DIRECT_IO;
    deviceObject->AlignmentRequirement = AlignmentRequirement;
    if (FtVolume) {
        deviceObject->StackSize = FtVolume->QueryStackSize() + 1;
    } else {
        deviceObject->StackSize = TargetObject->StackSize + 1;
    }

    if (IsPreExposure) {
        extension->TargetObject = NULL;
        extension->FtVolume = NULL;
        extension->IsPreExposure = TRUE;
        extension->WholeDiskPdo = NULL;
        extension->WholeDisk = NULL;
        extension->PartitionOffset = 0;
        extension->PartitionLength = 0;

        r = 1;
        for (l = RootExtension->VolumeList.Flink;
             l != &RootExtension->VolumeList; l = l->Flink) {

            e = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
            if (e == extension) {
                continue;
            }
            r = RtlCompareUnicodeString(&e->DeviceNodeName,
                                        &extension->DeviceNodeName, TRUE);
            if (!r) {
                break;
            }
        }

        if (!r) {
            RemoveEntryList(&extension->ListEntry);
            ExFreePool(extension->DeviceNodeName.Buffer);
            delete extension->EmergencyTransferPacket;
            IoDeleteDevice(deviceObject);
            return FALSE;
        }

        RootExtension->PreExposureCount++;

    } else {
        FtpCreateOldNameLinks(extension);
    }

    if (!IsPreExposure && RootExtension->PreExposureCount) {
        r = 1;
        for (l = RootExtension->VolumeList.Flink;
             l != &RootExtension->VolumeList; l = l->Flink) {

            e = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
            if (e == extension) {
                continue;
            }
            if (!e->IsPreExposure) {
                continue;
            }

            r = RtlCompareUnicodeString(&e->DeviceNodeName,
                                        &extension->DeviceNodeName, TRUE);
            if (!r) {
                break;
            }
        }

        if (!r) {
            RootExtension->PreExposureCount--;
            RemoveEntryList(&e->ListEntry);
            InsertTailList(&RootExtension->DeadVolumeList, &e->ListEntry);
            FtpCleanupVolumeExtension(e);
        }
    }

    // Allocate WMI library context

    extension->WmilibContext = (PWMILIB_CONTEXT)
        ExAllocatePool(PagedPool, sizeof(WMILIB_CONTEXT));
    if (extension->WmilibContext != NULL) {
        RtlZeroMemory(extension->WmilibContext, sizeof(WMILIB_CONTEXT));
        extension->WmilibContext->GuidCount          = DiskperfGuidCount;
        extension->WmilibContext->GuidList           = DiskperfGuidList;
        extension->WmilibContext->QueryWmiRegInfo    = FtQueryWmiRegInfo;
        extension->WmilibContext->QueryWmiDataBlock  = FtQueryWmiDataBlock;
        extension->WmilibContext->WmiFunctionControl = FtWmiFunctionControl;
    }

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return TRUE;
}

PVOLUME_EXTENSION
FtpFindExtension(
    IN  PROOT_EXTENSION     RootExtension,
    IN  ULONG               Signature,
    IN  LONGLONG            Offset
    )

/*++

Routine Description:

    This routine finds the device extension for the given partition.

Arguments:

    RootExtension   - Supplies the root device extension.

    Signature       - Supplies the partition's disk signature.

    Offset          - Supplies the partition's offset.

Return Value:

    A volume extension or NULL.

--*/

{
    PLIST_ENTRY         l;
    PVOLUME_EXTENSION   extension;
    ULONG               signature;
    NTSTATUS            status;
    LONGLONG            offset;

    for (l = RootExtension->VolumeList.Flink; l != &RootExtension->VolumeList;
         l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        if (!extension->TargetObject) {
            continue;
        }

        signature = FtpQueryDiskSignature(extension->WholeDiskPdo);
        if (Signature != signature) {
            continue;
        }

        status = FtpQueryPartitionInformation(RootExtension,
                                              extension->TargetObject,
                                              NULL, &offset, NULL, NULL, NULL,
                                              NULL, NULL, NULL, NULL);
        if (!NT_SUCCESS(status)) {
            continue;
        }

        if (offset != Offset) {
            continue;
        }

        return extension;
    }

    return NULL;
}

BOOLEAN
FtpQueryNtDeviceNameString(
    IN  PROOT_EXTENSION     RootExtension,
    IN  ULONG               Signature,
    IN  LONGLONG            Offset,
    OUT PUNICODE_STRING     String
    )

{
    PVOLUME_EXTENSION   extension;
    PWSTR               stringBuffer;

    extension = FtpFindExtension(RootExtension, Signature, Offset);
    if (!extension) {
        return FALSE;
    }

    stringBuffer = (PWSTR) ExAllocatePool(PagedPool, 128);
    if (!stringBuffer) {
        return FALSE;
    }

    swprintf(stringBuffer, L"\\Device\\HarddiskVolume%d", extension->VolumeNumber);
    RtlInitUnicodeString(String, stringBuffer);

    return TRUE;
}

BOOLEAN
FtpQueryNtDeviceNameString(
    IN  PROOT_EXTENSION     RootExtension,
    IN  FT_LOGICAL_DISK_ID  RootLogicalDiskId,
    OUT PUNICODE_STRING     String
    )

{
    PVOLUME_EXTENSION   extension;
    PWSTR               stringBuffer;

    extension = FtpFindExtension(RootExtension, RootLogicalDiskId);
    if (!extension) {
        return FALSE;
    }

    stringBuffer = (PWSTR) ExAllocatePool(PagedPool, 128);
    if (!stringBuffer) {
        return FALSE;
    }

    swprintf(stringBuffer, L"\\Device\\HarddiskVolume%d", extension->VolumeNumber);
    RtlInitUnicodeString(String, stringBuffer);

    return TRUE;
}

BOOLEAN
FtpLockLogicalDisk(
    IN  PROOT_EXTENSION     RootExtension,
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    OUT PHANDLE             Handle
    )

/*++

Routine Description:

    This routine attempts to lock the given logical disk id by going through
    the file system.  If it is successful then it returns the handle to the
    locked volume.

Arguments:

    RootExtension   - Supplies the root extension.

    LogicalDiskId   - Supplies the logical disk id.

    Handle          - Returns a handle to the locked volume.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    UNICODE_STRING      string;
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    IO_STATUS_BLOCK     ioStatus;

    if (!FtpQueryNtDeviceNameString(RootExtension, LogicalDiskId, &string)) {
        return FALSE;
    }

    FtpRelease(RootExtension);

    InitializeObjectAttributes(&oa, &string, OBJ_CASE_INSENSITIVE, 0, 0);

    status = ZwOpenFile(Handle, SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                        &oa, &ioStatus, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);

    ExFreePool(string.Buffer);

    if (!NT_SUCCESS(status)) {
        FtpAcquire(RootExtension);
        return FALSE;
    }

    status = ZwFsControlFile(*Handle, 0, NULL, NULL, &ioStatus,
                             FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0);

    if (!NT_SUCCESS(status)) {
        ZwClose(*Handle);
        FtpAcquire(RootExtension);
        return FALSE;
    }

    FtpAcquire(RootExtension);

    return TRUE;
}

VOID
FtpUniqueIdNotify(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PMOUNTDEV_UNIQUE_ID NewUniqueId
    )

/*++

Routine Description:

    This routine goes through all of the mount manager clients that
    have registered to be aware of unique id changes to devices.

Arguments:

    Extension   - Supplies the volume extension.

    NewUniqueId - Supplies the new unique id.

Return Value:

    None.

--*/

{
    PMOUNTDEV_UNIQUE_ID                         oldUniqueId;
    UCHAR                                       oldUniqueIdBuffer[UNIQUE_ID_MAX_BUFFER_SIZE];
    PLIST_ENTRY                                 l;
    PIRP                                        irp;
    PIO_STACK_LOCATION                          irpSp;
    PMOUNTDEV_UNIQUE_ID                         input;
    ULONG                                       inputLength, outputLength;
    PMOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT    output;

    oldUniqueId = (PMOUNTDEV_UNIQUE_ID) oldUniqueIdBuffer;

    while (!IsListEmpty(&Extension->ChangeNotifyIrps)) {

        l = RemoveHeadList(&Extension->ChangeNotifyIrps);

        irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);

        //
        // Remove cancel routine. If cancel is active let it complete this IRP.
        //
        if (IoSetCancelRoutine (irp, NULL) == NULL) {
            InitializeListHead (&irp->Tail.Overlay.ListEntry);
            continue;
        }

        irpSp = IoGetCurrentIrpStackLocation(irp);
        input = (PMOUNTDEV_UNIQUE_ID) irp->AssociatedIrp.SystemBuffer;

        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(MOUNTDEV_UNIQUE_ID)) {

            irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Information = 0;
            IoCompleteRequest(irp, IO_NO_INCREMENT);
            continue;
        }

        inputLength = FIELD_OFFSET(MOUNTDEV_UNIQUE_ID, UniqueId) +
                      input->UniqueIdLength;

        if (inputLength >
            irpSp->Parameters.DeviceIoControl.InputBufferLength) {

            irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Information = 0;
            IoCompleteRequest(irp, IO_NO_INCREMENT);
            continue;
        }

        if (inputLength > 20) {
            irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Information = 0;
            IoCompleteRequest(irp, IO_NO_INCREMENT);
            continue;
        }

        RtlCopyMemory(oldUniqueId, input, inputLength);

        outputLength = sizeof(MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT) +
                       oldUniqueId->UniqueIdLength +
                       NewUniqueId->UniqueIdLength;

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT)) {

            irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Information = 0;
            IoCompleteRequest(irp, IO_NO_INCREMENT);
            continue;
        }

        output = (PMOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT)
                 irp->AssociatedIrp.SystemBuffer;
        output->Size = outputLength;

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            outputLength) {

            irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
            irp->IoStatus.Information =
                    sizeof(MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT);
            IoCompleteRequest(irp, IO_NO_INCREMENT);
            continue;
        }

        output->OldUniqueIdOffset =
                sizeof(MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT);
        output->OldUniqueIdLength = oldUniqueId->UniqueIdLength;
        output->NewUniqueIdOffset = output->OldUniqueIdOffset +
                                    output->OldUniqueIdLength;
        output->NewUniqueIdLength = NewUniqueId->UniqueIdLength;

        RtlCopyMemory((PCHAR) output + output->OldUniqueIdOffset,
                      oldUniqueId->UniqueId, output->OldUniqueIdLength);
        RtlCopyMemory((PCHAR) output + output->NewUniqueIdOffset,
                      NewUniqueId->UniqueId, output->NewUniqueIdLength);

        irp->IoStatus.Status = STATUS_SUCCESS;
        irp->IoStatus.Information = output->Size;

        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    // Perform a pre-exposure of the new devnode to avoid the PNP reboot
    // pop-up.

    if (FtpCreateNewDevice(Extension->Root, Extension->TargetObject,
                           Extension->FtVolume, Extension->WholeDiskPdo,
                           Extension->DeviceObject->AlignmentRequirement,
                           TRUE, TRUE, FALSE, FALSE, 0)) {

        IoInvalidateDeviceRelations(Extension->Root->Pdo, BusRelations);
    }
}

NTSTATUS
FtpDeleteMountPoints(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine deletes the all of the entries in the mount table that
    are pointing to the given unique id.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    NTSTATUS

--*/

{
    UNICODE_STRING          name;
    NTSTATUS                status;
    PFILE_OBJECT            fileObject;
    PDEVICE_OBJECT          deviceObject;
    WCHAR                   deviceNameBuffer[30];
    UNICODE_STRING          deviceName;
    PMOUNTMGR_MOUNT_POINT   point;
    UCHAR                   buffer[sizeof(MOUNTMGR_MOUNT_POINT) + 60];
    PVOID                   mountPoints;
    KEVENT                  event;
    PIRP                    irp;
    IO_STATUS_BLOCK         ioStatus;

    RtlInitUnicodeString(&name, MOUNTMGR_DEVICE_NAME);
    status = IoGetDeviceObjectPointer(&name, FILE_READ_ATTRIBUTES, &fileObject,
                                      &deviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    swprintf(deviceNameBuffer, L"\\Device\\HarddiskVolume%d", Extension->VolumeNumber);
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);

    point = (PMOUNTMGR_MOUNT_POINT) buffer;
    RtlZeroMemory(point, sizeof(MOUNTMGR_MOUNT_POINT));
    point->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    point->DeviceNameLength = deviceName.Length;
    RtlCopyMemory((PCHAR) point + point->DeviceNameOffset, deviceName.Buffer,
                  point->DeviceNameLength);

    mountPoints = ExAllocatePool(PagedPool, PAGE_SIZE);
    if (!mountPoints) {
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTMGR_DELETE_POINTS,
                                        deviceObject, point,
                                        sizeof(MOUNTMGR_MOUNT_POINT) +
                                        point->DeviceNameLength, mountPoints,
                                        PAGE_SIZE, FALSE, &event, &ioStatus);
    if (!irp) {
        ExFreePool(mountPoints);
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ExFreePool(mountPoints);
    ObDereferenceObject(fileObject);

    return status;
}

VOID
FtpCleanupVolumeExtension(
    IN OUT  PVOLUME_EXTENSION   Extension
    )

{
    PLIST_ENTRY              l;
    PIRP                     irp;
    PPMWMICOUNTERLIB_CONTEXT counterLib;

    if (Extension->EmergencyTransferPacket) {
        delete Extension->EmergencyTransferPacket;
        Extension->EmergencyTransferPacket = NULL;
    }

    while (!IsListEmpty(&Extension->ChangeNotifyIrps)) {

        l = RemoveHeadList(&Extension->ChangeNotifyIrps);
        irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);

        //
        // Remove cancel routine. If cancel is active let it complete this IRP.
        //
        if (IoSetCancelRoutine (irp, NULL) == NULL) {
            InitializeListHead (&irp->Tail.Overlay.ListEntry);
            continue;
        }

        irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        irp->IoStatus.Information = 0;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    if (Extension->WmilibContext != NULL) {
        IoWMIRegistrationControl(Extension->DeviceObject,
                                 WMIREG_ACTION_DEREGISTER);
        ExFreePool(Extension->WmilibContext);
        Extension->WmilibContext = NULL;

        counterLib = &Extension->Root->PmWmiCounterLibContext;
        counterLib->PmWmiCounterDisable(&Extension->PmWmiCounterContext,
                                        TRUE, TRUE);
        Extension->CountersEnabled = FALSE;
    }
}


NTSTATUS
FtpStartSystemThread(
    IN  PROOT_EXTENSION RootExtension
    )

{
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    HANDLE              handle;

    if (!RootExtension->TerminateThread) {
        return STATUS_SUCCESS;
    }

    InterlockedExchange(&RootExtension->TerminateThread, FALSE);

    InitializeObjectAttributes(&oa, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

    status = PsCreateSystemThread(&handle, 0, &oa, 0, NULL, FtpWorkerThread,
                                  RootExtension);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = ObReferenceObjectByHandle(handle, THREAD_ALL_ACCESS, NULL,
                                       KernelMode,
                                       &RootExtension->WorkerThread, NULL);
    ZwClose(handle);

    if (!NT_SUCCESS(status)) {
        InterlockedExchange(&RootExtension->TerminateThread, TRUE);
    }

    return status;
}

NTSTATUS
FtpCreateLogicalDisk(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine creates the given logical disk.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_CREATE_LOGICAL_DISK_INPUT       createDisk;
    ULONG                               inputSize;
    PVOID                               configInfo;
    NTSTATUS                            status;
    FT_LOGICAL_DISK_ID                  newLogicalDiskId;
    PFT_CREATE_LOGICAL_DISK_OUTPUT      createDiskOutput;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_CREATE_LOGICAL_DISK_INPUT) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(FT_CREATE_LOGICAL_DISK_OUTPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    createDisk = (PFT_CREATE_LOGICAL_DISK_INPUT)
                 Irp->AssociatedIrp.SystemBuffer;

    inputSize = FIELD_OFFSET(FT_CREATE_LOGICAL_DISK_INPUT, MemberArray) +
                createDisk->NumberOfMembers*sizeof(FT_LOGICAL_DISK_ID) +
                createDisk->ConfigurationInformationSize;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < inputSize) {
        return STATUS_INVALID_PARAMETER;
    }

    configInfo = &createDisk->MemberArray[createDisk->NumberOfMembers];

    if (!RootExtension->FtCodeLocked) {
        MmLockPagableCodeSection(FtpComputeParity);
        status = FtpStartSystemThread(RootExtension);
        if (!NT_SUCCESS(status)) {
            return status;
        }
        RootExtension->FtCodeLocked = TRUE;
    }

    status = FtpCreateLogicalDiskHelper(RootExtension,
                                        createDisk->LogicalDiskType,
                                        createDisk->NumberOfMembers,
                                        createDisk->MemberArray,
                                        createDisk->ConfigurationInformationSize,
                                        configInfo, 0, NULL, &newLogicalDiskId);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    createDiskOutput = (PFT_CREATE_LOGICAL_DISK_OUTPUT)
                       Irp->AssociatedIrp.SystemBuffer;

    createDiskOutput->NewLogicalDiskId = newLogicalDiskId;
    Irp->IoStatus.Information = sizeof(FT_CREATE_LOGICAL_DISK_OUTPUT);

    return status;
}

VOID
FtpResetPartitionType(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine resets the FT bit in the partition type.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT              targetObject;
    KEVENT                      event;
    PIRP                        irp;
    PARTITION_INFORMATION       partInfo;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;
    SET_PARTITION_INFORMATION   setPartInfo;

    targetObject = Extension->TargetObject;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO,
                                        targetObject, NULL, 0, &partInfo,
                                        sizeof(partInfo), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return;
    }

    status = IoCallDriver(targetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return;
    }

    setPartInfo.PartitionType = (partInfo.PartitionType & ~(0x80));

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_SET_PARTITION_INFO,
                                        targetObject, &setPartInfo,
                                        sizeof(setPartInfo), NULL, 0, FALSE,
                                        &event, &ioStatus);
    if (!irp) {
        return;
    }

    status = IoCallDriver(targetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }
}

NTSTATUS
FtpBreakLogicalDisk(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine breaks a given logical disk.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_BREAK_LOGICAL_DISK_INPUT            input;
    FT_LOGICAL_DISK_ID                      diskId;
    NTSTATUS                                status;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_BREAK_LOGICAL_DISK_INPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_BREAK_LOGICAL_DISK_INPUT) Irp->AssociatedIrp.SystemBuffer;
    diskId = input->RootLogicalDiskId;

    status = FtpBreakLogicalDiskHelper(RootExtension, diskId);

    return status;
}

NTSTATUS
FtpEnumerateLogicalDisks(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine enumerates all of the logical disks in the system.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_LOGICAL_DISK_INFORMATION_SET    diskInfoSet;
    PFT_ENUMERATE_LOGICAL_DISKS_OUTPUT  output;
    ULONG                               i;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(FT_ENUMERATE_LOGICAL_DISKS_OUTPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    diskInfoSet = RootExtension->DiskInfoSet;
    output = (PFT_ENUMERATE_LOGICAL_DISKS_OUTPUT)
             Irp->AssociatedIrp.SystemBuffer;

    output->NumberOfRootLogicalDisks =
            diskInfoSet->QueryNumberOfRootLogicalDiskIds();
    Irp->IoStatus.Information = FIELD_OFFSET(FT_ENUMERATE_LOGICAL_DISKS_OUTPUT,
                                             RootLogicalDiskIds) +
                                output->NumberOfRootLogicalDisks*
                                sizeof(FT_LOGICAL_DISK_ID);
    if (Irp->IoStatus.Information >
        irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

        Irp->IoStatus.Information =
                FIELD_OFFSET(FT_ENUMERATE_LOGICAL_DISKS_OUTPUT,
                             RootLogicalDiskIds);
        return STATUS_BUFFER_OVERFLOW;
    }

    for (i = 0; i < output->NumberOfRootLogicalDisks; i++) {
        output->RootLogicalDiskIds[i] = diskInfoSet->QueryRootLogicalDiskId(i);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryLogicalDiskInformation(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine returns the logical disk information.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_QUERY_LOGICAL_DISK_INFORMATION_INPUT    input;
    PFT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT   output;
    FT_LOGICAL_DISK_ID                          diskId;
    PFT_LOGICAL_DISK_INFORMATION_SET            diskInfoSet;
    PVOLUME_EXTENSION                           extension;
    PFT_VOLUME                                  topVol, vol;
    PFT_LOGICAL_DISK_DESCRIPTION                diskDescription;
    PFT_PARTITION_CONFIGURATION_INFORMATION     partInfo;
    LONGLONG                                    offset;
    PDEVICE_OBJECT                              wholeDisk;
    ULONG                                       diskNumber, sectorSize;
    PDRIVE_LAYOUT_INFORMATION_EX                layout;
    NTSTATUS                                    status;
    USHORT                                      i;
    PCHAR                                       p, q;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_QUERY_LOGICAL_DISK_INFORMATION_INPUT) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(FT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_QUERY_LOGICAL_DISK_INFORMATION_INPUT)
            Irp->AssociatedIrp.SystemBuffer;
    output = (PFT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT)
             Irp->AssociatedIrp.SystemBuffer;
    diskId = input->LogicalDiskId;

    diskInfoSet = RootExtension->DiskInfoSet;
    diskDescription = diskInfoSet->GetLogicalDiskDescription(diskId, 0);
    if (!diskDescription) {
        return STATUS_INVALID_PARAMETER;
    }

    output->LogicalDiskType = diskDescription->LogicalDiskType;
    output->VolumeSize = 0;

    extension = FtpFindExtensionCoveringDiskId(RootExtension, diskId);
    if (extension) {
        topVol = extension->FtVolume;
        vol = topVol->GetContainedLogicalDisk(diskId);
        output->VolumeSize = vol->QueryVolumeSize();
    }

    if (output->LogicalDiskType == FtPartition) {

        if (!diskInfoSet->QueryFtPartitionInformation(diskId, &offset,
                                                      &wholeDisk, &diskNumber,
                                                      &sectorSize, NULL)) {

            Irp->IoStatus.Information = 0;
            return STATUS_INVALID_PARAMETER;
        }

        status = FtpReadPartitionTableEx(wholeDisk, &layout);
        if (!NT_SUCCESS(status)) {
            Irp->IoStatus.Information = 0;
            return status;
        }

        output->NumberOfMembers = 0;
        output->ConfigurationInformationSize =
                sizeof(FT_PARTITION_CONFIGURATION_INFORMATION);
        output->StateInformationSize = 0;
        output->Reserved = 0;

        Irp->IoStatus.Information =
                FIELD_OFFSET(FT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT,
                             MemberArray) +
                output->ConfigurationInformationSize;

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            Irp->IoStatus.Information) {

            Irp->IoStatus.Information =
                    FIELD_OFFSET(FT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT,
                                 MemberArray);
            ExFreePool(layout);
            return STATUS_BUFFER_OVERFLOW;
        }

        partInfo = (PFT_PARTITION_CONFIGURATION_INFORMATION)
                   ((PCHAR) output +
                    FIELD_OFFSET(FT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT,
                                 MemberArray));

        partInfo->Signature = layout->Mbr.Signature;
        partInfo->DiskNumber = diskNumber;
        partInfo->ByteOffset = offset;

        ExFreePool(layout);

    } else {

        output->NumberOfMembers = diskDescription->u.Other.NumberOfMembers;
        if (diskDescription->u.Other.ByteOffsetToConfigurationInformation) {
            if (diskDescription->u.Other.ByteOffsetToStateInformation) {
                output->ConfigurationInformationSize =
                        diskDescription->u.Other.ByteOffsetToStateInformation -
                        diskDescription->u.Other.ByteOffsetToConfigurationInformation;
            } else {
                output->ConfigurationInformationSize =
                        diskDescription->DiskDescriptionSize -
                        diskDescription->u.Other.ByteOffsetToConfigurationInformation;
            }
        } else {
            output->ConfigurationInformationSize = 0;
        }
        if (diskDescription->u.Other.ByteOffsetToStateInformation) {
            output->StateInformationSize =
                    diskDescription->DiskDescriptionSize -
                    diskDescription->u.Other.ByteOffsetToStateInformation;
        } else {
            output->StateInformationSize = 0;
        }
        diskDescription->Reserved = 0;

        Irp->IoStatus.Information =
                FIELD_OFFSET(FT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT,
                             MemberArray) +
                output->NumberOfMembers*sizeof(FT_LOGICAL_DISK_ID) +
                output->ConfigurationInformationSize +
                output->StateInformationSize;

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            Irp->IoStatus.Information) {

            Irp->IoStatus.Information =
                    FIELD_OFFSET(FT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT,
                                 MemberArray);
            return STATUS_BUFFER_OVERFLOW;
        }

        for (i = 0; i < output->NumberOfMembers; i++) {
            output->MemberArray[i] =
                    diskInfoSet->QueryMemberLogicalDiskId(diskId, i);
        }

        if (output->ConfigurationInformationSize) {
            p = (PCHAR) &output->MemberArray[output->NumberOfMembers];
            q = (PCHAR) diskDescription +
                diskDescription->u.Other.ByteOffsetToConfigurationInformation;
            RtlCopyMemory(p, q, output->ConfigurationInformationSize);
        }

        if (output->StateInformationSize) {
            p = (PCHAR) &output->MemberArray[output->NumberOfMembers] +
                output->ConfigurationInformationSize;
            q = (PCHAR) diskDescription +
                diskDescription->u.Other.ByteOffsetToStateInformation;
            RtlCopyMemory(p, q, output->StateInformationSize);
            vol->ModifyStateForUser(p);
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpOrphanLogicalDiskMember(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine orphans the given logical disk member.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_ORPHAN_LOGICAL_DISK_MEMBER_INPUT    input;
    FT_LOGICAL_DISK_ID                      diskId;
    USHORT                                  member;
    PVOLUME_EXTENSION                       extension;
    PFT_VOLUME                              vol;
    NTSTATUS                                status;
    KEVENT                                  event;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_ORPHAN_LOGICAL_DISK_MEMBER_INPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_ORPHAN_LOGICAL_DISK_MEMBER_INPUT)
            Irp->AssociatedIrp.SystemBuffer;
    diskId = input->LogicalDiskId;
    member = input->MemberNumberToOrphan;

    extension = FtpFindExtensionCoveringDiskId(RootExtension, diskId);
    if (!extension || !extension->FtVolume) {
        return STATUS_INVALID_PARAMETER;
    }

    vol = extension->FtVolume->GetContainedLogicalDisk(diskId);
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    status = vol->OrphanMember(member, FtpEventSignalCompletion, &event);
    if (NT_SUCCESS(status)) {
        FtpRelease(RootExtension);
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        FtpAcquire(RootExtension);
    }

    return status;
}

NTSTATUS
FtpQueryNtDeviceNameForLogicalDisk(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine returns the nt device name for the given logical partition.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                                  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_INPUT     input;
    PFT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT    output;
    FT_LOGICAL_DISK_ID                                  diskId;
    UNICODE_STRING                                      targetName;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_INPUT) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_INPUT)
            Irp->AssociatedIrp.SystemBuffer;
    output = (PFT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT)
             Irp->AssociatedIrp.SystemBuffer;

    diskId = input->RootLogicalDiskId;
    if (!FtpQueryNtDeviceNameString(RootExtension, diskId, &targetName)) {
        return STATUS_INVALID_PARAMETER;
    }

    output->NumberOfCharactersInNtDeviceName = targetName.Length/sizeof(WCHAR);

    Irp->IoStatus.Information =
            FIELD_OFFSET(FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT,
                         NtDeviceName) +
            output->NumberOfCharactersInNtDeviceName*sizeof(WCHAR);

    if (Irp->IoStatus.Information >
        irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

        Irp->IoStatus.Information =
            FIELD_OFFSET(FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT,
                         NtDeviceName);

        ExFreePool(targetName.Buffer);
        return STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory(output->NtDeviceName, targetName.Buffer,
                  targetName.Length);

    ExFreePool(targetName.Buffer);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryDriveLetterForLogicalDisk(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine queries the drive letter for the given root logical disk.

Arguments:

    Extension   - Supplies the root extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT   input;
    PFT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_OUTPUT  output;
    PFT_LOGICAL_DISK_INFORMATION_SET                diskInfoSet;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_OUTPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT)
            Irp->AssociatedIrp.SystemBuffer;
    output = (PFT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_OUTPUT)
             Irp->AssociatedIrp.SystemBuffer;

    diskInfoSet = RootExtension->DiskInfoSet;

    output->DriveLetter = diskInfoSet->QueryDriveLetter(
                          input->RootLogicalDiskId);
    if (output->DriveLetter == 0xFF) {
        output->DriveLetter = 0;
    }

    Irp->IoStatus.Information =
            sizeof(FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_OUTPUT);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpDeleteMountLetter(
    IN  UCHAR   DriveLetter
    )

/*++

Routine Description:

    This routine deletes the given drive letter from the mount point
    manager.

Arguments:

    DriveLetter - Supplies the drive letter.

Return Value:

    NTSTATUS

--*/

{
    UNICODE_STRING          name;
    NTSTATUS                status;
    PFILE_OBJECT            fileObject;
    PDEVICE_OBJECT          deviceObject;
    PMOUNTMGR_MOUNT_POINT   point;
    UCHAR                   buffer[sizeof(MOUNTMGR_MOUNT_POINT) + 50];
    PWSTR                   s;
    UNICODE_STRING          symName;
    PVOID                   mountPoints;
    KEVENT                  event;
    PIRP                    irp;
    IO_STATUS_BLOCK         ioStatus;

    RtlInitUnicodeString(&name, MOUNTMGR_DEVICE_NAME);
    status = IoGetDeviceObjectPointer(&name, FILE_READ_ATTRIBUTES, &fileObject,
                                      &deviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    point = (PMOUNTMGR_MOUNT_POINT) buffer;
    RtlZeroMemory(point, sizeof(MOUNTMGR_MOUNT_POINT));
    s = (PWSTR) ((PCHAR) point + sizeof(MOUNTMGR_MOUNT_POINT));
    swprintf(s, L"\\DosDevices\\%c:", DriveLetter);
    RtlInitUnicodeString(&symName, s);
    point->SymbolicLinkNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    point->SymbolicLinkNameLength = symName.Length;

    mountPoints = ExAllocatePool(PagedPool, PAGE_SIZE);
    if (!mountPoints) {
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTMGR_DELETE_POINTS,
                                        deviceObject, point,
                                        sizeof(MOUNTMGR_MOUNT_POINT) +
                                        symName.Length, mountPoints, PAGE_SIZE,
                                        FALSE, &event, &ioStatus);
    if (!irp) {
        ExFreePool(mountPoints);
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ExFreePool(mountPoints);
    ObDereferenceObject(fileObject);

    return status;
}

NTSTATUS
FtpSetDriveLetterForLogicalDisk(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine sets the drive letter for the given root logical disk.

Arguments:

    Extension   - Supplies the root extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT input;
    FT_LOGICAL_DISK_ID                          diskId;
    UCHAR                                       driveLetter, currentLetter;
    PVOLUME_EXTENSION                           extension;
    PFT_LOGICAL_DISK_INFORMATION_SET            diskInfoSet;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT)
            Irp->AssociatedIrp.SystemBuffer;

    diskId = input->RootLogicalDiskId;
    driveLetter = input->DriveLetter;
    if (driveLetter < FirstDriveLetter || driveLetter > LastDriveLetter) {
        if (driveLetter) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    extension = FtpFindExtension(RootExtension, diskId);
    if (!extension) {
        return STATUS_INVALID_PARAMETER;
    }

    currentLetter = FtpQueryMountLetter(extension);
    if (currentLetter) {
        FtpDeleteMountLetter(currentLetter);
    }

    if (driveLetter && !FtpSetMountLetter(extension, driveLetter)) {
        return STATUS_INVALID_PARAMETER;
    }

    diskInfoSet = RootExtension->DiskInfoSet;
    diskInfoSet->SetDriveLetter(diskId, driveLetter);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryNtDeviceNameForPartition(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine returns the nt device name for the given partition.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_INPUT    input;
    PFT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_OUTPUT   output;
    UNICODE_STRING                                  targetName;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_INPUT) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_OUTPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_INPUT)
            Irp->AssociatedIrp.SystemBuffer;
    output = (PFT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_OUTPUT)
             Irp->AssociatedIrp.SystemBuffer;

    if (!FtpQueryNtDeviceNameString(RootExtension, input->Signature,
                                    input->Offset, &targetName)) {
        return STATUS_INVALID_PARAMETER;
    }

    output->NumberOfCharactersInNtDeviceName = targetName.Length/sizeof(WCHAR);

    Irp->IoStatus.Information =
            FIELD_OFFSET(FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_OUTPUT,
                         NtDeviceName) +
            output->NumberOfCharactersInNtDeviceName*sizeof(WCHAR);

    if (Irp->IoStatus.Information >
        irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

        Irp->IoStatus.Information =
            FIELD_OFFSET(FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_OUTPUT,
                         NtDeviceName);

        ExFreePool(targetName.Buffer);
        return STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory(output->NtDeviceName, targetName.Buffer,
                  targetName.Length);

    ExFreePool(targetName.Buffer);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpStopSyncOperations(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine stops all sync operations on the given root logical disk.

Arguments:

    Extension   - Supplies the root extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_STOP_SYNC_OPERATIONS_INPUT  input;
    FT_LOGICAL_DISK_ID              diskId;
    PVOLUME_EXTENSION               extension;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_STOP_SYNC_OPERATIONS_INPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_STOP_SYNC_OPERATIONS_INPUT) Irp->AssociatedIrp.SystemBuffer;
    diskId = input->RootLogicalDiskId;

    extension = FtpFindExtension(RootExtension, diskId);
    if (!extension || !extension->FtVolume) {
        return STATUS_INVALID_PARAMETER;
    }

    extension->FtVolume->StopSyncOperations();

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryStableGuid(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine is called to query the stable guid for this volume.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTDEV_STABLE_GUID   output;

    if (!Extension->IsGpt) {
        return STATUS_UNSUCCESSFUL;
    }

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(MOUNTDEV_STABLE_GUID)) {

        return STATUS_INVALID_PARAMETER;
    }

    output = (PMOUNTDEV_STABLE_GUID) Irp->AssociatedIrp.SystemBuffer;
    output->StableGuid = Extension->UniqueIdGuid;
    Irp->IoStatus.Information = sizeof(MOUNTDEV_STABLE_GUID);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryUniqueId(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine is called to query the unique id for this volume.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTDEV_UNIQUE_ID output;
    NTSTATUS            status;
    ULONG               diskNumber;
    LONGLONG            offset;
    FT_LOGICAL_DISK_ID  diskId;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(MOUNTDEV_UNIQUE_ID)) {

        return STATUS_INVALID_PARAMETER;
    }

    output = (PMOUNTDEV_UNIQUE_ID) Irp->AssociatedIrp.SystemBuffer;

    if (Extension->IsSuperFloppy) {

        output->UniqueIdLength = Extension->DeviceNodeName.Length;

    } else {
        if (!FtpQueryUniqueIdBuffer(Extension, NULL,
                                    &output->UniqueIdLength)) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    Irp->IoStatus.Information = sizeof(USHORT) + output->UniqueIdLength;

    if (Irp->IoStatus.Information >
        irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

        Irp->IoStatus.Information = sizeof(MOUNTDEV_UNIQUE_ID);
        return STATUS_BUFFER_OVERFLOW;
    }

    if (Extension->IsSuperFloppy) {

        RtlCopyMemory(output->UniqueId, Extension->DeviceNodeName.Buffer,
                      output->UniqueIdLength);

    } else {
        if (!FtpQueryUniqueIdBuffer(Extension, output->UniqueId,
                                    &output->UniqueIdLength)) {

            return STATUS_INVALID_DEVICE_REQUEST;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
FtpUniqueIdChangeNotify(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine is to give a notify callback routine.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTDEV_UNIQUE_ID input;
    ULONG               len;
    PMOUNTDEV_UNIQUE_ID currentId;
    UCHAR               idBuffer[UNIQUE_ID_MAX_BUFFER_SIZE];

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTDEV_UNIQUE_ID)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (!Extension->TargetObject && !Extension->FtVolume) {
        return STATUS_INVALID_PARAMETER;
    }

    if (Extension->IsSuperFloppy) {
        return STATUS_INVALID_PARAMETER;
    }

    input = (PMOUNTDEV_UNIQUE_ID) Irp->AssociatedIrp.SystemBuffer;
    len = FIELD_OFFSET(MOUNTDEV_UNIQUE_ID, UniqueId) +
          input->UniqueIdLength;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < len) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!IsListEmpty(&Extension->ChangeNotifyIrps)) {
        return STATUS_INVALID_PARAMETER;
    }

    Irp->Tail.Overlay.DriverContext[0] = Extension;

    IoSetCancelRoutine (Irp, FtpCancelChangeNotify);

    if (Irp->Cancel && IoSetCancelRoutine (Irp, NULL) == NULL) {
        return STATUS_CANCELLED;
    }

    IoMarkIrpPending(Irp);

    InsertTailList(&Extension->ChangeNotifyIrps, &Irp->Tail.Overlay.ListEntry);

    currentId = (PMOUNTDEV_UNIQUE_ID) idBuffer;
    FtpQueryUniqueIdBuffer(Extension, currentId->UniqueId,
                           &currentId->UniqueIdLength);

    if (input->UniqueIdLength != currentId->UniqueIdLength ||
        RtlCompareMemory(input->UniqueId, currentId->UniqueId,
                         input->UniqueIdLength) != input->UniqueIdLength) {

        FtpUniqueIdNotify(Extension, currentId);
    }

    return STATUS_PENDING;
}

NTSTATUS
FtpCreatePartitionLogicalDisk(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine creates assigns a logical disk id to a partition.

Arguments:

    Extension   - Supplies the partition extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                          irpSp = IoGetCurrentIrpStackLocation(Irp);
    LONGLONG                                    partitionSize;
    NTSTATUS                                    status;
    FT_LOGICAL_DISK_ID                          diskId;
    PFT_CREATE_PARTITION_LOGICAL_DISK_OUTPUT    output;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(FT_CREATE_PARTITION_LOGICAL_DISK_OUTPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength >=
        sizeof(LONGLONG)) {

        partitionSize = *((PLONGLONG) Irp->AssociatedIrp.SystemBuffer);
    } else {
        partitionSize = 0;
    }

    status = FtpCreatePartitionLogicalDiskHelper(Extension, partitionSize,
                                                 &diskId);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    Irp->IoStatus.Information =
            sizeof(FT_CREATE_PARTITION_LOGICAL_DISK_OUTPUT);

    output = (PFT_CREATE_PARTITION_LOGICAL_DISK_OUTPUT)
             Irp->AssociatedIrp.SystemBuffer;

    output->NewLogicalDiskId = diskId;

    return status;
}

NTSTATUS
FtpQueryDeviceName(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the device name for the given device.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    WCHAR               nameBuffer[100];
    UNICODE_STRING      nameString;
    PMOUNTDEV_NAME      name;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(MOUNTDEV_NAME)) {

        return STATUS_INVALID_PARAMETER;
    }

    swprintf(nameBuffer, L"\\Device\\HarddiskVolume%d", Extension->VolumeNumber);
    RtlInitUnicodeString(&nameString, nameBuffer);

    name = (PMOUNTDEV_NAME) Irp->AssociatedIrp.SystemBuffer;
    name->NameLength = nameString.Length;
    Irp->IoStatus.Information = name->NameLength + sizeof(USHORT);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = sizeof(MOUNTDEV_NAME);
        return STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory(name->Name, nameString.Buffer, name->NameLength);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQuerySuggestedLinkName(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the suggested link name for the given device.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    BOOLEAN                         deleteLetter;
    UCHAR                           driveLetter;
    PFT_VOLUME                      vol;
    FT_LOGICAL_DISK_ID              diskId;
    WCHAR                           nameBuffer[30];
    UNICODE_STRING                  nameString;
    PMOUNTDEV_SUGGESTED_LINK_NAME   name;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(MOUNTDEV_SUGGESTED_LINK_NAME)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength >=
        FIELD_OFFSET(MOUNTDEV_SUGGESTED_LINK_NAME, Name) + 28) {

        deleteLetter = TRUE;
    } else {
        deleteLetter = FALSE;
    }

    driveLetter = FtpQueryDriveLetterFromRegistry(Extension, deleteLetter);
    vol = Extension->FtVolume;
    if (vol) {
        diskId = vol->QueryLogicalDiskId();
        driveLetter = Extension->Root->DiskInfoSet->QueryDriveLetter(diskId);
    }

    if (!driveLetter) {
        return STATUS_NOT_FOUND;
    }

    swprintf(nameBuffer, L"\\DosDevices\\%c:", driveLetter);
    RtlInitUnicodeString(&nameString, nameBuffer);

    name = (PMOUNTDEV_SUGGESTED_LINK_NAME) Irp->AssociatedIrp.SystemBuffer;
    name->UseOnlyIfThereAreNoOtherLinks = TRUE;
    name->NameLength = nameString.Length;
    Irp->IoStatus.Information =
            name->NameLength + FIELD_OFFSET(MOUNTDEV_SUGGESTED_LINK_NAME, Name);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = sizeof(MOUNTDEV_SUGGESTED_LINK_NAME);
        return STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory(name->Name, nameString.Buffer, name->NameLength);

    return STATUS_SUCCESS;
}

class CHANGE_DRIVE_LETTER_WORK_ITEM : public WORK_QUEUE_ITEM {

    public:

        PROOT_EXTENSION     RootExtension;
        FT_LOGICAL_DISK_ID  LogicalDiskId;
        UCHAR               OldDriveLetter;
        UCHAR               NewDriveLetter;

};

typedef CHANGE_DRIVE_LETTER_WORK_ITEM *PCHANGE_DRIVE_LETTER_WORK_ITEM;

VOID
FtpChangeDriveLetterWorkerRoutine(
    IN  PVOID   WorkItem
    )

/*++

Routine Description:

    This routine changes the drive letter.

Arguments:

    WorkItem    - Supplies the work item.

Return Value:

    None.

--*/

{
    PCHANGE_DRIVE_LETTER_WORK_ITEM      workItem = (PCHANGE_DRIVE_LETTER_WORK_ITEM) WorkItem;
    PROOT_EXTENSION                     rootExtension = workItem->RootExtension;
    PFT_LOGICAL_DISK_INFORMATION_SET    diskInfoSet = rootExtension->DiskInfoSet;

    FtpAcquire(rootExtension);
    if (workItem->OldDriveLetter &&
        diskInfoSet->QueryDriveLetter(workItem->LogicalDiskId) !=
        workItem->OldDriveLetter) {

        FtpRelease(rootExtension);
        ExFreePool(WorkItem);
        return;
    }
    diskInfoSet->SetDriveLetter(workItem->LogicalDiskId,
                                workItem->NewDriveLetter);
    FtpRelease(rootExtension);

    ExFreePool(WorkItem);
}

NTSTATUS
FtpLinkCreated(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine is called when the mount manager changes the link.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_VOLUME                      vol;
    PMOUNTDEV_NAME                  name;
    ULONG                           nameLen;
    UNICODE_STRING                  nameString;
    UNICODE_STRING                  dosDevices;
    UCHAR                           driveLetter;
    PCHANGE_DRIVE_LETTER_WORK_ITEM  workItem;

    vol = Extension->FtVolume;
    if (!vol) {
        return STATUS_SUCCESS;
    }

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTDEV_NAME)) {

        return STATUS_INVALID_PARAMETER;
    }

    name = (PMOUNTDEV_NAME) Irp->AssociatedIrp.SystemBuffer;
    nameLen = name->NameLength + sizeof(USHORT);

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < nameLen) {
        return STATUS_INVALID_PARAMETER;
    }

    nameString.Buffer = name->Name;
    nameString.Length = nameString.MaximumLength = name->NameLength;

    if (nameString.Length != 28 || nameString.Buffer[13] != ':' ||
        nameString.Buffer[12] < FirstDriveLetter || nameString.Buffer[12] > LastDriveLetter) {
        return STATUS_SUCCESS;
    }

    nameString.Length -= 2*sizeof(WCHAR);

    RtlInitUnicodeString(&dosDevices, L"\\DosDevices\\");

    if (!RtlEqualUnicodeString(&dosDevices, &nameString, TRUE)) {
        return STATUS_SUCCESS;
    }

    driveLetter = (UCHAR) nameString.Buffer[12];

    workItem = (PCHANGE_DRIVE_LETTER_WORK_ITEM)
               ExAllocatePool(NonPagedPool, sizeof(CHANGE_DRIVE_LETTER_WORK_ITEM));
    if (!workItem) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ExInitializeWorkItem(workItem, FtpChangeDriveLetterWorkerRoutine, workItem);
    workItem->RootExtension = Extension->Root;
    workItem->LogicalDiskId = vol->QueryLogicalDiskId();
    workItem->OldDriveLetter = 0;
    workItem->NewDriveLetter = driveLetter;

    ExQueueWorkItem(workItem, DelayedWorkQueue);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpLinkDeleted(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine is called when the mount manager deletes a link.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_VOLUME                      vol;
    PMOUNTDEV_NAME                  name;
    ULONG                           nameLen;
    UNICODE_STRING                  nameString;
    UNICODE_STRING                  dosDevices;
    UCHAR                           driveLetter;
    PCHANGE_DRIVE_LETTER_WORK_ITEM  workItem;

    vol = Extension->FtVolume;
    if (!vol) {
        return STATUS_SUCCESS;
    }

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(MOUNTDEV_NAME)) {

        return STATUS_INVALID_PARAMETER;
    }

    name = (PMOUNTDEV_NAME) Irp->AssociatedIrp.SystemBuffer;
    nameLen = name->NameLength + sizeof(USHORT);

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < nameLen) {
        return STATUS_INVALID_PARAMETER;
    }

    nameString.Buffer = name->Name;
    nameString.Length = nameString.MaximumLength = name->NameLength;

    if (nameString.Length != 28 || nameString.Buffer[13] != ':' ||
        nameString.Buffer[12] < FirstDriveLetter || nameString.Buffer[12] > LastDriveLetter) {
        return STATUS_SUCCESS;
    }

    nameString.Length -= 2*sizeof(WCHAR);

    RtlInitUnicodeString(&dosDevices, L"\\DosDevices\\");

    if (!RtlEqualUnicodeString(&dosDevices, &nameString, TRUE)) {
        return STATUS_SUCCESS;
    }

    driveLetter = (UCHAR) nameString.Buffer[12];

    workItem = (PCHANGE_DRIVE_LETTER_WORK_ITEM)
               ExAllocatePool(NonPagedPool, sizeof(CHANGE_DRIVE_LETTER_WORK_ITEM));
    if (!workItem) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ExInitializeWorkItem(workItem, FtpChangeDriveLetterWorkerRoutine, workItem);
    workItem->RootExtension = Extension->Root;
    workItem->LogicalDiskId = vol->QueryLogicalDiskId();
    workItem->OldDriveLetter = driveLetter;
    workItem->NewDriveLetter = 0;

    ExQueueWorkItem(workItem, DelayedWorkQueue);

    return STATUS_SUCCESS;
}

VOID
FtpSyncLogicalDiskIds(
    IN      PFT_LOGICAL_DISK_INFORMATION_SET    DiskInfoSet,
    IN OUT  PFT_VOLUME                          RootVolume,
    IN OUT  PFT_VOLUME                          Volume
    )

/*++

Routine Description:

    This routine syncs up the logical disk ids in the given FT_VOLUME object
    with the on disk logical disk ids.

Arguments:

    DiskInfoSet - Supplies the disk info set.

    RootVolume  - Supplies the root volume.

    Volume      - Supplies the volume.

Return Value:

    None.

--*/

{
    FT_LOGICAL_DISK_ID              diskId;
    PFT_LOGICAL_DISK_DESCRIPTION    p;
    USHORT                          n, i;
    PFT_VOLUME                      vol;

    if (Volume->QueryLogicalDiskType() == FtPartition) {

        for (;;) {

            diskId = Volume->QueryLogicalDiskId();
            p = DiskInfoSet->GetParentLogicalDiskDescription(diskId);
            if (!p) {
                break;
            }

            Volume = RootVolume->GetParentLogicalDisk(Volume);
            if (!Volume) {
                break;
            }

            Volume->SetLogicalDiskId(p->LogicalDiskId);
        }
        return;
    }

    n = Volume->QueryNumberOfMembers();
    for (i = 0; i < n; i++) {
        vol = Volume->GetMember(i);
        if (vol) {
            FtpSyncLogicalDiskIds(DiskInfoSet, RootVolume, vol);
        }
    }
}

VOID
FtpSyncLogicalDiskIds(
    IN  PROOT_EXTENSION RootExtension
    )

/*++

Routine Description:

    This routine syncs up the logical disk ids in the FT_VOLUME objects
    with the on disk logical disk ids.

Arguments:

    RootExtension   - Supplies the root extension.

Return Value:

    None.

--*/

{
    PLIST_ENTRY                         l;
    PVOLUME_EXTENSION                   extension;
    PFT_VOLUME                          vol;

    for (l = RootExtension->VolumeList.Flink;
         l != &RootExtension->VolumeList; l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        vol = extension->FtVolume;
        if (!vol) {
            continue;
        }

        FtpSyncLogicalDiskIds(RootExtension->DiskInfoSet, vol, vol);
    }
}

NTSTATUS
FtpPartitionArrivedHelper(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      PDEVICE_OBJECT      Partition,
    IN      PDEVICE_OBJECT      WholeDiskPdo
    )

{
    ULONG                               diskNumber;
    LONGLONG                            offset;
    UCHAR                               partitionType;
    PFT_LOGICAL_DISK_INFORMATION_SET    diskInfoSet;
    PFT_LOGICAL_DISK_INFORMATION        diskInfo;
    NTSTATUS                            status;
    BOOLEAN                             changedLogicalDiskIds;
    FT_LOGICAL_DISK_ID                  diskId, partitionDiskId;
    PVOLUME_EXTENSION                   extension;
    PFT_VOLUME                          vol, c;
    PFT_LOGICAL_DISK_DESCRIPTION        parentDesc;
    ULONG                               n;
    UCHAR                               registryState[100];
    USHORT                              registryStateSize;
    BOOLEAN                             IsGpt, isHidden, isReadOnly, isEspType;
    GUID                                partitionTypeGuid, partitionUniqueId;
    ULONGLONG                           gptAttributes;
    ULONG                               signature;

    status = FtpQueryPartitionInformation(RootExtension, Partition,
                                          &diskNumber, &offset, NULL,
                                          &partitionType, NULL,
                                          &partitionTypeGuid,
                                          &partitionUniqueId, &IsGpt,
                                          &gptAttributes);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    isHidden = FALSE;
    isReadOnly = FALSE;
    isEspType = FALSE;

    if (IsGpt) {
        if (IsEqualGUID(partitionTypeGuid, PARTITION_LDM_DATA_GUID)) {
            return STATUS_INVALID_PARAMETER;
        }

        if (RootExtension->GptAttributeRevertEntries) {
            FtpCheckForRevertGptAttributes(RootExtension, Partition, 0,
                                           &partitionUniqueId, NULL);
            status = FtpQueryPartitionInformation(
                     RootExtension, Partition, NULL, NULL, NULL, NULL, NULL,
                     NULL, NULL, NULL, &gptAttributes);
            if (!NT_SUCCESS(status)) {
                return status;
            }
        }

        if (IsEqualGUID(partitionTypeGuid, PARTITION_BASIC_DATA_GUID)) {
            if (gptAttributes&GPT_BASIC_DATA_ATTRIBUTE_HIDDEN) {
                isHidden = TRUE;
            }
            if (gptAttributes&GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY) {
                isReadOnly = TRUE;
            }
        } else {
            if (IsEqualGUID(partitionTypeGuid, PARTITION_SYSTEM_GUID)) {
                isEspType = TRUE;
            }
            isHidden = TRUE;
        }

        if (!FtpCreateNewDevice(RootExtension, Partition, NULL, WholeDiskPdo,
                                Partition->AlignmentRequirement, FALSE,
                                isHidden, isReadOnly, isEspType, 0)) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        IoInvalidateDeviceRelations(RootExtension->Pdo, BusRelations);

        return STATUS_SUCCESS;
    }

    if (partitionType == PARTITION_LDM) {
        return STATUS_INVALID_PARAMETER;
    }
    if (!IsRecognizedPartition(partitionType)) {
        isHidden = TRUE;
    }

    diskInfoSet = RootExtension->DiskInfoSet;
    if (!diskInfoSet->IsDiskInSet(WholeDiskPdo)) {

        diskInfo = new FT_LOGICAL_DISK_INFORMATION;
        if (!diskInfo) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = diskInfo->Initialize(RootExtension, WholeDiskPdo);
        if (!NT_SUCCESS(status)) {
            delete diskInfo;
            return status;
        }

        status = diskInfoSet->AddLogicalDiskInformation(diskInfo,
                                                        &changedLogicalDiskIds);
        if (!NT_SUCCESS(status)) {
            delete diskInfo;
            return status;
        }

        if (changedLogicalDiskIds) {
            FtpSyncLogicalDiskIds(RootExtension);
        }

        if (RootExtension->GptAttributeRevertEntries) {
            signature = FtpQueryDiskSignature(WholeDiskPdo);
            if (signature) {
                FtpCheckForRevertGptAttributes(RootExtension, Partition,
                                               signature, NULL, diskInfo);
            }
        }

    } else {
        diskInfo = diskInfoSet->FindLogicalDiskInformation(WholeDiskPdo);
    }

    if (diskInfo) {
        if (IsRecognizedPartition(partitionType)) {
            gptAttributes = diskInfo->GetGptAttributes();
            if (gptAttributes&GPT_BASIC_DATA_ATTRIBUTE_HIDDEN) {
                isHidden = TRUE;
            }
            if (gptAttributes&GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY) {
                isReadOnly = TRUE;
            }
        } else {
            gptAttributes = 0;
        }
    }

    // Make sure that the on disk reflects the state of the registry.

    diskInfoSet->MigrateRegistryInformation(Partition, diskNumber, offset);

    diskId = diskInfoSet->QueryRootLogicalDiskIdForContainedPartition(
             diskNumber, offset);
    if (diskId) {

        if (!RootExtension->FtCodeLocked) {
            MmLockPagableCodeSection(FtpComputeParity);
            status = FtpStartSystemThread(RootExtension);
            if (!NT_SUCCESS(status)) {
                return status;
            }
            RootExtension->FtCodeLocked = TRUE;
        }

        extension = FtpFindExtension(RootExtension, diskId);
        if (extension) {
            status = FtpAddPartition(extension, Partition, WholeDiskPdo);
            if (!NT_SUCCESS(status)) {
                return status;
            }

            FtpNotify(RootExtension, extension);

        } else {

            vol = FtpBuildFtVolume(RootExtension, diskId, Partition,
                                   WholeDiskPdo);

            if (!vol) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            partitionDiskId = diskInfoSet->QueryPartitionLogicalDiskId(
                              diskNumber, offset);
            parentDesc = diskInfoSet->GetParentLogicalDiskDescription(
                         partitionDiskId, &n);
            while (parentDesc) {

                if (parentDesc->u.Other.ByteOffsetToStateInformation &&
                    (c = vol->GetContainedLogicalDisk(
                         parentDesc->LogicalDiskId))) {

                    c->NewStateArrival((PCHAR) parentDesc +
                            parentDesc->u.Other.ByteOffsetToStateInformation);
                }

                parentDesc = diskInfoSet->GetParentLogicalDiskDescription(
                             parentDesc, n);
            }

            if (!FtpCreateNewDevice(RootExtension, NULL, vol, NULL,
                                    Partition->AlignmentRequirement, FALSE,
                                    isHidden, isReadOnly, FALSE, 0)) {

                FtpDeleteVolume(vol);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            IoInvalidateDeviceRelations(RootExtension->Pdo, BusRelations);
        }

    } else {

        if (!FtpCreateNewDevice(RootExtension, Partition, NULL, WholeDiskPdo,
                                Partition->AlignmentRequirement, FALSE,
                                isHidden, isReadOnly, FALSE, gptAttributes)) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        IoInvalidateDeviceRelations(RootExtension->Pdo, BusRelations);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpPartitionArrived(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine is called when a new partition is introduced into the
    system.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLMGR_PARTITION_INFORMATION       input;
    PDEVICE_OBJECT                      partition, wholeDiskPdo;
    NTSTATUS                            status;
    ULONG                               diskNumber;
    LONGLONG                            offset;
    UCHAR                               partitionType;
    PVOLUME_EXTENSION                   extension;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLMGR_PARTITION_INFORMATION)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PVOLMGR_PARTITION_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
    partition = input->PartitionDeviceObject;
    wholeDiskPdo = input->WholeDiskPdo;

    status = FtpPartitionArrivedHelper(RootExtension, partition, wholeDiskPdo);

    return status;
}

VOID
FtpTotalBreakUp(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  LogicalDiskId
    )

{
    PFT_LOGICAL_DISK_INFORMATION_SET    diskInfoSet = RootExtension->DiskInfoSet;
    USHORT                              numDiskIds, i;
    PFT_LOGICAL_DISK_ID                 diskIds;

    if (!LogicalDiskId) {
        return;
    }

    numDiskIds = diskInfoSet->QueryNumberOfMembersInLogicalDisk(LogicalDiskId);
    if (numDiskIds) {
        diskIds = (PFT_LOGICAL_DISK_ID)
                  ExAllocatePool(PagedPool, numDiskIds*sizeof(FT_LOGICAL_DISK_ID));
        if (!diskIds) {
            return;
        }

        for (i = 0; i < numDiskIds; i++) {
            diskIds[i] = diskInfoSet->QueryMemberLogicalDiskId(LogicalDiskId, i);
        }
    }

    diskInfoSet->BreakLogicalDisk(LogicalDiskId);

    if (numDiskIds) {
        for (i = 0; i < numDiskIds; i++) {
            FtpTotalBreakUp(RootExtension, diskIds[i]);
        }

        ExFreePool(diskIds);
    }
}

NTSTATUS
FtpWholeDiskRemoved(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine is called when a whole disk is removed from the system.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLMGR_WHOLE_DISK_INFORMATION  input;
    PDEVICE_OBJECT                  pdo, wholeDisk;
    NTSTATUS                        status;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLMGR_WHOLE_DISK_INFORMATION)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PVOLMGR_WHOLE_DISK_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
    pdo = input->WholeDiskPdo;

    status = RootExtension->DiskInfoSet->RemoveLogicalDiskInformation(pdo);

    return status;
}

NTSTATUS
FtpReferenceDependantVolume(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine references the volume dependant to the given partition.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLMGR_PARTITION_INFORMATION           input;
    PDEVICE_OBJECT                          partition;
    PVOLUME_EXTENSION                       extension;
    PVOLMGR_DEPENDANT_VOLUMES_INFORMATION   output;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLMGR_PARTITION_INFORMATION) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(VOLMGR_DEPENDANT_VOLUMES_INFORMATION)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PVOLMGR_PARTITION_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
    partition = input->PartitionDeviceObject;
    output = (PVOLMGR_DEPENDANT_VOLUMES_INFORMATION)
             Irp->AssociatedIrp.SystemBuffer;

    output->DependantVolumeReferences = (PDEVICE_RELATIONS)
                                        ExAllocatePool(PagedPool,
                                        sizeof(DEVICE_RELATIONS));
    if (!output->DependantVolumeReferences) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    extension = FtpFindExtensionCoveringPartition(RootExtension, partition);
    if (!extension) {
        ExFreePool(output->DependantVolumeReferences);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (extension->IsStarted) {
        output->DependantVolumeReferences->Count = 1;
        output->DependantVolumeReferences->Objects[0] =
                extension->DeviceObject;
        ObReferenceObject(extension->DeviceObject);
    } else {
        output->DependantVolumeReferences->Count = 0;
    }

    Irp->IoStatus.Information = sizeof(VOLMGR_DEPENDANT_VOLUMES_INFORMATION);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpPartitionRemoved(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine is called when a partition is removed from the system.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLMGR_PARTITION_INFORMATION   input;
    PDEVICE_OBJECT                  partition;
    PDEVICE_OBJECT                  wholeDiskPdo;
    NTSTATUS                        status;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLMGR_PARTITION_INFORMATION)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PVOLMGR_PARTITION_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
    partition = input->PartitionDeviceObject;
    wholeDiskPdo = input->WholeDiskPdo;

    status = FtpPartitionRemovedHelper(RootExtension, partition, wholeDiskPdo);

    return status;
}

NTSTATUS
FtpQueryChangePartition(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine checks to see if the given partition can be grown.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLMGR_PARTITION_INFORMATION           input;
    PVOLUME_EXTENSION                       extension;
    NTSTATUS                                status;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLMGR_PARTITION_INFORMATION)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PVOLMGR_PARTITION_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

    extension = FtpFindExtensionCoveringPartition(
            RootExtension, input->PartitionDeviceObject);
    if (!extension) {
        return STATUS_INVALID_PARAMETER;
    }

    if (extension->TargetObject) {
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    return status;
}

NTSTATUS
FtpPartitionChanged(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine does a notification because the given partition has
    changed.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLMGR_PARTITION_INFORMATION           input;
    PVOLUME_EXTENSION                       extension;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLMGR_PARTITION_INFORMATION)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PVOLMGR_PARTITION_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

    extension = FtpFindExtensionCoveringPartition(
            RootExtension, input->PartitionDeviceObject);
    if (!extension) {
        return STATUS_INVALID_PARAMETER;
    }

    extension->WholeDisk = NULL;
    extension->PartitionOffset = 0;
    extension->PartitionLength = 0;

    FtpNotify(RootExtension, extension);

    // Perform a pre-exposure of the new devnode to avoid the PNP reboot
    // pop-up.

    if (!extension->IsGpt &&
        FtpCreateNewDevice(extension->Root, extension->TargetObject,
                           extension->FtVolume, extension->WholeDiskPdo,
                           extension->DeviceObject->AlignmentRequirement,
                           TRUE, TRUE, FALSE, FALSE, 0)) {

        IoInvalidateDeviceRelations(RootExtension->Pdo, BusRelations);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryRootId(
    IN  PROOT_EXTENSION Extension,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine queries the ID for the given PDO.

Arguments:

    Extension   - Supplies the root extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    UNICODE_STRING      string;
    NTSTATUS            status;
    ULONG               diskNumber;
    LONGLONG            offset;
    WCHAR               buffer[100];
    FT_LOGICAL_DISK_ID  diskId;
    PWSTR               id;

    switch (irpSp->Parameters.QueryId.IdType) {

        case BusQueryDeviceID:
            RtlInitUnicodeString(&string, L"ROOT\\FTDISK");
            break;

        case BusQueryHardwareIDs:
            RtlInitUnicodeString(&string, L"ROOT\\FTDISK");
            break;

        case BusQueryInstanceID:
            RtlInitUnicodeString(&string, L"0000");
            break;

        default:
            return STATUS_NOT_SUPPORTED ;

    }

    id = (PWSTR) ExAllocatePool(PagedPool, string.Length + 2*sizeof(WCHAR));
    if (!id) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(id, string.Buffer, string.Length);
    id[string.Length/sizeof(WCHAR)] = 0;
    id[string.Length/sizeof(WCHAR) + 1] = 0;

    Irp->IoStatus.Information = (ULONG_PTR) id;

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryId(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine queries the ID for the given PDO.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    UNICODE_STRING      string;
    NTSTATUS            status;
    PWSTR               id;

    switch (irpSp->Parameters.QueryId.IdType) {

        case BusQueryDeviceID:
            RtlInitUnicodeString(&string, L"STORAGE\\Volume");
            break;

        case BusQueryHardwareIDs:
            RtlInitUnicodeString(&string, L"STORAGE\\Volume");
            break;

        case BusQueryInstanceID:
            string = Extension->DeviceNodeName;
            break;

        default:
            return STATUS_NOT_SUPPORTED ;

    }

    id = (PWSTR) ExAllocatePool(PagedPool, string.Length + 2*sizeof(WCHAR));
    if (!id) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(id, string.Buffer, string.Length);
    id[string.Length/sizeof(WCHAR)] = 0;
    id[string.Length/sizeof(WCHAR) + 1] = 0;

    Irp->IoStatus.Information = (ULONG_PTR) id;

    return STATUS_SUCCESS;
}

class FTP_LOG_ERROR_CONTEXT : public WORK_QUEUE_ITEM {

    public:

        PDEVICE_EXTENSION   Extension;
        FT_LOGICAL_DISK_ID  LogicalDiskId;
        NTSTATUS            SpecificIoStatus;
        NTSTATUS            FinalStatus;
        ULONG               UniqueErrorValue;

};

typedef FTP_LOG_ERROR_CONTEXT *PFTP_LOG_ERROR_CONTEXT;

VOID
FtpLogErrorWorker(
    IN  PVOID   Context
    )

{
    PFTP_LOG_ERROR_CONTEXT  context = (PFTP_LOG_ERROR_CONTEXT) Context;
    PDEVICE_EXTENSION       Extension;
    PDEVICE_OBJECT          deviceObject;
    ULONG                   volumeNumber;
    FT_LOGICAL_DISK_ID      LogicalDiskId;
    NTSTATUS                SpecificIoStatus;
    NTSTATUS                FinalStatus;
    ULONG                   UniqueErrorValue;
    PDEVICE_EXTENSION       extension;
    NTSTATUS                status;
    UNICODE_STRING          dosName;
    ULONG                   extraSpace;
    PIO_ERROR_LOG_PACKET    errorLogPacket;
    PWCHAR                  p;

    Extension = context->Extension;
    LogicalDiskId = context->LogicalDiskId;
    SpecificIoStatus = context->SpecificIoStatus;
    FinalStatus = context->FinalStatus;
    UniqueErrorValue = context->UniqueErrorValue;

    if (LogicalDiskId) {
        FtpAcquire(Extension->Root);
        extension = FtpFindExtensionCoveringDiskId(Extension->Root,
                                                   LogicalDiskId);
        if (extension) {
            deviceObject = extension->DeviceObject;
            volumeNumber = ((PVOLUME_EXTENSION) extension)->VolumeNumber;
            ObReferenceObject(deviceObject);
        } else {
            deviceObject = NULL;
        }
        FtpRelease(Extension->Root);

        if (!extension) {
            extension = Extension->Root;
        }
    } else {
        extension = Extension;
        deviceObject = NULL;
    }

    DebugPrint((2, "FtpLogError: DE %x:%x, unique %x, status %x\n",
                extension,
                extension->DeviceObject,
                UniqueErrorValue,
                SpecificIoStatus));

    if (deviceObject) {
        status = RtlVolumeDeviceToDosName(deviceObject, &dosName);
        ObDereferenceObject(deviceObject);
        if (!NT_SUCCESS(status)) {
            dosName.Buffer = (PWCHAR) ExAllocatePool(PagedPool, 100*sizeof(WCHAR));
            if (dosName.Buffer) {
                swprintf(dosName.Buffer, L"\\Device\\HarddiskVolume%d",
                         volumeNumber);
                RtlInitUnicodeString(&dosName, dosName.Buffer);
            }
        }
    } else {
        dosName.Buffer = NULL;
    }

    if (dosName.Buffer) {
        extraSpace = dosName.Length + sizeof(WCHAR);
    } else {
        extraSpace = 34;
    }

    errorLogPacket = (PIO_ERROR_LOG_PACKET)
                     IoAllocateErrorLogEntry(extension->DeviceObject,
                                             sizeof(IO_ERROR_LOG_PACKET) +
                                             (UCHAR)extraSpace);
    if (!errorLogPacket) {
        DebugPrint((1, "FtpLogError: unable to allocate error log packet\n"));
        if (dosName.Buffer) {
            ExFreePool(dosName.Buffer);
        }
        return;
    }

    errorLogPacket->ErrorCode = SpecificIoStatus;
    errorLogPacket->SequenceNumber = FtErrorLogSequence++;
    errorLogPacket->FinalStatus = FinalStatus;
    errorLogPacket->UniqueErrorValue = UniqueErrorValue;
    errorLogPacket->DumpDataSize = 0;
    errorLogPacket->RetryCount = 0;

    errorLogPacket->NumberOfStrings = 1;
    errorLogPacket->StringOffset = sizeof(IO_ERROR_LOG_PACKET);
    p = (PWCHAR) ((PCHAR) errorLogPacket + sizeof(IO_ERROR_LOG_PACKET));
    if (dosName.Buffer) {
        RtlCopyMemory(p, dosName.Buffer, dosName.Length);
        p[dosName.Length/sizeof(WCHAR)] = 0;
        ExFreePool(dosName.Buffer);
    } else if (LogicalDiskId <= 0xFFFF && LogicalDiskId >= 0) {
        swprintf(p, L"%d", LogicalDiskId);
    } else {
        swprintf(p, L"%I64X", LogicalDiskId);
    }

    IoWriteErrorLogEntry(errorLogPacket);

    ExFreePool(Context);
}

VOID
FtpSendPagingNotification(
    IN  PDEVICE_OBJECT  Partition
    )

/*++

Routine Description:

    This routine sends a paging path IRP to the given partition.

Arguments:

    Partition   - Supplies the partition.

Return Value:

    None.

--*/

{
    KEVENT              event;
    PIRP                irp;
    IO_STATUS_BLOCK     ioStatus;
    PIO_STACK_LOCATION  irpSp;
    NTSTATUS            status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(0, Partition, NULL, 0, NULL, 0,
                                        FALSE, &event, &ioStatus);
    if (!irp) {
        return;
    }

    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->MajorFunction = IRP_MJ_PNP;
    irpSp->MinorFunction = IRP_MN_DEVICE_USAGE_NOTIFICATION;
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED ;
    irpSp->Parameters.UsageNotification.InPath = TRUE;
    irpSp->Parameters.UsageNotification.Type = DeviceUsageTypePaging;

    status = IoCallDriver(Partition, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
}

NTSTATUS
FtpInitializeLogicalDisk(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine initializes a given logical disk.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_INITIALIZE_LOGICAL_DISK_INPUT   input;
    FT_LOGICAL_DISK_ID                  diskId;
    PVOLUME_EXTENSION                   extension;
    PFT_VOLUME                          vol;
    NTSTATUS                            status;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_INITIALIZE_LOGICAL_DISK_INPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_INITIALIZE_LOGICAL_DISK_INPUT) Irp->AssociatedIrp.SystemBuffer;
    diskId = input->RootLogicalDiskId;

    extension = FtpFindExtension(RootExtension, diskId);
    if (!extension || !extension->FtVolume) {
        return STATUS_INVALID_PARAMETER;
    }

    vol = extension->FtVolume;
    ASSERT(vol);

    status = FtpAllSystemsGo(extension, NULL, TRUE, TRUE, TRUE);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    vol->StartSyncOperations(input->RegenerateOrphans,
                             FtpRefCountCompletion, extension);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpCheckIo(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine checks the io path for the given logical disk.

Arguments:

    Extension   - Supplies the root extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_CHECK_IO_INPUT  input;
    PFT_CHECK_IO_OUTPUT output;
    FT_LOGICAL_DISK_ID  diskId;
    PVOLUME_EXTENSION   extension;
    PFT_VOLUME          vol;
    NTSTATUS            status;
    BOOLEAN             ok;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_CHECK_IO_INPUT) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(FT_CHECK_IO_OUTPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_CHECK_IO_INPUT) Irp->AssociatedIrp.SystemBuffer;
    output = (PFT_CHECK_IO_OUTPUT) Irp->AssociatedIrp.SystemBuffer;
    diskId = input->LogicalDiskId;

    extension = FtpFindExtensionCoveringDiskId(RootExtension, diskId);
    if (!extension || !extension->FtVolume) {
        return STATUS_INVALID_PARAMETER;
    }

    status = FtpAllSystemsGo(extension, NULL, FALSE, TRUE, TRUE);
    if (!NT_SUCCESS(status)) {
        output->IsIoOk = FALSE;
        Irp->IoStatus.Information = sizeof(FT_CHECK_IO_OUTPUT);
        return STATUS_SUCCESS;
    }

    vol = extension->FtVolume->GetContainedLogicalDisk(diskId);
    status = vol->CheckIo(&ok);

    FtpDecrementRefCount(extension);

    if (NT_SUCCESS(status)) {
        output->IsIoOk = ok;
        Irp->IoStatus.Information = sizeof(FT_CHECK_IO_OUTPUT);
    }

    return status;
}

NTSTATUS
FtpBreakLogicalDiskHelper(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  RootLogicalDiskId
    )

/*++

Routine Description:

    This routine breaks a given logical disk.

Arguments:

    RootExtension       - Supplies the root extension.

    RootLogicalDiskId   - Supplies the root logical disk id.

Return Value:

    NTSTATUS

--*/

{
    FT_LOGICAL_DISK_ID                      diskId;
    PFT_LOGICAL_DISK_INFORMATION_SET        diskInfoSet;
    PVOLUME_EXTENSION                       extension;
    FT_LOGICAL_DISK_TYPE                    diskType;
    UCHAR                                   newUniqueIdBuffer[UNIQUE_ID_MAX_BUFFER_SIZE];
    PMOUNTDEV_UNIQUE_ID                     newUniqueId;
    PPARTITION                              partition;
    BOOLEAN                                 closeHandle;
    PFT_VOLUME                              vol, member, m;
    HANDLE                                  handle;
    PFT_MIRROR_AND_SWP_STATE_INFORMATION    state;
    USHORT                                  n, i;
    NTSTATUS                                status;
    KEVENT                                  event;
    SET_TARGET_CONTEXT                      context;
    ULONG                                   alignment;

    diskId = RootLogicalDiskId;
    diskInfoSet = RootExtension->DiskInfoSet;

    extension = FtpFindExtension(RootExtension, diskId);
    if (!extension) {
        return STATUS_INVALID_PARAMETER;
    }
    alignment = extension->DeviceObject->AlignmentRequirement;

    diskType = diskInfoSet->QueryLogicalDiskType(diskId);
    newUniqueId = (PMOUNTDEV_UNIQUE_ID) newUniqueIdBuffer;

    vol = extension->FtVolume;

    if (diskType == FtPartition) {

        partition = (PPARTITION) vol;
        KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
        context.TargetObject = partition->GetTargetObject();
        context.FtVolume = NULL;
        context.WholeDiskPdo = partition->GetWholeDiskPdo();
        FtpZeroRefCallback(extension, FtpSetTargetCallback, &context, TRUE);
        KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE,
                              NULL);

        member = NULL;
        closeHandle = FALSE;
        FtpResetPartitionType(extension);

        FtpQueryUniqueIdBuffer(extension, newUniqueId->UniqueId,
                               &newUniqueId->UniqueIdLength);
        FtpUniqueIdNotify(extension, newUniqueId);

    } else if (diskType == FtMirrorSet) {

        state = (PFT_MIRROR_AND_SWP_STATE_INFORMATION)
                diskInfoSet->GetStateInformation(diskId);
        if (!state) {
            return STATUS_INVALID_PARAMETER;
        }

        if (state->UnhealthyMemberState == FtMemberHealthy ||
            state->UnhealthyMemberNumber != 0) {

            member = vol->GetMember(0);
            if (!member) {
                member = vol->GetMember(1);
            }

        } else {
            member = vol->GetMember(1);
            if (!member) {
                member = vol->GetMember(0);
            }
        }

        KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
        context.TargetObject = NULL;
        context.FtVolume = member;
        context.WholeDiskPdo = NULL;
        FtpZeroRefCallback(extension, FtpSetTargetCallback, &context, TRUE);
        KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE,
                              NULL);

        closeHandle = FALSE;

        FtpQueryUniqueIdBuffer(extension, newUniqueId->UniqueId,
                               &newUniqueId->UniqueIdLength);
        FtpUniqueIdNotify(extension, newUniqueId);

    } else {
        if (!FtpLockLogicalDisk(RootExtension, diskId, &handle)) {
            return STATUS_ACCESS_DENIED;
        }
        closeHandle = TRUE;
        member = NULL;
    }

    status = diskInfoSet->BreakLogicalDisk(diskId);
    if (!NT_SUCCESS(status)) {
        KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
        context.TargetObject = NULL;
        context.FtVolume = vol;
        context.WholeDiskPdo = NULL;
        FtpZeroRefCallback(extension, FtpSetTargetCallback, &context, TRUE);
        KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE,
                              NULL);

        if (closeHandle) {
            ZwClose(handle);
        }
        return status;
    }

    if (closeHandle) {

        KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
        context.TargetObject = NULL;
        context.FtVolume = NULL;
        context.WholeDiskPdo = NULL;
        FtpZeroRefCallback(extension, FtpSetTargetCallback, &context, TRUE);
        KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE,
                              NULL);

        RemoveEntryList(&extension->ListEntry);
        InsertTailList(&RootExtension->DeadVolumeList, &extension->ListEntry);
        FtpDeleteMountPoints(extension);
        FtpCleanupVolumeExtension(extension);
    }

    n = vol->QueryNumberOfMembers();
    for (i = 0; i < n; i++) {
        m = vol->GetMember(i);
        if (!m || m == member) {
            continue;
        }
        FtpCreateNewDevice(RootExtension, NULL, m, NULL, alignment, FALSE,
                           FALSE, FALSE, FALSE, 0);
    }
    if (!InterlockedDecrement(&vol->_refCount)) {
        delete vol;
    }

    if (member) {
        FtpNotify(RootExtension, extension);
    } else if (!closeHandle) {
        FtpNotify(RootExtension, extension);
    }

    if (closeHandle) {
        ZwClose(handle);
    }

    if (diskType != FtPartition) {
        IoInvalidateDeviceRelations(RootExtension->Pdo, BusRelations);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpReplaceLogicalDiskMember(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine replaces the given logical disk member.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFT_REPLACE_LOGICAL_DISK_MEMBER_INPUT   input;
    PFT_REPLACE_LOGICAL_DISK_MEMBER_OUTPUT  output;
    FT_LOGICAL_DISK_ID                      diskId, newMemberDiskId, newDiskId;
    USHORT                                  member;
    HANDLE                                  handle;
    PVOLUME_EXTENSION                       replacementExtension, extension;
    PFT_VOLUME                              replacementVolume, vol, oldVol, root;
    NTSTATUS                                status;
    PFT_LOGICAL_DISK_INFORMATION_SET        diskInfoSet;
    PVOLUME_EXTENSION                       oldVolExtension;
    PFT_LOGICAL_DISK_DESCRIPTION            p;
    WCHAR                                   deviceNameBuffer[64];
    UNICODE_STRING                          deviceName;
    UCHAR                                   newUniqueIdBuffer[UNIQUE_ID_MAX_BUFFER_SIZE];
    PMOUNTDEV_UNIQUE_ID                     newUniqueId;
    KEVENT                                  event;
    SET_TARGET_CONTEXT                      context;
    ULONG                                   alignment;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(FT_REPLACE_LOGICAL_DISK_MEMBER_INPUT) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(FT_REPLACE_LOGICAL_DISK_MEMBER_OUTPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PFT_REPLACE_LOGICAL_DISK_MEMBER_INPUT)
            Irp->AssociatedIrp.SystemBuffer;
    output = (PFT_REPLACE_LOGICAL_DISK_MEMBER_OUTPUT)
             Irp->AssociatedIrp.SystemBuffer;

    diskId = input->LogicalDiskId;
    member = input->MemberNumberToReplace;
    newMemberDiskId = input->NewMemberLogicalDiskId;

    if (!FtpLockLogicalDisk(RootExtension, newMemberDiskId, &handle)) {
        return STATUS_ACCESS_DENIED;
    }

    replacementExtension = FtpFindExtension(RootExtension, newMemberDiskId);
    extension = FtpFindExtensionCoveringDiskId(RootExtension, diskId);
    if (!extension || !extension->FtVolume || !replacementExtension ||
        !replacementExtension->FtVolume) {

        ZwClose(handle);
        return STATUS_INVALID_PARAMETER;
    }

    alignment = extension->DeviceObject->AlignmentRequirement;
    extension->DeviceObject->AlignmentRequirement |=
            replacementExtension->DeviceObject->AlignmentRequirement;

    newUniqueId = (PMOUNTDEV_UNIQUE_ID) newUniqueIdBuffer;

    replacementVolume = replacementExtension->FtVolume;
    root = extension->FtVolume;
    vol = root->GetContainedLogicalDisk(diskId);

    // Flush the QUEUE so that no IRPs in transit have incorrect alignment.
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    FtpZeroRefCallback(extension, FtpQueryRemoveCallback, &event,
                       TRUE);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                          NULL);

    status = FtpAllSystemsGo(extension, NULL, FALSE, TRUE, TRUE);
    if (!NT_SUCCESS(status)) {
        ZwClose(handle);
        return status;
    }

    status = FtpCheckForCompleteVolume(extension, vol);
    if (!NT_SUCCESS(status)) {
        FtpDecrementRefCount(extension);
        ZwClose(handle);
        return status;
    }

    status = FtpAllSystemsGo(replacementExtension, NULL, TRUE, TRUE, TRUE);
    if (!NT_SUCCESS(status)) {
        FtpDecrementRefCount(extension);
        ZwClose(handle);
        return status;
    }

    FtpDecrementRefCount(replacementExtension);

    KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
    context.TargetObject = NULL;
    context.FtVolume = NULL;
    context.WholeDiskPdo = NULL;
    FtpZeroRefCallback(replacementExtension, FtpSetTargetCallback, &context,
                       TRUE);
    KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE, NULL);

    oldVol = vol->GetMember(member);

    if (!vol->IsVolumeSuitableForRegenerate(member, replacementVolume)) {
        FtpDecrementRefCount(extension);

        KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
        context.TargetObject = NULL;
        context.FtVolume = replacementVolume;
        context.WholeDiskPdo = NULL;
        FtpZeroRefCallback(replacementExtension, FtpSetTargetCallback,
                           &context, TRUE);
        KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE,
                              NULL);

        ZwClose(handle);
        return STATUS_INVALID_PARAMETER;
    }

    diskInfoSet = RootExtension->DiskInfoSet;
    status = diskInfoSet->ReplaceLogicalDiskMember(diskId, member,
                                                   newMemberDiskId,
                                                   &newDiskId);
    if (!NT_SUCCESS(status)) {
        FtpDecrementRefCount(extension);

        KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
        context.TargetObject = NULL;
        context.FtVolume = replacementVolume;
        context.WholeDiskPdo = NULL;
        FtpZeroRefCallback(replacementExtension, FtpSetTargetCallback,
                           &context, TRUE);
        KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE,
                              NULL);

        ZwClose(handle);
        return status;
    }

    InterlockedIncrement(&extension->RefCount);
    vol->RegenerateMember(member, replacementVolume,
                          FtpRefCountCompletion, extension);
    vol->StartSyncOperations(FALSE, FtpRefCountCompletion, extension);

    RemoveEntryList(&replacementExtension->ListEntry);
    InsertTailList(&RootExtension->DeadVolumeList,
                   &replacementExtension->ListEntry);
    FtpDeleteMountPoints(replacementExtension);
    FtpCleanupVolumeExtension(replacementExtension);

    Irp->IoStatus.Information =
            sizeof(FT_REPLACE_LOGICAL_DISK_MEMBER_OUTPUT);
    output->NewLogicalDiskId = newDiskId;

    vol->SetLogicalDiskId(newDiskId);

    while (p = diskInfoSet->GetParentLogicalDiskDescription(
           vol->QueryLogicalDiskId())) {

        if (vol = root->GetParentLogicalDisk(vol)) {
            vol->SetLogicalDiskId(p->LogicalDiskId);
        }
    }

    if (oldVol) {
        FtpCreateNewDevice(RootExtension, NULL, oldVol, NULL, alignment, FALSE,
                           FALSE, FALSE, FALSE, 0);
    }

    swprintf(deviceNameBuffer, L"\\Device\\HarddiskVolume%d", extension->VolumeNumber);
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);
    replacementVolume->CreateLegacyNameLinks(&deviceName);

    FtpQueryUniqueIdBuffer(extension, newUniqueId->UniqueId,
                           &newUniqueId->UniqueIdLength);
    FtpUniqueIdNotify(extension, newUniqueId);

    IoInvalidateDeviceRelations(RootExtension->Pdo, BusRelations);

    ZwClose(handle);

    return status;
}

NTSTATUS
FtDiskPagingNotification(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine handles the PnP paging notification IRP.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION                   extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION                  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                            status;
    PFT_VOLUME                          vol;

    ASSERT(extension->DeviceExtensionType != DEVICE_EXTENSION_ROOT);

    status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
    if (status == STATUS_PENDING) {
        return status;
    }
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging) {
        extension->InPagingPath = irpSp->Parameters.UsageNotification.InPath;
        IoInvalidateDeviceState(extension->DeviceObject);
    }

    if (extension->TargetObject) {
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, FtpRefCountCompletionRoutine,
                               extension, TRUE, TRUE, TRUE);
        IoMarkIrpPending(Irp);

        IoCallDriver(extension->TargetObject, Irp);

        return STATUS_PENDING;
    }

    vol = extension->FtVolume;
    ASSERT(vol);

    IoMarkIrpPending(Irp);
    irpSp->DeviceObject = DeviceObject;

    vol->BroadcastIrp(Irp, FtDiskShutdownFlushCompletionRoutine, Irp);

    return STATUS_PENDING;
}

VOID
FtpDereferenceMbrGptAttributes(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PDEVICE_OBJECT      WholeDiskPdo
    )

{
    PLIST_ENTRY                     l;
    PVOLUME_EXTENSION               extension;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;

    for (l = Extension->Root->VolumeList.Flink;
         l != &Extension->Root->VolumeList; l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        if (extension == Extension ||
            extension->WholeDiskPdo != WholeDiskPdo ||
            !extension->MbrGptAttributes) {

            continue;
        }

        return;
    }

    diskInfo = Extension->Root->DiskInfoSet->FindLogicalDiskInformation(
               WholeDiskPdo);
    if (diskInfo) {
        diskInfo->SetGptAttributes(0);
    }
}

NTSTATUS
FtpPartitionRemovedHelper(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN      PDEVICE_OBJECT  Partition,
    IN      PDEVICE_OBJECT  WholeDiskPdo
    )

{
    PVOLUME_EXTENSION               extension;
    KEVENT                          event;
    PFT_VOLUME                      vol, part, parent;
    FT_PARTITION_OFFLINE_CONTEXT    offlineContext;
    USHORT                          n, i;
    SET_TARGET_CONTEXT              context;

    extension = FtpFindExtensionCoveringPartition(RootExtension, Partition);
    if (!extension) {
        return STATUS_INVALID_PARAMETER;
    }

    if (extension->TargetObject) {
        ASSERT(extension->TargetObject == Partition);

        KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
        context.TargetObject = NULL;
        context.FtVolume = NULL;
        context.WholeDiskPdo = NULL;
        FtpZeroRefCallback(extension, FtpSetTargetCallback, &context, TRUE);
        KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE,
                              NULL);

        if (WholeDiskPdo) {
            FtpDeleteMountPoints(extension);
            if (!extension->IsGpt && extension->MbrGptAttributes) {
                FtpDereferenceMbrGptAttributes(extension, WholeDiskPdo);
            }
        }

        RemoveEntryList(&extension->ListEntry);
        InsertTailList(&RootExtension->DeadVolumeList, &extension->ListEntry);
        FtpCleanupVolumeExtension(extension);

        IoInvalidateDeviceRelations(RootExtension->Pdo, BusRelations);

    } else {

        vol = extension->FtVolume;
        ASSERT(vol);
        part = vol->GetContainedLogicalDisk(Partition);
        parent = vol->GetParentLogicalDisk(part);
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        offlineContext.Root = vol;
        offlineContext.Parent = parent;
        offlineContext.Child = part;
        offlineContext.Event = &event;
        FtpZeroRefCallback(extension, FtpMemberOfflineCallback,
                           &offlineContext, TRUE);
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

        if (extension->FtVolume) {
            FtpNotify(RootExtension, extension);
        } else {
            if (WholeDiskPdo) {
                FtpDeleteMountPoints(extension);
                FtpTotalBreakUp(RootExtension, vol->QueryLogicalDiskId());
            }
            FtpDeleteVolume(vol);
            RemoveEntryList(&extension->ListEntry);
            InsertTailList(&RootExtension->DeadVolumeList, &extension->ListEntry);
            FtpCleanupVolumeExtension(extension);
            IoInvalidateDeviceRelations(RootExtension->Pdo, BusRelations);
        }

        if (parent) {
            if (!InterlockedDecrement(&part->_refCount)) {
                delete part;
            }
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpGetVolumeDiskExtents(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the disk extents for the given volume.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLUME_DISK_EXTENTS    output = (PVOLUME_DISK_EXTENTS) Irp->AssociatedIrp.SystemBuffer;
    NTSTATUS                status;
    ULONG                   diskNumber, numExtents;
    LONGLONG                offset, length;
    PDISK_EXTENT            extents;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(VOLUME_DISK_EXTENTS)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (Extension->TargetObject) {
        status = FtpQueryPartitionInformation(Extension->Root,
                                              Extension->TargetObject,
                                              &diskNumber, &offset, NULL,
                                              NULL, &length, NULL, NULL, NULL,
                                              NULL);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        Irp->IoStatus.Information = sizeof(VOLUME_DISK_EXTENTS);
        output->NumberOfDiskExtents = 1;
        output->Extents[0].DiskNumber = diskNumber;
        output->Extents[0].StartingOffset.QuadPart = offset;
        output->Extents[0].ExtentLength.QuadPart = length;

        return STATUS_SUCCESS;
    }

    status = Extension->FtVolume->QueryDiskExtents(&extents, &numExtents);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    output->NumberOfDiskExtents = numExtents;
    Irp->IoStatus.Information = FIELD_OFFSET(VOLUME_DISK_EXTENTS, Extents) +
                                numExtents*sizeof(DISK_EXTENT);
    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = FIELD_OFFSET(VOLUME_DISK_EXTENTS, Extents);
        ExFreePool(extents);
        return STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory(output->Extents, extents, numExtents*sizeof(DISK_EXTENT));
    ExFreePool(extents);

    return status;
}

NTSTATUS
FtpDisksFromFtVolume(
    IN  PFT_VOLUME          FtVolume,
    OUT PDEVICE_OBJECT**    DiskPdos,
    OUT PULONG              NumDiskPdos
    )

{
    PDEVICE_OBJECT* diskPdos;
    ULONG           numDisks, nd, j, k;
    USHORT          n, i;
    PFT_VOLUME      vol;
    PDEVICE_OBJECT* dp;
    NTSTATUS        status;
    PDEVICE_OBJECT* diskPdos2;

    if (FtVolume->QueryLogicalDiskType() == FtPartition) {
        numDisks = 1;
        diskPdos = (PDEVICE_OBJECT*)
                   ExAllocatePool(PagedPool, numDisks*sizeof(PDEVICE_OBJECT));
        if (!diskPdos) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        diskPdos[0] = ((PPARTITION) FtVolume)->GetWholeDiskPdo();
        *DiskPdos = diskPdos;
        *NumDiskPdos = numDisks;
        return STATUS_SUCCESS;
    }

    diskPdos = NULL;
    numDisks = 0;

    n = FtVolume->QueryNumberOfMembers();
    for (i = 0; i < n; i++) {
        vol = FtVolume->GetMember(i);
        if (!vol) {
            continue;
        }

        status = FtpDisksFromFtVolume(vol, &dp, &nd);
        if (!NT_SUCCESS(status)) {
            if (diskPdos) {
                ExFreePool(diskPdos);
            }
            return status;
        }

        diskPdos2 = diskPdos;
        diskPdos = (PDEVICE_OBJECT*) ExAllocatePool(PagedPool,
                   (numDisks + nd)*sizeof(PDEVICE_OBJECT));
        if (!diskPdos) {
            ExFreePool(dp);
            if (diskPdos2) {
                ExFreePool(diskPdos2);
            }
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        if (diskPdos2) {
            RtlCopyMemory(diskPdos, diskPdos2,
                          numDisks*sizeof(PDEVICE_OBJECT));
            ExFreePool(diskPdos2);
        }

        for (j = 0; j < nd; j++) {
            for (k = 0; k < numDisks; k++) {
                if (dp[j] == diskPdos[k]) {
                    break;
                }
            }
            if (k == numDisks) {
                diskPdos[numDisks++] = dp[j];
            }
        }

        ExFreePool(dp);
    }

    *DiskPdos = diskPdos;
    *NumDiskPdos = numDisks;

    return STATUS_SUCCESS;
}

NTSTATUS
FtpDisksFromVolumes(
    IN  PVOLUME_EXTENSION*  Extensions,
    IN  ULONG               NumVolumes,
    OUT PDEVICE_OBJECT**    WholeDiskPdos,
    OUT PULONG              NumDisks
    )

/*++

Routine Description:

    This routine computes the disks that are used by the given volumes
    and returns the list of whole disk pdos.

Arguments:

    Extensions      - Supplies the list of volumes.

    NumVolumes      - Supplies the number of volumes.

    WholeDiskPdos   - Returns the list of disks.

    NumDisks        - Returns the number of disks.

Return Value:

    NTSTATUS

--*/

{
    ULONG           numDisks, i, j, k;
    PDEVICE_OBJECT* diskPdos;
    PDEVICE_OBJECT* diskPdos2;
    NTSTATUS        status;
    PDEVICE_OBJECT* volumeDiskPdos;
    ULONG           numVolumeDisks;

    numDisks = 0;
    diskPdos = NULL;

    for (i = 0; i < NumVolumes; i++) {

        if (Extensions[i]->TargetObject) {
            for (j = 0; j < numDisks; j++) {
                if (Extensions[i]->WholeDiskPdo == diskPdos[j]) {
                    break;
                }
            }
            if (j == numDisks) {
                diskPdos2 = diskPdos;
                numDisks++;
                diskPdos = (PDEVICE_OBJECT*)
                           ExAllocatePool(PagedPool,
                                          numDisks*sizeof(PDEVICE_OBJECT));
                if (!diskPdos) {
                    if (diskPdos2) {
                        ExFreePool(diskPdos2);
                    }
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
                if (diskPdos2) {
                    RtlCopyMemory(diskPdos, diskPdos2,
                                  (numDisks - 1)*sizeof(PDEVICE_OBJECT));
                    ExFreePool(diskPdos2);
                }
                diskPdos[numDisks - 1] = Extensions[i]->WholeDiskPdo;
            }

        } else if (Extensions[i]->FtVolume) {

            status = FtpDisksFromFtVolume(Extensions[i]->FtVolume,
                                          &volumeDiskPdos, &numVolumeDisks);
            if (!NT_SUCCESS(status)) {
                if (diskPdos) {
                    ExFreePool(diskPdos);
                }
                return status;
            }

            diskPdos2 = diskPdos;
            diskPdos = (PDEVICE_OBJECT*) ExAllocatePool(PagedPool,
                       (numDisks + numVolumeDisks)*sizeof(PDEVICE_OBJECT));
            if (!diskPdos) {
                ExFreePool(volumeDiskPdos);
                if (diskPdos2) {
                    ExFreePool(diskPdos2);
                }
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            if (diskPdos2) {
                RtlCopyMemory(diskPdos, diskPdos2,
                              numDisks*sizeof(PDEVICE_OBJECT));
                ExFreePool(diskPdos2);
            }

            for (j = 0; j < numVolumeDisks; j++) {
                for (k = 0; k < numDisks; k++) {
                    if (volumeDiskPdos[j] == diskPdos[k]) {
                        break;
                    }
                }
                if (k == numDisks) {
                    diskPdos[numDisks++] = volumeDiskPdos[j];
                }
            }

            ExFreePool(volumeDiskPdos);
        }
    }

    *WholeDiskPdos = diskPdos;
    *NumDisks = numDisks;

    return STATUS_SUCCESS;
}

BOOLEAN
FtpVolumeContainsDisks(
    IN  PFT_VOLUME          FtVolume,
    IN  PDEVICE_OBJECT*     WholeDiskPdos,
    IN  ULONG               NumDisks
    )

/*++

Routine Description:

    This routine determines whether or not the given volume contains
    any of the given disks.

Arguments:

    FtVolume    - Supplies the FT volumes.

    WholeDiskPdos   - Supplies the list of disks.

    NumDisks        - Supplies the number of disks.

Return Value:

    FALSE   - The given volume does not contain any of the given disks.

    TRUE    - The given volume contains at least one of the given disks.

--*/

{
    PDEVICE_OBJECT  wholeDiskPdo;
    ULONG           i;
    USHORT          n, j;
    PFT_VOLUME      vol;

    if (FtVolume->QueryLogicalDiskType() == FtPartition) {
        wholeDiskPdo = ((PPARTITION) FtVolume)->GetWholeDiskPdo();
        for (i = 0; i < NumDisks; i++) {
            if (wholeDiskPdo == WholeDiskPdos[i]) {
                return TRUE;
            }
        }

        return FALSE;
    }

    n = FtVolume->QueryNumberOfMembers();
    for (j = 0; j < n; j++) {
        vol = FtVolume->GetMember(j);
        if (!vol) {
            continue;
        }

        if (FtpVolumeContainsDisks(vol, WholeDiskPdos, NumDisks)) {
            return TRUE;
        }
    }

    return FALSE;
}

NTSTATUS
FtpVolumesFromDisks(
    IN  PROOT_EXTENSION     RootExtension,
    IN  PDEVICE_OBJECT*     WholeDiskPdos,
    IN  ULONG               NumDisks,
    OUT PVOLUME_EXTENSION** Extensions,
    OUT PULONG              NumVolumes
    )

/*++

Routine Description:

    This routine computes the volumes that use the given set of disks
    and returns the list of volume device extensions.

Arguments:

    RootExtension   - Supplies the root extension.

    WholeDiskPdos   - Supplies the list of disks.

    NumDisks        - Supplies the number of disks.

    Extensions      - Returns the list of volumes.

    NumVolumes      - Returns the number of volumes.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION*  extensions;
    ULONG               numVolumes;
    PLIST_ENTRY         l;
    PVOLUME_EXTENSION   extension;
    ULONG               i;

    extensions = (PVOLUME_EXTENSION*)
                 ExAllocatePool(PagedPool, RootExtension->NextVolumeNumber*
                                sizeof(PVOLUME_EXTENSION));
    if (!extensions) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    numVolumes = 0;
    for (l = RootExtension->VolumeList.Flink;
         l != &RootExtension->VolumeList; l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        if (extension->TargetObject) {
            for (i = 0; i < NumDisks; i++) {
                if (WholeDiskPdos[i] == extension->WholeDiskPdo) {
                    break;
                }
            }
            if (i == NumDisks) {
                continue;
            }
        } else if (extension->FtVolume) {
            if (!FtpVolumeContainsDisks(extension->FtVolume, WholeDiskPdos,
                                        NumDisks)) {

                continue;
            }
        } else {
            continue;
        }

        extensions[numVolumes++] = extension;
    }

    *Extensions = extensions;
    *NumVolumes = numVolumes;

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryFailoverSet(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the list of disks which include the given volume
    and which make up a failover set.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG                   numVolumes, numVolumes2, numDisks, numDisks2;
    PVOLUME_EXTENSION*      extensions;
    PDEVICE_OBJECT*         diskPdos;
    NTSTATUS                status;
    PVOLUME_FAILOVER_SET    output;
    ULONG                   i;
    PDEVICE_OBJECT          deviceObject;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(VOLUME_FAILOVER_SET)) {

        return STATUS_INVALID_PARAMETER;
    }

    numVolumes = 1;
    extensions = (PVOLUME_EXTENSION*)
                 ExAllocatePool(PagedPool,
                                numVolumes*sizeof(PVOLUME_EXTENSION));
    if (!extensions) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    extensions[0] = Extension;

    diskPdos = NULL;
    numDisks = 0;

    for (;;) {

        numDisks2 = numDisks;
        if (diskPdos) {
            ExFreePool(diskPdos);
            diskPdos = NULL;
        }

        status = FtpDisksFromVolumes(extensions, numVolumes, &diskPdos,
                                     &numDisks);
        if (!NT_SUCCESS(status)) {
            break;
        }

        if (numDisks == numDisks2) {
            status = STATUS_SUCCESS;
            break;
        }

        numVolumes2 = numVolumes;
        if (extensions) {
            ExFreePool(extensions);
            extensions = NULL;
        }

        status = FtpVolumesFromDisks(Extension->Root, diskPdos, numDisks,
                                     &extensions, &numVolumes);
        if (!NT_SUCCESS(status)) {
            break;
        }

        if (numVolumes == numVolumes2) {
            status = STATUS_SUCCESS;
            break;
        }
    }

    if (extensions) {
        ExFreePool(extensions);
    }

    if (!NT_SUCCESS(status)) {
        if (diskPdos) {
            ExFreePool(diskPdos);
        }
        return status;
    }

    output = (PVOLUME_FAILOVER_SET) Irp->AssociatedIrp.SystemBuffer;
    output->NumberOfDisks = numDisks;
    Irp->IoStatus.Information =
            FIELD_OFFSET(VOLUME_FAILOVER_SET, DiskNumbers) +
            numDisks*sizeof(ULONG);
    if (Irp->IoStatus.Information >
        irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

        Irp->IoStatus.Information = sizeof(VOLUME_FAILOVER_SET);
        if (diskPdos) {
            ExFreePool(diskPdos);
        }
        return STATUS_BUFFER_OVERFLOW;
    }

    for (i = 0; i < numDisks; i++) {
        deviceObject = IoGetAttachedDeviceReference(diskPdos[i]);
        status = FtpQueryPartitionInformation(Extension->Root, deviceObject,
                                              &output->DiskNumbers[i],
                                              NULL, NULL, NULL, NULL, NULL,
                                              NULL, NULL, NULL);
        ObDereferenceObject(deviceObject);
        if (!NT_SUCCESS(status)) {
            Irp->IoStatus.Information = 0;
            if (diskPdos) {
                ExFreePool(diskPdos);
            }
            return status;
        }
    }

    if (diskPdos) {
        ExFreePool(diskPdos);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryVolumeNumber(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the volume number for the given volume.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLUME_NUMBER      output;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(VOLUME_NUMBER)) {

        return STATUS_INVALID_PARAMETER;
    }

    output = (PVOLUME_NUMBER) Irp->AssociatedIrp.SystemBuffer;
    output->VolumeNumber = Extension->VolumeNumber;
    RtlCopyMemory(output->VolumeManagerName, L"FTDISK  ", 16);

    Irp->IoStatus.Information = sizeof(VOLUME_NUMBER);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpLogicalToPhysical(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns physical disk and offset for a given volume
    logical offset.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLUME_LOGICAL_OFFSET      input;
    LONGLONG                    logicalOffset;
    PVOLUME_PHYSICAL_OFFSETS    output;
    NTSTATUS                    status;
    ULONG                       diskNumber;
    LONGLONG                    partitionOffset, partitionLength;
    PFT_VOLUME                  vol;
    PVOLUME_PHYSICAL_OFFSET     physicalOffsets;
    ULONG                       numPhysicalOffsets;
    ULONG                       i;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLUME_LOGICAL_OFFSET) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(VOLUME_PHYSICAL_OFFSETS)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PVOLUME_LOGICAL_OFFSET) Irp->AssociatedIrp.SystemBuffer;
    logicalOffset = input->LogicalOffset;
    output = (PVOLUME_PHYSICAL_OFFSETS) Irp->AssociatedIrp.SystemBuffer;

    if (Extension->TargetObject) {
        status = FtpQueryPartitionInformation(Extension->Root,
                                              Extension->TargetObject,
                                              &diskNumber,
                                              &partitionOffset, NULL, NULL,
                                              &partitionLength, NULL, NULL,
                                              NULL, NULL);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (logicalOffset < 0 ||
            partitionLength <= logicalOffset) {
            return STATUS_INVALID_PARAMETER;
        }

        output->NumberOfPhysicalOffsets = 1;
        output->PhysicalOffset[0].DiskNumber = diskNumber;
        output->PhysicalOffset[0].Offset = partitionOffset + logicalOffset;

        Irp->IoStatus.Information = sizeof(VOLUME_PHYSICAL_OFFSETS);

        return status;
    }

    vol = Extension->FtVolume;
    ASSERT(vol);

    status = vol->QueryPhysicalOffsets(logicalOffset, &physicalOffsets,
                                       &numPhysicalOffsets);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    Irp->IoStatus.Information = FIELD_OFFSET(VOLUME_PHYSICAL_OFFSETS,
                                             PhysicalOffset) +
                                numPhysicalOffsets*
                                sizeof(VOLUME_PHYSICAL_OFFSET);

    output->NumberOfPhysicalOffsets = numPhysicalOffsets;

    if (Irp->IoStatus.Information >
        irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

        Irp->IoStatus.Information = FIELD_OFFSET(VOLUME_PHYSICAL_OFFSETS,
                                                 PhysicalOffset);
        ExFreePool(physicalOffsets);
        return STATUS_BUFFER_OVERFLOW;
    }

    for (i = 0; i < numPhysicalOffsets; i++) {
        output->PhysicalOffset[i] = physicalOffsets[i];
    }

    ExFreePool(physicalOffsets);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpPhysicalToLogical(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the volume logical offset for a given disk number
    and physical offset.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLUME_PHYSICAL_OFFSET     input;
    ULONG                       diskNumber, otherDiskNumber;
    LONGLONG                    physicalOffset;
    PVOLUME_LOGICAL_OFFSET      output;
    NTSTATUS                    status;
    LONGLONG                    partitionOffset, partitionLength;
    PFT_VOLUME                  vol;
    LONGLONG                    logicalOffset;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLUME_PHYSICAL_OFFSET) ||
        irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(VOLUME_LOGICAL_OFFSET)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PVOLUME_PHYSICAL_OFFSET) Irp->AssociatedIrp.SystemBuffer;
    diskNumber = input->DiskNumber;
    physicalOffset = input->Offset;
    output = (PVOLUME_LOGICAL_OFFSET) Irp->AssociatedIrp.SystemBuffer;

    if (Extension->TargetObject) {
        status = FtpQueryPartitionInformation(Extension->Root,
                                              Extension->TargetObject,
                                              &otherDiskNumber,
                                              &partitionOffset, NULL, NULL,
                                              &partitionLength, NULL, NULL,
                                              NULL, NULL);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (diskNumber != otherDiskNumber ||
            physicalOffset < partitionOffset ||
            partitionOffset + partitionLength <= physicalOffset) {

            return STATUS_INVALID_PARAMETER;
        }

        output->LogicalOffset = physicalOffset - partitionOffset;

        Irp->IoStatus.Information = sizeof(VOLUME_LOGICAL_OFFSET);

        return status;
    }

    vol = Extension->FtVolume;
    ASSERT(vol);

    status = vol->QueryLogicalOffset(input, &logicalOffset);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    output->LogicalOffset = logicalOffset;
    Irp->IoStatus.Information = sizeof(VOLUME_LOGICAL_OFFSET);

    return status;
}

BOOLEAN
FtpIsReplicatedPartition(
    IN  PFT_VOLUME  FtVolume
    )

{
    PFT_VOLUME  m0, m1;

    if (FtVolume->QueryLogicalDiskType() == FtPartition) {
        return TRUE;
    }

    if (FtVolume->QueryLogicalDiskType() != FtMirrorSet) {
        return FALSE;
    }

    m0 = FtVolume->GetMember(0);
    m1 = FtVolume->GetMember(1);

    if (m0 && !FtpIsReplicatedPartition(m0)) {
        return FALSE;
    }

    if (m1 && !FtpIsReplicatedPartition(m1)) {
        return FALSE;
    }

    if (!m0 && !m1) {
        return FALSE;
    }

    return TRUE;
}

NTSTATUS
FtpIsPartition(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine determines whether the given volume is installable. 
    To be an installable volume on Whistler, the volume must be a basic 
    partition. 

    We will disallow installing to Ft mirrors on Whistler, because we will
    offline Ft volumes after a Whistler install\upgrade.
    
    This call will return STATUS_UNSUCCESSFUL for all volumes that are
    not a simple basic partition, e.g., mirrors, RAID5, stripe sets
    and volume sets.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS    status;

    if (Extension->TargetObject) {
        status = STATUS_SUCCESS;
    } 
    else if (Extension->FtVolume && FtpIsReplicatedPartition(Extension->FtVolume)) {
        status = STATUS_SUCCESS;
    } 
    else {
        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}

NTSTATUS
FtpSetGptAttributesOnDisk(
    IN  PDEVICE_OBJECT  Partition,
    IN  ULONGLONG       GptAttributes
    )

{
    KEVENT                          event;
    PIRP                            irp;
    PARTITION_INFORMATION_EX        partInfo;
    IO_STATUS_BLOCK                 ioStatus;
    NTSTATUS                        status;
    SET_PARTITION_INFORMATION_EX    setPartInfo;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO_EX,
                                        Partition, NULL, 0, &partInfo,
                                        sizeof(partInfo), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(Partition, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        return status;
    }

    ASSERT(partInfo.PartitionStyle == PARTITION_STYLE_GPT);

    setPartInfo.PartitionStyle = partInfo.PartitionStyle;
    setPartInfo.Gpt = partInfo.Gpt;
    setPartInfo.Gpt.Attributes = GptAttributes;

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_SET_PARTITION_INFO_EX,
                                        Partition, &setPartInfo,
                                        sizeof(setPartInfo), NULL, 0, FALSE,
                                        &event, &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(Partition, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        return status;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpCheckSecurity(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

{
    SECURITY_SUBJECT_CONTEXT    securityContext;
    BOOLEAN                     accessGranted;
    NTSTATUS                    status;
    ACCESS_MASK                 grantedAccess;

    SeCaptureSubjectContext(&securityContext);
    SeLockSubjectContext(&securityContext);

    accessGranted = FALSE;
    status = STATUS_ACCESS_DENIED;

    _try {

        accessGranted = SeAccessCheck(
                        Extension->DeviceObject->SecurityDescriptor,
                        &securityContext, TRUE, FILE_READ_DATA, 0, NULL,
                        IoGetFileObjectGenericMapping(), Irp->RequestorMode,
                        &grantedAccess, &status);

    } _finally {
        SeUnlockSubjectContext(&securityContext);
        SeReleaseSubjectContext(&securityContext);
    }

    if (!accessGranted) {
        return status;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryRegistryRevertEntriesCallback(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   RevertEntries,
    IN  PVOID   NumberOfRevertEntries
    )

{
    PFTP_GPT_ATTRIBUTE_REVERT_ENTRY*    revertEntries = (PFTP_GPT_ATTRIBUTE_REVERT_ENTRY*) RevertEntries;
    PULONG                              pn = (PULONG) NumberOfRevertEntries;

    if (ValueType != REG_BINARY) {
        return STATUS_SUCCESS;
    }

    (*revertEntries) = (PFTP_GPT_ATTRIBUTE_REVERT_ENTRY)
                       ExAllocatePool(PagedPool, ValueLength);
    if (!(*revertEntries)) {
        return STATUS_SUCCESS;
    }

    RtlCopyMemory((*revertEntries), ValueData, ValueLength);
    *pn = ValueLength/sizeof(FTP_GPT_ATTRIBUTE_REVERT_ENTRY);

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryRegistryRevertEntries(
    IN  PROOT_EXTENSION                     RootExtension,
    OUT PFTP_GPT_ATTRIBUTE_REVERT_ENTRY*    RevertEntries,
    OUT PULONG                              NumberOfRevertEntries
    )

{
    RTL_QUERY_REGISTRY_TABLE        queryTable[2];
    PFTP_GPT_ATTRIBUTE_REVERT_ENTRY revertEntries;
    ULONG                           n;

    revertEntries = NULL;
    n = 0;

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = FtpQueryRegistryRevertEntriesCallback;
    queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = REVERT_GPT_ATTRIBUTES_REGISTRY_NAME;
    queryTable[0].EntryContext = &n;

    if (!RootExtension->DiskPerfRegistryPath.Buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                           RootExtension->DiskPerfRegistryPath.Buffer,
                           queryTable, &revertEntries, NULL);

    if (!revertEntries) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *RevertEntries = revertEntries;
    *NumberOfRevertEntries = n;

    return STATUS_SUCCESS;
}

NTSTATUS
FtpStoreGptAttributeRevertRecord(
    IN  PROOT_EXTENSION RootExtension,
    IN  ULONG           MbrSignature,
    IN  GUID*           GptPartitionGuid,
    IN  ULONGLONG       GptAttributes
    )

{
    NTSTATUS                        status;
    PFTP_GPT_ATTRIBUTE_REVERT_ENTRY p, q;
    ULONG                           n, i;

    status = FtpQueryRegistryRevertEntries(RootExtension, &p, &n);
    if (!NT_SUCCESS(status)) {
        p = NULL;
        n = 0;
    }

    for (i = 0; i < n; i++) {
        if (MbrSignature) {
            if (MbrSignature == p[i].MbrSignature) {
                break;
            }
        } else {
            if (IsEqualGUID(*GptPartitionGuid, p[i].PartitionUniqueId)) {
                break;
            }
        }
    }

    if (i == n) {
        q = (PFTP_GPT_ATTRIBUTE_REVERT_ENTRY)
            ExAllocatePool(PagedPool,
                           (n + 1)*sizeof(FTP_GPT_ATTRIBUTE_REVERT_ENTRY));
        if (!q) {
            if (p) {
                ExFreePool(p);
            }
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        if (n) {
            RtlCopyMemory(q, p, n*sizeof(FTP_GPT_ATTRIBUTE_REVERT_ENTRY));
        }
        if (p) {
            ExFreePool(p);
        }

        p = q;
        n++;
    }

    RtlZeroMemory(&p[i], sizeof(FTP_GPT_ATTRIBUTE_REVERT_ENTRY));
    if (GptPartitionGuid) {
        p[i].PartitionUniqueId = *GptPartitionGuid;
    }
    p[i].GptAttributes = GptAttributes;
    p[i].MbrSignature = MbrSignature;

    status = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                   RootExtension->DiskPerfRegistryPath.Buffer,
                                   REVERT_GPT_ATTRIBUTES_REGISTRY_NAME,
                                   REG_BINARY, p,
                                   n*sizeof(FTP_GPT_ATTRIBUTE_REVERT_ENTRY));

    ExFreePool(p);

    return status;
}

VOID
FtpDeleteGptAttributeRevertRecord(
    IN  PROOT_EXTENSION RootExtension,
    IN  ULONG           MbrSignature,
    IN  GUID*           GptPartitionGuid
    )

{
    NTSTATUS                        status;
    PFTP_GPT_ATTRIBUTE_REVERT_ENTRY p, q;
    ULONG                           n, i;

    status = FtpQueryRegistryRevertEntries(RootExtension, &p, &n);
    if (!NT_SUCCESS(status)) {
        return;
    }

    for (i = 0; i < n; i++) {
        if (MbrSignature) {
            if (MbrSignature == p[i].MbrSignature) {
                break;
            }
        } else {
            if (IsEqualGUID(*GptPartitionGuid, p[i].PartitionUniqueId)) {
                break;
            }
        }
    }

    if (i == n) {
        return;
    }

    if (i + 1 < n) {
        RtlMoveMemory(&p[i], &p[i + 1],
                      (n - i - 1)*sizeof(FTP_GPT_ATTRIBUTE_REVERT_ENTRY));
    }

    n--;

    if (n) {
        RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                              RootExtension->DiskPerfRegistryPath.Buffer,
                              REVERT_GPT_ATTRIBUTES_REGISTRY_NAME,
                              REG_BINARY, p,
                              n*sizeof(FTP_GPT_ATTRIBUTE_REVERT_ENTRY));
    } else {
        RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                               RootExtension->DiskPerfRegistryPath.Buffer,
                               REVERT_GPT_ATTRIBUTES_REGISTRY_NAME);
    }

    ExFreePool(p);

    return;
}

VOID
FtpApplyGptAttributes(
    IN  PVOLUME_EXTENSION   Extension,
    IN  ULONGLONG           GptAttributes
    )

{
    NTSTATUS    status;

    if (GptAttributes&GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY) {
        if (!Extension->IsReadOnly) {
            FtpZeroRefCallback(Extension, FtpVolumeReadOnlyCallback,
                               (PVOID) TRUE, TRUE);
        }
    } else {
        if (Extension->IsReadOnly) {
            FtpZeroRefCallback(Extension, FtpVolumeReadOnlyCallback,
                               (PVOID) FALSE, TRUE);
        }
    }

    if (GptAttributes&GPT_BASIC_DATA_ATTRIBUTE_HIDDEN) {
        if (!Extension->IsHidden) {
            Extension->IsHidden = TRUE;
            if (Extension->MountedDeviceInterfaceName.Buffer) {
                IoSetDeviceInterfaceState(
                        &Extension->MountedDeviceInterfaceName, FALSE);
            }
        }
    } else {
        if (Extension->IsHidden) {
            Extension->IsHidden = FALSE;

            if (!Extension->MountedDeviceInterfaceName.Buffer) {
                if (!Extension->IsStarted) {
                    return;
                }
                status = IoRegisterDeviceInterface(
                         Extension->DeviceObject,
                         &MOUNTDEV_MOUNTED_DEVICE_GUID, NULL,
                         &Extension->MountedDeviceInterfaceName);
                if (!NT_SUCCESS(status)) {
                    return;
                }
            }

            IoSetDeviceInterfaceState(
                    &Extension->MountedDeviceInterfaceName, TRUE);
        }
    }
}

VOID
FtpRevertGptAttributes(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    ULONG                           signature;
    PLIST_ENTRY                     l;
    PVOLUME_EXTENSION               extension;

    Extension->RevertOnCloseFileObject = NULL;

    if (!Extension->IsGpt) {

        diskInfo = Extension->Root->DiskInfoSet->FindLogicalDiskInformation(
                   Extension->WholeDiskPdo);
        if (diskInfo) {
            diskInfo->SetGptAttributes(Extension->GptAttributesToRevertTo);
        }

        signature = FtpQueryDiskSignature(Extension->WholeDiskPdo);
        if (signature) {
            FtpDeleteGptAttributeRevertRecord(Extension->Root, signature,
                                              NULL);
        }

        return;
    }

    l = &Extension->Root->VolumeList;
    extension = Extension;

    for (;;) {

        FtpSetGptAttributesOnDisk(extension->TargetObject,
                                  Extension->GptAttributesToRevertTo);

        FtpDeleteGptAttributeRevertRecord(Extension->Root, 0,
                                          &extension->UniqueIdGuid);

        if (!Extension->ApplyToAllConnectedVolumes) {
            break;
        }

        for (l = l->Flink; l != &Extension->Root->VolumeList; l = l->Flink) {

            extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
            if (extension == Extension ||
                extension->WholeDiskPdo != Extension->WholeDiskPdo) {

                continue;
            }
        }

        if (l == &Extension->Root->VolumeList) {
            break;
        }
    }
}

NTSTATUS
FtpSetGptAttributes(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine sets the given GPT attributes on the given volume.  If the
    'RevertOnClose' bit is set then the GPT attributes will go back to
    their original state when the handle that this IOCTL was sent using
    gets an IRP_MJ_CLEANUP.  In order for this driver to get the CLEANUP, the
    handle must not be opened with read or write access but just
    read_attributes.  If the 'RevertOnClose' bit is set then the effect of
    the bit changes will not be applied to this volume and every effort will
    be made so that if the system crashes, the bits will be properly reverted.

    If the 'RevertOnClose' bit is clear then the effect of the bit changes will
    be immediate.  If READ_ONLY is set, for example, the volume will instantly
    become read only and all writes will fail.  The caller should normally
    only issue READ_ONLY request after issueing an
    IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES and before issueing the corresponding
    IOCTL_VOLSNAP_RELEASE_WRITES.  If HIDDEN is set, then the volume will
    take itself out of the list of volumes used by the MOUNTMGR.  Similarly,
    if the HIDDEN bit is cleared then the volume will put itself back in
    the list of volumes used by the MOUNTMGR.

    If the 'ApplyToAllConnectedVolumes' bit is set then the GPT attributes
    will be set for all volumes that are joined by a disk relation.  In
    the basic disk case, this means all partitions on the disk.  In the
    dynamic disk case, this means all volumes in the group.  This IOCTL will
    fail on MBR basic disks unless this is set because MBR basic disks do
    not support the GPT attributes per partition but per disk.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLUME_SET_GPT_ATTRIBUTES_INFORMATION  input = (PVOLUME_SET_GPT_ATTRIBUTES_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
    NTSTATUS                                status;
    UCHAR                                   partitionType;
    PFT_LOGICAL_DISK_INFORMATION            diskInfo;
    ULONGLONG                               gptAttributes;
    ULONG                                   signature;
    PLIST_ENTRY                             l;
    PVOLUME_EXTENSION                       extension;
    GUID                                    partitionTypeGuid;

    status = FtpCheckSecurity(Extension, Irp);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLUME_SET_GPT_ATTRIBUTES_INFORMATION)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (input->Reserved1 || input->Reserved2 || !Extension->TargetObject) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!Extension->IsGpt) {
        if (!input->ApplyToAllConnectedVolumes) {
            return STATUS_INVALID_PARAMETER;
        }

        status = FtpQueryPartitionInformation(Extension->Root,
                                              Extension->TargetObject,
                                              NULL, NULL, NULL, &partitionType,
                                              NULL, NULL, NULL, NULL, NULL);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (!IsRecognizedPartition(partitionType)) {
            return STATUS_INVALID_PARAMETER;
        }

        diskInfo = Extension->Root->DiskInfoSet->
                   FindLogicalDiskInformation(Extension->WholeDiskPdo);
        if (!diskInfo) {
            return STATUS_INVALID_PARAMETER;
        }

        if (input->RevertOnClose) {
            gptAttributes = diskInfo->GetGptAttributes();
            Extension->GptAttributesToRevertTo = gptAttributes;
            Extension->RevertOnCloseFileObject = irpSp->FileObject;
            Extension->ApplyToAllConnectedVolumes =
                    input->ApplyToAllConnectedVolumes;
            signature = FtpQueryDiskSignature(Extension->WholeDiskPdo);
            if (!signature) {
                Extension->RevertOnCloseFileObject = NULL;
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            status = FtpStoreGptAttributeRevertRecord(Extension->Root,
                                                      signature, NULL,
                                                      gptAttributes);
            if (!NT_SUCCESS(status)) {
                Extension->RevertOnCloseFileObject = NULL;
                return status;
            }
        }

        status = diskInfo->SetGptAttributes(input->GptAttributes);
        if (!NT_SUCCESS(status)) {
            if (input->RevertOnClose) {
                Extension->RevertOnCloseFileObject = NULL;
                FtpDeleteGptAttributeRevertRecord(Extension->Root, signature,
                                                  NULL);
            }
            return status;
        }

        if (!input->RevertOnClose) {

            FtpApplyGptAttributes(Extension, input->GptAttributes);
            Extension->MbrGptAttributes = input->GptAttributes;

            for (l = Extension->Root->VolumeList.Flink;
                 l != &Extension->Root->VolumeList; l = l->Flink) {

                extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
                if (extension == Extension ||
                    extension->WholeDiskPdo != Extension->WholeDiskPdo) {

                    continue;
                }

                status = FtpQueryPartitionInformation(extension->Root,
                                                      extension->TargetObject,
                                                      NULL, NULL, NULL,
                                                      &partitionType, NULL,
                                                      NULL, NULL, NULL, NULL);
                if (!NT_SUCCESS(status) ||
                    !IsRecognizedPartition(partitionType)) {

                    continue;
                }

                FtpApplyGptAttributes(extension, input->GptAttributes);
                extension->MbrGptAttributes = input->GptAttributes;
            }
        }

        return STATUS_SUCCESS;
    }

    l = &Extension->Root->VolumeList;
    extension = Extension;

    for (;;) {

        status = FtpQueryPartitionInformation(Extension->Root,
                                              extension->TargetObject,
                                              NULL, NULL, NULL, NULL, NULL,
                                              &partitionTypeGuid, NULL,
                                              NULL, &gptAttributes);
        if (!NT_SUCCESS(status)) {
            return status;
        }
        if (!IsEqualGUID(partitionTypeGuid, PARTITION_BASIC_DATA_GUID)) {
            if (extension == Extension) {
                return STATUS_INVALID_PARAMETER;
            }
            goto NextVolume;
        }

        if (input->RevertOnClose) {

            if (extension == Extension) {
                Extension->RevertOnCloseFileObject = irpSp->FileObject;
                Extension->GptAttributesToRevertTo = gptAttributes;
                Extension->ApplyToAllConnectedVolumes =
                        input->ApplyToAllConnectedVolumes;
            }

            status = FtpStoreGptAttributeRevertRecord(
                        Extension->Root, 0, &extension->UniqueIdGuid,
                        gptAttributes);
            if (!NT_SUCCESS(status)) {
                if (input->RevertOnClose) {
                    FtpRevertGptAttributes(Extension);
                }
                return status;
            }
        }

        status = FtpSetGptAttributesOnDisk(extension->TargetObject,
                                           input->GptAttributes);
        if (!NT_SUCCESS(status)) {
            if (input->RevertOnClose) {
                FtpRevertGptAttributes(Extension);
            }
            return status;
        }

        if (!input->RevertOnClose) {
            FtpApplyGptAttributes(extension, input->GptAttributes);
        }

NextVolume:
        if (!input->ApplyToAllConnectedVolumes) {
            break;
        }

        for (l = l->Flink; l != &Extension->Root->VolumeList; l = l->Flink) {

            extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
            if (extension == Extension ||
                extension->WholeDiskPdo != Extension->WholeDiskPdo) {

                continue;
            }
        }

        if (l == &Extension->Root->VolumeList) {
            break;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FtpGetGptAttributes(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the current GPT attributes definitions for the volume.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLUME_GET_GPT_ATTRIBUTES_INFORMATION  output = (PVOLUME_GET_GPT_ATTRIBUTES_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
    NTSTATUS                                status;
    UCHAR                                   partitionType;
    GUID                                    gptPartitionType;
    ULONGLONG                               gptAttributes;
    PFT_LOGICAL_DISK_INFORMATION            diskInfo;

    Irp->IoStatus.Information = sizeof(VOLUME_GET_GPT_ATTRIBUTES_INFORMATION);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }


    if (!Extension->TargetObject) {
        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    status = FtpQueryPartitionInformation(Extension->Root,
                                          Extension->TargetObject, NULL, NULL,
                                          NULL, &partitionType, NULL,
                                          &gptPartitionType, NULL, NULL,
                                          &gptAttributes);
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Information = 0;
        return status;
    }

    if (Extension->IsGpt) {
        if (!IsEqualGUID(gptPartitionType, PARTITION_BASIC_DATA_GUID)) {
            Irp->IoStatus.Information = 0;
            return STATUS_INVALID_PARAMETER;
        }
        output->GptAttributes = gptAttributes;
        return STATUS_SUCCESS;
    }

    if (!IsRecognizedPartition(partitionType)) {
        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    diskInfo = Extension->Root->DiskInfoSet->
               FindLogicalDiskInformation(Extension->WholeDiskPdo);
    if (!diskInfo) {
        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    gptAttributes = diskInfo->GetGptAttributes();
    output->GptAttributes = gptAttributes;

    return STATUS_SUCCESS;
}

NTSTATUS
FtpQueryHiddenVolumes(
    IN  PROOT_EXTENSION RootExtension,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine returns a list of hidden volumes.  Hidden volumes are those
    that do not give PNP VolumeClassGuid notification.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

-*/

{
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLMGR_HIDDEN_VOLUMES  output;
    PLIST_ENTRY             l;
    PVOLUME_EXTENSION       extension;
    WCHAR                   buffer[100];
    UNICODE_STRING          name;
    PWCHAR                  buf;

    Irp->IoStatus.Information = FIELD_OFFSET(VOLMGR_HIDDEN_VOLUMES, MultiSz);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    output = (PVOLMGR_HIDDEN_VOLUMES) Irp->AssociatedIrp.SystemBuffer;

    output->MultiSzLength = sizeof(WCHAR);

    for (l = RootExtension->VolumeList.Flink; l != &RootExtension->VolumeList;
         l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        if (!extension->IsHidden || !extension->IsInstalled) {
            continue;
        }

        swprintf(buffer, L"\\Device\\HarddiskVolume%d",
                 extension->VolumeNumber);
        RtlInitUnicodeString(&name, buffer);

        output->MultiSzLength += name.Length + sizeof(WCHAR);
    }

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information + output->MultiSzLength) {

        return STATUS_BUFFER_OVERFLOW;
    }

    Irp->IoStatus.Information += output->MultiSzLength;
    buf = output->MultiSz;

    for (l = RootExtension->VolumeList.Flink; l != &RootExtension->VolumeList;
         l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        if (!extension->IsHidden || !extension->IsInstalled) {
            continue;
        }

        swprintf(buf, L"\\Device\\HarddiskVolume%d", extension->VolumeNumber);
        RtlInitUnicodeString(&name, buf);

        buf += name.Length/sizeof(WCHAR) + 1;
    }

    *buf = 0;

    return STATUS_SUCCESS;
}

NTSTATUS
FtDiskDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_DEVICE_CONTROL.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION                       extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;
    PROOT_EXTENSION                         rootExtension = extension->Root;
    PIO_STACK_LOCATION                      irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                                status;
    PFT_VOLUME                              vol;
    PDISPATCH_TP                            packet;
    PVERIFY_INFORMATION                     verifyInfo;
    PSET_PARTITION_INFORMATION              setPartitionInfo;
    PSET_PARTITION_INFORMATION_EX           setPartitionInfoEx;
    PDEVICE_OBJECT                          targetObject;
    KEVENT                                  event;
    PPARTITION_INFORMATION                  partInfo;
    PPARTITION_INFORMATION_EX               partInfoEx;
    PDISK_GEOMETRY                          diskGeometry;
    PFT_LOGICAL_DISK_INFORMATION_SET        diskInfoSet;
    PFT_SET_INFORMATION                     setInfo;
    FT_LOGICAL_DISK_ID                      diskId;
    PFT_MIRROR_AND_SWP_STATE_INFORMATION    stateInfo;
    PFT_SPECIAL_READ                        specialRead;
    PFT_QUERY_LOGICAL_DISK_ID_OUTPUT        queryLogicalDiskIdOutput;
    PGET_LENGTH_INFORMATION                 lengthInfo;
    ULONG                                   cylinderSize;

    Irp->IoStatus.Information = 0;

    if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {

        FtpAcquire(rootExtension);

        switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

            case FT_CONFIGURE:
                status = STATUS_INVALID_PARAMETER;
                break;

            case FT_CREATE_LOGICAL_DISK:
                status = FtpCreateLogicalDisk(rootExtension, Irp);
                break;

            case FT_BREAK_LOGICAL_DISK:
                status = FtpBreakLogicalDisk(rootExtension, Irp);
                break;

            case FT_ENUMERATE_LOGICAL_DISKS:
                status = FtpEnumerateLogicalDisks(rootExtension, Irp);
                break;

            case FT_QUERY_LOGICAL_DISK_INFORMATION:
                status = FtpQueryLogicalDiskInformation(rootExtension, Irp);
                break;

            case FT_ORPHAN_LOGICAL_DISK_MEMBER:
                status = FtpOrphanLogicalDiskMember(rootExtension, Irp);
                break;

            case FT_REPLACE_LOGICAL_DISK_MEMBER:
                status = FtpReplaceLogicalDiskMember(rootExtension, Irp);
                break;

            case FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK:
                status = FtpQueryNtDeviceNameForLogicalDisk(rootExtension, Irp);
                break;

            case FT_INITIALIZE_LOGICAL_DISK:
                status = FtpInitializeLogicalDisk(rootExtension, Irp);
                break;

            case FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK:
                status = FtpQueryDriveLetterForLogicalDisk(rootExtension, Irp);
                break;

            case FT_CHECK_IO:
                status = FtpCheckIo(rootExtension, Irp);
                break;

            case FT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK:
                status = FtpSetDriveLetterForLogicalDisk(rootExtension, Irp);
                break;

            case FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION:
                status = FtpQueryNtDeviceNameForPartition(rootExtension, Irp);
                break;

            case FT_CHANGE_NOTIFY:
                status = FtpChangeNotify(rootExtension, Irp);
                break;

            case FT_STOP_SYNC_OPERATIONS:
                status = FtpStopSyncOperations(rootExtension, Irp);
                break;

            case IOCTL_VOLMGR_QUERY_HIDDEN_VOLUMES:
                status = FtpQueryHiddenVolumes(rootExtension, Irp);
                break;

            default:
                status = STATUS_INVALID_PARAMETER;
                break;

        }

        FtpRelease(rootExtension);

        if (status != STATUS_PENDING) {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }

        return status;
    }

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                status = FtpQueryUniqueId(extension, Irp);
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_MOUNTDEV_QUERY_STABLE_GUID:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                status = FtpQueryStableGuid(extension, Irp);
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY:
            FtpAcquire(extension->Root);
            status = FtpUniqueIdChangeNotify(extension, Irp);
            FtpRelease(extension->Root);
            if (status != STATUS_PENDING) {
                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            return status;

        case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME:
            status = FtpAllSystemsGo(extension, Irp, FALSE, FALSE, FALSE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                status = FtpQueryDeviceName(extension, Irp);
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME:
            FtpAcquire(extension->Root);
            status = FtpQuerySuggestedLinkName(extension, Irp);
            FtpRelease(extension->Root);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_MOUNTDEV_LINK_CREATED:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, TRUE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                status = FtpLinkCreated(extension, Irp);
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_MOUNTDEV_LINK_DELETED:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, TRUE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                status = FtpLinkDeleted(extension, Irp);
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS:
        case IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS_ADMIN:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                status = FtpGetVolumeDiskExtents(extension, Irp);
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE:
            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_SUCCESS;

        case IOCTL_VOLUME_ONLINE:
            FtpAcquire(extension->Root);

            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
            if (status == STATUS_PENDING) {
                FtpRelease(extension->Root);
                return status;
            }
            if (!NT_SUCCESS(status)) {
                FtpRelease(extension->Root);
                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return status;
            }

            if (extension->FtVolume) {
                FtpPropogateRegistryState(extension, extension->FtVolume);
            }

            KeInitializeEvent(&event, NotificationEvent, FALSE);
            FtpZeroRefCallback(extension, FtpVolumeOnlineCallback, &event,
                               TRUE);
            FtpDecrementRefCount(extension);
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

            FtpRelease(extension->Root);

            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_SUCCESS;

        case IOCTL_VOLUME_OFFLINE:
            FtpAcquire(extension->Root);

            KeInitializeEvent(&event, NotificationEvent, FALSE);
            FtpZeroRefCallback(extension, FtpVolumeOfflineCallback, &event,
                               TRUE);
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

            FtpRelease(extension->Root);

            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_SUCCESS;

        case IOCTL_VOLUME_IS_OFFLINE:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                if (!extension->IsOffline) {
                    status = STATUS_UNSUCCESSFUL;
                }
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_VOLUME_IS_IO_CAPABLE:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                if (!extension->TargetObject &&
                    !extension->FtVolume->IsComplete(TRUE)) {

                    status = STATUS_UNSUCCESSFUL;
                }
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_VOLUME_QUERY_FAILOVER_SET:
            FtpAcquire(extension->Root);
            status = FtpQueryFailoverSet(extension, Irp);
            FtpRelease(extension->Root);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_VOLUME_QUERY_VOLUME_NUMBER:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                status = FtpQueryVolumeNumber(extension, Irp);
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_VOLUME_LOGICAL_TO_PHYSICAL:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                status = FtpLogicalToPhysical(extension, Irp);
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_VOLUME_PHYSICAL_TO_LOGICAL:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                status = FtpPhysicalToLogical(extension, Irp);
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_VOLUME_IS_PARTITION:
            status = FtpAllSystemsGo(extension, Irp, TRUE, TRUE, TRUE);
            if (status == STATUS_PENDING) {
                return status;
            }
            if (NT_SUCCESS(status)) {
                status = FtpIsPartition(extension, Irp);
                FtpDecrementRefCount(extension);
            }
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_VOLUME_SET_GPT_ATTRIBUTES:
            FtpAcquire(extension->Root);
            status = FtpSetGptAttributes(extension, Irp);
            FtpRelease(extension->Root);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_VOLUME_GET_GPT_ATTRIBUTES:
            FtpAcquire(extension->Root);
            status = FtpGetGptAttributes(extension, Irp);
            FtpRelease(extension->Root);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_PARTMGR_EJECT_VOLUME_MANAGERS:
            status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_DISK_GET_PARTITION_INFO:
        case IOCTL_DISK_GET_PARTITION_INFO_EX:
            status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, FALSE);
            break;

        case IOCTL_DISK_IS_WRITABLE:
            if (extension->IsReadOnly) {
                status = STATUS_MEDIA_WRITE_PROTECTED;
            } else {
                status = FtpAllSystemsGo(extension, Irp, TRUE, TRUE, TRUE);
            }
            break;

        case IOCTL_DISK_PERFORMANCE:
            //
            // Verify user buffer is large enough for the performance data.
            //

            status = STATUS_SUCCESS;
            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(DISK_PERFORMANCE)) {

                //
                // Indicate unsuccessful status and no data transferred.
                //

                status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Information = 0;
            }
            else if (!(extension->CountersEnabled)) {
                if (!FtQueryEnableAlways(DeviceObject)) {
                    status = STATUS_UNSUCCESSFUL;
                    Irp->IoStatus.Information = 0;
                }
            }
            if (status == STATUS_SUCCESS) {
                extension->Root->PmWmiCounterLibContext.
                PmWmiCounterQuery(extension->PmWmiCounterContext,
                                  (PDISK_PERFORMANCE) Irp->AssociatedIrp.SystemBuffer,
                                  L"FTDISK  ",
                                  extension->VolumeNumber);
                Irp->IoStatus.Information = sizeof(DISK_PERFORMANCE);
            }

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        case IOCTL_DISK_PERFORMANCE_OFF:
            //
            // Turns off counting
            //
            if (extension->CountersEnabled) {
                if (InterlockedCompareExchange(&extension->EnableAlways, 0, 1) == 1) {
                    if (!(extension->Root->PmWmiCounterLibContext.
                          PmWmiCounterDisable(&extension->PmWmiCounterContext, FALSE, FALSE))) {
                        extension->CountersEnabled = FALSE;
                    }
                }
            }
            Irp->IoStatus.Information = 0;
            status = STATUS_SUCCESS;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        default:
            status = FtpAllSystemsGo(extension, Irp, TRUE, TRUE, TRUE);
            break;

    }

    if (status == STATUS_PENDING) {
        return status;
    }
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if (extension->TargetObject) {
        if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
            FT_CREATE_PARTITION_LOGICAL_DISK) {

            FtpDecrementRefCount(extension);

            Irp->IoStatus.Information = 0;

            FtpAcquire(extension->Root);

            if (!extension->Root->FtCodeLocked) {
                MmLockPagableCodeSection(FtpComputeParity);
                status = FtpStartSystemThread(extension->Root);
                if (!NT_SUCCESS(status)) {
                    FtpRelease(extension->Root);
                    Irp->IoStatus.Status = status;
                    IoCompleteRequest(Irp, IO_NO_INCREMENT);
                    return status;
                }
                extension->Root->FtCodeLocked = TRUE;
            }
            status = FtpCreatePartitionLogicalDisk(extension, Irp);

            FtpRelease(extension->Root);

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;
        }

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, FtpRefCountCompletionRoutine,
                               extension, TRUE, TRUE, TRUE);
        IoMarkIrpPending(Irp);

        IoCallDriver(extension->TargetObject, Irp);

        return STATUS_PENDING;
    }

    vol = extension->FtVolume;
    ASSERT(vol);

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_DISK_GET_DRIVE_LAYOUT:
        case IOCTL_DISK_GET_DRIVE_LAYOUT_EX:
        case IOCTL_SCSI_GET_ADDRESS:
        case IOCTL_SCSI_GET_DUMP_POINTERS:
        case IOCTL_SCSI_FREE_DUMP_POINTERS:
            if (FtpIsReplicatedPartition(vol)) {
                targetObject = vol->GetLeftmostPartitionObject();
                ASSERT(targetObject);

                KeInitializeEvent(&event, NotificationEvent, FALSE);
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp, FtpSignalCompletion, &event, TRUE,
                                       TRUE, TRUE);
                IoCallDriver(targetObject, Irp);
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                      NULL);

                status = Irp->IoStatus.Status;

            } else {
                status = STATUS_INVALID_DEVICE_REQUEST;
            }
            break;

        case IOCTL_DISK_VERIFY:

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(VERIFY_INFORMATION)) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            packet = new DISPATCH_TP;
            if (!packet) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            verifyInfo = (PVERIFY_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

            if (verifyInfo->StartingOffset.QuadPart < 0) {
                delete packet;
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            packet->Mdl = NULL;
            packet->Offset = verifyInfo->StartingOffset.QuadPart;
            packet->Length = verifyInfo->Length;
            packet->CompletionRoutine = FtpReadWriteCompletionRoutine;
            packet->TargetVolume = vol;
            packet->Thread = Irp->Tail.Overlay.Thread;
            packet->IrpFlags = irpSp->Flags;
            packet->ReadPacket = TRUE;
            packet->Irp = Irp;
            packet->Extension = extension;

            IoMarkIrpPending(Irp);

            TRANSFER(packet);

            return STATUS_PENDING;

        case IOCTL_DISK_SET_PARTITION_INFO:

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SET_PARTITION_INFORMATION)) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            setPartitionInfo = (PSET_PARTITION_INFORMATION)
                               Irp->AssociatedIrp.SystemBuffer;

            status = vol->SetPartitionType(setPartitionInfo->PartitionType);
            break;

        case IOCTL_DISK_SET_PARTITION_INFO_EX:

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SET_PARTITION_INFORMATION_EX)) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            setPartitionInfoEx = (PSET_PARTITION_INFORMATION_EX)
                                 Irp->AssociatedIrp.SystemBuffer;
            if (setPartitionInfoEx->PartitionStyle != PARTITION_STYLE_MBR) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            status = vol->SetPartitionType(
                     setPartitionInfoEx->Mbr.PartitionType);
            break;

        case IOCTL_DISK_GET_PARTITION_INFO_EX:

            if (extension->IsGpt) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Fall through.
            //

        case IOCTL_DISK_GET_PARTITION_INFO:

            targetObject = vol->GetLeftmostPartitionObject();
            if (!targetObject) {
                status = STATUS_NO_SUCH_DEVICE;
                break;
            }

            KeInitializeEvent(&event, NotificationEvent, FALSE);
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp, FtpSignalCompletion, &event, TRUE,
                                   TRUE, TRUE);
            IoCallDriver(targetObject, Irp);
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

            status = Irp->IoStatus.Status;
            if (!NT_SUCCESS(status)) {
                break;
            }

            if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_DISK_GET_PARTITION_INFO) {

                partInfo = (PPARTITION_INFORMATION)
                           Irp->AssociatedIrp.SystemBuffer;
                partInfo->PartitionLength.QuadPart = vol->QueryVolumeSize();
                break;
            }

            partInfoEx = (PPARTITION_INFORMATION_EX)
                         Irp->AssociatedIrp.SystemBuffer;
            if (partInfoEx->PartitionStyle != PARTITION_STYLE_MBR) {
                ASSERT(FALSE);
                status = STATUS_INVALID_PARAMETER;
                break;
            }
            partInfoEx->PartitionLength.QuadPart = vol->QueryVolumeSize();
            break;

        case IOCTL_DISK_GET_LENGTH_INFO:

            Irp->IoStatus.Information = sizeof(GET_LENGTH_INFORMATION);

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                Irp->IoStatus.Information) {

                Irp->IoStatus.Information = 0;
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            lengthInfo = (PGET_LENGTH_INFORMATION)
                         Irp->AssociatedIrp.SystemBuffer;

            lengthInfo->Length.QuadPart = vol->QueryVolumeSize();
            status = STATUS_SUCCESS;
            break;

        case IOCTL_DISK_GET_DRIVE_GEOMETRY:

            targetObject = vol->GetLeftmostPartitionObject();
            if (!targetObject) {
                status = STATUS_NO_SUCH_DEVICE;
                break;
            }

            KeInitializeEvent(&event, NotificationEvent, FALSE);
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp, FtpSignalCompletion, &event, TRUE,
                                   TRUE, TRUE);
            IoCallDriver(targetObject, Irp);
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

            status = Irp->IoStatus.Status;
            if (!NT_SUCCESS(status)) {
                break;
            }

            diskGeometry = (PDISK_GEOMETRY) Irp->AssociatedIrp.SystemBuffer;
            diskGeometry->BytesPerSector = vol->QuerySectorSize();
            cylinderSize = diskGeometry->TracksPerCylinder*
                           diskGeometry->SectorsPerTrack*
                           diskGeometry->BytesPerSector;
            if (cylinderSize) {
                diskGeometry->Cylinders.QuadPart =
                        vol->QueryVolumeSize()/cylinderSize;
            }
            break;

        case IOCTL_DISK_CHECK_VERIFY:
            status = STATUS_SUCCESS;
            break;

        case FT_QUERY_SET_STATE:

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(FT_SET_INFORMATION)) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            FtpAcquire(rootExtension);
            diskInfoSet = rootExtension->DiskInfoSet;
            setInfo = (PFT_SET_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
            diskId = vol->QueryLogicalDiskId();
            setInfo->NumberOfMembers =
                    diskInfoSet->QueryNumberOfMembersInLogicalDisk(diskId);
            switch (diskInfoSet->QueryLogicalDiskType(diskId)) {
                case FtVolumeSet:
                    setInfo->Type = VolumeSet;
                    break;

                case FtStripeSet:
                    setInfo->Type = Stripe;
                    break;

                case FtMirrorSet:
                    setInfo->Type = Mirror;
                    break;

                case FtStripeSetWithParity:
                    setInfo->Type = StripeWithParity;
                    break;

                default:
                    setInfo->Type = NotAnFtMember;
                    break;

            }

            stateInfo = (PFT_MIRROR_AND_SWP_STATE_INFORMATION)
                        diskInfoSet->GetStateInformation(diskId);
            if (stateInfo) {
                if (stateInfo->IsInitializing) {
                    setInfo->SetState = FtInitializing;
                } else {
                    switch (stateInfo->UnhealthyMemberState) {
                        case FtMemberHealthy:
                            setInfo->SetState = FtStateOk;
                            break;

                        case FtMemberRegenerating:
                            setInfo->SetState = FtRegenerating;
                            break;

                        case FtMemberOrphaned:
                            setInfo->SetState = FtHasOrphan;
                            break;

                    }
                }
            } else {
                setInfo->SetState = FtStateOk;
            }
            FtpRelease(rootExtension);

            Irp->IoStatus.Information = sizeof(FT_SET_INFORMATION);
            status = STATUS_SUCCESS;
            break;

        case FT_SECONDARY_READ:
        case FT_PRIMARY_READ:

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(FT_SPECIAL_READ)) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            specialRead = (PFT_SPECIAL_READ) Irp->AssociatedIrp.SystemBuffer;
            if (specialRead->ByteOffset.QuadPart <= 0) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            if (specialRead->Length >
                irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            packet = new DISPATCH_TP;
            if (!packet) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            packet->Mdl = Irp->MdlAddress;
            packet->Offset = specialRead->ByteOffset.QuadPart;
            packet->Length = specialRead->Length;
            packet->CompletionRoutine = FtpReadWriteCompletionRoutine;
            packet->TargetVolume = vol;
            packet->Thread = Irp->Tail.Overlay.Thread;
            packet->IrpFlags = irpSp->Flags;
            packet->ReadPacket = TRUE;
            if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                FT_SECONDARY_READ) {

                packet->SpecialRead = TP_SPECIAL_READ_SECONDARY;
            } else {
                packet->SpecialRead = TP_SPECIAL_READ_PRIMARY;
            }
            packet->Irp = Irp;
            packet->Extension = extension;

            IoMarkIrpPending(Irp);

            TRANSFER(packet);

            return STATUS_PENDING;

        case FT_BALANCED_READ_MODE:
        case FT_SEQUENTIAL_WRITE_MODE:
        case FT_PARALLEL_WRITE_MODE:

            status = STATUS_SUCCESS;
            break;

        case FT_QUERY_LOGICAL_DISK_ID:

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(FT_QUERY_LOGICAL_DISK_ID_OUTPUT)) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            queryLogicalDiskIdOutput = (PFT_QUERY_LOGICAL_DISK_ID_OUTPUT)
                                       Irp->AssociatedIrp.SystemBuffer;

            queryLogicalDiskIdOutput->RootLogicalDiskId =
                    vol->QueryLogicalDiskId();

            Irp->IoStatus.Information = sizeof(FT_QUERY_LOGICAL_DISK_ID_OUTPUT);
            status = STATUS_SUCCESS;
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

    }

    FtpDecrementRefCount(extension);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
FtpCreatePartitionLogicalDiskHelper(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN      LONGLONG            PartitionSize,
    OUT     PFT_LOGICAL_DISK_ID NewLogicalDiskId
    )

{
    PMOUNTDEV_UNIQUE_ID                 newUniqueId;
    UCHAR                               newUniqueIdBuffer[UNIQUE_ID_MAX_BUFFER_SIZE];
    NTSTATUS                            status;
    ULONG                               diskNumber;
    LONGLONG                            offset;
    PFT_LOGICAL_DISK_INFORMATION_SET    diskInfoSet;
    FT_LOGICAL_DISK_ID                  diskId;
    PPARTITION                          partition;
    UCHAR                               type;
    SET_TARGET_CONTEXT                  context;

    if (Extension->IsGpt) {
        return STATUS_INVALID_PARAMETER;
    }

    newUniqueId = (PMOUNTDEV_UNIQUE_ID) newUniqueIdBuffer;

    status = FtpQueryPartitionInformation(Extension->Root,
                                          Extension->TargetObject, &diskNumber,
                                          &offset, NULL, NULL, NULL, NULL,
                                          NULL, NULL, NULL);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    diskInfoSet = Extension->Root->DiskInfoSet;
    status = diskInfoSet->CreatePartitionLogicalDisk(diskNumber, offset,
                                                     PartitionSize, &diskId);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    partition = new PARTITION;
    if (!partition) {
        diskInfoSet->BreakLogicalDisk(diskId);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    status = partition->Initialize(Extension->Root, diskId,
                                   Extension->TargetObject,
                                   Extension->WholeDiskPdo);
    if (!NT_SUCCESS(status)) {
        if (!InterlockedDecrement(&partition->_refCount)) {
            delete partition;
        }
        diskInfoSet->BreakLogicalDisk(diskId);
        return status;
    }

    type = partition->QueryPartitionType();
    if (!type) {
        if (!InterlockedDecrement(&partition->_refCount)) {
            delete partition;
        }
        diskInfoSet->BreakLogicalDisk(diskId);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = partition->SetPartitionType(type);
    if (!NT_SUCCESS(status)) {
        if (!InterlockedDecrement(&partition->_refCount)) {
            delete partition;
        }
        diskInfoSet->BreakLogicalDisk(diskId);
        return status;
    }

    KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
    context.TargetObject = NULL;
    context.FtVolume = partition;
    context.WholeDiskPdo = NULL;
    FtpZeroRefCallback(Extension, FtpSetTargetCallback, &context, TRUE);
    KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE,
                          NULL);

    FtpQueryUniqueIdBuffer(Extension, newUniqueId->UniqueId,
                           &newUniqueId->UniqueIdLength);
    FtpUniqueIdNotify(Extension, newUniqueId);

    *NewLogicalDiskId = diskId;

    FtpNotify(Extension->Root, Extension);

    return status;
}

NTSTATUS
FtpInsertMirror(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      PFT_LOGICAL_DISK_ID ArrayOfMembers,
    OUT     PFT_LOGICAL_DISK_ID NewLogicalDiskId
    )

{
    PFT_LOGICAL_DISK_INFORMATION_SET        diskInfoSet;
    ULONG                                   i;
    NTSTATUS                                status;
    PVOLUME_EXTENSION                       extension, shadowExtension;
    PFT_VOLUME                              topVol, vol, shadowVol, parentVol;
    FT_LOGICAL_DISK_ID                      fakeDiskId, mirrorDiskId, parentDiskId;
    FT_LOGICAL_DISK_ID                      mirrorMembers[2];
    FT_MIRROR_SET_CONFIGURATION_INFORMATION config;
    FT_MIRROR_AND_SWP_STATE_INFORMATION     state;
    USHORT                                  n, j;
    PMIRROR                                 mirror;
    PFT_VOLUME*                             arrayOfVolumes;
    KEVENT                                  event;
    INSERT_MEMBER_CONTEXT                   context;
    UCHAR                                   newUniqueIdBuffer[UNIQUE_ID_MAX_BUFFER_SIZE];
    PMOUNTDEV_UNIQUE_ID                     newUniqueId;
    PFT_LOGICAL_DISK_DESCRIPTION            p;
    WCHAR                                   deviceNameBuffer[64];
    UNICODE_STRING                          deviceName;
    SET_TARGET_CONTEXT                      setContext;

    diskInfoSet = RootExtension->DiskInfoSet;
    for (i = 0; i < 100; i++) {
        status = diskInfoSet->CreatePartitionLogicalDisk(i, 0, 0, &fakeDiskId);
        if (NT_SUCCESS(status)) {
            break;
        }
    }

    if (i == 100) {
        return status;
    }

    extension = FtpFindExtensionCoveringDiskId(RootExtension,
                                               ArrayOfMembers[0]);
    ASSERT(extension);

    topVol = extension->FtVolume;
    vol = topVol->GetContainedLogicalDisk(ArrayOfMembers[0]);

    shadowExtension = FtpFindExtension(RootExtension, ArrayOfMembers[1]);
    ASSERT(shadowExtension);
    shadowVol = shadowExtension->FtVolume;

    if (shadowVol->QueryVolumeSize() < vol->QueryVolumeSize()) {
        return STATUS_INVALID_PARAMETER;
    }

    mirrorMembers[0] = fakeDiskId;
    mirrorMembers[1] = ArrayOfMembers[1];
    config.MemberSize = vol->QueryVolumeSize();
    state.IsInitializing = FALSE;
    state.IsDirty = TRUE;
    state.UnhealthyMemberNumber = 1;
    state.UnhealthyMemberState = FtMemberRegenerating;

    status = diskInfoSet->AddNewLogicalDisk(FtMirrorSet, 2, mirrorMembers,
                                            sizeof(config), &config,
                                            sizeof(state), &state,
                                            &mirrorDiskId);
    if (!NT_SUCCESS(status)) {
        diskInfoSet->BreakLogicalDisk(fakeDiskId);
        return status;
    }

    parentVol = topVol->GetParentLogicalDisk(vol);
    if (!parentVol) {
        diskInfoSet->BreakLogicalDisk(mirrorDiskId);
        diskInfoSet->BreakLogicalDisk(fakeDiskId);
        return STATUS_INVALID_PARAMETER;
    }

    n = parentVol->QueryNumberOfMembers();
    for (j = 0; j < n; j++) {
        if (parentVol->GetMember(j) == vol) {
            break;
        }
    }

    status = diskInfoSet->ReplaceLogicalDiskMember(
             parentVol->QueryLogicalDiskId(), j, mirrorDiskId, &parentDiskId);
    if (!NT_SUCCESS(status)) {
        diskInfoSet->BreakLogicalDisk(mirrorDiskId);
        diskInfoSet->BreakLogicalDisk(fakeDiskId);
        return status;
    }

    status = diskInfoSet->ReplaceLogicalDiskMember(
             mirrorDiskId, 0, ArrayOfMembers[0], &mirrorDiskId);
    if (!NT_SUCCESS(status)) {
        diskInfoSet->ReplaceLogicalDiskMember(
                 parentDiskId, j, ArrayOfMembers[0], &parentDiskId);
        diskInfoSet->BreakLogicalDisk(mirrorDiskId);
        diskInfoSet->BreakLogicalDisk(fakeDiskId);
        return status;
    }

    *NewLogicalDiskId = mirrorDiskId;
    diskInfoSet->BreakLogicalDisk(fakeDiskId);

    arrayOfVolumes = (PFT_VOLUME*) ExAllocatePool(NonPagedPool, 2*sizeof(PFT_VOLUME));
    if (!arrayOfVolumes) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    mirror = new MIRROR;
    if (!mirror) {
        ExFreePool(arrayOfVolumes);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    arrayOfVolumes[0] = vol;
    arrayOfVolumes[1] = shadowVol;

    status = mirror->Initialize(RootExtension, mirrorDiskId, arrayOfVolumes, 2,
                                &config, &state);
    if (!NT_SUCCESS(status)) {
        if (!InterlockedDecrement(&mirror->_refCount)) {
            delete mirror;
        }
        return status;
    }

    KeInitializeEvent(&setContext.Event, NotificationEvent, FALSE);
    setContext.TargetObject = NULL;
    setContext.FtVolume = NULL;
    setContext.WholeDiskPdo = NULL;
    FtpZeroRefCallback(shadowExtension, FtpSetTargetCallback, &setContext,
                       TRUE);
    KeWaitForSingleObject(&setContext.Event, Executive, KernelMode, FALSE,
                          NULL);

    RemoveEntryList(&shadowExtension->ListEntry);
    InsertTailList(&RootExtension->DeadVolumeList,
                   &shadowExtension->ListEntry);
    FtpDeleteMountPoints(shadowExtension);
    FtpCleanupVolumeExtension(shadowExtension);

    KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
    context.Parent = parentVol;
    context.MemberNumber = j;
    context.Member = mirror;
    FtpZeroRefCallback(extension, FtpInsertMemberCallback, &context, TRUE);
    KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE, NULL);

    parentVol = mirror;
    while (p = diskInfoSet->GetParentLogicalDiskDescription(
           parentVol->QueryLogicalDiskId())) {

        if (parentVol = topVol->GetParentLogicalDisk(parentVol)) {
            parentVol->SetLogicalDiskId(p->LogicalDiskId);
        }
    }

    swprintf(deviceNameBuffer, L"\\Device\\HarddiskVolume%d", extension->VolumeNumber);
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);
    mirror->CreateLegacyNameLinks(&deviceName);

    newUniqueId = (PMOUNTDEV_UNIQUE_ID) newUniqueIdBuffer;
    FtpQueryUniqueIdBuffer(extension, newUniqueId->UniqueId,
                           &newUniqueId->UniqueIdLength);

    FtpUniqueIdNotify(extension, newUniqueId);

    IoInvalidateDeviceRelations(RootExtension->Pdo, BusRelations);
    FtpNotify(RootExtension, extension);

    return STATUS_SUCCESS;
}

VOID
FtpBootDriverReinitialization(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PVOID           RootExtension,
    IN  ULONG           Count
    )

/*++

Routine Description:

    This routine is called after all of the boot drivers are loaded and it
    checks to make sure that we did not boot off of the stale half of a
    mirror.

Arguments:

    DriverObject    - Supplies the drive object.

    RootExtension   - Supplies the root extension.

    Count           - Supplies the count.

Return Value:

    None.

--*/

{
    PROOT_EXTENSION         rootExtension = (PROOT_EXTENSION) RootExtension;
    NTSTATUS                status;
    BOOTDISK_INFORMATION    bootInfo;
    BOOLEAN                 onlyOne, skipBoot, skipSystem;
    PLIST_ENTRY             l;
    PVOLUME_EXTENSION       extension;
    PFT_VOLUME              vol, partition;
    FT_MEMBER_STATE         state;

    status = IoGetBootDiskInformation(&bootInfo, sizeof(bootInfo));
    if (!NT_SUCCESS(status)) {
        return;
    }

    if (bootInfo.BootDeviceSignature == bootInfo.SystemDeviceSignature &&
        bootInfo.BootPartitionOffset == bootInfo.SystemPartitionOffset) {

        onlyOne = TRUE;
    } else {
        onlyOne = FALSE;
    }

    if (!bootInfo.BootDeviceSignature || !bootInfo.BootPartitionOffset) {
        skipBoot = TRUE;
    } else {
        skipBoot = FALSE;
    }

    if (!bootInfo.SystemDeviceSignature || !bootInfo.SystemPartitionOffset) {
        skipSystem = TRUE;
    } else {
        skipSystem = FALSE;
    }

    if (skipBoot && skipSystem) {
        return;
    }

    FtpAcquire(rootExtension);

    for (l = rootExtension->VolumeList.Flink;
         l != &rootExtension->VolumeList; l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        vol = extension->FtVolume;
        if (!vol) {
            continue;
        }

        if (!skipBoot) {
            partition = vol->GetContainedLogicalDisk(
                        bootInfo.BootDeviceSignature,
                        bootInfo.BootPartitionOffset);
            if (partition) {
                if (vol->QueryVolumeState(partition, &state) &&
                    state != FtMemberHealthy) {

                    KeBugCheckEx(FTDISK_INTERNAL_ERROR,
                                 (ULONG_PTR) extension,
                                 bootInfo.BootDeviceSignature,
                                 (ULONG_PTR) bootInfo.BootPartitionOffset,
                                 state);
                }
            }
        }

        if (onlyOne) {
            continue;
        }

        if (!skipSystem) {
            partition = vol->GetContainedLogicalDisk(
                        bootInfo.SystemDeviceSignature,
                        bootInfo.SystemPartitionOffset);
            if (partition) {
                if (vol->QueryVolumeState(partition, &state) &&
                    state != FtMemberHealthy) {

                    KeBugCheckEx(FTDISK_INTERNAL_ERROR,
                                 (ULONG_PTR) extension,
                                 bootInfo.BootDeviceSignature,
                                 (ULONG_PTR) bootInfo.BootPartitionOffset,
                                 state);
                }
            }
        }
    }

    rootExtension->PastBootReinitialize = TRUE;

    FtpRelease(rootExtension);
}

NTSTATUS
FtpQuerySystemVolumeNameQueryRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine queries the unique id for the given value.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Returns the system volume name.

    EntryContext    - Not used.

Return Value:

    NTSTATUS

--*/

{
    PUNICODE_STRING systemVolumeName = (PUNICODE_STRING) Context;
    UNICODE_STRING  string;

    if (ValueType != REG_SZ) {
        return STATUS_SUCCESS;
    }

    RtlInitUnicodeString(&string, (PWSTR) ValueData);

    systemVolumeName->Length = string.Length;
    systemVolumeName->MaximumLength = systemVolumeName->Length + sizeof(WCHAR);
    systemVolumeName->Buffer = (PWSTR) ExAllocatePool(PagedPool,
                                              systemVolumeName->MaximumLength);
    if (!systemVolumeName->Buffer) {
        return STATUS_SUCCESS;
    }

    RtlCopyMemory(systemVolumeName->Buffer, ValueData,
                  systemVolumeName->Length);
    systemVolumeName->Buffer[systemVolumeName->Length/sizeof(WCHAR)] = 0;

    return STATUS_SUCCESS;
}

VOID
FtpDriverReinitialization(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PVOID           RootExtension,
    IN  ULONG           Count
    )

/*++

Routine Description:

    This routine is called after all of the disk drivers are loaded

Arguments:

    DriverObject    - Supplies the drive object.

    RootExtension   - Supplies the root extension.

    Count           - Supplies the count.

Return Value:

    None.

--*/

{
    PROOT_EXTENSION             rootExtension = (PROOT_EXTENSION) RootExtension;
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    UNICODE_STRING              systemVolumeName, s;
    PLIST_ENTRY                 l;
    PVOLUME_EXTENSION           extension;
    WCHAR                       buffer[100];

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = FtpQuerySystemVolumeNameQueryRoutine;
    queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = L"SystemPartition";

    systemVolumeName.Buffer = NULL;

    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                           L"\\Registry\\Machine\\System\\Setup",
                           queryTable, &systemVolumeName, NULL);

    FtpAcquire(rootExtension);

    for (l = rootExtension->VolumeList.Flink;
         l != &rootExtension->VolumeList; l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

        if (!extension->IsEspType) {
            continue;
        }

        swprintf(buffer, L"\\Device\\HarddiskVolume%d", extension->VolumeNumber);
        RtlInitUnicodeString(&s, buffer);

        if (systemVolumeName.Buffer &&
            RtlEqualUnicodeString(&s, &systemVolumeName, TRUE)) {

            rootExtension->ESPUniquePartitionGUID = extension->UniqueIdGuid;
        }

        FtpApplyESPProtection(&s);
    }

    rootExtension->PastReinitialize = TRUE;

    FtpRelease(rootExtension);

    if (systemVolumeName.Buffer) {
        ExFreePool(systemVolumeName.Buffer);
    }
}

VOID
FtpCopyStateToRegistry(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  PVOID               LogicalDiskState,
    IN  USHORT              LogicalDiskStateSize
    )

/*++

Routine Description:

    This routine writes the given state to the registry so that it can
    be retrieved to solve some of the so called split brain problems.

Arguments:

    LogicalDiskId           - Supplies the logical disk id.

    LogicalDiskState        - Supplies the logical disk state.

    LogicalDiskStateSize    - Supplies the logical disk state size.

Return Value:

    None.

--*/

{
    WCHAR   registryName[50];

    RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE, FT_STATE_REGISTRY_KEY);

    swprintf(registryName, L"%I64X", LogicalDiskId);

    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, FT_STATE_REGISTRY_KEY,
                          registryName, REG_BINARY, LogicalDiskState,
                          LogicalDiskStateSize);
}

NTSTATUS
FtpQueryStateFromRegistryRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine fetches the binary data for the given regitry entry.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Returns the registry data.

    EntryContext    - Supplies the length of the registry data buffer.

Return Value:

    NTSTATUS

--*/

{
    if (ValueLength > *((PUSHORT) EntryContext)) {
        return STATUS_INVALID_PARAMETER;
    }

    *((PUSHORT) EntryContext) = (USHORT) ValueLength;
    RtlCopyMemory(Context, ValueData, ValueLength);

    return STATUS_SUCCESS;
}

BOOLEAN
FtpQueryStateFromRegistry(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  PVOID               LogicalDiskState,
    IN  USHORT              BufferSize,
    OUT PUSHORT             LogicalDiskStateSize
    )

/*++

Routine Description:

    This routine queries the given state from the registry so that it can
    be retrieved to solve some of the so called split brain problems.

Arguments:

    LogicalDiskId           - Supplies the logical disk id.

    LogicalDiskState        - Supplies the logical disk state.

    LogicalDiskStateSize    - Supplie the logical disk state size.

Return Value:

    None.

--*/

{
    WCHAR                       registryName[50];
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    NTSTATUS                    status;

    *LogicalDiskStateSize = BufferSize;

    swprintf(registryName, L"%I64X", LogicalDiskId);

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = FtpQueryStateFromRegistryRoutine;
    queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = registryName;
    queryTable[0].EntryContext = LogicalDiskStateSize;

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    FT_STATE_REGISTRY_KEY, queryTable,
                                    LogicalDiskState, NULL);

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    return TRUE;
}

VOID
FtpDeleteStateInRegistry(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine deletes the given registry state in the registry.

Arguments:

    LogicalDiskId           - Supplies the logical disk id.

Return Value:

    None.

--*/

{
    WCHAR                       registryName[50];

    swprintf(registryName, L"%I64X", LogicalDiskId);

    RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE, FT_STATE_REGISTRY_KEY,
                           registryName);
}


NTSTATUS
FtWmi(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine handles any WMI requests for information.

Arguments:

    DeviceObject - Context for the activity.

    Irp          - The device control argument block.

Return Value:

    Status is returned.

--*/

{
    PVOLUME_EXTENSION       extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                status;
    SYSCTL_IRP_DISPOSITION  disposition;

    if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(extension->Root->TargetObject, Irp);
    }

    ASSERT(extension->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);

    status = WmiSystemControl(extension->WmilibContext, DeviceObject,
                              Irp, &disposition);

    switch (disposition) {
        case IrpProcessed:
            break;

        case IrpNotCompleted:
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;

        default:
            status = Irp->IoStatus.Status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
    }

    return status;
}


NTSTATUS
FtWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for enabling or
    disabling events and data collection.  When the driver has finished it
    must call WmiCompleteRequest to complete the irp. The driver can return
    STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose events or data collection are being
        enabled or disabled

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    Function differentiates between event and data collection operations

    Enable indicates whether to enable or disable


Return Value:

    status

--*/
{
    NTSTATUS status;
    PVOLUME_EXTENSION extension;
    PPMWMICOUNTERLIB_CONTEXT counterLib;

    extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;
    counterLib = &extension->Root->PmWmiCounterLibContext;

    if (GuidIndex == 0)
    {
        status = STATUS_SUCCESS;
        if (Function == WmiDataBlockControl) {
            if (!Enable) {
                extension->CountersEnabled =
                    counterLib->PmWmiCounterDisable(
                        &extension->PmWmiCounterContext,FALSE,FALSE);
            } else {
                status = counterLib->PmWmiCounterEnable(
                            &extension->PmWmiCounterContext);
                if (NT_SUCCESS(status)) {
                    extension->CountersEnabled = TRUE;
                }
            }
        }
    } else {
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(
                                 DeviceObject,
                                 Irp,
                                 status,
                                 0,
                                 IO_NO_INCREMENT);
    return(status);
}



NTSTATUS
FtpPmWmiCounterLibContext(
    IN OUT PROOT_EXTENSION RootExtension,
    IN PIRP            Irp
    )

/*++

Routine Description:

    This routine is called from the partition manager to enable access to
    the performance counter maintenance routines.

Arguments:

    RootExtension   - Supplies the device extension.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PPMWMICOUNTERLIB_CONTEXT            input;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(PMWMICOUNTERLIB_CONTEXT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PPMWMICOUNTERLIB_CONTEXT) Irp->AssociatedIrp.SystemBuffer;
    RootExtension->PmWmiCounterLibContext = *input;

    return STATUS_SUCCESS;
}


VOID
FtDiskUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )

/*++

Routine Description:

    This routine unloads.

Arguments:

    DriverObject    - Supplies the driver object.

Return Value:

    None.

--*/

{
    ObDereferenceObject(DriverObject);
}

VOID
FtpApplyESPSecurityWorker(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PVOID           WorkItem
    )

{
    PVOLUME_EXTENSION   extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;
    PIO_WORKITEM        workItem = (PIO_WORKITEM) WorkItem;
    WCHAR               buffer[100];
    UNICODE_STRING      s;

    swprintf(buffer, L"\\Device\\HarddiskVolume%d", extension->VolumeNumber);
    RtlInitUnicodeString(&s, buffer);

    FtpApplyESPProtection(&s);

    IoFreeWorkItem(workItem);
}

VOID
FtpPostApplyESPSecurity(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    PIO_WORKITEM    workItem;

    workItem = IoAllocateWorkItem(Extension->DeviceObject);
    if (!workItem) {
        return;
    }

    IoQueueWorkItem(workItem, FtpApplyESPSecurityWorker, DelayedWorkQueue,
                    workItem);
}

NTSTATUS
FtDiskPnp(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_PNP.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION       extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PROOT_EXTENSION         rootExtension;
    PDEVICE_OBJECT          targetObject;
    NTSTATUS                status;
    UNICODE_STRING          interfaceName;
    PLIST_ENTRY             l;
    PVOLUME_EXTENSION       e;
    UNICODE_STRING          dosName;
    KEVENT                  event;
    ULONG                   n, size;
    PDEVICE_RELATIONS       deviceRelations;
    PDEVICE_CAPABILITIES    capabilities;
    DEVICE_INSTALL_STATE    deviceInstallState;
    ULONG                   bytes;
    BOOLEAN                 deletePdo;
    BOOLEAN                 dontAssertGuid;
    BOOLEAN                 removeInProgress;

    if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {

        rootExtension = (PROOT_EXTENSION) extension;
        targetObject = rootExtension->TargetObject;

        switch (irpSp->MinorFunction) {

            case IRP_MN_START_DEVICE:
            case IRP_MN_CANCEL_REMOVE_DEVICE:
            case IRP_MN_CANCEL_STOP_DEVICE:
            case IRP_MN_QUERY_RESOURCES:
            case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
                Irp->IoStatus.Status = STATUS_SUCCESS ;
                IoSkipCurrentIrpStackLocation(Irp);
                return IoCallDriver(targetObject, Irp);

            case IRP_MN_QUERY_DEVICE_RELATIONS:
                if (irpSp->Parameters.QueryDeviceRelations.Type != BusRelations) {
                    IoSkipCurrentIrpStackLocation(Irp);
                    return IoCallDriver(targetObject, Irp);
                }

                FtpAcquire(rootExtension);

                n = 0;
                for (l = rootExtension->VolumeList.Flink;
                     l != &rootExtension->VolumeList; l = l->Flink) {

                    n++;
                }

                size = FIELD_OFFSET(DEVICE_RELATIONS, Objects) +
                       n*sizeof(PDEVICE_OBJECT);

                deviceRelations = (PDEVICE_RELATIONS)
                                  ExAllocatePool(PagedPool, size);
                if (!deviceRelations) {
                    FtpRelease(rootExtension);
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    Irp->IoStatus.Information = 0;
                    break;
                }

                deviceRelations->Count = n;
                n = 0;
                for (l = rootExtension->VolumeList.Flink;
                     l != &rootExtension->VolumeList; l = l->Flink) {

                    e = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
                    deviceRelations->Objects[n++] = e->DeviceObject;
                    ObReferenceObject(e->DeviceObject);
                }

                while (!IsListEmpty(&rootExtension->DeadVolumeList)) {
                    l = RemoveHeadList(&rootExtension->DeadVolumeList);
                    e = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
                    e->DeadToPnp = TRUE;
                }

                FtpRelease(rootExtension);

                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

                IoSkipCurrentIrpStackLocation(Irp);
                return IoCallDriver(targetObject, Irp);

            case IRP_MN_QUERY_ID:
                status = FtpQueryRootId(rootExtension, Irp);

                if (NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED)) {
                    if (NT_SUCCESS(status)) {
                        Irp->IoStatus.Status = status;
                    }

                    IoSkipCurrentIrpStackLocation(Irp);
                    return IoCallDriver(targetObject, Irp);
                }
                break;

            case IRP_MN_REMOVE_DEVICE:
            case IRP_MN_SURPRISE_REMOVAL:

                FtpAcquire(rootExtension);

                if (rootExtension->VolumeManagerInterfaceName.Buffer) {
                    IoSetDeviceInterfaceState(
                            &rootExtension->VolumeManagerInterfaceName, FALSE);
                    ExFreePool(rootExtension->VolumeManagerInterfaceName.Buffer);
                    rootExtension->VolumeManagerInterfaceName.Buffer = NULL;
                }

                if (irpSp->MinorFunction == IRP_MN_REMOVE_DEVICE) {

                    ASSERT(IsListEmpty(&rootExtension->VolumeList));

                    while (!IsListEmpty(&rootExtension->VolumeList)) {

                        l = RemoveHeadList(&rootExtension->VolumeList);
                        e = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

                        FtpCleanupVolumeExtension(e);
                        ExFreePool(e->DeviceNodeName.Buffer);
                        IoDeleteDevice(e->DeviceObject);
                    }

                    delete rootExtension->DiskInfoSet;
                    rootExtension->DiskInfoSet = NULL;

                    FtpRelease(rootExtension);

                    InterlockedExchange(&rootExtension->TerminateThread, TRUE);

                    KeReleaseSemaphore(&rootExtension->WorkerSemaphore,
                                       IO_NO_INCREMENT, 1, FALSE);

                    KeWaitForSingleObject(rootExtension->WorkerThread, Executive,
                                          KernelMode, FALSE, NULL);

                    ObDereferenceObject(rootExtension->WorkerThread);

                    ASSERT(IsListEmpty(&rootExtension->ChangeNotifyIrpList));

                    IoDetachDevice(targetObject);
                    IoUnregisterShutdownNotification(rootExtension->DeviceObject);
                    IoDeleteDevice(rootExtension->DeviceObject);
                } else {
                    FtpRelease(rootExtension);
                }

                Irp->IoStatus.Status = STATUS_SUCCESS;
                IoSkipCurrentIrpStackLocation(Irp);
                return IoCallDriver(targetObject, Irp);

            case IRP_MN_QUERY_REMOVE_DEVICE:
            case IRP_MN_DEVICE_USAGE_NOTIFICATION:
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;

            case IRP_MN_QUERY_CAPABILITIES:
                KeInitializeEvent(&event, NotificationEvent, FALSE);
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp, FtpSignalCompletion,
                                       &event, TRUE, TRUE, TRUE);
                IoCallDriver(targetObject, Irp);
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                      NULL);

                capabilities = irpSp->Parameters.DeviceCapabilities.Capabilities;
                capabilities->SilentInstall = 1;
                capabilities->RawDeviceOK = 1;
                status = Irp->IoStatus.Status;
                break;

            case IRP_MN_QUERY_PNP_DEVICE_STATE:
                KeInitializeEvent(&event, NotificationEvent, FALSE);
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp, FtpSignalCompletion,
                                       &event, TRUE, TRUE, TRUE);
                IoCallDriver(targetObject, Irp);
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                      NULL);

                status = Irp->IoStatus.Status;
                if (NT_SUCCESS(status)) {
                    Irp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE |
                                                 PNP_DEVICE_DONT_DISPLAY_IN_UI;
                } else {
                    status = STATUS_SUCCESS;
                    Irp->IoStatus.Information = PNP_DEVICE_NOT_DISABLEABLE |
                                                PNP_DEVICE_DONT_DISPLAY_IN_UI;
                }
                break;

            default:
                IoSkipCurrentIrpStackLocation(Irp);
                return IoCallDriver(targetObject, Irp);

        }

    } else if (extension->DeviceExtensionType == DEVICE_EXTENSION_VOLUME) {

        switch (irpSp->MinorFunction) {

            case IRP_MN_START_DEVICE:
                FtpAcquire(extension->Root);

                KeInitializeEvent(&event, NotificationEvent, FALSE);
                FtpZeroRefCallback(extension, FtpStartCallback, &event, TRUE);
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                      NULL);

                dontAssertGuid = FALSE;
                if (extension->Root->PastBootReinitialize) {

                    status = IoGetDeviceProperty(extension->DeviceObject,
                                                 DevicePropertyInstallState,
                                                 sizeof(deviceInstallState),
                                                 &deviceInstallState, &bytes);
                    if (NT_SUCCESS(status)) {
                        if (deviceInstallState == InstallStateInstalled) {
                            extension->IsInstalled = TRUE;
                            if (extension->IsPreExposure) {
                                extension->Root->PreExposureCount--;
                                RemoveEntryList(&extension->ListEntry);
                                InsertTailList(
                                        &extension->Root->DeadVolumeList,
                                        &extension->ListEntry);
                                FtpCleanupVolumeExtension(extension);
                                status = STATUS_UNSUCCESSFUL;
                                dontAssertGuid = TRUE;
                            } else if (extension->IsHidden) {
                                status = STATUS_UNSUCCESSFUL;
                                dontAssertGuid = TRUE;
                                if (extension->IsEspType &&
                                    extension->Root->PastReinitialize) {

                                    FtpPostApplyESPSecurity(extension);
                                }
                            } else {
                                status = IoRegisterDeviceInterface(
                                         extension->DeviceObject,
                                         &MOUNTDEV_MOUNTED_DEVICE_GUID, NULL,
                                         &extension->MountedDeviceInterfaceName);
                            }
                        } else {
                            status = STATUS_UNSUCCESSFUL;
                            dontAssertGuid = TRUE;
                        }
                    } else {
                        dontAssertGuid = TRUE;
                    }
                } else {
                    extension->IsInstalled = TRUE;
                    if (extension->IsPreExposure || extension->IsHidden) {
                        status = STATUS_UNSUCCESSFUL;
                        dontAssertGuid = TRUE;
                    } else {
                        status = IoRegisterDeviceInterface(
                                 extension->DeviceObject,
                                 &MOUNTDEV_MOUNTED_DEVICE_GUID, NULL,
                                 &extension->MountedDeviceInterfaceName);
                    }
                }

                if (NT_SUCCESS(status)) {
                    status = IoSetDeviceInterfaceState(
                             &extension->MountedDeviceInterfaceName, TRUE);
                }

                if (!NT_SUCCESS(status)) {
                    if (extension->MountedDeviceInterfaceName.Buffer) {
                        ExFreePool(extension->MountedDeviceInterfaceName.Buffer);
                        extension->MountedDeviceInterfaceName.Buffer = NULL;
                    }
                    KeInitializeEvent(&event, NotificationEvent, FALSE);
                    FtpZeroRefCallback(extension, FtpVolumeOnlineCallback,
                                       &event, TRUE);
                    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                          NULL);
                }

                if (!extension->IsHidden) {
                    FtRegisterDevice(DeviceObject);
                }

                FtpRelease(extension->Root);
                if (dontAssertGuid) {
                    status = STATUS_SUCCESS;
                }
                break;

            case IRP_MN_QUERY_REMOVE_DEVICE:
                if (extension->DeviceObject->Flags&DO_SYSTEM_BOOT_PARTITION) {
                    status = STATUS_INVALID_DEVICE_REQUEST;
                    break;
                }

                status = FtpCheckForQueryRemove(extension);
                break;

            case IRP_MN_CANCEL_REMOVE_DEVICE:
                removeInProgress = FtpCheckForCancelRemove(extension);

                if (removeInProgress) {
                    KeInitializeEvent(&event, NotificationEvent, FALSE);
                    FtpZeroRefCallback(extension, FtpQueryRemoveCallback, &event,
                                       TRUE);
                    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                          NULL);
                }
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_QUERY_STOP_DEVICE:
                status = STATUS_UNSUCCESSFUL;
                break;

            case IRP_MN_CANCEL_STOP_DEVICE:
            case IRP_MN_QUERY_RESOURCES:
            case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_REMOVE_DEVICE:
            case IRP_MN_SURPRISE_REMOVAL:

                FtpAcquire(extension->Root);

                FtpRemoveHelper(extension);

                KeInitializeEvent(&event, NotificationEvent, FALSE);
                FtpZeroRefCallback(extension, FtpQueryRemoveCallback, &event,
                                   TRUE);
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                      NULL);

                if (extension->MountedDeviceInterfaceName.Buffer) {
                    IoSetDeviceInterfaceState(
                            &extension->MountedDeviceInterfaceName, FALSE);
                    ExFreePool(extension->MountedDeviceInterfaceName.Buffer);
                    extension->MountedDeviceInterfaceName.Buffer = NULL;
                }

                if (irpSp->MinorFunction == IRP_MN_REMOVE_DEVICE) {
                    if (extension->DeadToPnp && !extension->DeviceDeleted) {
                        extension->DeviceDeleted = TRUE;
                        ExFreePool(extension->DeviceNodeName.Buffer);
                        deletePdo = TRUE;
                    } else {
                        deletePdo = FALSE;
                    }
                } else {
                    deletePdo = FALSE;
                }

                FtpRelease(extension->Root);

                // If this device is still being enumerated then don't
                // delete it and wait for a start instead.  If it is not
                // being enumerated then blow it away.

                if (deletePdo) {
                    IoDeleteDevice(extension->DeviceObject);
                }
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_QUERY_DEVICE_RELATIONS:
                if (irpSp->Parameters.QueryDeviceRelations.Type !=
                    TargetDeviceRelation) {

                    status = STATUS_NOT_SUPPORTED;
                    break;
                }

                deviceRelations = (PDEVICE_RELATIONS)
                                  ExAllocatePool(PagedPool,
                                                 sizeof(DEVICE_RELATIONS));
                if (!deviceRelations) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                ObReferenceObject(DeviceObject);
                deviceRelations->Count = 1;
                deviceRelations->Objects[0] = DeviceObject;
                Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_QUERY_INTERFACE:
                status = STATUS_NOT_SUPPORTED ;
                break;

            case IRP_MN_QUERY_CAPABILITIES:
                capabilities = irpSp->Parameters.DeviceCapabilities.Capabilities;
                capabilities->SilentInstall = 1;
                capabilities->RawDeviceOK = 1;
                capabilities->SurpriseRemovalOK = 1;
                capabilities->Address = extension->VolumeNumber;
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_QUERY_ID:
                status = FtpQueryId(extension, Irp);
                break;

            case IRP_MN_QUERY_PNP_DEVICE_STATE:
                Irp->IoStatus.Information = PNP_DEVICE_DONT_DISPLAY_IN_UI;
                if ((extension->DeviceObject->Flags&DO_SYSTEM_BOOT_PARTITION) ||
                    extension->InPagingPath) {

                    Irp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;
                }
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_DEVICE_USAGE_NOTIFICATION:
                return FtDiskPagingNotification(DeviceObject, Irp);

            default:
                status = STATUS_NOT_SUPPORTED;
                break;

        }
    } else {
        Irp->IoStatus.Information = 0;
        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    if (status != STATUS_NOT_SUPPORTED) {
        Irp->IoStatus.Status = status;
    } else {
        status = Irp->IoStatus.Status;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

class DELETE_FT_REGISTRY_WORK_ITEM : public WORK_QUEUE_ITEM {

    public:

        PROOT_EXTENSION     RootExtension;
        FT_LOGICAL_DISK_ID  LogicalDiskId;

};

typedef DELETE_FT_REGISTRY_WORK_ITEM *PDELETE_FT_REGISTRY_WORK_ITEM;

VOID
FtpDeleteFtRegistryWorker(
    IN  PVOID   WorkItem
    )

{
    PDELETE_FT_REGISTRY_WORK_ITEM       workItem = (PDELETE_FT_REGISTRY_WORK_ITEM) WorkItem;
    PROOT_EXTENSION                     rootExtension = workItem->RootExtension;
    PFT_LOGICAL_DISK_INFORMATION_SET    diskInfoSet = rootExtension->DiskInfoSet;

    FtpAcquire(rootExtension);
    diskInfoSet->DeleteFtRegistryInfo(workItem->LogicalDiskId);
    FtpRelease(rootExtension);
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif

PVOLUME_EXTENSION
FtpFindExtensionCoveringPartition(
    IN  PROOT_EXTENSION RootExtension,
    IN  PDEVICE_OBJECT  Partition
    )

/*++

Routine Description:

    This routine finds the device extension covering the given partition.

Arguments:

    RootExtension   - Supplies the root extension.

    Partition       - Supplies the partition.

Return Value:

    The volume extension covering the given partition.

--*/

{
    PLIST_ENTRY         l;
    PVOLUME_EXTENSION   extension;
    PFT_VOLUME          vol;

    for (l = RootExtension->VolumeList.Flink; l != &RootExtension->VolumeList;
         l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

        if (extension->TargetObject) {
            if (extension->TargetObject == Partition) {
                return extension;
            }
            continue;
        }

        vol = extension->FtVolume;
        if (vol && vol->GetContainedLogicalDisk(Partition)) {
            return extension;
        }
    }

    return NULL;
}

VOID
FtpAcquire(
    IN OUT  PROOT_EXTENSION RootExtension
    )

/*++

Routine Description:

    This routine grabs the root semaphore.

Arguments:

    RootExtension   - Supplies the root extension.

Return Value:

    None.

--*/

{
    KeWaitForSingleObject(&RootExtension->Mutex, Executive, KernelMode,
                          FALSE, NULL);
}

VOID
FtpRelease(
    IN OUT  PROOT_EXTENSION RootExtension
    )

/*++

Routine Description:

    This routine releases the root semaphore.

Arguments:

    RootExtension   - Supplies the root extension.

Return Value:

    None.

--*/

{
    KeReleaseSemaphore(&RootExtension->Mutex, IO_NO_INCREMENT, 1, FALSE);
}

VOID
FtpCancelChangeNotify(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the cancel routine for notification IRPs.

Arguments:

    DeviceObject   - Supplies the device object.

    Irp            - Supplies the IO request packet.

Return Value:

    None

--*/
{
    PVOLUME_EXTENSION   Extension;

    IoReleaseCancelSpinLock (Irp->CancelIrql);

    Extension = (PVOLUME_EXTENSION) Irp->Tail.Overlay.DriverContext[0];

    FtpAcquire(Extension->Root);
    RemoveEntryList (&Irp->Tail.Overlay.ListEntry);
    FtpRelease(Extension->Root);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}


NTSTATUS
FtDiskCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_CREATE.

Arguments:

    DeviceObject - Supplies the device object.

    Irp          - Supplies the IO request block.

Return Value:

    NTSTATUS

--*/

{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

VOID
FtpEventSignalCompletion(
    IN  PVOID       Event,
    IN  NTSTATUS    Status
    )

/*++

Routine Description:

    Completion routine of type FT_COMPLETION_ROUTINE that sets
    the status of the given event to Signaled

Arguments:

    Event       - Supplies the event

    Status      - Supplies the status of the operation.

Return Value:

    None.

--*/

{
    KeSetEvent( (PKEVENT) Event, IO_NO_INCREMENT, FALSE );
}

VOID
FtpVolumeOnlineCallback(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    if (Extension->IsOffline) {
        Extension->IsOffline = FALSE;
        Extension->IsComplete = FALSE;
    }
    KeSetEvent((PKEVENT) Extension->ZeroRefContext, IO_NO_INCREMENT, FALSE);
}

VOID
FtpVolumeOfflineCallback(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    if (!Extension->IsOffline) {
        Extension->IsOffline = TRUE;
        if (Extension->FtVolume) {
            Extension->FtVolume->SetDirtyBit(FALSE, NULL, NULL);
        }
    }
    KeSetEvent((PKEVENT) Extension->ZeroRefContext, IO_NO_INCREMENT, FALSE);
}

NTSTATUS
FtpAllSystemsGo(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp,
    IN  BOOLEAN             MustBeComplete,
    IN  BOOLEAN             MustHaveVolume,
    IN  BOOLEAN             MustBeOnline
    )

/*++

Routine Description:

    This routine checks the device extension states to make sure that the
    IRP can proceed.  If the IRP can proceed then the device extension ref
    count is incremented.  If the IRP is queued then STATUS_PENDING returned.

Arguments:

    Extension       - Supplies the device extension.

    Irp             - Supplies the I/O request packet.

    MustBeComplete  - Supplies whether or not the FT set must be complete.

    MustHaveVolume  - Supplies whether or not the PDO still refers to an
                        existing volume.

    MustBeOnline    - Supplies whether or not the volume must be online.

Return Value:

    STATUS_PENDING      - The IRP was put on the ZeroRef queue.

    STATUS_SUCCESS      - The IRP can proceed.  The ref count was incremented.

    !NT_SUCCESS(status) - The IRP must fail with the status returned.

--*/

{
    KIRQL                           irql;
    PFT_VOLUME                      vol;
    BOOLEAN                         deleteFtRegistryInfo;
    PDELETE_FT_REGISTRY_WORK_ITEM   workItem;

    if (MustBeComplete) {
        MustHaveVolume = TRUE;
        MustBeOnline = TRUE;
    }

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    if (MustHaveVolume && !Extension->TargetObject && !Extension->FtVolume) {
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        return STATUS_NO_SUCH_DEVICE;
    }

    if (!Extension->IsStarted) {
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        return STATUS_NO_SUCH_DEVICE;
    }

    if (MustBeOnline && Extension->IsOffline) {
        if (Extension->DeviceObject->Flags&DO_SYSTEM_BOOT_PARTITION) {
            Extension->IsOffline = FALSE;
        } else {
            KeReleaseSpinLock(&Extension->SpinLock, irql);
            return STATUS_NO_SUCH_DEVICE;
        }
    }

    if (Extension->ZeroRefCallback || Extension->RemoveInProgress) {
        ASSERT(Irp);
        IoMarkIrpPending(Irp);
        InsertTailList(&Extension->ZeroRefHoldQueue,
                       &Irp->Tail.Overlay.ListEntry);
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        return STATUS_PENDING;
    }

    if (Extension->TargetObject) {
        InterlockedIncrement(&Extension->RefCount);
        if (!Extension->IsOffline) {
            InterlockedExchange(&Extension->AllSystemsGo, TRUE);
        }
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        return STATUS_SUCCESS;
    }

    if (!MustBeComplete || Extension->IsComplete) {
        InterlockedIncrement(&Extension->RefCount);
        if (Extension->IsComplete && MustHaveVolume && !Extension->IsOffline) {
            InterlockedExchange(&Extension->AllSystemsGo, TRUE);
        }
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        return STATUS_SUCCESS;
    }

    vol = Extension->FtVolume;
    ASSERT(vol);

    if (!vol->IsComplete(TRUE)) {
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        return STATUS_NO_SUCH_DEVICE;
    }
    vol->CompleteNotification(TRUE);

    if (vol->IsComplete(FALSE)) {
        deleteFtRegistryInfo = FALSE;
    } else {
        deleteFtRegistryInfo = TRUE;
    }

    Extension->IsComplete = TRUE;
    InterlockedIncrement(&Extension->RefCount);
    InterlockedIncrement(&Extension->RefCount);
    InterlockedExchange(&Extension->AllSystemsGo, TRUE);
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    vol->StartSyncOperations(FALSE, FtpRefCountCompletion, Extension);
    vol->SetDirtyBit(TRUE, NULL, NULL);

    if (deleteFtRegistryInfo) {

        workItem = (PDELETE_FT_REGISTRY_WORK_ITEM)
                   ExAllocatePool(NonPagedPool,
                                  sizeof(DELETE_FT_REGISTRY_WORK_ITEM));
        if (!workItem) {
            return STATUS_SUCCESS;
        }

        ExInitializeWorkItem(workItem, FtpDeleteFtRegistryWorker, workItem);
        workItem->RootExtension = Extension->Root;
        workItem->LogicalDiskId = vol->QueryLogicalDiskId();

        FtpQueueWorkItem(Extension->Root, workItem);
    }

    return STATUS_SUCCESS;
}

VOID
FtpZeroRefCallback(
    IN  PVOLUME_EXTENSION   Extension,
    IN  ZERO_REF_CALLBACK   ZeroRefCallback,
    IN  PVOID               ZeroRefContext,
    IN  BOOLEAN             AcquireSemaphore
    )

/*++

Routine Description:

    This routine sets up the given zero ref callback and state.

Arguments:

    Extension           - Supplies the device extension.

    ZeroRefCallback     - Supplies the zero ref callback.

    ZeroRefContext      - Supplies the zero ref context.

    AcquireSemaphore    - Supplies whether or not to acquire the semaphore.

Return Value:

    None.

--*/

{
    KIRQL   irql;

    if (AcquireSemaphore) {
        KeWaitForSingleObject(&Extension->Semaphore, Executive, KernelMode,
                              FALSE, NULL);
    }

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    InterlockedExchange(&Extension->AllSystemsGo, FALSE);
    ASSERT(!Extension->ZeroRefCallback);
    Extension->ZeroRefCallback = ZeroRefCallback;
    Extension->ZeroRefContext = ZeroRefContext;
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    if (Extension->FtVolume) {
        Extension->FtVolume->StopSyncOperations();
    }

    FtpDecrementRefCount(Extension);
}

NTSTATUS
FtDiskPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_PNP.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION       extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;
    PROOT_EXTENSION         rootExtension = extension->Root;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                status;

    if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
        PoStartNextPowerIrp(Irp);
        IoSkipCurrentIrpStackLocation(Irp);
        return PoCallDriver(rootExtension->TargetObject, Irp);
    }

    switch (irpSp->MinorFunction) {
        case IRP_MN_WAIT_WAKE:
        case IRP_MN_POWER_SEQUENCE:
        case IRP_MN_SET_POWER:
        case IRP_MN_QUERY_POWER:
            status = STATUS_SUCCESS;
            break;

        default:
            status = Irp->IoStatus.Status;
            break;

    }

    Irp->IoStatus.Status = status;
    PoStartNextPowerIrp(Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

VOID
FtpWorkerThread(
    IN  PVOID   RootExtension
    )

/*++

Routine Description:

    This is a worker thread to process work queue items.

Arguments:

    RootExtension   - Supplies the root device extension.

Return Value:

    None.

--*/

{
    PROOT_EXTENSION     extension = (PROOT_EXTENSION) RootExtension;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PWORK_QUEUE_ITEM    queueItem;

    for (;;) {

        KeWaitForSingleObject(&extension->WorkerSemaphore,
                              Executive, KernelMode, FALSE, NULL);

        KeAcquireSpinLock(&extension->SpinLock, &irql);
        if (extension->TerminateThread) {
            KeReleaseSpinLock(&extension->SpinLock, irql);
            PsTerminateSystemThread(STATUS_SUCCESS);
            return;
        }

        ASSERT(!IsListEmpty(&extension->WorkerQueue));
        l = RemoveHeadList(&extension->WorkerQueue);
        KeReleaseSpinLock(&extension->SpinLock, irql);

        queueItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
        queueItem->WorkerRoutine(queueItem->Parameter);

        ExFreePool(queueItem);
    }
}

VOID
FtpEmptyQueueAtDispatchLevel(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN OUT  PLIST_ENTRY         IrpQueue
    )

/*++

Routine Description:

    This routine empties the given queue of irps that are callable at
    dispatch level by calling their respective dispatch routines.

Arguments:

    Extension   - Supplies the device extension.

    IrpQueue    - Supplies the queue of IRPs.

Return Value:

    None.

--*/

{
    PDRIVER_OBJECT      driverObject;
    PDEVICE_OBJECT      deviceObject;
    PLIST_ENTRY         l, tmp;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;

    driverObject = Extension->Root->DriverObject;
    deviceObject = Extension->DeviceObject;

    for (l = IrpQueue->Flink; l != IrpQueue; l = l->Flink) {
        irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
        irpSp = IoGetCurrentIrpStackLocation(irp);
        switch (irpSp->MajorFunction) {
            case IRP_MJ_POWER:
            case IRP_MJ_READ:
            case IRP_MJ_WRITE:
                tmp = l->Blink;
                RemoveEntryList(l);
                l = tmp;
                driverObject->MajorFunction[irpSp->MajorFunction](
                        deviceObject, irp);
                break;

        }
    }
}

VOID
FtpDecrementRefCount(
    IN OUT  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine decrements the ref count and handles the case
    when the ref count goes to zero.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    None.

--*/

{
    LONG                        count;
    KIRQL                       irql;
    BOOLEAN                     startSync, list;
    LIST_ENTRY                  q;
    PEMPTY_IRP_QUEUE_WORK_ITEM  workItem;
    PLIST_ENTRY                 l;
    PIRP                        irp;

    count = InterlockedDecrement(&Extension->RefCount);
    if (count) {
        return;
    }

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    if (!Extension->ZeroRefCallback) {
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        return;
    }

    Extension->ZeroRefCallback(Extension);
    Extension->ZeroRefCallback = NULL;
    InterlockedIncrement(&Extension->RefCount);

    if (Extension->FtVolume && Extension->IsComplete && Extension->IsStarted &&
        !Extension->IsOffline) {

        startSync = TRUE;
        InterlockedIncrement(&Extension->RefCount);
    } else {
        startSync = FALSE;
    }

    if (IsListEmpty(&Extension->ZeroRefHoldQueue) ||
        Extension->RemoveInProgress) {

        list = FALSE;
    } else {
        list = TRUE;
        q = Extension->ZeroRefHoldQueue;
        InitializeListHead(&Extension->ZeroRefHoldQueue);
    }
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    KeReleaseSemaphore(&Extension->Semaphore, IO_NO_INCREMENT, 1, FALSE);

    if (startSync) {
        Extension->FtVolume->StartSyncOperations(FALSE, FtpRefCountCompletion,
                                                 Extension);
    }

    if (!list) {
        return;
    }

    q.Flink->Blink = &q;
    q.Blink->Flink = &q;

    FtpEmptyQueueAtDispatchLevel(Extension, &q);

    if (IsListEmpty(&q)) {
        return;
    }

    workItem = (PEMPTY_IRP_QUEUE_WORK_ITEM)
               ExAllocatePool(NonPagedPool,
                              sizeof(EMPTY_IRP_QUEUE_WORK_ITEM));
    if (!workItem) {
        workItem = (PEMPTY_IRP_QUEUE_WORK_ITEM)
                   ExAllocatePool(NonPagedPool,
                                  sizeof(EMPTY_IRP_QUEUE_WORK_ITEM));
        if (!workItem) {
            while (!IsListEmpty(&q)) {
                l = RemoveHeadList(&q);
                irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
                irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                irp->IoStatus.Information = 0;
                IoCompleteRequest(irp, IO_NO_INCREMENT);
            }
            return;
        }
    }

    ExInitializeWorkItem(workItem, FtpEmptyQueueWorkerRoutine, workItem);
    workItem->IrpQueue = q;
    workItem->IrpQueue.Flink->Blink = &workItem->IrpQueue;
    workItem->IrpQueue.Blink->Flink = &workItem->IrpQueue;
    workItem->Extension = Extension;

    ExQueueWorkItem(workItem, CriticalWorkQueue);
}

NTSTATUS
FtDiskAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates and initializes a new FDO for the corresponding
    PDO.

Arguments:

    DriverObject            - Supplies the FTDISK driver object.

    PhysicalDeviceObject    - Supplies the physical device object.

Return Value:

    NTSTATUS

--*/

{
    UNICODE_STRING      deviceName, dosName;
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject;
    PROOT_EXTENSION     rootExtension;
    HANDLE              handle;
    KIRQL               irql;

    //
    // Create the FT root device.
    //

    RtlInitUnicodeString(&deviceName, DD_FT_CONTROL_DEVICE_NAME);

    status = IoCreateDevice(DriverObject, sizeof(ROOT_EXTENSION),
                            &deviceName, FILE_DEVICE_NETWORK,
                            FILE_DEVICE_SECURE_OPEN, FALSE,
                            &deviceObject);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    RtlInitUnicodeString(&dosName, L"\\DosDevices\\FtControl");
    IoCreateSymbolicLink(&dosName, &deviceName);

    rootExtension = (PROOT_EXTENSION) deviceObject->DeviceExtension;
    RtlZeroMemory(rootExtension, sizeof(ROOT_EXTENSION));
    rootExtension->DeviceObject = deviceObject;
    rootExtension->Root = rootExtension;
    rootExtension->DeviceExtensionType = DEVICE_EXTENSION_ROOT;
    KeInitializeSpinLock(&rootExtension->SpinLock);
    rootExtension->DriverObject = DriverObject;

    rootExtension->TargetObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);
    if (!rootExtension->TargetObject) {
        IoDeleteSymbolicLink(&dosName);
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }

    rootExtension->Pdo = PhysicalDeviceObject;
    InitializeListHead(&rootExtension->VolumeList);
    InitializeListHead(&rootExtension->DeadVolumeList);
    rootExtension->NextVolumeNumber = 1;

    rootExtension->DiskInfoSet = new FT_LOGICAL_DISK_INFORMATION_SET;
    if (!rootExtension->DiskInfoSet) {
        IoDeleteSymbolicLink(&dosName);
        IoDetachDevice(rootExtension->TargetObject);
        IoDeleteDevice(deviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    status = rootExtension->DiskInfoSet->Initialize();
    if (!NT_SUCCESS(status)) {
        delete rootExtension->DiskInfoSet;
        IoDeleteSymbolicLink(&dosName);
        IoDetachDevice(rootExtension->TargetObject);
        IoDeleteDevice(deviceObject);
        return status;
    }

    InitializeListHead(&rootExtension->WorkerQueue);
    KeInitializeSemaphore(&rootExtension->WorkerSemaphore, 0, MAXLONG);
    rootExtension->TerminateThread = TRUE;
    InitializeListHead(&rootExtension->ChangeNotifyIrpList);
    KeInitializeSemaphore(&rootExtension->Mutex, 1, 1);

    status = IoRegisterShutdownNotification(deviceObject);
    if (!NT_SUCCESS(status)) {
        delete rootExtension->DiskInfoSet;
        IoDeleteSymbolicLink(&dosName);
        IoDetachDevice(rootExtension->TargetObject);
        IoDeleteDevice(deviceObject);
        return status;
    }

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return STATUS_SUCCESS;
}

NTSTATUS
FtpRefCountCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Extension
    )

/*++

Routine Description:

    This routine decrements the ref count in the device extension.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

    Extension       - Supplies the device extension.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION   extension = (PVOLUME_EXTENSION) Extension;

    if (extension->CountersEnabled) {
        PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
        if (irpStack->MajorFunction == IRP_MJ_READ ||
            irpStack->MajorFunction == IRP_MJ_WRITE) {
            PPMWMICOUNTERLIB_CONTEXT counterLib;
    
            counterLib = &extension->Root->PmWmiCounterLibContext;
            counterLib->PmWmiCounterIoComplete(
                extension->PmWmiCounterContext, Irp,
                (PLARGE_INTEGER) &irpStack->Parameters.Read);
        }
    }

    FtpDecrementRefCount(extension);
    return STATUS_SUCCESS;
}

NTSTATUS
FtDiskReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_READ and IRP_MJ_WRITE.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION   extension;
    NTSTATUS            status;
    PFT_VOLUME          vol;
    PDISPATCH_TP        packet;
    KIRQL               irql;
    PIO_STACK_LOCATION  irpSp;
    LONGLONG            offset;
    ULONG               length;

    extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;

    if (extension->DeviceExtensionType != DEVICE_EXTENSION_VOLUME) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;
    }

    InterlockedIncrement(&extension->RefCount);
    if (!extension->AllSystemsGo) {
        FtpDecrementRefCount(extension);

        status = FtpAllSystemsGo(extension, Irp, TRUE, TRUE, TRUE);
        if (status == STATUS_PENDING) {
            return STATUS_PENDING;
        }

        if (!NT_SUCCESS(status)) {
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;
        }
    }

    if (extension->IsReadOnly) {
        irpSp = IoGetCurrentIrpStackLocation(Irp);
        if (irpSp->MajorFunction == IRP_MJ_WRITE) {
            Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_INVALID_DEVICE_REQUEST;
        }
    }

    if (extension->TargetObject) {
        IoCopyCurrentIrpStackLocationToNext(Irp);

        if (extension->WholeDisk) {
            irpSp = IoGetNextIrpStackLocation(Irp);
            offset = irpSp->Parameters.Read.ByteOffset.QuadPart;
            length = irpSp->Parameters.Read.Length;
            if (offset < 0 || offset + length > extension->PartitionLength) {
                FtpDecrementRefCount(extension);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return STATUS_INVALID_PARAMETER;
            }

            if (extension->CountersEnabled) {
                PIO_STACK_LOCATION currentIrpStack =
                    IoGetCurrentIrpStackLocation(Irp);
                PPMWMICOUNTERLIB_CONTEXT counterLib;
    
                counterLib = &extension->Root->PmWmiCounterLibContext;
                counterLib->PmWmiCounterIoStart(
                    extension->PmWmiCounterContext,
                    (PLARGE_INTEGER) &currentIrpStack->Parameters.Read);
            }

            irpSp->Parameters.Read.ByteOffset.QuadPart +=
                    extension->PartitionOffset;

            IoSetCompletionRoutine(Irp, FtpRefCountCompletionRoutine,
                                   extension, TRUE, TRUE, TRUE);

            IoMarkIrpPending(Irp);

            IoCallDriver(extension->WholeDisk, Irp);

        } else {

            if (extension->CountersEnabled) {
                PIO_STACK_LOCATION currentIrpStack =
                    IoGetCurrentIrpStackLocation(Irp);
                PPMWMICOUNTERLIB_CONTEXT counterLib;
    
                counterLib = &extension->Root->PmWmiCounterLibContext;
                counterLib->PmWmiCounterIoStart(
                    extension->PmWmiCounterContext,
                    (PLARGE_INTEGER) &currentIrpStack->Parameters.Read);
            }

            IoSetCompletionRoutine(Irp, FtpRefCountCompletionRoutine,
                                   extension, TRUE, TRUE, TRUE);

            IoMarkIrpPending(Irp);

            IoCallDriver(extension->TargetObject, Irp);
        }

        return STATUS_PENDING;
    }

    vol = extension->FtVolume;
    ASSERT(vol);

    packet = new DISPATCH_TP;
    if (!packet) {
        KeAcquireSpinLock(&extension->SpinLock, &irql);
        if (extension->EmergencyTransferPacketInUse) {
            IoMarkIrpPending(Irp);
            InsertTailList(&extension->
                           EmergencyTransferPacketQueue,
                           &Irp->Tail.Overlay.ListEntry);
            KeReleaseSpinLock(&extension->SpinLock, irql);
            return STATUS_PENDING;
        }
        packet = extension->EmergencyTransferPacket;
        extension->EmergencyTransferPacketInUse = TRUE;
        KeReleaseSpinLock(&extension->SpinLock, irql);
    }

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    packet->Mdl = Irp->MdlAddress;
    packet->OriginalIrp = Irp;
    packet->Offset = irpSp->Parameters.Read.ByteOffset.QuadPart;
    packet->Length = irpSp->Parameters.Read.Length;
    packet->CompletionRoutine = FtpReadWriteCompletionRoutine;
    packet->TargetVolume = vol;
    packet->Thread = Irp->Tail.Overlay.Thread;
    packet->IrpFlags = irpSp->Flags;
    if (irpSp->MajorFunction == IRP_MJ_READ) {
        packet->ReadPacket = TRUE;
    } else {
        packet->ReadPacket = FALSE;
    }
    packet->Irp = Irp;
    packet->Extension = extension;

    if (extension->CountersEnabled) {
        PPMWMICOUNTERLIB_CONTEXT counterLib;

        counterLib = &extension->Root->PmWmiCounterLibContext;
        counterLib->PmWmiCounterIoStart(
            extension->PmWmiCounterContext,
            (PLARGE_INTEGER) &irpSp->Parameters.Read);
    }

    IoMarkIrpPending(Irp);

    TRANSFER(packet);

    return STATUS_PENDING;
}

NTSTATUS
FtpSetPowerState(
    IN  PROOT_EXTENSION RootExtension,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine sets the power state for the volume from the power state
    given to it by the disk.

Arguments:

    RootExtension   - Supplies the root extension.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLMGR_POWER_STATE input = (PVOLMGR_POWER_STATE) Irp->AssociatedIrp.SystemBuffer;
    PVOLUME_EXTENSION   extension;
    KIRQL               irql;
    POWER_STATE         powerState;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLMGR_POWER_STATE)) {

        return STATUS_INVALID_PARAMETER;
    }

    extension = FtpFindExtensionCoveringPartition(
                RootExtension, input->PartitionDeviceObject);
    if (!extension) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    KeAcquireSpinLock(&extension->SpinLock, &irql);
    if (extension->PowerState == input->PowerState) {
        KeReleaseSpinLock(&extension->SpinLock, irql);
        return STATUS_SUCCESS;
    }
    extension->PowerState = input->PowerState;
    KeReleaseSpinLock(&extension->SpinLock, irql);

    powerState.DeviceState = input->PowerState;
    PoSetPowerState(extension->DeviceObject, DevicePowerState, powerState);
    PoRequestPowerIrp(extension->DeviceObject, IRP_MN_SET_POWER,
                      powerState, NULL, NULL, NULL);

    return STATUS_SUCCESS;
}

NTSTATUS
FtDiskInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_DEVICE_CONTROL.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION   extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;

    Irp->IoStatus.Information = 0;

    FtpAcquire(extension->Root);

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_INTERNAL_VOLMGR_PARTITION_ARRIVED:
            if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
                status = FtpPartitionArrived(extension->Root, Irp);
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
            break;

        case IOCTL_INTERNAL_VOLMGR_PARTITION_REMOVED:
            if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
                status = FtpPartitionRemoved(extension->Root, Irp);
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
            break;

        case IOCTL_INTERNAL_VOLMGR_WHOLE_DISK_REMOVED:
            if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
                status = FtpWholeDiskRemoved(extension->Root, Irp);
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
            break;

        case IOCTL_INTERNAL_VOLMGR_REFERENCE_DEPENDANT_VOLUMES:
            if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
                status = FtpReferenceDependantVolume(extension->Root, Irp);
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
            break;

        case IOCTL_INTERNAL_VOLMGR_QUERY_CHANGE_PARTITION:
            if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
                status = FtpQueryChangePartition(extension->Root, Irp);
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
            break;

        case IOCTL_INTERNAL_VOLMGR_CANCEL_CHANGE_PARTITION:
            if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
            break;

        case IOCTL_INTERNAL_VOLMGR_PARTITION_CHANGED:
            if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
                status = FtpPartitionChanged(extension->Root, Irp);
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
            break;

        case IOCTL_INTERNAL_VOLMGR_PMWMICOUNTERLIB_CONTEXT:
            if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
                status = FtpPmWmiCounterLibContext(extension->Root, Irp);
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
            break;

        case IOCTL_INTERNAL_VOLMGR_SET_POWER_STATE:
            if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {
                status = FtpSetPowerState(extension->Root, Irp);
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
            break;


        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

    }

    FtpRelease(extension->Root);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}
VOID
FtpVolumeReadOnlyCallback(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    if (Extension->ZeroRefContext) {
        Extension->IsReadOnly = TRUE;
    } else {
        Extension->IsReadOnly = FALSE;
    }
}

VOID
FtpSetTargetCallback(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine sets the given target object.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    None.

--*/

{
    PSET_TARGET_CONTEXT context = (PSET_TARGET_CONTEXT) Extension->ZeroRefContext;

    Extension->OldWholeDiskPdo = Extension->WholeDiskPdo;
    Extension->TargetObject = context->TargetObject;
    Extension->FtVolume = context->FtVolume;
    Extension->WholeDiskPdo = context->WholeDiskPdo;
    Extension->WholeDisk = NULL;
    Extension->PartitionOffset = 0;
    Extension->PartitionLength = 0;
    KeSetEvent(&context->Event, IO_NO_INCREMENT, FALSE);
}

VOID
FtpCancelRoutine(
    IN OUT  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine is called on when the given IRP is cancelled.  It
    will dequeue this IRP off the work queue and complete the
    request as CANCELLED.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IRP.

Return Value:

    None.

--*/

{
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

NTSTATUS
FtpChangeNotify(
    IN OUT  PROOT_EXTENSION RootExtension,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine queues up a change notify IRP to be completed when
    a change occurs in the FT state.

Arguments:

    Extension   - Supplies the root extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    KIRQL       irql;
    NTSTATUS    status;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoAcquireCancelSpinLock(&irql);
    if (Irp->Cancel) {
        status = STATUS_CANCELLED;
    } else {
        InsertTailList(&RootExtension->ChangeNotifyIrpList,
                       &Irp->Tail.Overlay.ListEntry);
        status = STATUS_PENDING;
        IoMarkIrpPending(Irp);
        IoSetCancelRoutine(Irp, FtpCancelRoutine);
    }
    IoReleaseCancelSpinLock(irql);

    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
}

VOID
FtDiskShutdownFlushCompletionRoutine(
    IN  PVOID       Irp,
    IN  NTSTATUS    Status
    )

/*++

Routine Description:

    This is the completion routine for FtDiskShutdownFlush and
    FtDiskPagingNotification.

Arguments:

    Irp         - IRP involved.

    Status      - Status of operation.

Return Value:

    None.

--*/

{
    PIRP                irp = (PIRP) Irp;
    PIO_STACK_LOCATION  irpSp;
    PVOLUME_EXTENSION   extension;

    irpSp = IoGetCurrentIrpStackLocation(irp);
    extension = (PVOLUME_EXTENSION) irpSp->DeviceObject->DeviceExtension;

    FtpDecrementRefCount(extension);

    irp->IoStatus.Status = Status;
    irp->IoStatus.Information = 0;

    if (irpSp->MajorFunction == IRP_MJ_POWER) {
        PoStartNextPowerIrp(irp);
    }

    IoCompleteRequest(irp, IO_DISK_INCREMENT);
}

typedef struct _FTP_SHUTDOWN_CONTEXT {
    PIRP    Irp;
    LONG    RefCount;
} FTP_SHUTDOWN_CONTEXT, *PFTP_SHUTDOWN_CONTEXT;

NTSTATUS
FtDiskShutdownFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_SHUTDOWN and IRP_MJ_FLUSH.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION                   extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;
    PROOT_EXTENSION                     rootExtension;
    ULONG                               numVolumes, i;
    PVOLUME_EXTENSION*                  arrayOfVolumes;
    PLIST_ENTRY                         l;
    NTSTATUS                            status;
    PFT_VOLUME                          vol;
    PFTP_SHUTDOWN_CONTEXT               context;
    PIO_STACK_LOCATION                  irpSp;

    if (extension->DeviceExtensionType == DEVICE_EXTENSION_ROOT) {

        rootExtension = (PROOT_EXTENSION) extension;
        FtpAcquire(rootExtension);

        numVolumes = rootExtension->NextVolumeNumber;
        arrayOfVolumes = (PVOLUME_EXTENSION*)
                         ExAllocatePool(PagedPool,
                                        numVolumes*sizeof(PVOLUME_EXTENSION));
        if (!arrayOfVolumes) {
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        numVolumes = 0;
        for (l = rootExtension->VolumeList.Flink;
             l != &rootExtension->VolumeList; l = l->Flink) {

            extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

            status = FtpAllSystemsGo(extension, NULL, FALSE, TRUE, TRUE);
            if (!NT_SUCCESS(status)) {
                continue;
            }

            vol = extension->FtVolume;
            if (vol) {
                arrayOfVolumes[numVolumes++] = extension;
            } else {
                FtpDecrementRefCount(extension);
            }
        }

        FtpRelease(rootExtension);

        if (numVolumes) {

            context = (PFTP_SHUTDOWN_CONTEXT)
                      ExAllocatePool(NonPagedPool,
                                     sizeof(FTP_SHUTDOWN_CONTEXT));
            if (!context) {
                for (i = 0; i < numVolumes; i++) {
                    FtpDecrementRefCount(extension);
                }
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            Irp->IoStatus.Status = STATUS_SUCCESS;

            context->Irp = Irp;
            context->RefCount = (LONG) numVolumes;

            IoMarkIrpPending(Irp);

            for (i = 0; i < numVolumes; i++) {
                vol = arrayOfVolumes[i]->FtVolume;
                vol->SetDirtyBit(FALSE, FtDiskShutdownCompletionRoutine,
                                 context);
            }

            ExFreePool(arrayOfVolumes);

            return STATUS_PENDING;
        }

        ExFreePool(arrayOfVolumes);

        //
        // Complete this request.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_SUCCESS;
    }

    status = FtpAllSystemsGo(extension, Irp, FALSE, TRUE, TRUE);
    if (status == STATUS_PENDING) {
        return status;
    }
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if (extension->TargetObject) {
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, FtpRefCountCompletionRoutine,
                               extension, TRUE, TRUE, TRUE);
        IoMarkIrpPending(Irp);

        IoCallDriver(extension->TargetObject, Irp);

        return STATUS_PENDING;
    }

    vol = extension->FtVolume;
    ASSERT(vol);

    IoMarkIrpPending(Irp);
    irpSp = IoGetCurrentIrpStackLocation(Irp);
    irpSp->DeviceObject = DeviceObject;

    vol->BroadcastIrp(Irp, FtDiskShutdownFlushCompletionRoutine, Irp);

    return STATUS_PENDING;
}

NTSTATUS
FtpSignalCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Event
    )

{
    KeSetEvent((PKEVENT) Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
FtpQueryRemoveCallback(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine sets the ZeroRef event.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    None.

--*/

{
    KeSetEvent((PKEVENT) Extension->ZeroRefContext, IO_NO_INCREMENT, FALSE);
}

VOID
FtpStartCallback(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine sets the ZeroRef event.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    None.

--*/

{
    Extension->IsStarted = TRUE;
    KeSetEvent((PKEVENT) Extension->ZeroRefContext, IO_NO_INCREMENT, FALSE);
}

NTSTATUS
FtpCheckForQueryRemove(
    IN OUT  PVOLUME_EXTENSION   Extension
    )

{
    KIRQL       irql;
    NTSTATUS    status;

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    if (Extension->InPagingPath || Extension->RemoveInProgress) {
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        status = STATUS_INVALID_DEVICE_REQUEST;
    } else {
        InterlockedExchange(&Extension->AllSystemsGo, FALSE);
        Extension->RemoveInProgress = TRUE;
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        status = STATUS_SUCCESS;
    }

    return status;
}

BOOLEAN
FtpCheckForCancelRemove(
    IN OUT  PVOLUME_EXTENSION   Extension
    )

{
    KIRQL   irql;
    BOOLEAN removeInProgress;

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    removeInProgress = Extension->RemoveInProgress;
    Extension->RemoveInProgress = FALSE;
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    return removeInProgress;
}

VOID
FtpRemoveHelper(
    IN OUT  PVOLUME_EXTENSION   Extension
    )

{
    KIRQL   irql;

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    InterlockedExchange(&Extension->AllSystemsGo, FALSE);
    Extension->IsStarted = FALSE;
    Extension->RemoveInProgress = FALSE;
    KeReleaseSpinLock(&Extension->SpinLock, irql);
}

NTSTATUS
FtDiskCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine cancels all of the IRPs currently queued on
    the given device.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the cleanup IRP.

Return Value:

    STATUS_SUCCESS  - Success.

--*/

{
    PROOT_EXTENSION     rootExtension = (PROOT_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILE_OBJECT        file = irpSp->FileObject;
    PVOLUME_EXTENSION   extension;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PIRP                irp;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    if (rootExtension->DeviceExtensionType != DEVICE_EXTENSION_ROOT) {
        ASSERT(rootExtension->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);
        extension = (PVOLUME_EXTENSION) rootExtension;
        if (extension->RevertOnCloseFileObject == file) {
            FtpAcquire(extension->Root);
            FtpRevertGptAttributes(extension);
            FtpRelease(extension->Root);
        }
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_SUCCESS;
    }

    IoAcquireCancelSpinLock(&irql);

    for (;;) {

        for (l = rootExtension->ChangeNotifyIrpList.Flink;
             l != &rootExtension->ChangeNotifyIrpList; l = l->Flink) {

            irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
            if (IoGetCurrentIrpStackLocation(irp)->FileObject == file) {
                break;
            }
        }

        if (l == &rootExtension->ChangeNotifyIrpList) {
            break;
        }

        irp->Cancel = TRUE;
        irp->CancelIrql = irql;
        irp->CancelRoutine = NULL;
        FtpCancelRoutine(DeviceObject, irp);

        IoAcquireCancelSpinLock(&irql);
    }

    IoReleaseCancelSpinLock(irql);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is called when the driver loads loads.

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                    status;
    PDEVICE_OBJECT              pdo = 0, fdo;
    PROOT_EXTENSION             rootExtension;

    DriverObject->DriverUnload = FtDiskUnload;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = FtDiskCreate;
    DriverObject->MajorFunction[IRP_MJ_READ] = FtDiskReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = FtDiskReadWrite;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = FtDiskDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = FtDiskInternalDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = FtDiskShutdownFlush;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS] = FtDiskShutdownFlush;
    DriverObject->MajorFunction[IRP_MJ_PNP] = FtDiskPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = FtDiskPower;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = FtDiskCleanup;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = FtWmi;

    ObReferenceObject(DriverObject);

    status = IoReportDetectedDevice(
                 DriverObject,
                 InterfaceTypeUndefined,
                 -1,
                 -1,
                 NULL,
                 NULL,
                 TRUE,
                 &pdo
             );
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = FtDiskAddDevice(DriverObject, pdo);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    fdo = IoGetAttachedDeviceReference(pdo);
    ObDereferenceObject(fdo);

    rootExtension = (PROOT_EXTENSION) fdo->DeviceExtension;

    rootExtension->DiskPerfRegistryPath.MaximumLength =
        RegistryPath->Length + sizeof(UNICODE_NULL);
    rootExtension->DiskPerfRegistryPath.Buffer = (PWSTR)
        ExAllocatePool(PagedPool,
                       rootExtension->DiskPerfRegistryPath.MaximumLength);
    if (rootExtension->DiskPerfRegistryPath.Buffer) {
        RtlCopyUnicodeString(&rootExtension->DiskPerfRegistryPath,
                             RegistryPath);
    } else {
        rootExtension->DiskPerfRegistryPath.Length = 0;
        rootExtension->DiskPerfRegistryPath.MaximumLength = 0;
    }


    status = IoRegisterDeviceInterface(rootExtension->Pdo,
                                       &VOLMGR_VOLUME_MANAGER_GUID, NULL,
                                       &rootExtension->VolumeManagerInterfaceName);
    if (NT_SUCCESS(status)) {
        status = IoSetDeviceInterfaceState(
                 &rootExtension->VolumeManagerInterfaceName, TRUE);
    } else {
        rootExtension->VolumeManagerInterfaceName.Buffer = NULL;
    }

    IoRegisterBootDriverReinitialization(DriverObject,
                                         FtpBootDriverReinitialization,
                                         rootExtension);

    IoRegisterDriverReinitialization(DriverObject, FtpDriverReinitialization,
                                     rootExtension);

    FtpQueryRegistryRevertEntries(rootExtension,
                                  &rootExtension->GptAttributeRevertEntries,
                                  &rootExtension->NumberOfAttributeRevertEntries);

    RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE, RegistryPath->Buffer,
                           REVERT_GPT_ATTRIBUTES_REGISTRY_NAME);

    IoInvalidateDeviceState(rootExtension->Pdo);

    return STATUS_SUCCESS;
}

VOID
FtpLogError(
    IN  PDEVICE_EXTENSION   Extension,
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  NTSTATUS            SpecificIoStatus,
    IN  NTSTATUS            FinalStatus,
    IN  ULONG               UniqueErrorValue
    )

/*++

Routine Description:

    This routine performs error logging for the FT driver.

Arguments:

    Extension        - Extension.
    LogicalDiskId    - Logical disk id representing failing device.
    SpecificIoStatus - IO error status value.
    FinalStatus      - Status returned for failure.
    UniqueErrorValue - Values defined to uniquely identify error location.

Return Value:

    None

--*/

{
    PFTP_LOG_ERROR_CONTEXT  context;

    context = (PFTP_LOG_ERROR_CONTEXT)
              ExAllocatePool(NonPagedPool, sizeof(FTP_LOG_ERROR_CONTEXT));
    if (!context) {
        return;
    }

    ExInitializeWorkItem(context, FtpLogErrorWorker, context);
    context->Extension = Extension;
    context->LogicalDiskId = LogicalDiskId;
    context->SpecificIoStatus = SpecificIoStatus;
    context->FinalStatus = FinalStatus;
    context->UniqueErrorValue = UniqueErrorValue;

    ExQueueWorkItem(context, CriticalWorkQueue);
}

VOID
FtpQueueWorkItem(
    IN  PROOT_EXTENSION     RootExtension,
    IN  PWORK_QUEUE_ITEM    WorkItem
    )

/*++

Routine Description:

    This routine queues a work item to a private worker thread.

Arguments:

    RootExtension       - Supplies the root device extension.

    WorkItem            - The work item to be queued.

Return Value:

    None.

--*/

{
    KIRQL   irql;

    KeAcquireSpinLock(&RootExtension->SpinLock, &irql);
    InsertTailList(&RootExtension->WorkerQueue, &WorkItem->List);
    KeReleaseSpinLock(&RootExtension->SpinLock, irql);

    KeReleaseSemaphore(&RootExtension->WorkerSemaphore, 0, 1, FALSE);
}

VOID
FtpNotify(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine completes all of the change notify irps in the queue.

Arguments:

    RootExtension   - Supplies the root extension.

    Extension       - Supplies the specific extension being changed.

Return Value:

    None.

--*/

{
    LIST_ENTRY                          q;
    KIRQL                               irql;
    PLIST_ENTRY                         p;
    PIRP                                irp;
    TARGET_DEVICE_CUSTOM_NOTIFICATION   notification;

    InitializeListHead(&q);
    IoAcquireCancelSpinLock(&irql);
    while (!IsListEmpty(&RootExtension->ChangeNotifyIrpList)) {
        p = RemoveHeadList(&RootExtension->ChangeNotifyIrpList);
        irp = CONTAINING_RECORD(p, IRP, Tail.Overlay.ListEntry);
        IoSetCancelRoutine(irp, NULL);
        InsertTailList(&q, p);
    }
    IoReleaseCancelSpinLock(irql);

    while (!IsListEmpty(&q)) {
        p = RemoveHeadList(&q);
        irp = CONTAINING_RECORD(p, IRP, Tail.Overlay.ListEntry);
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    if (Extension->IsStarted) {
        notification.Version = 1;
        notification.Size = (USHORT)
                            FIELD_OFFSET(TARGET_DEVICE_CUSTOM_NOTIFICATION,
                                         CustomDataBuffer);
        RtlCopyMemory(&notification.Event,
                      &GUID_IO_VOLUME_PHYSICAL_CONFIGURATION_CHANGE,
                      sizeof(GUID_IO_VOLUME_PHYSICAL_CONFIGURATION_CHANGE));
        notification.FileObject = NULL;
        notification.NameBufferOffset = -1;

        IoReportTargetDeviceChangeAsynchronous(Extension->DeviceObject,
                                               &notification, NULL, NULL);
    }
}

#if DBG

ULONG FtDebug;

VOID
FtDebugPrint(
    ULONG  DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for the Fault Tolerance Driver.

Arguments:

    Debug print level between 0 and N, with N being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;
    char buffer[256];

    va_start( ap, DebugMessage );

    if (DebugPrintLevel <= FtDebug) {
        vsprintf(buffer, DebugMessage, ap);
        DbgPrint(buffer);
    }

    va_end(ap);

} // end FtDebugPrint()

#endif

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

NTSTATUS
FtpCheckForCompleteVolume(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PFT_VOLUME          FtVolume
    )

{
    KIRQL   irql;

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    if (!FtVolume->IsComplete(TRUE)) {
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        return STATUS_NO_SUCH_DEVICE;
    }
    FtVolume->CompleteNotification(TRUE);
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    return STATUS_SUCCESS;
}

BOOLEAN
FsRtlIsTotalDeviceFailure(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine is given an NTSTATUS value and make a determination as to
    if this value indicates that the complete device has failed and therefore
    should no longer be used, or if the failure is one that indicates that
    continued use of the device is ok (i.e. a sector failure).

Arguments:

    Status - the NTSTATUS value to test.

Return Value:

    TRUE  - The status value given is believed to be a fatal device error.
    FALSE - The status value given is believed to be a sector failure, but not
            a complete device failure.
--*/

{
    if (NT_SUCCESS(Status)) {

        //
        // All warning and informational errors will be resolved here.
        //

        return FALSE;
    }

    switch (Status) {
    case STATUS_CRC_ERROR:
    case STATUS_DEVICE_DATA_ERROR:
        return FALSE;
    default:
        return TRUE;
    }
}

BOOLEAN
FtpIsWorseStatus(
    IN  NTSTATUS    Status1,
    IN  NTSTATUS    Status2
    )

/*++

Routine Description:

    This routine compares two NTSTATUS codes and decides if Status1 is
    worse than Status2.

Arguments:

    Status1 - Supplies the first status.

    Status2 - Supplies the second status.

Return Value:

    FALSE   - Status1 is not worse than Status2.

    TRUE    - Status1 is worse than Status2.


--*/

{
    if (NT_ERROR(Status2) && FsRtlIsTotalDeviceFailure(Status2)) {
        return FALSE;
    }

    if (NT_ERROR(Status1) && FsRtlIsTotalDeviceFailure(Status1)) {
        return TRUE;
    }

    if (NT_ERROR(Status2)) {
        return FALSE;
    }

    if (NT_ERROR(Status1)) {
        return TRUE;
    }

    if (NT_WARNING(Status2)) {
        return FALSE;
    }

    if (NT_WARNING(Status1)) {
        return TRUE;
    }

    if (NT_INFORMATION(Status2)) {
        return FALSE;
    }

    if (NT_INFORMATION(Status1)) {
        return TRUE;
    }

    return FALSE;
}

VOID
FtDiskShutdownCompletionRoutine(
    IN  PVOID       Context,
    IN  NTSTATUS    Status
    )

{
    PFTP_SHUTDOWN_CONTEXT   context = (PFTP_SHUTDOWN_CONTEXT) Context;

    if (InterlockedDecrement(&context->RefCount)) {
        return;
    }

    IoCompleteRequest(context->Irp, IO_NO_INCREMENT);
    ExFreePool(context);
}

NTSTATUS
FtpCreateLogicalDiskHelper(
    IN OUT  PROOT_EXTENSION         RootExtension,
    IN      FT_LOGICAL_DISK_TYPE    LogicalDiskType,
    IN      USHORT                  NumberOfMembers,
    IN      PFT_LOGICAL_DISK_ID     ArrayOfMembers,
    IN      USHORT                  ConfigurationInformationSize,
    IN      PVOID                   ConfigurationInformation,
    IN      USHORT                  StateInformationSize,
    IN      PVOID                   StateInformation,
    OUT     PFT_LOGICAL_DISK_ID     NewLogicalDiskId
    )

{
    BOOLEAN                                         lockZero;
    FT_MIRROR_AND_SWP_STATE_INFORMATION             actualStateInfo;
    FT_REDISTRIBUTION_STATE_INFORMATION             redistStateInfo;
    PHANDLE                                         handleArray;
    PFT_LOGICAL_DISK_INFORMATION_SET                diskInfoSet;
    NTSTATUS                                        status;
    FT_LOGICAL_DISK_ID                              newLogicalDiskId;
    PFT_VOLUME*                                     volArray;
    PVOLUME_EXTENSION*                              extArray;
    PVOLUME_EXTENSION                               extension;
    KIRQL                                           irql;
    USHORT                                          i, j;
    KEVENT                                          event;
    PCOMPOSITE_FT_VOLUME                            comp;
    WCHAR                                           deviceNameBuffer[64];
    UNICODE_STRING                                  deviceName;
    UCHAR                                           newUniqueIdBuffer[UNIQUE_ID_MAX_BUFFER_SIZE];
    PMOUNTDEV_UNIQUE_ID                             newUniqueId;
    SET_TARGET_CONTEXT                              context;
    ULONG                                           alignment;
    PFT_REDISTRIBUTION_CONFIGURATION_INFORMATION    redistConfig;
    PFT_REDISTRIBUTION_STATE_INFORMATION            redistState;
    PFT_MIRROR_AND_SWP_STATE_INFORMATION            mirrorState;

    switch (LogicalDiskType) {

        case FtVolumeSet:
            ConfigurationInformation = NULL;
            ConfigurationInformationSize = 0;
            StateInformation = NULL;
            StateInformationSize = 0;
            lockZero = FALSE;
            if (NumberOfMembers == 0) {
                return STATUS_INVALID_PARAMETER;
            }
            break;

        case FtStripeSet:
            if (ConfigurationInformationSize <
                sizeof(FT_STRIPE_SET_CONFIGURATION_INFORMATION)) {

                return STATUS_INVALID_PARAMETER;
            }
            ConfigurationInformationSize =
                    sizeof(FT_STRIPE_SET_CONFIGURATION_INFORMATION);
            StateInformation = NULL;
            StateInformationSize = 0;
            lockZero = TRUE;
            if (NumberOfMembers == 0) {
                return STATUS_INVALID_PARAMETER;
            }
            break;

        case FtMirrorSet:
            if (ConfigurationInformationSize <
                sizeof(FT_MIRROR_SET_CONFIGURATION_INFORMATION)) {

                return STATUS_INVALID_PARAMETER;
            }
            ConfigurationInformationSize =
                    sizeof(FT_MIRROR_SET_CONFIGURATION_INFORMATION);
            if (!StateInformation) {
                actualStateInfo.IsDirty = TRUE;
                actualStateInfo.IsInitializing = FALSE;
                actualStateInfo.UnhealthyMemberNumber = 1;
                actualStateInfo.UnhealthyMemberState = FtMemberRegenerating;
                StateInformation = &actualStateInfo;
                StateInformationSize = sizeof(actualStateInfo);
            }
            lockZero = FALSE;
            if (NumberOfMembers != 2) {
                return STATUS_INVALID_PARAMETER;
            }
            j = NumberOfMembers;
            for (i = 0; i < NumberOfMembers; i++) {
                if (!ArrayOfMembers[i]) {
                    if (j < NumberOfMembers) {
                        return STATUS_INVALID_PARAMETER;
                    }
                    j = i;
                    mirrorState = (PFT_MIRROR_AND_SWP_STATE_INFORMATION)
                                  StateInformation;
                    mirrorState->UnhealthyMemberNumber = i;
                    mirrorState->UnhealthyMemberState = FtMemberOrphaned;
                }
            }
            break;

        case FtStripeSetWithParity:
            if (ConfigurationInformationSize <
                sizeof(FT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION)) {

                return STATUS_INVALID_PARAMETER;
            }
            ConfigurationInformationSize =
                    sizeof(FT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION);
            if (!StateInformation) {
                actualStateInfo.IsDirty = TRUE;
                actualStateInfo.IsInitializing = TRUE;
                actualStateInfo.UnhealthyMemberNumber = 0;
                actualStateInfo.UnhealthyMemberState = FtMemberHealthy;
                StateInformation = &actualStateInfo;
                StateInformationSize = sizeof(actualStateInfo);
            }
            lockZero = TRUE;
            if (NumberOfMembers < 3) {
                return STATUS_INVALID_PARAMETER;
            }
            j = NumberOfMembers;
            for (i = 0; i < NumberOfMembers; i++) {
                if (!ArrayOfMembers[i]) {
                    if (j < NumberOfMembers) {
                        return STATUS_INVALID_PARAMETER;
                    }
                    j = i;
                    mirrorState = (PFT_MIRROR_AND_SWP_STATE_INFORMATION)
                                  StateInformation;
                    mirrorState->IsInitializing = FALSE;
                    mirrorState->UnhealthyMemberNumber = i;
                    mirrorState->UnhealthyMemberState = FtMemberOrphaned;
                }
            }
            break;

        case FtRedistribution:
            if (ConfigurationInformationSize <
                sizeof(FT_REDISTRIBUTION_CONFIGURATION_INFORMATION)) {

                return STATUS_INVALID_PARAMETER;
            }
            ConfigurationInformationSize =
                    sizeof(FT_REDISTRIBUTION_CONFIGURATION_INFORMATION);
            if (!StateInformation) {
                redistStateInfo.BytesRedistributed = 0;
                StateInformation = &redistStateInfo;
                StateInformationSize = sizeof(redistStateInfo);
            }
            redistConfig = (PFT_REDISTRIBUTION_CONFIGURATION_INFORMATION)
                           ConfigurationInformation;
            if (redistConfig->StripeSize&0x80000000) {
                lockZero = TRUE;
                redistConfig->StripeSize &= (~0x80000000);
                redistState = (PFT_REDISTRIBUTION_STATE_INFORMATION)
                              StateInformation;
                redistState->BytesRedistributed = 0x7FFFFFFFFFFFFFFF;
            } else {
                lockZero = FALSE;
            }
            if (NumberOfMembers != 2) {
                return STATUS_INVALID_PARAMETER;
            }
            break;

        default:
            return STATUS_INVALID_PARAMETER;

    }

    handleArray = (PHANDLE)
                  ExAllocatePool(NonPagedPool, NumberOfMembers*sizeof(HANDLE));
    if (!handleArray) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (i = lockZero ? 0 : 1; i < NumberOfMembers; i++) {
        if (!ArrayOfMembers[i]) {
            continue;
        }
        if (!FtpLockLogicalDisk(RootExtension, ArrayOfMembers[i],
                                &handleArray[i])) {
            break;
        }
    }

    if (i < NumberOfMembers) {
        for (j = lockZero ? 0 : 1; j < i; j++) {
            if (ArrayOfMembers[j]) {
                ZwClose(handleArray[j]);
            }
        }
        ExFreePool(handleArray);
        return STATUS_ACCESS_DENIED;
    }

    if (LogicalDiskType == FtMirrorSet &&
        ArrayOfMembers[0] &&
        !(extension = FtpFindExtension(RootExtension, ArrayOfMembers[0])) &&
        (extension = FtpFindExtensionCoveringDiskId(RootExtension,
                                                    ArrayOfMembers[0]))) {

        status = FtpInsertMirror(RootExtension, ArrayOfMembers,
                                 NewLogicalDiskId);

        if (ArrayOfMembers[1]) {
            ZwClose(handleArray[1]);
        }
        ExFreePool(handleArray);
        return status;
    }

    diskInfoSet = RootExtension->DiskInfoSet;
    status = diskInfoSet->AddNewLogicalDisk(LogicalDiskType,
                                            NumberOfMembers,
                                            ArrayOfMembers,
                                            ConfigurationInformationSize,
                                            ConfigurationInformation,
                                            StateInformationSize,
                                            StateInformation,
                                            &newLogicalDiskId);
    if (!NT_SUCCESS(status)) {
        for (i = lockZero ? 0 : 1; i < NumberOfMembers; i++) {
            if (ArrayOfMembers[i]) {
                ZwClose(handleArray[i]);
            }
        }
        ExFreePool(handleArray);
        return status;
    }

    volArray = (PFT_VOLUME*)
               ExAllocatePool(NonPagedPool, NumberOfMembers*sizeof(PFT_VOLUME));
    if (!volArray) {
        for (i = lockZero ? 0 : 1; i < NumberOfMembers; i++) {
            if (ArrayOfMembers[i]) {
                ZwClose(handleArray[i]);
            }
        }
        ExFreePool(handleArray);
        diskInfoSet->BreakLogicalDisk(newLogicalDiskId);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    extArray = (PVOLUME_EXTENSION*)
               ExAllocatePool(NonPagedPool, NumberOfMembers*
                              sizeof(PVOLUME_EXTENSION));
    if (!extArray) {
        for (i = lockZero ? 0 : 1; i < NumberOfMembers; i++) {
            if (ArrayOfMembers[i]) {
                ZwClose(handleArray[i]);
            }
        }
        ExFreePool(handleArray);
        ExFreePool(volArray);
        diskInfoSet->BreakLogicalDisk(newLogicalDiskId);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    alignment = 0;
    for (i = 0; i < NumberOfMembers; i++) {

        if (!ArrayOfMembers[i]) {
            extArray[i] = NULL;
            volArray[i] = NULL;
            continue;
        }

        extension = FtpFindExtension(RootExtension, ArrayOfMembers[i]);
        extArray[i] = extension;
        if (!extension || !extension->FtVolume) {
            break;
        }

        alignment |= extension->DeviceObject->AlignmentRequirement;

        volArray[i] = extension->FtVolume;
        if (!lockZero && i == 0) {
            continue;
        }

        KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
        context.TargetObject = NULL;
        context.FtVolume = NULL;
        context.WholeDiskPdo = NULL;
        FtpZeroRefCallback(extension, FtpSetTargetCallback, &context, TRUE);
        KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE,
                              NULL);
    }

    if (i < NumberOfMembers) {
        for (j = 0; j < i; j++) {
            if (ArrayOfMembers[j]) {
                KeAcquireSpinLock(&extArray[j]->SpinLock, &irql);
                extArray[j]->FtVolume = volArray[j];
                KeReleaseSpinLock(&extArray[j]->SpinLock, irql);
            }
        }
        for (i = lockZero ? 0 : 1; i < NumberOfMembers; i++) {
            if (ArrayOfMembers[i]) {
                ZwClose(handleArray[i]);
            }
        }
        ExFreePool(handleArray);
        ExFreePool(extArray);
        ExFreePool(volArray);
        diskInfoSet->BreakLogicalDisk(newLogicalDiskId);
        return STATUS_INVALID_PARAMETER;
    }

    switch (LogicalDiskType) {

        case FtVolumeSet:
            comp = new VOLUME_SET;
            break;

        case FtStripeSet:
            comp = new STRIPE;
            break;

        case FtMirrorSet:
            comp = new MIRROR;
            break;

        case FtStripeSetWithParity:
            comp = new STRIPE_WP;
            break;

        case FtRedistribution:
            comp = new REDISTRIBUTION;
            break;

        default:
            comp = NULL;
            break;

    }

    if (!comp) {
        for (j = 0; j < NumberOfMembers; j++) {
            if (ArrayOfMembers[j]) {
                KeAcquireSpinLock(&extArray[j]->SpinLock, &irql);
                extArray[j]->FtVolume = volArray[j];
                KeReleaseSpinLock(&extArray[j]->SpinLock, irql);
            }
        }
        for (i = lockZero ? 0 : 1; i < NumberOfMembers; i++) {
            if (ArrayOfMembers[i]) {
                ZwClose(handleArray[i]);
            }
        }
        ExFreePool(handleArray);
        ExFreePool(extArray);
        ExFreePool(volArray);
        diskInfoSet->BreakLogicalDisk(newLogicalDiskId);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = comp->Initialize(RootExtension, newLogicalDiskId,
                              volArray, NumberOfMembers,
                              ConfigurationInformation, StateInformation);
    if (!NT_SUCCESS(status)) {
        for (j = 0; j < NumberOfMembers; j++) {
            if (ArrayOfMembers[j]) {
                KeAcquireSpinLock(&extArray[j]->SpinLock, &irql);
                extArray[j]->FtVolume = volArray[j];
                KeReleaseSpinLock(&extArray[j]->SpinLock, irql);
            }
        }
        for (i = lockZero ? 0 : 1; i < NumberOfMembers; i++) {
            if (ArrayOfMembers[i]) {
                ZwClose(handleArray[i]);
            }
        }
        delete comp;
        ExFreePool(handleArray);
        ExFreePool(extArray);
        diskInfoSet->BreakLogicalDisk(newLogicalDiskId);
        return status;
    }

    for (i = lockZero ? 0 : 1; i < NumberOfMembers; i++) {
        extension = extArray[i];
        if (!extension) {
            continue;
        }
        RemoveEntryList(&extension->ListEntry);
        InsertTailList(&RootExtension->DeadVolumeList, &extension->ListEntry);
        FtpDeleteMountPoints(extension);
        FtpCleanupVolumeExtension(extension);
        ZwClose(handleArray[i]);
    }
    ExFreePool(handleArray);

    extension = extArray[0];
    ExFreePool(extArray);

    if (lockZero || !extension) {

        if (!FtpCreateNewDevice(RootExtension, NULL, comp, NULL, alignment,
                                FALSE, FALSE, FALSE, FALSE, 0)) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        swprintf(deviceNameBuffer, L"\\Device\\HarddiskVolume%d", extension->VolumeNumber);
        RtlInitUnicodeString(&deviceName, deviceNameBuffer);
        comp->CreateLegacyNameLinks(&deviceName);

        extension->DeviceObject->AlignmentRequirement = alignment;

        KeInitializeEvent(&context.Event, NotificationEvent, FALSE);
        context.TargetObject = NULL;
        context.FtVolume = comp;
        context.WholeDiskPdo = NULL;
        FtpZeroRefCallback(extension, FtpSetTargetCallback, &context, TRUE);
        KeWaitForSingleObject(&context.Event, Executive, KernelMode, FALSE,
                              NULL);

        newUniqueId = (PMOUNTDEV_UNIQUE_ID) newUniqueIdBuffer;
        FtpQueryUniqueIdBuffer(extension, newUniqueId->UniqueId,
                               &newUniqueId->UniqueIdLength);

        FtpUniqueIdNotify(extension, newUniqueId);

        FtpNotify(RootExtension, extension);
    }

    *NewLogicalDiskId = newLogicalDiskId;

    IoInvalidateDeviceRelations(RootExtension->Pdo, BusRelations);

    return STATUS_SUCCESS;
}

VOID
FtpMemberOfflineCallback(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine is called to offline a partition after disk activity
    has stopped.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    None.

--*/

{
    PFT_PARTITION_OFFLINE_CONTEXT   offline = (PFT_PARTITION_OFFLINE_CONTEXT) Extension->ZeroRefContext;
    USHORT                          n, i;

    if (offline->Parent) {
        Extension->IsComplete = FALSE;
        n = offline->Parent->QueryNumberOfMembers();
        for (i = 0; i < n; i++) {
            if (offline->Parent->GetMember(i) == offline->Child) {
                offline->Parent->SetMember(i, NULL);
                break;
            }
        }
        if (!offline->Root->QueryNumberOfPartitions()) {
            Extension->FtVolume = NULL;
        }
    } else {
        Extension->FtVolume = NULL;
        Extension->IsComplete = FALSE;
    }

    KeSetEvent(offline->Event, IO_NO_INCREMENT, FALSE);
}

VOID
FtpInsertMemberCallback(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine inserts the given member into the given set.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    None.

--*/

{
    PINSERT_MEMBER_CONTEXT  context = (PINSERT_MEMBER_CONTEXT) Extension->ZeroRefContext;

    context->Parent->SetMember(context->MemberNumber, context->Member);
    KeSetEvent(&context->Event, IO_NO_INCREMENT, FALSE);
}

VOID
FtpReadWriteCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for FtDiskReadWrite dispatch routine.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PDISPATCH_TP                transferPacket = (PDISPATCH_TP) TransferPacket;
    PIRP                        irp = transferPacket->Irp;
    PVOLUME_EXTENSION           extension = transferPacket->Extension;
    KIRQL                       irql;
    PLIST_ENTRY                 l;
    PDISPATCH_TP                p;
    PIO_STACK_LOCATION          irpSp;
    PIRP                        nextIrp;

    irp->IoStatus = transferPacket->IoStatus;
    if (transferPacket == extension->EmergencyTransferPacket) {

        for (;;) {

            KeAcquireSpinLock(&extension->SpinLock, &irql);
            if (IsListEmpty(&extension->EmergencyTransferPacketQueue)) {
                extension->EmergencyTransferPacketInUse = FALSE;
                KeReleaseSpinLock(&extension->SpinLock, irql);
                break;
            }

            l = RemoveHeadList(&extension->EmergencyTransferPacketQueue);
            KeReleaseSpinLock(&extension->SpinLock, irql);

            nextIrp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);

            p = new DISPATCH_TP;
            if (!p) {
                p = transferPacket;
            }

            irpSp = IoGetCurrentIrpStackLocation(nextIrp);

            p->Mdl = nextIrp->MdlAddress;
            p->Offset = irpSp->Parameters.Read.ByteOffset.QuadPart;
            p->Length = irpSp->Parameters.Read.Length;
            p->CompletionRoutine = FtpReadWriteCompletionRoutine;
            p->TargetVolume = extension->FtVolume;
            p->Thread = nextIrp->Tail.Overlay.Thread;
            p->IrpFlags = irpSp->Flags;
            if (irpSp->MajorFunction == IRP_MJ_READ) {
                p->ReadPacket = TRUE;
            } else {
                p->ReadPacket = FALSE;
            }
            p->Irp = nextIrp;
            p->Extension = extension;

            if (p == transferPacket) {
                TRANSFER(p);
                break;
            } else {
                TRANSFER(p);
            }
        }

    } else {
        delete transferPacket;
    }

    if (extension->CountersEnabled) {
        PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(irp);
        if (irpStack->MajorFunction == IRP_MJ_READ ||
            irpStack->MajorFunction == IRP_MJ_WRITE) {
            PPMWMICOUNTERLIB_CONTEXT counterLib;
    
            counterLib = &extension->Root->PmWmiCounterLibContext;
            counterLib->PmWmiCounterIoComplete(
                extension->PmWmiCounterContext, irp,
                (PLARGE_INTEGER) &irpStack->Parameters.Read);
        }
    }

    IoCompleteRequest(irp, IO_DISK_INCREMENT);

    FtpDecrementRefCount(extension);
}

VOID
FtpRefCountCompletion(
    IN  PVOID       Extension,
    IN  NTSTATUS    Status
    )

/*++

Routine Description:

    Completion routine of type FT_COMPLETION_ROUTINE that decrements
    the ref count.

Arguments:

    Extension   - Supplies the device extension.

    Status      - Supplies the status of the operation.

Return Value:

    None.

--*/

{
    PVOLUME_EXTENSION   extension = (PVOLUME_EXTENSION) Extension;

    FtpDecrementRefCount(extension);
}

NTSTATUS
FtpAddPartition(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PDEVICE_OBJECT      Partition,
    IN  PDEVICE_OBJECT      WholeDiskPdo
    )

/*++

Routine Description:

    This routine adds the given partition to the given ft set.

Arguments:

    Extension       - Supplies the extension where the FT set is rooted.

    Partition       - Supplies the new partition.

    WholeDiskPdo    - Supplies the whole disk PDO.

Return Value:

    NTSTATUS

--*/

{
    PFT_VOLUME                          vol = Extension->FtVolume;
    PROOT_EXTENSION                     rootExtension = Extension->Root;
    PFT_LOGICAL_DISK_INFORMATION_SET    diskInfoSet = rootExtension->DiskInfoSet;
    NTSTATUS                            status;
    ULONG                               diskNumber, n;
    LONGLONG                            offset;
    FT_LOGICAL_DISK_ID                  partitionDiskId, diskId;
    PFT_LOGICAL_DISK_DESCRIPTION        parentDesc;
    PFT_VOLUME                          parent, child, c;
    BOOLEAN                             inPagingPath, wasStarted;
    KIRQL                               irql;
    PDEVICE_OBJECT                      leftmost;
    BOOLEAN                             nameChange;
    WCHAR                               deviceNameBuffer[64];
    UNICODE_STRING                      deviceName;
    UCHAR                               registryState[100];
    USHORT                              registryStateSize;

    status = FtpQueryPartitionInformation(Extension->Root,
                                          Partition, &diskNumber, &offset,
                                          NULL, NULL, NULL, NULL, NULL, NULL,
                                          NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    partitionDiskId = diskId =
            diskInfoSet->QueryPartitionLogicalDiskId(diskNumber, offset);
    if (!diskId) {
        return STATUS_INVALID_PARAMETER;
    }

    for (;;) {
        parentDesc = diskInfoSet->GetParentLogicalDiskDescription(diskId);
        if (!parentDesc) {
            return STATUS_INVALID_PARAMETER;
        }
        parent = vol->GetContainedLogicalDisk(parentDesc->LogicalDiskId);
        if (parent) {
            break;
        }
        diskId = parentDesc->LogicalDiskId;
    }

    child = FtpBuildFtVolume(rootExtension, diskId, Partition, WholeDiskPdo);
    if (!child) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    parent->SetMember(parentDesc->u.Other.ThisMemberNumber, child);
    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    if (!Extension->IsComplete) {
        KeReleaseSpinLock(&Extension->SpinLock, irql);

        leftmost = Extension->FtVolume->GetLeftmostPartitionObject();

        KeAcquireSpinLock(&Extension->SpinLock, &irql);
        if (!Extension->IsComplete) {

            parentDesc = diskInfoSet->GetParentLogicalDiskDescription(
                         partitionDiskId, &n);
            while (parentDesc) {

                if (parentDesc->u.Other.ByteOffsetToStateInformation &&
                    (c = vol->GetContainedLogicalDisk(parentDesc->LogicalDiskId))) {

                    c->NewStateArrival((PCHAR) parentDesc +
                            parentDesc->u.Other.ByteOffsetToStateInformation);

                    KeReleaseSpinLock(&Extension->SpinLock, irql);

                    if (FtpQueryStateFromRegistry(parentDesc->LogicalDiskId,
                                                  &registryState,
                                                  sizeof(registryState),
                                                  &registryStateSize)) {

                        KeAcquireSpinLock(&Extension->SpinLock, &irql);
                        if (Extension->IsComplete) {
                            break;
                        }

                        if (!Extension->IsOffline) {
                            c->NewStateArrival(&registryState);
                        }

                    } else {
                        KeAcquireSpinLock(&Extension->SpinLock, &irql);
                        if (Extension->IsComplete) {
                            break;
                        }
                    }
                }

                parentDesc = diskInfoSet->GetParentLogicalDiskDescription(
                             parentDesc, n);
            }
        }
    }

    if (Extension->IsComplete) {

        KeReleaseSpinLock(&Extension->SpinLock, irql);

        status = FtpAllSystemsGo(Extension, NULL, TRUE, TRUE, TRUE);
        if (NT_SUCCESS(status)) {
            vol->StartSyncOperations(FALSE, FtpRefCountCompletion,
                                     Extension);
        }

        KeAcquireSpinLock(&Extension->SpinLock, &irql);

    }

    inPagingPath = Extension->InPagingPath;
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    if (inPagingPath) {
        FtpSendPagingNotification(Partition);
    }

    swprintf(deviceNameBuffer, L"\\Device\\HarddiskVolume%d", Extension->VolumeNumber);
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);
    child->CreateLegacyNameLinks(&deviceName);

    Extension->DeviceObject->AlignmentRequirement |=
            Partition->AlignmentRequirement;

    return STATUS_SUCCESS;
}

VOID
FtpPropogateRegistryState(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PFT_VOLUME          Volume
    )

{
    UCHAR       state[100];
    USHORT      stateSize;
    KIRQL       irql;
    USHORT      n, i;
    PFT_VOLUME  vol;

    if (Volume->QueryLogicalDiskType() == FtPartition) {
        return;
    }

    if (FtpQueryStateFromRegistry(Volume->QueryLogicalDiskId(), state,
                                  100, &stateSize)) {

        KeAcquireSpinLock(&Extension->SpinLock, &irql);
        if (!Extension->IsComplete) {
            Volume->NewStateArrival(state);
        }
        KeReleaseSpinLock(&Extension->SpinLock, irql);
    }

    n = Volume->QueryNumberOfMembers();
    for (i = 0; i < n; i++) {
        vol = Volume->GetMember(i);
        if (!vol) {
            continue;
        }

        FtpPropogateRegistryState(Extension, vol);

    }
}

VOID
FtpComputeParity(
    IN  PVOID   TargetBuffer,
    IN  PVOID   SourceBuffer,
    IN  ULONG   BufferLength
    )

/*++

Routine Description:

    This routine computes the parity of the source and target buffers
    and places the result of the computation into the target buffer.
    I.E.  TargetBuffer ^= SourceBuffer.

Arguments:

    TargetBuffer    - Supplies the target buffer.

    SourceBuffer    - Supplies the source buffer.

    BufferLength    - Supplies the buffer length.

Return Value:

    None.

--*/

{
    PULONGLONG  p, q;
    ULONG       i, n;

    ASSERT(sizeof(ULONGLONG) == 8);

    p = (PULONGLONG) TargetBuffer;
    q = (PULONGLONG) SourceBuffer;
    n = BufferLength/128;
    ASSERT(BufferLength%128 == 0);
    for (i = 0; i < n; i++) {
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
        *p++ ^= *q++;
    }
}

NTSTATUS
FtpReadPartitionTableEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDRIVE_LAYOUT_INFORMATION_EX* DriveLayout
    )

/*++

Routine Description:

    This routine reads the partition table for the disk.

    The partition list is built in nonpaged pool that is allocated by this
    routine. It is the caller's responsability to free this memory when it
    is finished with the data.

Arguments:

    DeviceObject - Pointer for device object for this disk.

    DriveLayout - Pointer to the pointer that will return the patition list.
            This buffer is allocated in nonpaged pool by this routine. It is
            the responsability of the caller to free this memory if this
            routine is successful.

Return Values:

    Status.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    PIRP Irp;
    KEVENT Event;
    PVOID IoCtlBuffer;
    ULONG IoCtlBufferSize;
    ULONG NewAllocationSize;
    ULONG NumTries;

    //
    // Initialize locals.
    //

    NumTries = 0;
    IoCtlBuffer = NULL;
    IoCtlBufferSize = 0;
    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    //
    // Initialize the IOCTL buffer.
    //

    IoCtlBuffer = ExAllocatePoolWithTag(NonPagedPool, 
                                        PAGE_SIZE,
                                        FTDISK_TAG_IOCTL_BUFFER);
    
    if (!IoCtlBuffer) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }
    
    IoCtlBufferSize = PAGE_SIZE;

    //
    // First try to get the partition table by issuing an IOCTL.
    //
    
    do {

        //
        // Make sure the event is reset.
        //

        KeClearEvent(&Event);

        //
        // Build an IOCTL Irp.
        //

        Irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                            DeviceObject,
                                            NULL, 
                                            0, 
                                            IoCtlBuffer, 
                                            IoCtlBufferSize, 
                                            FALSE,
                                            &Event, 
                                            &IoStatus);
        if (!Irp) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        //
        // Call the driver.
        //

        Status = IoCallDriver(DeviceObject, Irp);

        if (Status == STATUS_PENDING) {
            KeWaitForSingleObject(&Event, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);

            //
            // Update status.
            //
            
            Status = IoStatus.Status;
        }
    
        if (NT_SUCCESS(Status)) {
            
            //
            // We got it!
            //

            break;
        }

        if (Status != STATUS_BUFFER_TOO_SMALL) {
            
            //
            // It is a real error.
            //

            goto cleanup;
        }

        //
        // Resize IOCTL buffer. We should not enter the loop with a
        // NULL buffer.
        //

        ASSERT(IoCtlBuffer && IoCtlBufferSize);

        NewAllocationSize = IoCtlBufferSize * 2;

        ExFreePool(IoCtlBuffer);
        IoCtlBufferSize = 0;
        
        IoCtlBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                            NewAllocationSize,
                                            FTDISK_TAG_IOCTL_BUFFER);
        
        if (!IoCtlBuffer) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }
        
        IoCtlBufferSize = NewAllocationSize;

        //
        // Try again with the new buffer but do not loop forever.
        //

        NumTries++;

        if (NumTries > 32) {
            Status = STATUS_UNSUCCESSFUL;
            goto cleanup;
        }

    } while (TRUE);

    //
    // If we came here we should have acquired the partition tables in
    // IoCtlBuffer.
    //
    
    ASSERT(NT_SUCCESS(Status));
    ASSERT(IoCtlBuffer && IoCtlBufferSize);
    
    //
    // Set the output parameter and clear IoCtlBuffer so we don't free
    // it when we are cleaning up.
    //

    (*DriveLayout) = (PDRIVE_LAYOUT_INFORMATION_EX) IoCtlBuffer;

    IoCtlBuffer = NULL;
    IoCtlBufferSize = 0;

    Status = STATUS_SUCCESS;

 cleanup:
    
    if (IoCtlBuffer) {
        ASSERT(IoCtlBufferSize);
        ExFreePool(IoCtlBuffer);
    }

    //
    // If we were not successful with the IOCTL, pass the request off
    // to IoReadPartitionTableEx.
    //

    if (!NT_SUCCESS(Status)) {
        
        Status = IoReadPartitionTableEx(DeviceObject,
                                        DriveLayout);

    }
    
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\newft\ftvol.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    ftvol.cxx

Abstract:

    This module contains the code specific to all volume objects.

Author:

    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

VOID
FT_VOLUME::Initialize(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This is the init routine for an FT_VOLUME.  It must be called before
    the FT_VOLUME is used.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id for this volume.

Return Value:

    None.

--*/

{
    KeInitializeSpinLock(&_spinLock);
    _diskInfoSet = RootExtension->DiskInfoSet;
    _rootExtension = RootExtension;
    _logicalDiskId = LogicalDiskId;
}

BOOLEAN
FT_VOLUME::IsVolumeSuitableForRegenerate(
    IN  USHORT      MemberNumber,
    IN  PFT_VOLUME  Volume
    )

/*++

Routine Description:

    This routine computes whether or not the given volume is suitable
    for a regenerate operation.

Arguments:

    MemberNumber    - Supplies the member number.

    Volume          - Supplies the volume.

Return Value:

    FALSE   - The volume is not suitable.

    TRUE    - The volume is suitable.

--*/

{
    return FALSE;
}

VOID
FT_VOLUME::ModifyStateForUser(
    IN OUT  PVOID   State
    )

/*++

Routine Description:

    This routine modifies the state for the user to see, possibly adding
    non-persistant state different than what is stored on disk.

Arguments:

    State   - Supplies and returns the state for the logical disk.

Return Value:

    None.

--*/

{
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

PVOID
FT_BASE_CLASS::operator new(
    IN  size_t    Size
    )

/*++

Routine Description:

    This routine is the memory allocator for all classes derived from
    FT_VOLUME.

Arguments:

    Size    - Supplies the number of bytes to allocate.

Return Value:

    A pointer to Size bytes of non-paged pool.

--*/

{
    return ExAllocatePool(NonPagedPool, Size);
}

VOID
FT_BASE_CLASS::operator delete(
    IN  PVOID   MemPtr
    )

/*++

Routine Description:

    This routine frees memory allocated for all classes derived from
    FT_VOLUME.

Arguments:

    MemPtr  - Supplies a pointer to the memory to free.

Return Value:

    None.

--*/

{
    if (MemPtr) {
        ExFreePool(MemPtr);
    }
}


FT_LOGICAL_DISK_ID
FT_VOLUME::QueryLogicalDiskId(
    )
{
    KIRQL               irql;
    FT_LOGICAL_DISK_ID  r;

    KeAcquireSpinLock(&_spinLock, &irql);
    r = _logicalDiskId;
    KeReleaseSpinLock(&_spinLock, irql);

    return r;
}

VOID
FT_VOLUME::SetLogicalDiskId(
    IN  FT_LOGICAL_DISK_ID  NewLogicalDiskId
    )
{
    KIRQL   irql;

    KeAcquireSpinLock(&_spinLock, &irql);
    _logicalDiskId = NewLogicalDiskId;
    KeReleaseSpinLock(&_spinLock, irql);
}

VOID
FtVolumeNotifyWorker(
    IN  PVOID   FtVolume
    )

/*++

Routine Description:

    This is the worker routine to signal a notify on the given volume
    object.

Arguments:

    FtVolume    - Supplies the FT volume.

Return Value:

    None.

--*/

{
    PFT_VOLUME          vol = (PFT_VOLUME) FtVolume;
    PVOLUME_EXTENSION   extension;

    FtpAcquire(vol->_rootExtension);
    extension = FtpFindExtensionCoveringDiskId(vol->_rootExtension,
                                               vol->QueryLogicalDiskId());
    FtpRelease(vol->_rootExtension);

    if (extension) {
        FtpNotify(extension->Root, extension);
    }

    if (!InterlockedDecrement(&vol->_refCount)) {
        delete vol;
    }
}

VOID
FT_VOLUME::Notify(
    )

/*++

Routine Description:

    This routine is called when a sub class would like to post notification
    about a state change.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PWORK_QUEUE_ITEM    workItem;

    workItem = (PWORK_QUEUE_ITEM)
               ExAllocatePool(NonPagedPool, sizeof(WORK_QUEUE_ITEM));
    if (!workItem) {
        return;
    }
    ExInitializeWorkItem(workItem, FtVolumeNotifyWorker, this);

    InterlockedIncrement(&_refCount);

    FtpQueueWorkItem(_rootExtension, workItem);
}

VOID
FT_VOLUME::NewStateArrival(
    IN  PVOID   NewStateInstance
    )

/*++

Routine Description:

    This routine takes the new state instance arrival combined with its
    current state to come up with the new current state for the volume.
    If the two states cannot be reconciled then this routine returns FALSE
    indicating that the volume is invalid and should be broken into its
    constituant parts.

Arguments:

    NewStateInstance    - Supplies the new state instance.

Return Value:

    None.

--*/

{
}

FT_VOLUME::~FT_VOLUME(
    )

/*++

Routine Description:

    Desctructor for FT_VOLUME.

Arguments:

    None.

Return Value:

    None.

--*/

{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\newft\ftwmireg.h ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    ftwmireg.h

Abstract:

    This file contains prototypes for routines to register for and response 
    to WMI queries.

Author:

    Bruce Worthington      26-Oct-1998

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {

#include <ntddk.h>


NTSTATUS FtRegisterDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
FtQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
FtQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

BOOLEAN
FtQueryEnableAlways(
    IN PDEVICE_OBJECT DeviceObject
    );

extern WMIGUIDREGINFO DiskperfGuidList[];

extern ULONG DiskperfGuidCount;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\newft\mirror.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    mirror.cxx

Abstract:

    This module contains the code specific to mirrors for the fault
    tolerance driver.

Author:

    Bob Rinne   (bobri)  2-Feb-1992
    Mike Glass  (mglass)
    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
MIRROR::Initialize(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN OUT  PFT_VOLUME*         VolumeArray,
    IN      USHORT              ArraySize,
    IN      PVOID               ConfigInfo,
    IN      PVOID               StateInfo
    )

/*++

Routine Description:

    Initialize routine for FT_VOLUME of type MIRROR.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id for this volume.

    VolumeArray     - Supplies the array of volumes for this volume set.

    ArraySize       - Supplies the number of volumes in the volume array.

    ConfigInfo      - Supplies the configuration information.

    StateInfo       - Supplies the state information.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                                    status;
    PFT_MIRROR_SET_CONFIGURATION_INFORMATION    config;

    if (ArraySize != 2) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!VolumeArray[0] && !VolumeArray[1]) {
        return STATUS_INVALID_PARAMETER;
    }

    status = COMPOSITE_FT_VOLUME::Initialize(RootExtension, LogicalDiskId,
                                             VolumeArray, ArraySize,
                                             ConfigInfo, StateInfo);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    config = (PFT_MIRROR_SET_CONFIGURATION_INFORMATION) ConfigInfo;

    _volumeSize = config->MemberSize;
    _requestCount[0] = 0;
    _requestCount[1] = 0;
    _lastPosition[0] = 0;
    _lastPosition[1] = 0;

    if (VolumeArray[0] && VolumeArray[0]->QueryVolumeSize() < _volumeSize) {
        return STATUS_INVALID_PARAMETER;
    }
    if (VolumeArray[1] && VolumeArray[1]->QueryVolumeSize() < _volumeSize) {
        return STATUS_INVALID_PARAMETER;
    }

    RtlCopyMemory(&_state, StateInfo,
                  sizeof(FT_MIRROR_AND_SWP_STATE_INFORMATION));

    _originalDirtyBit = _state.IsDirty;
    _orphanedBecauseOfMissingMember = FALSE;
    _syncOk = TRUE;
    _balancedReads = _state.IsDirty ? FALSE : TRUE;
    _stopSyncs = FALSE;

    _ePacket = new MIRROR_TP;
    if (!_ePacket) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    _ePacket2 = new MIRROR_TP;
    if (!_ePacket2) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    _ePacketInUse = FALSE;
    InitializeListHead(&_ePacketQueue);

    _eRecoverPacket = new MIRROR_RECOVER_TP;
    if (!_eRecoverPacket) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!_eRecoverPacket->AllocateMdls(QuerySectorSize())) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    _eRecoverPacketInUse = FALSE;
    InitializeListHead(&_eRecoverPacketQueue);

    status = _overlappedIoManager.Initialize(0);

    return status;
}

FT_LOGICAL_DISK_TYPE
MIRROR::QueryLogicalDiskType(
    )

/*++

Routine Description:

    This routine returns the type of the logical disk.

Arguments:

    None.

Return Value:

    The type of the logical disk.

--*/

{
    return FtMirrorSet;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

MIRROR::~MIRROR(
    )

{
    if (_ePacket) {
        delete _ePacket;
        _ePacket = NULL;
    }
    if (_ePacket2) {
        delete _ePacket2;
        _ePacket2 = NULL;
    }
    if (_eRecoverPacket) {
        delete _eRecoverPacket;
        _eRecoverPacket = NULL;
    }
}

NTSTATUS
MIRROR::OrphanMember(
    IN  USHORT                  MemberNumber,
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine tries to orphan the given member of this logical disk. 
    A completion routine will be called if and only if this attempt is successful.

Arguments:

    MemberNumber        - Supplies the member number to orphan.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the completion routine context.

Return Value:

    NTSTATUS

--*/

{
    KIRQL       irql;
    NTSTATUS    status = STATUS_SUCCESS;
    BOOLEAN     b;

    if (MemberNumber >= 2) {
        return STATUS_INVALID_PARAMETER;
    }

    KeAcquireSpinLock(&_spinLock, &irql);
    b = SetMemberState(MemberNumber, FtMemberOrphaned);
    KeReleaseSpinLock(&_spinLock, irql);

    if (b) {
        PropogateStateChanges(CompletionRoutine, Context);
        Notify();
        FtpLogError(_rootExtension, QueryLogicalDiskId(),
                    FT_ORPHANING, STATUS_SUCCESS, 2);
    }

    return b ? STATUS_SUCCESS : STATUS_INVALID_PARAMETER;
}

VOID
MirrorCompositeVolumeCompletionRoutine(
    IN  PVOID       Context,
    IN  NTSTATUS    Status
    )

{
    PFT_COMPLETION_ROUTINE_CONTEXT  context;
    KIRQL                           irql;
    LONG                            count;

    context = (PFT_COMPLETION_ROUTINE_CONTEXT) Context;

    KeAcquireSpinLock(&context->SpinLock, &irql);
    if (!NT_SUCCESS(Status) &&
        FtpIsWorseStatus(Status, context->Status)) {

        context->Status = Status;
    }

    count = --context->RefCount;
    KeReleaseSpinLock(&context->SpinLock, irql);

    if (!count) {
        context->CompletionRoutine(context->Context, STATUS_SUCCESS);
        ExFreePool(context);
    }
}

VOID
FinishRegenerate(
    IN  PMIRROR                         Mirror,
    IN  PFT_COMPLETION_ROUTINE_CONTEXT  RegenContext,
    IN  PMIRROR_TP                      TransferPacket
    )

{
    PMIRROR     t = Mirror;

    delete TransferPacket;
    MirrorCompositeVolumeCompletionRoutine(RegenContext, STATUS_SUCCESS);
}

VOID
MirrorRegenerateCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    );

VOID
MirrorRegeneratePhase1(
    IN  PTRANSFER_PACKET    TransferPacket
    )

{
    TransferPacket->CompletionRoutine = MirrorRegenerateCompletionRoutine;
    TRANSFER(TransferPacket);
}

VOID
MirrorRegenerateCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for MIRROR::RestartRegenerations routine.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_TP                      transferPacket = (PMIRROR_TP) TransferPacket;
    PFT_COMPLETION_ROUTINE_CONTEXT  context = (PFT_COMPLETION_ROUTINE_CONTEXT) transferPacket->MasterPacket;
    PMIRROR                         t = transferPacket->Mirror;
    KIRQL                           irql;
    PLIST_ENTRY                     l;
    PMIRROR_TP                      packet;
    BOOLEAN                         b;

    if (!NT_SUCCESS(transferPacket->IoStatus.Status)) {

        // We can't get a VERIFY_REQUIRED because we put IrpFlags equal
        // to SL_OVERRIDE_VERIFY_VOLUME.

        ASSERT(transferPacket->IoStatus.Status != STATUS_VERIFY_REQUIRED);

        if (FsRtlIsTotalDeviceFailure(transferPacket->IoStatus.Status)) {

            KeAcquireSpinLock(&t->_spinLock, &irql);
            b = t->SetMemberState(transferPacket->WhichMember, FtMemberOrphaned);
            t->_syncOk = TRUE;
            KeReleaseSpinLock(&t->_spinLock, irql);

            if (b) {
                t->PropogateStateChanges(NULL, NULL);
                t->Notify();
                FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                            FT_ORPHANING, STATUS_SUCCESS, 3);
                IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
            }

            FinishRegenerate(t, context, transferPacket);
            return;
        }

        // Transfer the maximum amount that we can.  This will always
        // complete successfully.

        t->MaxTransfer(transferPacket);
        return;
    }

    // Set up for the next packet.

    transferPacket->Thread = PsGetCurrentThread();
    transferPacket->ReadPacket = !transferPacket->ReadPacket;
    transferPacket->WhichMember = (transferPacket->WhichMember + 1)%2;
    transferPacket->TargetVolume = t->GetMemberUnprotected(
                                   transferPacket->WhichMember);

    KeAcquireSpinLock(&t->_spinLock, &irql);
    if (t->QueryMemberState(transferPacket->WhichMember) == FtMemberOrphaned ||
        t->_stopSyncs) {

        t->_syncOk = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);
        FinishRegenerate(t, context, transferPacket);
        return;
    }
    KeReleaseSpinLock(&t->_spinLock, irql);

    if (transferPacket->ReadPacket) {

        t->_overlappedIoManager.ReleaseIoRegion(transferPacket);

        if (transferPacket->Offset + STRIPE_SIZE >= t->_volumeSize) {

            KeAcquireSpinLock(&t->_spinLock, &irql);
            b = t->SetMemberState((transferPacket->WhichMember + 1)%2,
                                  FtMemberHealthy);
            t->_balancedReads = TRUE;
            t->_syncOk = TRUE;
            t->_originalDirtyBit = FALSE;
            KeReleaseSpinLock(&t->_spinLock, irql);

            if (b) {
                t->PropogateStateChanges(NULL, NULL);
                t->Notify();
                FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                            FT_MIRROR_COPY_ENDED, STATUS_SUCCESS, 0);
            }

            FinishRegenerate(t, context, transferPacket);
            return;
        }

        transferPacket->Offset += STRIPE_SIZE;
        if (t->_volumeSize - transferPacket->Offset < STRIPE_SIZE) {
            transferPacket->Length = (ULONG) (t->_volumeSize -
                                              transferPacket->Offset);
        }

        transferPacket->CompletionRoutine = MirrorRegeneratePhase1;
        t->_overlappedIoManager.AcquireIoRegion(transferPacket, TRUE);

    } else {
        TRANSFER(transferPacket);
    }
}

NTSTATUS
MIRROR::RegenerateMember(
    IN      USHORT                  MemberNumber,
    IN OUT  PFT_VOLUME              NewMember,
    IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN      PVOID                   Context
    )

/*++

Routine Description:

    This routine regenerates the given member of this volume with
    the given volume.

Arguments:

    MemberNumber        - Supplies the member number to regenerate.

    NewMember           - Supplies the new member to regenerate to.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the completion routine context.

Return Value:

    NTSTATUS

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  context;
    PMIRROR_TP                      packet;
    NTSTATUS                        status;
    KIRQL                           irql;
    BOOLEAN                         b;

    if (MemberNumber >= 2 ||
        NewMember->QueryVolumeSize() < _volumeSize) {

        return STATUS_INVALID_PARAMETER;
    }

    context = (PFT_COMPLETION_ROUTINE_CONTEXT)
              ExAllocatePool(NonPagedPool,
                             sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
    packet = new MIRROR_TP;
    if (packet && !packet->AllocateMdl(STRIPE_SIZE)) {
        delete packet;
        packet = NULL;
    }
    if (!context || !packet) {
        if (context) {
            ExFreePool(context);
        }
        if (packet) {
            delete packet;
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeSpinLock(&context->SpinLock);
    context->Status = STATUS_SUCCESS;
    context->RefCount = 1;
    context->CompletionRoutine = CompletionRoutine;
    context->Context = Context;
    context->ParentVolume = this;

    packet->Length = STRIPE_SIZE;
    packet->Offset = 0;
    packet->CompletionRoutine = MirrorRegeneratePhase1;
    packet->Thread = PsGetCurrentThread();
    packet->IrpFlags = SL_OVERRIDE_VERIFY_VOLUME;
    packet->ReadPacket = TRUE;
    packet->MasterPacket = (PTRANSFER_PACKET) context;
    packet->Mirror = this;

    status = STATUS_SUCCESS;
    KeAcquireSpinLock(&_spinLock, &irql);
    if (_syncOk) {
        _syncOk = FALSE;
        _stopSyncs = FALSE;
    } else {
        KeReleaseSpinLock(&_spinLock, irql);
        delete packet;
        ExFreePool(context);
        return STATUS_INVALID_PARAMETER;
    }

    if (_state.UnhealthyMemberState != FtMemberHealthy) {
        if (MemberNumber == _state.UnhealthyMemberNumber) {
            if (_state.UnhealthyMemberState == FtMemberRegenerating) {
                status = STATUS_INVALID_PARAMETER;
            }
        } else {
            status = STATUS_INVALID_PARAMETER;
        }
    }

    if (!NT_SUCCESS(status)) {
        _syncOk = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);
        ExFreePool(context);
        delete packet;
        return status;
    }

    packet->WhichMember = (MemberNumber + 1)%2;
    packet->TargetVolume = GetMemberUnprotected(packet->WhichMember);

    SetMemberUnprotected(MemberNumber, NewMember);
    b = SetMemberState(MemberNumber, FtMemberRegenerating);
    KeReleaseSpinLock(&_spinLock, irql);

    ASSERT(b);

    PropogateStateChanges(NULL, NULL);
    Notify();
    FtpLogError(_rootExtension, QueryLogicalDiskId(),
                FT_MIRROR_COPY_STARTED, STATUS_SUCCESS, 2);

    _overlappedIoManager.AcquireIoRegion(packet, TRUE);

    return status;
}

VOID
MIRROR::Transfer(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Transfer routine for MIRROR type FT_VOLUME.  Balance READs as
    much as possible and propogate WRITEs to both the primary and
    secondary volumes.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    KIRQL       irql;
    PMIRROR_TP  packet1, packet2;

    if (TransferPacket->Offset + TransferPacket->Length > _volumeSize) {
        TransferPacket->IoStatus.Status = STATUS_INVALID_PARAMETER;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    if (!TransferPacket->Mdl) {
        TransferPacket->ReadPacket = FALSE;
    }

    packet1 = new MIRROR_TP;
    if (packet1 && !TransferPacket->ReadPacket) {
        packet2 = new MIRROR_TP;
        if (!packet2) {
            delete packet1;
            packet1 = NULL;
        }
    } else {
        packet2 = NULL;
    }

    if (!packet1) {
        if (!TransferPacket->Mdl) {
            TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            TransferPacket->IoStatus.Information = 0;
            TransferPacket->CompletionRoutine(TransferPacket);
            return;
        }

        KeAcquireSpinLock(&_spinLock, &irql);
        if (_ePacketInUse) {
            InsertTailList(&_ePacketQueue, &TransferPacket->QueueEntry);
            KeReleaseSpinLock(&_spinLock, irql);
            return;
        }
        _ePacketInUse = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);

        packet1 = _ePacket;
        packet2 = _ePacket2;
    }

    if (TransferPacket->ReadPacket) {
        if (!LaunchRead(TransferPacket, packet1)) {
            Recycle(packet1, TRUE);
        }
    } else {
        if (!LaunchWrite(TransferPacket, packet1, packet2)) {
            Recycle(packet1, FALSE);
            Recycle(packet2, TRUE);
        }
    }
}

VOID
MIRROR::ReplaceBadSector(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is a no-op since replacing bad sectors doesn't make sense
    on an FT component with redundancy built in to it.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    TransferPacket->IoStatus.Status = STATUS_UNSUCCESSFUL;
    TransferPacket->IoStatus.Information = 0;
    TransferPacket->CompletionRoutine(TransferPacket);
}

VOID
MIRROR::StartSyncOperations(
    IN      BOOLEAN                 RegenerateOrphans,
    IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN      PVOID                   Context
    )

/*++

Routine Description:

    This routine restarts any regenerate or initialize requests that were
    suspended because of a reboot.  The volume examines the member state of
    all of its constituents and restarts any regenerations pending.

Arguments:

    RegenerateOrphans   - Supplies whether or not to try and regenerate
                            orphaned members.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the context for the completion routine.

Return Value:

    None.

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  context;
    BOOLEAN                         dirty, b;
    KIRQL                           irql;
    USHORT                          srcIndex;
    PMIRROR_TP                      packet;

    context = (PFT_COMPLETION_ROUTINE_CONTEXT)
              ExAllocatePool(NonPagedPool,
                             sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
    if (!context) {
        CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    KeInitializeSpinLock(&context->SpinLock);
    context->Status = STATUS_SUCCESS;
    context->RefCount = 2;
    context->CompletionRoutine = CompletionRoutine;
    context->Context = Context;
    context->ParentVolume = this;

    COMPOSITE_FT_VOLUME::StartSyncOperations(
            RegenerateOrphans, MirrorCompositeVolumeCompletionRoutine, context);

    if (_orphanedBecauseOfMissingMember) {
        RegenerateOrphans = TRUE;
        _orphanedBecauseOfMissingMember = FALSE;
    }

    dirty = FALSE;
    b = FALSE;
    KeAcquireSpinLock(&_spinLock, &irql);
    if (_syncOk) {
        _syncOk = FALSE;
        _stopSyncs = FALSE;
    } else {
        KeReleaseSpinLock(&_spinLock, irql);
        MirrorCompositeVolumeCompletionRoutine(context, STATUS_SUCCESS);
        return;
    }
    if (_state.UnhealthyMemberState == FtMemberOrphaned &&
        RegenerateOrphans &&
        GetMemberUnprotected(_state.UnhealthyMemberNumber)) {

        _state.UnhealthyMemberState = FtMemberRegenerating;
        b = TRUE;
    }
    if (_state.UnhealthyMemberState == FtMemberHealthy) {
        if (_originalDirtyBit) {
            srcIndex = 0;
            dirty = TRUE;
        } else {
            _syncOk = TRUE;
            KeReleaseSpinLock(&_spinLock, irql);
            MirrorCompositeVolumeCompletionRoutine(context, STATUS_SUCCESS);
            return;
        }
    } else if (_state.UnhealthyMemberState == FtMemberRegenerating) {
        srcIndex = (_state.UnhealthyMemberNumber + 1)%2;
        b = TRUE;
    } else {
        _syncOk = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);
        MirrorCompositeVolumeCompletionRoutine(context, STATUS_SUCCESS);
        return;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    if (dirty) {
        FtpLogError(_rootExtension, QueryLogicalDiskId(),
                    FT_DIRTY_SHUTDOWN, STATUS_SUCCESS, 0);
    }

    if (b) {
        PropogateStateChanges(NULL, NULL);
        Notify();
        FtpLogError(_rootExtension, QueryLogicalDiskId(),
                    FT_MIRROR_COPY_STARTED, STATUS_SUCCESS, 3);
    }

    packet = new MIRROR_TP;
    if (packet && !packet->AllocateMdl(STRIPE_SIZE)) {
        delete packet;
        packet = NULL;
    }
    if (!packet) {
        MirrorCompositeVolumeCompletionRoutine(context,
                                               STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    packet->Length = STRIPE_SIZE;
    packet->Offset = 0;
    packet->CompletionRoutine = MirrorRegeneratePhase1;
    packet->Thread = PsGetCurrentThread();
    packet->IrpFlags = SL_OVERRIDE_VERIFY_VOLUME;
    packet->ReadPacket = TRUE;
    packet->MasterPacket = (PMIRROR_TP) context;
    packet->Mirror = this;
    packet->WhichMember = srcIndex;
    packet->TargetVolume = GetMemberUnprotected(packet->WhichMember);

    _overlappedIoManager.AcquireIoRegion(packet, TRUE);
}

VOID
MIRROR::StopSyncOperations(
    )

/*++

Routine Description:

    This routine stops all sync operations.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KIRQL   irql;

    COMPOSITE_FT_VOLUME::StopSyncOperations();

    KeAcquireSpinLock(&_spinLock, &irql);
    _stopSyncs = TRUE;
    KeReleaseSpinLock(&_spinLock, irql);
}

LONGLONG
MIRROR::QueryVolumeSize(
    )

/*++

Routine Description:

    Returns the number of bytes on the entire volume.

Arguments:

    None.

Return Value:

    The volume size in bytes.

--*/

{
    return _volumeSize;
}

VOID
MIRROR::SetDirtyBit(
    IN  BOOLEAN                 IsDirty,
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine sets the dirty bit on the volume.  This bit is used at
    startup to determine whether or not there was a clean shutdown.

Arguments:

    IsDirty - Supplies the value of the dirty bit.

Return Value:

    None.

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  context;
    KIRQL                           irql;

    if (CompletionRoutine) {

        context = (PFT_COMPLETION_ROUTINE_CONTEXT)
                  ExAllocatePool(NonPagedPool,
                                 sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
        if (!context) {
            CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
            return;
        }

        KeInitializeSpinLock(&context->SpinLock);
        context->Status = STATUS_SUCCESS;
        context->RefCount = 2;
        context->CompletionRoutine = CompletionRoutine;
        context->Context = Context;
        context->ParentVolume = this;

        COMPOSITE_FT_VOLUME::SetDirtyBit(IsDirty,
                MirrorCompositeVolumeCompletionRoutine, context);

    } else {
        COMPOSITE_FT_VOLUME::SetDirtyBit(IsDirty, NULL, NULL);
    }

    KeAcquireSpinLock(&_spinLock, &irql);
    if (IsDirty || _syncOk) {
        if (!_stopSyncs) {
            _state.IsDirty = IsDirty;
        }
    }
    KeReleaseSpinLock(&_spinLock, irql);

    if (CompletionRoutine) {
        PropogateStateChanges(MirrorCompositeVolumeCompletionRoutine, context);
    } else {
        PropogateStateChanges(NULL, NULL);
    }
}

BOOLEAN
MIRROR::IsComplete(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine computes whether or not this volume has either all
    (if IoPending is FALSE) of its members or enough (if IoPending is TRUE) of
    its members.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
    BOOLEAN     b;
    USHORT      n, i, orphanMember;
    PFT_VOLUME  vol;

    b = COMPOSITE_FT_VOLUME::IsComplete(IoPending);
    if (b) {
        return TRUE;
    }

    if (!IoPending) {
        return FALSE;
    }

    n = QueryNumMembers();
    orphanMember = n;
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol || !vol->IsComplete(IoPending)) {
            if (orphanMember < n) {
                return FALSE;
            }
            orphanMember = i;
        }
    }

    if (orphanMember < n) {
        if (_state.UnhealthyMemberState != FtMemberHealthy &&
            _state.UnhealthyMemberNumber != orphanMember) {

            return FALSE;
        }
    }

    return TRUE;
}

VOID
MIRROR::CompleteNotification(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine is called to notify the volume that it is complete and
    to therefore prepare for incoming requests.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
    USHORT      n, i, orphanMember;
    PFT_VOLUME  vol;

    COMPOSITE_FT_VOLUME::CompleteNotification(IoPending);

    n = QueryNumMembers();
    orphanMember = n;
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol || !vol->IsComplete(IoPending)) {
            orphanMember = i;
            break;
        }
    }

    if (orphanMember < n) {
        if (SetMemberState(orphanMember, FtMemberOrphaned)) {
            PropogateStateChanges(NULL, NULL);
            Notify();
            FtpLogError(_rootExtension, QueryLogicalDiskId(),
                        FT_ORPHANING, STATUS_SUCCESS, 1);
            IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
            _orphanedBecauseOfMissingMember = TRUE;
       }
    }
}

NTSTATUS
MIRROR::CheckIo(
    OUT PBOOLEAN    IsIoOk
    )

/*++

Routine Description:

    This routine returns whether or not IO is possible on the given
    logical disk.

Arguments:

    IsIoOk  - Returns the state of IO.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS    status;
    KIRQL       irql;
    USHORT      n, numOk, skipVol, i;
    PFT_VOLUME  vol;
    BOOLEAN     ok, b;

    n = QueryNumMembers();
    numOk = 0;
    KeAcquireSpinLock(&_spinLock, &irql);
    if (_state.UnhealthyMemberState == FtMemberHealthy) {
        skipVol = n;
    } else {
        skipVol = _state.UnhealthyMemberNumber;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    for (i = 0; i < n; i++) {
        if (i == skipVol) {
            continue;
        }
        vol = GetMemberUnprotected(i);
        if (!vol) {
            continue;
        }

        status = vol->CheckIo(&ok);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (ok) {
            numOk++;
        }
    }

    if (numOk >= n - 1) {
        *IsIoOk = TRUE;
    } else {
        *IsIoOk = FALSE;
    }

    return STATUS_SUCCESS;
}

BOOLEAN
MIRROR::IsVolumeSuitableForRegenerate(
    IN  USHORT      MemberNumber,
    IN  PFT_VOLUME  Volume
    )

/*++

Routine Description:

    This routine computes whether or not the given volume is suitable
    for a regenerate operation.

Arguments:

    MemberNumber    - Supplies the member number.

    Volume          - Supplies the volume.

Return Value:

    FALSE   - The volume is not suitable.

    TRUE    - The volume is suitable.

--*/

{
    KIRQL   irql;

    if (Volume->QueryVolumeSize() < _volumeSize) {
        return FALSE;
    }

    KeAcquireSpinLock(&_spinLock, &irql);
    if (!_syncOk ||
        _state.UnhealthyMemberState != FtMemberOrphaned ||
        _state.UnhealthyMemberNumber != MemberNumber) {

        KeReleaseSpinLock(&_spinLock, irql);
        return FALSE;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    return TRUE;
}

VOID
MIRROR::NewStateArrival(
    IN  PVOID   NewStateInstance
    )

/*++

Routine Description:

    This routine takes the new state instance arrival combined with its
    current state to come up with the new current state for the volume.
    If the two states cannot be reconciled then this routine returns FALSE
    indicating that the volume is invalid and should be broken into its
    constituant parts.

Arguments:

    NewStateInstance    - Supplies the new state instance.

Return Value:

    None.

--*/

{
    BOOLEAN                                 changed = FALSE;
    PFT_MIRROR_AND_SWP_STATE_INFORMATION    state;

    state = (PFT_MIRROR_AND_SWP_STATE_INFORMATION) NewStateInstance;
    if (state->IsDirty) {
        if (!_state.IsDirty) {
            _originalDirtyBit = _state.IsDirty = state->IsDirty;
            _balancedReads = FALSE;
            changed = TRUE;
        }
    }

    if (state->UnhealthyMemberState != FtMemberHealthy) {
        if (state->UnhealthyMemberNumber >= QueryNumMembers()) {

            _state.UnhealthyMemberNumber = 1;
            _state.UnhealthyMemberState = FtMemberOrphaned;
            changed = TRUE;

            FtpLogError(_rootExtension, QueryLogicalDiskId(),
                        FT_MIRROR_STATE_CORRUPTION,
                        STATUS_SUCCESS, 0);

        } else if (_state.UnhealthyMemberState == FtMemberHealthy) {
            _state.UnhealthyMemberState = state->UnhealthyMemberState;
            _state.UnhealthyMemberNumber = state->UnhealthyMemberNumber;
            changed = TRUE;
        } else {
            if (_state.UnhealthyMemberNumber == state->UnhealthyMemberNumber) {
                if (state->UnhealthyMemberState == FtMemberOrphaned) {
                    if (_state.UnhealthyMemberState != FtMemberOrphaned) {
                        _state.UnhealthyMemberState = FtMemberOrphaned;
                        changed = TRUE;
                    }
                }
            } else {
                _state.UnhealthyMemberNumber = 1;
                _state.UnhealthyMemberState = FtMemberOrphaned;
                changed = TRUE;

                FtpLogError(_rootExtension, QueryLogicalDiskId(),
                            FT_MIRROR_STATE_CORRUPTION,
                            STATUS_SUCCESS, 0);
            }
        }
    }

    if (changed) {
        PropogateStateChanges(NULL, NULL);
    }
}

PDEVICE_OBJECT
MIRROR::GetLeftmostPartitionObject(
    )

{
    KIRQL       irql;
    USHORT      memberNumber;
    PFT_VOLUME  vol;

    KeAcquireSpinLock(&_spinLock, &irql);
    if (_state.UnhealthyMemberState != FtMemberHealthy &&
        _state.UnhealthyMemberNumber == 0) {

        memberNumber = 1;
    } else {
        memberNumber = 0;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    vol = GetMember(memberNumber);
    if (!vol) {
        return NULL;
    }

    return vol->GetLeftmostPartitionObject();
}

BOOLEAN
MIRROR::QueryVolumeState(
    IN  PFT_VOLUME          Volume,
    OUT PFT_MEMBER_STATE    State
    )

/*++

Routine Description:

    This routine returns the state of the given volume considered as a
    member of this volume.

Arguments:

    Volume  - Supplies the volume to query the state for.

    State   - Returns the state.

Return Value:

    FALSE   - The given Volume is not a member of this volume.

    TRUE    - The state was successfully computed.

--*/

{
    USHORT          n, i;
    PFT_VOLUME      vol;
    KIRQL           irql;
    FT_MEMBER_STATE state;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            continue;
        }

        if (!vol->QueryVolumeState(Volume, State)) {
            continue;
        }

        KeAcquireSpinLock(&_spinLock, &irql);
        state = QueryMemberState(i);
        if (state != FtMemberHealthy) {
            if (*State != FtMemberOrphaned) {
                *State = state;
            }
        }
        KeReleaseSpinLock(&_spinLock, irql);

        return TRUE;
    }

    return FALSE;
}

BOOLEAN
MIRROR::SetMemberState(
    IN  USHORT          MemberNumber,
    IN  FT_MEMBER_STATE MemberState
    )

/*++

Routine Description:

    This routine sets the given member to the given state.

Arguments:

    MemberNumber    - Supplies the member number.

    MemberState     - Supplies the member state.

Return Value:

    FALSE   - There was no state change.

    TRUE    - A state change took place.

Notes:

    The caller must be holding the class spin lock.

--*/

{
    if (_state.UnhealthyMemberState == FtMemberHealthy) {
        if (MemberNumber >= QueryNumMembers()) {
            KeBugCheckEx(FTDISK_INTERNAL_ERROR, (ULONG_PTR) this,
                         MemberNumber, MemberState, 0);
        }
        _state.UnhealthyMemberNumber = MemberNumber;
        _state.UnhealthyMemberState = MemberState;
        return TRUE;
    }

    if (_state.UnhealthyMemberNumber == MemberNumber &&
        _state.UnhealthyMemberState != MemberState) {

        _state.UnhealthyMemberState = MemberState;
        return TRUE;
    }

    return FALSE;
}

VOID
MirrorTransferCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for MIRROR::Transfer function.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_TP          transferPacket = (PMIRROR_TP) TransferPacket;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    PMIRROR             t = transferPacket->Mirror;
    KIRQL               irql;
    LONG                count;
    BOOLEAN             b;
    PMIRROR_TP          otherPacket;


    // Check for the read completion case.

    if (transferPacket->ReadPacket) {

        KeAcquireSpinLock(&t->_spinLock, &irql);
        t->_requestCount[transferPacket->WhichMember]--;
        KeReleaseSpinLock(&t->_spinLock, irql);

        if (!NT_SUCCESS(status) && status != STATUS_VERIFY_REQUIRED) {

            if (FsRtlIsTotalDeviceFailure(status)) {

                // Device failure case.

                KeAcquireSpinLock(&t->_spinLock, &irql);
                b = t->SetMemberState(transferPacket->WhichMember,
                                      FtMemberOrphaned);
                KeReleaseSpinLock(&t->_spinLock, irql);

                if (b) {
                    t->PropogateStateChanges(NULL, NULL);
                    t->Notify();
                    FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                                FT_ORPHANING, STATUS_SUCCESS, 4);
                    IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL,
                                                  NULL);
                }

                if (!transferPacket->OneReadFailed) {

                    transferPacket->OneReadFailed = TRUE;
                    transferPacket->WhichMember =
                            (transferPacket->WhichMember + 1) % 2;
                    transferPacket->TargetVolume = t->GetMemberUnprotected(
                                                   transferPacket->WhichMember);

                    if (t->_state.UnhealthyMemberNumber !=
                        transferPacket->WhichMember) {

                        TRANSFER(transferPacket);
                        return;
                    }
                }

            } else {

                // Bad sector case.

                if (!transferPacket->OneReadFailed) {
                    transferPacket->OneReadFailed = TRUE;
                    t->Recover(transferPacket);
                    return;
                }
            }
        }

        masterPacket->IoStatus = transferPacket->IoStatus;
        masterPacket->CompletionRoutine(masterPacket);

        t->Recycle(transferPacket, TRUE);
        return;
    }


    // This a write or a verify in which two requests may have been sent.

    KeAcquireSpinLock(&masterPacket->SpinLock, &irql);

    if (NT_SUCCESS(status)) {

        if (NT_SUCCESS(masterPacket->IoStatus.Status)) {
             masterPacket->IoStatus.Information =
                    transferPacket->IoStatus.Information;
        }

    } else {

        if (status == STATUS_VERIFY_REQUIRED) {
            masterPacket->IoStatus.Information = 0;
            if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
                masterPacket->IoStatus.Status = status;
            }

        } else if (FsRtlIsTotalDeviceFailure(status)) {

            KeAcquireSpinLock(&t->_spinLock, &irql);
            b = t->SetMemberState(transferPacket->WhichMember,
                                  FtMemberOrphaned);
            KeReleaseSpinLock(&t->_spinLock, irql);

            if (b) {
                t->PropogateStateChanges(NULL, NULL);
                t->Notify();
                FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                            FT_ORPHANING, STATUS_SUCCESS, 5);
                IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
            } else {
                masterPacket->IoStatus.Information = 0;
                if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
                    masterPacket->IoStatus.Status = status;
                }
            }

        } else if (!transferPacket->OneReadFailed && transferPacket->Mdl) {

            KeReleaseSpinLock(&masterPacket->SpinLock, irql);

            transferPacket->OneReadFailed = TRUE;
            t->CarefulWrite(transferPacket);
            return;

        } else {
            masterPacket->IoStatus.Information = 0;
            if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
                masterPacket->IoStatus.Status = status;
            }
        }
    }

    count = --masterPacket->RefCount;
    b = (masterPacket->IrpFlags&SL_FT_SEQUENTIAL_WRITE) ? TRUE : FALSE;

    KeReleaseSpinLock(&masterPacket->SpinLock, irql);

    if (count) {
        if (b) {
            otherPacket = transferPacket->SecondWritePacket;
            otherPacket->CompletionRoutine = MirrorTransferCompletionRoutine;
            TRANSFER(otherPacket);
        }
    } else {
        masterPacket->CompletionRoutine(masterPacket);
        if (transferPacket->SecondWritePacket) {
            t->Recycle(transferPacket->SecondWritePacket, FALSE);
        }
        t->Recycle(transferPacket, TRUE);
    }
}

BOOLEAN
MIRROR::LaunchRead(
    IN OUT  PTRANSFER_PACKET    TransferPacket,
    IN OUT  PMIRROR_TP          Packet1
    )

/*++

Routine Description:

    This routine lauches the given read transfer packet in parallel accross
    all members using the given mirror transfer packet.

Arguments:

    TransferPacket  - Supplies the transfer packet to launch.

    Packet1         - Supplies a worker transfer packet.

Return Value:

    FALSE   - The read request was not launched.

    TRUE    - The read request was launched.

--*/

{
    PMIRROR_TP          packet;
    KIRQL               irql;
    LONG                diff;
    LONGLONG            seek0, seek1;

    packet = Packet1;

    packet->Mdl = TransferPacket->Mdl;
    packet->OriginalIrp = TransferPacket->OriginalIrp;
    packet->Length = TransferPacket->Length;
    packet->Offset = TransferPacket->Offset;
    packet->CompletionRoutine = MirrorTransferCompletionRoutine;
    packet->Thread = TransferPacket->Thread;
    packet->IrpFlags = TransferPacket->IrpFlags;
    packet->ReadPacket = TransferPacket->ReadPacket;
    packet->MasterPacket = TransferPacket;
    packet->Mirror = this;

    // Determine which member to dispatch this read request to.
    // Balance the load if both members are healthy.

    KeAcquireSpinLock(&_spinLock, &irql);
    if (TransferPacket->SpecialRead) {

        if (TransferPacket->SpecialRead == TP_SPECIAL_READ_PRIMARY) {
            packet->WhichMember = 0;
        } else {
            packet->WhichMember = 1;
        }

        if (QueryMemberState(packet->WhichMember) != FtMemberHealthy) {
            packet->WhichMember = 2;
        }

    } else if (_state.UnhealthyMemberState == FtMemberHealthy) {

        if (!_balancedReads) {
            packet->WhichMember = 0;
        } else {
            diff = _requestCount[1] - _requestCount[0];
            if (diff < -4) {
                packet->WhichMember = 1;
            } else if (diff > 4) {
                packet->WhichMember = 0;
            } else {
                seek0 = _lastPosition[0] - packet->Offset;
                seek1 = _lastPosition[1] - packet->Offset;
                if (seek0 < 0) {
                    seek0 = -seek0;
                }
                if (seek1 < 0) {
                    seek1 = -seek1;
                }
                if (seek1 < seek0) {
                    packet->WhichMember = 1;
                } else {
                    packet->WhichMember = 0;
                }
            }
        }

    } else {
        packet->WhichMember = (_state.UnhealthyMemberNumber + 1)%2;
    }
    if (packet->WhichMember < 2) {
        _requestCount[packet->WhichMember]++;
        _lastPosition[packet->WhichMember] = packet->Offset + packet->Length;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    if (packet->WhichMember >= 2) {
        TransferPacket->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return FALSE;
    }

    packet->TargetVolume = GetMemberUnprotected(packet->WhichMember);
    TRANSFER(packet);

    return TRUE;
}

VOID
MirrorWritePhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine sends down the given transfer packets for a write to
    the volumes.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PTRANSFER_PACKET    p;

    p = ((PMIRROR_TP) TransferPacket)->SecondWritePacket;
    if (p) {
        p->CompletionRoutine = MirrorTransferCompletionRoutine;
        if (TransferPacket->IrpFlags&SL_FT_SEQUENTIAL_WRITE) {
            TRANSFER(p);
            return;
        }
        TRANSFER(p);
    }

    TransferPacket->CompletionRoutine = MirrorTransferCompletionRoutine;
    TRANSFER(TransferPacket);
}

BOOLEAN
MIRROR::LaunchWrite(
    IN OUT  PTRANSFER_PACKET    TransferPacket,
    IN OUT  PMIRROR_TP          Packet1,
    IN OUT  PMIRROR_TP          Packet2
    )

/*++

Routine Description:

    This routine lauches the given write transfer packet in parallel accross
    all members using the given mirror transfer packets.

Arguments:

    TransferPacket  - Supplies the transfer packet to launch.

    Packet1         - Supplies a worker transfer packet.

    Packet2         - Supplies a worker transfer packet.

Return Value:

    FALSE   - The read request was not launched.

    TRUE    - The read request was launched.

--*/

{
    PMIRROR_TP          packet;
    KIRQL               irql;
    PFT_VOLUME          pri, sec;
    FT_PARTITION_STATE  priState, secState;
    LONGLONG            rowStart;
    ULONG               numRows, length, remainder;
    USHORT              source;
    LONG                count;
    BOOLEAN             b;

    KeInitializeSpinLock(&TransferPacket->SpinLock);
    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = 0;
    TransferPacket->RefCount = 2;

    // Send down the first request to the primary or to the source
    // if we're doing a regenerate.

    KeAcquireSpinLock(&_spinLock, &irql);
    if (_state.UnhealthyMemberState == FtMemberHealthy) {
        source = 0;
    } else if (_state.UnhealthyMemberState == FtMemberRegenerating) {
        source = (_state.UnhealthyMemberNumber + 1)%2;
    } else {
        TransferPacket->RefCount = 1;
        source = (_state.UnhealthyMemberNumber + 1)%2;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    packet = Packet1;

    packet->Mdl = TransferPacket->Mdl;
    packet->Length = TransferPacket->Length;
    packet->Offset = TransferPacket->Offset;
    packet->CompletionRoutine = MirrorWritePhase1;
    packet->Thread = TransferPacket->Thread;
    packet->IrpFlags = TransferPacket->IrpFlags;
    packet->ReadPacket = TransferPacket->ReadPacket;
    packet->MasterPacket = TransferPacket;
    packet->Mirror = this;
    packet->WhichMember = source;
    packet->SecondWritePacket = NULL;
    packet->TargetVolume = GetMemberUnprotected(packet->WhichMember);

    if (TransferPacket->RefCount == 1) {
        _overlappedIoManager.AcquireIoRegion(packet, TRUE);
        if (Packet2 != _ePacket && Packet2 != _ePacket2) {
            delete Packet2;
        }
        return TRUE;
    }

    packet->SecondWritePacket = Packet2;

    packet = Packet2;

    packet->Mdl = TransferPacket->Mdl;
    packet->Length = TransferPacket->Length;
    packet->Offset = TransferPacket->Offset;
    packet->CompletionRoutine = MirrorWritePhase1;
    packet->Thread = TransferPacket->Thread;
    packet->IrpFlags = TransferPacket->IrpFlags;
    packet->ReadPacket = TransferPacket->ReadPacket;
    packet->MasterPacket = TransferPacket;
    packet->Mirror = this;
    packet->WhichMember = (source + 1)%2;
    packet->SecondWritePacket = Packet1;
    packet->TargetVolume = GetMemberUnprotected(packet->WhichMember);

    _overlappedIoManager.AcquireIoRegion(packet, TRUE);

    return TRUE;
}

VOID
MIRROR::Recycle(
    IN OUT  PMIRROR_TP  TransferPacket,
    IN      BOOLEAN     ServiceEmergencyQueue
    )

/*++

Routine Description:

    This routine recycles the given transfer packet and services
    the emergency queue if need be.

Arguments:

    TransferPacket          - Supplies the transfer packet.

    ServiceEmergencyQueue   - Supplies whether or not to service the
                                emergency queue.

Return Value:

    None.

--*/

{
    KIRQL               irql;
    PLIST_ENTRY         l;
    PTRANSFER_PACKET    p;
    PMIRROR_TP          packet1, packet2;

    if (TransferPacket != _ePacket &&
        TransferPacket != _ePacket2 &&
        TransferPacket != _eRecoverPacket) {

        delete TransferPacket;
        return;
    }

    TransferPacket->OriginalIrp = NULL;
    TransferPacket->SpecialRead = 0;
    TransferPacket->OneReadFailed = FALSE;
    _overlappedIoManager.ReleaseIoRegion(TransferPacket);

    if (TransferPacket == _eRecoverPacket) {
        MmPrepareMdlForReuse(_eRecoverPacket->PartialMdl);
        KeAcquireSpinLock(&_spinLock, &irql);
        if (IsListEmpty(&_eRecoverPacketQueue)) {
            _eRecoverPacketInUse = FALSE;
            KeReleaseSpinLock(&_spinLock, irql);
            return;
        }
        l = RemoveHeadList(&_eRecoverPacketQueue);
        KeReleaseSpinLock(&_spinLock, irql);
        p = CONTAINING_RECORD(l, TRANSFER_PACKET, QueueEntry);
        p->CompletionRoutine(p);
        return;
    }

    if (!ServiceEmergencyQueue) {
        return;
    }

    for (;;) {

        KeAcquireSpinLock(&_spinLock, &irql);
        if (IsListEmpty(&_ePacketQueue)) {
            _ePacketInUse = FALSE;
            KeReleaseSpinLock(&_spinLock, irql);
            break;
        }
        l = RemoveHeadList(&_ePacketQueue);
        KeReleaseSpinLock(&_spinLock, irql);

        p = CONTAINING_RECORD(l, TRANSFER_PACKET, QueueEntry);

        packet1 = new MIRROR_TP;
        if (packet1 && !TransferPacket->ReadPacket) {
            packet2 = new MIRROR_TP;
            if (!packet2) {
                delete packet1;
                packet1 = NULL;
            }
        } else {
            packet2 = NULL;
        }

        if (!packet1) {
            packet1 = _ePacket;
            packet2 = _ePacket2;
        }

        if (TransferPacket->ReadPacket) {
            if (!LaunchRead(TransferPacket, packet1)) {
                if (packet1 != _ePacket) {
                    delete packet1;
                    packet1 = NULL;
                }
            }
        } else {
            if (!LaunchWrite(TransferPacket, packet1, packet2)) {
                if (packet1 != _ePacket) {
                    delete packet1;
                    delete packet2;
                    packet1 = NULL;
                }
            }
        }

        if (packet1 == _ePacket) {
            break;
        }
    }
}

VOID
MirrorRecoverPhase8(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector read
    of the main member after a write was done to check for
    data integrity.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_RECOVER_TP  subPacket = (PMIRROR_RECOVER_TP) TransferPacket;
    PMIRROR_TP          masterPacket = (PMIRROR_TP) subPacket->MasterPacket;
    PMIRROR             t = masterPacket->Mirror;
    NTSTATUS            status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->OneReadFailed = FALSE;
        masterPacket->IoStatus = subPacket->IoStatus;
        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (!NT_SUCCESS(status) ||
        RtlCompareMemory(MmGetSystemAddressForMdl(subPacket->PartialMdl),
                         MmGetSystemAddressForMdl(subPacket->VerifyMdl),
                         subPacket->Length) != subPacket->Length) {

        masterPacket->IoStatus.Status = STATUS_FT_READ_RECOVERY_FROM_BACKUP;

        FtpLogError(t->_rootExtension,
                    subPacket->TargetVolume->QueryLogicalDiskId(),
                    FT_SECTOR_FAILURE, status,
                    (ULONG) (subPacket->Offset/t->QuerySectorSize()));
    }

    if (subPacket->Offset + subPacket->Length ==
        masterPacket->Offset + masterPacket->Length) {

        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    subPacket->Offset += subPacket->Length;
    subPacket->CompletionRoutine = MirrorRecoverPhase2;
    subPacket->ReadPacket = TRUE;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    TRANSFER(subPacket);
}

VOID
MirrorRecoverPhase7(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector write
    of the main member after a replace sector was done.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_RECOVER_TP  subPacket = (PMIRROR_RECOVER_TP) TransferPacket;
    PMIRROR_TP          masterPacket = (PMIRROR_TP) subPacket->MasterPacket;
    PMIRROR             t = masterPacket->Mirror;
    NTSTATUS            status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->OneReadFailed = FALSE;
        masterPacket->IoStatus = subPacket->IoStatus;
        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (!NT_SUCCESS(status)) {

        masterPacket->IoStatus.Status = STATUS_FT_READ_RECOVERY_FROM_BACKUP;

        FtpLogError(t->_rootExtension,
                    subPacket->TargetVolume->QueryLogicalDiskId(),
                    FT_SECTOR_FAILURE, status,
                    (ULONG) (subPacket->Offset/t->QuerySectorSize()));

        if (subPacket->Offset + subPacket->Length ==
            masterPacket->Offset + masterPacket->Length) {

            t->Recycle(subPacket, TRUE);
            masterPacket->CompletionRoutine(masterPacket);
            return;
        }

        subPacket->Mdl = subPacket->PartialMdl;
        subPacket->Offset += subPacket->Length;
        subPacket->CompletionRoutine = MirrorRecoverPhase2;
        subPacket->ReadPacket = TRUE;
        MmPrepareMdlForReuse(subPacket->Mdl);
        IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                          (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                          (ULONG) (subPacket->Offset - masterPacket->Offset),
                          subPacket->Length);

        TRANSFER(subPacket);
        return;
    }

    subPacket->Mdl = subPacket->VerifyMdl;
    subPacket->CompletionRoutine = MirrorRecoverPhase8;
    subPacket->ReadPacket = TRUE;

    TRANSFER(subPacket);
}

VOID
MirrorRecoverPhase6(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector replace
    of the main member.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_RECOVER_TP  subPacket = (PMIRROR_RECOVER_TP) TransferPacket;
    PMIRROR_TP          masterPacket = (PMIRROR_TP) subPacket->MasterPacket;
    PMIRROR             t = masterPacket->Mirror;
    NTSTATUS            status = subPacket->IoStatus.Status;

    if (!NT_SUCCESS(status)) {

        masterPacket->IoStatus.Status = STATUS_FT_READ_RECOVERY_FROM_BACKUP;

        FtpLogError(t->_rootExtension,
                    subPacket->TargetVolume->QueryLogicalDiskId(),
                    FT_SECTOR_FAILURE, status,
                    (ULONG) (subPacket->Offset/t->QuerySectorSize()));

        if (subPacket->Offset + subPacket->Length ==
            masterPacket->Offset + masterPacket->Length) {

            t->Recycle(subPacket, TRUE);
            masterPacket->CompletionRoutine(masterPacket);
            return;
        }

        subPacket->Mdl = subPacket->PartialMdl;
        subPacket->Offset += subPacket->Length;
        subPacket->CompletionRoutine = MirrorRecoverPhase2;
        subPacket->ReadPacket = TRUE;
        MmPrepareMdlForReuse(subPacket->Mdl);
        IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                          (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                          (ULONG) (subPacket->Offset - masterPacket->Offset),
                          subPacket->Length);

        TRANSFER(subPacket);
        return;
    }

    // We were able to relocate the bad sector so now do a write and
    // then read to make sure it's ok.

    subPacket->Mdl = subPacket->PartialMdl;
    subPacket->CompletionRoutine = MirrorRecoverPhase7;
    subPacket->ReadPacket = FALSE;

    TRANSFER(subPacket);
}

VOID
MirrorRecoverPhase5(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector read
    of the main member after a successful write to check and
    see if the write was successful.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_RECOVER_TP  subPacket = (PMIRROR_RECOVER_TP) TransferPacket;
    PMIRROR_TP          masterPacket = (PMIRROR_TP) subPacket->MasterPacket;
    PMIRROR             t = masterPacket->Mirror;
    NTSTATUS            status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->OneReadFailed = FALSE;
        masterPacket->IoStatus = subPacket->IoStatus;
        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (!NT_SUCCESS(status) ||
        RtlCompareMemory(MmGetSystemAddressForMdl(subPacket->PartialMdl),
                         MmGetSystemAddressForMdl(subPacket->VerifyMdl),
                         subPacket->Length) != subPacket->Length) {

        subPacket->Mdl = subPacket->PartialMdl;
        subPacket->CompletionRoutine = MirrorRecoverPhase6;
        subPacket->TargetVolume->ReplaceBadSector(subPacket);
        return;
    }

    if (subPacket->Offset + subPacket->Length ==
        masterPacket->Offset + masterPacket->Length) {

        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    subPacket->Offset += subPacket->Length;
    subPacket->CompletionRoutine = MirrorRecoverPhase2;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    TRANSFER(subPacket);
}

VOID
MirrorRecoverPhase4(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector write
    of the main member.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_RECOVER_TP  subPacket = (PMIRROR_RECOVER_TP) TransferPacket;
    PMIRROR_TP          masterPacket = (PMIRROR_TP) subPacket->MasterPacket;
    PMIRROR             t = masterPacket->Mirror;
    NTSTATUS            status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->OneReadFailed = FALSE;
        masterPacket->IoStatus = subPacket->IoStatus;
        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (!NT_SUCCESS(status)) {
        subPacket->CompletionRoutine = MirrorRecoverPhase6;
        subPacket->TargetVolume->ReplaceBadSector(subPacket);
        return;
    }

    // Write was successful so try a read and then compare.

    subPacket->Mdl = subPacket->VerifyMdl;
    subPacket->CompletionRoutine = MirrorRecoverPhase5;
    subPacket->ReadPacket = TRUE;

    TRANSFER(subPacket);
}

VOID
MirrorRecoverPhase3(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector read
    of the other member.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_RECOVER_TP  subPacket = (PMIRROR_RECOVER_TP) TransferPacket;
    PMIRROR_TP          masterPacket = (PMIRROR_TP) subPacket->MasterPacket;
    PMIRROR             t = masterPacket->Mirror;
    NTSTATUS            status = subPacket->IoStatus.Status;
    KIRQL               irql;
    BOOLEAN             b;

    if (!NT_SUCCESS(status)) {

        if (FsRtlIsTotalDeviceFailure(status) &&
            status != STATUS_VERIFY_REQUIRED) {

            masterPacket->IoStatus.Status = STATUS_DEVICE_DATA_ERROR;
            masterPacket->IoStatus.Information = 0;

            KeAcquireSpinLock(&t->_spinLock, &irql);
            b = t->SetMemberState(subPacket->WhichMember, FtMemberOrphaned);
            KeReleaseSpinLock(&t->_spinLock, irql);

            if (b) {
                t->PropogateStateChanges(NULL, NULL);
                t->Notify();
                FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                            FT_ORPHANING, STATUS_SUCCESS, 6);
                IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
            }

        } else {
            masterPacket->IoStatus = subPacket->IoStatus;
            if (status != STATUS_VERIFY_REQUIRED) {
                FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                            FT_DOUBLE_FAILURE, status,
                            (ULONG) (subPacket->Offset/t->QuerySectorSize()));
            }
        }

        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    // We have the data required in the subpacket partial mdl.
    // Try writting it back to where the read failed and see
    // if the sector just fixes itself.

    subPacket->WhichMember = (subPacket->WhichMember + 1)%2;
    subPacket->CompletionRoutine = MirrorRecoverPhase4;
    subPacket->TargetVolume = t->GetMemberUnprotected(subPacket->WhichMember);
    subPacket->ReadPacket = FALSE;

    TRANSFER(subPacket);
}

VOID
MirrorRecoverPhase2(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector transfer
    that is part of a larger recover operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_RECOVER_TP  subPacket = (PMIRROR_RECOVER_TP) TransferPacket;
    PMIRROR_TP          masterPacket = (PMIRROR_TP) subPacket->MasterPacket;
    PMIRROR             t = masterPacket->Mirror;
    NTSTATUS            status = subPacket->IoStatus.Status;
    KIRQL               irql;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->OneReadFailed = FALSE;
        masterPacket->IoStatus = subPacket->IoStatus;
        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (NT_SUCCESS(status)) {
        if (subPacket->Offset + subPacket->Length ==
            masterPacket->Offset + masterPacket->Length) {

            t->Recycle(subPacket, TRUE);
            masterPacket->CompletionRoutine(masterPacket);
            return;
        }

        subPacket->Offset += subPacket->Length;
        MmPrepareMdlForReuse(subPacket->Mdl);
        IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                          (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                          (ULONG) (subPacket->Offset - masterPacket->Offset),
                          subPacket->Length);

        TRANSFER(subPacket);
        return;
    }

    // This read sector failed from a bad sector error.  Try
    // reading the data from the other member.

    subPacket->WhichMember = (subPacket->WhichMember + 1)%2;
    subPacket->TargetVolume = t->GetMemberUnprotected(subPacket->WhichMember);

    KeAcquireSpinLock(&t->_spinLock, &irql);
    if (t->QueryMemberState(subPacket->WhichMember) != FtMemberHealthy) {
        KeReleaseSpinLock(&t->_spinLock, irql);
        masterPacket->IoStatus = subPacket->IoStatus;
        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }
    KeReleaseSpinLock(&t->_spinLock, irql);

    subPacket->CompletionRoutine = MirrorRecoverPhase3;
    TRANSFER(subPacket);
}

VOID
MirrorRecoverEmergencyCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion for use of the emergency recover packet
    in a recover operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_TP          transferPacket = (PMIRROR_TP) TransferPacket;
    PMIRROR             t = transferPacket->Mirror;
    PMIRROR_RECOVER_TP  subPacket = t->_eRecoverPacket;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(transferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(transferPacket->Mdl),
                      t->QuerySectorSize());

    subPacket->Length = t->QuerySectorSize();
    subPacket->Offset = transferPacket->Offset;
    subPacket->CompletionRoutine = MirrorRecoverPhase2;
    subPacket->TargetVolume = transferPacket->TargetVolume;
    subPacket->Thread = transferPacket->Thread;
    subPacket->IrpFlags = transferPacket->IrpFlags;
    subPacket->ReadPacket = TRUE;
    subPacket->MasterPacket = transferPacket;
    subPacket->Mirror = t;
    subPacket->WhichMember = transferPacket->WhichMember;

    TRANSFER(subPacket);
}

VOID
MirrorRecoverPhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for an acquire io region
    to a recover operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_TP          transferPacket = (PMIRROR_TP) TransferPacket;
    PMIRROR             t = transferPacket->Mirror;
    PMIRROR_RECOVER_TP  subPacket;
    KIRQL               irql;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;
    transferPacket->IoStatus.Status = STATUS_SUCCESS;
    transferPacket->IoStatus.Information = transferPacket->Length;

    subPacket = new MIRROR_RECOVER_TP;
    if (subPacket && !subPacket->AllocateMdls(t->QuerySectorSize())) {
        delete subPacket;
        subPacket = NULL;
    }
    if (!subPacket) {
        KeAcquireSpinLock(&t->_spinLock, &irql);
        if (t->_eRecoverPacketInUse) {
            transferPacket->SavedCompletionRoutine =
                    transferPacket->CompletionRoutine;
            transferPacket->CompletionRoutine = MirrorRecoverEmergencyCompletion;
            InsertTailList(&t->_eRecoverPacketQueue, &transferPacket->QueueEntry);
            KeReleaseSpinLock(&t->_spinLock, irql);
            return;
        }
        t->_eRecoverPacketInUse = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);

        subPacket = t->_eRecoverPacket;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(transferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(transferPacket->Mdl),
                      t->QuerySectorSize());

    subPacket->Length = t->QuerySectorSize();
    subPacket->Offset = transferPacket->Offset;
    subPacket->CompletionRoutine = MirrorRecoverPhase2;
    subPacket->TargetVolume = transferPacket->TargetVolume;
    subPacket->Thread = transferPacket->Thread;
    subPacket->IrpFlags = transferPacket->IrpFlags;
    subPacket->ReadPacket = TRUE;
    subPacket->MasterPacket = transferPacket;
    subPacket->Mirror = t;
    subPacket->WhichMember = transferPacket->WhichMember;

    TRANSFER(subPacket);
}

VOID
MIRROR::Recover(
    IN OUT  PMIRROR_TP  TransferPacket
    )

/*++

Routine Description:

    This routine attempts the given read packet sector by sector.  Every
    sector that fails to read because of a bad sector error is retried
    on the other member and then the good data is written back to the
    failed sector if possible.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    ASSERT(TransferPacket->ReadPacket);
    TransferPacket->SavedCompletionRoutine = TransferPacket->CompletionRoutine;
    TransferPacket->CompletionRoutine = MirrorRecoverPhase1;
    _overlappedIoManager.AcquireIoRegion(TransferPacket, TRUE);
}

VOID
MirrorMaxTransferCompletionRoutine(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a sector transfer subordinate
    to a MAX transfer operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_RECOVER_TP  subPacket = (PMIRROR_RECOVER_TP) TransferPacket;
    PMIRROR_TP          masterPacket = (PMIRROR_TP) subPacket->MasterPacket;
    PMIRROR             t = masterPacket->Mirror;
    NTSTATUS            status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (subPacket->Offset + subPacket->Length ==
        masterPacket->Offset + masterPacket->Length) {

        t->Recycle(subPacket, TRUE);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    subPacket->Offset += subPacket->Length;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    TRANSFER(subPacket);
}

VOID
MirrorMaxTransferEmergencyCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion for use of the emergency recover packet
    in a max transfer operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_TP          transferPacket = (PMIRROR_TP) TransferPacket;
    PMIRROR             t = transferPacket->Mirror;
    PMIRROR_RECOVER_TP  subPacket = t->_eRecoverPacket;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(transferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(transferPacket->Mdl),
                      t->QuerySectorSize());

    subPacket->Length = t->QuerySectorSize();
    subPacket->Offset = transferPacket->Offset;
    subPacket->CompletionRoutine = MirrorMaxTransferCompletionRoutine;
    subPacket->TargetVolume = transferPacket->TargetVolume;
    subPacket->Thread = transferPacket->Thread;
    subPacket->IrpFlags = transferPacket->IrpFlags;
    subPacket->ReadPacket = transferPacket->ReadPacket;
    subPacket->MasterPacket = transferPacket;
    subPacket->Mirror = t;
    subPacket->WhichMember = transferPacket->WhichMember;

    TRANSFER(subPacket);
}

VOID
MIRROR::MaxTransfer(
    IN OUT  PMIRROR_TP  TransferPacket
    )

/*++

Routine Description:

    This routine transfers the maximum possible subset of the given transfer
    by doing it one sector at a time.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_RECOVER_TP  subPacket;
    KIRQL               irql;

    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = TransferPacket->Length;

    subPacket = new MIRROR_RECOVER_TP;
    if (subPacket && !subPacket->AllocateMdls(QuerySectorSize())) {
        delete subPacket;
        subPacket = NULL;
    }
    if (!subPacket) {
        KeAcquireSpinLock(&_spinLock, &irql);
        if (_eRecoverPacketInUse) {
            TransferPacket->SavedCompletionRoutine =
                    TransferPacket->CompletionRoutine;
            TransferPacket->CompletionRoutine = MirrorMaxTransferEmergencyCompletion;
            InsertTailList(&_eRecoverPacketQueue, &TransferPacket->QueueEntry);
            KeReleaseSpinLock(&_spinLock, irql);
            return;
        }
        _eRecoverPacketInUse = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);

        subPacket = _eRecoverPacket;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(TransferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(TransferPacket->Mdl),
                      QuerySectorSize());

    subPacket->Length = QuerySectorSize();
    subPacket->Offset = TransferPacket->Offset;
    subPacket->CompletionRoutine = MirrorMaxTransferCompletionRoutine;
    subPacket->TargetVolume = TransferPacket->TargetVolume;
    subPacket->Thread = TransferPacket->Thread;
    subPacket->IrpFlags = TransferPacket->IrpFlags;
    subPacket->ReadPacket = TransferPacket->ReadPacket;
    subPacket->MasterPacket = TransferPacket;
    subPacket->Mirror = this;
    subPacket->WhichMember = TransferPacket->WhichMember;

    TRANSFER(subPacket);
}

class FTP_MIRROR_STATE_WORK_ITEM : public WORK_QUEUE_ITEM {

    public:

        FT_COMPLETION_ROUTINE   CompletionRoutine;
        PVOID                   Context;
        PMIRROR                 Mirror;

};

typedef FTP_MIRROR_STATE_WORK_ITEM* PFTP_MIRROR_STATE_WORK_ITEM;

VOID
MirrorPropogateStateChangesWorker(
    IN  PVOID   Context
    )

/*++

Routine Description:

    This routine is a worker thread routine for propogating state changes.

Arguments:

    Mirror  - Supplies a pointer to the mirror object.

Return Value:

    None.

--*/

{
    PFTP_MIRROR_STATE_WORK_ITEM         context = (PFTP_MIRROR_STATE_WORK_ITEM) Context;
    PMIRROR                             t = context->Mirror;
    KIRQL                               irql;
    FT_MIRROR_AND_SWP_STATE_INFORMATION state;
    NTSTATUS                            status;

    FtpAcquire(t->_rootExtension);

    KeAcquireSpinLock(&t->_spinLock, &irql);
    RtlCopyMemory(&state, &t->_state, sizeof(state));
    KeReleaseSpinLock(&t->_spinLock, irql);

    status = t->_diskInfoSet->WriteStateInformation(t->QueryLogicalDiskId(),
                                                    &state, sizeof(state));

    FtpRelease(t->_rootExtension);

    if (context->CompletionRoutine) {
        context->CompletionRoutine(context->Context, status);
    }
}

VOID
MIRROR::PropogateStateChanges(
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine propogates the changes in the local memory state to
    the on disk state.

Arguments:

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the completion routine context.

Return Value:

    None.

--*/

{
    PFTP_MIRROR_STATE_WORK_ITEM  workItem;

    workItem = (PFTP_MIRROR_STATE_WORK_ITEM)
               ExAllocatePool(NonPagedPool,
                              sizeof(FTP_MIRROR_STATE_WORK_ITEM));
    if (!workItem) {
        return;
    }
    ExInitializeWorkItem(workItem, MirrorPropogateStateChangesWorker, workItem);

    workItem->CompletionRoutine = CompletionRoutine;
    workItem->Context = Context;
    workItem->Mirror = this;

    FtpQueueWorkItem(_rootExtension, workItem);
}

VOID
MirrorCarefulWritePhase2(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine a sector replacement
    for a careful write operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_TP  subPacket = (PMIRROR_TP) TransferPacket;

    subPacket->CompletionRoutine = MirrorCarefulWritePhase1;
    TRANSFER(subPacket);
}

VOID
MirrorCarefulWritePhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine a first attempt of a single sector write
    for a careful write operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_TP  subPacket = (PMIRROR_TP) TransferPacket;
    NTSTATUS    status = subPacket->IoStatus.Status;
    PMIRROR_TP  masterPacket = (PMIRROR_TP) subPacket->MasterPacket;
    PMIRROR     t = subPacket->Mirror;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
        masterPacket->CompletionRoutine(masterPacket);
        t->Recycle(subPacket, TRUE);
        return;
    }

    if (!NT_SUCCESS(status)) {
        if (!subPacket->OneReadFailed) {
            subPacket->CompletionRoutine = MirrorCarefulWritePhase2;
            subPacket->OneReadFailed = TRUE;
            subPacket->TargetVolume->ReplaceBadSector(subPacket);
            return;
        }

        masterPacket->IoStatus = subPacket->IoStatus;
    }

    if (masterPacket->Offset + masterPacket->Length ==
        subPacket->Offset + subPacket->Length) {

        masterPacket->CompletionRoutine(masterPacket);
        t->Recycle(subPacket, TRUE);
        return;
    }

    subPacket->Offset += subPacket->Length;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);
    subPacket->OneReadFailed = FALSE;

    TRANSFER(subPacket);
}

VOID
MirrorCarefulWriteEmergencyCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion for use of the emergency recover packet
    in a careful write operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_TP          transferPacket = (PMIRROR_TP) TransferPacket;
    PMIRROR             t = transferPacket->Mirror;
    PMIRROR_RECOVER_TP  subPacket = t->_eRecoverPacket;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(transferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(transferPacket->Mdl),
                      t->QuerySectorSize());

    subPacket->Length = t->QuerySectorSize();
    subPacket->Offset = transferPacket->Offset;
    subPacket->CompletionRoutine = MirrorCarefulWritePhase1;
    subPacket->TargetVolume = transferPacket->TargetVolume;
    subPacket->Thread = transferPacket->Thread;
    subPacket->IrpFlags = transferPacket->IrpFlags;
    subPacket->ReadPacket = FALSE;
    subPacket->MasterPacket = transferPacket;
    subPacket->Mirror = t;
    subPacket->WhichMember = transferPacket->WhichMember;
    subPacket->OneReadFailed = FALSE;

    TRANSFER(subPacket);
}

VOID
MIRROR::CarefulWrite(
    IN OUT  PMIRROR_TP  TransferPacket
    )

/*++

Routine Description:

    This routine goes through the transfer packet sector by sector
    and fixes write failures when possible.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PMIRROR_RECOVER_TP  subPacket;
    KIRQL               irql;

    ASSERT(!TransferPacket->ReadPacket);

    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = TransferPacket->Length;

    subPacket = new MIRROR_RECOVER_TP;
    if (subPacket && !subPacket->AllocateMdls(QuerySectorSize())) {
        delete subPacket;
        subPacket = NULL;
    }
    if (!subPacket) {
        KeAcquireSpinLock(&_spinLock, &irql);
        if (_eRecoverPacketInUse) {
            TransferPacket->SavedCompletionRoutine =
                    TransferPacket->CompletionRoutine;
            TransferPacket->CompletionRoutine = MirrorCarefulWriteEmergencyCompletion;
            InsertTailList(&_eRecoverPacketQueue, &TransferPacket->QueueEntry);
            KeReleaseSpinLock(&_spinLock, irql);
            return;
        }
        _eRecoverPacketInUse = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);

        subPacket = _eRecoverPacket;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(TransferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(TransferPacket->Mdl),
                      QuerySectorSize());

    subPacket->Length = QuerySectorSize();
    subPacket->Offset = TransferPacket->Offset;
    subPacket->CompletionRoutine = MirrorCarefulWritePhase1;
    subPacket->TargetVolume = TransferPacket->TargetVolume;
    subPacket->Thread = TransferPacket->Thread;
    subPacket->IrpFlags = TransferPacket->IrpFlags;
    subPacket->ReadPacket = FALSE;
    subPacket->MasterPacket = TransferPacket;
    subPacket->Mirror = this;
    subPacket->WhichMember = TransferPacket->WhichMember;
    subPacket->OneReadFailed = FALSE;

    TRANSFER(subPacket);
}

NTSTATUS
MIRROR::QueryPhysicalOffsets(
    IN  LONGLONG                    LogicalOffset,
    OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
    OUT PULONG                      NumberOfPhysicalOffsets
    )
/*++

Routine Description:

    This routine returns physical disk and offset for a given volume
    logical offset.

Arguments:

    LogicalOffset           - Supplies the logical offset

    PhysicalOffsets         - Returns the physical offsets

    NumberOfPhysicalOffsets - Returns the number of physical offsets

Return Value:

    NTSTATUS

--*/
{
    PFT_VOLUME                  vol;
    KIRQL                       irql;
    USHORT                      n, i, numberOfArrays = 0;
    PVOLUME_PHYSICAL_OFFSET*    arrayOfArrays;    
    PULONG                      arrayOfSizes;
    ULONG                       currentSize = 0;
    NTSTATUS                    status;
    FT_MEMBER_STATE             memberState;
    
    if (LogicalOffset < 0 ||
        _volumeSize <= LogicalOffset) {
        return STATUS_INVALID_PARAMETER;
    }
    
    n = QueryNumMembers();

    arrayOfArrays = (PVOLUME_PHYSICAL_OFFSET*) ExAllocatePool(PagedPool, n*sizeof(PVOLUME_PHYSICAL_OFFSET));
    if (!arrayOfArrays) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    arrayOfSizes = (PULONG) ExAllocatePool(PagedPool, n*sizeof(ULONG));
    if (!arrayOfSizes) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            continue;
        }

        KeAcquireSpinLock(&_spinLock, &irql);
        memberState = QueryMemberState(i);
        KeReleaseSpinLock(&_spinLock, irql);
        if (memberState != FtMemberHealthy) {
            continue;
        }
        
        status = vol->QueryPhysicalOffsets(LogicalOffset, &(arrayOfArrays[numberOfArrays]), 
                                           &(arrayOfSizes[numberOfArrays]) );
        if (NT_SUCCESS(status)) {
            currentSize += arrayOfSizes[numberOfArrays++];
        }       
    }

    if (numberOfArrays > 1) {

        *PhysicalOffsets = (PVOLUME_PHYSICAL_OFFSET) ExAllocatePool(PagedPool, currentSize*sizeof(VOLUME_PHYSICAL_OFFSET));
        if (!(*PhysicalOffsets)) {
            for (i = 0; i < numberOfArrays; i++) {
                ExFreePool(arrayOfArrays[i]);
            }
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }
        *NumberOfPhysicalOffsets = currentSize;
        
        currentSize = 0;
        for (i = 0; i < numberOfArrays; i++) {
            RtlCopyMemory(&((*PhysicalOffsets)[currentSize]), arrayOfArrays[i], arrayOfSizes[i]*sizeof(VOLUME_PHYSICAL_OFFSET));
            currentSize += arrayOfSizes[i];
            ExFreePool(arrayOfArrays[i]);
        }

        status = STATUS_SUCCESS;
        goto cleanup;
    }

    if (numberOfArrays == 1) {
        *PhysicalOffsets = arrayOfArrays[0];
        ASSERT(arrayOfSizes[0] == currentSize);
        *NumberOfPhysicalOffsets = currentSize;
        status = STATUS_SUCCESS;
        goto cleanup;
    }

    ASSERT(numberOfArrays == 0);
    status = STATUS_INVALID_PARAMETER;

cleanup:
    ExFreePool(arrayOfArrays);
    ExFreePool(arrayOfSizes);
    return status;
}

NTSTATUS
MIRROR::QueryLogicalOffset(
    IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
    OUT PLONGLONG               LogicalOffset
    )
/*++

Routine Description:

    This routine returns the volume logical offset for a given disk number
    and physical offset.

Arguments:

    PhysicalOffset          - Supplies the physical offset

    LogicalOffset           - Returns the logical offset

Return Value:

    NTSTATUS

--*/
{    
    USHORT          n, i;
    LONGLONG        logicalOffsetInMember;
    NTSTATUS        status;
    PFT_VOLUME      vol;
    KIRQL           irql;
    FT_MEMBER_STATE memberState;
    
    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            continue;
        }

        KeAcquireSpinLock(&_spinLock, &irql);
        memberState = QueryMemberState(i);
        KeReleaseSpinLock(&_spinLock, irql);
        if (memberState != FtMemberHealthy) {
            continue;
        }

        status = vol->QueryLogicalOffset(PhysicalOffset, &logicalOffsetInMember);
        if (NT_SUCCESS(status)) {
            if (_volumeSize <= logicalOffsetInMember) {
                return STATUS_INVALID_PARAMETER;
            }

            *LogicalOffset = logicalOffsetInMember;
            return status;
        }        
    }

    return STATUS_INVALID_PARAMETER;
}

VOID
MIRROR::ModifyStateForUser(
    IN OUT  PVOID   State
    )

/*++

Routine Description:

    This routine modifies the state for the user to see, possibly adding
    non-persistant state different than what is stored on disk.

Arguments:

    State   - Supplies and returns the state for the logical disk.

Return Value:

    None.

--*/

{
    KIRQL                                   irql;
    BOOLEAN                                 isDirty;
    PFT_MIRROR_AND_SWP_STATE_INFORMATION    state;

    KeAcquireSpinLock(&_spinLock, &irql);
    if (_syncOk && !_stopSyncs) {
        isDirty = FALSE;
    } else {
        isDirty = TRUE;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    if (!isDirty) {
        return;
    }

    state = (PFT_MIRROR_AND_SWP_STATE_INFORMATION) State;
    if (state->UnhealthyMemberState == FtMemberHealthy) {
        state->UnhealthyMemberState = FtMemberRegenerating;
        state->UnhealthyMemberNumber = 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\newft\ondisk.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    ondisk.h

Abstract:

    This header file defines the ondisk structures for storing FT
    information on disk.

Author:

    Norbert Kusters 15-July-1996

Notes:

Revision History:

--*/

#include <fttypes.h>

//
// Define an on disk signature so that we can recognize valid FT on disk
// structures.
//

#define FT_ON_DISK_SIGNATURE                    ((ULONG) 'TFTN')
#define FT_ON_DISK_DESCRIPTION_VERSION_NUMBER   (1)

//
// Define the preamble for the on disk structures which contains the
// signature and a pointer to the first FT disk description.
//

typedef struct _FT_ON_DISK_PREAMBLE {
    ULONG   FtOnDiskSignature;
    ULONG   DiskDescriptionVersionNumber;
    ULONG   ByteOffsetToFirstFtLogicalDiskDescription;
    ULONG   ByteOffsetToReplaceLog;
} FT_ON_DISK_PREAMBLE, *PFT_ON_DISK_PREAMBLE;

//
// Define the FT logical disk description structure.
//

typedef struct _FT_LOGICAL_DISK_DESCRIPTION {
    USHORT                  DiskDescriptionSize;
    UCHAR                   DriveLetter;
    UCHAR                   Reserved;
    FT_LOGICAL_DISK_TYPE    LogicalDiskType;
    FT_LOGICAL_DISK_ID      LogicalDiskId;

    union {

        struct {
            LONGLONG    ByteOffset;
            LONGLONG    PartitionSize;  // 0 indicates full size.
        } FtPartition;

        struct {
            FT_LOGICAL_DISK_ID  ThisMemberLogicalDiskId;
            USHORT              ThisMemberNumber;
            USHORT              NumberOfMembers;
            USHORT              ByteOffsetToConfigurationInformation;
            USHORT              ByteOffsetToStateInformation;
        } Other;

    } u;

} FT_LOGICAL_DISK_DESCRIPTION, *PFT_LOGICAL_DISK_DESCRIPTION;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\newft\overlap.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    overlap.cxx

Abstract:

    This module contains code specific to the overlapped io manager.

    The purpose of this module is to help serialize io that overlaps with
    each other.  This class is used by stripes with parity to help prevent
    corruption caused by race conditions when computing parity.

Author:

    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
OVERLAPPED_IO_MANAGER::Initialize(
    IN  ULONG   BucketSize
    )

/*++

Routine Description:

    This routine initializes an overlapped io manager.

Arguments:

    BucketSize  - Supplies the bucket size.  Any I/O to this class may
                    not span more than one bucket.  In the case of stripes
                    with parity, the bucket size is the stripe size.  A
                    bucket size of 0 means that there are no buckets by
                    which requests would be partitioned (alt. an "infinite"
                    bucket size).

Return Value:

    NTSTATUS

--*/

{
    ULONG   i;

    _numQueues = 256;
    _bucketSize = BucketSize;
    if (!_bucketSize) {
        _bucketSize = STRIPE_SIZE;
        _numQueues = 1;
    }
    _spinLock = (PKSPIN_LOCK)
                ExAllocatePool(NonPagedPool, _numQueues*sizeof(KSPIN_LOCK));
    if (!_spinLock) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    _ioQueue = (PLIST_ENTRY)
               ExAllocatePool(NonPagedPool, _numQueues*sizeof(LIST_ENTRY));
    if (!_ioQueue) {
        ExFreePool(_spinLock);
        _spinLock = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (i = 0; i < _numQueues; i++) {
        KeInitializeSpinLock(&_spinLock[i]);
        InitializeListHead(&_ioQueue[i]);
    }

    return STATUS_SUCCESS;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

VOID
OVERLAPPED_IO_MANAGER::AcquireIoRegion(
    IN OUT  POVERLAP_TP TransferPacket,
    IN      BOOLEAN     AllMembers
    )

/*++

Routine Description:

    This routine queues the given transfer packet for its desired region.
    The transfer packet completion routine will be called when the region
    is free.  'ReleaseIoRegion' must be called to allow other transfer packets
    to pass for a region that overlaps with one that is acquired.

Arguments:

    TransferPacket  - Supplies the IO region and completion routine.

    AllMembers      - Supplies whether or not to allocate this region
                        on all members.

Return Value:

    None.

--*/

{
    ULONG       queueNumber;
    PLIST_ENTRY q;
    PKSPIN_LOCK spin;
    KIRQL       irql;
    PLIST_ENTRY l;
    POVERLAP_TP p;

    ASSERT(!TransferPacket->InQueue);

    TransferPacket->AllMembers = AllMembers;
    TransferPacket->OverlappedIoManager = this;

    // Search the queue for a request that overlaps with this one.
    // If there is no overlap then call the completion routine
    // for this transfer packet.  Either way, queue this transfer
    // packet at the end of the queue.

    queueNumber = (ULONG) ((TransferPacket->Offset/_bucketSize)%_numQueues);
    q = &_ioQueue[queueNumber];
    spin = &_spinLock[queueNumber];
    KeAcquireSpinLock(spin, &irql);
    for (l = q->Blink; l != q; l = l->Blink) {

        p = CONTAINING_RECORD(l, OVERLAP_TP, OverlapQueue);

        if ((TransferPacket->AllMembers || p->AllMembers ||
             p->TargetVolume == TransferPacket->TargetVolume) &&
            p->Offset < TransferPacket->Offset + TransferPacket->Length &&
            TransferPacket->Offset < p->Offset + p->Length) {

            break;
        }
    }
    InsertTailList(q, &TransferPacket->OverlapQueue);
    TransferPacket->InQueue = TRUE;
    KeReleaseSpinLock(spin, irql);

    if (l == q) {
        TransferPacket->CompletionRoutine(TransferPacket);
    } else {
        // DbgPrint("Overlap: Transfer packet %x stuck in behind %x\n", TransferPacket, p);
    }
}

VOID
OVERLAPPED_IO_MANAGER::ReleaseIoRegion(
    IN OUT  POVERLAP_TP TransferPacket
    )

/*++

Routine Description:

    This routine releases the IO region held by this packet and
    wakes up waiting transfer packets.

Arguments:

    TransferPacket  - Supplies the TransferPacket whose region is to be
                        released.

Return Value:

    None.

--*/

{
    ULONG               queueNumber;
    PLIST_ENTRY         q;
    PKSPIN_LOCK         spin;
    LIST_ENTRY          completionList;
    KIRQL               irql;
    PLIST_ENTRY         l, ll;
    POVERLAP_TP         p, pp;

    if (!TransferPacket->InQueue) {
        return;
    }

    queueNumber = (ULONG) ((TransferPacket->Offset/_bucketSize)%_numQueues);
    q = &_ioQueue[queueNumber];
    spin = &_spinLock[queueNumber];
    InitializeListHead(&completionList);

    KeAcquireSpinLock(spin, &irql);
    l = TransferPacket->OverlapQueue.Flink;
    RemoveEntryList(&TransferPacket->OverlapQueue);
    TransferPacket->InQueue = FALSE;
    for (; l != q; l = l->Flink) {

        p = CONTAINING_RECORD(l, OVERLAP_TP, OverlapQueue);

        if ((TransferPacket->AllMembers || p->AllMembers ||
             p->TargetVolume == TransferPacket->TargetVolume) &&
            TransferPacket->Offset < p->Offset + p->Length &&
            p->Offset < TransferPacket->Offset + TransferPacket->Length) {

            // This is a candidate for allocation, make sure that it
            // is clear to run by checking for any other contention.

            for (ll = p->OverlapQueue.Blink; ll != q; ll = ll->Blink) {

                pp = CONTAINING_RECORD(ll, OVERLAP_TP, OverlapQueue);

                if ((p->AllMembers || pp->AllMembers ||
                     p->TargetVolume == pp->TargetVolume) &&
                    pp->Offset < p->Offset + p->Length &&
                    p->Offset < pp->Offset + pp->Length) {

                    break;
                }
            }

            if (ll == q) {
                InsertTailList(&completionList, &p->CompletionList);
                // DbgPrint("Overlap: Releasing packet %x that was behind %x\n", p, TransferPacket);
            }
        }
    }
    KeReleaseSpinLock(spin, irql);

    while (!IsListEmpty(&completionList)) {
        l = RemoveHeadList(&completionList);
        p = CONTAINING_RECORD(l, OVERLAP_TP, CompletionList);
        p->CompletionRoutine(p);
    }
}

VOID
OVERLAPPED_IO_MANAGER::PromoteToAllMembers(
    IN OUT  POVERLAP_TP TransferPacket
    )

/*++

Routine Description:

    This routine promotes an already allocated transfer packet to
    all members.

Arguments:

    TransferPacket  - Supplies a transfer packet that is already in
                        the overlapped io queue.

Return Value:

    None.

--*/

{
    ULONG       queueNumber;
    PLIST_ENTRY q;
    PKSPIN_LOCK spin;
    KIRQL       irql;
    PLIST_ENTRY l;
    POVERLAP_TP p;

    if (TransferPacket->AllMembers) {
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    // DbgPrint("Overlap: Promoting %x to all members.\n", TransferPacket);

    queueNumber = (ULONG) ((TransferPacket->Offset/_bucketSize)%_numQueues);
    q = &_ioQueue[queueNumber];
    spin = &_spinLock[queueNumber];
    KeAcquireSpinLock(spin, &irql);
    ASSERT(!TransferPacket->AllMembers);
    TransferPacket->AllMembers = TRUE;
    for (l = q->Blink; l != &TransferPacket->OverlapQueue; l = l->Blink) {

        p = CONTAINING_RECORD(l, OVERLAP_TP, OverlapQueue);

        if (!p->AllMembers &&
            p->TargetVolume != TransferPacket->TargetVolume &&
            TransferPacket->Offset < p->Offset + p->Length &&
            p->Offset < TransferPacket->Offset + TransferPacket->Length) {

            break;
        }
    }
    if (l != &TransferPacket->OverlapQueue) {
        RemoveEntryList(&TransferPacket->OverlapQueue);
        InsertHeadList(l, &TransferPacket->OverlapQueue);
        // DbgPrint("Moving behind %x.\n", p);
    }
    for (l = TransferPacket->OverlapQueue.Blink; l != q; l = l->Blink) {

        p = CONTAINING_RECORD(l, OVERLAP_TP, OverlapQueue);

        if (TransferPacket->Offset < p->Offset + p->Length &&
            p->Offset < TransferPacket->Offset + TransferPacket->Length) {

            break;
        }
    }
    KeReleaseSpinLock(spin, irql);

    if (l == q) {
        TransferPacket->CompletionRoutine(TransferPacket);
    } else {
        // DbgPrint("Overlap: Waiting for %x.\n", p);
    }
}

OVERLAPPED_IO_MANAGER::~OVERLAPPED_IO_MANAGER(
            )

{
    if (_spinLock) {
        ExFreePool(_spinLock);
        _spinLock = NULL;
    }
    if (_ioQueue) {
        ExFreePool(_ioQueue);
        _ioQueue = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\newft\ondisk.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ondisk.cxx

Abstract:

    This file contains the implementation for the classes defined in
    ondisk.hxx

Author:

    Norbert Kusters 15-July-1996

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
IsFormatMediaTypeNEC_98(
    IN  PDEVICE_OBJECT      WholeDisk,
    IN  ULONG               SectorSize,
    OUT PBOOLEAN            FormatMediaTypeIsNEC_98
    )
/*++

Routine Description:

    Determine format media type, PC-9800 architecture or PC/AT architecture
    Logic of determination:
      [removable]                                      - PC/AT architecture
      [fixed] and [0x55AA exist] and [non "IPL1"]    - PC/AT architecture
      [fixed] and [0x55AA exist] and ["IPL1" exist]  - PC-9800 architecture
      [fixed] and [non 0x55AA  ]                     - PC-9800 architecture

Arguments:

    WholeDisk               - Supplies the device object.

    SectorSize              - Supplies the sector size.

    FormatMediaTypeIsNEC_98 - Return format type
                                TRUE   - The media was formated by PC-9800 architecture
                                FALSE  - The media was formated by PC/AT architecture
                                          or it was not formated

Return Value:

--*/
{
    KEVENT              event;
    IO_STATUS_BLOCK     ioStatus;
    PIRP                irp;
    NTSTATUS            status;
    ULONG               readSize;
    PVOID               readBuffer;
    LARGE_INTEGER       byteOffset;

#define IPL1_OFFSET             4
#define BOOT_SIGNATURE_OFFSET   ((0x200 / 2) -1)
#define BOOT_RECORD_SIGNATURE   (0xAA55)

    *FormatMediaTypeIsNEC_98 = FALSE;

    // Is this removable?

    if (WholeDisk->Characteristics&FILE_REMOVABLE_MEDIA) {

        // Removable media is PC/AT architecture.
        return STATUS_SUCCESS;
    }

    // Start at sector 0 of the device.

    readSize = SectorSize;
    byteOffset.QuadPart = 0;

    if (readSize < 512) {
        readSize = 512;
    }

    readBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                readSize < PAGE_SIZE ? PAGE_SIZE : readSize);
    if (!readBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildSynchronousFsdRequest(IRP_MJ_READ, WholeDisk,
                                       readBuffer, readSize, &byteOffset,
                                       &event, &ioStatus);

    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(WholeDisk, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        ExFreePool(readBuffer);
        return status;
    }

    if (((PUSHORT) readBuffer)[BOOT_SIGNATURE_OFFSET] ==
        BOOT_RECORD_SIGNATURE) {

        if (!strncmp((PCHAR) readBuffer + IPL1_OFFSET, "IPL1",
                     sizeof("IPL1") - 1)) {

            // It's PC-9800 Architecture.
            *FormatMediaTypeIsNEC_98 = TRUE;
        }
    } else {

        // It's PC-9800 Architecture.
        *FormatMediaTypeIsNEC_98 = TRUE;
    }

    ExFreePool(readBuffer);
    return STATUS_SUCCESS;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION::Initialize(
    IN      PROOT_EXTENSION RootExtension,
    IN OUT  PDEVICE_OBJECT  WholeDiskPdo
    )

/*++

Routine Description:

    This routine reads in the on disk information on the given device
    into memory.

Arguments:

    RootExtension   - Supplies the root extension.

    WholeDiskPdo    - Supplies the device object for the whole physical disk PDO.

Return Value:

    NTSTATUS

--*/

{
    KEVENT                      event;
    PIRP                        irp;
    STORAGE_DEVICE_NUMBER       deviceNumber;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;
    DISK_GEOMETRY               geometry;
    PDRIVE_LAYOUT_INFORMATION_EX layout;
    ULONG                       i;
    LONGLONG                    offset, minStartingOffset;
    PVOID                       buffer;
    BOOLEAN                     formatMediaTypeIsNEC_98;

    _rootExtension = RootExtension;
    _wholeDisk = IoGetAttachedDeviceReference(WholeDiskPdo);
    _wholeDiskPdo = WholeDiskPdo;
    _diskBuffer = NULL;
    _isDiskSuitableForFtOnDisk = TRUE;

    status = FtpQueryPartitionInformation(RootExtension, _wholeDisk,
                                          &_diskNumber, NULL, NULL, NULL,
                                          NULL, NULL, NULL, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                        _wholeDisk, NULL, 0, &geometry,
                                        sizeof(geometry), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(_wholeDisk, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        return status;
    }

    _sectorSize = geometry.BytesPerSector;

    _byteOffset.QuadPart = 1024;

    HalExamineMBR(_wholeDisk, _sectorSize, 0x55, &buffer);
    if (buffer) {
        _byteOffset.QuadPart = 0x3000;
        ExFreePool(buffer);
    }

    if (IsNEC_98) {
        status = IsFormatMediaTypeNEC_98(_wholeDisk, _sectorSize,
                                         &formatMediaTypeIsNEC_98);

        if (!NT_SUCCESS(status)) {
            FtpLogError(_rootExtension, _diskNumber, FT_CANT_READ_ON_DISK,
                        status, 0);
            _isDiskSuitableForFtOnDisk = FALSE;
            return status;
        }

        if (formatMediaTypeIsNEC_98) {
            _byteOffset.QuadPart = 17*_sectorSize;
        }
    }


    if (_byteOffset.QuadPart < _sectorSize) {
        _byteOffset.QuadPart = _sectorSize;
    }

    status = FtpReadPartitionTableEx(_wholeDisk, &layout);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    minStartingOffset = 0x4000;
    for (i = 0; i < layout->PartitionCount; i++) {
        offset = layout->PartitionEntry[i].StartingOffset.QuadPart;
        if (!offset) {
            continue;
        }
        if (offset < minStartingOffset) {
            minStartingOffset = offset;
        }
    }

    ExFreePool(layout);

    _length = (4095/_sectorSize + 1)*_sectorSize;
    if (_byteOffset.QuadPart + _length > minStartingOffset) {
        if (_byteOffset.QuadPart < minStartingOffset) {
            _length = (ULONG) (minStartingOffset - _byteOffset.QuadPart);
        } else {
            _length = 0;
        }
    }

    if (_length) {
        _diskBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                     _length < PAGE_SIZE ? PAGE_SIZE : _length);
        if (!_diskBuffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        irp = IoBuildSynchronousFsdRequest(IRP_MJ_READ, _wholeDisk,
                                           _diskBuffer, _length, &_byteOffset,
                                           &event, &ioStatus);

        if (!irp) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = IoCallDriver(_wholeDisk, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        if (!NT_SUCCESS(status)) {
            FtpLogError(_rootExtension, _diskNumber, FT_CANT_READ_ON_DISK,
                        status, 0);
            _isDiskSuitableForFtOnDisk = FALSE;
            RtlZeroMemory(_diskBuffer, _length);
            status = STATUS_SUCCESS;
        }

    } else {
        _diskBuffer = NULL;
    }

    return status;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION::Write(
    )

/*++

Routine Description:

    This routine writes out the changes in the disk buffer
    back out to disk.

Arguments:

    None.

Return Value:

    NTSTATUS

--*/

{
    KEVENT                  event;
    PIRP                    irp;
    IO_STATUS_BLOCK         ioStatus;
    NTSTATUS                status;

    if (!_length) {
        return STATUS_SUCCESS;
    }

    if (!_isDiskSuitableForFtOnDisk) {
        ASSERT(FALSE);
        return STATUS_SUCCESS;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildSynchronousFsdRequest(IRP_MJ_WRITE, _wholeDisk,
                                       _diskBuffer, _length, &_byteOffset,
                                       &event, &ioStatus);

    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(_wholeDisk, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        FtpLogError(GetRootExtension(), QueryDiskNumber(),
                    FT_CANT_WRITE_ON_DISK, status, 0);
    }

    return status;
}

PFT_LOGICAL_DISK_DESCRIPTION
FT_LOGICAL_DISK_INFORMATION::AddLogicalDiskDescription(
    IN  PFT_LOGICAL_DISK_DESCRIPTION    LogicalDiskDescription
    )

/*++

Routine Description:

    This routine adds a new logical disk description at the end of the
    list of logical disk descriptions.

Arguments:

    LogicalDiskDescription  - Supplies a new logical disk description.

Return Value:

    A pointer into the on disk buffer where the new logical disk
    description was added or NULL.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    p, last;
    PFT_ON_DISK_PREAMBLE            preamble;

    if (!_length) {
        return NULL;
    }

    if (!_isDiskSuitableForFtOnDisk) {
        FtpLogError(GetRootExtension(), QueryDiskNumber(), FT_NOT_FT_CAPABLE,
                    STATUS_SUCCESS, 0);
        return NULL;
    }

    last = NULL;
    for (p = GetFirstLogicalDiskDescription(); p;
         p = GetNextLogicalDiskDescription(p)) {

        last = p;
    }

    preamble = (PFT_ON_DISK_PREAMBLE) _diskBuffer;

    if (preamble->FtOnDiskSignature == FT_ON_DISK_SIGNATURE &&
        preamble->DiskDescriptionVersionNumber !=
        FT_ON_DISK_DESCRIPTION_VERSION_NUMBER) {

        FtpLogError(GetRootExtension(), QueryDiskNumber(), FT_WRONG_VERSION,
                    STATUS_SUCCESS, 0);
        return NULL;
    }

    if (last) {
        p = (PFT_LOGICAL_DISK_DESCRIPTION)
            ((PCHAR) last + last->DiskDescriptionSize);
    } else {

        preamble->FtOnDiskSignature = FT_ON_DISK_SIGNATURE;
        preamble->DiskDescriptionVersionNumber =
                FT_ON_DISK_DESCRIPTION_VERSION_NUMBER;

        preamble->ByteOffsetToFirstFtLogicalDiskDescription =
                sizeof(FT_ON_DISK_PREAMBLE);
        preamble->ByteOffsetToReplaceLog = 0;

        p = (PFT_LOGICAL_DISK_DESCRIPTION)
            ((PCHAR) preamble +
             preamble->ByteOffsetToFirstFtLogicalDiskDescription);
    }

    if ((PCHAR) p - (PCHAR) preamble +
        LogicalDiskDescription->DiskDescriptionSize + sizeof(USHORT) >
        _length) {

        return NULL;
    }

    ClearReplaceLog();

    RtlMoveMemory(p, LogicalDiskDescription,
                  LogicalDiskDescription->DiskDescriptionSize);

    last = (PFT_LOGICAL_DISK_DESCRIPTION) ((PCHAR) p + p->DiskDescriptionSize);
    last->DiskDescriptionSize = 0;

    return p;
}

ULONG
FT_LOGICAL_DISK_INFORMATION::QueryDiskDescriptionFreeSpace(
    )

/*++

Routine Description:

    This routine returns the free space for new disk
    descriptions.

Arguments:

    None.

Return Value:

    The free space for new disk descriptions.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    p, last;

    if (!_length) {
        return 0;
    }

    if (!_isDiskSuitableForFtOnDisk) {
        FtpLogError(GetRootExtension(), QueryDiskNumber(), FT_NOT_FT_CAPABLE,
                    STATUS_SUCCESS, 0);
        return 0;
    }

    last = NULL;
    for (p = GetFirstLogicalDiskDescription(); p;
         p = GetNextLogicalDiskDescription(p)) {

        last = p;
    }

    if (last) {
        return _length - ((ULONG)((PCHAR) last - (PCHAR) _diskBuffer) +
                          last->DiskDescriptionSize + sizeof(USHORT));
    } else {
        return _length - sizeof(USHORT) - sizeof(FT_ON_DISK_PREAMBLE);
    }
}

VOID
FT_LOGICAL_DISK_INFORMATION::DeleteLogicalDiskDescription(
    IN  PFT_LOGICAL_DISK_DESCRIPTION    LogicalDiskDescription
    )

/*++

Routine Description:

    This routine deletes the given logical disk description from the
    logical disk description list.

Arguments:

    LogicalDiskDescription  - Supplies the logical disk description to
                                delete.

Return Value:

    None.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    p, last;
    BOOLEAN                         exists;
    ULONG                           moveLength;
    PFT_ON_DISK_PREAMBLE            preamble;

    exists = FALSE;
    last = NULL;
    for (p = GetFirstLogicalDiskDescription(); p;
         p = GetNextLogicalDiskDescription(p)) {

        if (p == LogicalDiskDescription) {
            exists = TRUE;
        }

        last = p;
    }

    if (!exists) {
        ASSERT(FALSE);
        return;
    }

    moveLength = (ULONG)((PCHAR) last - (PCHAR) LogicalDiskDescription) +
                 last->DiskDescriptionSize + sizeof(USHORT) -
                 LogicalDiskDescription->DiskDescriptionSize;

    RtlMoveMemory(LogicalDiskDescription,
                  (PCHAR) LogicalDiskDescription +
                  LogicalDiskDescription->DiskDescriptionSize,
                  moveLength);

    if (!GetFirstLogicalDiskDescription()) {
        preamble = (PFT_ON_DISK_PREAMBLE) _diskBuffer;
        preamble->FtOnDiskSignature = 0;
    }
}

BOOLEAN
FT_LOGICAL_DISK_INFORMATION::AddReplaceLog(
    IN  FT_LOGICAL_DISK_ID  ReplacedMemberLogicalDiskId,
    IN  FT_LOGICAL_DISK_ID  NewMemberLogicalDiskId,
    IN  ULONG               NumberOfChangedDiskIds,
    IN  PFT_LOGICAL_DISK_ID OldLogicalDiskIds,
    IN  PFT_LOGICAL_DISK_ID NewLogicalDiskIds
    )

/*++

Routine Description:

    This routine adds the given replace log to the on disk structure.

Arguments:

    NumberOfChangedDiskIds - Supplies the number of replaced disk ids.

    OldLogicalDiskIds       - Supplies the old logical disk ids.

    NewLogicalDiskIds       - Supplies the new logical disk ids.

Return Value:

    FALSE   - Insufficient disk space.

    TRUE    - Success.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    p, last = NULL;
    PFT_LOGICAL_DISK_ID             diskId;
    ULONG                           offset, freeSpace, i;
    PFT_ON_DISK_PREAMBLE            preamble;

    for (p = GetFirstLogicalDiskDescription(); p;
         p = GetNextLogicalDiskDescription(p)) {

        last = p;
    }

    if (!last) {
        return TRUE;
    }

    diskId = (PFT_LOGICAL_DISK_ID)
             ((ULONG_PTR) ((PCHAR) last + last->DiskDescriptionSize +
                       2*sizeof(FT_LOGICAL_DISK_ID))/
              (2*sizeof(FT_LOGICAL_DISK_ID))*
              (2*sizeof(FT_LOGICAL_DISK_ID)));

    offset = (ULONG) ((PCHAR) diskId - (PCHAR) _diskBuffer);
    freeSpace = _length - offset;
    if (freeSpace <
        2*(NumberOfChangedDiskIds + 2)*sizeof(FT_LOGICAL_DISK_ID)) {

        return FALSE;
    }

    preamble = (PFT_ON_DISK_PREAMBLE) _diskBuffer;
    preamble->ByteOffsetToReplaceLog = offset;
    diskId[0] = ReplacedMemberLogicalDiskId;
    diskId[1] = NewMemberLogicalDiskId;
    for (i = 0; i < NumberOfChangedDiskIds; i++) {
        diskId[2*(i + 1)] = OldLogicalDiskIds[i];
        diskId[2*(i + 1) + 1] = NewLogicalDiskIds[i];
    }
    diskId[2*(i + 1)] = 0;

    return TRUE;
}

BOOLEAN
FT_LOGICAL_DISK_INFORMATION::ClearReplaceLog(
    )

/*++

Routine Description:

    This routine clears the replace log.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PFT_ON_DISK_PREAMBLE    preamble;

    preamble = (PFT_ON_DISK_PREAMBLE) _diskBuffer;
    if (preamble->FtOnDiskSignature != FT_ON_DISK_SIGNATURE ||
        preamble->DiskDescriptionVersionNumber !=
        FT_ON_DISK_DESCRIPTION_VERSION_NUMBER ||
        !preamble->ByteOffsetToReplaceLog) {

        return FALSE;
    }

    preamble->ByteOffsetToReplaceLog = 0;

    return TRUE;
}

BOOLEAN
FT_LOGICAL_DISK_INFORMATION::BackOutReplaceOperation(
    )

/*++

Routine Description:

    This routine backs out the given replace operation.

Arguments:

    None.

Return Value:

    FALSE   - No change was made to the on disk structures.

    TRUE    - A change was made to the on disk structures.

--*/

{
    PFT_ON_DISK_PREAMBLE            preamble;
    PFT_LOGICAL_DISK_ID             diskId;
    PFT_LOGICAL_DISK_DESCRIPTION    partition;
    FT_LOGICAL_DISK_ID              child;
    BOOLEAN                         needsBackout;
    PFT_LOGICAL_DISK_DESCRIPTION    other;
    ULONG                           i;

    preamble = (PFT_ON_DISK_PREAMBLE) _diskBuffer;
    if (preamble->FtOnDiskSignature != FT_ON_DISK_SIGNATURE ||
        preamble->DiskDescriptionVersionNumber !=
        FT_ON_DISK_DESCRIPTION_VERSION_NUMBER ||
        !preamble->ByteOffsetToReplaceLog) {

        return FALSE;
    }

    diskId = (PFT_LOGICAL_DISK_ID)
             ((PCHAR) _diskBuffer + preamble->ByteOffsetToReplaceLog);

    for (partition = GetFirstLogicalDiskDescription(); partition;
         partition = GetNextLogicalDiskDescription(partition)) {

        if (partition->LogicalDiskType != FtPartition) {
            continue;
        }

        child = partition->LogicalDiskId;
        needsBackout = TRUE;

        for (other = GetNextLogicalDiskDescription(partition); other;
             other = GetNextLogicalDiskDescription(other)) {

            if (other->LogicalDiskType == FtPartition ||
                other->u.Other.ThisMemberLogicalDiskId != child) {

                continue;
            }

            if (child == diskId[1]) {
                needsBackout = FALSE;
                break;
            }

            child = other->LogicalDiskId;
        }

        if (!needsBackout) {
            continue;
        }

        child = partition->LogicalDiskId;

        for (other = GetNextLogicalDiskDescription(partition); other;
             other = GetNextLogicalDiskDescription(other)) {

            if (other->LogicalDiskType == FtPartition ||
                other->u.Other.ThisMemberLogicalDiskId != child) {

                continue;
            }

            child = other->LogicalDiskId;

            for (i = 2; diskId[i]; i += 2) {
                if (other->LogicalDiskId == diskId[i + 1]) {
                    other->LogicalDiskId = diskId[i];
                } else if (other->u.Other.ThisMemberLogicalDiskId ==
                           diskId[i + 1]) {

                    other->u.Other.ThisMemberLogicalDiskId = diskId[i];
                }
            }
        }
    }

    preamble->ByteOffsetToReplaceLog = 0;

    return TRUE;
}

BOOLEAN
FT_LOGICAL_DISK_INFORMATION::BackOutReplaceOperationIf(
    IN  PFT_LOGICAL_DISK_INFORMATION    LogicalDiskInformation
    )

/*++

Routine Description:

    This routine backs out the given replace operation on this
    logical disk information if there is evidence from the given
    logical disk information that this logical disk information is
    invalid.

Arguments:

    LogicalDiskInformation  - Supplies the logical disk information.

Return Value:

    FALSE   - No change was made to the on disk structures.

    TRUE    - A change was made to the on disk structures.

--*/

{
    PFT_ON_DISK_PREAMBLE            preamble;
    PFT_LOGICAL_DISK_ID             diskId;
    ULONG                           i;
    FT_LOGICAL_DISK_ID              oldRootDiskId, replacedDiskId;
    PFT_LOGICAL_DISK_DESCRIPTION    partition;
    FT_LOGICAL_DISK_ID              child;
    PFT_LOGICAL_DISK_DESCRIPTION    other;

    preamble = (PFT_ON_DISK_PREAMBLE) _diskBuffer;
    if (!preamble ||
        preamble->FtOnDiskSignature != FT_ON_DISK_SIGNATURE ||
        preamble->DiskDescriptionVersionNumber !=
        FT_ON_DISK_DESCRIPTION_VERSION_NUMBER ||
        !preamble->ByteOffsetToReplaceLog) {

        return FALSE;
    }

    diskId = (PFT_LOGICAL_DISK_ID)
             ((PCHAR) _diskBuffer + preamble->ByteOffsetToReplaceLog);

    for (i = 0; ; i++) {
        if (!diskId[i]) {
            break;
        }
    }

    oldRootDiskId = diskId[i - 2];
    replacedDiskId = diskId[0];

    for (partition = LogicalDiskInformation->GetFirstLogicalDiskDescription();
         partition; partition =
         LogicalDiskInformation->GetNextLogicalDiskDescription(partition)) {

        if (partition->LogicalDiskType != FtPartition) {
            continue;
        }

        child = partition->LogicalDiskId;

        for (other =
             LogicalDiskInformation->GetNextLogicalDiskDescription(partition);
             other; other =
             LogicalDiskInformation->GetNextLogicalDiskDescription(other)) {

            if (other->LogicalDiskType == FtPartition ||
                other->u.Other.ThisMemberLogicalDiskId != child) {

                continue;
            }

            if (child == replacedDiskId) {
                break;
            }

            child = other->LogicalDiskId;
        }

        if (child == oldRootDiskId) {
            return BackOutReplaceOperation();
        }
    }

    return FALSE;
}

ULONGLONG
FT_LOGICAL_DISK_INFORMATION::GetGptAttributes(
    )

/*++

Routine Description:

    This routine returns the simulated GPT attribute bits on sector 2 if
    present, otherwise it returns 0.

Arguments:

    None.

Return Value:

    GPT attribute bits.

--*/

{
    GUID*       pguid;
    PULONGLONG  p;

    pguid = (GUID*) _diskBuffer;
    if (!pguid) {
        return 0;
    }

    if (!IsEqualGUID(*pguid, PARTITION_BASIC_DATA_GUID)) {
        return 0;
    }

    p = (PULONGLONG) ((PCHAR) _diskBuffer + sizeof(GUID));

    return *p;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION::SetGptAttributes(
    IN  ULONGLONG   GptAttributes
    )

/*++

Routine Description:

    This routine sets the GPT simulated attributes bits on sector 2 of this
    MBR disk.

Arguments:

    GptAttributes   - Supplies the GPT attributes.

Return Value:

    NTSTATUS

--*/

{
    LONGLONG                offset;
    PFT_ON_DISK_PREAMBLE    preamble;
    GUID*                   pguid;
    PULONGLONG              p;

    offset = 1024;
    if (offset < _sectorSize) {
        offset = _sectorSize;
    }
    preamble = (PFT_ON_DISK_PREAMBLE) _diskBuffer;
    if (!_diskBuffer || !_isDiskSuitableForFtOnDisk ||
        _byteOffset.QuadPart != offset ||
        preamble->FtOnDiskSignature == FT_ON_DISK_SIGNATURE) {

        return STATUS_INVALID_PARAMETER;
    }

    pguid = (GUID*) _diskBuffer;
    *pguid = PARTITION_BASIC_DATA_GUID;
    p = (PULONGLONG) ((PCHAR) _diskBuffer + sizeof(GUID));
    *p = GptAttributes;

    return Write();
}

FT_LOGICAL_DISK_INFORMATION::~FT_LOGICAL_DISK_INFORMATION(
    )

/*++

Routine Description:

    This routine is the destructor for this class.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (_wholeDisk != _wholeDiskPdo) {
        ObDereferenceObject(_wholeDisk);
    }
    if (_diskBuffer) {
        ExFreePool(_diskBuffer);
    }
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION_SET::Initialize(
    )

/*++

Routine Description:

    This routine initializes the class for use.

Arguments:

    None.

Return Value:

    NTSTATUS

--*/

{
    _numberOfLogicalDiskInformations = 0;
    _arrayOfLogicalDiskInformations = NULL;
    _numberOfRootLogicalDisksIds = 0;
    _arrayOfRootLogicalDiskIds = NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION_SET::AddLogicalDiskInformation(
    IN  PFT_LOGICAL_DISK_INFORMATION    LogicalDiskInformation,
    OUT PBOOLEAN                        ChangedLogicalDiskIds
    )

/*++

Routine Description:

    This routine adds a logical disk information structure to this
    set of logical disk information structures.

Arguments:

    LogicalDiskInformation  - Supplies the disk information to add.

    ChangedLogicalDiskIds   - Returns whether or not any existing logical
                                disk ids have changed.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                        status;
    PDRIVE_LAYOUT_INFORMATION_EX    layout;
    PFT_LOGICAL_DISK_DESCRIPTION    p, q, r;
    ULONG                           numEntries, i, j;
    PFT_LOGICAL_DISK_INFORMATION*   n;
    BOOLEAN                         error;
    PPARTITION_INFORMATION_EX       partInfo;
    ULONG                           configLength, stateLength;
    PCHAR                           pc, qc;
    ULONG                           uniqueError;

    if (ChangedLogicalDiskIds) {
        *ChangedLogicalDiskIds = FALSE;
    }


    // Check for any partial replace operations that need to be backed out.

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        if (_arrayOfLogicalDiskInformations[i]->BackOutReplaceOperationIf(
            LogicalDiskInformation)) {

            _arrayOfLogicalDiskInformations[i]->Write();

            if (ChangedLogicalDiskIds) {
                *ChangedLogicalDiskIds = TRUE;
            }
        }

        if (LogicalDiskInformation->BackOutReplaceOperationIf(
            _arrayOfLogicalDiskInformations[i])) {

            LogicalDiskInformation->Write();
        }
    }


    // Read in the partition table for future reference.

    status = FtpReadPartitionTableEx(LogicalDiskInformation->GetWholeDisk(),
                                     &layout);
    if (!NT_SUCCESS(status)) {
        return status;
    }


    // First count how many entries are in the given list and also perform
    // a sanity check on these entries.

    numEntries = 0;
    for (p = LogicalDiskInformation->GetFirstLogicalDiskDescription(); p; ) {

        if (!p->DiskDescriptionSize) {
            break;
        }

        error = FALSE;

        if (p->DiskDescriptionSize < sizeof(FT_LOGICAL_DISK_DESCRIPTION) ||
            p->LogicalDiskId == 0) {

            DbgPrint("Disk Description too small, %x, or no logical disk id %I64x\n",
                     p->DiskDescriptionSize, p->LogicalDiskId);
            error = TRUE;
            uniqueError = 1;
        }

        if (!error && p->LogicalDiskType == FtPartition) {

            for (i = 0; i < layout->PartitionCount; i++) {
                partInfo = &layout->PartitionEntry[i];
                if (partInfo->StartingOffset.QuadPart ==
                    p->u.FtPartition.ByteOffset &&
                    (partInfo->Mbr.PartitionType&0x80)) {

                    break;
                }
            }

            if (i == layout->PartitionCount) {
                error = TRUE;
                uniqueError = 2;
                DbgPrint("Partition not found in partition table.\n");
                DbgPrint("Partition start = %I64x\n", p->u.FtPartition.ByteOffset);
                DbgPrint("Drive layout partition count = %d\n", layout->PartitionCount);
            } else if (GetLogicalDiskDescription(p->LogicalDiskId, 0)) {
                error = TRUE;
                uniqueError = 3;
                DbgPrint("Duplicate logical disk description on other disk: %I64x\n",
                         p->LogicalDiskId);
            } else {

                for (q = LogicalDiskInformation->GetFirstLogicalDiskDescription();
                     q != p;
                     q = LogicalDiskInformation->GetNextLogicalDiskDescription(q)) {

                    if (p->LogicalDiskId == q->LogicalDiskId) {
                        error = TRUE;
                        uniqueError = 4;
                        DbgPrint("Duplicate logical disk description on same disk: %I64x\n",
                                 p->LogicalDiskId);
                    } else if (q->LogicalDiskType == FtPartition &&
                               p->u.FtPartition.ByteOffset ==
                               q->u.FtPartition.ByteOffset) {

                        error = TRUE;
                        uniqueError = 100;
                        DbgPrint("%I64x and %I64x are FtPartitions pointing to offset %x\n",
                                 p->LogicalDiskId, q->LogicalDiskId,
                                 p->u.FtPartition.ByteOffset);
                    }
                }
            }

        } else if (!error) {

            for (q = LogicalDiskInformation->GetFirstLogicalDiskDescription();
                 q != p;
                 q = LogicalDiskInformation->GetNextLogicalDiskDescription(q)) {

                if (p->u.Other.ThisMemberLogicalDiskId == q->LogicalDiskId) {
                    break;
                }
            }

            if (p == q) {
                error = TRUE;
                uniqueError = 5;
                DbgPrint("This member logical disk id not found %I64x\n",
                         p->u.Other.ThisMemberLogicalDiskId);
            }

            if (p->u.Other.ThisMemberNumber >= p->u.Other.NumberOfMembers) {
                error = TRUE;
                uniqueError = 6;
                DbgPrint("This member number %d >= number of members %d\n",
                         p->u.Other.ThisMemberNumber, p->u.Other.NumberOfMembers);
            }

            if (p->u.Other.ThisMemberLogicalDiskId == p->LogicalDiskId) {
                error = TRUE;
                uniqueError = 7;
                DbgPrint("This member logical disk == logical disk == %I64x\n",
                         p->LogicalDiskId);
            }

            if (p->u.Other.ByteOffsetToConfigurationInformation &&
                p->u.Other.ByteOffsetToConfigurationInformation <
                sizeof(FT_LOGICAL_DISK_DESCRIPTION)) {

                error = TRUE;
                uniqueError = 8;
                DbgPrint("Byte offset to config info too small: %d\n",
                         p->u.Other.ByteOffsetToConfigurationInformation);
            }

            if (p->u.Other.ByteOffsetToStateInformation &&
                p->u.Other.ByteOffsetToStateInformation <
                sizeof(FT_LOGICAL_DISK_DESCRIPTION)) {

                error = TRUE;
                uniqueError = 9;
                DbgPrint("Byte offset to state info too small: %d\n",
                         p->u.Other.ByteOffsetToStateInformation);
            }

            if (p->u.Other.ByteOffsetToConfigurationInformation &&
                p->u.Other.ByteOffsetToStateInformation &&
                p->u.Other.ByteOffsetToConfigurationInformation >=
                p->u.Other.ByteOffsetToStateInformation) {

                error = TRUE;
                uniqueError = 10;
                DbgPrint("Config info %d past state info %d\n",
                         p->u.Other.ByteOffsetToConfigurationInformation,
                         p->u.Other.ByteOffsetToStateInformation);
            }

            if (p->u.Other.ByteOffsetToConfigurationInformation >=
                p->DiskDescriptionSize) {

                error = TRUE;
                uniqueError = 11;
                DbgPrint("Byte offset to config info too large: %d vs. %d\n",
                         p->u.Other.ByteOffsetToConfigurationInformation,
                         p->DiskDescriptionSize);
            }

            if (p->u.Other.ByteOffsetToStateInformation >=
                p->DiskDescriptionSize) {

                error = TRUE;
                uniqueError = 12;
                DbgPrint("Byte offset to state info too large: %d vs. %d\n",
                         p->u.Other.ByteOffsetToStateInformation,
                         p->DiskDescriptionSize);
            }

            if (!error && p->u.Other.ByteOffsetToConfigurationInformation) {
                if (p->u.Other.ByteOffsetToStateInformation) {
                    configLength = p->u.Other.ByteOffsetToStateInformation -
                                   p->u.Other.ByteOffsetToConfigurationInformation;
                } else {
                    configLength = p->DiskDescriptionSize -
                                   p->u.Other.ByteOffsetToConfigurationInformation;
                }

                switch (p->LogicalDiskType) {
                    case FtStripeSet:
                        if (configLength <
                            sizeof(FT_STRIPE_SET_CONFIGURATION_INFORMATION)) {

                            error = TRUE;
                            uniqueError = 13;
                            DbgPrint("Stripe config too small: %d\n",
                                     configLength);
                        }
                        break;

                    case FtMirrorSet:
                        if (configLength <
                            sizeof(FT_MIRROR_SET_CONFIGURATION_INFORMATION)) {

                            error = TRUE;
                            uniqueError = 14;
                            DbgPrint("Mirror config too small: %d\n",
                                     configLength);
                        }
                        break;

                    case FtStripeSetWithParity:
                        if (configLength <
                            sizeof(FT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION)) {

                            error = TRUE;
                            uniqueError = 15;
                            DbgPrint("SWP config too small: %d\n",
                                     configLength);
                        }
                        break;

                    case FtRedistribution:
                        if (configLength <
                            sizeof(FT_REDISTRIBUTION_CONFIGURATION_INFORMATION)) {

                            error = TRUE;
                            uniqueError = 16;
                            DbgPrint("Redistrubution config too small: %d\n",
                                     configLength);
                        }
                        break;

                }
            }


            if (!error && p->u.Other.ByteOffsetToStateInformation) {
                stateLength = p->DiskDescriptionSize -
                              p->u.Other.ByteOffsetToStateInformation;

                switch (p->LogicalDiskType) {
                    case FtMirrorSet:
                    case FtStripeSetWithParity:
                        if (stateLength <
                            sizeof(FT_MIRROR_AND_SWP_STATE_INFORMATION)) {

                            error = TRUE;
                            uniqueError = 17;
                            DbgPrint("State too small: %d\n", stateLength);
                        }
                        break;

                    case FtRedistribution:
                        if (stateLength <
                            sizeof(FT_REDISTRIBUTION_STATE_INFORMATION)) {

                            error = TRUE;
                            uniqueError = 18;
                            DbgPrint("Redist State too small: %d\n", stateLength);
                        }
                        break;

                }
            }

            if (error) {
                q = NULL;
            } else {
                if (!(q = GetLogicalDiskDescription(p->LogicalDiskId, 0))) {

                    for (q = LogicalDiskInformation->GetFirstLogicalDiskDescription();
                         q != p;
                         q = LogicalDiskInformation->GetNextLogicalDiskDescription(q)) {

                        if (q->LogicalDiskId == p->LogicalDiskId) {
                            break;
                        }
                    }

                    if (q == p) {
                        q = NULL;
                    }

                    if (q) {
                        for (r = q; r != p;
                             r = LogicalDiskInformation->
                             GetNextLogicalDiskDescription(r)) {

                            if (r->LogicalDiskId == p->LogicalDiskId) {
                                if (p->u.Other.ThisMemberNumber ==
                                    r->u.Other.ThisMemberNumber ||
                                    p->u.Other.ThisMemberLogicalDiskId ==
                                    r->u.Other.ThisMemberLogicalDiskId) {

                                    error = TRUE;
                                    uniqueError = 19;
                                    DbgPrint("Matching logical disks %I64x\n",
                                             p->LogicalDiskId);
                                    DbgPrint("have same member number %d, %d\n",
                                             p->u.Other.ThisMemberNumber,
                                             r->u.Other.ThisMemberNumber);
                                    DbgPrint("or same member disk id %I64x, %I64x\n",
                                             p->u.Other.ThisMemberLogicalDiskId,
                                             r->u.Other.ThisMemberLogicalDiskId);
                                    break;
                                }
                            }
                        }
                    }
                }
            }

            if (q) {
                if (p->DiskDescriptionSize != q->DiskDescriptionSize ||
                    p->LogicalDiskType != q->LogicalDiskType ||
                    p->u.Other.NumberOfMembers !=
                    q->u.Other.NumberOfMembers ||
                    p->u.Other.ByteOffsetToConfigurationInformation !=
                    q->u.Other.ByteOffsetToConfigurationInformation ||
                    p->u.Other.ByteOffsetToStateInformation !=
                    q->u.Other.ByteOffsetToStateInformation) {

                    error = TRUE;
                    uniqueError = 20;
                    DbgPrint("Matching logical disks %I64x\n", p->LogicalDiskId);
                    DbgPrint("have different description size %d, %d\n",
                             p->DiskDescriptionSize, q->DiskDescriptionSize);
                    DbgPrint("or different logical disk type %d, %d\n",
                             p->LogicalDiskType, q->LogicalDiskType);
                    DbgPrint("or different number of members %d, %d\n",
                             p->u.Other.NumberOfMembers, q->u.Other.NumberOfMembers);
                    DbgPrint("or different offsets to config %d, %d\n",
                             p->u.Other.ByteOffsetToConfigurationInformation,
                             q->u.Other.ByteOffsetToConfigurationInformation);
                    DbgPrint("or different offsets to state %d, %d\n",
                             p->u.Other.ByteOffsetToStateInformation,
                             q->u.Other.ByteOffsetToStateInformation);
                }

                if (!error &&
                    p->u.Other.ByteOffsetToConfigurationInformation) {

                    pc = (PCHAR) p +
                         p->u.Other.ByteOffsetToConfigurationInformation;
                    qc = (PCHAR) q +
                         q->u.Other.ByteOffsetToConfigurationInformation;

                    if (RtlCompareMemory(pc, qc, configLength) !=
                        configLength) {

                        error = TRUE;
                        uniqueError = 21;
                        DbgPrint("Matching logical disks %I64x\n",
                                 p->LogicalDiskId);
                        DbgPrint("have different configuration information\n");
                    }
                }
            }

            if (!error) {

                for (i = 0; q = GetLogicalDiskDescription(p->LogicalDiskId, i);
                     i++) {

                    if (q->u.Other.ThisMemberLogicalDiskId ==
                        p->u.Other.ThisMemberLogicalDiskId &&
                        q->u.Other.ThisMemberNumber !=
                        p->u.Other.ThisMemberNumber) {

                        error = TRUE;
                        uniqueError = 22;
                        DbgPrint("Different members map to the same disk\n");
                        DbgPrint("--- %I64x, member %d and member %d\n",
                                 p->u.Other.ThisMemberLogicalDiskId,
                                 q->u.Other.ThisMemberNumber,
                                 p->u.Other.ThisMemberNumber);
                    }

                    if (q->u.Other.ThisMemberNumber ==
                        p->u.Other.ThisMemberNumber &&
                        q->u.Other.ThisMemberLogicalDiskId !=
                        p->u.Other.ThisMemberLogicalDiskId) {

                        error = TRUE;
                        uniqueError = 23;
                        DbgPrint("Member %d of %I64x is defined twice.\n",
                                 q->u.Other.ThisMemberNumber,
                                 p->LogicalDiskId);
                        DbgPrint("---- once as %I64x and then as %I64x.\n",
                                 q->u.Other.ThisMemberLogicalDiskId,
                                 p->u.Other.ThisMemberLogicalDiskId);
                    }
                }
            }
        }

        if (!error) {

            q = GetParentLogicalDiskDescription(p->LogicalDiskId);
            for (r = LogicalDiskInformation->
                 GetNextLogicalDiskDescription(p); r;
                 r = LogicalDiskInformation->
                 GetNextLogicalDiskDescription(r)) {

                if (r->LogicalDiskType != FtPartition &&
                    r->u.Other.ThisMemberLogicalDiskId ==
                    p->LogicalDiskId) {

                    break;
                }
            }

            if (q) {

                if (!r) {

                    // The set indicates that p->LogicalDiskId has a parent
                    // but this logical disk information does not have a
                    // parent.  Therefore, add a parent to match.

                    LogicalDiskInformation->AddLogicalDiskDescription(q);
                    LogicalDiskInformation->Write();

                } else if (q->LogicalDiskId != r->LogicalDiskId ||
                           q->u.Other.ThisMemberNumber !=
                           r->u.Other.ThisMemberNumber) {

                    error = TRUE;
                    uniqueError = 24;
                    DbgPrint("No parent on this disk info for %I64x\n",
                             p->LogicalDiskId);
                }

            } else if (r && GetLogicalDiskDescription(p->LogicalDiskId, 0)) {

                error = TRUE;
                uniqueError = 25;
                DbgPrint("Parent on this disk info that doesn't exist\n");
                DbgPrint("in the set.  %I64x\n", p->LogicalDiskId,
                r->LogicalDiskId);
            }
        }

        if (error) {

            FtpLogError(LogicalDiskInformation->GetRootExtension(),
                        LogicalDiskInformation->QueryDiskNumber(),
                        FT_CORRUPT_DISK_DESCRIPTION, STATUS_SUCCESS,
                        uniqueError);

            DbgPrint("Deleting logical disk description %I64x\n",
                     p->LogicalDiskId);
            DbgPrint("Description size = %d\n", p->DiskDescriptionSize);
            DbgPrint("Disk type = %d\n", p->LogicalDiskType);
            if (p->LogicalDiskType == FtPartition) {
                DbgPrint("Byte offset = %I64x\n", p->u.FtPartition.ByteOffset);
            } else {
                DbgPrint("This member = %I64x\n", p->u.Other.ThisMemberLogicalDiskId);
                DbgPrint("This member number = %d\n", p->u.Other.ThisMemberNumber);
                DbgPrint("Number of members = %d\n", p->u.Other.NumberOfMembers);
                DbgPrint("Offset to config = %d\n", p->u.Other.ByteOffsetToConfigurationInformation);
                DbgPrint("Offset to state = %d\n", p->u.Other.ByteOffsetToStateInformation);
            }

            LogicalDiskInformation->DeleteLogicalDiskDescription(p);
            LogicalDiskInformation->Write();
        } else {
            p = LogicalDiskInformation->GetNextLogicalDiskDescription(p);
            numEntries++;
        }
    }

    ExFreePool(layout);


    // Realloc the logical disk informations array.

    n = (PFT_LOGICAL_DISK_INFORMATION*)
        ExAllocatePool(NonPagedPool, sizeof(PFT_LOGICAL_DISK_INFORMATION)*
                       (_numberOfLogicalDiskInformations + 1));
    if (!n) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (_numberOfLogicalDiskInformations) {
        RtlMoveMemory(n, _arrayOfLogicalDiskInformations,
                      sizeof(PFT_LOGICAL_DISK_INFORMATION)*
                      _numberOfLogicalDiskInformations);
        ExFreePool(_arrayOfLogicalDiskInformations);
    }
    _arrayOfLogicalDiskInformations = n;


    // Realloc the root array so that it is at least large enough.

    if (!ReallocRootLogicalDiskIds(_numberOfRootLogicalDisksIds + numEntries)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    // Now add the logical disk information to this list.

    _arrayOfLogicalDiskInformations[_numberOfLogicalDiskInformations++] =
            LogicalDiskInformation;


    // Recompute the list of root disk ids.

    RecomputeArrayOfRootLogicalDiskIds();

    return STATUS_SUCCESS;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION_SET::RemoveLogicalDiskInformation(
    IN OUT  PDEVICE_OBJECT  WholeDiskPdo
    )

/*++

Routine Description:

    This routine removes the logical disk information associated with the
    given whole disk device object from the disk information set.

Arguments:

    WholeDiskPdo    - Supplies the device object.

Return Value:

    NTSTATUS

--*/

{
    ULONG                           i;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        if (diskInfo->GetWholeDiskPdo() == WholeDiskPdo) {
            break;
        }
    }

    if (i == _numberOfLogicalDiskInformations) {
        return STATUS_NOT_FOUND;
    }

    _numberOfLogicalDiskInformations--;

    RtlMoveMemory(&_arrayOfLogicalDiskInformations[i],
                  &_arrayOfLogicalDiskInformations[i + 1],
                  (_numberOfLogicalDiskInformations - i)*
                  sizeof(PFT_LOGICAL_DISK_INFORMATION));

    RecomputeArrayOfRootLogicalDiskIds();

    delete diskInfo;

    return STATUS_SUCCESS;
}

BOOLEAN
FT_LOGICAL_DISK_INFORMATION_SET::IsDiskInSet(
    IN OUT  PDEVICE_OBJECT  WholeDiskPdo
    )

/*++

Routine Description:

    This routine removes the logical disk information associated with the
    given whole disk device object from the disk information set.

Arguments:

    WholeDiskPdo    - Supplies the device object.

Return Value:

    FALSE   - The PDO is not in the set.

    TRUE    - The PDO is in the set.

--*/

{
    ULONG                           i;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        if (diskInfo->GetWholeDiskPdo() == WholeDiskPdo) {
            return TRUE;
        }
    }

    return FALSE;
}

PFT_LOGICAL_DISK_DESCRIPTION
FT_LOGICAL_DISK_INFORMATION_SET::GetLogicalDiskDescription(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  ULONG               InstanceNumber
    )

/*++

Routine Description:

    This routine returns the logical disk description for the given
    instance number and logical disk id.

Arguments:

    LogicalDiskId   - Supplies the logical disk id.

    InstanceNumber  - Supplies the instance number.

Return Value:

    A logical disk decription.

--*/

{
    ULONG                           i, instanceNumber;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    instanceNumber = 0;
    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
             p = diskInfo->GetNextLogicalDiskDescription(p)) {

            if (p->LogicalDiskId == LogicalDiskId) {
                if (InstanceNumber == instanceNumber) {
                    return p;
                } else {
                    instanceNumber++;
                }
            }
        }
    }

    return NULL;
}

ULONG
FT_LOGICAL_DISK_INFORMATION_SET::QueryNumberOfRootLogicalDiskIds(
    )

/*++

Routine Description:

    This routine returns the number of root logical disk ids.

Arguments:

    None.

Return Value:

    The number of root logical disk ids.

--*/

{
    return _numberOfRootLogicalDisksIds;
}

FT_LOGICAL_DISK_ID
FT_LOGICAL_DISK_INFORMATION_SET::QueryRootLogicalDiskId(
    IN  ULONG   Index
    )

/*++

Routine Description:

    This routine returns the 'Index'th root logical disk id.

Arguments:

    Index   - Supplies the 0 based index.

Return Value:

    The 'Index'th root logical disk id.

--*/

{
    if (Index >= _numberOfRootLogicalDisksIds) {
        return 0;
    }

    return _arrayOfRootLogicalDiskIds[Index];
}

FT_LOGICAL_DISK_ID
FT_LOGICAL_DISK_INFORMATION_SET::QueryRootLogicalDiskIdForContainedPartition(
    IN  ULONG       DiskNumber,
    IN  LONGLONG    Offset
    )

/*++

Routine Description:

    This routine returns the root logical disk id of the logical disk that
    contains the given partition.

Arguments:

    DiskNumber  - Supplies the disk number of the whole disk
                    of the partition.

    Offset      - Supplies the offset of the partition.

Return Value:

    The logical disk id of the root disk containing the given partition or 0.

--*/

{
    ULONG                           i;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    p;
    FT_LOGICAL_DISK_ID              id;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        if (diskInfo->QueryDiskNumber() == DiskNumber) {
            break;
        }
    }

    if (i == _numberOfLogicalDiskInformations) {
        return 0;
    }

    id = 0;
    for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
         p = diskInfo->GetNextLogicalDiskDescription(p)) {

        if (id) {
            if (p->LogicalDiskType != FtPartition &&
                p->u.Other.ThisMemberLogicalDiskId == id) {

                id = p->LogicalDiskId;
            }
        } else {
            if (p->LogicalDiskType == FtPartition &&
                p->u.FtPartition.ByteOffset == Offset) {

                id = p->LogicalDiskId;
            }
        }
    }

    return id;
}

FT_LOGICAL_DISK_ID
FT_LOGICAL_DISK_INFORMATION_SET::QueryPartitionLogicalDiskId(
    IN  ULONG       DiskNumber,
    IN  LONGLONG    Offset
    )

/*++

Routine Description:

    This routine returns the logical disk id for the given partition.

Arguments:

    DiskNumber  - Supplies the disk number of the whole disk
                    of the partition.

    Offset      - Supplies the offset of the partition.

Return Value:

    A logical disk id or 0.

--*/

{
    ULONG                           i;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        if (diskInfo->QueryDiskNumber() == DiskNumber) {
            break;
        }
    }

    if (i == _numberOfLogicalDiskInformations) {
        return 0;
    }

    for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
         p = diskInfo->GetNextLogicalDiskDescription(p)) {

        if (p->LogicalDiskType == FtPartition &&
            p->u.FtPartition.ByteOffset == Offset) {

            return p->LogicalDiskId;
        }
    }

    return 0;
}

USHORT
FT_LOGICAL_DISK_INFORMATION_SET::QueryNumberOfMembersInLogicalDisk(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine returns the number of members in a logical disk.

Arguments:

    LogicalDiskId   - Supplies the logical disk id.

Return Value:

    The number of members in a logical disk.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    p = GetLogicalDiskDescription(LogicalDiskId, 0);
    if (!p) {
        ASSERT(FALSE);
        return 0;
    }

    if (p->LogicalDiskType == FtPartition) {
        return 0;
    }

    return p->u.Other.NumberOfMembers;
}

FT_LOGICAL_DISK_ID
FT_LOGICAL_DISK_INFORMATION_SET::QueryMemberLogicalDiskId(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  USHORT              MemberNumber
    )

/*++

Routine Description:

    This routine returns the logical disk id for the given member number.

Arguments:

    LogicalDiskId   - Supplies the logical disk id.

    MemberNumber    - Supplies the requested member number.

Return Value:

    The logical disk id of the given member number.

--*/

{
    ULONG                           i;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
             p = diskInfo->GetNextLogicalDiskDescription(p)) {

            if (p->LogicalDiskId == LogicalDiskId) {
                ASSERT(p->LogicalDiskType != FtPartition);
                if (p->u.Other.ThisMemberNumber == MemberNumber) {
                    return p->u.Other.ThisMemberLogicalDiskId;
                }
            }
        }
    }

    return 0;
}

FT_LOGICAL_DISK_TYPE
FT_LOGICAL_DISK_INFORMATION_SET::QueryLogicalDiskType(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine returns the logical disk type for the given logical disk
    id.

Arguments:

    LogicalDiskId   - Supplies the logical disk id.

Return Value:

    The logical disk type for the given logical disk id.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    p = GetLogicalDiskDescription(LogicalDiskId, 0);
    if (!p) {
        ASSERT(FALSE);
        return FtPartition;
    }

    return p->LogicalDiskType;
}

BOOLEAN
FT_LOGICAL_DISK_INFORMATION_SET::QueryFtPartitionInformation(
    IN  FT_LOGICAL_DISK_ID  PartitionLogicalDiskId,
    OUT PLONGLONG           Offset,
    OUT PDEVICE_OBJECT*     WholeDisk,
    OUT PULONG              DiskNumber,
    OUT PULONG              SectorSize,
    OUT PLONGLONG           PartitionSize
    )

/*++

Routine Description:

    This routine returns information about the given partition.

Arguments:

    PartitionLogicalDiskId  - Supplies the logical disk id.

    Offset                  - Returns the partition offset.

    WholeDisk               - Returns the whole disk device object.

    DiskNumber              - Returns the disk number.

    SectorSize              - Returns the sector size.

    PartitionSize           - Returns the partition size.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    ULONG                           i, instanceNumber;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    instanceNumber = 0;
    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
             p = diskInfo->GetNextLogicalDiskDescription(p)) {

            if (p->LogicalDiskId == PartitionLogicalDiskId) {
                if (p->LogicalDiskType != FtPartition) {
                    return FALSE;
                }
                if (Offset) {
                    *Offset = p->u.FtPartition.ByteOffset;
                }
                if (WholeDisk) {
                    *WholeDisk = diskInfo->GetWholeDisk();
                }
                if (DiskNumber) {
                    *DiskNumber = diskInfo->QueryDiskNumber();
                }
                if (SectorSize) {
                    *SectorSize = diskInfo->QuerySectorSize();
                }
                if (PartitionSize) {
                    *PartitionSize = p->u.FtPartition.PartitionSize;
                }
                return TRUE;
            }
        }
    }

    return FALSE;
}

PVOID
FT_LOGICAL_DISK_INFORMATION_SET::GetConfigurationInformation(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine returns a pointer to the configuration information
    for the given logical disk.

Arguments:

    LogicalDiskId   - Supplies the logical disk id.

Return Value:

    A pointer to the configuration information for the given logical disk.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    p = GetLogicalDiskDescription(LogicalDiskId, 0);
    if (!p) {
        ASSERT(FALSE);
        return NULL;
    }

    if (p->LogicalDiskType == FtPartition) {
        ASSERT(FALSE);
        return NULL;
    }

    if (!p->u.Other.ByteOffsetToConfigurationInformation) {
        return NULL;
    }

    return ((PCHAR) p + p->u.Other.ByteOffsetToConfigurationInformation);
}

PVOID
FT_LOGICAL_DISK_INFORMATION_SET::GetStateInformation(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine returns a pointer to the state information
    for the given logical disk.

Arguments:

    LogicalDiskId   - Supplies the logical disk id.

Return Value:

    A pointer to the state information for the given logical disk.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    p = GetLogicalDiskDescription(LogicalDiskId, 0);
    if (!p) {
        ASSERT(FALSE);
        return NULL;
    }

    if (p->LogicalDiskType == FtPartition ||
        !p->u.Other.ByteOffsetToStateInformation) {

        return NULL;
    }

    return ((PCHAR) p + p->u.Other.ByteOffsetToStateInformation);
}

BOOLEAN
FT_LOGICAL_DISK_INFORMATION_SET::IsLogicalDiskComplete(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine computes whether or not a given logical disk is
    complete.  In other words, whether or not it has all of its members
    and its members' members etc...

Arguments:

    LogicalDiskId   - Supplies the logical disk id.

Return Value:

    FALSE   - This logical disk is not complete.

    TRUE    - This logical disk is complete.

--*/

{
    USHORT              numMembers, i;
    FT_LOGICAL_DISK_ID  memberDiskId;

    numMembers = QueryNumberOfMembersInLogicalDisk(LogicalDiskId);
    for (i = 0; i < numMembers; i++) {
        memberDiskId = QueryMemberLogicalDiskId(LogicalDiskId, i);
        if (!memberDiskId || !IsLogicalDiskComplete(memberDiskId)) {
            return FALSE;
        }
    }

    return TRUE;
}

UCHAR
FT_LOGICAL_DISK_INFORMATION_SET::QueryDriveLetter(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine returns the drive letter for the given logical disk.

Arguments:

    LogicalDiskId   - Supplies the logical disk id.

Return Value:

    The drive letter or 0.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    p = GetLogicalDiskDescription(LogicalDiskId, 0);
    if (!p) {
        return 0;
    }

    return p->DriveLetter;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION_SET::SetDriveLetter(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  UCHAR               DriveLetter
    )

/*++

Routine Description:

    This routine sets the drive letter for the given logical disk.

Arguments:

    LogicalDiskId   - Supplies the logical disk id.

    DriveLetter     - Supplies the drive letter.

Return Value:

    NTSTATUS

--*/

{
    ULONG                           i;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    p;
    BOOLEAN                         found;

    found = FALSE;
    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
             p = diskInfo->GetNextLogicalDiskDescription(p)) {

            if (p->LogicalDiskId == LogicalDiskId) {
                p->DriveLetter = DriveLetter;
                diskInfo->Write();
                found = TRUE;
            }
        }
    }

    return found ? STATUS_SUCCESS : STATUS_OBJECT_NAME_NOT_FOUND;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION_SET::WriteStateInformation(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  PVOID               LogicalDiskState,
    IN  USHORT              LogicalDiskStateSize
    )

/*++

Routine Description:

    This routine writes out the given state information to all on
    disk instances of the given logical disk.  If one of the instances
    fails to commit to disk, this routine will continue to write out
    all that it can and then return the error that it received.

Arguments:

    LogicalDiskId           - Supplies the logical disk id.

    LogicalDiskState        - Supplies the logical disk state to write.

    LogicalDiskStateSize    - Supplies the number of bytes in the given
                                logical disk state.

Return Value:

    NTSTATUS

--*/

{
    ULONG                           i;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
             p = diskInfo->GetNextLogicalDiskDescription(p)) {

            if (p->LogicalDiskId == LogicalDiskId) {
                ASSERT(p->LogicalDiskType != FtPartition);
                ASSERT(p->u.Other.ByteOffsetToStateInformation);

                RtlMoveMemory((PCHAR) p +
                              p->u.Other.ByteOffsetToStateInformation,
                              LogicalDiskState,
                              LogicalDiskStateSize);

                diskInfo->Write();
            }
        }
    }

    FtpCopyStateToRegistry(LogicalDiskId, LogicalDiskState,
                           LogicalDiskStateSize);

    return STATUS_SUCCESS;
}

FT_LOGICAL_DISK_ID
GenerateNewLogicalDiskId(
    )

/*++

Routine Description:

    This routine computes a new, random, unique, logical disk id for
    use to identify a new logical disk.

Arguments:

    None.

Return Value:

    A new logical disk id.

--*/

{
    NTSTATUS                status;
    UUID                    uuid;
    PUCHAR                  p;
    FT_LOGICAL_DISK_ID      diskId;
    static LARGE_INTEGER    lastSystemTime;
    LARGE_INTEGER           x;
    ULONG                   i;

    status = ExUuidCreate(&uuid);
    if (NT_SUCCESS(status)) {

        p = (PUCHAR) &uuid;
        diskId = (*((PFT_LOGICAL_DISK_ID) p)) ^
                 (*((PFT_LOGICAL_DISK_ID) (p + sizeof(FT_LOGICAL_DISK_ID))));

        return diskId;
    }

    x.QuadPart = 0;
    while (x.QuadPart == 0) {
        for (;;) {
            KeQuerySystemTime(&x);
            if (x.QuadPart != lastSystemTime.QuadPart) {
                break;
            }
        }
        lastSystemTime.QuadPart = x.QuadPart;
        p = (PUCHAR) &x.QuadPart;
        for (i = 0; i < sizeof(LONGLONG); i++) {
            x.QuadPart += *p++;
            x.QuadPart = (x.QuadPart >> 2) + (x.QuadPart << 62);
        }
    }

    return x.QuadPart;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION_SET::CreatePartitionLogicalDisk(
    IN  ULONG               DiskNumber,
    IN  LONGLONG            PartitionOffset,
    IN  LONGLONG            PartitionSize,
    OUT PFT_LOGICAL_DISK_ID NewLogicalDiskId
    )

/*++

Routine Description:

    This routine takes a DOS partition and assigns it a logical disk id.

Arguments:

    DiskNumber          - Supplies the disk number where the partition
                                resides.

    PartitionOffset     - Supplies the partition offset.

    PartitionSize       - Supplies the partition size.

    NewLogicalDiskId    - Returns the logical disk id.

Return Value:

    NTSTATUS

--*/

{
    ULONG                           i;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    newLogicalDiskDescription, p;
    NTSTATUS                        status;

    // Find the disk information for the given device object.

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        if (diskInfo->QueryDiskNumber() == DiskNumber) {
            break;
        }
    }

    if (i == _numberOfLogicalDiskInformations) {
        return STATUS_INVALID_PARAMETER;
    }


    // Generate a new logical disk id for this one.

    *NewLogicalDiskId = GenerateNewLogicalDiskId();


    // Allocate and set up a new logical disk description.

    newLogicalDiskDescription = (PFT_LOGICAL_DISK_DESCRIPTION)
            ExAllocatePool(PagedPool, sizeof(FT_LOGICAL_DISK_DESCRIPTION));
    if (!newLogicalDiskDescription) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    newLogicalDiskDescription->DiskDescriptionSize =
            sizeof(FT_LOGICAL_DISK_DESCRIPTION);
    newLogicalDiskDescription->DriveLetter = 0;
    newLogicalDiskDescription->Reserved = 0;
    newLogicalDiskDescription->LogicalDiskType = FtPartition;
    newLogicalDiskDescription->LogicalDiskId = *NewLogicalDiskId;
    newLogicalDiskDescription->u.FtPartition.ByteOffset = PartitionOffset;
    newLogicalDiskDescription->u.FtPartition.PartitionSize = PartitionSize;


    // Check for enough free disk space.

    if (newLogicalDiskDescription->DiskDescriptionSize >
        diskInfo->QueryDiskDescriptionFreeSpace()) {

        FtpLogError(diskInfo->GetRootExtension(),
                    diskInfo->QueryDiskNumber(),
                    FT_NOT_ENOUGH_ON_DISK_SPACE, STATUS_DISK_FULL, 0);

        ExFreePool(newLogicalDiskDescription);
        return STATUS_DISK_FULL;
    }


    // Now allocate the memory that we need to store this new logical
    // disk.

    if (!ReallocRootLogicalDiskIds(_numberOfRootLogicalDisksIds + 1)) {
        ExFreePool(newLogicalDiskDescription);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    // Write out the disk description.

    p = diskInfo->AddLogicalDiskDescription(newLogicalDiskDescription);
    ASSERT(p);

    ExFreePool(newLogicalDiskDescription);

    status = diskInfo->Write();
    if (!NT_SUCCESS(status)) {
        BreakLogicalDisk(*NewLogicalDiskId);
        return status;
    }


    // Fix up the list of root entries.

    RecomputeArrayOfRootLogicalDiskIds();

    return status;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION_SET::AddNewLogicalDisk(
    IN  FT_LOGICAL_DISK_TYPE    NewLogicalDiskType,
    IN  USHORT                  NumberOfMembers,
    IN  PFT_LOGICAL_DISK_ID     ArrayOfMembers,
    IN  USHORT                  ConfigurationInformationSize,
    IN  PVOID                   ConfigurationInformation,
    IN  USHORT                  StateInformationSize,
    IN  PVOID                   StateInformation,
    OUT PFT_LOGICAL_DISK_ID     NewLogicalDiskId
    )

/*++

Routine Description:

    This routine adds the given logical disk to the system.

Arguments:

    NewLogicalDiskType              - Supplies the logical disk type of the
                                        new logical disk.

    NumberOfMembers                 - Supplies the number of members contained
                                        in the new logical disk.

    ArrayOfMembers                  - Supplies the array of members.

    ConfigurationInformationSize    - Supplies the configuration information
                                        size.

    ConfigurationInformation        - Supplies the configuration information.

    StateInformationSize            - Supplies the state information size.

    StateInformation                - Supplies the state information.

    NewLogicalDiskId                - Returns the new logical disk id.

Return Value:

    NTSTATUS

--*/

{
    ULONG                                   i, j;
    USHORT                                  size;
    UCHAR                                   driveLetter;
    PFT_LOGICAL_DISK_DESCRIPTION            newLogicalDiskDescription;
    PFT_LOGICAL_DISK_INFORMATION            diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION            p, q;
    NTSTATUS                                status;
    ULONG                                   numInstancesInThisInfo;
    WCHAR                                   name[3];

    if (NewLogicalDiskType == FtPartition) {
        return STATUS_INVALID_PARAMETER;
    }


    // First make sure that the members are all root logical disks and
    // are complete.

    for (i = 0; i < NumberOfMembers; i++) {
        if (!ArrayOfMembers[i]) {
            continue;
        }

        for (j = 0; j < _numberOfRootLogicalDisksIds; j++) {
            if (ArrayOfMembers[i] == _arrayOfRootLogicalDiskIds[j]) {
                break;
            }
        }

        if (j == _numberOfRootLogicalDisksIds) {
            return STATUS_INVALID_PARAMETER;
        }

        if (!IsLogicalDiskComplete(ArrayOfMembers[i])) {
            return STATUS_INVALID_PARAMETER;
        }
    }


    // In the mirror, volume set, and redist cases.  Save the
    // drive letter of the first member.

    if (NewLogicalDiskType == FtVolumeSet ||
        NewLogicalDiskType == FtMirrorSet ||
        NewLogicalDiskType == FtRedistribution) {

        driveLetter = QueryDriveLetter(ArrayOfMembers[0]);

    } else {
        driveLetter = 0;
    }

    for (i = 0; i < NumberOfMembers; i++) {
        SetDriveLetter(ArrayOfMembers[i], 0);
    }

    *NewLogicalDiskId = GenerateNewLogicalDiskId();


    // Construct the disk description record.

    size = sizeof(FT_LOGICAL_DISK_DESCRIPTION) +
           ConfigurationInformationSize + StateInformationSize;

    size = (size + FILE_QUAD_ALIGNMENT)&(~FILE_QUAD_ALIGNMENT);

    newLogicalDiskDescription = (PFT_LOGICAL_DISK_DESCRIPTION)
                                ExAllocatePool(PagedPool, size);
    if (!newLogicalDiskDescription) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    newLogicalDiskDescription->DiskDescriptionSize = size;
    newLogicalDiskDescription->DriveLetter = driveLetter;
    newLogicalDiskDescription->Reserved = 0;
    newLogicalDiskDescription->LogicalDiskType = NewLogicalDiskType;
    newLogicalDiskDescription->LogicalDiskId = *NewLogicalDiskId;
    newLogicalDiskDescription->u.Other.ThisMemberLogicalDiskId = 0;
    newLogicalDiskDescription->u.Other.ThisMemberNumber = 0;
    newLogicalDiskDescription->u.Other.NumberOfMembers = NumberOfMembers;
    if (ConfigurationInformationSize) {
        newLogicalDiskDescription->u.Other.
                ByteOffsetToConfigurationInformation =
                sizeof(FT_LOGICAL_DISK_DESCRIPTION);
        RtlMoveMemory((PCHAR) newLogicalDiskDescription +
                      newLogicalDiskDescription->u.Other.
                      ByteOffsetToConfigurationInformation,
                      ConfigurationInformation,
                      ConfigurationInformationSize);
    } else {
        newLogicalDiskDescription->u.Other.
                ByteOffsetToConfigurationInformation = 0;
    }
    if (StateInformationSize) {
        newLogicalDiskDescription->u.Other.ByteOffsetToStateInformation =
                sizeof(FT_LOGICAL_DISK_DESCRIPTION) +
                ConfigurationInformationSize;
        RtlMoveMemory((PCHAR) newLogicalDiskDescription +
                      newLogicalDiskDescription->u.Other.
                      ByteOffsetToStateInformation,
                      StateInformation,
                      StateInformationSize);
    } else {
        newLogicalDiskDescription->u.Other.ByteOffsetToStateInformation = 0;
    }


    // Figure out how many instances we're going to need and check to make
    // sure that there is enough disk space for all of the instances.

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];

        numInstancesInThisInfo = 0;
        for (j = 0; j < NumberOfMembers; j++) {
            for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
                 p = diskInfo->GetNextLogicalDiskDescription(p)) {

                if (p->LogicalDiskId == ArrayOfMembers[j]) {
                    break;
                }
            }

            if (p) {
                numInstancesInThisInfo++;
            }
        }

        if (numInstancesInThisInfo) {
            if (numInstancesInThisInfo*
                newLogicalDiskDescription->DiskDescriptionSize >
                diskInfo->QueryDiskDescriptionFreeSpace()) {

                FtpLogError(diskInfo->GetRootExtension(),
                            diskInfo->QueryDiskNumber(),
                            FT_NOT_ENOUGH_ON_DISK_SPACE, STATUS_DISK_FULL, 0);

                ExFreePool(newLogicalDiskDescription);
                return STATUS_DISK_FULL;
            }
        }
    }


    // Now allocate the memory that we need to store this new logical
    // disk.

    if (!ReallocRootLogicalDiskIds(_numberOfRootLogicalDisksIds + 1)) {
        ExFreePool(newLogicalDiskDescription);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    // Now that we have the memory and disk space we can proceed with
    // the changes.  First fix up the logical disk entries and write out
    // the structures to disk.

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];

        for (j = 0; j < NumberOfMembers; j++) {
            for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
                 p = diskInfo->GetNextLogicalDiskDescription(p)) {

                if (p->LogicalDiskId == ArrayOfMembers[j]) {
                    break;
                }
            }

            if (p) {
                newLogicalDiskDescription->u.Other.
                        ThisMemberLogicalDiskId = ArrayOfMembers[j];
                newLogicalDiskDescription->u.Other.ThisMemberNumber =
                    (USHORT) j;

                q = diskInfo->AddLogicalDiskDescription(
                        newLogicalDiskDescription);
                ASSERT(q);

                status = diskInfo->Write();
                if (!NT_SUCCESS(status)) {
                    BreakLogicalDisk(*NewLogicalDiskId);
                    ExFreePool(newLogicalDiskDescription);
                    return status;
                }
            }
        }
    }

    ExFreePool(newLogicalDiskDescription);


    // Fix up the list of root entries.

    RecomputeArrayOfRootLogicalDiskIds();

    return STATUS_SUCCESS;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION_SET::BreakLogicalDisk(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine breaks the given logical disk into its members.

Arguments:

    LogicalDiskId   - Supplies the root logical disk id to break.

Return Value:

    NTSTATUS

--*/

{
    ULONG                                   i, j, numMembers;
    PFT_LOGICAL_DISK_DESCRIPTION            p;
    FT_LOGICAL_DISK_TYPE                    diskType;
    UCHAR                                   driveLetter;
    PFT_MIRROR_AND_SWP_STATE_INFORMATION    state;
    FT_LOGICAL_DISK_ID                      mainMember;
    NTSTATUS                                status;
    PFT_LOGICAL_DISK_INFORMATION            diskInfo;

    // First make sure that the given logical disk id is a root.

    for (i = 0; i < _numberOfRootLogicalDisksIds; i++) {
        if (LogicalDiskId == _arrayOfRootLogicalDiskIds[i]) {
            break;
        }
    }

    if (i == _numberOfRootLogicalDisksIds) {
        return STATUS_INVALID_PARAMETER;
    }


    // Allocate the memory needed to grow the list of roots.

    p = GetLogicalDiskDescription(LogicalDiskId, 0);
    ASSERT(p);

    diskType = p->LogicalDiskType;
    driveLetter = p->DriveLetter;
    if (diskType == FtPartition) {
        numMembers = 0;
    } else {
        numMembers = p->u.Other.NumberOfMembers;
    }

    if (!ReallocRootLogicalDiskIds(_numberOfRootLogicalDisksIds + numMembers)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    DeleteFtRegistryInfo(LogicalDiskId);

    if (diskType == FtMirrorSet) {

        state = (PFT_MIRROR_AND_SWP_STATE_INFORMATION)
                GetStateInformation(LogicalDiskId);
        ASSERT(state);

        if (state->UnhealthyMemberState == FtMemberHealthy ||
            state->UnhealthyMemberNumber == 1) {

            mainMember = QueryMemberLogicalDiskId(LogicalDiskId, 0);
        } else {
            mainMember = QueryMemberLogicalDiskId(LogicalDiskId, 1);
        }

        SetDriveLetter(mainMember, driveLetter);
    }

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];

        p = diskInfo->GetFirstLogicalDiskDescription();
        while (p) {
            if (p->LogicalDiskId == LogicalDiskId) {

                diskInfo->DeleteLogicalDiskDescription(p);
                if (!p->DiskDescriptionSize) {
                    p = NULL;
                }
                diskInfo->Write();

            } else {
                p = diskInfo->GetNextLogicalDiskDescription(p);
            }
        }
    }

    FtpDeleteStateInRegistry(LogicalDiskId);


    // Recompute the list of roots.

    RecomputeArrayOfRootLogicalDiskIds();

    return STATUS_SUCCESS;
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION_SET::ReplaceLogicalDiskMember(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN  USHORT              MemberNumberToReplace,
    IN  FT_LOGICAL_DISK_ID  NewMemberLogicalDiskId,
    OUT PFT_LOGICAL_DISK_ID NewLogicalDiskId
    )

/*++

Routine Description:

    This routine replaces the given member with the new given member.

Arguments:

    LogicalDiskId           - Supplies the logical disk whose member we are
                                going to replace.

    MemberNumberToReplace   - Supplies the member number to replace.

    NewMemberLogicalDiskId  - Supplies the new member.

    NewLogicalDiskId        - Returns the new logical disk id for the set
                                containing the new member.

Return Value:

    NTSTATUS

--*/

{
    ULONG                               i, j, numInstances, n;
    PFT_LOGICAL_DISK_ID                 oldLogicalDiskIds;
    PFT_LOGICAL_DISK_ID                 newLogicalDiskIds;
    PFT_LOGICAL_DISK_DESCRIPTION        p, q, newDiskDescription;
    PFT_LOGICAL_DISK_INFORMATION        diskInfo;
    NTSTATUS                            status;
    BOOLEAN                             wroteLog;
    FT_LOGICAL_DISK_ID                  replacedMemberDiskId, child;
    UCHAR                               state[100];
    USHORT                              stateSize;


    // Make sure that the replacement is a root and is complete.

    for (i = 0; i < _numberOfRootLogicalDisksIds; i++) {
        if (NewMemberLogicalDiskId == _arrayOfRootLogicalDiskIds[i]) {
            break;
        }
    }

    if (i == _numberOfRootLogicalDisksIds ||
        !IsLogicalDiskComplete(NewMemberLogicalDiskId)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (!ReallocRootLogicalDiskIds(_numberOfRootLogicalDisksIds + 1)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    DeleteFtRegistryInfo(LogicalDiskId);


    // Figure out 'n' where n is how many new logical disk ids we need.

    if (!ComputeNewParentLogicalDiskIds(LogicalDiskId, &n,
                                        &oldLogicalDiskIds,
                                        &newLogicalDiskIds)) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    // Copy back the new logical disk id.

    *NewLogicalDiskId = newLogicalDiskIds[0];


    // Figure out the logical disk id of the member to replace.

    replacedMemberDiskId = QueryMemberLogicalDiskId(LogicalDiskId,
                                                    MemberNumberToReplace);


    // Build up the new member into a new tree that will eventually
    // replace the old tree of which this logical disk is a member.

    for (i = 0; i < n; i++) {

        if (i == 0) {
            p = GetLogicalDiskDescription(oldLogicalDiskIds[i], 0);
        } else {
            p = GetParentLogicalDiskDescription(oldLogicalDiskIds[i - 1]);
        }
        if (!p || p->LogicalDiskType == FtPartition) {
            ExFreePool(oldLogicalDiskIds);
            ExFreePool(newLogicalDiskIds);
            return STATUS_INVALID_PARAMETER;
        }

        newDiskDescription = (PFT_LOGICAL_DISK_DESCRIPTION)
                             ExAllocatePool(PagedPool, p->DiskDescriptionSize);
        if (!newDiskDescription) {
            ExFreePool(oldLogicalDiskIds);
            ExFreePool(newLogicalDiskIds);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlMoveMemory(newDiskDescription, p, p->DiskDescriptionSize);
        newDiskDescription->LogicalDiskId = newLogicalDiskIds[i];
        if (i == 0) {
            newDiskDescription->u.Other.ThisMemberLogicalDiskId =
                    NewMemberLogicalDiskId;
            newDiskDescription->u.Other.ThisMemberNumber =
                    MemberNumberToReplace;
        } else {
            newDiskDescription->u.Other.ThisMemberLogicalDiskId =
                    newLogicalDiskIds[i - 1];
        }

        for (j = 0; j < _numberOfLogicalDiskInformations; j++) {

            diskInfo = _arrayOfLogicalDiskInformations[j];

            for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
                 p = diskInfo->GetNextLogicalDiskDescription(p)) {

                if (p->LogicalDiskId !=
                    newDiskDescription->u.Other.ThisMemberLogicalDiskId) {

                    continue;
                }

                if (!diskInfo->AddLogicalDiskDescription(newDiskDescription)) {

                    FtpLogError(diskInfo->GetRootExtension(),
                                diskInfo->QueryDiskNumber(),
                                FT_NOT_ENOUGH_ON_DISK_SPACE, STATUS_DISK_FULL,
                                0);

                    ExFreePool(newDiskDescription);
                    ExFreePool(oldLogicalDiskIds);
                    ExFreePool(newLogicalDiskIds);
                    return STATUS_DISK_FULL;
                }

                status = diskInfo->Write();
                if (!NT_SUCCESS(status)) {
                    ExFreePool(newDiskDescription);
                    ExFreePool(oldLogicalDiskIds);
                    ExFreePool(newLogicalDiskIds);
                    return status;
                }
                break;
            }
        }

        ExFreePool(newDiskDescription);
    }


    // Substitute new logical disk ids for old ones, logging the operation
    // for a safe backout in the event of a crash.

    status = STATUS_SUCCESS;
    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        wroteLog = FALSE;
        for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
             p = diskInfo->GetNextLogicalDiskDescription(p)) {

            if (p->LogicalDiskType != FtPartition) {
                continue;
            }

            child = p->LogicalDiskId;

            for (q = diskInfo->GetNextLogicalDiskDescription(p); q;
                 q = diskInfo->GetNextLogicalDiskDescription(q)) {

                if (q->LogicalDiskType == FtPartition ||
                    q->u.Other.ThisMemberLogicalDiskId != child) {

                    continue;
                }

                if (q->LogicalDiskId == LogicalDiskId &&
                    q->u.Other.ThisMemberNumber == MemberNumberToReplace) {

                    break;
                }

                child = q->LogicalDiskId;
            }

            if (q) {
                continue;
            }

            child = p->LogicalDiskId;

            for (q = diskInfo->GetNextLogicalDiskDescription(p); q;
                 q = diskInfo->GetNextLogicalDiskDescription(q)) {

                if (q->LogicalDiskType == FtPartition ||
                    q->u.Other.ThisMemberLogicalDiskId != child) {

                    continue;
                }

                child = q->LogicalDiskId;

                for (j = 0; j < n; j++) {
                    if (q->LogicalDiskId == oldLogicalDiskIds[j]) {
                        if (!wroteLog) {
                            diskInfo->AddReplaceLog(replacedMemberDiskId,
                                                    NewMemberLogicalDiskId,
                                                    n, oldLogicalDiskIds,
                                                    newLogicalDiskIds);
                            wroteLog = TRUE;
                        }
                        q->LogicalDiskId = newLogicalDiskIds[j];
                    } else if (q->u.Other.ThisMemberLogicalDiskId ==
                               oldLogicalDiskIds[j]) {
                        if (!wroteLog) {
                            diskInfo->AddReplaceLog(replacedMemberDiskId,
                                                    NewMemberLogicalDiskId,
                                                    n, oldLogicalDiskIds,
                                                    newLogicalDiskIds);
                            wroteLog = TRUE;
                        }
                        q->u.Other.ThisMemberLogicalDiskId =
                                newLogicalDiskIds[j];
                    }
                }
            }
        }

        if (wroteLog) {
            status = diskInfo->Write();
            if (!NT_SUCCESS(status)) {
                break;
            }
        }
    }

    if (NT_SUCCESS(status)) {
        for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
            diskInfo = _arrayOfLogicalDiskInformations[i];
            if (diskInfo->ClearReplaceLog()) {
                diskInfo->Write();
            }
        }

        // Erase all logical disk descriptions that contain the old
        // logical disk ids.

        for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
            diskInfo = _arrayOfLogicalDiskInformations[i];

            for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
                 p = diskInfo->GetNextLogicalDiskDescription(p)) {

                for (j = 0; j < n; j++) {
                    if (p->LogicalDiskId == oldLogicalDiskIds[j]) {
                        diskInfo->DeleteLogicalDiskDescription(p);
                        diskInfo->Write();
                    }
                }
            }
        }

        for (i = 0; i < n; i++) {
            if (FtpQueryStateFromRegistry(oldLogicalDiskIds[i], state, 100,
                                          &stateSize)) {

                FtpDeleteStateInRegistry(oldLogicalDiskIds[i]);
                FtpCopyStateToRegistry(newLogicalDiskIds[i], state, stateSize);
            }
        }

    } else {
        for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
            diskInfo = _arrayOfLogicalDiskInformations[i];
            if (diskInfo->BackOutReplaceOperation()) {
                diskInfo->Write();
            }
        }

        RecomputeArrayOfRootLogicalDiskIds();
        for (i = n; i > 0; i--) {
            BreakLogicalDisk(newLogicalDiskIds[i - 1]);
        }
    }

    ExFreePool(oldLogicalDiskIds);
    ExFreePool(newLogicalDiskIds);


    // Recompute list of root entries.

    RecomputeArrayOfRootLogicalDiskIds();

    return status;
}

FT_LOGICAL_DISK_TYPE
TranslateFtDiskType(
    IN  FT_TYPE FtType
    )

{
    switch (FtType) {
        case Mirror:
            return FtMirrorSet;

        case Stripe:
            return FtStripeSet;

        case StripeWithParity:
            return FtStripeSetWithParity;

        case VolumeSet:
            return FtVolumeSet;

    }

    return FtPartition;
}

PFT_DESCRIPTION
GetFtDescription(
    IN  PDISK_CONFIG_HEADER Registry,
    IN  PDISK_PARTITION     DiskPartition
    )

{
    ULONG                   diskPartitionOffset;
    PFT_REGISTRY            ftRegistry;
    PFT_DESCRIPTION         ftDescription;
    USHORT                  i, j;
    PFT_MEMBER_DESCRIPTION  ftMember;

    diskPartitionOffset = (ULONG) ((PUCHAR) DiskPartition - (PUCHAR) Registry);
    ftRegistry = (PFT_REGISTRY) ((PUCHAR) Registry +
                                 Registry->FtInformationOffset);
    ftDescription = &ftRegistry->FtDescription[0];
    for (i = 0; i < ftRegistry->NumberOfComponents; i++) {
        for (j = 0; j < ftDescription->NumberOfMembers; j++) {
            ftMember = &ftDescription->FtMemberDescription[j];
            if (ftMember->OffsetToPartitionInfo == diskPartitionOffset) {
                return ftDescription;
            }
        }
        ftDescription = (PFT_DESCRIPTION) &ftDescription->FtMemberDescription[
                        ftDescription->NumberOfMembers];
    }

    return NULL;
}

USHORT
GetRegistryNumberOfMembers(
    IN  PDISK_CONFIG_HEADER Registry,
    IN  PDISK_PARTITION     DiskPartition
    )

{
    PFT_DESCRIPTION ftDescription;

    ftDescription = GetFtDescription(Registry, DiskPartition);
    if (!ftDescription) {
        return 0;
    }

    return ftDescription->NumberOfMembers;
}

ULONG
FT_LOGICAL_DISK_INFORMATION_SET::DiskNumberFromSignature(
    IN  ULONG   Signature
    )

{
    ULONG                           i;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        if (Signature == FtpQueryDiskSignature(diskInfo->GetWholeDiskPdo())) {
            return diskInfo->QueryDiskNumber();
        }
    }

    return 0xFFFFFFFF;
}

VOID
DeleteFtRegistryInformation(
    IN  PDISK_CONFIG_HEADER Registry,
    IN  PDISK_PARTITION     DiskPartition
    )

{
    PFT_DESCRIPTION         ftDescription, next;
    USHORT                  i;
    PFT_MEMBER_DESCRIPTION  ftMember;
    PDISK_PARTITION         diskPartition;
    PFT_REGISTRY            ftRegistry;

    ftDescription = GetFtDescription(Registry, DiskPartition);
    if (!ftDescription) {
        return;
    }

    for (i = 0; i < ftDescription->NumberOfMembers; i++) {
        ftMember = &ftDescription->FtMemberDescription[i];
        diskPartition = (PDISK_PARTITION) ((PUCHAR) Registry +
                        ftMember->OffsetToPartitionInfo);

        diskPartition->FtType = NotAnFtMember;
        diskPartition->FtState = Healthy;
        RtlZeroMemory(&diskPartition->FtLength.QuadPart, sizeof(LONGLONG));
        diskPartition->FtGroup = (USHORT) -1;
        diskPartition->FtMember = 0;
        diskPartition->DriveLetter = 0;
    }

    next = (PFT_DESCRIPTION) &ftDescription->FtMemberDescription[
           ftDescription->NumberOfMembers];

    ftRegistry = (PFT_REGISTRY) ((PUCHAR) Registry +
                                 Registry->FtInformationOffset);

    RtlMoveMemory(ftDescription, next,
                  (PCHAR) ftRegistry + Registry->FtInformationSize -
                  (PCHAR) next);

    ftRegistry->NumberOfComponents--;
}

VOID
FT_LOGICAL_DISK_INFORMATION_SET::DeleteFtRegistryInfo(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

{
    USHORT                      n, i, j;
    FT_LOGICAL_DISK_ID          diskId;
    LONGLONG                    offset;
    PDEVICE_OBJECT              wholeDisk;
    ULONG                       diskNumber, signature;
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    ULONG                       registrySize;
    NTSTATUS                    status;
    PDISK_CONFIG_HEADER         registry;
    PFT_REGISTRY                ftRegistry;
    PFT_DESCRIPTION             ftDescription;
    PFT_MEMBER_DESCRIPTION      ftMember;
    PDISK_PARTITION             diskPartition;
    LONGLONG                    tmp;

    n = QueryNumberOfMembersInLogicalDisk(LogicalDiskId);
    if (!n) {
        return;
    }

    for (i = 0; i < n; i++) {
        diskId = QueryMemberLogicalDiskId(LogicalDiskId, i);
        if (diskId) {
            break;
        }
    }

    if (!diskId) {
        return;
    }

    if (!QueryFtPartitionInformation(diskId, &offset, &wholeDisk, NULL, NULL,
                                     NULL)) {

        return;
    }

    signature = FtpQueryDiskSignature(wholeDisk);
    if (!signature) {
        return;
    }

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = FtpDiskRegistryQueryRoutine;
    queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = L"Information";
    queryTable[0].EntryContext = &registrySize;

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, DISK_REGISTRY_KEY_W,
                                    queryTable, &registry, NULL);

    if (!NT_SUCCESS(status)) {
        return;
    }

    if (!registry->FtInformationSize) {
        ExFreePool(registry);
        return;
    }

    ftRegistry = (PFT_REGISTRY) ((PUCHAR) registry +
                                 registry->FtInformationOffset);
    ftDescription = &ftRegistry->FtDescription[0];
    for (i = 0; i < ftRegistry->NumberOfComponents; i++) {
        for (j = 0; j < ftDescription->NumberOfMembers; j++) {
            ftMember = &ftDescription->FtMemberDescription[j];
            diskPartition = (PDISK_PARTITION) ((PUCHAR) registry +
                            ftMember->OffsetToPartitionInfo);

            RtlCopyMemory(&tmp, &diskPartition->StartingOffset.QuadPart,
                          sizeof(LONGLONG));
            if (ftMember->Signature == signature && tmp == offset) {
                DeleteFtRegistryInformation(registry, diskPartition);
                goto Finish;
            }
        }
        ftDescription = (PFT_DESCRIPTION) &ftDescription->FtMemberDescription[
                        ftDescription->NumberOfMembers];
    }

Finish:
    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, DISK_REGISTRY_KEY_W,
                          L"Information", REG_BINARY, registry,
                          registrySize);

    ExFreePool(registry);
}

PFT_LOGICAL_DISK_INFORMATION
FT_LOGICAL_DISK_INFORMATION_SET::FindLogicalDiskInformation(
    IN  PDEVICE_OBJECT  WholeDiskPdo
    )

{
    ULONG   i;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        if (_arrayOfLogicalDiskInformations[i]->GetWholeDiskPdo() ==
            WholeDiskPdo) {

            return _arrayOfLogicalDiskInformations[i];
        }
    }

    return NULL;
}

LONGLONG
GetMemberSize(
    IN  PDISK_CONFIG_HEADER Registry,
    IN  PDISK_PARTITION     DiskPartition
    )

{
    PFT_DESCRIPTION         ftDescription;
    LONGLONG                memberSize;
    USHORT                  i;
    PFT_MEMBER_DESCRIPTION  ftMember;
    PDISK_PARTITION         diskPartition;
    LONGLONG                tmp;

    ftDescription = GetFtDescription(Registry, DiskPartition);
    if (!ftDescription) {
        return 0;
    }

    memberSize = 0;

    for (i = 0; i < ftDescription->NumberOfMembers; i++) {
        ftMember = &ftDescription->FtMemberDescription[i];
        diskPartition = (PDISK_PARTITION) ((PUCHAR) Registry +
                        ftMember->OffsetToPartitionInfo);

        RtlCopyMemory(&tmp, &diskPartition->Length.QuadPart, sizeof(LONGLONG));
        if (!memberSize || memberSize > tmp) {
            RtlCopyMemory(&memberSize, &diskPartition->Length.QuadPart,
                          sizeof(LONGLONG));
        }
    }

    return memberSize;
}

VOID
SetStateInfo(
    IN  PDISK_CONFIG_HEADER                     Registry,
    IN  PDISK_PARTITION                         DiskPartition,
    OUT PFT_MIRROR_AND_SWP_STATE_INFORMATION    State
    )

{
    PFT_DESCRIPTION         ftDescription;
    USHORT                  i;
    PFT_MEMBER_DESCRIPTION  ftMember;
    PDISK_PARTITION         diskPartition;

    RtlZeroMemory(State, sizeof(FT_MIRROR_AND_SWP_STATE_INFORMATION));
    if (Registry->DirtyShutdown) {
        State->IsDirty = TRUE;
    }

    ftDescription = GetFtDescription(Registry, DiskPartition);
    if (!ftDescription) {
        return;
    }

    for (i = 0; i < ftDescription->NumberOfMembers; i++) {
        ftMember = &ftDescription->FtMemberDescription[i];
        diskPartition = (PDISK_PARTITION) ((PUCHAR) Registry +
                        ftMember->OffsetToPartitionInfo);

        switch (diskPartition->FtState) {
            case Orphaned:
                State->UnhealthyMemberNumber = i;
                State->UnhealthyMemberState = FtMemberOrphaned;
                break;

            case Regenerating:
                State->UnhealthyMemberNumber = i;
                State->UnhealthyMemberState = FtMemberRegenerating;
                break;

            case Initializing:
                State->IsInitializing = TRUE;
                break;

        }
    }
}

BOOLEAN
FT_LOGICAL_DISK_INFORMATION_SET::GetDiskDescription(
    IN  PDISK_CONFIG_HEADER             Registry,
    IN  PDISK_PARTITION                 DiskPartition,
    IN  PFT_LOGICAL_DISK_DESCRIPTION    CheckDiskDescription,
    OUT PFT_LOGICAL_DISK_DESCRIPTION*   DiskDescription
    )

{
    PFT_DESCRIPTION                 ftDescription;
    USHORT                          i;
    PFT_MEMBER_DESCRIPTION          ftMember;
    PDISK_PARTITION                 diskPartition;
    FT_LOGICAL_DISK_ID              partitionDiskId;
    PFT_LOGICAL_DISK_DESCRIPTION    diskDesc;
    LONGLONG                        tmp;

    ftDescription = GetFtDescription(Registry, DiskPartition);
    if (!ftDescription) {
        return FALSE;
    }

    for (i = 0; i < ftDescription->NumberOfMembers; i++) {
        ftMember = &ftDescription->FtMemberDescription[i];
        diskPartition = (PDISK_PARTITION) ((PUCHAR) Registry +
                        ftMember->OffsetToPartitionInfo);

        RtlCopyMemory(&tmp, &diskPartition->StartingOffset.QuadPart,
                      sizeof(LONGLONG));
        partitionDiskId = QueryPartitionLogicalDiskId(
                          DiskNumberFromSignature(ftMember->Signature), tmp);
        if (!partitionDiskId) {
            continue;
        }

        diskDesc = GetParentLogicalDiskDescription(partitionDiskId);
        if (!diskDesc) {
            continue;
        }

        if (GetParentLogicalDiskDescription(diskDesc->LogicalDiskId)) {
            continue;
        }

        if (diskDesc != CheckDiskDescription) {
            *DiskDescription = diskDesc;
            return TRUE;
        }
    }

    return FALSE;
}

UCHAR
GetDriveLetter(
    IN  PDISK_CONFIG_HEADER             Registry,
    IN  PDISK_PARTITION                 DiskPartition
    )

{
    PFT_DESCRIPTION                 ftDescription;
    USHORT                          i;
    PFT_MEMBER_DESCRIPTION          ftMember;
    PDISK_PARTITION                 diskPartition;

    ftDescription = GetFtDescription(Registry, DiskPartition);
    if (!ftDescription) {
        return 0;
    }

    for (i = 0; i < ftDescription->NumberOfMembers; i++) {
        ftMember = &ftDescription->FtMemberDescription[i];
        diskPartition = (PDISK_PARTITION) ((PUCHAR) Registry +
                        ftMember->OffsetToPartitionInfo);

        if (diskPartition->AssignDriveLetter) {
            if (diskPartition->DriveLetter >= 'A' &&
                diskPartition->DriveLetter <= 'Z') {

                return diskPartition->DriveLetter;
            } else if (!diskPartition->DriveLetter) {
                if (IsNEC_98) return 0; //For fresh assigning drive letter on NEC98.
            }
        }
    }

    return 0xFF;
}

PFT_LOGICAL_DISK_DESCRIPTION
CreateDiskDescription(
    IN  PDISK_CONFIG_HEADER             Registry,
    IN  PDISK_PARTITION                 DiskPartition,
    IN  FT_LOGICAL_DISK_ID              PartitionDiskId
    )

{
    FT_LOGICAL_DISK_TYPE                                diskType;
    USHORT                                              configInfoSize, stateInfoSize, size;
    PVOID                                               configInfo, stateInfo;
    FT_STRIPE_SET_CONFIGURATION_INFORMATION             stripeConfig;
    FT_MIRROR_SET_CONFIGURATION_INFORMATION             mirrorConfig;
    FT_MIRROR_AND_SWP_STATE_INFORMATION                 state;
    FT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION swpConfig;
    PFT_LOGICAL_DISK_DESCRIPTION                        diskDesc;

    diskType = TranslateFtDiskType(DiskPartition->FtType);

    switch (diskType) {
        case FtVolumeSet:
            configInfoSize = 0;
            configInfo = NULL;
            stateInfoSize = 0;
            stateInfo = NULL;
            break;

        case FtStripeSet:
            RtlZeroMemory(&stripeConfig, sizeof(stripeConfig));
            stripeConfig.StripeSize = STRIPE_SIZE;
            configInfoSize = sizeof(stripeConfig);
            configInfo = &stripeConfig;
            stateInfoSize = 0;
            stateInfo = NULL;
            break;

        case FtMirrorSet:
            RtlZeroMemory(&mirrorConfig, sizeof(mirrorConfig));
            mirrorConfig.MemberSize = GetMemberSize(Registry, DiskPartition);
            configInfoSize = sizeof(mirrorConfig);
            configInfo = &mirrorConfig;
            stateInfoSize = sizeof(state);
            stateInfo = &state;
            SetStateInfo(Registry, DiskPartition, &state);
            break;

        case FtStripeSetWithParity:
            RtlZeroMemory(&swpConfig, sizeof(swpConfig));
            swpConfig.MemberSize = GetMemberSize(Registry, DiskPartition);
            swpConfig.StripeSize = STRIPE_SIZE;
            configInfoSize = sizeof(swpConfig);
            configInfo = &swpConfig;
            stateInfoSize = sizeof(state);
            stateInfo = &state;
            SetStateInfo(Registry, DiskPartition, &state);
            break;

        default:
            return NULL;

    }

    size = sizeof(FT_LOGICAL_DISK_DESCRIPTION) + configInfoSize +
           stateInfoSize;

    size = (size + FILE_QUAD_ALIGNMENT)&(~FILE_QUAD_ALIGNMENT);

    diskDesc = (PFT_LOGICAL_DISK_DESCRIPTION) ExAllocatePool(PagedPool, size);
    if (!diskDesc) {
        return NULL;
    }

    RtlZeroMemory(diskDesc, size);
    diskDesc->DiskDescriptionSize = size;
    diskDesc->DriveLetter = GetDriveLetter(Registry, DiskPartition);
    diskDesc->LogicalDiskType = diskType;
    diskDesc->LogicalDiskId = GenerateNewLogicalDiskId();
    diskDesc->u.Other.ThisMemberLogicalDiskId = PartitionDiskId;
    diskDesc->u.Other.ThisMemberNumber = DiskPartition->FtMember;
    diskDesc->u.Other.NumberOfMembers = GetRegistryNumberOfMembers(Registry,
                                        DiskPartition);
    if (diskDesc->u.Other.ThisMemberNumber >=
        diskDesc->u.Other.NumberOfMembers) {

        return NULL;
    }

    if (configInfo) {
        diskDesc->u.Other.ByteOffsetToConfigurationInformation =
                sizeof(FT_LOGICAL_DISK_DESCRIPTION);
        RtlMoveMemory((PCHAR) diskDesc +
                      diskDesc->u.Other.ByteOffsetToConfigurationInformation,
                      configInfo, configInfoSize);
    } else {
        diskDesc->u.Other.ByteOffsetToConfigurationInformation = 0;
    }

    if (stateInfo) {
        diskDesc->u.Other.ByteOffsetToStateInformation =
                diskDesc->u.Other.ByteOffsetToConfigurationInformation +
                configInfoSize;
        RtlMoveMemory((PCHAR) diskDesc +
                      diskDesc->u.Other.ByteOffsetToStateInformation,
                      stateInfo, stateInfoSize);
    } else {
        diskDesc->u.Other.ByteOffsetToStateInformation = 0;
    }

    return diskDesc;
}

VOID
SetPartitionType(
    IN  PDEVICE_OBJECT  Partition
    )

{
    KEVENT                      event;
    PIRP                        irp;
    PARTITION_INFORMATION       partInfo;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;
    SET_PARTITION_INFORMATION   setPartInfo;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO,
                                        Partition, NULL, 0, &partInfo,
                                        sizeof(partInfo), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return;
    }

    status = IoCallDriver(Partition, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return;
    }

    setPartInfo.PartitionType = (partInfo.PartitionType | (0x80));

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_SET_PARTITION_INFO,
                                        Partition, &setPartInfo,
                                        sizeof(setPartInfo), NULL, 0, FALSE,
                                        &event, &ioStatus);
    if (!irp) {
        return;
    }

    status = IoCallDriver(Partition, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }
}

VOID
DeleteAncestors(
    IN  PFT_LOGICAL_DISK_INFORMATION    LogicalDiskInformation,
    IN  FT_LOGICAL_DISK_ID              PartitionLogicalDiskId
    )

/*++

Routine Description:

    This routine deletes the disk descriptions which are ancestors
    to the given partition disk description on the given logical
    disk information.

Arguments:

    LogicalDiskInformation  - Supplies the logical disk information.

    PartitionLogicalDiskId  - Supplies the partition logical disk id.

Return Value:

    None.

--*/

{
    PFT_LOGICAL_DISK_INFORMATION    diskInfo = LogicalDiskInformation;
    FT_LOGICAL_DISK_ID              diskId = PartitionLogicalDiskId;
    PFT_LOGICAL_DISK_DESCRIPTION    diskDesc;

    diskDesc = diskInfo->GetFirstLogicalDiskDescription();
    while (diskDesc && diskDesc->DiskDescriptionSize) {

        if (diskDesc->LogicalDiskType == FtPartition ||
            diskDesc->u.Other.ThisMemberLogicalDiskId != diskId) {

            diskDesc = diskInfo->GetNextLogicalDiskDescription(diskDesc);
            continue;
        }

        diskId = diskDesc->LogicalDiskId;
        diskInfo->DeleteLogicalDiskDescription(diskDesc);
    }

    FtpLogError(diskInfo->GetRootExtension(), diskInfo->QueryDiskNumber(),
                FT_STALE_ONDISK, STATUS_SUCCESS, 0);
}

NTSTATUS
FT_LOGICAL_DISK_INFORMATION_SET::MigrateRegistryInformation(
    IN  PDEVICE_OBJECT  Partition,
    IN  ULONG           DiskNumber,
    IN  LONGLONG        Offset
    )

/*++

Routine Description:

    This routine migrates the registry information for the given partition to
    on disk structures.  If all members of the FT set being migrated are on
    disk then the registry information pertaining to the FT set is deleted.

Arguments:

    DiskNumber  - Supplies the disk number of the partition.

    Offset      - Supplies the partition offset.

Return Value:

    NTSTATUS

--*/

{
    ULONG                           i, signature, registrySize, length;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    RTL_QUERY_REGISTRY_TABLE        queryTable[2];
    NTSTATUS                        status;
    PDISK_CONFIG_HEADER             registry;
    PDISK_REGISTRY                  diskRegistry;
    PDISK_PARTITION                 diskPartition;
    FT_LOGICAL_DISK_ID              partitionDiskId;
    PFT_LOGICAL_DISK_DESCRIPTION    diskDesc, newDesc, otherDesc;
    PVOID                           config, newConfig;
    PVOID                           state, newState;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        if (diskInfo->QueryDiskNumber() == DiskNumber) {
            break;
        }
    }

    if (i == _numberOfLogicalDiskInformations) {
        return STATUS_INVALID_PARAMETER;
    }

    signature = FtpQueryDiskSignature(diskInfo->GetWholeDiskPdo());
    if (!signature) {
        return STATUS_SUCCESS;
    }

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].QueryRoutine = FtpDiskRegistryQueryRoutine;
    queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = L"Information";
    queryTable[0].EntryContext = &registrySize;

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, DISK_REGISTRY_KEY_W,
                                    queryTable, &registry, NULL);

    if (!NT_SUCCESS(status)) {
        return STATUS_SUCCESS;
    }

    if (!registry->FtInformationSize) {
        ExFreePool(registry);
        return STATUS_SUCCESS;
    }

    diskRegistry = (PDISK_REGISTRY)
                   ((PUCHAR) registry + registry->DiskInformationOffset);

    diskPartition = FtpFindDiskPartition(diskRegistry, signature, Offset);
    if (!diskPartition || diskPartition->FtType == NotAnFtMember) {
        ExFreePool(registry);
        return STATUS_SUCCESS;
    }

    if (!ReallocRootLogicalDiskIds(_numberOfRootLogicalDisksIds + 1)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    partitionDiskId = QueryPartitionLogicalDiskId(DiskNumber, Offset);
    if (!partitionDiskId) {
        status = CreatePartitionLogicalDisk(DiskNumber, Offset, 0,
                                            &partitionDiskId);
        if (!NT_SUCCESS(status)) {
            ExFreePool(registry);
            return status;
        }

        SetPartitionType(Partition);
    }

    diskDesc = GetParentLogicalDiskDescription(partitionDiskId);
    newDesc = CreateDiskDescription(registry, diskPartition, partitionDiskId);
    if (!newDesc) {
        ExFreePool(registry);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (d